import { ao as cD, w as fD, X as hD, Z as uD, u as vm } from "./apis-0c1c184f.js";
import { aF as dD } from "./dateTimeUtils-a817f99d.js";
import { _ as Tn } from "./extends-98964cd2.js";
import { _ as z } from "./iframe-35b6cbe2.js";
import { M as Ux, r as os } from "./index-363833c6.js";
import { R as C, a as HM, g as Ql, $ as XM, r as w, c as xk } from "./index-7c191284.js";
import {
  C as CP,
  d as GM,
  t as JM,
  v as KM,
  n as Om,
  q as SP,
  a as Vo,
  o as Xx,
  T as YM,
  r as _P,
  c as aD,
  k as as,
  l as bP,
  w as eD,
  j as gm,
  B as iD,
  h as kP,
  _ as kn,
  A as lD,
  i as mm,
  y as nD,
  H as nr,
  G as oD,
  f as ph,
  s as qM,
  z as rD,
  E as sD,
  x as tD,
  p as wP,
  m as yP,
} from "./index-f0f16ed8.js";
import { j as E } from "./jsx-runtime-69eee039.js";
import { a as vP, b as xP } from "./useResultBannerController-cd95b20f.js";
var EP = { exports: {} },
  pD = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  mD = pD,
  gD = mD;
function TP() {}
function PP() {}
PP.resetWarningCache = TP;
var OD = function () {
  function t(r, i, s, o, a, l) {
    if (l !== gD) {
      var c = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((c.name = "Invariant Violation"), c);
    }
  }
  t.isRequired = t;
  function e() {
    return t;
  }
  var n = {
    array: t,
    bigint: t,
    bool: t,
    func: t,
    number: t,
    object: t,
    string: t,
    symbol: t,
    any: t,
    arrayOf: e,
    element: t,
    elementType: t,
    instanceOf: e,
    node: t,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: PP,
    resetWarningCache: TP,
  };
  return (n.PropTypes = n), n;
};
EP.exports = OD();
var vD = EP.exports;
const ae = Ql(vD);
var xD = Object.defineProperty,
  bD = (t, e, n) => (e in t ? xD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  _s = (t, e, n) => (bD(t, typeof e != "symbol" ? e + "" : e, n), n);
let yD = class AP {
    constructor(e = new Map()) {
      this.map = e;
    }
    clone() {
      return new AP(new Map(this.map));
    }
    increment(e) {
      const n = this.map.get(e) ?? 0;
      this.map.set(e, n + 1);
    }
    decrement(e, n) {
      let r = this.map.get(e);
      r !== void 0 && ((r -= 1), this.map.set(e, r), r === 0 && n());
    }
  },
  gf = class {
    constructor() {
      _s(this, "map", new Map());
    }
    getOrCreate(e) {
      let n = this.map.get(e);
      return n === void 0 && ((n = new Set()), this.map.set(e, n)), n;
    }
    get(e) {
      return this.map.get(e);
    }
    use(e, n) {
      const r = this.get(e);
      r !== void 0 && n(r);
    }
    delete(e) {
      return this.map.delete(e);
    }
  };
function Ua(t, e) {
  return e(t), t;
}
function Hx() {}
function K1(t, e) {
  return t === e;
}
const xm = new Map();
let qx = class {
  constructor(e = {}) {
    _s(this, "subscriptions", new gf()),
      _s(this, "singletonSubscriptions", new Map()),
      _s(this, "graph", new gf()),
      _s(this, "state", new Map()),
      _s(this, "distinctNodes", new Map()),
      _s(this, "executionMaps", new Map()),
      _s(this, "definitionRegistry", new Set());
    for (const n of Object.getOwnPropertySymbols(e)) this.state.set(n, e[n]);
  }
  cellInstance(e, n = !0, r = Symbol()) {
    return (
      this.state.has(r) || this.state.set(r, e), n !== !1 && !this.distinctNodes.has(r) && this.distinctNodes.set(r, n === !0 ? K1 : n), r
    );
  }
  signalInstance(e = !0, n = Symbol()) {
    return e !== !1 && this.distinctNodes.set(n, e === !0 ? K1 : e), n;
  }
  sub(e, n) {
    this.register(e);
    const r = this.subscriptions.getOrCreate(e);
    return r.add(n), () => r.delete(n);
  }
  singletonSub(e, n) {
    return (
      this.register(e),
      n === void 0 ? this.singletonSubscriptions.delete(e) : this.singletonSubscriptions.set(e, n),
      () => this.singletonSubscriptions.delete(e)
    );
  }
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  subMultiple(e, n) {
    const r = this.signalInstance();
    return (
      this.connect({
        map:
          (i) =>
          (...s) => {
            i(s);
          },
        sink: r,
        sources: e,
      }),
      this.sub(r, n)
    );
  }
  pubIn(e) {
    var n;
    const r = Reflect.ownKeys(e),
      i = this.getExecutionMap(r),
      s = i.refCount.clone(),
      o = i.participatingNodes.slice(),
      a = new Map(this.state),
      l = (c) => {
        this.graph.use(c, (u) => {
          for (const { sources: h, sink: f } of u)
            h.has(c) &&
              s.decrement(f, () => {
                o.splice(o.indexOf(f), 1), l(f);
              });
        });
      };
    for (;;) {
      const c = o.shift();
      if (c === void 0) break;
      const u = c;
      let h = !1;
      const f = (d) => {
        const p = this.distinctNodes.get(u);
        if (p !== void 0 && p(a.get(u), d)) {
          h = !1;
          return;
        }
        (h = !0), a.set(u, d), this.state.has(u) && this.state.set(u, d);
      };
      if (
        (Object.prototype.hasOwnProperty.call(e, u)
          ? f(e[u])
          : i.projections.use(u, (d) => {
              for (const p of d) {
                const m = [...Array.from(p.sources), ...Array.from(p.pulls)].map((O) => a.get(O));
                p.map(f)(...m);
              }
            }),
        h)
      ) {
        const d = a.get(u);
        this.subscriptions.use(u, (p) => {
          for (const m of p) m(d);
        }),
          (n = this.singletonSubscriptions.get(u)) == null || n(d);
      } else l(u);
    }
  }
  connect({ sources: e, pulls: n = [], map: r, sink: i }) {
    const s = { map: r, pulls: new Set(n), sink: this.register(i), sources: new Set(e) };
    for (const o of [...e, ...n]) this.register(o), this.graph.getOrCreate(o).add(s);
    this.executionMaps.clear();
  }
  pub(e, n) {
    this.pubIn({ [e]: n });
  }
  pipe(e, ...n) {
    return this.combineOperators(...n)(e);
  }
  transformer(...e) {
    return (n) => Ua(this.signalInstance(), (r) => (this.link(this.pipe(r, ...e), n), r));
  }
  link(e, n) {
    this.connect({
      map: (r) => (i) => {
        r(i);
      },
      sink: n,
      sources: [e],
    });
  }
  combine(...e) {
    return Ua(this.signalInstance(), (n) => {
      this.connect({
        map:
          (r) =>
          (...i) => {
            r(i);
          },
        sink: n,
        sources: e,
      });
    });
  }
  getValue(e) {
    return this.register(e), this.state.get(e);
  }
  getValues(e) {
    return e.map((n) => this.getValue(n));
  }
  register(e) {
    const n = xm.get(e);
    return n === void 0 || this.definitionRegistry.has(e)
      ? e
      : (this.definitionRegistry.add(e),
        Ua(n.type === "cell" ? this.cellInstance(n.initial, n.distinct, e) : this.signalInstance(n.distinct, e), (r) => {
          n.init(this, r);
        }));
  }
  changeWith(e, n, r) {
    this.connect({
      sources: [n],
      pulls: [e],
      sink: e,
      map: (i) => (s, o) => {
        i(r(o, s));
      },
    });
  }
  calculateExecutionMap(e) {
    const n = [],
      r = new Set(),
      i = new gf(),
      s = new yD(),
      o = new gf(),
      a = (l, c = 0) => {
        s.increment(l),
          !r.has(l) &&
            (this.register(l),
            i.use(l, (u) => {
              c = Math.max(...Array.from(u).map((h) => n.indexOf(h))) + 1;
            }),
            this.graph.use(l, (u) => {
              for (const h of u) h.sources.has(l) ? (o.getOrCreate(h.sink).add(h), a(h.sink, c)) : i.getOrCreate(h.sink).add(l);
            }),
            r.add(l),
            n.splice(c, 0, l));
      };
    return e.forEach(a), { participatingNodes: n, pendingPulls: i, projections: o, refCount: s };
  }
  getExecutionMap(e) {
    let n = e;
    if (e.length === 1) {
      n = e[0];
      const i = this.executionMaps.get(n);
      if (i !== void 0) return i;
    } else
      for (const [i, s] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === e.length && i.every((o) => e.includes(o))) return s;
    const r = this.calculateExecutionMap(e);
    return this.executionMaps.set(n, r), r;
  }
  combineOperators(...e) {
    return (n) => {
      for (const r of e) n = r(n, this);
      return n;
    };
  }
};
function Se(t, e = Hx, n = !0) {
  return Ua(Symbol(), (r) => {
    xm.set(r, { type: "cell", distinct: n, initial: t, init: e });
  });
}
function $t(t = Hx, e = !1) {
  return Ua(Symbol(), (n) => {
    xm.set(n, { type: "signal", distinct: e, init: t });
  });
}
function ni(t = Hx) {
  return Ua(Symbol(), (e) => {
    xm.set(e, { type: "signal", distinct: !1, init: t });
  });
}
const bm = C.createContext(null);
function wD({ children: t, initWith: e, updateWith: n = {} }) {
  const r = C.useMemo(() => new qx(e), []);
  return (
    C.useEffect(() => {
      r.pubIn(n);
    }, [n, r]),
    E.jsx(bm.Provider, { value: r, children: t })
  );
}
function Fl() {
  const t = C.useContext(bm);
  if (t === null) throw new Error("useRealm must be used within a RealmContextProvider");
  return t;
}
function yt(t) {
  const e = Fl();
  e.register(t);
  const n = C.useCallback((r) => e.sub(t, r), [e, t]);
  return C.useSyncExternalStore(
    n,
    () => e.getValue(t),
    () => e.getValue(t)
  );
}
function nt(...t) {
  const e = Fl(),
    n = C.useMemo(() => e.getValues(t), []),
    r = C.useRef(n),
    i = C.useCallback(
      (s) => {
        const o = (a) => {
          (r.current = a), s();
        };
        return e.subMultiple(t, o);
      },
      [e, ...t]
    );
  return C.useSyncExternalStore(
    i,
    () => r.current,
    () => r.current
  );
}
function tt(t) {
  const e = Fl();
  return (
    e.register(t),
    C.useCallback(
      (n) => {
        e.pub(t, n);
      },
      [e, t]
    )
  );
}
function SD(t) {
  return [yt(t), tt(t)];
}
function Rr(t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => (s) => {
          i(t(s));
        },
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function bt(...t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map:
          (i) =>
          (...s) => {
            i(s);
          },
        pulls: t,
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function Yx(t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => () => {
          i(t);
        },
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function Vl(t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => (s) => {
          t(s) && i(s);
        },
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function kD() {
  return (t, e) => {
    const n = e.signalInstance();
    let r = !1;
    return (
      e.connect({
        map: (i) => (s) => {
          r || ((r = !0), i(s));
        },
        sink: n,
        sources: [t],
      }),
      n
    );
  };
}
function Gx(t, e) {
  return (n, r) => {
    const i = r.signalInstance();
    return (
      r.connect({
        map: (s) => (o) => {
          s((e = t(e, o)));
        },
        sink: i,
        sources: [n],
      }),
      i
    );
  };
}
function CD(t) {
  return (e, n) => {
    const r = n.signalInstance();
    let i,
      s = null;
    return (
      n.sub(e, (o) => {
        (i = o),
          s === null &&
            (s = setTimeout(() => {
              (s = null), n.pub(r, i);
            }, t));
      }),
      r
    );
  };
}
function _D(t) {
  return (e, n) => {
    const r = n.signalInstance();
    let i,
      s = null;
    return (
      n.sub(e, (o) => {
        (i = o),
          s !== null && clearTimeout(s),
          (s = setTimeout(() => {
            n.pub(r, i);
          }, t));
      }),
      r
    );
  };
}
function ED() {
  return (t, e) => {
    const n = e.signalInstance();
    return (
      e.sub(t, (r) => {
        queueMicrotask(() => {
          e.pub(n, r);
        });
      }),
      n
    );
  };
}
function TD(t) {
  return (e, n) => {
    const r = n.signalInstance(),
      i = Symbol();
    let s = i;
    return (
      n.connect({
        map: (o) => (a) => {
          s !== i && (o([s, a]), (s = i));
        },
        sink: r,
        sources: [t],
      }),
      n.sub(e, (o) => (s = o)),
      r
    );
  };
}
function PD(t, e, n) {
  return (r, i) => {
    const s = i.signalInstance();
    return (
      i.sub(r, (o) => {
        o !== null && typeof o == "object" && "then" in o
          ? (i.pub(s, t()),
            o
              .then((a) => {
                i.pub(s, e(a));
              })
              .catch((a) => {
                i.pub(s, n(a));
              }))
          : i.pub(s, e(o));
      }),
      s
    );
  };
}
function AD(t, e) {
  return (n) => t(e(n));
}
function $D(t, e) {
  return e(t);
}
function RD(t, e) {
  return (n) => t(e, n);
}
function ID(t, e) {
  return () => t(e);
}
function ND(t) {
  return (e) => e[t];
}
function Jx(t, e) {
  return e(t), t;
}
function $P(t) {
  t();
}
function LD(t) {
  return () => t;
}
function MD(...t) {
  return () => {
    t.map($P);
  };
}
function Zs() {}
function en(t) {
  return function (e) {
    return {
      init: (n) => {
        var r;
        return (r = t.init) == null ? void 0 : r.call(t, n, e);
      },
      postInit: (n) => {
        var r;
        return (r = t.postInit) == null ? void 0 : r.call(t, n, e);
      },
      update: (n) => {
        var r;
        return (r = t.update) == null ? void 0 : r.call(t, n, e);
      },
    };
  };
}
function RP({ children: t, plugins: e }) {
  const n = C.useMemo(
    () =>
      Jx(new qx(), (r) => {
        var i, s;
        for (const o of e) (i = o.init) == null || i.call(o, r);
        for (const o of e) (s = o.postInit) == null || s.call(o, r);
      }),
    []
  );
  return (
    C.useEffect(() => {
      var r;
      for (const i of e) (r = i.update) == null || r.call(i, n);
    }),
    C.createElement(bm.Provider, { value: n }, t)
  );
}
function DD(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var QD = DD(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const zd = w.createContext(null);
function IP(t, e) {
  let n = null;
  return (
    t != null && (n = t[1]),
    {
      getTheme: function () {
        return e ?? (n != null ? n.getTheme() : null);
      },
    }
  );
}
function jn() {
  const t = w.useContext(zd);
  return t == null && QD(8), t;
}
function gs(t) {
  return {};
}
const Bl = {},
  FD = {},
  ym = {},
  No = {},
  Xa = {},
  xu = {},
  Ha = {},
  mh = {},
  eO = {},
  bu = {},
  yu = {},
  Gi = {},
  wm = {},
  Sm = {},
  Kx = {},
  NP = {},
  VD = {},
  eb = {},
  BD = {},
  tb = {},
  nb = {},
  pl = {},
  LP = {},
  gh = {},
  Oh = {},
  km = {},
  rb = {},
  MP = {},
  ib = {},
  tO = {},
  sb = {},
  jD = {},
  Cm = {},
  ob = {},
  ZD = {},
  _m = {},
  ab = {},
  nO = {},
  zD = {},
  WD = {},
  Nc = {},
  Lc = {},
  lb = {},
  Em = {},
  DP = {},
  ri = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  UD = ri && "documentMode" in document ? document.documentMode : null,
  Zr = ri && /Mac|iPod|iPhone|iPad/.test(navigator.platform),
  zs = ri && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),
  Wd = !(!ri || !("InputEvent" in window) || UD) && "getTargetRanges" in new window.InputEvent("input"),
  cb = ri && /Version\/[\d.]+.*Safari/.test(navigator.userAgent),
  Tm = ri && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
  XD = ri && /Android/.test(navigator.userAgent),
  QP = ri && /^(?=.*Chrome).*/i.test(navigator.userAgent),
  HD = ri && XD && QP,
  ub = ri && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !QP,
  vh = 1,
  lo = 3,
  Bo = 0,
  FP = 1,
  ml = 2,
  qD = 0,
  YD = 1,
  GD = 2,
  Ud = 4,
  Xd = 8,
  hb = 128,
  JD = 112 | (3 | Ud | Xd) | hb,
  fb = 1,
  db = 2,
  pb = 3,
  mb = 4,
  gb = 5,
  Ob = 6,
  Pm = cb || Tm || ub ? " " : "​",
  ls = `

`,
  KD = zs ? " " : Pm,
  VP = "֑-߿יִ-﷽ﹰ-ﻼ",
  BP = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿",
  eQ = new RegExp("^[^" + BP + "]*[" + VP + "]"),
  tQ = new RegExp("^[^" + VP + "]*[" + BP + "]"),
  ts = { bold: 1, code: 16, highlight: hb, italic: 2, strikethrough: Ud, subscript: 32, superscript: 64, underline: Xd },
  nQ = { directionless: 1, unmergeable: 2 },
  bk = { center: db, end: Ob, justify: mb, left: fb, right: pb, start: gb },
  rQ = { [db]: "center", [Ob]: "end", [mb]: "justify", [fb]: "left", [pb]: "right", [gb]: "start" },
  iQ = { normal: 0, segmented: 2, token: 1 },
  sQ = { [qD]: "normal", [GD]: "segmented", [YD]: "token" };
function oQ(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Oe = oQ(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function Hd(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
const aQ = 100;
let rO = !1,
  vb = 0;
function lQ(t) {
  vb = t.timeStamp;
}
function Kg(t, e, n) {
  return e.__lexicalLineBreak === t || t[`__lexicalKey_${n._key}`] !== void 0;
}
function cQ(t, e, n) {
  const r = $i(n._window);
  let i = null,
    s = null;
  r !== null && r.anchorNode === t && ((i = r.anchorOffset), (s = r.focusOffset));
  const o = t.nodeValue;
  o !== null && Sb(e, o, i, s, !1);
}
function uQ(t, e, n) {
  if (ee(t)) {
    const r = t.anchor.getNode();
    if (r.is(n) && t.format !== r.getFormat()) return !1;
  }
  return e.nodeType === lo && n.isAttached();
}
function jP(t, e, n) {
  rO = !0;
  const r = performance.now() - vb > aQ;
  try {
    hr(t, () => {
      const i =
          ce() ||
          (function (f) {
            return f.getEditorState().read(() => {
              const d = ce();
              return d !== null ? d.clone() : null;
            });
          })(t),
        s = new Map(),
        o = t.getRootElement(),
        a = t._editorState,
        l = t._blockCursorElement;
      let c = !1,
        u = "";
      for (let f = 0; f < e.length; f++) {
        const d = e[f],
          p = d.type,
          m = d.target;
        let O = Ai(m, a);
        if (!((O === null && m !== o) || ht(O))) {
          if (p === "characterData") r && ne(O) && uQ(i, m, O) && cQ(m, O, t);
          else if (p === "childList") {
            c = !0;
            const v = d.addedNodes;
            for (let y = 0; y < v.length; y++) {
              const S = v[y],
                k = HP(S),
                b = S.parentNode;
              if (b != null && S !== l && k === null && (S.nodeName !== "BR" || !Kg(S, b, t))) {
                if (zs) {
                  const _ = S.innerText || S.nodeValue;
                  _ && (u += _);
                }
                b.removeChild(S);
              }
            }
            const g = d.removedNodes,
              x = g.length;
            if (x > 0) {
              let y = 0;
              for (let S = 0; S < x; S++) {
                const k = g[S];
                ((k.nodeName === "BR" && Kg(k, m, t)) || l === k) && (m.appendChild(k), y++);
              }
              x !== y && (m === o && (O = YP(a)), s.set(m, O));
            }
          }
        }
      }
      if (s.size > 0)
        for (const [f, d] of s)
          if (W(d)) {
            const p = d.getChildrenKeys();
            let m = f.firstChild;
            for (let O = 0; O < p.length; O++) {
              const v = p[O],
                g = t.getElementByKey(v);
              g !== null && (m == null ? (f.appendChild(g), (m = g)) : m !== g && f.replaceChild(g, m), (m = m.nextSibling));
            }
          } else ne(d) && d.markDirty();
      const h = n.takeRecords();
      if (h.length > 0) {
        for (let f = 0; f < h.length; f++) {
          const d = h[f],
            p = d.addedNodes,
            m = d.target;
          for (let O = 0; O < p.length; O++) {
            const v = p[O],
              g = v.parentNode;
            g == null || v.nodeName !== "BR" || Kg(v, m, t) || g.removeChild(v);
          }
        }
        n.takeRecords();
      }
      i !== null && (c && ((i.dirty = !0), yn(i)), zs && e3(t) && i.insertRawText(u));
    });
  } finally {
    rO = !1;
  }
}
function ZP(t) {
  const e = t._observer;
  e !== null && jP(t, e.takeRecords(), e);
}
function zP(t) {
  (function (e) {
    vb === 0 && Rm(e).addEventListener("textInput", lQ, !0);
  })(t),
    (t._observer = new MutationObserver((e, n) => {
      jP(t, e, n);
    }));
}
function yk(t, e) {
  const n = t.__mode,
    r = t.__format,
    i = t.__style,
    s = e.__mode,
    o = e.__format,
    a = e.__style;
  return !((n !== null && n !== s) || (r !== null && r !== o) || (i !== null && i !== a));
}
function wk(t, e) {
  const n = t.mergeWithSibling(e),
    r = Vt()._normalizedNodes;
  return r.add(t.__key), r.add(e.__key), n;
}
function Sk(t) {
  let e,
    n,
    r = t;
  if (r.__text !== "" || !r.isSimpleText() || r.isUnmergeable()) {
    for (; (e = r.getPreviousSibling()) !== null && ne(e) && e.isSimpleText() && !e.isUnmergeable(); ) {
      if (e.__text !== "") {
        if (yk(e, r)) {
          r = wk(e, r);
          break;
        }
        break;
      }
      e.remove();
    }
    for (; (n = r.getNextSibling()) !== null && ne(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if (n.__text !== "") {
        if (yk(r, n)) {
          r = wk(r, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else r.remove();
}
function xb(t) {
  return kk(t.anchor), kk(t.focus), t;
}
function kk(t) {
  for (; t.type === "element"; ) {
    const e = t.getNode(),
      n = t.offset;
    let r, i;
    if ((n === e.getChildrenSize() ? ((r = e.getChildAtIndex(n - 1)), (i = !0)) : ((r = e.getChildAtIndex(n)), (i = !1)), ne(r))) {
      t.set(r.__key, i ? r.getTextContentSize() : 0, "text");
      break;
    }
    if (!W(r)) break;
    t.set(r.__key, i ? r.getChildrenSize() : 0, "element");
  }
}
let hQ = 1;
const fQ =
  typeof queueMicrotask == "function"
    ? queueMicrotask
    : (t) => {
        Promise.resolve().then(t);
      };
function bb(t) {
  const e = document.activeElement;
  if (e === null) return !1;
  const n = e.nodeName;
  return ht(Ai(t)) && (n === "INPUT" || n === "TEXTAREA" || (e.contentEditable === "true" && e.__lexicalEditor == null));
}
function xh(t, e, n) {
  const r = t.getRootElement();
  try {
    return r !== null && r.contains(e) && r.contains(n) && e !== null && !bb(e) && WP(e) === t;
  } catch {
    return !1;
  }
}
function WP(t) {
  let e = t;
  for (; e != null; ) {
    const n = e.__lexicalEditor;
    if (n != null) return n;
    e = $m(e);
  }
  return null;
}
function Pa(t) {
  return t.isToken() || t.isSegmented();
}
function dQ(t) {
  return t.nodeType === lo;
}
function qd(t) {
  let e = t;
  for (; e != null; ) {
    if (dQ(e)) return e;
    e = e.firstChild;
  }
  return null;
}
function iO(t, e, n) {
  const r = ts[e];
  if (n !== null && (t & r) == (n & r)) return t;
  let i = t ^ r;
  return e === "subscript" ? (i &= ~ts.superscript) : e === "superscript" && (i &= ~ts.subscript), i;
}
function UP(t) {
  return ne(t) || Hr(t) || ht(t);
}
function XP(t, e) {
  if (e != null) return void (t.__key = e);
  Ln(), b3();
  const n = Vt(),
    r = vs(),
    i = "" + hQ++;
  r._nodeMap.set(i, t),
    W(t) ? n._dirtyElements.set(i, !0) : n._dirtyLeaves.add(i),
    n._cloneNotNeeded.add(i),
    (n._dirtyType = FP),
    (t.__key = i);
}
function Lo(t) {
  const e = t.getParent();
  if (e !== null) {
    const n = t.getWritable(),
      r = e.getWritable(),
      i = t.getPreviousSibling(),
      s = t.getNextSibling();
    if (i === null)
      if (s !== null) {
        const o = s.getWritable();
        (r.__first = s.__key), (o.__prev = null);
      } else r.__first = null;
    else {
      const o = i.getWritable();
      if (s !== null) {
        const a = s.getWritable();
        (a.__prev = o.__key), (o.__next = a.__key);
      } else o.__next = null;
      n.__prev = null;
    }
    if (s === null)
      if (i !== null) {
        const o = i.getWritable();
        (r.__last = i.__key), (o.__next = null);
      } else r.__last = null;
    else {
      const o = s.getWritable();
      if (i !== null) {
        const a = i.getWritable();
        (a.__next = o.__key), (o.__prev = a.__key);
      } else o.__prev = null;
      n.__next = null;
    }
    r.__size--, (n.__parent = null);
  }
}
function Yd(t) {
  b3();
  const e = t.getLatest(),
    n = e.__parent,
    r = vs(),
    i = Vt(),
    s = r._nodeMap,
    o = i._dirtyElements;
  n !== null &&
    (function (l, c, u) {
      let h = l;
      for (; h !== null; ) {
        if (u.has(h)) return;
        const f = c.get(h);
        if (f === void 0) break;
        u.set(h, !1), (h = f.__parent);
      }
    })(n, s, o);
  const a = e.__key;
  (i._dirtyType = FP), W(t) ? o.set(a, !0) : i._dirtyLeaves.add(a);
}
function pn(t) {
  Ln();
  const e = Vt(),
    n = e._compositionKey;
  if (t !== n) {
    if (((e._compositionKey = t), n !== null)) {
      const r = vt(n);
      r !== null && r.getWritable();
    }
    if (t !== null) {
      const r = vt(t);
      r !== null && r.getWritable();
    }
  }
}
function Ls() {
  return wh() ? null : Vt()._compositionKey;
}
function vt(t, e) {
  const n = (e || vs())._nodeMap.get(t);
  return n === void 0 ? null : n;
}
function HP(t, e) {
  const n = t[`__lexicalKey_${Vt()._key}`];
  return n !== void 0 ? vt(n, e) : null;
}
function Ai(t, e) {
  let n = t;
  for (; n != null; ) {
    const r = HP(n, e);
    if (r !== null) return r;
    n = $m(n);
  }
  return null;
}
function qP(t) {
  const e = t._decorators,
    n = Object.assign({}, e);
  return (t._pendingDecorators = n), n;
}
function Ck(t) {
  return t.read(() => Be().getTextContent());
}
function Be() {
  return YP(vs());
}
function YP(t) {
  return t._nodeMap.get("root");
}
function yn(t) {
  Ln();
  const e = vs();
  t !== null && ((t.dirty = !0), t.setCachedNodes(null)), (e._selection = t);
}
function Qa(t) {
  const e = Vt(),
    n = (function (r, i) {
      let s = r;
      for (; s != null; ) {
        const o = s[`__lexicalKey_${i._key}`];
        if (o !== void 0) return o;
        s = $m(s);
      }
      return null;
    })(t, e);
  return n === null ? (t === e.getRootElement() ? vt("root") : null) : vt(n);
}
function _k(t, e) {
  return e ? t.getTextContentSize() : 0;
}
function GP(t) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(t);
}
function yb(t) {
  const e = [];
  let n = t;
  for (; n !== null; ) e.push(n), (n = n._parentEditor);
  return e;
}
function JP() {
  return Math.random()
    .toString(36)
    .replace(/[^a-z]+/g, "")
    .substr(0, 5);
}
function KP(t) {
  return t.nodeType === lo ? t.nodeValue : null;
}
function wb(t, e, n) {
  const r = $i(e._window);
  if (r === null) return;
  const i = r.anchorNode;
  let { anchorOffset: s, focusOffset: o } = r;
  if (i !== null) {
    let a = KP(i);
    const l = Ai(i);
    if (a !== null && ne(l)) {
      if (a === Pm && n) {
        const c = n.length;
        (a = n), (s = c), (o = c);
      }
      a !== null && Sb(l, a, s, o, t);
    }
  }
}
function Sb(t, e, n, r, i) {
  let s = t;
  if (s.isAttached() && (i || !s.isDirty())) {
    const o = s.isComposing();
    let a = e;
    (o || i) && e[e.length - 1] === Pm && (a = e.slice(0, -1));
    const l = s.getTextContent();
    if (i || a !== l) {
      if (a === "") {
        if ((pn(null), cb || Tm || ub)) s.remove();
        else {
          const m = Vt();
          setTimeout(() => {
            m.update(() => {
              s.isAttached() && s.remove();
            });
          }, 20);
        }
        return;
      }
      const c = s.getParent(),
        u = ca(),
        h = s.getTextContentSize(),
        f = Ls(),
        d = s.getKey();
      if (
        s.isToken() ||
        (f !== null && d === f && !o) ||
        (ee(u) &&
          ((c !== null && !c.canInsertTextBefore() && u.anchor.offset === 0) ||
            (u.anchor.key === t.__key && u.anchor.offset === 0 && !s.canInsertTextBefore() && !o) ||
            (u.focus.key === t.__key && u.focus.offset === h && !s.canInsertTextAfter() && !o)))
      )
        return void s.markDirty();
      const p = ce();
      if (!ee(p) || n === null || r === null) return void s.setTextContent(a);
      if ((p.setTextNodeRange(s, n, s, r), s.isSegmented())) {
        const m = Et(s.getTextContent());
        s.replace(m), (s = m);
      }
      s.setTextContent(a);
    }
  }
}
function pQ(t, e) {
  if (e.isSegmented()) return !0;
  if (!t.isCollapsed()) return !1;
  const n = t.anchor.offset,
    r = e.getParentOrThrow(),
    i = e.isToken();
  return n === 0
    ? !e.canInsertTextBefore() ||
        (!r.canInsertTextBefore() && !e.isComposing()) ||
        i ||
        (function (s) {
          const o = s.getPreviousSibling();
          return (ne(o) || (W(o) && o.isInline())) && !o.canInsertTextAfter();
        })(e)
    : n === e.getTextContentSize() && (!e.canInsertTextAfter() || (!r.canInsertTextAfter() && !e.isComposing()) || i);
}
function Ek(t) {
  return t === "ArrowLeft";
}
function Tk(t) {
  return t === "ArrowRight";
}
function Mc(t, e) {
  return Zr ? t : e;
}
function Pk(t) {
  return t === "Enter";
}
function gc(t) {
  return t === "Backspace";
}
function Oc(t) {
  return t === "Delete";
}
function Ak(t, e, n) {
  return t.toLowerCase() === "a" && Mc(e, n);
}
function mQ() {
  const t = Be();
  yn(xb(t.select(0, t.getChildrenSize())));
}
function Kc(t, e) {
  t.__lexicalClassNameCache === void 0 && (t.__lexicalClassNameCache = {});
  const n = t.__lexicalClassNameCache,
    r = n[e];
  if (r !== void 0) return r;
  const i = t[e];
  if (typeof i == "string") {
    const s = Hd(i);
    return (n[e] = s), s;
  }
  return i;
}
function kb(t, e, n, r, i) {
  if (n.size === 0) return;
  const s = r.__type,
    o = r.__key,
    a = e.get(s);
  a === void 0 && Oe(33, s);
  const l = a.klass;
  let c = t.get(l);
  c === void 0 && ((c = new Map()), t.set(l, c));
  const u = c.get(o),
    h = u === "destroyed" && i === "created";
  (u === void 0 || h) && c.set(o, h ? "updated" : i);
}
function $k(t, e, n) {
  const r = t.getParent();
  let i = n,
    s = t;
  return (
    r !== null &&
      (e && n === 0
        ? ((i = s.getIndexWithinParent()), (s = r))
        : e || n !== s.getChildrenSize() || ((i = s.getIndexWithinParent() + 1), (s = r))),
    s.getChildAtIndex(e ? i - 1 : i)
  );
}
function wu(t, e) {
  const n = t.offset;
  if (t.type === "element") return $k(t.getNode(), e, n);
  {
    const r = t.getNode();
    if ((e && n === 0) || (!e && n === r.getTextContentSize())) {
      const i = e ? r.getPreviousSibling() : r.getNextSibling();
      return i === null ? $k(r.getParentOrThrow(), e, r.getIndexWithinParent() + (e ? 0 : 1)) : i;
    }
  }
  return null;
}
function e3(t) {
  const e = Rm(t).event,
    n = e && e.inputType;
  return n === "insertFromPaste" || n === "insertFromPasteAsQuotation";
}
function xe(t, e, n) {
  return y3(t, e, n);
}
function Am(t) {
  return !cn(t) && !t.isLastChild() && !t.isInline();
}
function Gd(t, e) {
  const n = t._keyToDOMMap.get(e);
  return n === void 0 && Oe(75, e), n;
}
function $m(t) {
  const e = t.assignedSlot || t.parentElement;
  return e !== null && e.nodeType === 11 ? e.host : e;
}
function gQ(t) {
  Ln(), Vt()._updateTags.add(t);
}
function sO(t, e) {
  let n = t.getParent();
  for (; n !== null; ) {
    if (n.is(e)) return !0;
    n = n.getParent();
  }
  return !1;
}
function Rm(t) {
  const e = t._window;
  return e === null && Oe(78), e;
}
function OQ(t) {
  let e = t.getParentOrThrow();
  for (; e !== null; ) {
    if (rn(e)) return e;
    e = e.getParentOrThrow();
  }
  return e;
}
function rn(t) {
  return cn(t) || (W(t) && t.isShadowRoot());
}
function vQ(t) {
  const e = t.constructor.clone(t);
  return XP(e, null), e;
}
function Zn(t) {
  const e = Vt(),
    n = t.constructor.getType(),
    r = e._nodes.get(n);
  r === void 0 && Oe(97);
  const i = r.replace;
  if (i !== null) {
    const s = i(t);
    return s instanceof t.constructor || Oe(98), s;
  }
  return t;
}
function e0(t, e) {
  !cn(t.getParent()) || W(e) || ht(e) || Oe(99);
}
function t0(t) {
  return (ht(t) || (W(t) && !t.canBeEmpty())) && !t.isInline();
}
function Cb(t, e, n) {
  n.style.removeProperty("caret-color"), (e._blockCursorElement = null);
  const r = t.parentElement;
  r !== null && r.removeChild(t);
}
function xQ(t, e, n) {
  let r = t._blockCursorElement;
  if (ee(n) && n.isCollapsed() && n.anchor.type === "element" && e.contains(document.activeElement)) {
    const i = n.anchor,
      s = i.getNode(),
      o = i.offset;
    let a = !1,
      l = null;
    if (o === s.getChildrenSize()) t0(s.getChildAtIndex(o - 1)) && (a = !0);
    else {
      const c = s.getChildAtIndex(o);
      if (t0(c)) {
        const u = c.getPreviousSibling();
        (u === null || t0(u)) && ((a = !0), (l = t.getElementByKey(c.__key)));
      }
    }
    if (a) {
      const c = t.getElementByKey(s.__key);
      return (
        r === null &&
          (t._blockCursorElement = r =
            (function (u) {
              const h = u.theme,
                f = document.createElement("div");
              (f.contentEditable = "false"), f.setAttribute("data-lexical-cursor", "true");
              let d = h.blockCursor;
              if (d !== void 0) {
                if (typeof d == "string") {
                  const p = Hd(d);
                  d = h.blockCursor = p;
                }
                d !== void 0 && f.classList.add(...d);
              }
              return f;
            })(t._config)),
        (e.style.caretColor = "transparent"),
        void (l === null ? c.appendChild(r) : c.insertBefore(r, l))
      );
    }
  }
  r !== null && Cb(r, t, e);
}
function $i(t) {
  return ri ? (t || window).getSelection() : null;
}
function bQ(t, e) {
  let n = t.getChildAtIndex(e);
  n == null && (n = t), rn(t) && Oe(102);
  const r = (o) => {
      const a = o.getParentOrThrow(),
        l = rn(a),
        c = o !== n || l ? vQ(o) : o;
      if (l) return (W(o) && W(c)) || Oe(133), o.insertAfter(c), [o, c, c];
      {
        const [u, h, f] = r(a),
          d = o.getNextSiblings();
        return f.append(c, ...d), [u, h, c];
      }
    },
    [i, s] = r(n);
  return [i, s];
}
function yQ(t) {
  return qr(t) && t.tagName === "A";
}
function qr(t) {
  return t.nodeType === 1;
}
function wQ(t) {
  const e = new RegExp(
    /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/,
    "i"
  );
  return t.nodeName.match(e) !== null;
}
function SQ(t) {
  const e = new RegExp(
    /^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/,
    "i"
  );
  return t.nodeName.match(e) !== null;
}
function Aa(t) {
  if (cn(t) || (ht(t) && !t.isInline())) return !0;
  if (!W(t) || rn(t)) return !1;
  const e = t.getFirstChild(),
    n = e === null || Hr(e) || ne(e) || e.isInline();
  return !t.isInline() && t.canBeEmpty() !== !1 && n;
}
function n0(t, e) {
  let n = t;
  for (; n !== null && n.getParent() !== null && !e(n); ) n = n.getParentOrThrow();
  return e(n) ? n : null;
}
function t3(t, e, n, r, i, s) {
  let o = t.getFirstChild();
  for (; o !== null; ) {
    const a = o.__key;
    o.__parent === e && (W(o) && t3(o, a, n, r, i, s), n.has(a) || s.delete(a), i.push(a)), (o = o.getNextSibling());
  }
}
let Ys,
  Qn,
  Su,
  Im,
  oO,
  aO,
  jo,
  Xr,
  lO,
  ku,
  tn = "",
  Dn = "",
  zr = null,
  qi = "",
  n3 = !1,
  Nm = !1,
  bd = null;
function Jd(t, e) {
  const n = jo.get(t);
  if (e !== null) {
    const r = hO(t);
    r.parentNode === e && e.removeChild(r);
  }
  if ((Xr.has(t) || Qn._keyToDOMMap.delete(t), W(n))) {
    const r = ep(n, jo);
    cO(r, 0, r.length - 1, null);
  }
  n !== void 0 && kb(ku, Su, Im, n, "destroyed");
}
function cO(t, e, n, r) {
  let i = e;
  for (; i <= n; ++i) {
    const s = t[i];
    s !== void 0 && Jd(s, r);
  }
}
function So(t, e) {
  t.setProperty("text-align", e);
}
const kQ = "40px";
function r3(t, e) {
  const n = Ys.theme.indent;
  if (typeof n == "string") {
    const i = t.classList.contains(n);
    e > 0 && !i ? t.classList.add(n) : e < 1 && i && t.classList.remove(n);
  }
  const r = getComputedStyle(t).getPropertyValue("--lexical-indent-base-value") || kQ;
  t.style.setProperty("padding-inline-start", e === 0 ? "" : `calc(${e} * ${r})`);
}
function i3(t, e) {
  const n = t.style;
  e === 0
    ? So(n, "")
    : e === fb
    ? So(n, "left")
    : e === db
    ? So(n, "center")
    : e === pb
    ? So(n, "right")
    : e === mb
    ? So(n, "justify")
    : e === gb
    ? So(n, "start")
    : e === Ob && So(n, "end");
}
function Kd(t, e, n) {
  const r = Xr.get(t);
  r === void 0 && Oe(60);
  const i = r.createDOM(Ys, Qn);
  if (
    ((function (s, o, a) {
      const l = a._keyToDOMMap;
      (o["__lexicalKey_" + a._key] = s), l.set(s, o);
    })(t, i, Qn),
    ne(r) ? i.setAttribute("data-lexical-text", "true") : ht(r) && i.setAttribute("data-lexical-decorator", "true"),
    W(r))
  ) {
    const s = r.__indent,
      o = r.__size;
    if ((s !== 0 && r3(i, s), o !== 0)) {
      const l = o - 1;
      (function (c, u, h, f) {
        const d = Dn;
        (Dn = ""), uO(c, h, 0, u, f, null), o3(h, f), (Dn = d);
      })(ep(r, Xr), l, r, i);
    }
    const a = r.__format;
    a !== 0 && i3(i, a), r.isInline() || s3(null, r, i), Am(r) && ((tn += ls), (qi += ls));
  } else {
    const s = r.getTextContent();
    if (ht(r)) {
      const o = r.decorate(Qn, Ys);
      o !== null && a3(t, o), (i.contentEditable = "false");
    } else ne(r) && (r.isDirectionless() || (Dn += s));
    (tn += s), (qi += s);
  }
  if (e !== null)
    if (n != null) e.insertBefore(i, n);
    else {
      const s = e.__lexicalLineBreak;
      s != null ? e.insertBefore(i, s) : e.appendChild(i);
    }
  return kb(ku, Su, Im, r, "created"), i;
}
function uO(t, e, n, r, i, s) {
  const o = tn;
  tn = "";
  let a = n;
  for (; a <= r; ++a) {
    Kd(t[a], i, s);
    const l = Xr.get(t[a]);
    l !== null && zr === null && ne(l) && (zr = l.getFormat());
  }
  Am(e) && (tn += ls), (i.__lexicalTextContent = tn), (tn = o + tn);
}
function Rk(t, e) {
  const n = e.get(t);
  return Hr(n) || (ht(n) && n.isInline());
}
function s3(t, e, n) {
  const r = t !== null && (t.__size === 0 || Rk(t.__last, jo)),
    i = e.__size === 0 || Rk(e.__last, Xr);
  if (r) {
    if (!i) {
      const s = n.__lexicalLineBreak;
      s != null && n.removeChild(s), (n.__lexicalLineBreak = null);
    }
  } else if (i) {
    const s = document.createElement("br");
    (n.__lexicalLineBreak = s), n.appendChild(s);
  }
}
function o3(t, e) {
  const n = e.__lexicalDirTextContent,
    r = e.__lexicalDir;
  if (n !== Dn || r !== bd) {
    const s = Dn === "",
      o = s ? bd : ((i = Dn), eQ.test(i) ? "rtl" : tQ.test(i) ? "ltr" : null);
    if (o !== r) {
      const a = e.classList,
        l = Ys.theme;
      let c = r !== null ? l[r] : void 0,
        u = o !== null ? l[o] : void 0;
      if (c !== void 0) {
        if (typeof c == "string") {
          const h = Hd(c);
          c = l[r] = h;
        }
        a.remove(...c);
      }
      if (o === null || (s && o === "ltr")) e.removeAttribute("dir");
      else {
        if (u !== void 0) {
          if (typeof u == "string") {
            const h = Hd(u);
            u = l[o] = h;
          }
          u !== void 0 && a.add(...u);
        }
        e.dir = o;
      }
      Nm || (t.getWritable().__dir = o);
    }
    (bd = o), (e.__lexicalDirTextContent = Dn), (e.__lexicalDir = o);
  }
  var i;
}
function CQ(t, e, n) {
  const r = Dn;
  var i;
  (Dn = ""),
    (zr = null),
    (function (s, o, a) {
      const l = tn,
        c = s.__size,
        u = o.__size;
      if (((tn = ""), c === 1 && u === 1)) {
        const h = s.__first,
          f = o.__first;
        if (h === f) Dc(h, a);
        else {
          const p = hO(h),
            m = Kd(f, null, null);
          a.replaceChild(m, p), Jd(h, null);
        }
        const d = Xr.get(f);
        zr === null && ne(d) && (zr = d.getFormat());
      } else {
        const h = ep(s, jo),
          f = ep(o, Xr);
        if (c === 0) u !== 0 && uO(f, o, 0, u - 1, a, null);
        else if (u === 0) {
          if (c !== 0) {
            const d = a.__lexicalLineBreak == null;
            cO(h, 0, c - 1, d ? null : a), d && (a.textContent = "");
          }
        } else
          (function (d, p, m, O, v, g) {
            const x = O - 1,
              y = v - 1;
            let S,
              k,
              b = ((P = g), P.firstChild),
              _ = 0,
              T = 0;
            for (var P; _ <= x && T <= y; ) {
              const V = p[_],
                Q = m[T];
              if (V === Q) (b = r0(Dc(Q, g))), _++, T++;
              else {
                S === void 0 && (S = new Set(p)), k === void 0 && (k = new Set(m));
                const G = k.has(V),
                  H = S.has(Q);
                if (G)
                  if (H) {
                    const te = Gd(Qn, Q);
                    te === b ? (b = r0(Dc(Q, g))) : (b != null ? g.insertBefore(te, b) : g.appendChild(te), Dc(Q, g)), _++, T++;
                  } else Kd(Q, g, b), T++;
                else (b = r0(hO(V))), Jd(V, g), _++;
              }
              const N = Xr.get(Q);
              N !== null && zr === null && ne(N) && (zr = N.getFormat());
            }
            const M = _ > x,
              D = T > y;
            if (M && !D) {
              const V = m[y + 1];
              uO(m, d, T, y, g, V === void 0 ? null : Qn.getElementByKey(V));
            } else D && !M && cO(p, _, x, g);
          })(o, h, f, c, u, a);
      }
      Am(o) && (tn += ls), (a.__lexicalTextContent = tn), (tn = l + tn);
    })(t, e, n),
    o3(e, n),
    cs((i = e)) && zr != null && zr !== i.__textFormat && !Nm && i.setTextFormat(zr),
    (Dn = r),
    (zr = null);
}
function ep(t, e) {
  const n = [];
  let r = t.__first;
  for (; r !== null; ) {
    const i = e.get(r);
    i === void 0 && Oe(101), n.push(r), (r = i.__next);
  }
  return n;
}
function Dc(t, e) {
  const n = jo.get(t);
  let r = Xr.get(t);
  (n !== void 0 && r !== void 0) || Oe(61);
  const i = n3 || aO.has(t) || oO.has(t),
    s = Gd(Qn, t);
  if (n === r && !i) {
    if (W(n)) {
      const o = s.__lexicalTextContent;
      o !== void 0 && ((tn += o), (qi += o));
      const a = s.__lexicalDirTextContent;
      a !== void 0 && (Dn += a);
    } else {
      const o = n.getTextContent();
      ne(n) && !n.isDirectionless() && (Dn += o), (qi += o), (tn += o);
    }
    return s;
  }
  if ((n !== r && i && kb(ku, Su, Im, r, "updated"), r.updateDOM(n, s, Ys))) {
    const o = Kd(t, null, null);
    return e === null && Oe(62), e.replaceChild(o, s), Jd(t, null), o;
  }
  if (W(n) && W(r)) {
    const o = r.__indent;
    o !== n.__indent && r3(s, o);
    const a = r.__format;
    a !== n.__format && i3(s, a), i && (CQ(n, r, s), cn(r) || r.isInline() || s3(n, r, s)), Am(r) && ((tn += ls), (qi += ls));
  } else {
    const o = r.getTextContent();
    if (ht(r)) {
      const a = r.decorate(Qn, Ys);
      a !== null && a3(t, a);
    } else ne(r) && !r.isDirectionless() && (Dn += o);
    (tn += o), (qi += o);
  }
  if (!Nm && cn(r) && r.__cachedText !== qi) {
    const o = r.getWritable();
    (o.__cachedText = qi), (r = o);
  }
  return s;
}
function a3(t, e) {
  let n = Qn._pendingDecorators;
  const r = Qn._decorators;
  if (n === null) {
    if (r[t] === e) return;
    n = qP(Qn);
  }
  n[t] = e;
}
function r0(t) {
  let e = t.nextSibling;
  return e !== null && e === Qn._blockCursorElement && (e = e.nextSibling), e;
}
function _Q(t, e, n, r, i, s) {
  (tn = ""),
    (qi = ""),
    (Dn = ""),
    (n3 = r === ml),
    (bd = null),
    (Qn = n),
    (Ys = n._config),
    (Su = n._nodes),
    (Im = Qn._listeners.mutation),
    (oO = i),
    (aO = s),
    (jo = t._nodeMap),
    (Xr = e._nodeMap),
    (Nm = e._readOnly),
    (lO = new Map(n._keyToDOMMap));
  const o = new Map();
  return (
    (ku = o),
    Dc("root", null),
    (Qn = void 0),
    (Su = void 0),
    (oO = void 0),
    (aO = void 0),
    (jo = void 0),
    (Xr = void 0),
    (Ys = void 0),
    (lO = void 0),
    (ku = void 0),
    o
  );
}
function hO(t) {
  const e = lO.get(t);
  return e === void 0 && Oe(75, t), e;
}
const Wi = Object.freeze({}),
  fO = 30,
  dO = [
    [
      "keydown",
      function (t, e) {
        if (((eu = t.timeStamp), (l3 = t.key), e.isComposing())) return;
        const { key: n, shiftKey: r, ctrlKey: i, metaKey: s, altKey: o } = t;
        xe(e, Kx, t) ||
          (n != null &&
            ((function (a, l, c, u) {
              return Tk(a) && !l && !u && !c;
            })(n, i, o, s)
              ? xe(e, NP, t)
              : (function (a, l, c, u, h) {
                  return Tk(a) && !u && !c && (l || h);
                })(n, i, r, o, s)
              ? xe(e, VD, t)
              : (function (a, l, c, u) {
                  return Ek(a) && !l && !u && !c;
                })(n, i, o, s)
              ? xe(e, eb, t)
              : (function (a, l, c, u, h) {
                  return Ek(a) && !u && !c && (l || h);
                })(n, i, r, o, s)
              ? xe(e, BD, t)
              : (function (a, l, c) {
                  return (
                    (function (u) {
                      return u === "ArrowUp";
                    })(a) &&
                    !l &&
                    !c
                  );
                })(n, i, s)
              ? xe(e, tb, t)
              : (function (a, l, c) {
                  return (
                    (function (u) {
                      return u === "ArrowDown";
                    })(a) &&
                    !l &&
                    !c
                  );
                })(n, i, s)
              ? xe(e, nb, t)
              : (function (a, l) {
                  return Pk(a) && l;
                })(n, r)
              ? ((tu = !0), xe(e, pl, t))
              : (function (a) {
                  return a === " ";
                })(n)
              ? xe(e, LP, t)
              : (function (a, l) {
                  return Zr && l && a.toLowerCase() === "o";
                })(n, i)
              ? (t.preventDefault(), (tu = !0), xe(e, Xa, !0))
              : (function (a, l) {
                  return Pk(a) && !l;
                })(n, r)
              ? ((tu = !1), xe(e, pl, t))
              : (function (a, l, c, u) {
                  return Zr ? !l && !c && (gc(a) || (a.toLowerCase() === "h" && u)) : !(u || l || c) && gc(a);
                })(n, o, s, i)
              ? gc(n)
                ? xe(e, gh, t)
                : (t.preventDefault(), xe(e, No, !0))
              : (function (a) {
                  return a === "Escape";
                })(n)
              ? xe(e, Oh, t)
              : (function (a, l, c, u, h) {
                  return Zr ? !(c || u || h) && (Oc(a) || (a.toLowerCase() === "d" && l)) : !(l || u || h) && Oc(a);
                })(n, i, r, o, s)
              ? Oc(n)
                ? xe(e, km, t)
                : (t.preventDefault(), xe(e, No, !1))
              : (function (a, l, c) {
                  return gc(a) && (Zr ? l : c);
                })(n, o, i)
              ? (t.preventDefault(), xe(e, bu, !0))
              : (function (a, l, c) {
                  return Oc(a) && (Zr ? l : c);
                })(n, o, i)
              ? (t.preventDefault(), xe(e, bu, !1))
              : (function (a, l) {
                  return Zr && l && gc(a);
                })(n, s)
              ? (t.preventDefault(), xe(e, yu, !0))
              : (function (a, l) {
                  return Zr && l && Oc(a);
                })(n, s)
              ? (t.preventDefault(), xe(e, yu, !1))
              : (function (a, l, c, u) {
                  return a.toLowerCase() === "b" && !l && Mc(c, u);
                })(n, o, s, i)
              ? (t.preventDefault(), xe(e, Gi, "bold"))
              : (function (a, l, c, u) {
                  return a.toLowerCase() === "u" && !l && Mc(c, u);
                })(n, o, s, i)
              ? (t.preventDefault(), xe(e, Gi, "underline"))
              : (function (a, l, c, u) {
                  return a.toLowerCase() === "i" && !l && Mc(c, u);
                })(n, o, s, i)
              ? (t.preventDefault(), xe(e, Gi, "italic"))
              : (function (a, l, c, u) {
                  return a === "Tab" && !l && !c && !u;
                })(n, o, i, s)
              ? xe(e, rb, t)
              : (function (a, l, c, u) {
                  return a.toLowerCase() === "z" && !l && Mc(c, u);
                })(n, r, s, i)
              ? (t.preventDefault(), xe(e, wm, void 0))
              : (function (a, l, c, u) {
                  return Zr ? a.toLowerCase() === "z" && c && l : (a.toLowerCase() === "y" && u) || (a.toLowerCase() === "z" && u && l);
                })(n, r, s, i)
              ? (t.preventDefault(), xe(e, Sm, void 0))
              : Ht(e._editorState._selection)
              ? (function (a, l, c, u) {
                  return !l && a.toLowerCase() === "c" && (Zr ? c : u);
                })(n, r, s, i)
                ? (t.preventDefault(), xe(e, _m, t))
                : (function (a, l, c, u) {
                    return !l && a.toLowerCase() === "x" && (Zr ? c : u);
                  })(n, r, s, i)
                ? (t.preventDefault(), xe(e, ab, t))
                : Ak(n, s, i) && (t.preventDefault(), xe(e, nO, t))
              : !zs && Ak(n, s, i) && (t.preventDefault(), xe(e, nO, t)),
            (function (a, l, c, u) {
              return a || l || c || u;
            })(i, r, o, s) && xe(e, DP, t)));
      },
    ],
    [
      "pointerdown",
      function (t, e) {
        const n = t.target,
          r = t.pointerType;
        n instanceof Node &&
          r !== "touch" &&
          hr(e, () => {
            ht(Ai(n)) || (mO = !0);
          });
      },
    ],
    [
      "compositionstart",
      function (t, e) {
        hr(e, () => {
          const n = ce();
          if (ee(n) && !e.isComposing()) {
            const r = n.anchor,
              i = n.anchor.getNode();
            pn(r.key),
              (t.timeStamp < eu + fO ||
                r.type === "element" ||
                !n.isCollapsed() ||
                i.getFormat() !== n.format ||
                (ne(i) && i.getStyle() !== n.style)) &&
                xe(e, Ha, KD);
          }
        });
      },
    ],
    [
      "compositionend",
      function (t, e) {
        zs
          ? (vc = !0)
          : hr(e, () => {
              i0(e, t.data);
            });
      },
    ],
    [
      "input",
      function (t, e) {
        t.stopPropagation(),
          hr(e, () => {
            const n = ce(),
              r = t.data,
              i = f3(t);
            if (r != null && ee(n) && h3(n, i, r, t.timeStamp, !1)) {
              vc && (i0(e, r), (vc = !1));
              const s = n.anchor.getNode(),
                o = $i(e._window);
              if (o === null) return;
              const a = n.isBackward(),
                l = a ? n.anchor.offset : n.focus.offset,
                c = a ? n.focus.offset : n.anchor.offset;
              (Wd &&
                !n.isCollapsed() &&
                ne(s) &&
                o.anchorNode !== null &&
                s.getTextContent().slice(0, l) + r + s.getTextContent().slice(l + c) === KP(o.anchorNode)) ||
                xe(e, Ha, r);
              const u = r.length;
              zs && u > 1 && t.inputType === "insertCompositionText" && !e.isComposing() && (n.anchor.offset -= u),
                cb || Tm || ub || !e.isComposing() || ((eu = 0), pn(null));
            } else wb(!1, e, r !== null ? r : void 0), vc && (i0(e, r || void 0), (vc = !1));
            Ln(), ZP(Vt());
          }),
          ($a = null);
      },
    ],
    [
      "click",
      function (t, e) {
        hr(e, () => {
          const n = ce(),
            r = $i(e._window),
            i = ca();
          if (r) {
            if (ee(n)) {
              const s = n.anchor,
                o = s.getNode();
              s.type === "element" &&
              s.offset === 0 &&
              n.isCollapsed() &&
              !cn(o) &&
              Be().getChildrenSize() === 1 &&
              o.getTopLevelElementOrThrow().isEmpty() &&
              i !== null &&
              n.is(i)
                ? (r.removeAllRanges(), (n.dirty = !0))
                : t.detail === 3 && !n.isCollapsed() && o !== n.focus.getNode() && (W(o) ? o.select(0) : o.getParentOrThrow().select(0));
            } else if (t.pointerType === "touch") {
              const s = r.anchorNode;
              if (s !== null) {
                const o = s.nodeType;
                (o === vh || o === lo) && yn(Tb(i, r, e, t));
              }
            }
          }
          xe(e, ym, t);
        });
      },
    ],
    ["cut", Wi],
    ["copy", Wi],
    ["dragstart", Wi],
    ["dragover", Wi],
    ["dragend", Wi],
    ["paste", Wi],
    ["focus", Wi],
    ["blur", Wi],
    ["drop", Wi],
  ];
Wd &&
  dO.push([
    "beforeinput",
    (t, e) =>
      (function (n, r) {
        const i = n.inputType,
          s = f3(n);
        i === "deleteCompositionText" ||
          (zs && e3(r)) ||
          (i !== "insertCompositionText" &&
            hr(r, () => {
              const o = ce();
              if (i === "deleteContentBackward") {
                if (o === null) {
                  const d = ca();
                  if (!ee(d)) return;
                  yn(d.clone());
                }
                if (ee(o)) {
                  const d = o.anchor.key === o.focus.key;
                  if (((a = n.timeStamp), l3 === "MediaLast" && a < eu + fO && r.isComposing() && d)) {
                    if (
                      (pn(null),
                      (eu = 0),
                      setTimeout(() => {
                        hr(r, () => {
                          pn(null);
                        });
                      }, fO),
                      ee(o))
                    ) {
                      const p = o.anchor.getNode();
                      p.markDirty(), (o.format = p.getFormat()), ne(p) || Oe(142), (o.style = p.getStyle());
                    }
                  } else {
                    pn(null), n.preventDefault();
                    const p = o.anchor.getNode().getTextContent(),
                      m = o.anchor.offset === 0 && o.focus.offset === p.length;
                    (HD && d && !m) || xe(r, No, !0);
                  }
                  return;
                }
              }
              var a;
              if (!ee(o)) return;
              const l = n.data;
              $a !== null && wb(!1, r, $a),
                (o.dirty && $a === null) || !o.isCollapsed() || cn(o.anchor.getNode()) || s === null || o.applyDOMRange(s),
                ($a = null);
              const c = o.anchor,
                u = o.focus,
                h = c.getNode(),
                f = u.getNode();
              if (i !== "insertText" && i !== "insertTranspose")
                switch ((n.preventDefault(), i)) {
                  case "insertFromYank":
                  case "insertFromDrop":
                  case "insertReplacementText":
                    xe(r, Ha, n);
                    break;
                  case "insertFromComposition":
                    pn(null), xe(r, Ha, n);
                    break;
                  case "insertLineBreak":
                    pn(null), xe(r, Xa, !1);
                    break;
                  case "insertParagraph":
                    pn(null), tu && !Tm ? ((tu = !1), xe(r, Xa, !1)) : xe(r, xu, void 0);
                    break;
                  case "insertFromPaste":
                  case "insertFromPasteAsQuotation":
                    xe(r, mh, n);
                    break;
                  case "deleteByComposition":
                    (function (d, p) {
                      return d !== p || W(d) || W(p) || !d.isToken() || !p.isToken();
                    })(h, f) && xe(r, eO, n);
                    break;
                  case "deleteByDrag":
                  case "deleteByCut":
                    xe(r, eO, n);
                    break;
                  case "deleteContent":
                    xe(r, No, !1);
                    break;
                  case "deleteWordBackward":
                    xe(r, bu, !0);
                    break;
                  case "deleteWordForward":
                    xe(r, bu, !1);
                    break;
                  case "deleteHardLineBackward":
                  case "deleteSoftLineBackward":
                    xe(r, yu, !0);
                    break;
                  case "deleteContentForward":
                  case "deleteHardLineForward":
                  case "deleteSoftLineForward":
                    xe(r, yu, !1);
                    break;
                  case "formatStrikeThrough":
                    xe(r, Gi, "strikethrough");
                    break;
                  case "formatBold":
                    xe(r, Gi, "bold");
                    break;
                  case "formatItalic":
                    xe(r, Gi, "italic");
                    break;
                  case "formatUnderline":
                    xe(r, Gi, "underline");
                    break;
                  case "historyUndo":
                    xe(r, wm, void 0);
                    break;
                  case "historyRedo":
                    xe(r, Sm, void 0);
                }
              else {
                if (
                  l ===
                  `
`
                )
                  n.preventDefault(), xe(r, Xa, !1);
                else if (l === ls) n.preventDefault(), xe(r, xu, void 0);
                else if (l == null && n.dataTransfer) {
                  const d = n.dataTransfer.getData("text/plain");
                  n.preventDefault(), o.insertRawText(d);
                } else l != null && h3(o, s, l, n.timeStamp, !0) ? (n.preventDefault(), xe(r, Ha, l)) : ($a = l);
                c3 = n.timeStamp;
              }
            }));
      })(t, e),
  ]);
let eu = 0,
  l3 = null,
  c3 = 0,
  $a = null;
const tp = new WeakMap();
let pO = !1,
  mO = !1,
  tu = !1,
  vc = !1,
  u3 = [0, "", 0, "root", 0];
function h3(t, e, n, r, i) {
  const s = t.anchor,
    o = t.focus,
    a = s.getNode(),
    l = Vt(),
    c = $i(l._window),
    u = c !== null ? c.anchorNode : null,
    h = s.key,
    f = l.getElementByKey(h),
    d = n.length;
  return (
    h !== o.key ||
    !ne(a) ||
    (((!i && (!Wd || c3 < r + 50)) || (a.isDirty() && d < 2) || GP(n)) && s.offset !== o.offset && !a.isComposing()) ||
    Pa(a) ||
    (a.isDirty() && d > 1) ||
    ((i || !Wd) && f !== null && !a.isComposing() && u !== qd(f)) ||
    (c !== null && e !== null && (!e.collapsed || e.startContainer !== c.anchorNode || e.startOffset !== c.anchorOffset)) ||
    a.getFormat() !== t.format ||
    a.getStyle() !== t.style ||
    pQ(t, a)
  );
}
function Ik(t, e) {
  return t !== null && t.nodeValue !== null && t.nodeType === lo && e !== 0 && e !== t.nodeValue.length;
}
function Nk(t, e, n) {
  const { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o } = t;
  (pO && ((pO = !1), Ik(r, i) && Ik(s, o))) ||
    hr(e, () => {
      if (!n) return void yn(null);
      if (!xh(e, r, s)) return;
      const a = ce();
      if (ee(a)) {
        const l = a.anchor,
          c = l.getNode();
        if (a.isCollapsed()) {
          t.type === "Range" && t.anchorNode === t.focusNode && (a.dirty = !0);
          const u = Rm(e).event,
            h = u ? u.timeStamp : performance.now(),
            [f, d, p, m, O] = u3,
            v = Be(),
            g = e.isComposing() === !1 && v.getTextContent() === "";
          if (h < O + 200 && l.offset === p && l.key === m) (a.format = f), (a.style = d);
          else if (l.type === "text") ne(c) || Oe(141), (a.format = c.getFormat()), (a.style = c.getStyle());
          else if (l.type === "element" && !g) {
            const x = l.getNode();
            x instanceof ua && x.getChildrenSize() === 0 ? (a.format = x.getTextFormat()) : (a.format = 0), (a.style = "");
          }
        } else {
          const u = l.key,
            h = a.focus.key,
            f = a.getNodes(),
            d = f.length,
            p = a.isBackward(),
            m = p ? o : i,
            O = p ? i : o,
            v = p ? h : u,
            g = p ? u : h;
          let x = JD,
            y = !1;
          for (let S = 0; S < d; S++) {
            const k = f[S],
              b = k.getTextContentSize();
            if (
              ne(k) &&
              b !== 0 &&
              !((S === 0 && k.__key === v && m === b) || (S === d - 1 && k.__key === g && O === 0)) &&
              ((y = !0), (x &= k.getFormat()), x === 0)
            )
              break;
          }
          a.format = y ? x : 0;
        }
      }
      xe(e, Bl, void 0);
    });
}
function f3(t) {
  if (!t.getTargetRanges) return null;
  const e = t.getTargetRanges();
  return e.length === 0 ? null : e[0];
}
function i0(t, e) {
  const n = t._compositionKey;
  if ((pn(null), n !== null && e != null)) {
    if (e === "") {
      const r = vt(n),
        i = qd(t.getElementByKey(n));
      return void (i !== null && i.nodeValue !== null && ne(r) && Sb(r, i.nodeValue, null, null, !0));
    }
    if (
      e[e.length - 1] ===
      `
`
    ) {
      const r = ce();
      if (ee(r)) {
        const i = r.focus;
        return r.anchor.set(i.key, i.offset, i.type), void xe(t, pl, null);
      }
    }
  }
  wb(!0, t, e);
}
function d3(t) {
  let e = t.__lexicalEventHandles;
  return e === void 0 && ((e = []), (t.__lexicalEventHandles = e)), e;
}
const qa = new Map();
function p3(t) {
  const e = t.target,
    n = $i(e == null ? null : e.nodeType === 9 ? e.defaultView : e.ownerDocument.defaultView);
  if (n === null) return;
  const r = WP(n.anchorNode);
  if (r === null) return;
  mO &&
    ((mO = !1),
    hr(r, () => {
      const c = ca(),
        u = n.anchorNode;
      if (u === null) return;
      const h = u.nodeType;
      (h !== vh && h !== lo) || yn(Tb(c, n, r, t));
    }));
  const i = yb(r),
    s = i[i.length - 1],
    o = s._key,
    a = qa.get(o),
    l = a || s;
  l !== r && Nk(n, l, !1), Nk(n, r, !0), r !== s ? qa.set(o, r) : a && qa.delete(o);
}
function Lk(t) {
  t._lexicalHandled = !0;
}
function Mk(t) {
  return t._lexicalHandled === !0;
}
function EQ(t) {
  const e = t.ownerDocument,
    n = tp.get(e);
  n === void 0 && Oe(162);
  const r = n - 1;
  r >= 0 || Oe(164), tp.set(e, r), r === 0 && e.removeEventListener("selectionchange", p3);
  const i = t.__lexicalEditor;
  i != null &&
    ((function (o) {
      if (o._parentEditor !== null) {
        const a = yb(o),
          l = a[a.length - 1]._key;
        qa.get(l) === o && qa.delete(l);
      } else qa.delete(o._key);
    })(i),
    (t.__lexicalEditor = null));
  const s = d3(t);
  for (let o = 0; o < s.length; o++) s[o]();
  t.__lexicalEventHandles = [];
}
function gO(t, e, n) {
  Ln();
  const r = t.__key,
    i = t.getParent();
  if (i === null) return;
  const s = (function (a) {
    const l = ce();
    if (!ee(l) || !W(a)) return l;
    const { anchor: c, focus: u } = l,
      h = c.getNode(),
      f = u.getNode();
    return sO(h, a) && c.set(a.__key, 0, "element"), sO(f, a) && u.set(a.__key, 0, "element"), l;
  })(t);
  let o = !1;
  if (ee(s) && e) {
    const a = s.anchor,
      l = s.focus;
    a.key === r && (ip(a, t, i, t.getPreviousSibling(), t.getNextSibling()), (o = !0)),
      l.key === r && (ip(l, t, i, t.getPreviousSibling(), t.getNextSibling()), (o = !0));
  } else Ht(s) && e && t.isSelected() && t.selectPrevious();
  if (ee(s) && e && !o) {
    const a = t.getIndexWithinParent();
    Lo(t), rp(s, i, a, -1);
  } else Lo(t);
  n || rn(i) || i.canBeEmpty() || !i.isEmpty() || gO(i, e), e && cn(i) && i.isEmpty() && i.selectEnd();
}
class Lm {
  static getType() {
    Oe(64, this.name);
  }
  static clone(e) {
    Oe(65, this.name);
  }
  constructor(e) {
    (this.__type = this.constructor.getType()), (this.__parent = null), (this.__prev = null), (this.__next = null), XP(this, e);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    Oe(137, this.constructor.name);
  }
  isAttached() {
    let e = this.__key;
    for (; e !== null; ) {
      if (e === "root") return !0;
      const n = vt(e);
      if (n === null) break;
      e = n.__parent;
    }
    return !1;
  }
  isSelected(e) {
    const n = e || ce();
    if (n == null) return !1;
    const r = n.getNodes().some((i) => i.__key === this.__key);
    return (
      (ne(this) ||
        !ee(n) ||
        n.anchor.type !== "element" ||
        n.focus.type !== "element" ||
        n.anchor.key !== n.focus.key ||
        n.anchor.offset !== n.focus.offset) &&
      r
    );
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const e = this.getParent();
    if (e === null) return -1;
    let n = e.getFirstChild(),
      r = 0;
    for (; n !== null; ) {
      if (this.is(n)) return r;
      r++, (n = n.getNextSibling());
    }
    return -1;
  }
  getParent() {
    const e = this.getLatest().__parent;
    return e === null ? null : vt(e);
  }
  getParentOrThrow() {
    const e = this.getParent();
    return e === null && Oe(66, this.__key), e;
  }
  getTopLevelElement() {
    let e = this;
    for (; e !== null; ) {
      const n = e.getParent();
      if (rn(n)) return W(e) || Oe(138), e;
      e = n;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const e = this.getTopLevelElement();
    return e === null && Oe(67, this.__key), e;
  }
  getParents() {
    const e = [];
    let n = this.getParent();
    for (; n !== null; ) e.push(n), (n = n.getParent());
    return e;
  }
  getParentKeys() {
    const e = [];
    let n = this.getParent();
    for (; n !== null; ) e.push(n.__key), (n = n.getParent());
    return e;
  }
  getPreviousSibling() {
    const e = this.getLatest().__prev;
    return e === null ? null : vt(e);
  }
  getPreviousSiblings() {
    const e = [],
      n = this.getParent();
    if (n === null) return e;
    let r = n.getFirstChild();
    for (; r !== null && !r.is(this); ) e.push(r), (r = r.getNextSibling());
    return e;
  }
  getNextSibling() {
    const e = this.getLatest().__next;
    return e === null ? null : vt(e);
  }
  getNextSiblings() {
    const e = [];
    let n = this.getNextSibling();
    for (; n !== null; ) e.push(n), (n = n.getNextSibling());
    return e;
  }
  getCommonAncestor(e) {
    const n = this.getParents(),
      r = e.getParents();
    W(this) && n.unshift(this), W(e) && r.unshift(e);
    const i = n.length,
      s = r.length;
    if (i === 0 || s === 0 || n[i - 1] !== r[s - 1]) return null;
    const o = new Set(r);
    for (let a = 0; a < i; a++) {
      const l = n[a];
      if (o.has(l)) return l;
    }
    return null;
  }
  is(e) {
    return e != null && this.__key === e.__key;
  }
  isBefore(e) {
    if (this === e) return !1;
    if (e.isParentOf(this)) return !0;
    if (this.isParentOf(e)) return !1;
    const n = this.getCommonAncestor(e);
    let r = 0,
      i = 0,
      s = this;
    for (;;) {
      const o = s.getParentOrThrow();
      if (o === n) {
        r = s.getIndexWithinParent();
        break;
      }
      s = o;
    }
    for (s = e; ; ) {
      const o = s.getParentOrThrow();
      if (o === n) {
        i = s.getIndexWithinParent();
        break;
      }
      s = o;
    }
    return r < i;
  }
  isParentOf(e) {
    const n = this.__key;
    if (n === e.__key) return !1;
    let r = e;
    for (; r !== null; ) {
      if (r.__key === n) return !0;
      r = r.getParent();
    }
    return !1;
  }
  getNodesBetween(e) {
    const n = this.isBefore(e),
      r = [],
      i = new Set();
    let s = this;
    for (; s !== null; ) {
      const o = s.__key;
      if ((i.has(o) || (i.add(o), r.push(s)), s === e)) break;
      const a = W(s) ? (n ? s.getFirstChild() : s.getLastChild()) : null;
      if (a !== null) {
        s = a;
        continue;
      }
      const l = n ? s.getNextSibling() : s.getPreviousSibling();
      if (l !== null) {
        s = l;
        continue;
      }
      const c = s.getParentOrThrow();
      if ((i.has(c.__key) || r.push(c), c === e)) break;
      let u = null,
        h = c;
      do {
        if ((h === null && Oe(68), (u = n ? h.getNextSibling() : h.getPreviousSibling()), (h = h.getParent()), h === null)) break;
        u !== null || i.has(h.__key) || r.push(h);
      } while (u === null);
      s = u;
    }
    return n || r.reverse(), r;
  }
  isDirty() {
    const e = Vt()._dirtyLeaves;
    return e !== null && e.has(this.__key);
  }
  getLatest() {
    const e = vt(this.__key);
    return e === null && Oe(113), e;
  }
  getWritable() {
    Ln();
    const e = vs(),
      n = Vt(),
      r = e._nodeMap,
      i = this.__key,
      s = this.getLatest(),
      o = s.__parent,
      a = n._cloneNotNeeded,
      l = ce();
    if ((l !== null && l.setCachedNodes(null), a.has(i))) return Yd(s), s;
    const c = s.constructor.clone(s);
    return (
      (c.__parent = o),
      (c.__next = s.__next),
      (c.__prev = s.__prev),
      W(s) && W(c)
        ? (cs(s) && cs(c) && (c.__textFormat = s.__textFormat),
          (c.__first = s.__first),
          (c.__last = s.__last),
          (c.__size = s.__size),
          (c.__indent = s.__indent),
          (c.__format = s.__format),
          (c.__dir = s.__dir))
        : ne(s) && ne(c) && ((c.__format = s.__format), (c.__style = s.__style), (c.__mode = s.__mode), (c.__detail = s.__detail)),
      a.add(i),
      (c.__key = i),
      Yd(c),
      r.set(i, c),
      c
    );
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(e, n) {
    Oe(70);
  }
  updateDOM(e, n, r) {
    Oe(71);
  }
  exportDOM(e) {
    return { element: this.createDOM(e._config, e) };
  }
  exportJSON() {
    Oe(72);
  }
  static importJSON(e) {
    Oe(18, this.name);
  }
  static transform() {
    return null;
  }
  remove(e) {
    gO(this, !0, e);
  }
  replace(e, n) {
    Ln();
    let r = ce();
    r !== null && (r = r.clone()), e0(this, e);
    const i = this.getLatest(),
      s = this.__key,
      o = e.__key,
      a = e.getWritable(),
      l = this.getParentOrThrow().getWritable(),
      c = l.__size;
    Lo(a);
    const u = i.getPreviousSibling(),
      h = i.getNextSibling(),
      f = i.__prev,
      d = i.__next,
      p = i.__parent;
    if (
      (gO(i, !1, !0),
      u === null ? (l.__first = o) : (u.getWritable().__next = o),
      (a.__prev = f),
      h === null ? (l.__last = o) : (h.getWritable().__prev = o),
      (a.__next = d),
      (a.__parent = p),
      (l.__size = c),
      n &&
        ((W(this) && W(a)) || Oe(139),
        this.getChildren().forEach((m) => {
          a.append(m);
        })),
      ee(r))
    ) {
      yn(r);
      const m = r.anchor,
        O = r.focus;
      m.key === s && Bk(m, a), O.key === s && Bk(O, a);
    }
    return Ls() === s && pn(o), a;
  }
  insertAfter(e, n = !0) {
    Ln(), e0(this, e);
    const r = this.getWritable(),
      i = e.getWritable(),
      s = i.getParent(),
      o = ce();
    let a = !1,
      l = !1;
    if (s !== null) {
      const d = e.getIndexWithinParent();
      if ((Lo(i), ee(o))) {
        const p = s.__key,
          m = o.anchor,
          O = o.focus;
        (a = m.type === "element" && m.key === p && m.offset === d + 1), (l = O.type === "element" && O.key === p && O.offset === d + 1);
      }
    }
    const c = this.getNextSibling(),
      u = this.getParentOrThrow().getWritable(),
      h = i.__key,
      f = r.__next;
    if (
      (c === null ? (u.__last = h) : (c.getWritable().__prev = h),
      u.__size++,
      (r.__next = h),
      (i.__next = f),
      (i.__prev = r.__key),
      (i.__parent = r.__parent),
      n && ee(o))
    ) {
      const d = this.getIndexWithinParent();
      rp(o, u, d + 1);
      const p = u.__key;
      a && o.anchor.set(p, d + 2, "element"), l && o.focus.set(p, d + 2, "element");
    }
    return e;
  }
  insertBefore(e, n = !0) {
    Ln(), e0(this, e);
    const r = this.getWritable(),
      i = e.getWritable(),
      s = i.__key;
    Lo(i);
    const o = this.getPreviousSibling(),
      a = this.getParentOrThrow().getWritable(),
      l = r.__prev,
      c = this.getIndexWithinParent();
    o === null ? (a.__first = s) : (o.getWritable().__next = s),
      a.__size++,
      (r.__prev = s),
      (i.__prev = l),
      (i.__next = r.__key),
      (i.__parent = r.__parent);
    const u = ce();
    return n && ee(u) && rp(u, this.getParentOrThrow(), c), e;
  }
  isParentRequired() {
    return !1;
  }
  createParentElementNode() {
    return at();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(e, n) {
    Ln();
    const r = this.getPreviousSibling(),
      i = this.getParentOrThrow();
    if (r === null) return i.select(0, 0);
    if (W(r)) return r.select();
    if (!ne(r)) {
      const s = r.getIndexWithinParent() + 1;
      return i.select(s, s);
    }
    return r.select(e, n);
  }
  selectNext(e, n) {
    Ln();
    const r = this.getNextSibling(),
      i = this.getParentOrThrow();
    if (r === null) return i.select();
    if (W(r)) return r.select(0, 0);
    if (!ne(r)) {
      const s = r.getIndexWithinParent();
      return i.select(s, s);
    }
    return r.select(e, n);
  }
  markDirty() {
    this.getWritable();
  }
}
class bh extends Lm {
  static getType() {
    return "linebreak";
  }
  static clone(e) {
    return new bh(e.__key);
  }
  constructor(e) {
    super(e);
  }
  getTextContent() {
    return `
`;
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {
      br: (e) =>
        (function (n) {
          const r = n.parentElement;
          if (r !== null) {
            const i = r.firstChild;
            if (i === n || (i.nextSibling === n && Dk(i))) {
              const s = r.lastChild;
              if (s === n || (s.previousSibling === n && Dk(s))) return !0;
            }
          }
          return !1;
        })(e)
          ? null
          : { conversion: TQ, priority: 0 },
    };
  }
  static importJSON(e) {
    return Ri();
  }
  exportJSON() {
    return { type: "linebreak", version: 1 };
  }
}
function TQ(t) {
  return { node: Ri() };
}
function Ri() {
  return Zn(new bh());
}
function Hr(t) {
  return t instanceof bh;
}
function Dk(t) {
  return t.nodeType === lo && /^( |\t|\r?\n)+$/.test(t.textContent || "");
}
function s0(t, e) {
  return 16 & e ? "code" : e & hb ? "mark" : 32 & e ? "sub" : 64 & e ? "sup" : null;
}
function o0(t, e) {
  return 1 & e ? "strong" : 2 & e ? "em" : "span";
}
function m3(t, e, n, r, i) {
  const s = r.classList;
  let o = Kc(i, "base");
  o !== void 0 && s.add(...o), (o = Kc(i, "underlineStrikethrough"));
  let a = !1;
  const l = e & Xd && e & Ud;
  o !== void 0 && (n & Xd && n & Ud ? ((a = !0), l || s.add(...o)) : l && s.remove(...o));
  for (const c in ts) {
    const u = ts[c];
    if (((o = Kc(i, c)), o !== void 0))
      if (n & u) {
        if (a && (c === "underline" || c === "strikethrough")) {
          e & u && s.remove(...o);
          continue;
        }
        (e & u && (!l || c !== "underline") && c !== "strikethrough") || s.add(...o);
      } else e & u && s.remove(...o);
  }
}
function g3(t, e, n) {
  const r = e.firstChild,
    i = n.isComposing(),
    s = t + (i ? Pm : "");
  if (r == null) e.textContent = s;
  else {
    const o = r.nodeValue;
    if (o !== s)
      if (i || zs) {
        const [a, l, c] = (function (u, h) {
          const f = u.length,
            d = h.length;
          let p = 0,
            m = 0;
          for (; p < f && p < d && u[p] === h[p]; ) p++;
          for (; m + p < f && m + p < d && u[f - m - 1] === h[d - m - 1]; ) m++;
          return [p, f - p - m, h.slice(p, d - m)];
        })(o, s);
        l !== 0 && r.deleteData(a, l), r.insertData(a, c);
      } else r.nodeValue = s;
  }
}
function Qk(t, e, n, r, i, s) {
  g3(i, t, e);
  const o = s.theme.text;
  o !== void 0 && m3(0, 0, r, t, o);
}
function Of(t, e) {
  const n = document.createElement(e);
  return n.appendChild(t), n;
}
class Os extends Lm {
  static getType() {
    return "text";
  }
  static clone(e) {
    return new Os(e.__text, e.__key);
  }
  constructor(e, n) {
    super(n), (this.__text = e), (this.__format = 0), (this.__style = ""), (this.__mode = 0), (this.__detail = 0);
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const e = this.getLatest();
    return sQ[e.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return this.getLatest().__mode === 1;
  }
  isComposing() {
    return this.__key === Ls();
  }
  isSegmented() {
    return this.getLatest().__mode === 2;
  }
  isDirectionless() {
    return !!(1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return !!(2 & this.getLatest().__detail);
  }
  hasFormat(e) {
    const n = ts[e];
    return !!(this.getFormat() & n);
  }
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(e, n) {
    return iO(this.getLatest().__format, e, n);
  }
  canHaveFormat() {
    return !0;
  }
  createDOM(e, n) {
    const r = this.__format,
      i = s0(0, r),
      s = o0(0, r),
      o = i === null ? s : i,
      a = document.createElement(o);
    let l = a;
    this.hasFormat("code") && a.setAttribute("spellcheck", "false"),
      i !== null && ((l = document.createElement(s)), a.appendChild(l)),
      Qk(l, this, 0, r, this.__text, e);
    const c = this.__style;
    return c !== "" && (a.style.cssText = c), a;
  }
  updateDOM(e, n, r) {
    const i = this.__text,
      s = e.__format,
      o = this.__format,
      a = s0(0, s),
      l = s0(0, o),
      c = o0(0, s),
      u = o0(0, o);
    if ((a === null ? c : a) !== (l === null ? u : l)) return !0;
    if (a === l && c !== u) {
      const m = n.firstChild;
      m == null && Oe(48);
      const O = document.createElement(u);
      return Qk(O, this, 0, o, i, r), n.replaceChild(O, m), !1;
    }
    let h = n;
    l !== null && a !== null && ((h = n.firstChild), h == null && Oe(49)), g3(i, h, this);
    const f = r.theme.text;
    f !== void 0 && s !== o && m3(0, s, o, h, f);
    const d = e.__style,
      p = this.__style;
    return d !== p && (n.style.cssText = p), !1;
  }
  static importDOM() {
    return {
      "#text": () => ({ conversion: RQ, priority: 0 }),
      b: () => ({ conversion: AQ, priority: 0 }),
      code: () => ({ conversion: bs, priority: 0 }),
      em: () => ({ conversion: bs, priority: 0 }),
      i: () => ({ conversion: bs, priority: 0 }),
      s: () => ({ conversion: bs, priority: 0 }),
      span: () => ({ conversion: PQ, priority: 0 }),
      strong: () => ({ conversion: bs, priority: 0 }),
      sub: () => ({ conversion: bs, priority: 0 }),
      sup: () => ({ conversion: bs, priority: 0 }),
      u: () => ({ conversion: bs, priority: 0 }),
    };
  }
  static importJSON(e) {
    const n = Et(e.text);
    return n.setFormat(e.format), n.setDetail(e.detail), n.setMode(e.mode), n.setStyle(e.style), n;
  }
  exportDOM(e) {
    let { element: n } = super.exportDOM(e);
    return (
      (n !== null && qr(n)) || Oe(132),
      (n.style.whiteSpace = "pre-wrap"),
      this.hasFormat("bold") && (n = Of(n, "b")),
      this.hasFormat("italic") && (n = Of(n, "i")),
      this.hasFormat("strikethrough") && (n = Of(n, "s")),
      this.hasFormat("underline") && (n = Of(n, "u")),
      { element: n }
    );
  }
  exportJSON() {
    return {
      detail: this.getDetail(),
      format: this.getFormat(),
      mode: this.getMode(),
      style: this.getStyle(),
      text: this.getTextContent(),
      type: "text",
      version: 1,
    };
  }
  selectionTransform(e, n) {}
  setFormat(e) {
    const n = this.getWritable();
    return (n.__format = typeof e == "string" ? ts[e] : e), n;
  }
  setDetail(e) {
    const n = this.getWritable();
    return (n.__detail = typeof e == "string" ? nQ[e] : e), n;
  }
  setStyle(e) {
    const n = this.getWritable();
    return (n.__style = e), n;
  }
  toggleFormat(e) {
    const n = iO(this.getFormat(), e, null);
    return this.setFormat(n);
  }
  toggleDirectionless() {
    const e = this.getWritable();
    return (e.__detail ^= 1), e;
  }
  toggleUnmergeable() {
    const e = this.getWritable();
    return (e.__detail ^= 2), e;
  }
  setMode(e) {
    const n = iQ[e];
    if (this.__mode === n) return this;
    const r = this.getWritable();
    return (r.__mode = n), r;
  }
  setTextContent(e) {
    if (this.__text === e) return this;
    const n = this.getWritable();
    return (n.__text = e), n;
  }
  select(e, n) {
    Ln();
    let r = e,
      i = n;
    const s = ce(),
      o = this.getTextContent(),
      a = this.__key;
    if (typeof o == "string") {
      const l = o.length;
      r === void 0 && (r = l), i === void 0 && (i = l);
    } else (r = 0), (i = 0);
    if (!ee(s)) return x3(a, r, a, i, "text", "text");
    {
      const l = Ls();
      (l !== s.anchor.key && l !== s.focus.key) || pn(a), s.setTextNodeRange(this, r, this, i);
    }
    return s;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const e = this.getTextContentSize();
    return this.select(e, e);
  }
  spliceText(e, n, r, i) {
    const s = this.getWritable(),
      o = s.__text,
      a = r.length;
    let l = e;
    l < 0 && ((l = a + l), l < 0 && (l = 0));
    const c = ce();
    if (i && ee(c)) {
      const h = e + a;
      c.setTextNodeRange(s, h, s, h);
    }
    const u = o.slice(0, l) + r + o.slice(l + n);
    return (s.__text = u), s;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  splitText(...e) {
    Ln();
    const n = this.getLatest(),
      r = n.getTextContent(),
      i = n.__key,
      s = Ls(),
      o = new Set(e),
      a = [],
      l = r.length;
    let c = "";
    for (let b = 0; b < l; b++) c !== "" && o.has(b) && (a.push(c), (c = "")), (c += r[b]);
    c !== "" && a.push(c);
    const u = a.length;
    if (u === 0) return [];
    if (a[0] === r) return [n];
    const h = a[0],
      f = n.getParentOrThrow();
    let d;
    const p = n.getFormat(),
      m = n.getStyle(),
      O = n.__detail;
    let v = !1;
    n.isSegmented()
      ? ((d = Et(h)), (d.__format = p), (d.__style = m), (d.__detail = O), (v = !0))
      : ((d = n.getWritable()), (d.__text = h));
    const g = ce(),
      x = [d];
    let y = h.length;
    for (let b = 1; b < u; b++) {
      const _ = a[b],
        T = _.length,
        P = Et(_).getWritable();
      (P.__format = p), (P.__style = m), (P.__detail = O);
      const M = P.__key,
        D = y + T;
      if (ee(g)) {
        const V = g.anchor,
          Q = g.focus;
        V.key === i && V.type === "text" && V.offset > y && V.offset <= D && ((V.key = M), (V.offset -= y), (g.dirty = !0)),
          Q.key === i && Q.type === "text" && Q.offset > y && Q.offset <= D && ((Q.key = M), (Q.offset -= y), (g.dirty = !0));
      }
      s === i && pn(M), (y = D), x.push(P);
    }
    (function (b) {
      const _ = b.getPreviousSibling(),
        T = b.getNextSibling();
      _ !== null && Yd(_), T !== null && Yd(T);
    })(this);
    const S = f.getWritable(),
      k = this.getIndexWithinParent();
    return v ? (S.splice(k, 0, x), this.remove()) : S.splice(k, 1, x), ee(g) && rp(g, f, k, u - 1), x;
  }
  mergeWithSibling(e) {
    const n = e === this.getPreviousSibling();
    n || e === this.getNextSibling() || Oe(50);
    const r = this.__key,
      i = e.__key,
      s = this.__text,
      o = s.length;
    Ls() === i && pn(r);
    const a = ce();
    if (ee(a)) {
      const h = a.anchor,
        f = a.focus;
      h !== null && h.key === i && (Xk(h, n, r, e, o), (a.dirty = !0)), f !== null && f.key === i && (Xk(f, n, r, e, o), (a.dirty = !0));
    }
    const l = e.__text,
      c = n ? l + s : s + l;
    this.setTextContent(c);
    const u = this.getWritable();
    return e.remove(), u;
  }
  isTextEntity() {
    return !1;
  }
}
function PQ(t) {
  return { forChild: _b(t.style), node: null };
}
function AQ(t) {
  const e = t,
    n = e.style.fontWeight === "normal";
  return { forChild: _b(e.style, n ? void 0 : "bold"), node: null };
}
const Fk = new WeakMap();
function $Q(t) {
  return (
    t.nodeName === "PRE" ||
    (t.nodeType === vh && t.style !== void 0 && t.style.whiteSpace !== void 0 && t.style.whiteSpace.startsWith("pre"))
  );
}
function RQ(t) {
  const e = t;
  t.parentElement === null && Oe(129);
  let n = e.textContent || "";
  if (
    (function (r) {
      let i,
        s = r.parentNode;
      const o = [r];
      for (; s !== null && (i = Fk.get(s)) === void 0 && !$Q(s); ) o.push(s), (s = s.parentNode);
      const a = i === void 0 ? s : i;
      for (let l = 0; l < o.length; l++) Fk.set(o[l], a);
      return a;
    })(e) !== null
  ) {
    const r = n.split(/(\r?\n|\t)/),
      i = [],
      s = r.length;
    for (let o = 0; o < s; o++) {
      const a = r[o];
      a ===
        `
` ||
      a ===
        `\r
`
        ? i.push(Ri())
        : a === "	"
        ? i.push(jl())
        : a !== "" && i.push(Et(a));
    }
    return { node: i };
  }
  if (((n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " ")), n === "")) return { node: null };
  if (n[0] === " ") {
    let r = e,
      i = !0;
    for (; r !== null && (r = Vk(r, !1)) !== null; ) {
      const s = r.textContent || "";
      if (s.length > 0) {
        /[ \t\n]$/.test(s) && (n = n.slice(1)), (i = !1);
        break;
      }
    }
    i && (n = n.slice(1));
  }
  if (n[n.length - 1] === " ") {
    let r = e,
      i = !0;
    for (; r !== null && (r = Vk(r, !0)) !== null; )
      if ((r.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        i = !1;
        break;
      }
    i && (n = n.slice(0, n.length - 1));
  }
  return n === "" ? { node: null } : { node: Et(n) };
}
function Vk(t, e) {
  let n = t;
  for (;;) {
    let r;
    for (; (r = e ? n.nextSibling : n.previousSibling) === null; ) {
      const s = n.parentElement;
      if (s === null) return null;
      n = s;
    }
    if (((n = r), n.nodeType === vh)) {
      const s = n.style.display;
      if ((s === "" && !wQ(n)) || (s !== "" && !s.startsWith("inline"))) return null;
    }
    let i = n;
    for (; (i = e ? n.firstChild : n.lastChild) !== null; ) n = i;
    if (n.nodeType === lo) return n;
    if (n.nodeName === "BR") return null;
  }
}
const IQ = {
  code: "code",
  em: "italic",
  i: "italic",
  s: "strikethrough",
  strong: "bold",
  sub: "subscript",
  sup: "superscript",
  u: "underline",
};
function bs(t) {
  const e = IQ[t.nodeName.toLowerCase()];
  return e === void 0 ? { node: null } : { forChild: _b(t.style, e), node: null };
}
function Et(t = "") {
  return Zn(new Os(t));
}
function ne(t) {
  return t instanceof Os;
}
function _b(t, e) {
  const n = t.fontWeight,
    r = t.textDecoration.split(" "),
    i = n === "700" || n === "bold",
    s = r.includes("line-through"),
    o = t.fontStyle === "italic",
    a = r.includes("underline"),
    l = t.verticalAlign;
  return (c) => (
    ne(c) &&
      (i && !c.hasFormat("bold") && c.toggleFormat("bold"),
      s && !c.hasFormat("strikethrough") && c.toggleFormat("strikethrough"),
      o && !c.hasFormat("italic") && c.toggleFormat("italic"),
      a && !c.hasFormat("underline") && c.toggleFormat("underline"),
      l !== "sub" || c.hasFormat("subscript") || c.toggleFormat("subscript"),
      l !== "super" || c.hasFormat("superscript") || c.toggleFormat("superscript"),
      e && !c.hasFormat(e) && c.toggleFormat(e)),
    c
  );
}
class yh extends Os {
  static getType() {
    return "tab";
  }
  static clone(e) {
    const n = new yh(e.__key);
    return (n.__text = e.__text), (n.__format = e.__format), (n.__style = e.__style), n;
  }
  constructor(e) {
    super("	", e), (this.__detail = 2);
  }
  static importDOM() {
    return null;
  }
  static importJSON(e) {
    const n = jl();
    return n.setFormat(e.format), n.setStyle(e.style), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "tab", version: 1 };
  }
  setTextContent(e) {
    Oe(126);
  }
  setDetail(e) {
    Oe(127);
  }
  setMode(e) {
    Oe(128);
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
}
function jl() {
  return Zn(new yh());
}
function Eb(t) {
  return t instanceof yh;
}
class NQ {
  constructor(e, n, r) {
    (this._selection = null), (this.key = e), (this.offset = n), (this.type = r);
  }
  is(e) {
    return this.key === e.key && this.offset === e.offset && this.type === e.type;
  }
  isBefore(e) {
    let n = this.getNode(),
      r = e.getNode();
    const i = this.offset,
      s = e.offset;
    if (W(n)) {
      const o = n.getDescendantByIndex(i);
      n = o ?? n;
    }
    if (W(r)) {
      const o = r.getDescendantByIndex(s);
      r = o ?? r;
    }
    return n === r ? i < s : n.isBefore(r);
  }
  getNode() {
    const e = vt(this.key);
    return e === null && Oe(20), e;
  }
  set(e, n, r) {
    const i = this._selection,
      s = this.key;
    (this.key = e),
      (this.offset = n),
      (this.type = r),
      wh() || (Ls() === s && pn(e), i !== null && (i.setCachedNodes(null), (i.dirty = !0)));
  }
}
function Ii(t, e, n) {
  return new NQ(t, e, n);
}
function a0(t, e) {
  let n = e.__key,
    r = t.offset,
    i = "element";
  if (ne(e)) {
    i = "text";
    const s = e.getTextContentSize();
    r > s && (r = s);
  } else if (!W(e)) {
    const s = e.getNextSibling();
    if (ne(s)) (n = s.__key), (r = 0), (i = "text");
    else {
      const o = e.getParent();
      o && ((n = o.__key), (r = e.getIndexWithinParent() + 1));
    }
  }
  t.set(n, r, i);
}
function Bk(t, e) {
  if (W(e)) {
    const n = e.getLastDescendant();
    W(n) || ne(n) ? a0(t, n) : a0(t, e);
  } else a0(t, e);
}
function Ps(t, e, n, r) {
  (t.key = e), (t.offset = n), (t.type = r);
}
class Mm {
  constructor(e) {
    (this._cachedNodes = null), (this._nodes = e), (this.dirty = !1);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    if (!Ht(e)) return !1;
    const n = this._nodes,
      r = e._nodes;
    return n.size === r.size && Array.from(n).every((i) => r.has(i));
  }
  isCollapsed() {
    return !1;
  }
  isBackward() {
    return !1;
  }
  getStartEndPoints() {
    return null;
  }
  add(e) {
    (this.dirty = !0), this._nodes.add(e), (this._cachedNodes = null);
  }
  delete(e) {
    (this.dirty = !0), this._nodes.delete(e), (this._cachedNodes = null);
  }
  clear() {
    (this.dirty = !0), this._nodes.clear(), (this._cachedNodes = null);
  }
  has(e) {
    return this._nodes.has(e);
  }
  clone() {
    return new Mm(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(e) {}
  insertText() {}
  insertNodes(e) {
    const n = this.getNodes(),
      r = n.length,
      i = n[r - 1];
    let s;
    if (ne(i)) s = i.select();
    else {
      const o = i.getIndexWithinParent() + 1;
      s = i.getParentOrThrow().select(o, o);
    }
    s.insertNodes(e);
    for (let o = 0; o < r; o++) n[o].remove();
  }
  getNodes() {
    const e = this._cachedNodes;
    if (e !== null) return e;
    const n = this._nodes,
      r = [];
    for (const i of n) {
      const s = vt(i);
      s !== null && r.push(s);
    }
    return wh() || (this._cachedNodes = r), r;
  }
  getTextContent() {
    const e = this.getNodes();
    let n = "";
    for (let r = 0; r < e.length; r++) n += e[r].getTextContent();
    return n;
  }
}
function ee(t) {
  return t instanceof co;
}
class co {
  constructor(e, n, r, i) {
    (this.anchor = e),
      (this.focus = n),
      (e._selection = this),
      (n._selection = this),
      (this._cachedNodes = null),
      (this.format = r),
      (this.style = i),
      (this.dirty = !1);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    return !!ee(e) && this.anchor.is(e.anchor) && this.focus.is(e.focus) && this.format === e.format && this.style === e.style;
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const e = this._cachedNodes;
    if (e !== null) return e;
    const n = this.anchor,
      r = this.focus,
      i = n.isBefore(r),
      s = i ? n : r,
      o = i ? r : n;
    let a = s.getNode(),
      l = o.getNode();
    const c = s.offset,
      u = o.offset;
    if (W(a)) {
      const f = a.getDescendantByIndex(c);
      a = f ?? a;
    }
    if (W(l)) {
      let f = l.getDescendantByIndex(u);
      f !== null && f !== a && l.getChildAtIndex(u) === f && (f = f.getPreviousSibling()), (l = f ?? l);
    }
    let h;
    return (h = a.is(l) ? (W(a) && a.getChildrenSize() > 0 ? [] : [a]) : a.getNodesBetween(l)), wh() || (this._cachedNodes = h), h;
  }
  setTextNodeRange(e, n, r, i) {
    Ps(this.anchor, e.__key, n, "text"), Ps(this.focus, r.__key, i, "text"), (this._cachedNodes = null), (this.dirty = !0);
  }
  getTextContent() {
    const e = this.getNodes();
    if (e.length === 0) return "";
    const n = e[0],
      r = e[e.length - 1],
      i = this.anchor,
      s = this.focus,
      o = i.isBefore(s),
      [a, l] = OO(this);
    let c = "",
      u = !0;
    for (let h = 0; h < e.length; h++) {
      const f = e[h];
      if (W(f) && !f.isInline())
        u ||
          (c += `
`),
          (u = !f.isEmpty());
      else if (((u = !1), ne(f))) {
        let d = f.getTextContent();
        f === n
          ? f === r
            ? (i.type === "element" && s.type === "element" && s.offset !== i.offset) || (d = a < l ? d.slice(a, l) : d.slice(l, a))
            : (d = o ? d.slice(a) : d.slice(l))
          : f === r && (d = o ? d.slice(0, l) : d.slice(0, a)),
          (c += d);
      } else (!ht(f) && !Hr(f)) || (f === r && this.isCollapsed()) || (c += f.getTextContent());
    }
    return c;
  }
  applyDOMRange(e) {
    const n = Vt(),
      r = n.getEditorState()._selection,
      i = v3(e.startContainer, e.startOffset, e.endContainer, e.endOffset, n, r);
    if (i === null) return;
    const [s, o] = i;
    Ps(this.anchor, s.key, s.offset, s.type), Ps(this.focus, o.key, o.offset, o.type), (this._cachedNodes = null);
  }
  clone() {
    const e = this.anchor,
      n = this.focus;
    return new co(Ii(e.key, e.offset, e.type), Ii(n.key, n.offset, n.type), this.format, this.style);
  }
  toggleFormat(e) {
    (this.format = iO(this.format, e, null)), (this.dirty = !0);
  }
  setStyle(e) {
    (this.style = e), (this.dirty = !0);
  }
  hasFormat(e) {
    const n = ts[e];
    return !!(this.format & n);
  }
  insertRawText(e) {
    const n = e.split(/(\r?\n|\t)/),
      r = [],
      i = n.length;
    for (let s = 0; s < i; s++) {
      const o = n[s];
      o ===
        `
` ||
      o ===
        `\r
`
        ? r.push(Ri())
        : o === "	"
        ? r.push(jl())
        : r.push(Et(o));
    }
    this.insertNodes(r);
  }
  insertText(e) {
    const n = this.anchor,
      r = this.focus,
      i = this.format,
      s = this.style;
    let o = n,
      a = r;
    !this.isCollapsed() && r.isBefore(n) && ((o = r), (a = n)),
      o.type === "element" &&
        (function (O, v, g, x) {
          const y = O.getNode(),
            S = y.getChildAtIndex(O.offset),
            k = Et(),
            b = cn(y) ? at().append(k) : k;
          k.setFormat(g),
            k.setStyle(x),
            S === null ? y.append(b) : S.insertBefore(b),
            O.is(v) && v.set(k.__key, 0, "text"),
            O.set(k.__key, 0, "text");
        })(o, a, i, s);
    const l = o.offset;
    let c = a.offset;
    const u = this.getNodes(),
      h = u.length;
    let f = u[0];
    ne(f) || Oe(26);
    const d = f.getTextContent().length,
      p = f.getParentOrThrow();
    let m = u[h - 1];
    if (
      (h === 1 && a.type === "element" && ((c = d), a.set(o.key, c, "text")),
      this.isCollapsed() &&
        l === d &&
        (f.isSegmented() || f.isToken() || !f.canInsertTextAfter() || (!p.canInsertTextAfter() && f.getNextSibling() === null)))
    ) {
      let O = f.getNextSibling();
      if (
        ((ne(O) && O.canInsertTextBefore() && !Pa(O)) ||
          ((O = Et()), O.setFormat(i), O.setStyle(s), p.canInsertTextAfter() ? f.insertAfter(O) : p.insertAfter(O)),
        O.select(0, 0),
        (f = O),
        e !== "")
      )
        return void this.insertText(e);
    } else if (
      this.isCollapsed() &&
      l === 0 &&
      (f.isSegmented() || f.isToken() || !f.canInsertTextBefore() || (!p.canInsertTextBefore() && f.getPreviousSibling() === null))
    ) {
      let O = f.getPreviousSibling();
      if (
        ((ne(O) && !Pa(O)) || ((O = Et()), O.setFormat(i), p.canInsertTextBefore() ? f.insertBefore(O) : p.insertBefore(O)),
        O.select(),
        (f = O),
        e !== "")
      )
        return void this.insertText(e);
    } else if (f.isSegmented() && l !== d) {
      const O = Et(f.getTextContent());
      O.setFormat(i), f.replace(O), (f = O);
    } else if (!this.isCollapsed() && e !== "") {
      const O = m.getParent();
      if (!p.canInsertTextBefore() || !p.canInsertTextAfter() || (W(O) && (!O.canInsertTextBefore() || !O.canInsertTextAfter())))
        return this.insertText(""), O3(this.anchor, this.focus, null), void this.insertText(e);
    }
    if (h === 1) {
      if (f.isToken()) {
        const x = Et(e);
        return x.select(), void f.replace(x);
      }
      const O = f.getFormat(),
        v = f.getStyle();
      if (l !== c || (O === i && v === s)) {
        if (Eb(f)) {
          const x = Et(e);
          return x.setFormat(i), x.setStyle(s), x.select(), void f.replace(x);
        }
      } else {
        if (f.getTextContent() !== "") {
          const x = Et(e);
          if ((x.setFormat(i), x.setStyle(s), x.select(), l === 0)) f.insertBefore(x, !1);
          else {
            const [y] = f.splitText(l);
            y.insertAfter(x, !1);
          }
          return void (x.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length));
        }
        f.setFormat(i), f.setStyle(s);
      }
      const g = c - l;
      (f = f.spliceText(l, g, e, !0)),
        f.getTextContent() === ""
          ? f.remove()
          : this.anchor.type === "text" && (f.isComposing() ? (this.anchor.offset -= e.length) : ((this.format = O), (this.style = v)));
    } else {
      const O = new Set([...f.getParentKeys(), ...m.getParentKeys()]),
        v = W(f) ? f : f.getParentOrThrow();
      let g = W(m) ? m : m.getParentOrThrow(),
        x = m;
      if (!v.is(g) && g.isInline())
        do (x = g), (g = g.getParentOrThrow());
        while (g.isInline());
      if ((a.type === "text" && (c !== 0 || m.getTextContent() === "")) || (a.type === "element" && m.getIndexWithinParent() < c))
        if (ne(m) && !m.isToken() && c !== m.getTextContentSize()) {
          if (m.isSegmented()) {
            const _ = Et(m.getTextContent());
            m.replace(_), (m = _);
          }
          cn(a.getNode()) || a.type !== "text" || (m = m.spliceText(0, c, "")), O.add(m.__key);
        } else {
          const _ = m.getParentOrThrow();
          _.canBeEmpty() || _.getChildrenSize() !== 1 ? m.remove() : _.remove();
        }
      else O.add(m.__key);
      const y = g.getChildren(),
        S = new Set(u),
        k = v.is(g),
        b = v.isInline() && f.getNextSibling() === null ? v : f;
      for (let _ = y.length - 1; _ >= 0; _--) {
        const T = y[_];
        if (T.is(f) || (W(T) && T.isParentOf(f))) break;
        T.isAttached() && (!S.has(T) || T.is(x) ? k || b.insertAfter(T, !1) : T.remove());
      }
      if (!k) {
        let _ = g,
          T = null;
        for (; _ !== null; ) {
          const P = _.getChildren(),
            M = P.length;
          (M === 0 || P[M - 1].is(T)) && (O.delete(_.__key), (T = _)), (_ = _.getParent());
        }
      }
      if (f.isToken())
        if (l === d) f.select();
        else {
          const _ = Et(e);
          _.select(), f.replace(_);
        }
      else
        (f = f.spliceText(l, d - l, e, !0)),
          f.getTextContent() === "" ? f.remove() : f.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length);
      for (let _ = 1; _ < h; _++) {
        const T = u[_],
          P = T.__key;
        O.has(P) || T.remove();
      }
    }
  }
  removeText() {
    this.insertText("");
  }
  formatText(e) {
    if (this.isCollapsed()) return this.toggleFormat(e), void pn(null);
    const n = this.getNodes(),
      r = [];
    for (const g of n) ne(g) && r.push(g);
    const i = r.length;
    if (i === 0) return this.toggleFormat(e), void pn(null);
    const s = this.anchor,
      o = this.focus,
      a = this.isBackward(),
      l = a ? o : s,
      c = a ? s : o;
    let u = 0,
      h = r[0],
      f = l.type === "element" ? 0 : l.offset;
    if ((l.type === "text" && f === h.getTextContentSize() && ((u = 1), (h = r[1]), (f = 0)), h == null)) return;
    const d = h.getFormatFlags(e, null),
      p = i - 1;
    let m = r[p];
    const O = c.type === "text" ? c.offset : m.getTextContentSize();
    if (h.is(m)) {
      if (f === O) return;
      if (Pa(h) || (f === 0 && O === h.getTextContentSize())) h.setFormat(d);
      else {
        const g = h.splitText(f, O),
          x = f === 0 ? g[0] : g[1];
        x.setFormat(d), l.type === "text" && l.set(x.__key, 0, "text"), c.type === "text" && c.set(x.__key, O - f, "text");
      }
      return void (this.format = d);
    }
    f === 0 || Pa(h) || (([, h] = h.splitText(f)), (f = 0)), h.setFormat(d);
    const v = m.getFormatFlags(e, d);
    O > 0 && (O === m.getTextContentSize() || Pa(m) || ([m] = m.splitText(O)), m.setFormat(v));
    for (let g = u + 1; g < p; g++) {
      const x = r[g],
        y = x.getFormatFlags(e, v);
      x.setFormat(y);
    }
    l.type === "text" && l.set(h.__key, f, "text"), c.type === "text" && c.set(m.__key, O, "text"), (this.format = d | v);
  }
  insertNodes(e) {
    if (e.length === 0) return;
    if (this.anchor.key === "root") {
      this.insertParagraph();
      const p = ce();
      return ee(p) || Oe(134), p.insertNodes(e);
    }
    const n = n0((this.isBackward() ? this.focus : this.anchor).getNode(), Aa),
      r = e[e.length - 1];
    if ("__language" in n && W(n)) {
      if ("__language" in e[0]) this.insertText(e[0].getTextContent());
      else {
        const p = l0(this);
        n.splice(p, 0, e), r.selectEnd();
      }
      return;
    }
    if (!e.some((p) => (W(p) || ht(p)) && !p.isInline())) {
      W(n) || Oe(135);
      const p = l0(this);
      return n.splice(p, 0, e), void r.selectEnd();
    }
    const i = (function (p) {
        const m = at();
        let O = null;
        for (let v = 0; v < p.length; v++) {
          const g = p[v],
            x = Hr(g);
          if (x || (ht(g) && g.isInline()) || (W(g) && g.isInline()) || ne(g) || g.isParentRequired()) {
            if (O === null && ((O = g.createParentElementNode()), m.append(O), x)) continue;
            O !== null && O.append(g);
          } else m.append(g), (O = null);
        }
        return m;
      })(e),
      s = i.getLastDescendant(),
      o = i.getChildren(),
      a = (p) => "__value" in p && "__checked" in p,
      l = !W(n) || !n.isEmpty() ? this.insertParagraph() : null,
      c = o[o.length - 1];
    let u = o[0];
    var h;
    W((h = u)) && Aa(h) && !h.isEmpty() && W(n) && (!n.isEmpty() || a(n)) && (W(n) || Oe(135), n.append(...u.getChildren()), (u = o[1])),
      u &&
        (function (p, m, O) {
          const v = m.getParentOrThrow().getLastChild();
          let g = m;
          const x = [m];
          for (; g !== v; ) g.getNextSibling() || Oe(140), (g = g.getNextSibling()), x.push(g);
          let y = p;
          for (const S of x) y = y.insertAfter(S);
        })(n, u);
    const f = n0(s, Aa);
    l && W(f) && (a(l) || Aa(c)) && (f.append(...l.getChildren()), l.remove()), W(n) && n.isEmpty() && n.remove(), s.selectEnd();
    const d = W(n) ? n.getLastChild() : null;
    Hr(d) && f !== n && d.remove();
  }
  insertParagraph() {
    if (this.anchor.key === "root") {
      const o = at();
      return Be().splice(this.anchor.offset, 0, [o]), o.select(), o;
    }
    const e = l0(this),
      n = n0(this.anchor.getNode(), Aa);
    W(n) || Oe(136);
    const r = n.getChildAtIndex(e),
      i = r ? [r, ...r.getNextSiblings()] : [],
      s = n.insertNewAfter(this, !1);
    return s ? (s.append(...i), s.selectStart(), s) : null;
  }
  insertLineBreak(e) {
    const n = Ri();
    if ((this.insertNodes([n]), e)) {
      const r = n.getParentOrThrow(),
        i = n.getIndexWithinParent();
      r.select(i, i);
    }
  }
  extract() {
    const e = this.getNodes(),
      n = e.length,
      r = n - 1,
      i = this.anchor,
      s = this.focus;
    let o = e[0],
      a = e[r];
    const [l, c] = OO(this);
    if (n === 0) return [];
    if (n === 1) {
      if (ne(o) && !this.isCollapsed()) {
        const h = l > c ? c : l,
          f = l > c ? l : c,
          d = o.splitText(h, f),
          p = h === 0 ? d[0] : d[1];
        return p != null ? [p] : [];
      }
      return [o];
    }
    const u = i.isBefore(s);
    if (ne(o)) {
      const h = u ? l : c;
      h === o.getTextContentSize() ? e.shift() : h !== 0 && (([, o] = o.splitText(h)), (e[0] = o));
    }
    if (ne(a)) {
      const h = a.getTextContent().length,
        f = u ? c : l;
      f === 0 ? e.pop() : f !== h && (([a] = a.splitText(f)), (e[r] = a));
    }
    return e;
  }
  modify(e, n, r) {
    const i = this.focus,
      s = this.anchor,
      o = e === "move",
      a = wu(i, n);
    if (ht(a) && !a.isIsolated()) {
      if (o && a.isKeyboardSelectable()) {
        const d = vO();
        return d.add(a.__key), void yn(d);
      }
      const f = n ? a.getPreviousSibling() : a.getNextSibling();
      if (ne(f)) {
        const d = f.__key,
          p = n ? f.getTextContent().length : 0;
        return i.set(d, p, "text"), void (o && s.set(d, p, "text"));
      }
      {
        const d = a.getParentOrThrow();
        let p, m;
        return (
          W(f) ? ((m = f.__key), (p = n ? f.getChildrenSize() : 0)) : ((p = a.getIndexWithinParent()), (m = d.__key), n || p++),
          i.set(m, p, "element"),
          void (o && s.set(m, p, "element"))
        );
      }
    }
    const l = Vt(),
      c = $i(l._window);
    if (!c) return;
    const u = l._blockCursorElement,
      h = l._rootElement;
    if (
      (h === null || u === null || !W(a) || a.isInline() || a.canBeEmpty() || Cb(u, l, h),
      (function (f, d, p, m) {
        f.modify(d, p, m);
      })(c, e, n ? "backward" : "forward", r),
      c.rangeCount > 0)
    ) {
      const f = c.getRangeAt(0),
        d = this.anchor.getNode(),
        p = cn(d) ? d : OQ(d);
      if ((this.applyDOMRange(f), (this.dirty = !0), !o)) {
        const m = this.getNodes(),
          O = [];
        let v = !1;
        for (let g = 0; g < m.length; g++) {
          const x = m[g];
          sO(x, p) ? O.push(x) : (v = !0);
        }
        if (v && O.length > 0)
          if (n) {
            const g = O[0];
            W(g) ? g.selectStart() : g.getParentOrThrow().selectStart();
          } else {
            const g = O[O.length - 1];
            W(g) ? g.selectEnd() : g.getParentOrThrow().selectEnd();
          }
        (c.anchorNode === f.startContainer && c.anchorOffset === f.startOffset) ||
          (function (g) {
            const x = g.focus,
              y = g.anchor,
              S = y.key,
              k = y.offset,
              b = y.type;
            Ps(y, x.key, x.offset, x.type), Ps(x, S, k, b), (g._cachedNodes = null);
          })(this);
      }
    }
  }
  forwardDeletion(e, n, r) {
    if (
      !r &&
      ((e.type === "element" && W(n) && e.offset === n.getChildrenSize()) || (e.type === "text" && e.offset === n.getTextContentSize()))
    ) {
      const i = n.getParent(),
        s = n.getNextSibling() || (i === null ? null : i.getNextSibling());
      if (W(s) && s.isShadowRoot()) return !0;
    }
    return !1;
  }
  deleteCharacter(e) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const r = this.anchor;
      let i = r.getNode();
      if (this.forwardDeletion(r, i, e)) return;
      const s = this.focus,
        o = wu(s, e);
      if (ht(o) && !o.isIsolated()) {
        if (o.isKeyboardSelectable() && W(i) && i.getChildrenSize() === 0) {
          i.remove();
          const a = vO();
          a.add(o.__key), yn(a);
        } else o.remove(), Vt().dispatchCommand(Bl, void 0);
        return;
      }
      if (!e && W(o) && W(i) && i.isEmpty()) return i.remove(), void o.selectStart();
      if ((this.modify("extend", e, "character"), this.isCollapsed())) {
        if (e && r.offset === 0 && (r.type === "element" ? r.getNode() : r.getNode().getParentOrThrow()).collapseAtStart(this)) return;
      } else {
        const a = s.type === "text" ? s.getNode() : null;
        if (((i = r.type === "text" ? r.getNode() : null), a !== null && a.isSegmented())) {
          const l = s.offset,
            c = a.getTextContentSize();
          if (a.is(i) || (e && l !== c) || (!e && l !== 0)) return void Zk(a, e, l);
        } else if (i !== null && i.isSegmented()) {
          const l = r.offset,
            c = i.getTextContentSize();
          if (i.is(a) || (e && l !== 0) || (!e && l !== c)) return void Zk(i, e, l);
        }
        (function (l, c) {
          const u = l.anchor,
            h = l.focus,
            f = u.getNode(),
            d = h.getNode();
          if (f === d && u.type === "text" && h.type === "text") {
            const p = u.offset,
              m = h.offset,
              O = p < m,
              v = O ? p : m,
              g = O ? m : p,
              x = g - 1;
            v !== x && (GP(f.getTextContent().slice(v, g)) || (c ? (h.offset = x) : (u.offset = x)));
          }
        })(this, e);
      }
    }
    if ((this.removeText(), e && !n && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0)) {
      const r = this.anchor.getNode();
      r.isEmpty() && cn(r.getParent()) && r.getIndexWithinParent() === 0 && r.collapseAtStart(this);
    }
  }
  deleteLine(e) {
    if (this.isCollapsed()) {
      const n = this.anchor.type === "element";
      if (
        (n && this.insertText(" "),
        this.modify("extend", e, "lineboundary"),
        (e ? this.focus : this.anchor).offset === 0 && this.modify("extend", e, "character"),
        n)
      ) {
        const r = e ? this.anchor : this.focus;
        r.set(r.key, r.offset + 1, r.type);
      }
    }
    this.removeText();
  }
  deleteWord(e) {
    if (this.isCollapsed()) {
      const n = this.anchor,
        r = n.getNode();
      if (this.forwardDeletion(n, r, e)) return;
      this.modify("extend", e, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
}
function Ht(t) {
  return t instanceof Mm;
}
function jk(t) {
  const e = t.offset;
  if (t.type === "text") return e;
  const n = t.getNode();
  return e === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function OO(t) {
  const e = t.getStartEndPoints();
  if (e === null) return [0, 0];
  const [n, r] = e;
  return n.type === "element" && r.type === "element" && n.key === r.key && n.offset === r.offset ? [0, 0] : [jk(n), jk(r)];
}
function Zk(t, e, n) {
  const r = t,
    i = r.getTextContent().split(/(?=\s)/g),
    s = i.length;
  let o = 0,
    a = 0;
  for (let c = 0; c < s; c++) {
    const u = c === s - 1;
    if (((a = o), (o += i[c].length), (e && o === n) || o > n || u)) {
      i.splice(c, 1), u && (a = void 0);
      break;
    }
  }
  const l = i.join("").trim();
  l === "" ? r.remove() : (r.setTextContent(l), r.select(a, a));
}
function zk(t, e, n, r) {
  let i,
    s = e;
  if (t.nodeType === vh) {
    let o = !1;
    const a = t.childNodes,
      l = a.length,
      c = r._blockCursorElement;
    s === l && ((o = !0), (s = l - 1));
    let u = a[s],
      h = !1;
    if (u === c) (u = a[s + 1]), (h = !0);
    else if (c !== null) {
      const f = c.parentNode;
      t === f && e > Array.prototype.indexOf.call(f.children, c) && s--;
    }
    if (((i = Qa(u)), ne(i))) s = _k(i, o);
    else {
      let f = Qa(t);
      if (f === null) return null;
      if (W(f)) {
        s = Math.min(f.getChildrenSize(), s);
        let d = f.getChildAtIndex(s);
        if (
          W(d) &&
          (function (p, m, O) {
            const v = p.getParent();
            return O === null || v === null || !v.canBeEmpty() || v !== O.getNode();
          })(d, 0, n)
        ) {
          const p = o ? d.getLastDescendant() : d.getFirstDescendant();
          p === null ? (f = d) : ((d = p), (f = W(d) ? d : d.getParentOrThrow())), (s = 0);
        }
        ne(d) ? ((i = d), (f = null), (s = _k(d, o))) : d !== f && o && !h && s++;
      } else {
        const d = f.getIndexWithinParent();
        (s = e === 0 && ht(f) && Qa(t) === f ? d : d + 1), (f = f.getParentOrThrow());
      }
      if (W(f)) return Ii(f.__key, s, "element");
    }
  } else i = Qa(t);
  return ne(i) ? Ii(i.__key, s, "text") : null;
}
function Wk(t, e, n) {
  const r = t.offset,
    i = t.getNode();
  if (r === 0) {
    const s = i.getPreviousSibling(),
      o = i.getParent();
    if (e) {
      if ((n || !e) && s === null && W(o) && o.isInline()) {
        const a = o.getPreviousSibling();
        ne(a) && ((t.key = a.__key), (t.offset = a.getTextContent().length));
      }
    } else
      W(s) && !n && s.isInline()
        ? ((t.key = s.__key), (t.offset = s.getChildrenSize()), (t.type = "element"))
        : ne(s) && ((t.key = s.__key), (t.offset = s.getTextContent().length));
  } else if (r === i.getTextContent().length) {
    const s = i.getNextSibling(),
      o = i.getParent();
    if (e && W(s) && s.isInline()) (t.key = s.__key), (t.offset = 0), (t.type = "element");
    else if ((n || e) && s === null && W(o) && o.isInline() && !o.canInsertTextAfter()) {
      const a = o.getNextSibling();
      ne(a) && ((t.key = a.__key), (t.offset = 0));
    }
  }
}
function O3(t, e, n) {
  if (t.type === "text" && e.type === "text") {
    const r = t.isBefore(e),
      i = t.is(e);
    Wk(t, r, i), Wk(e, !r, i), i && ((e.key = t.key), (e.offset = t.offset), (e.type = t.type));
    const s = Vt();
    if (s.isComposing() && s._compositionKey !== t.key && ee(n)) {
      const o = n.anchor,
        a = n.focus;
      Ps(t, o.key, o.offset, o.type), Ps(e, a.key, a.offset, a.type);
    }
  }
}
function v3(t, e, n, r, i, s) {
  if (t === null || n === null || !xh(i, t, n)) return null;
  const o = zk(t, e, ee(s) ? s.anchor : null, i);
  if (o === null) return null;
  const a = zk(n, r, ee(s) ? s.focus : null, i);
  if (a === null) return null;
  if (o.type === "element" && a.type === "element") {
    const l = Qa(t),
      c = Qa(n);
    if (ht(l) && ht(c)) return null;
  }
  return O3(o, a, s), [o, a];
}
function np(t) {
  return W(t) && !t.isInline();
}
function x3(t, e, n, r, i, s) {
  const o = vs(),
    a = new co(Ii(t, e, i), Ii(n, r, s), 0, "");
  return (a.dirty = !0), (o._selection = a), a;
}
function Dm() {
  const t = Ii("root", 0, "element"),
    e = Ii("root", 0, "element");
  return new co(t, e, 0, "");
}
function vO() {
  return new Mm(new Set());
}
function Tb(t, e, n, r) {
  const i = n._window;
  if (i === null) return null;
  const s = r || i.event,
    o = s ? s.type : void 0,
    a = o === "selectionchange",
    l =
      !rO &&
      (a ||
        o === "beforeinput" ||
        o === "compositionstart" ||
        o === "compositionend" ||
        (o === "click" && s && s.detail === 3) ||
        o === "drop" ||
        o === void 0);
  let c, u, h, f;
  if (ee(t) && !l) return t.clone();
  if (e === null) return null;
  if (((c = e.anchorNode), (u = e.focusNode), (h = e.anchorOffset), (f = e.focusOffset), a && ee(t) && !xh(n, c, u))) return t.clone();
  const d = v3(c, h, u, f, n, t);
  if (d === null) return null;
  const [p, m] = d;
  return new co(p, m, ee(t) ? t.format : 0, ee(t) ? t.style : "");
}
function ce() {
  return vs()._selection;
}
function ca() {
  return Vt()._editorState._selection;
}
function rp(t, e, n, r = 1) {
  const i = t.anchor,
    s = t.focus,
    o = i.getNode(),
    a = s.getNode();
  if (!e.is(o) && !e.is(a)) return;
  const l = e.__key;
  if (t.isCollapsed()) {
    const c = i.offset;
    if ((n <= c && r > 0) || (n < c && r < 0)) {
      const u = Math.max(0, c + r);
      i.set(l, u, "element"), s.set(l, u, "element"), Uk(t);
    }
  } else {
    const c = t.isBackward(),
      u = c ? s : i,
      h = u.getNode(),
      f = c ? i : s,
      d = f.getNode();
    if (e.is(h)) {
      const p = u.offset;
      ((n <= p && r > 0) || (n < p && r < 0)) && u.set(l, Math.max(0, p + r), "element");
    }
    if (e.is(d)) {
      const p = f.offset;
      ((n <= p && r > 0) || (n < p && r < 0)) && f.set(l, Math.max(0, p + r), "element");
    }
  }
  Uk(t);
}
function Uk(t) {
  const e = t.anchor,
    n = e.offset,
    r = t.focus,
    i = r.offset,
    s = e.getNode(),
    o = r.getNode();
  if (t.isCollapsed()) {
    if (!W(s)) return;
    const a = s.getChildrenSize(),
      l = n >= a,
      c = l ? s.getChildAtIndex(a - 1) : s.getChildAtIndex(n);
    if (ne(c)) {
      let u = 0;
      l && (u = c.getTextContentSize()), e.set(c.__key, u, "text"), r.set(c.__key, u, "text");
    }
  } else {
    if (W(s)) {
      const a = s.getChildrenSize(),
        l = n >= a,
        c = l ? s.getChildAtIndex(a - 1) : s.getChildAtIndex(n);
      if (ne(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), e.set(c.__key, u, "text");
      }
    }
    if (W(o)) {
      const a = o.getChildrenSize(),
        l = i >= a,
        c = l ? o.getChildAtIndex(a - 1) : o.getChildAtIndex(i);
      if (ne(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), r.set(c.__key, u, "text");
      }
    }
  }
}
function ip(t, e, n, r, i) {
  let s = null,
    o = 0,
    a = null;
  r !== null
    ? ((s = r.__key), ne(r) ? ((o = r.getTextContentSize()), (a = "text")) : W(r) && ((o = r.getChildrenSize()), (a = "element")))
    : i !== null && ((s = i.__key), ne(i) ? (a = "text") : W(i) && (a = "element")),
    s !== null && a !== null
      ? t.set(s, o, a)
      : ((o = e.getIndexWithinParent()), o === -1 && (o = n.getChildrenSize()), t.set(n.__key, o, "element"));
}
function Xk(t, e, n, r, i) {
  t.type === "text" ? ((t.key = n), e || (t.offset += i)) : t.offset > r.getIndexWithinParent() && (t.offset -= 1);
}
function LQ(t, e, n, r, i, s, o) {
  const a = r.anchorNode,
    l = r.focusNode,
    c = r.anchorOffset,
    u = r.focusOffset,
    h = document.activeElement;
  if ((i.has("collaboration") && h !== s) || (h !== null && bb(h))) return;
  if (!ee(e)) return void (t !== null && xh(n, a, l) && r.removeAllRanges());
  const f = e.anchor,
    d = e.focus,
    p = f.key,
    m = d.key,
    O = Gd(n, p),
    v = Gd(n, m),
    g = f.offset,
    x = d.offset,
    y = e.format,
    S = e.style,
    k = e.isCollapsed();
  let b = O,
    _ = v,
    T = !1;
  if (f.type === "text") {
    b = qd(O);
    const N = f.getNode();
    T = N.getFormat() !== y || N.getStyle() !== S;
  } else ee(t) && t.anchor.type === "text" && (T = !0);
  var P, M, D, V, Q;
  if (
    (d.type === "text" && (_ = qd(v)),
    b !== null &&
      _ !== null &&
      (k &&
        (t === null || T || (ee(t) && (t.format !== y || t.style !== S))) &&
        ((P = y), (M = S), (D = g), (V = p), (Q = performance.now()), (u3 = [P, M, D, V, Q])),
      c !== g ||
        u !== x ||
        a !== b ||
        l !== _ ||
        (r.type === "Range" && k) ||
        ((h !== null && s.contains(h)) || s.focus({ preventScroll: !0 }), f.type === "element")))
  ) {
    try {
      r.setBaseAndExtent(b, g, _, x);
    } catch {}
    if (!i.has("skip-scroll-into-view") && e.isCollapsed() && s !== null && s === document.activeElement) {
      const N = e instanceof co && e.anchor.type === "element" ? b.childNodes[g] || null : r.rangeCount > 0 ? r.getRangeAt(0) : null;
      if (N !== null) {
        let G;
        if (N instanceof Text) {
          const H = document.createRange();
          H.selectNode(N), (G = H.getBoundingClientRect());
        } else G = N.getBoundingClientRect();
        (function (H, te, le) {
          const $ = le.ownerDocument,
            B = $.defaultView;
          if (B === null) return;
          let { top: ie, bottom: L } = te,
            pe = 0,
            Ce = 0,
            me = le;
          for (; me !== null; ) {
            const Y = me === $.body;
            if (Y) (pe = 0), (Ce = Rm(H).innerHeight);
            else {
              const se = me.getBoundingClientRect();
              (pe = se.top), (Ce = se.bottom);
            }
            let q = 0;
            if ((ie < pe ? (q = -(pe - ie)) : L > Ce && (q = L - Ce), q !== 0))
              if (Y) B.scrollBy(0, q);
              else {
                const se = me.scrollTop;
                me.scrollTop += q;
                const ue = me.scrollTop - se;
                (ie -= ue), (L -= ue);
              }
            if (Y) break;
            me = $m(me);
          }
        })(n, G, s);
      }
    }
    pO = !0;
  }
}
function Zl(t) {
  let e = ce() || ca();
  e === null && (e = Be().selectEnd()), e.insertNodes(t);
}
function l0(t) {
  let e = t;
  t.isCollapsed() || e.removeText();
  const n = ce();
  ee(n) && (e = n), ee(e) || Oe(161);
  const r = e.anchor;
  let i = r.getNode(),
    s = r.offset;
  for (; !Aa(i); ) [i, s] = MQ(i, s);
  return s;
}
function MQ(t, e) {
  const n = t.getParent();
  if (!n) {
    const i = at();
    return Be().append(i), i.select(), [Be(), 0];
  }
  if (ne(t)) {
    const i = t.splitText(e);
    if (i.length === 0) return [n, t.getIndexWithinParent()];
    const s = e === 0 ? 0 : 1;
    return [n, i[0].getIndexWithinParent() + s];
  }
  if (!W(t) || e === 0) return [n, t.getIndexWithinParent()];
  const r = t.getChildAtIndex(e);
  if (r) {
    const i = new co(Ii(t.__key, e, "element"), Ii(t.__key, e, "element"), 0, ""),
      s = t.insertNewAfter(i);
    s && s.append(r, ...r.getNextSiblings());
  }
  return [n, t.getIndexWithinParent() + 1];
}
let an = null,
  ln = null,
  tr = !1,
  c0 = !1,
  yd = 0;
const Hk = { characterData: !0, childList: !0, subtree: !0 };
function wh() {
  return tr || (an !== null && an._readOnly);
}
function Ln() {
  tr && Oe(13);
}
function b3() {
  yd > 99 && Oe(14);
}
function vs() {
  return an === null && Oe(15), an;
}
function Vt() {
  return ln === null && Oe(16), ln;
}
function DQ() {
  return ln;
}
function qk(t, e, n) {
  const r = e.__type,
    i = (function (a, l) {
      const c = a._nodes.get(l);
      return c === void 0 && Oe(30, l), c;
    })(t, r);
  let s = n.get(r);
  s === void 0 && ((s = Array.from(i.transforms)), n.set(r, s));
  const o = s.length;
  for (let a = 0; a < o && (s[a](e), e.isAttached()); a++);
}
function Yk(t, e) {
  return t !== void 0 && t.__key !== e && t.isAttached();
}
function QQ(t) {
  return Pb(t, Vt()._nodes);
}
function Pb(t, e) {
  const n = t.type,
    r = e.get(n);
  r === void 0 && Oe(17, n);
  const i = r.klass;
  t.type !== i.getType() && Oe(18, i.name);
  const s = i.importJSON(t),
    o = t.children;
  if (W(s) && Array.isArray(o))
    for (let a = 0; a < o.length; a++) {
      const l = Pb(o[a], e);
      s.append(l);
    }
  return s;
}
function Gk(t, e) {
  const n = an,
    r = tr,
    i = ln;
  (an = t), (tr = !0), (ln = null);
  try {
    return e();
  } finally {
    (an = n), (tr = r), (ln = i);
  }
}
function Mo(t, e) {
  const n = t._pendingEditorState,
    r = t._rootElement,
    i = t._headless || r === null;
  if (n === null) return;
  const s = t._editorState,
    o = s._selection,
    a = n._selection,
    l = t._dirtyType !== Bo,
    c = an,
    u = tr,
    h = ln,
    f = t._updating,
    d = t._observer;
  let p = null;
  if (((t._pendingEditorState = null), (t._editorState = n), !i && l && d !== null)) {
    (ln = t), (an = n), (tr = !1), (t._updating = !0);
    try {
      const k = t._dirtyType,
        b = t._dirtyElements,
        _ = t._dirtyLeaves;
      d.disconnect(), (p = _Q(s, n, t, k, b, _));
    } catch (k) {
      if ((k instanceof Error && t._onError(k), c0)) throw k;
      return k3(t, null, r, n), zP(t), (t._dirtyType = ml), (c0 = !0), Mo(t, s), void (c0 = !1);
    } finally {
      d.observe(r, Hk), (t._updating = f), (an = c), (tr = u), (ln = h);
    }
  }
  n._readOnly || (n._readOnly = !0);
  const m = t._dirtyLeaves,
    O = t._dirtyElements,
    v = t._normalizedNodes,
    g = t._updateTags,
    x = t._deferred;
  l &&
    ((t._dirtyType = Bo),
    t._cloneNotNeeded.clear(),
    (t._dirtyLeaves = new Set()),
    (t._dirtyElements = new Map()),
    (t._normalizedNodes = new Set()),
    (t._updateTags = new Set())),
    (function (k, b) {
      const _ = k._decorators;
      let T = k._pendingDecorators || _;
      const P = b._nodeMap;
      let M;
      for (M in T) P.has(M) || (T === _ && (T = qP(k)), delete T[M]);
    })(t, n);
  const y = i ? null : $i(t._window);
  if (t._editable && y !== null && (l || a === null || a.dirty)) {
    (ln = t), (an = n);
    try {
      if ((d !== null && d.disconnect(), l || a === null || a.dirty)) {
        const k = t._blockCursorElement;
        k !== null && Cb(k, t, r), LQ(o, a, t, y, g, r);
      }
      xQ(t, r, a), d !== null && d.observe(r, Hk);
    } finally {
      (ln = h), (an = c);
    }
  }
  p !== null &&
    (function (k, b, _, T, P) {
      const M = Array.from(k._listeners.mutation),
        D = M.length;
      for (let V = 0; V < D; V++) {
        const [Q, N] = M[V],
          G = b.get(N);
        G !== void 0 && Q(G, { dirtyLeaves: T, prevEditorState: P, updateTags: _ });
      }
    })(t, p, g, m, s),
    ee(a) || a === null || (o !== null && o.is(a)) || t.dispatchCommand(Bl, void 0);
  const S = t._pendingDecorators;
  S !== null && ((t._decorators = S), (t._pendingDecorators = null), nu("decorator", t, !0, S)),
    (function (k, b, _) {
      const T = Ck(b),
        P = Ck(_);
      T !== P && nu("textcontent", k, !0, P);
    })(t, e || s, n),
    nu("update", t, !0, { dirtyElements: O, dirtyLeaves: m, editorState: n, normalizedNodes: v, prevEditorState: e || s, tags: g }),
    (function (k, b) {
      if (((k._deferred = []), b.length !== 0)) {
        const _ = k._updating;
        k._updating = !0;
        try {
          for (let T = 0; T < b.length; T++) b[T]();
        } finally {
          k._updating = _;
        }
      }
    })(t, x),
    (function (k) {
      const b = k._updates;
      if (b.length !== 0) {
        const _ = b.shift();
        if (_) {
          const [T, P] = _;
          w3(k, T, P);
        }
      }
    })(t);
}
function nu(t, e, n, ...r) {
  const i = e._updating;
  e._updating = n;
  try {
    const s = Array.from(e._listeners[t]);
    for (let o = 0; o < s.length; o++) s[o].apply(null, r);
  } finally {
    e._updating = i;
  }
}
function y3(t, e, n) {
  if (t._updating === !1 || ln !== t) {
    let i = !1;
    return (
      t.update(() => {
        i = y3(t, e, n);
      }),
      i
    );
  }
  const r = yb(t);
  for (let i = 4; i >= 0; i--)
    for (let s = 0; s < r.length; s++) {
      const o = r[s]._commands.get(e);
      if (o !== void 0) {
        const a = o[i];
        if (a !== void 0) {
          const l = Array.from(a),
            c = l.length;
          for (let u = 0; u < c; u++) if (l[u](n, t) === !0) return !0;
        }
      }
    }
  return !1;
}
function Jk(t, e) {
  const n = t._updates;
  let r = e || !1;
  for (; n.length !== 0; ) {
    const i = n.shift();
    if (i) {
      const [s, o] = i;
      let a, l;
      o !== void 0 && ((a = o.onUpdate), (l = o.tag), o.skipTransforms && (r = !0), a && t._deferred.push(a), l && t._updateTags.add(l)),
        s();
    }
  }
  return r;
}
function w3(t, e, n) {
  const r = t._updateTags;
  let i,
    s,
    o = !1,
    a = !1;
  n !== void 0 && ((i = n.onUpdate), (s = n.tag), s != null && r.add(s), (o = n.skipTransforms || !1), (a = n.discrete || !1)),
    i && t._deferred.push(i);
  const l = t._editorState;
  let c = t._pendingEditorState,
    u = !1;
  (c === null || c._readOnly) && ((c = t._pendingEditorState = new Qm(new Map((c || l)._nodeMap))), (u = !0)), (c._flushSync = a);
  const h = an,
    f = tr,
    d = ln,
    p = t._updating;
  (an = c), (tr = !1), (t._updating = !0), (ln = t);
  try {
    u &&
      (t._headless
        ? l._selection !== null && (c._selection = l._selection.clone())
        : (c._selection = (function (g) {
            const x = g.getEditorState()._selection,
              y = $i(g._window);
            return ee(x) || x == null ? Tb(x, y, g, null) : x.clone();
          })(t)));
    const O = t._compositionKey;
    e(),
      (o = Jk(t, o)),
      (function (g, x) {
        const y = x.getEditorState()._selection,
          S = g._selection;
        if (ee(S)) {
          const k = S.anchor,
            b = S.focus;
          let _;
          if ((k.type === "text" && ((_ = k.getNode()), _.selectionTransform(y, S)), b.type === "text")) {
            const T = b.getNode();
            _ !== T && T.selectionTransform(y, S);
          }
        }
      })(c, t),
      t._dirtyType !== Bo &&
        (o
          ? (function (g, x) {
              const y = x._dirtyLeaves,
                S = g._nodeMap;
              for (const k of y) {
                const b = S.get(k);
                ne(b) && b.isAttached() && b.isSimpleText() && !b.isUnmergeable() && Sk(b);
              }
            })(c, t)
          : (function (g, x) {
              const y = x._dirtyLeaves,
                S = x._dirtyElements,
                k = g._nodeMap,
                b = Ls(),
                _ = new Map();
              let T = y,
                P = T.size,
                M = S,
                D = M.size;
              for (; P > 0 || D > 0; ) {
                if (P > 0) {
                  x._dirtyLeaves = new Set();
                  for (const V of T) {
                    const Q = k.get(V);
                    ne(Q) && Q.isAttached() && Q.isSimpleText() && !Q.isUnmergeable() && Sk(Q),
                      Q !== void 0 && Yk(Q, b) && qk(x, Q, _),
                      y.add(V);
                  }
                  if (((T = x._dirtyLeaves), (P = T.size), P > 0)) {
                    yd++;
                    continue;
                  }
                }
                (x._dirtyLeaves = new Set()), (x._dirtyElements = new Map());
                for (const V of M) {
                  const Q = V[0],
                    N = V[1];
                  if (Q !== "root" && !N) continue;
                  const G = k.get(Q);
                  G !== void 0 && Yk(G, b) && qk(x, G, _), S.set(Q, N);
                }
                (T = x._dirtyLeaves), (P = T.size), (M = x._dirtyElements), (D = M.size), yd++;
              }
              (x._dirtyLeaves = y), (x._dirtyElements = S);
            })(c, t),
        Jk(t),
        (function (g, x, y, S) {
          const k = g._nodeMap,
            b = x._nodeMap,
            _ = [];
          for (const [T] of S) {
            const P = b.get(T);
            P !== void 0 && (P.isAttached() || (W(P) && t3(P, T, k, b, _, S), k.has(T) || S.delete(T), _.push(T)));
          }
          for (const T of _) b.delete(T);
          for (const T of y) {
            const P = b.get(T);
            P === void 0 || P.isAttached() || (k.has(T) || y.delete(T), b.delete(T));
          }
        })(l, c, t._dirtyLeaves, t._dirtyElements)),
      O !== t._compositionKey && (c._flushSync = !0);
    const v = c._selection;
    if (ee(v)) {
      const g = c._nodeMap,
        x = v.anchor.key,
        y = v.focus.key;
      (g.get(x) !== void 0 && g.get(y) !== void 0) || Oe(19);
    } else Ht(v) && v._nodes.size === 0 && (c._selection = null);
  } catch (O) {
    return (
      O instanceof Error && t._onError(O),
      (t._pendingEditorState = l),
      (t._dirtyType = ml),
      t._cloneNotNeeded.clear(),
      (t._dirtyLeaves = new Set()),
      t._dirtyElements.clear(),
      void Mo(t)
    );
  } finally {
    (an = h), (tr = f), (ln = d), (t._updating = p), (yd = 0);
  }
  t._dirtyType !== Bo ||
  (function (O, v) {
    const g = v.getEditorState()._selection,
      x = O._selection;
    if (x !== null) {
      if (x.dirty || !x.is(g)) return !0;
    } else if (g !== null) return !0;
    return !1;
  })(c, t)
    ? c._flushSync
      ? ((c._flushSync = !1), Mo(t))
      : u &&
        fQ(() => {
          Mo(t);
        })
    : ((c._flushSync = !1), u && (r.clear(), (t._deferred = []), (t._pendingEditorState = null)));
}
function hr(t, e, n) {
  t._updating ? t._updates.push([e, n]) : w3(t, e, n);
}
class ii extends Lm {
  constructor(e) {
    super(e), (this.__first = null), (this.__last = null), (this.__size = 0), (this.__format = 0), (this.__indent = 0), (this.__dir = null);
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const e = this.getFormat();
    return rQ[e] || "";
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) e.push(n), (n = n.getNextSibling());
    return e;
  }
  getChildrenKeys() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) e.push(n.__key), (n = n.getNextSibling());
    return e;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const e = Vt()._dirtyElements;
    return e !== null && e.has(this.__key);
  }
  isLastChild() {
    const e = this.getLatest(),
      n = this.getParentOrThrow().getLastChild();
    return n !== null && n.is(e);
  }
  getAllTextNodes() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) {
      if ((ne(n) && e.push(n), W(n))) {
        const r = n.getAllTextNodes();
        e.push(...r);
      }
      n = n.getNextSibling();
    }
    return e;
  }
  getFirstDescendant() {
    let e = this.getFirstChild();
    for (; W(e); ) {
      const n = e.getFirstChild();
      if (n === null) break;
      e = n;
    }
    return e;
  }
  getLastDescendant() {
    let e = this.getLastChild();
    for (; W(e); ) {
      const n = e.getLastChild();
      if (n === null) break;
      e = n;
    }
    return e;
  }
  getDescendantByIndex(e) {
    const n = this.getChildren(),
      r = n.length;
    if (e >= r) {
      const s = n[r - 1];
      return (W(s) && s.getLastDescendant()) || s || null;
    }
    const i = n[e];
    return (W(i) && i.getFirstDescendant()) || i || null;
  }
  getFirstChild() {
    const e = this.getLatest().__first;
    return e === null ? null : vt(e);
  }
  getFirstChildOrThrow() {
    const e = this.getFirstChild();
    return e === null && Oe(45, this.__key), e;
  }
  getLastChild() {
    const e = this.getLatest().__last;
    return e === null ? null : vt(e);
  }
  getLastChildOrThrow() {
    const e = this.getLastChild();
    return e === null && Oe(96, this.__key), e;
  }
  getChildAtIndex(e) {
    const n = this.getChildrenSize();
    let r, i;
    if (e < n / 2) {
      for (r = this.getFirstChild(), i = 0; r !== null && i <= e; ) {
        if (i === e) return r;
        (r = r.getNextSibling()), i++;
      }
      return null;
    }
    for (r = this.getLastChild(), i = n - 1; r !== null && i >= e; ) {
      if (i === e) return r;
      (r = r.getPreviousSibling()), i--;
    }
    return null;
  }
  getTextContent() {
    let e = "";
    const n = this.getChildren(),
      r = n.length;
    for (let i = 0; i < r; i++) {
      const s = n[i];
      (e += s.getTextContent()), W(s) && i !== r - 1 && !s.isInline() && (e += ls);
    }
    return e;
  }
  getTextContentSize() {
    let e = 0;
    const n = this.getChildren(),
      r = n.length;
    for (let i = 0; i < r; i++) {
      const s = n[i];
      (e += s.getTextContentSize()), W(s) && i !== r - 1 && !s.isInline() && (e += ls.length);
    }
    return e;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  hasFormat(e) {
    if (e !== "") {
      const n = bk[e];
      return !!(this.getFormat() & n);
    }
    return !1;
  }
  select(e, n) {
    Ln();
    const r = ce();
    let i = e,
      s = n;
    const o = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (e === 0 && n === 0) {
        const l = this.getFirstChild();
        if (ne(l) || W(l)) return l.select(0, 0);
      } else if (!((e !== void 0 && e !== o) || (n !== void 0 && n !== o))) {
        const l = this.getLastChild();
        if (ne(l) || W(l)) return l.select();
      }
    }
    i === void 0 && (i = o), s === void 0 && (s = o);
    const a = this.__key;
    return ee(r) ? (r.anchor.set(a, i, "element"), r.focus.set(a, s, "element"), (r.dirty = !0), r) : x3(a, i, a, s, "element", "element");
  }
  selectStart() {
    const e = this.getFirstDescendant();
    return e ? e.selectStart() : this.select();
  }
  selectEnd() {
    const e = this.getLastDescendant();
    return e ? e.selectEnd() : this.select();
  }
  clear() {
    const e = this.getWritable();
    return this.getChildren().forEach((n) => n.remove()), e;
  }
  append(...e) {
    return this.splice(this.getChildrenSize(), 0, e);
  }
  setDirection(e) {
    const n = this.getWritable();
    return (n.__dir = e), n;
  }
  setFormat(e) {
    return (this.getWritable().__format = e !== "" ? bk[e] : 0), this;
  }
  setIndent(e) {
    return (this.getWritable().__indent = e), this;
  }
  splice(e, n, r) {
    const i = r.length,
      s = this.getChildrenSize(),
      o = this.getWritable(),
      a = o.__key,
      l = [],
      c = [],
      u = this.getChildAtIndex(e + n);
    let h = null,
      f = s - n + i;
    if (e !== 0)
      if (e === s) h = this.getLastChild();
      else {
        const p = this.getChildAtIndex(e);
        p !== null && (h = p.getPreviousSibling());
      }
    if (n > 0) {
      let p = h === null ? this.getFirstChild() : h.getNextSibling();
      for (let m = 0; m < n; m++) {
        p === null && Oe(100);
        const O = p.getNextSibling(),
          v = p.__key;
        Lo(p.getWritable()), c.push(v), (p = O);
      }
    }
    let d = h;
    for (let p = 0; p < i; p++) {
      const m = r[p];
      d !== null && m.is(d) && (h = d = d.getPreviousSibling());
      const O = m.getWritable();
      O.__parent === a && f--, Lo(O);
      const v = m.__key;
      if (d === null) (o.__first = v), (O.__prev = null);
      else {
        const g = d.getWritable();
        (g.__next = v), (O.__prev = g.__key);
      }
      m.__key === a && Oe(76), (O.__parent = a), l.push(v), (d = m);
    }
    if (e + n === s) d !== null && ((d.getWritable().__next = null), (o.__last = d.__key));
    else if (u !== null) {
      const p = u.getWritable();
      if (d !== null) {
        const m = d.getWritable();
        (p.__prev = d.__key), (m.__next = u.__key);
      } else p.__prev = null;
    }
    if (((o.__size = f), c.length)) {
      const p = ce();
      if (ee(p)) {
        const m = new Set(c),
          O = new Set(l),
          { anchor: v, focus: g } = p;
        Kk(v, m, O) && ip(v, v.getNode(), this, h, u),
          Kk(g, m, O) && ip(g, g.getNode(), this, h, u),
          f !== 0 || this.canBeEmpty() || rn(this) || this.remove();
      }
    }
    return o;
  }
  exportJSON() {
    return {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      type: "element",
      version: 1,
    };
  }
  insertNewAfter(e, n) {
    return null;
  }
  canIndent() {
    return !0;
  }
  collapseAtStart(e) {
    return !1;
  }
  excludeFromCopy(e) {
    return !1;
  }
  canReplaceWith(e) {
    return !0;
  }
  canInsertAfter(e) {
    return !0;
  }
  canBeEmpty() {
    return !0;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  isInline() {
    return !1;
  }
  isShadowRoot() {
    return !1;
  }
  canMergeWith(e) {
    return !1;
  }
  extractWithChild(e, n, r) {
    return !1;
  }
}
function W(t) {
  return t instanceof ii;
}
function Kk(t, e, n) {
  let r = t.getNode();
  for (; r; ) {
    const i = r.__key;
    if (e.has(i) && !n.has(i)) return !0;
    r = r.getParent();
  }
  return !1;
}
class Mi extends Lm {
  constructor(e) {
    super(e);
  }
  decorate(e, n) {
    Oe(47);
  }
  isIsolated() {
    return !1;
  }
  isInline() {
    return !0;
  }
  isKeyboardSelectable() {
    return !0;
  }
}
function ht(t) {
  return t instanceof Mi;
}
class zl extends ii {
  static getType() {
    return "root";
  }
  static clone() {
    return new zl();
  }
  constructor() {
    super("root"), (this.__cachedText = null);
  }
  getTopLevelElementOrThrow() {
    Oe(51);
  }
  getTextContent() {
    const e = this.__cachedText;
    return (!wh() && Vt()._dirtyType !== Bo) || e === null ? super.getTextContent() : e;
  }
  remove() {
    Oe(52);
  }
  replace(e) {
    Oe(53);
  }
  insertBefore(e) {
    Oe(54);
  }
  insertAfter(e) {
    Oe(55);
  }
  updateDOM(e, n) {
    return !1;
  }
  append(...e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      W(r) || ht(r) || Oe(56);
    }
    return super.append(...e);
  }
  static importJSON(e) {
    const n = Be();
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      type: "root",
      version: 1,
    };
  }
  collapseAtStart() {
    return !0;
  }
}
function cn(t) {
  return t instanceof zl;
}
function Ab() {
  return new Qm(new Map([["root", new zl()]]));
}
function S3(t) {
  const e = t.exportJSON(),
    n = t.constructor;
  if ((e.type !== n.getType() && Oe(130, n.name), W(t))) {
    const r = e.children;
    Array.isArray(r) || Oe(59, n.name);
    const i = t.getChildren();
    for (let s = 0; s < i.length; s++) {
      const o = S3(i[s]);
      r.push(o);
    }
  }
  return e;
}
class Qm {
  constructor(e, n) {
    (this._nodeMap = e), (this._selection = n || null), (this._flushSync = !1), (this._readOnly = !1);
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(e) {
    return Gk(this, e);
  }
  clone(e) {
    const n = new Qm(this._nodeMap, e === void 0 ? this._selection : e);
    return (n._readOnly = !0), n;
  }
  toJSON() {
    return Gk(this, () => ({ root: S3(Be()) }));
  }
}
class $b extends ii {
  static getType() {
    return "artificial";
  }
  createDOM(e) {
    return document.createElement("div");
  }
}
class ua extends ii {
  constructor(e) {
    super(e), (this.__textFormat = 0);
  }
  static getType() {
    return "paragraph";
  }
  getTextFormat() {
    return this.getLatest().__textFormat;
  }
  setTextFormat(e) {
    const n = this.getWritable();
    return (n.__textFormat = e), n;
  }
  hasTextFormat(e) {
    const n = ts[e];
    return !!(this.getTextFormat() & n);
  }
  static clone(e) {
    return new ua(e.__key);
  }
  createDOM(e) {
    const n = document.createElement("p"),
      r = Kc(e.theme, "paragraph");
    return r !== void 0 && n.classList.add(...r), n;
  }
  updateDOM(e, n, r) {
    return !1;
  }
  static importDOM() {
    return { p: (e) => ({ conversion: FQ, priority: 0 }) };
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (n && qr(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
      const s = this.getIndent();
      s > 0 && (n.style.textIndent = 20 * s + "px");
    }
    return { element: n };
  }
  static importJSON(e) {
    const n = at();
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n.setTextFormat(e.textFormat), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), textFormat: this.getTextFormat(), type: "paragraph", version: 1 };
  }
  insertNewAfter(e, n) {
    const r = at();
    r.setTextFormat(e.format);
    const i = this.getDirection();
    return r.setDirection(i), r.setFormat(this.getFormatType()), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const e = this.getChildren();
    if (e.length === 0 || (ne(e[0]) && e[0].getTextContent().trim() === "")) {
      if (this.getNextSibling() !== null) return this.selectNext(), this.remove(), !0;
      if (this.getPreviousSibling() !== null) return this.selectPrevious(), this.remove(), !0;
    }
    return !1;
  }
}
function FQ(t) {
  const e = at();
  if (t.style) {
    e.setFormat(t.style.textAlign);
    const n = parseInt(t.style.textIndent, 10) / 20;
    n > 0 && e.setIndent(n);
  }
  return { node: e };
}
function at() {
  return Zn(new ua());
}
function cs(t) {
  return t instanceof ua;
}
const Ue = 0,
  Ot = 1,
  sp = 3,
  Gn = 4;
function k3(t, e, n, r) {
  const i = t._keyToDOMMap;
  i.clear(),
    (t._editorState = Ab()),
    (t._pendingEditorState = r),
    (t._compositionKey = null),
    (t._dirtyType = Bo),
    t._cloneNotNeeded.clear(),
    (t._dirtyLeaves = new Set()),
    t._dirtyElements.clear(),
    (t._normalizedNodes = new Set()),
    (t._updateTags = new Set()),
    (t._updates = []),
    (t._blockCursorElement = null);
  const s = t._observer;
  s !== null && (s.disconnect(), (t._observer = null)),
    e !== null && (e.textContent = ""),
    n !== null && ((n.textContent = ""), i.set("root", n));
}
function Rb(t) {
  const e = t || {},
    n = DQ(),
    r = e.theme || {},
    i = t === void 0 ? n : e.parentEditor || null,
    s = e.disableEvents || !1,
    o = Ab(),
    a = e.namespace || (i !== null ? i._config.namespace : JP()),
    l = e.editorState,
    c = [zl, Os, bh, yh, ua, $b, ...(e.nodes || [])],
    { onError: u, html: h } = e,
    f = e.editable === void 0 || e.editable;
  let d;
  if (t === void 0 && n !== null) d = n._nodes;
  else {
    d = new Map();
    for (let m = 0; m < c.length; m++) {
      let O = c[m],
        v = null,
        g = null;
      if (typeof O != "function") {
        const k = O;
        (O = k.replace), (v = k.with), (g = k.withKlass || null);
      }
      const x = O.getType(),
        y = O.transform(),
        S = new Set();
      y !== null && S.add(y),
        d.set(x, { exportDOM: h && h.export ? h.export.get(O) : void 0, klass: O, replace: v, replaceWithKlass: g, transforms: S });
    }
  }
  const p = new VQ(
    o,
    i,
    d,
    { disableEvents: s, namespace: a, theme: r },
    u || console.error,
    (function (m, O) {
      const v = new Map(),
        g = new Set(),
        x = (y) => {
          Object.keys(y).forEach((S) => {
            let k = v.get(S);
            k === void 0 && ((k = []), v.set(S, k)), k.push(y[S]);
          });
        };
      return (
        m.forEach((y) => {
          const S = y.klass.importDOM;
          if (S == null || g.has(S)) return;
          g.add(S);
          const k = S.call(y.klass);
          k !== null && x(k);
        }),
        O && x(O),
        v
      );
    })(d, h ? h.import : void 0),
    f
  );
  return l !== void 0 && ((p._pendingEditorState = l), (p._dirtyType = ml)), p;
}
class VQ {
  constructor(e, n, r, i, s, o, a) {
    (this._parentEditor = n),
      (this._rootElement = null),
      (this._editorState = e),
      (this._pendingEditorState = null),
      (this._compositionKey = null),
      (this._deferred = []),
      (this._keyToDOMMap = new Map()),
      (this._updates = []),
      (this._updating = !1),
      (this._listeners = {
        decorator: new Set(),
        editable: new Set(),
        mutation: new Map(),
        root: new Set(),
        textcontent: new Set(),
        update: new Set(),
      }),
      (this._commands = new Map()),
      (this._config = i),
      (this._nodes = r),
      (this._decorators = {}),
      (this._pendingDecorators = null),
      (this._dirtyType = Bo),
      (this._cloneNotNeeded = new Set()),
      (this._dirtyLeaves = new Set()),
      (this._dirtyElements = new Map()),
      (this._normalizedNodes = new Set()),
      (this._updateTags = new Set()),
      (this._observer = null),
      (this._key = JP()),
      (this._onError = s),
      (this._htmlConversions = o),
      (this._editable = a),
      (this._headless = n !== null && n._headless),
      (this._window = null),
      (this._blockCursorElement = null);
  }
  isComposing() {
    return this._compositionKey != null;
  }
  registerUpdateListener(e) {
    const n = this._listeners.update;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerEditableListener(e) {
    const n = this._listeners.editable;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerDecoratorListener(e) {
    const n = this._listeners.decorator;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerTextContentListener(e) {
    const n = this._listeners.textcontent;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerRootListener(e) {
    const n = this._listeners.root;
    return (
      e(this._rootElement, null),
      n.add(e),
      () => {
        e(null, this._rootElement), n.delete(e);
      }
    );
  }
  registerCommand(e, n, r) {
    r === void 0 && Oe(35);
    const i = this._commands;
    i.has(e) || i.set(e, [new Set(), new Set(), new Set(), new Set(), new Set()]);
    const s = i.get(e);
    s === void 0 && Oe(36, String(e));
    const o = s[r];
    return (
      o.add(n),
      () => {
        o.delete(n), s.every((a) => a.size === 0) && i.delete(e);
      }
    );
  }
  registerMutationListener(e, n) {
    let r = this._nodes.get(e.getType());
    r === void 0 && Oe(37, e.name);
    let i = e,
      s = null;
    for (; (s = r.replaceWithKlass); ) (i = s), (r = this._nodes.get(s.getType())), r === void 0 && Oe(37, s.name);
    const o = this._listeners.mutation;
    return (
      o.set(n, i),
      () => {
        o.delete(n);
      }
    );
  }
  registerNodeTransformToKlass(e, n) {
    const r = e.getType(),
      i = this._nodes.get(r);
    return i === void 0 && Oe(37, e.name), i.transforms.add(n), i;
  }
  registerNodeTransform(e, n) {
    const r = this.registerNodeTransformToKlass(e, n),
      i = [r],
      s = r.replaceWithKlass;
    if (s != null) {
      const l = this.registerNodeTransformToKlass(s, n);
      i.push(l);
    }
    var o, a;
    return (
      (o = this),
      (a = e.getType()),
      hr(
        o,
        () => {
          const l = vs();
          if (l.isEmpty()) return;
          if (a === "root") return void Be().markDirty();
          const c = l._nodeMap;
          for (const [, u] of c) u.markDirty();
        },
        o._pendingEditorState === null ? { tag: "history-merge" } : void 0
      ),
      () => {
        i.forEach((l) => l.transforms.delete(n));
      }
    );
  }
  hasNode(e) {
    return this._nodes.has(e.getType());
  }
  hasNodes(e) {
    return e.every(this.hasNode.bind(this));
  }
  dispatchCommand(e, n) {
    return xe(this, e, n);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(e) {
    const n = this._rootElement;
    if (e !== n) {
      const r = Kc(this._config.theme, "root"),
        i = this._pendingEditorState || this._editorState;
      if (
        ((this._rootElement = e),
        k3(this, n, e, i),
        n !== null && (this._config.disableEvents || EQ(n), r != null && n.classList.remove(...r)),
        e !== null)
      ) {
        const s = (function (a) {
            const l = a.ownerDocument;
            return (l && l.defaultView) || null;
          })(e),
          o = e.style;
        (o.userSelect = "text"),
          (o.whiteSpace = "pre-wrap"),
          (o.wordBreak = "break-word"),
          e.setAttribute("data-lexical-editor", "true"),
          (this._window = s),
          (this._dirtyType = ml),
          zP(this),
          this._updateTags.add("history-merge"),
          Mo(this),
          this._config.disableEvents ||
            (function (a, l) {
              const c = a.ownerDocument,
                u = tp.get(c);
              (u === void 0 || u < 1) && c.addEventListener("selectionchange", p3), tp.set(c, (u || 0) + 1), (a.__lexicalEditor = l);
              const h = d3(a);
              for (let f = 0; f < dO.length; f++) {
                const [d, p] = dO[f],
                  m =
                    typeof p == "function"
                      ? (O) => {
                          Mk(O) || (Lk(O), (l.isEditable() || d === "click") && p(O, l));
                        }
                      : (O) => {
                          if (Mk(O)) return;
                          Lk(O);
                          const v = l.isEditable();
                          switch (d) {
                            case "cut":
                              return v && xe(l, ab, O);
                            case "copy":
                              return xe(l, _m, O);
                            case "paste":
                              return v && xe(l, mh, O);
                            case "dragstart":
                              return v && xe(l, Cm, O);
                            case "dragover":
                              return v && xe(l, ob, O);
                            case "dragend":
                              return v && xe(l, ZD, O);
                            case "focus":
                              return v && xe(l, lb, O);
                            case "blur":
                              return v && xe(l, Em, O);
                            case "drop":
                              return v && xe(l, sb, O);
                          }
                        };
                a.addEventListener(d, m),
                  h.push(() => {
                    a.removeEventListener(d, m);
                  });
              }
            })(e, this),
          r != null && e.classList.add(...r);
      } else (this._editorState = i), (this._pendingEditorState = null), (this._window = null);
      nu("root", this, !1, e, n);
    }
  }
  getElementByKey(e) {
    return this._keyToDOMMap.get(e) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(e, n) {
    e.isEmpty() && Oe(38), ZP(this);
    const r = this._pendingEditorState,
      i = this._updateTags,
      s = n !== void 0 ? n.tag : null;
    r === null || r.isEmpty() || (s != null && i.add(s), Mo(this)),
      (this._pendingEditorState = e),
      (this._dirtyType = ml),
      this._dirtyElements.set("root", !1),
      (this._compositionKey = null),
      s != null && i.add(s),
      Mo(this);
  }
  parseEditorState(e, n) {
    return (function (r, i, s) {
      const o = Ab(),
        a = an,
        l = tr,
        c = ln,
        u = i._dirtyElements,
        h = i._dirtyLeaves,
        f = i._cloneNotNeeded,
        d = i._dirtyType;
      (i._dirtyElements = new Map()),
        (i._dirtyLeaves = new Set()),
        (i._cloneNotNeeded = new Set()),
        (i._dirtyType = 0),
        (an = o),
        (tr = !1),
        (ln = i);
      try {
        const p = i._nodes;
        Pb(r.root, p), s && s(), (o._readOnly = !0);
      } catch (p) {
        p instanceof Error && i._onError(p);
      } finally {
        (i._dirtyElements = u), (i._dirtyLeaves = h), (i._cloneNotNeeded = f), (i._dirtyType = d), (an = a), (tr = l), (ln = c);
      }
      return o;
    })(typeof e == "string" ? JSON.parse(e) : e, this, n);
  }
  update(e, n) {
    hr(this, e, n);
  }
  focus(e, n = {}) {
    const r = this._rootElement;
    r !== null &&
      (r.setAttribute("autocapitalize", "off"),
      hr(
        this,
        () => {
          const i = ce(),
            s = Be();
          i !== null ? (i.dirty = !0) : s.getChildrenSize() !== 0 && (n.defaultSelection === "rootStart" ? s.selectStart() : s.selectEnd());
        },
        {
          onUpdate: () => {
            r.removeAttribute("autocapitalize"), e && e();
          },
          tag: "focus",
        }
      ),
      this._pendingEditorState === null && r.removeAttribute("autocapitalize"));
  }
  blur() {
    const e = this._rootElement;
    e !== null && e.blur();
    const n = $i(this._window);
    n !== null && n.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(e) {
    this._editable !== e && ((this._editable = e), nu("editable", this, !0, e));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
}
function BQ(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var C3 = BQ(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const jQ = new Map();
function ZQ(t) {
  const e = {},
    n = t.split(";");
  for (const r of n)
    if (r !== "") {
      const [i, s] = r.split(/:([^]+)/);
      i && s && (e[i.trim()] = s.trim());
    }
  return e;
}
function Ib(t) {
  const e = t.constructor.clone(t);
  return (
    (e.__parent = t.__parent),
    (e.__next = t.__next),
    (e.__prev = t.__prev),
    W(t) && W(e)
      ? ((r = t),
        ((n = e).__first = r.__first),
        (n.__last = r.__last),
        (n.__size = r.__size),
        (n.__format = r.__format),
        (n.__indent = r.__indent),
        (n.__dir = r.__dir),
        n)
      : ne(t) && ne(e)
      ? (function (i, s) {
          return (i.__format = s.__format), (i.__style = s.__style), (i.__mode = s.__mode), (i.__detail = s.__detail), i;
        })(e, t)
      : cs(t) && cs(e)
      ? (function (i, s) {
          return (i.__textFormat = s.__textFormat), i;
        })(e, t)
      : e
  );
  var n, r;
}
function _3(t, e) {
  const n = t.getStartEndPoints();
  if (e.isSelected(t) && !e.isSegmented() && !e.isToken() && n !== null) {
    const [r, i] = n,
      s = t.isBackward(),
      o = r.getNode(),
      a = i.getNode(),
      l = e.is(o),
      c = e.is(a);
    if (l || c) {
      const [u, h] = OO(t),
        f = o.is(a),
        d = e.is(s ? a : o),
        p = e.is(s ? o : a);
      let m,
        O = 0;
      return (
        f ? ((O = u > h ? h : u), (m = u > h ? u : h)) : d ? ((O = s ? h : u), (m = void 0)) : p && ((O = 0), (m = s ? u : h)),
        (e.__text = e.__text.slice(O, m)),
        e
      );
    }
  }
  return e;
}
function e2(t) {
  if (t.type === "text") return t.offset === t.getNode().getTextContentSize();
  const e = t.getNode();
  return W(e) || C3(177), t.offset === e.getChildrenSize();
}
function zQ(t, e, n) {
  let r = e.getNode(),
    i = n;
  if (W(r)) {
    const s = r.getDescendantByIndex(e.offset);
    s !== null && (r = s);
  }
  for (; i > 0 && r !== null; ) {
    if (W(r)) {
      const c = r.getLastDescendant();
      c !== null && (r = c);
    }
    let s = r.getPreviousSibling(),
      o = 0;
    if (s === null) {
      let c = r.getParentOrThrow(),
        u = c.getPreviousSibling();
      for (; u === null; ) {
        if (((c = c.getParent()), c === null)) {
          s = null;
          break;
        }
        u = c.getPreviousSibling();
      }
      c !== null && ((o = c.isInline() ? 0 : 2), (s = u));
    }
    let a = r.getTextContent();
    a === "" &&
      W(r) &&
      !r.isInline() &&
      (a = `

`);
    const l = a.length;
    if (!ne(r) || i >= l) {
      const c = r.getParent();
      r.remove(), c == null || c.getChildrenSize() !== 0 || cn(c) || c.remove(), (i -= l + o), (r = s);
    } else {
      const c = r.getKey(),
        u = t.getEditorState().read(() => {
          const d = vt(c);
          return ne(d) && d.isSimpleText() ? d.getTextContent() : null;
        }),
        h = l - i,
        f = a.slice(0, h);
      if (u !== null && u !== a) {
        const d = ca();
        let p = r;
        if (r.isSimpleText()) r.setTextContent(u);
        else {
          const m = Et(u);
          r.replace(m), (p = m);
        }
        if (ee(d) && d.isCollapsed()) {
          const m = d.anchor.offset;
          p.select(m, m);
        }
      } else if (r.isSimpleText()) {
        const d = e.key === c;
        let p = e.offset;
        p < i && (p = l);
        const m = d ? p - i : 0,
          O = d ? p : h;
        if (d && m === 0) {
          const [v] = r.splitText(m, O);
          v.remove();
        } else {
          const [, v] = r.splitText(m, O);
          v.remove();
        }
      } else {
        const d = Et(f);
        r.replace(d);
      }
      i = 0;
    }
  }
}
function WQ(t) {
  const e = t.getStyle(),
    n = ZQ(e);
  jQ.set(e, n);
}
function UQ(t, e) {
  if (t === null) return;
  const n = t.getStartEndPoints(),
    r = n ? n[0] : null;
  if (r !== null && r.key === "root") {
    const o = e(),
      a = Be(),
      l = a.getFirstChild();
    return void (l ? l.replace(o, !0) : a.append(o));
  }
  const i = t.getNodes(),
    s =
      r !== null &&
      (function (o, a) {
        let l = o;
        for (; l !== null && l.getParent() !== null && !a(l); ) l = l.getParentOrThrow();
        return a(l) ? l : null;
      })(r.getNode(), r2);
  s && i.indexOf(s) === -1 && i.push(s);
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    if (!r2(a)) continue;
    W(a) || C3(178);
    const l = e();
    l.setFormat(a.getFormatType()), l.setIndent(a.getIndent()), a.replace(l, !0);
  }
}
function t2(t, e) {
  const n = wu(t.focus, e);
  return (ht(n) && !n.isIsolated()) || (W(n) && !n.isInline() && !n.canBeEmpty());
}
function XQ(t, e, n, r) {
  t.modify(e ? "extend" : "move", n, r);
}
function HQ(t) {
  const e = t.anchor.getNode();
  return (cn(e) ? e : e.getParentOrThrow()).getDirection() === "rtl";
}
function n2(t, e, n) {
  const r = HQ(t);
  XQ(t, e, n ? !r : r, "character");
}
function r2(t) {
  if (ht(t) || !W(t) || rn(t)) return !1;
  const e = t.getFirstChild(),
    n = e === null || Hr(e) || ne(e) || e.isInline();
  return !t.isInline() && t.canBeEmpty() !== !1 && n;
}
const qQ = zQ;
function YQ(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var E3 = YQ(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const Nb = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  GQ = Nb && "documentMode" in document ? document.documentMode : null,
  JQ = Nb && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
!(!Nb || !("InputEvent" in window) || GQ) && "getTargetRanges" in new window.InputEvent("input");
function T3(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
function ir(...t) {
  return () => {
    for (let e = t.length - 1; e >= 0; e--) t[e]();
    t.length = 0;
  };
}
const KQ = JQ;
function Yr(t, ...e) {
  const n = T3(...e);
  n.length > 0 && t.classList.add(...n);
}
function Fm(t, ...e) {
  const n = T3(...e);
  n.length > 0 && t.classList.remove(...n);
}
function P3(t, e) {
  let n = t;
  for (; n != null; ) {
    if (n instanceof e) return n;
    n = n.getParent();
  }
  return null;
}
function A3(t) {
  const e = Wl(t, (n) => W(n) && !n.isInline());
  return W(e) || E3(4, t.__key), e;
}
const Wl = (t, e) => {
  let n = t;
  for (; n !== Be() && n != null; ) {
    if (e(n)) return n;
    n = n.getParent();
  }
  return null;
};
function eF(t, e) {
  const n = new Map(),
    r = t._pendingEditorState;
  for (const [s, o] of e._nodeMap) {
    const a = Ib(o);
    ne(a) && (ne(o) || E3(180), (a.__text = o.__text)), n.set(s, a);
  }
  r && (r._nodeMap = n), (t._dirtyType = 2);
  const i = e._selection;
  yn(i === null ? null : i.clone());
}
function $3(t) {
  const e = ce() || ca();
  if (ee(e)) {
    const { focus: n } = e,
      r = n.getNode(),
      i = n.offset;
    if (rn(r)) {
      const s = r.getChildAtIndex(i);
      s == null ? r.append(t) : s.insertBefore(t), t.selectNext();
    } else {
      let s, o;
      ne(r) ? ((s = r.getParentOrThrow()), (o = r.getIndexWithinParent()), i > 0 && ((o += 1), r.splitText(i))) : ((s = r), (o = i));
      const [, a] = bQ(s, o);
      a.insertBefore(t), a.selectStart();
    }
  } else {
    if (e != null) {
      const r = e.getNodes();
      r[r.length - 1].getTopLevelElementOrThrow().insertAfter(t);
    } else Be().append(t);
    const n = at();
    t.insertAfter(n), n.select();
  }
  return t.getLatest();
}
function Lb(t, e) {
  const n = e();
  return t.replace(n), n.append(t), n;
}
function Ms(t, e) {
  return t !== null && Object.getPrototypeOf(t).constructor.name === e.name;
}
function tF(t, e) {
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const i = e(t[r]);
    i !== null && n.push(i);
  }
  return n;
}
function nF(t) {
  if (KQ) return 1;
  let e = 1;
  for (; t; ) (e *= Number(window.getComputedStyle(t).getPropertyValue("zoom"))), (t = t.parentElement);
  return e;
}
const vf = 0,
  xO = 1,
  bO = 2,
  Wr = 0,
  rF = 1,
  i2 = 2,
  iF = 3,
  sF = 4;
function oF(t, e, n, r, i) {
  if (t === null || (n.size === 0 && r.size === 0 && !i)) return Wr;
  const s = e._selection,
    o = t._selection;
  if (i) return rF;
  if (!(ee(s) && ee(o) && o.isCollapsed() && s.isCollapsed())) return Wr;
  const a = (function (v, g, x) {
    const y = v._nodeMap,
      S = [];
    for (const k of g) {
      const b = y.get(k);
      b !== void 0 && S.push(b);
    }
    for (const [k, b] of x) {
      if (!b) continue;
      const _ = y.get(k);
      _ === void 0 || cn(_) || S.push(_);
    }
    return S;
  })(e, n, r);
  if (a.length === 0) return Wr;
  if (a.length > 1) {
    const v = e._nodeMap,
      g = v.get(s.anchor.key),
      x = v.get(o.anchor.key);
    return g && x && !t._nodeMap.has(g.__key) && ne(g) && g.__text.length === 1 && s.anchor.offset === 1 ? i2 : Wr;
  }
  const l = a[0],
    c = t._nodeMap.get(l.__key);
  if (!ne(c) || !ne(l) || c.__mode !== l.__mode) return Wr;
  const u = c.__text,
    h = l.__text;
  if (u === h) return Wr;
  const f = s.anchor,
    d = o.anchor;
  if (f.key !== d.key || f.type !== "text") return Wr;
  const p = f.offset,
    m = d.offset,
    O = h.length - u.length;
  return O === 1 && m === p - 1 ? i2 : O === -1 && m === p + 1 ? iF : O === -1 && m === p ? sF : Wr;
}
function aF(t, e) {
  let n = Date.now(),
    r = Wr;
  return (i, s, o, a, l, c) => {
    const u = Date.now();
    if (c.has("historic")) return (r = Wr), (n = u), bO;
    const h = oF(i, s, a, l, t.isComposing()),
      f = (() => {
        const d = o === null || o.editor === t,
          p = c.has("history-push");
        if (!p && d && c.has("history-merge")) return vf;
        if (i === null) return xO;
        const m = s._selection;
        return a.size > 0 || l.size > 0
          ? (p === !1 && h !== Wr && h === r && u < n + e && d) ||
            (a.size === 1 &&
              (function (O, v, g) {
                const x = v._nodeMap.get(O),
                  y = g._nodeMap.get(O),
                  S = v._selection,
                  k = g._selection;
                let b = !1;
                return (
                  ee(S) &&
                    ee(k) &&
                    (b = S.anchor.type === "element" && S.focus.type === "element" && k.anchor.type === "text" && k.focus.type === "text"),
                  !(b || !ne(x) || !ne(y)) &&
                    x.__type === y.__type &&
                    x.__text === y.__text &&
                    x.__mode === y.__mode &&
                    x.__detail === y.__detail &&
                    x.__style === y.__style &&
                    x.__format === y.__format &&
                    x.__parent === y.__parent
                );
              })(Array.from(a)[0], i, s))
            ? vf
            : xO
          : m !== null
          ? vf
          : bO;
      })();
    return (n = u), (r = h), f;
  };
}
function s2(t) {
  (t.undoStack = []), (t.redoStack = []), (t.current = null);
}
function lF(t, e, n) {
  const r = aF(t, n);
  return ir(
    t.registerCommand(
      wm,
      () => (
        (function (s, o) {
          const a = o.redoStack,
            l = o.undoStack;
          if (l.length !== 0) {
            const c = o.current,
              u = l.pop();
            c !== null && (a.push(c), s.dispatchCommand(Nc, !0)),
              l.length === 0 && s.dispatchCommand(Lc, !1),
              (o.current = u || null),
              u && u.editor.setEditorState(u.editorState, { tag: "historic" });
          }
        })(t, e),
        !0
      ),
      Ue
    ),
    t.registerCommand(
      Sm,
      () => (
        (function (s, o) {
          const a = o.redoStack,
            l = o.undoStack;
          if (a.length !== 0) {
            const c = o.current;
            c !== null && (l.push(c), s.dispatchCommand(Lc, !0));
            const u = a.pop();
            a.length === 0 && s.dispatchCommand(Nc, !1),
              (o.current = u || null),
              u && u.editor.setEditorState(u.editorState, { tag: "historic" });
          }
        })(t, e),
        !0
      ),
      Ue
    ),
    t.registerCommand(zD, () => (s2(e), !1), Ue),
    t.registerCommand(WD, () => (s2(e), t.dispatchCommand(Nc, !1), t.dispatchCommand(Lc, !1), !0), Ue),
    t.registerUpdateListener(({ editorState: s, prevEditorState: o, dirtyLeaves: a, dirtyElements: l, tags: c }) => {
      const u = e.current,
        h = e.redoStack,
        f = e.undoStack,
        d = u === null ? null : u.editorState;
      if (u !== null && s === d) return;
      const p = r(o, s, u, a, l, c);
      if (p === xO)
        h.length !== 0 && ((e.redoStack = []), t.dispatchCommand(Nc, !1)), u !== null && (f.push({ ...u }), t.dispatchCommand(Lc, !0));
      else if (p === bO) return;
      e.current = { editor: t, editorState: s };
    })
  );
}
function R3() {
  return { current: null, redoStack: [], undoStack: [] };
}
function I3({ externalHistoryState: t }) {
  const [e] = jn();
  return (
    (function (n, r, i = 1e3) {
      const s = w.useMemo(() => r || R3(), [r]);
      w.useEffect(() => lF(n, s, i), [i, n, s]);
    })(e, t),
    null
  );
}
function cF(t, e) {
  const n = e.body ? e.body.childNodes : [];
  let r = [];
  const i = [];
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    if (!L3.has(o.nodeName)) {
      const a = M3(o, t, i, !1);
      a !== null && (r = r.concat(a));
    }
  }
  return (
    (function (s) {
      for (const o of s) o.getNextSibling() instanceof $b && o.insertAfter(Ri());
      for (const o of s) {
        const a = o.getChildren();
        for (const l of a) o.insertBefore(l);
        o.remove();
      }
    })(i),
    r
  );
}
function uF(t, e) {
  if (typeof document > "u" || (typeof window > "u" && global.window === void 0))
    throw new Error(
      "To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function."
    );
  const n = document.createElement("div"),
    r = Be().getChildren();
  for (let i = 0; i < r.length; i++) N3(t, r[i], n, e);
  return n.innerHTML;
}
function N3(t, e, n, r = null) {
  let i = r === null || e.isSelected(r);
  const s = W(e) && e.excludeFromCopy("html");
  let o = e;
  if (r !== null) {
    let d = Ib(e);
    (d = ne(d) && r !== null ? _3(r, d) : d), (o = d);
  }
  const a = W(o) ? o.getChildren() : [],
    l = t._nodes.get(o.getType());
  let c;
  c = l && l.exportDOM !== void 0 ? l.exportDOM(t, o) : o.exportDOM(t);
  const { element: u, after: h } = c;
  if (!u) return !1;
  const f = document.createDocumentFragment();
  for (let d = 0; d < a.length; d++) {
    const p = a[d],
      m = N3(t, p, f, r);
    !i && W(e) && m && e.extractWithChild(p, r, "html") && (i = !0);
  }
  if (i && !s) {
    if ((qr(u) && u.append(f), n.append(u), h)) {
      const d = h.call(o, u);
      d && u.replaceWith(d);
    }
  } else n.append(f);
  return i;
}
const L3 = new Set(["STYLE", "SCRIPT"]);
function M3(t, e, n, r, i = new Map(), s) {
  let o = [];
  if (L3.has(t.nodeName)) return o;
  let a = null;
  const l = (function (p, m) {
      const { nodeName: O } = p,
        v = m._htmlConversions.get(O.toLowerCase());
      let g = null;
      if (v !== void 0)
        for (const x of v) {
          const y = x(p);
          y !== null && (g === null || (g.priority || 0) < (y.priority || 0)) && (g = y);
        }
      return g !== null ? g.conversion : null;
    })(t, e),
    c = l ? l(t) : null;
  let u = null;
  if (c !== null) {
    u = c.after;
    const p = c.node;
    if (((a = Array.isArray(p) ? p[p.length - 1] : p), a !== null)) {
      for (const [, m] of i) if (((a = m(a, s)), !a)) break;
      a && o.push(...(Array.isArray(p) ? p : [a]));
    }
    c.forChild != null && i.set(t.nodeName, c.forChild);
  }
  const h = t.childNodes;
  let f = [];
  const d = (a == null || !rn(a)) && ((a != null && np(a)) || r);
  for (let p = 0; p < h.length; p++) f.push(...M3(h[p], e, n, d, new Map(i), a));
  return (
    u != null && (f = u(f)),
    SQ(t) &&
      (f = hF(
        t,
        f,
        d
          ? () => {
              const p = new $b();
              return n.push(p), p;
            }
          : at
      )),
    a == null ? (o = o.concat(f)) : W(a) && a.append(...f),
    o
  );
}
function hF(t, e, n) {
  const r = t.style.textAlign,
    i = [];
  let s = [];
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    if (np(a)) r && !a.getFormat() && a.setFormat(r), i.push(a);
    else if ((s.push(a), o === e.length - 1 || (o < e.length - 1 && np(e[o + 1])))) {
      const l = n();
      l.setFormat(r), l.append(...s), i.push(l), (s = []);
    }
  }
  return i;
}
function fF(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var op = fF(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const dF = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  D3 = (t) => (dF ? (t || window).getSelection() : null);
function pF(t) {
  const e = ce();
  return e == null && op(166), (ee(e) && e.isCollapsed()) || e.getNodes().length === 0 ? "" : uF(t, e);
}
function mF(t) {
  const e = ce();
  return e == null && op(166), (ee(e) && e.isCollapsed()) || e.getNodes().length === 0 ? null : JSON.stringify(gF(t, e));
}
function o2(t, e, n) {
  const r = t.getData("application/x-lexical-editor");
  if (r)
    try {
      const o = JSON.parse(r);
      if (o.namespace === n._config.namespace && Array.isArray(o.nodes)) return a2(n, OF(o.nodes), e);
    } catch {}
  const i = t.getData("text/html");
  if (i)
    try {
      const o = new DOMParser().parseFromString(i, "text/html");
      return a2(n, cF(n, o), e);
    } catch {}
  const s = t.getData("text/plain") || t.getData("text/uri-list");
  if (s != null)
    if (ee(e)) {
      const o = s.split(/(\r?\n|\t)/);
      o[o.length - 1] === "" && o.pop();
      for (let a = 0; a < o.length; a++) {
        const l = ce();
        if (ee(l)) {
          const c = o[a];
          c ===
            `
` ||
          c ===
            `\r
`
            ? l.insertParagraph()
            : c === "	"
            ? l.insertNodes([jl()])
            : l.insertText(c);
        }
      }
    } else e.insertRawText(s);
}
function a2(t, e, n) {
  t.dispatchCommand(FD, { nodes: e, selection: n }) || n.insertNodes(e);
}
function Q3(t, e, n, r = []) {
  let i = e === null || n.isSelected(e);
  const s = W(n) && n.excludeFromCopy("html");
  let o = n;
  if (e !== null) {
    let c = Ib(n);
    (c = ne(c) && e !== null ? _3(e, c) : c), (o = c);
  }
  const a = W(o) ? o.getChildren() : [],
    l = (function (c) {
      const u = c.exportJSON(),
        h = c.constructor;
      if ((u.type !== h.getType() && op(58, h.name), W(c))) {
        const f = u.children;
        Array.isArray(f) || op(59, h.name);
      }
      return u;
    })(o);
  if (ne(o)) {
    const c = o.__text;
    c.length > 0 ? (l.text = c) : (i = !1);
  }
  for (let c = 0; c < a.length; c++) {
    const u = a[c],
      h = Q3(t, e, u, l.children);
    !i && W(n) && h && n.extractWithChild(u, e, "clone") && (i = !0);
  }
  if (i && !s) r.push(l);
  else if (Array.isArray(l.children))
    for (let c = 0; c < l.children.length; c++) {
      const u = l.children[c];
      r.push(u);
    }
  return i;
}
function gF(t, e) {
  const n = [],
    r = Be().getChildren();
  for (let i = 0; i < r.length; i++) Q3(t, e, r[i], n);
  return { namespace: t._config.namespace, nodes: n };
}
function OF(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n],
      i = QQ(r);
    ne(i) && WQ(i), e.push(i);
  }
  return e;
}
let va = null;
async function l2(t, e) {
  if (va !== null) return !1;
  if (e !== null)
    return new Promise((a, l) => {
      t.update(() => {
        a(c2(t, e));
      });
    });
  const n = t.getRootElement(),
    r = t._window == null ? window.document : t._window.document,
    i = D3(t._window);
  if (n === null || i === null) return !1;
  const s = r.createElement("span");
  (s.style.cssText = "position: fixed; top: -1000px;"), s.append(r.createTextNode("#")), n.append(s);
  const o = new Range();
  return (
    o.setStart(s, 0),
    o.setEnd(s, 1),
    i.removeAllRanges(),
    i.addRange(o),
    new Promise((a, l) => {
      const c = t.registerCommand(
        _m,
        (u) => (Ms(u, ClipboardEvent) && (c(), va !== null && (window.clearTimeout(va), (va = null)), a(c2(t, u))), !0),
        Gn
      );
      (va = window.setTimeout(() => {
        c(), (va = null), a(!1);
      }, 50)),
        r.execCommand("copy"),
        s.remove();
    })
  );
}
function c2(t, e) {
  const n = D3(t._window);
  if (!n) return !1;
  const r = n.anchorNode,
    i = n.focusNode;
  if (r !== null && i !== null && !xh(t, r, i)) return !1;
  e.preventDefault();
  const s = e.clipboardData,
    o = ce();
  if (s === null || o === null) return !1;
  const a = pF(t),
    l = mF(t);
  let c = "";
  return (
    o !== null && (c = o.getTextContent()),
    a !== null && s.setData("text/html", a),
    l !== null && s.setData("application/x-lexical-editor", l),
    s.setData("text/plain", c),
    !0
  );
}
function u2(t, e) {
  if (document.caretRangeFromPoint !== void 0) {
    const n = document.caretRangeFromPoint(t, e);
    return n === null ? null : { node: n.startContainer, offset: n.startOffset };
  }
  if (document.caretPositionFromPoint !== "undefined") {
    const n = document.caretPositionFromPoint(t, e);
    return n === null ? null : { node: n.offsetNode, offset: n.offset };
  }
  return null;
}
const Ul = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  vF = Ul && "documentMode" in document ? document.documentMode : null,
  xF = !(!Ul || !("InputEvent" in window) || vF) && "getTargetRanges" in new window.InputEvent("input"),
  bF = Ul && /Version\/[\d.]+.*Safari/.test(navigator.userAgent),
  yF = Ul && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
  wF = Ul && /^(?=.*Chrome).*/i.test(navigator.userAgent),
  SF = Ul && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !wF,
  h2 = gs();
let Vm = class F3 extends ii {
  static getType() {
    return "quote";
  }
  static clone(e) {
    return new F3(e.__key);
  }
  constructor(e) {
    super(e);
  }
  createDOM(e) {
    const n = document.createElement("blockquote");
    return Yr(n, e.theme.quote), n;
  }
  updateDOM(e, n) {
    return !1;
  }
  static importDOM() {
    return { blockquote: (e) => ({ conversion: kF, priority: 0 }) };
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (n && qr(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(e) {
    const n = Sh();
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "quote" };
  }
  insertNewAfter(e, n) {
    const r = at(),
      i = this.getDirection();
    return r.setDirection(i), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const e = at();
    return this.getChildren().forEach((n) => e.append(n)), this.replace(e), !0;
  }
};
function Sh() {
  return Zn(new Vm());
}
function yO(t) {
  return t instanceof Vm;
}
let kh = class V3 extends ii {
  static getType() {
    return "heading";
  }
  static clone(e) {
    return new V3(e.__tag, e.__key);
  }
  constructor(e, n) {
    super(n), (this.__tag = e);
  }
  getTag() {
    return this.__tag;
  }
  createDOM(e) {
    const n = this.__tag,
      r = document.createElement(n),
      i = e.theme.heading;
    if (i !== void 0) {
      const s = i[n];
      Yr(r, s);
    }
    return r;
  }
  updateDOM(e, n) {
    return !1;
  }
  static importDOM() {
    return {
      h1: (e) => ({ conversion: xa, priority: 0 }),
      h2: (e) => ({ conversion: xa, priority: 0 }),
      h3: (e) => ({ conversion: xa, priority: 0 }),
      h4: (e) => ({ conversion: xa, priority: 0 }),
      h5: (e) => ({ conversion: xa, priority: 0 }),
      h6: (e) => ({ conversion: xa, priority: 0 }),
      p: (e) => {
        const n = e.firstChild;
        return n !== null && f2(n) ? { conversion: () => ({ node: null }), priority: 3 } : null;
      },
      span: (e) => (f2(e) ? { conversion: (n) => ({ node: Si("h1") }), priority: 3 } : null),
    };
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (n && qr(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(e) {
    const n = Si(e.tag);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
  }
  insertNewAfter(e, n = !0) {
    const r = e ? e.anchor.offset : 0,
      i = r !== this.getTextContentSize() && e ? Si(this.getTag()) : at(),
      s = this.getDirection();
    if ((i.setDirection(s), this.insertAfter(i, n), r === 0 && !this.isEmpty() && e)) {
      const o = at();
      o.select(), this.replace(o, !0);
    }
    return i;
  }
  collapseAtStart() {
    const e = this.isEmpty() ? at() : Si(this.getTag());
    return this.getChildren().forEach((n) => e.append(n)), this.replace(e), !0;
  }
  extractWithChild() {
    return !0;
  }
};
function f2(t) {
  return t.nodeName.toLowerCase() === "span" && t.style.fontSize === "26pt";
}
function xa(t) {
  const e = t.nodeName.toLowerCase();
  let n = null;
  return (
    (e !== "h1" && e !== "h2" && e !== "h3" && e !== "h4" && e !== "h5" && e !== "h6") ||
      ((n = Si(e)), t.style !== null && n.setFormat(t.style.textAlign)),
    { node: n }
  );
}
function kF(t) {
  const e = Sh();
  return t.style !== null && e.setFormat(t.style.textAlign), { node: e };
}
function Si(t) {
  return Zn(new kh(t));
}
function Bm(t) {
  return t instanceof kh;
}
function xf(t) {
  let e = null;
  if ((Ms(t, DragEvent) ? (e = t.dataTransfer) : Ms(t, ClipboardEvent) && (e = t.clipboardData), e === null)) return [!1, [], !1];
  const n = e.types,
    r = n.includes("Files"),
    i = n.includes("text/html") || n.includes("text/plain");
  return [r, Array.from(e.files), i];
}
function d2(t) {
  const e = ce();
  if (!ee(e)) return !1;
  const n = new Set(),
    r = e.getNodes();
  for (let i = 0; i < r.length; i++) {
    const s = r[i],
      o = s.getKey();
    if (n.has(o)) continue;
    const a = Wl(s, (c) => W(c) && !c.isInline());
    if (a === null) continue;
    const l = a.getKey();
    a.canIndent() && !n.has(l) && (n.add(l), t(a));
  }
  return n.size > 0;
}
function bf(t) {
  const e = Ai(t);
  return ht(e);
}
function CF(t) {
  return ir(
    t.registerCommand(
      ym,
      (e) => {
        const n = ce();
        return !!Ht(n) && (n.clear(), !0);
      },
      0
    ),
    t.registerCommand(
      No,
      (e) => {
        const n = ce();
        return !!ee(n) && (n.deleteCharacter(e), !0);
      },
      Ue
    ),
    t.registerCommand(
      bu,
      (e) => {
        const n = ce();
        return !!ee(n) && (n.deleteWord(e), !0);
      },
      Ue
    ),
    t.registerCommand(
      yu,
      (e) => {
        const n = ce();
        return !!ee(n) && (n.deleteLine(e), !0);
      },
      Ue
    ),
    t.registerCommand(
      Ha,
      (e) => {
        const n = ce();
        if (typeof e == "string") n !== null && n.insertText(e);
        else {
          if (n === null) return !1;
          const r = e.dataTransfer;
          if (r != null) o2(r, n, t);
          else if (ee(n)) {
            const i = e.data;
            return i && n.insertText(i), !0;
          }
        }
        return !0;
      },
      Ue
    ),
    t.registerCommand(
      eO,
      () => {
        const e = ce();
        return !!ee(e) && (e.removeText(), !0);
      },
      Ue
    ),
    t.registerCommand(
      Gi,
      (e) => {
        const n = ce();
        return !!ee(n) && (n.formatText(e), !0);
      },
      Ue
    ),
    t.registerCommand(
      jD,
      (e) => {
        const n = ce();
        if (!ee(n) && !Ht(n)) return !1;
        const r = n.getNodes();
        for (const i of r) {
          const s = Wl(i, (o) => W(o) && !o.isInline());
          s !== null && s.setFormat(e);
        }
        return !0;
      },
      Ue
    ),
    t.registerCommand(
      Xa,
      (e) => {
        const n = ce();
        return !!ee(n) && (n.insertLineBreak(e), !0);
      },
      Ue
    ),
    t.registerCommand(
      xu,
      () => {
        const e = ce();
        return !!ee(e) && (e.insertParagraph(), !0);
      },
      Ue
    ),
    t.registerCommand(MP, () => (Zl([jl()]), !0), Ue),
    t.registerCommand(
      ib,
      () =>
        d2((e) => {
          const n = e.getIndent();
          e.setIndent(n + 1);
        }),
      Ue
    ),
    t.registerCommand(
      tO,
      () =>
        d2((e) => {
          const n = e.getIndent();
          n > 0 && e.setIndent(n - 1);
        }),
      Ue
    ),
    t.registerCommand(
      tb,
      (e) => {
        const n = ce();
        if (Ht(n) && !bf(e.target)) {
          const r = n.getNodes();
          if (r.length > 0) return r[0].selectPrevious(), !0;
        } else if (ee(n)) {
          const r = wu(n.focus, !0);
          if (!e.shiftKey && ht(r) && !r.isIsolated() && !r.isInline()) return r.selectPrevious(), e.preventDefault(), !0;
        }
        return !1;
      },
      Ue
    ),
    t.registerCommand(
      nb,
      (e) => {
        const n = ce();
        if (Ht(n)) {
          const r = n.getNodes();
          if (r.length > 0) return r[0].selectNext(0, 0), !0;
        } else if (ee(n)) {
          if (
            (function (i) {
              const s = i.focus;
              return s.key === "root" && s.offset === Be().getChildrenSize();
            })(n)
          )
            return e.preventDefault(), !0;
          const r = wu(n.focus, !1);
          if (!e.shiftKey && ht(r) && !r.isIsolated() && !r.isInline()) return r.selectNext(), e.preventDefault(), !0;
        }
        return !1;
      },
      Ue
    ),
    t.registerCommand(
      eb,
      (e) => {
        const n = ce();
        if (Ht(n)) {
          const r = n.getNodes();
          if (r.length > 0) return e.preventDefault(), r[0].selectPrevious(), !0;
        }
        if (!ee(n)) return !1;
        if (t2(n, !0)) {
          const r = e.shiftKey;
          return e.preventDefault(), n2(n, r, !0), !0;
        }
        return !1;
      },
      Ue
    ),
    t.registerCommand(
      NP,
      (e) => {
        const n = ce();
        if (Ht(n) && !bf(e.target)) {
          const i = n.getNodes();
          if (i.length > 0) return e.preventDefault(), i[0].selectNext(0, 0), !0;
        }
        if (!ee(n)) return !1;
        const r = e.shiftKey;
        return !!t2(n, !1) && (e.preventDefault(), n2(n, r, !1), !0);
      },
      Ue
    ),
    t.registerCommand(
      gh,
      (e) => {
        if (bf(e.target)) return !1;
        const n = ce();
        if (!ee(n)) return !1;
        e.preventDefault();
        const { anchor: r } = n,
          i = r.getNode();
        return n.isCollapsed() && r.offset === 0 && !cn(i) && A3(i).getIndent() > 0
          ? t.dispatchCommand(tO, void 0)
          : t.dispatchCommand(No, !0);
      },
      Ue
    ),
    t.registerCommand(
      km,
      (e) => {
        if (bf(e.target)) return !1;
        const n = ce();
        return !!ee(n) && (e.preventDefault(), t.dispatchCommand(No, !1));
      },
      Ue
    ),
    t.registerCommand(
      pl,
      (e) => {
        const n = ce();
        if (!ee(n)) return !1;
        if (e !== null) {
          if ((yF || bF || SF) && xF) return !1;
          if ((e.preventDefault(), e.shiftKey)) return t.dispatchCommand(Xa, !1);
        }
        return t.dispatchCommand(xu, void 0);
      },
      Ue
    ),
    t.registerCommand(
      Oh,
      () => {
        const e = ce();
        return !!ee(e) && (t.blur(), !0);
      },
      Ue
    ),
    t.registerCommand(
      sb,
      (e) => {
        const [, n] = xf(e);
        if (n.length > 0) {
          const i = u2(e.clientX, e.clientY);
          if (i !== null) {
            const { offset: s, node: o } = i,
              a = Ai(o);
            if (a !== null) {
              const l = Dm();
              if (ne(a)) l.anchor.set(a.getKey(), s, "text"), l.focus.set(a.getKey(), s, "text");
              else {
                const u = a.getParentOrThrow().getKey(),
                  h = a.getIndexWithinParent() + 1;
                l.anchor.set(u, h, "element"), l.focus.set(u, h, "element");
              }
              const c = xb(l);
              yn(c);
            }
            t.dispatchCommand(h2, n);
          }
          return e.preventDefault(), !0;
        }
        const r = ce();
        return !!ee(r);
      },
      Ue
    ),
    t.registerCommand(
      Cm,
      (e) => {
        const [n] = xf(e),
          r = ce();
        return !(n && !ee(r));
      },
      Ue
    ),
    t.registerCommand(
      ob,
      (e) => {
        const [n] = xf(e),
          r = ce();
        if (n && !ee(r)) return !1;
        const i = u2(e.clientX, e.clientY);
        if (i !== null) {
          const s = Ai(i.node);
          ht(s) && e.preventDefault();
        }
        return !0;
      },
      Ue
    ),
    t.registerCommand(nO, () => (mQ(), !0), Ue),
    t.registerCommand(_m, (e) => (l2(t, Ms(e, ClipboardEvent) ? e : null), !0), Ue),
    t.registerCommand(
      ab,
      (e) => (
        (async function (n, r) {
          await l2(r, Ms(n, ClipboardEvent) ? n : null),
            r.update(() => {
              const i = ce();
              ee(i) ? i.removeText() : Ht(i) && i.getNodes().forEach((s) => s.remove());
            });
        })(e, t),
        !0
      ),
      Ue
    ),
    t.registerCommand(
      mh,
      (e) => {
        const [, n, r] = xf(e);
        return n.length > 0 && !r
          ? (t.dispatchCommand(h2, n), !0)
          : bb(e.target)
          ? !1
          : ce() !== null &&
            ((function (i, s) {
              i.preventDefault(),
                s.update(
                  () => {
                    const o = ce(),
                      a = Ms(i, InputEvent) || Ms(i, KeyboardEvent) ? null : i.clipboardData;
                    a != null && o !== null && o2(a, o, s);
                  },
                  { tag: "paste" }
                );
            })(e, t),
            !0);
      },
      Ue
    )
  );
}
function Ir(t, e, n, r) {
  const i = t.length;
  let s = 0,
    o;
  if ((e < 0 ? (e = -e > i ? 0 : i + e) : (e = e > i ? i : e), (n = n > 0 ? n : 0), r.length < 1e4))
    (o = Array.from(r)), o.unshift(e, n), t.splice(...o);
  else for (n && t.splice(e, n); s < r.length; ) (o = r.slice(s, s + 1e4)), o.unshift(e, 0), t.splice(...o), (s += 1e4), (e += 1e4);
}
function _r(t, e) {
  return t.length > 0 ? (Ir(t, t.length, 0, e), t) : e;
}
const fr = uo(/[A-Za-z]/),
  pr = uo(/[\dA-Za-z]/),
  _F = uo(/[#-'*+\--9=?A-Z^-~]/);
function wO(t) {
  return t !== null && (t < 32 || t === 127);
}
const SO = uo(/\d/),
  EF = uo(/[\dA-Fa-f]/),
  TF = uo(/[!-/:-@[-`{-~]/);
function de(t) {
  return t !== null && t < -2;
}
function st(t) {
  return t !== null && (t < 0 || t === 32);
}
function Re(t) {
  return t === -2 || t === -1 || t === 32;
}
const PF = uo(/\p{P}|\p{S}/u),
  Xi = uo(/\s/);
function uo(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function ap(t) {
  if (t === null || st(t) || Xi(t)) return 1;
  if (PF(t)) return 2;
}
function jm(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i].resolveAll;
    s && !r.includes(s) && ((e = s(e, n)), r.push(s));
  }
  return e;
}
function AF(t) {
  let n = (t || {}).singleTilde;
  const r = { name: "strikethrough", tokenize: s, resolveAll: i };
  return n == null && (n = !0), { text: { 126: r }, insideSpan: { null: [r] }, attentionMarkers: { null: [126] } };
  function i(o, a) {
    let l = -1;
    for (; ++l < o.length; )
      if (o[l][0] === "enter" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._close) {
        let c = l;
        for (; c--; )
          if (
            o[c][0] === "exit" &&
            o[c][1].type === "strikethroughSequenceTemporary" &&
            o[c][1]._open &&
            o[l][1].end.offset - o[l][1].start.offset === o[c][1].end.offset - o[c][1].start.offset
          ) {
            (o[l][1].type = "strikethroughSequence"), (o[c][1].type = "strikethroughSequence");
            const u = { type: "strikethrough", start: Object.assign({}, o[c][1].start), end: Object.assign({}, o[l][1].end) },
              h = { type: "strikethroughText", start: Object.assign({}, o[c][1].end), end: Object.assign({}, o[l][1].start) },
              f = [
                ["enter", u, a],
                ["enter", o[c][1], a],
                ["exit", o[c][1], a],
                ["enter", h, a],
              ],
              d = a.parser.constructs.insideSpan.null;
            d && Ir(f, f.length, 0, jm(d, o.slice(c + 1, l), a)),
              Ir(f, f.length, 0, [
                ["exit", h, a],
                ["enter", o[l][1], a],
                ["exit", o[l][1], a],
                ["exit", u, a],
              ]),
              Ir(o, c - 1, l - c + 3, f),
              (l = c + f.length - 2);
            break;
          }
      }
    for (l = -1; ++l < o.length; ) o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data");
    return o;
  }
  function s(o, a, l) {
    const c = this.previous,
      u = this.events;
    let h = 0;
    return f;
    function f(p) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(p) : (o.enter("strikethroughSequenceTemporary"), d(p));
    }
    function d(p) {
      const m = ap(c);
      if (p === 126) return h > 1 ? l(p) : (o.consume(p), h++, d);
      if (h < 2 && !n) return l(p);
      const O = o.exit("strikethroughSequenceTemporary"),
        v = ap(p);
      return (O._open = !v || (v === 2 && !!m)), (O._close = !m || (m === 2 && !!v)), a(p);
    }
  }
}
const $F = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"];
B3.peek = MF;
function RF() {
  return { canContainEols: ["delete"], enter: { strikethrough: NF }, exit: { strikethrough: LF } };
}
function IF() {
  return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: $F }], handlers: { delete: B3 } };
}
function NF(t) {
  this.enter({ type: "delete", children: [] }, t);
}
function LF(t) {
  this.exit(t);
}
function B3(t, e, n, r) {
  const i = n.createTracker(r),
    s = n.enter("strikethrough");
  let o = i.move("~~");
  return (o += n.containerPhrasing(t, { ...i.current(), before: o, after: "~" })), (o += i.move("~~")), s(), o;
}
function MF() {
  return "~";
}
function p2(t, e) {
  const n = String(t);
  if (typeof e != "string") throw new TypeError("Expected character");
  let r = 0,
    i = n.indexOf(e);
  for (; i !== -1; ) r++, (i = n.indexOf(e, i + e.length));
  return r;
}
const DF = [
    "AElig",
    "AMP",
    "Aacute",
    "Acirc",
    "Agrave",
    "Aring",
    "Atilde",
    "Auml",
    "COPY",
    "Ccedil",
    "ETH",
    "Eacute",
    "Ecirc",
    "Egrave",
    "Euml",
    "GT",
    "Iacute",
    "Icirc",
    "Igrave",
    "Iuml",
    "LT",
    "Ntilde",
    "Oacute",
    "Ocirc",
    "Ograve",
    "Oslash",
    "Otilde",
    "Ouml",
    "QUOT",
    "REG",
    "THORN",
    "Uacute",
    "Ucirc",
    "Ugrave",
    "Uuml",
    "Yacute",
    "aacute",
    "acirc",
    "acute",
    "aelig",
    "agrave",
    "amp",
    "aring",
    "atilde",
    "auml",
    "brvbar",
    "ccedil",
    "cedil",
    "cent",
    "copy",
    "curren",
    "deg",
    "divide",
    "eacute",
    "ecirc",
    "egrave",
    "eth",
    "euml",
    "frac12",
    "frac14",
    "frac34",
    "gt",
    "iacute",
    "icirc",
    "iexcl",
    "igrave",
    "iquest",
    "iuml",
    "laquo",
    "lt",
    "macr",
    "micro",
    "middot",
    "nbsp",
    "not",
    "ntilde",
    "oacute",
    "ocirc",
    "ograve",
    "ordf",
    "ordm",
    "oslash",
    "otilde",
    "ouml",
    "para",
    "plusmn",
    "pound",
    "quot",
    "raquo",
    "reg",
    "sect",
    "shy",
    "sup1",
    "sup2",
    "sup3",
    "szlig",
    "thorn",
    "times",
    "uacute",
    "ucirc",
    "ugrave",
    "uml",
    "uuml",
    "yacute",
    "yen",
    "yuml",
  ],
  m2 = {
    0: "�",
    128: "€",
    130: "‚",
    131: "ƒ",
    132: "„",
    133: "…",
    134: "†",
    135: "‡",
    136: "ˆ",
    137: "‰",
    138: "Š",
    139: "‹",
    140: "Œ",
    142: "Ž",
    145: "‘",
    146: "’",
    147: "“",
    148: "”",
    149: "•",
    150: "–",
    151: "—",
    152: "˜",
    153: "™",
    154: "š",
    155: "›",
    156: "œ",
    158: "ž",
    159: "Ÿ",
  };
function j3(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 48 && e <= 57;
}
function QF(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return (e >= 97 && e <= 102) || (e >= 65 && e <= 70) || (e >= 48 && e <= 57);
}
function FF(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
}
function g2(t) {
  return FF(t) || j3(t);
}
const O2 = document.createElement("i");
function Cu(t) {
  const e = "&" + t + ";";
  O2.innerHTML = e;
  const n = O2.textContent;
  return (n.charCodeAt(n.length - 1) === 59 && t !== "semi") || n === e ? !1 : n;
}
const ba = String.fromCharCode,
  VF = [
    "",
    "Named character references must be terminated by a semicolon",
    "Numeric character references must be terminated by a semicolon",
    "Named character references cannot be empty",
    "Numeric character references cannot be empty",
    "Named character references must be known",
    "Numeric character references cannot be disallowed",
    "Numeric character references cannot be outside the permissible Unicode range",
  ];
function Zm(t, e = {}) {
  const n = typeof e.additional == "string" ? e.additional.charCodeAt(0) : e.additional,
    r = [];
  let i = 0,
    s = -1,
    o = "",
    a,
    l;
  e.position && ("start" in e.position || "indent" in e.position ? ((l = e.position.indent), (a = e.position.start)) : (a = e.position));
  let c = (a ? a.line : 0) || 1,
    u = (a ? a.column : 0) || 1,
    h = d(),
    f;
  for (i--; ++i <= t.length; )
    if ((f === 10 && (u = (l ? l[s] : 0) || 1), (f = t.charCodeAt(i)), f === 38)) {
      const O = t.charCodeAt(i + 1);
      if (O === 9 || O === 10 || O === 12 || O === 32 || O === 38 || O === 60 || Number.isNaN(O) || (n && O === n)) {
        (o += ba(f)), u++;
        continue;
      }
      const v = i + 1;
      let g = v,
        x = v,
        y;
      if (O === 35) {
        x = ++g;
        const D = t.charCodeAt(x);
        D === 88 || D === 120 ? ((y = "hexadecimal"), (x = ++g)) : (y = "decimal");
      } else y = "named";
      let S = "",
        k = "",
        b = "";
      const _ = y === "named" ? g2 : y === "decimal" ? j3 : QF;
      for (x--; ++x <= t.length; ) {
        const D = t.charCodeAt(x);
        if (!_(D)) break;
        (b += ba(D)), y === "named" && DF.includes(b) && ((S = b), (k = Cu(b)));
      }
      let T = t.charCodeAt(x) === 59;
      if (T) {
        x++;
        const D = y === "named" ? Cu(b) : !1;
        D && ((S = b), (k = D));
      }
      let P = 1 + x - v,
        M = "";
      if (!(!T && e.nonTerminated === !1))
        if (!b) y !== "named" && p(4, P);
        else if (y === "named") {
          if (T && !k) p(5, 1);
          else if ((S !== b && ((x = g + S.length), (P = 1 + x - g), (T = !1)), !T)) {
            const D = S ? 1 : 3;
            if (e.attribute) {
              const V = t.charCodeAt(x);
              V === 61 ? (p(D, P), (k = "")) : g2(V) ? (k = "") : p(D, P);
            } else p(D, P);
          }
          M = k;
        } else {
          T || p(2, P);
          let D = Number.parseInt(b, y === "hexadecimal" ? 16 : 10);
          if (BF(D)) p(7, P), (M = ba(65533));
          else if (D in m2) p(6, P), (M = m2[D]);
          else {
            let V = "";
            jF(D) && p(6, P), D > 65535 && ((D -= 65536), (V += ba((D >>> 10) | 55296)), (D = 56320 | (D & 1023))), (M = V + ba(D));
          }
        }
      if (M) {
        m(), (h = d()), (i = x - 1), (u += x - v + 1), r.push(M);
        const D = d();
        D.offset++, e.reference && e.reference.call(e.referenceContext, M, { start: h, end: D }, t.slice(v - 1, x)), (h = D);
      } else (b = t.slice(v - 1, x)), (o += b), (u += b.length), (i = x - 1);
    } else f === 10 && (c++, s++, (u = 0)), Number.isNaN(f) ? m() : ((o += ba(f)), u++);
  return r.join("");
  function d() {
    return { line: c, column: u, offset: i + ((a ? a.offset : 0) || 0) };
  }
  function p(O, v) {
    let g;
    e.warning && ((g = d()), (g.column += v), (g.offset += v), e.warning.call(e.warningContext, VF[O], g, O));
  }
  function m() {
    o && (r.push(o), e.text && e.text.call(e.textContext, o, { start: h, end: d() }), (o = ""));
  }
}
function BF(t) {
  return (t >= 55296 && t <= 57343) || t > 1114111;
}
function jF(t) {
  return (
    (t >= 1 && t <= 8) ||
    t === 11 ||
    (t >= 13 && t <= 31) ||
    (t >= 127 && t <= 159) ||
    (t >= 64976 && t <= 65007) ||
    (t & 65535) === 65535 ||
    (t & 65535) === 65534
  );
}
const ZF = /["&'<>`]/g,
  zF = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  WF = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
  UF = /[|\\{}()[\]^$+*?.]/g,
  v2 = new WeakMap();
function XF(t, e) {
  if (((t = t.replace(e.subset ? HF(e.subset) : ZF, r)), e.subset || e.escapeOnly)) return t;
  return t.replace(zF, n).replace(WF, r);
  function n(i, s, o) {
    return e.format((i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536, o.charCodeAt(s + 2), e);
  }
  function r(i, s, o) {
    return e.format(i.charCodeAt(0), o.charCodeAt(s + 1), e);
  }
}
function HF(t) {
  let e = v2.get(t);
  return e || ((e = qF(t)), v2.set(t, e)), e;
}
function qF(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; ) e.push(t[n].replace(UF, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
function YF(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function Z3(t, e) {
  return XF(t, Object.assign({ format: YF }, e));
}
function Ji(t) {
  return !t || typeof t != "object"
    ? ""
    : "position" in t || "type" in t
    ? x2(t.position)
    : "start" in t || "end" in t
    ? x2(t)
    : "line" in t || "column" in t
    ? kO(t)
    : "";
}
function kO(t) {
  return b2(t && t.line) + ":" + b2(t && t.column);
}
function x2(t) {
  return kO(t && t.start) + "-" + kO(t && t.end);
}
function b2(t) {
  return t && typeof t == "number" ? t : 1;
}
class ct extends Error {
  constructor(e, n, r) {
    super(), typeof n == "string" && ((r = n), (n = void 0));
    let i = "",
      s = {},
      o = !1;
    if (
      (n &&
        ("line" in n && "column" in n
          ? (s = { place: n })
          : "start" in n && "end" in n
          ? (s = { place: n })
          : "type" in n
          ? (s = { ancestors: [n], place: n.position })
          : (s = { ...n })),
      typeof e == "string" ? (i = e) : !s.cause && e && ((o = !0), (i = e.message), (s.cause = e)),
      !s.ruleId && !s.source && typeof r == "string")
    ) {
      const l = r.indexOf(":");
      l === -1 ? (s.ruleId = r) : ((s.source = r.slice(0, l)), (s.ruleId = r.slice(l + 1)));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const l = s.ancestors[s.ancestors.length - 1];
      l && (s.place = l.position);
    }
    const a = s.place && "start" in s.place ? s.place.start : s.place;
    (this.ancestors = s.ancestors || void 0),
      (this.cause = s.cause || void 0),
      (this.column = a ? a.column : void 0),
      (this.fatal = void 0),
      this.file,
      (this.message = i),
      (this.line = a ? a.line : void 0),
      (this.name = Ji(s.place) || "1:1"),
      (this.place = s.place || void 0),
      (this.reason = this.message),
      (this.ruleId = s.ruleId || void 0),
      (this.source = s.source || void 0),
      (this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : ""),
      this.actual,
      this.expected,
      this.note,
      this.url;
  }
}
ct.prototype.file = "";
ct.prototype.name = "";
ct.prototype.reason = "";
ct.prototype.message = "";
ct.prototype.stack = "";
ct.prototype.column = void 0;
ct.prototype.line = void 0;
ct.prototype.ancestors = void 0;
ct.prototype.cause = void 0;
ct.prototype.fatal = void 0;
ct.prototype.place = void 0;
ct.prototype.ruleId = void 0;
ct.prototype.source = void 0;
const z3 = "  ";
function W3() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: r,
      mdxJsxFlowTagClosingMarker: i,
      mdxJsxFlowTagAttribute: h,
      mdxJsxFlowTagExpressionAttribute: f,
      mdxJsxFlowTagAttributeValueLiteral: t,
      mdxJsxFlowTagAttributeValueExpression: t,
      mdxJsxFlowTagSelfClosingMarker: o,
      mdxJsxTextTag: r,
      mdxJsxTextTagClosingMarker: i,
      mdxJsxTextTagAttribute: h,
      mdxJsxTextTagExpressionAttribute: f,
      mdxJsxTextTagAttributeValueLiteral: t,
      mdxJsxTextTagAttributeValueExpression: t,
      mdxJsxTextTagSelfClosingMarker: o,
    },
    exit: {
      mdxJsxFlowTagClosingMarker: a,
      mdxJsxFlowTagNamePrimary: l,
      mdxJsxFlowTagNameMember: c,
      mdxJsxFlowTagNameLocal: u,
      mdxJsxFlowTagExpressionAttribute: d,
      mdxJsxFlowTagExpressionAttributeValue: n,
      mdxJsxFlowTagAttributeNamePrimary: p,
      mdxJsxFlowTagAttributeNameLocal: m,
      mdxJsxFlowTagAttributeValueLiteral: O,
      mdxJsxFlowTagAttributeValueLiteralValue: n,
      mdxJsxFlowTagAttributeValueExpression: v,
      mdxJsxFlowTagAttributeValueExpressionValue: n,
      mdxJsxFlowTagSelfClosingMarker: g,
      mdxJsxFlowTag: x,
      mdxJsxTextTagClosingMarker: a,
      mdxJsxTextTagNamePrimary: l,
      mdxJsxTextTagNameMember: c,
      mdxJsxTextTagNameLocal: u,
      mdxJsxTextTagExpressionAttribute: d,
      mdxJsxTextTagExpressionAttributeValue: n,
      mdxJsxTextTagAttributeNamePrimary: p,
      mdxJsxTextTagAttributeNameLocal: m,
      mdxJsxTextTagAttributeValueLiteral: O,
      mdxJsxTextTagAttributeValueLiteralValue: n,
      mdxJsxTextTagAttributeValueExpression: v,
      mdxJsxTextTagAttributeValueExpressionValue: n,
      mdxJsxTextTagSelfClosingMarker: g,
      mdxJsxTextTag: x,
    },
  };
  function t() {
    this.buffer();
  }
  function e(b) {
    return { line: b.line, column: b.column, offset: b.offset };
  }
  function n(b) {
    this.config.enter.data.call(this, b), this.config.exit.data.call(this, b);
  }
  function r(b) {
    const _ = { name: void 0, attributes: [], close: !1, selfClosing: !1, start: b.start, end: b.end };
    this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), (this.data.mdxJsxTag = _), this.buffer();
  }
  function i(b) {
    if (this.data.mdxJsxTagStack.length === 0)
      throw new ct(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: b.start, end: b.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
  }
  function s(b) {
    if (this.data.mdxJsxTag.close)
      throw new ct(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: b.start, end: b.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
  }
  function o(b) {
    if (this.data.mdxJsxTag.close)
      throw new ct(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: b.start, end: b.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
  }
  function a() {
    const b = this.data.mdxJsxTag;
    b.close = !0;
  }
  function l(b) {
    const _ = this.data.mdxJsxTag;
    _.name = this.sliceSerialize(b);
  }
  function c(b) {
    const _ = this.data.mdxJsxTag;
    _.name += "." + this.sliceSerialize(b);
  }
  function u(b) {
    const _ = this.data.mdxJsxTag;
    _.name += ":" + this.sliceSerialize(b);
  }
  function h(b) {
    const _ = this.data.mdxJsxTag;
    s.call(this, b), _.attributes.push({ type: "mdxJsxAttribute", name: "", value: null, position: { start: e(b.start), end: void 0 } });
  }
  function f(b) {
    const _ = this.data.mdxJsxTag;
    s.call(this, b), _.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" }), this.buffer();
  }
  function d(b) {
    const _ = this.data.mdxJsxTag,
      T = _.attributes[_.attributes.length - 1];
    T.type;
    const P = b.estree;
    (T.value = this.resume()), P && (T.data = { estree: P });
  }
  function p(b) {
    const _ = this.data.mdxJsxTag,
      T = _.attributes[_.attributes.length - 1];
    T.type, (T.name = this.sliceSerialize(b)), T.position, (T.position.end = e(b.end));
  }
  function m(b) {
    const _ = this.data.mdxJsxTag,
      T = _.attributes[_.attributes.length - 1];
    T.type, (T.name += ":" + this.sliceSerialize(b)), T.position, (T.position.end = e(b.end));
  }
  function O(b) {
    const _ = this.data.mdxJsxTag,
      T = _.attributes[_.attributes.length - 1];
    (T.value = Zm(this.resume(), { nonTerminated: !1 })), T.position, (T.position.end = e(b.end));
  }
  function v(b) {
    const _ = this.data.mdxJsxTag,
      T = _.attributes[_.attributes.length - 1];
    T.type;
    const P = { type: "mdxJsxAttributeValueExpression", value: this.resume() },
      M = b.estree;
    M && (P.data = { estree: M }), (T.value = P), T.position, (T.position.end = e(b.end));
  }
  function g() {
    const b = this.data.mdxJsxTag;
    b.selfClosing = !0;
  }
  function x(b) {
    const _ = this.data.mdxJsxTag,
      T = this.data.mdxJsxTagStack,
      P = T[T.length - 1];
    if (_.close && P.name !== _.name)
      throw new ct(
        "Unexpected closing tag `" + k(_) + "`, expected corresponding closing tag for `" + k(P) + "` (" + Ji(P) + ")",
        { start: b.start, end: b.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    this.resume(),
      _.close
        ? T.pop()
        : this.enter(
            {
              type: b.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
              name: _.name || null,
              attributes: _.attributes,
              children: [],
            },
            b,
            y
          ),
      _.selfClosing || _.close ? this.exit(b, S) : T.push(_);
  }
  function y(b, _) {
    const T = this.data.mdxJsxTagStack,
      P = T[T.length - 1],
      M = b ? " before the end of `" + b.type + "`" : "",
      D = b ? { start: b.start, end: b.end } : void 0;
    throw new ct(
      "Expected a closing tag for `" + k(P) + "` (" + Ji({ start: _.start, end: _.end }) + ")" + M,
      D,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function S(b, _) {
    const T = this.data.mdxJsxTag;
    throw new ct(
      "Expected the closing tag `" +
        k(T) +
        "` either after the end of `" +
        _.type +
        "` (" +
        Ji(_.end) +
        ") or another opening tag after the start of `" +
        _.type +
        "` (" +
        Ji(_.start) +
        ")",
      { start: b.start, end: b.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function k(b) {
    return "<" + (b.close ? "/" : "") + (b.name || "") + ">";
  }
}
function U3(t) {
  const e = t || {},
    n = e.quote || '"',
    r = e.quoteSmart || !1,
    i = e.tightSelfClosing || !1,
    s = e.printWidth || Number.POSITIVE_INFINITY,
    o = n === '"' ? "'" : '"';
  if (n !== '"' && n !== "'")
    throw new Error("Cannot serialize attribute values with `" + n + "` for `options.quote`, expected `\"`, or `'`");
  return (
    (a.peek = JF),
    {
      handlers: { mdxJsxFlowElement: a, mdxJsxTextElement: a },
      unsafe: [
        { character: "<", inConstruct: ["phrasing"] },
        { atBreak: !0, character: "<" },
      ],
      fences: !0,
      resourceLink: !0,
    }
  );
  function a(l, c, u, h) {
    const f = l.type === "mdxJsxFlowElement",
      d = l.name ? !l.children || l.children.length === 0 : !1,
      p = X3(u),
      m = H3(p),
      O = u.createTracker(h),
      v = u.createTracker(h),
      g = [],
      x = (f ? m : "") + "<" + (l.name || ""),
      y = u.enter(l.type);
    if ((O.move(x), v.move(x), l.attributes && l.attributes.length > 0)) {
      if (!l.name) throw new Error("Cannot serialize fragment w/ attributes");
      let T = -1;
      for (; ++T < l.attributes.length; ) {
        const P = l.attributes[T];
        let M;
        if (P.type === "mdxJsxExpressionAttribute") M = "{" + (P.value || "") + "}";
        else {
          if (!P.name) throw new Error("Cannot serialize attribute w/o name");
          const D = P.value,
            V = P.name;
          let Q = "";
          if (D != null)
            if (typeof D == "object") Q = "{" + (D.value || "") + "}";
            else {
              const N = r && p2(D, n) > p2(D, o) ? o : n;
              Q = N + Z3(D, { subset: [N] }) + N;
            }
          M = V + (Q ? "=" : "") + Q;
        }
        g.push(M);
      }
    }
    let S = !1;
    const k = g.join(" ");
    f && (/\r?\n|\r/.test(k) || O.current().now.column + k.length + (d ? (i ? 2 : 3) : 1) > s) && (S = !0);
    let b = O,
      _ = x;
    if (S) {
      b = v;
      let T = -1;
      for (; ++T < g.length; ) g[T] = m + z3 + g[T];
      _ += b.move(
        `
` +
          g.join(`
`) +
          `
` +
          m
      );
    } else k && (_ += b.move(" " + k));
    return (
      d && (_ += b.move((i || S ? "" : " ") + "/")),
      (_ += b.move(">")),
      l.children &&
        l.children.length > 0 &&
        (l.type === "mdxJsxTextElement"
          ? (_ += b.move(u.containerPhrasing(l, { ...b.current(), before: ">", after: "<" })))
          : (b.shift(2),
            (_ += b.move(`
`)),
            (_ += b.move(GF(l, u, b.current()))),
            (_ += b.move(`
`)))),
      d || (_ += b.move((f ? m : "") + "</" + (l.name || "") + ">")),
      y(),
      _
    );
  }
}
function GF(t, e, n) {
  const r = e.indexStack,
    i = t.children,
    s = e.createTracker(n),
    o = H3(X3(e)),
    a = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const c = i[l];
    r[r.length - 1] = l;
    const u = {
        before: `
`,
        after: `
`,
        ...s.current(),
      },
      h = e.handle(c, t, e, u),
      f =
        c.type === "mdxJsxFlowElement"
          ? h
          : e.indentLines(h, function (d, p, m) {
              return (m ? "" : o) + d;
            });
    a.push(s.move(f)),
      c.type !== "list" && (e.bulletLastUsed = void 0),
      l < i.length - 1 &&
        a.push(
          s.move(`

`)
        );
  }
  return r.pop(), a.join("");
}
function X3(t) {
  let e = 0,
    n = t.stack.length;
  for (; --n > -1; ) {
    const r = t.stack[n];
    if (r === "blockquote" || r === "listItem") break;
    r === "mdxJsxFlowElement" && e++;
  }
  return e;
}
function H3(t) {
  return z3.repeat(t);
}
function JF() {
  return "<";
}
const KF = /[$_\p{ID_Start}]/u,
  eV = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u,
  tV = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u,
  nV = {};
function Vr(t) {
  return t ? KF.test(String.fromCodePoint(t)) : !1;
}
function xc(t, e) {
  const r = (e || nV).jsx ? tV : eV;
  return t ? r.test(String.fromCodePoint(t)) : !1;
}
const rV = {}.hasOwnProperty,
  iV = Symbol("continue"),
  u0 = Symbol("exit"),
  sV = Symbol("skip");
function oV(t, e) {
  let n, r;
  typeof e == "function" ? (n = e) : e && typeof e == "object" && (e.enter && (n = e.enter), e.leave && (r = e.leave)),
    i(t, void 0, void 0, [])();
  function i(s, o, a, l) {
    return h0(s) && (c.displayName = "node (" + s.type + ")"), c;
    function c() {
      const u = n ? y2(n(s, o, a, l)) : [];
      if (u[0] === u0) return u;
      if (u[0] !== sV) {
        let h;
        for (h in s)
          if (rV.call(s, h) && s[h] && typeof s[h] == "object" && h !== "data" && h !== "position") {
            const f = l.concat(s),
              d = s[h];
            if (Array.isArray(d)) {
              const p = d;
              let m = 0;
              for (; m > -1 && m < p.length; ) {
                const O = p[m];
                if (h0(O)) {
                  const v = i(O, h, m, f)();
                  if (v[0] === u0) return v;
                  m = typeof v[1] == "number" ? v[1] : m + 1;
                } else m++;
              }
            } else if (h0(d)) {
              const p = i(d, h, void 0, f)();
              if (p[0] === u0) return p;
            }
          }
      }
      return r ? y2(r(s, o, a, l)) : u;
    }
  }
}
function y2(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [iV, t] : [t];
}
function h0(t) {
  return !!(t && typeof t == "object" && "type" in t && typeof t.type == "string" && t.type.length > 0);
}
function q3(t, e) {
  const n = e.prefix || "",
    r = e.suffix || "",
    i = Object.assign({}, e.acornOptions),
    s = [],
    o = [],
    a = i.onComment,
    l = i.onToken;
  let c = !1,
    u,
    h;
  const f = Object.assign({}, i, { onComment: s, preserveParens: !0 });
  l && (f.onToken = o);
  const d = aV(t, e.tokenTypes),
    p = d.value,
    m = n + p + r,
    O = e.expression && w2(p);
  if (O && !e.allowEmpty)
    throw new ct("Unexpected empty expression", {
      place: g(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression",
    });
  try {
    u = e.expression && !O ? e.acorn.parseExpressionAt(m, 0, f) : e.acorn.parse(m, f);
  } catch (x) {
    const y = x,
      S = g(y.pos);
    (y.message = String(y.message).replace(/ \(\d+:\d+\)$/, "")),
      (y.pos = S.offset),
      (y.loc = { line: S.line, column: S.column - 1 }),
      (h = y),
      (c = y.raisedAt >= n.length + p.length || y.message === "Unterminated comment");
  }
  if (u && e.expression && !O)
    if (w2(m.slice(u.end, m.length - r.length)))
      u = {
        type: "Program",
        start: 0,
        end: n.length + p.length,
        body: [{ type: "ExpressionStatement", expression: u, start: 0, end: n.length + p.length }],
        sourceType: "module",
        comments: [],
      };
    else {
      const x = g(u.end),
        y = new Error("Unexpected content after expression");
      (y.pos = x.offset), (y.loc = { line: x.line, column: x.column - 1 }), (h = y), (u = void 0);
    }
  if (u) {
    if (
      ((u.comments = s),
      oV(u, function (x, y, S, k) {
        let b = k[k.length - 1],
          _ = y;
        x.type === "ParenthesizedExpression" && b && _ && (typeof S == "number" && ((b = b[_]), (_ = S)), (b[_] = x.expression)), v(x);
      }),
      Array.isArray(a))
    )
      a.push(...s);
    else if (typeof a == "function") for (const x of s) a(x.type === "Block", x.value, x.start, x.end, x.loc.start, x.loc.end);
    for (const x of o) x.end <= n.length || x.start - n.length >= p.length || (v(x), Array.isArray(l) ? l.push(x) : l(x));
  }
  return { estree: u, error: h, swallow: c };
  function v(x) {
    const y = g(x.start),
      S = g(x.end);
    (x.start = y.offset),
      (x.end = S.offset),
      (x.loc = {
        start: { line: y.line, column: y.column - 1, offset: y.offset },
        end: { line: S.line, column: S.column - 1, offset: S.offset },
      }),
      (x.range = [x.start, x.end]);
  }
  function g(x) {
    let y = x - n.length;
    y < 0 ? (y = 0) : y > p.length && (y = p.length);
    let S = lV(d.stops, y);
    return S || (S = { line: e.start.line, column: e.start.column, offset: e.start.offset }), S;
  }
}
function w2(t) {
  return /^\s*$/.test(t.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
}
function aV(t, e) {
  const n = { value: "", stops: [] };
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r];
    if (i[0] === "enter") {
      const s = i[1].type;
      if (s === "lineEnding" || e.includes(s)) {
        const o = i[2].sliceStream(i[1]);
        for (; o.length > 0 && o[0] === -1; ) o.shift();
        const a = cV(o);
        n.stops.push([n.value.length, i[1].start]), (n.value += a), n.stops.push([n.value.length, i[1].end]);
      }
    }
  }
  return n;
}
function lV(t, e) {
  let n = 0;
  for (; n < t.length && t[n][0] <= e; ) n += 1;
  if (n === 0) return;
  const [r, i] = t[n - 1],
    s = e - r;
  return { line: i.line, column: i.column + s, offset: i.offset + s };
}
function cV(t) {
  let e = -1;
  const n = [];
  let r;
  for (; ++e < t.length; ) {
    const i = t[e];
    let s;
    if (typeof i == "string") s = i;
    else
      switch (i) {
        case -5: {
          s = "\r";
          break;
        }
        case -4: {
          s = `
`;
          break;
        }
        case -3: {
          s = `\r
`;
          break;
        }
        case -2: {
          s = "	";
          break;
        }
        case -1: {
          if (r) continue;
          s = " ";
          break;
        }
        default:
          s = String.fromCharCode(i);
      }
    (r = i === -2), n.push(s);
  }
  return n.join("");
}
function wd(t) {
  const e = t || {},
    n = e.loc || {},
    r = e.range || [void 0, void 0],
    i = S2(n.start, r[0] || e.start),
    s = S2(n.end, r[1] || e.end);
  if (i && s) return { start: i, end: s };
}
function S2(t, e) {
  if (t && typeof t == "object") {
    const n = "line" in t ? f0(t.line) : void 0,
      r = "column" in t ? f0(t.column) : void 0;
    if (n && r !== void 0) return { line: n, column: r + 1, offset: f0(e) };
  }
}
function f0(t) {
  return typeof t == "number" && t > -1 ? t : void 0;
}
const Fa = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression",
  uV = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-",
  hV = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed",
  k2 = "#unexpected-type-in-code-expected-an-object-spread-spread",
  fV = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported",
  dV = "#could-not-parse-expression-with-acorn";
function lp(t, e, n, r, i, s, o, a, l, c, u) {
  const h = this,
    f = this.events.length + 3;
  let d = 0,
    p,
    m;
  return O;
  function O(y) {
    return t.enter(n), t.enter(r), t.consume(y), t.exit(r), (p = h.now()), v;
  }
  function v(y) {
    if (y === null) {
      if (m) throw m;
      const S = new ct("Unexpected end of file in expression, expected a corresponding closing brace for `{`", {
        place: h.now(),
        ruleId: "unexpected-eof",
        source: "micromark-extension-mdx-expression",
      });
      throw ((S.url = Fa + uV), S);
    }
    if (de(y)) return t.enter("lineEnding"), t.consume(y), t.exit("lineEnding"), x;
    if (y === 125 && d === 0) {
      const S = s ? pV.call(h, s, o, i, f, p, c || !1, l || !1) : { type: "ok", estree: void 0 };
      if (S.type === "ok") {
        t.enter(r), t.consume(y), t.exit(r);
        const k = t.exit(n);
        return a && S.estree && Object.assign(k, { estree: S.estree }), e;
      }
      return (m = S.message), t.enter(i), t.consume(y), g;
    }
    return t.enter(i), g(y);
  }
  function g(y) {
    return (y === 125 && d === 0) || y === null || de(y)
      ? (t.exit(i), v(y))
      : (y === 123 && !s ? (d += 1) : y === 125 && (d -= 1), t.consume(y), g);
  }
  function x(y) {
    const S = h.now();
    if (S.line !== p.line && !u && h.parser.lazy[S.line]) {
      const k = new ct(
        "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        { place: h.now(), ruleId: "unexpected-lazy", source: "micromark-extension-mdx-expression" }
      );
      throw ((k.url = Fa + hV), k);
    }
    return v(y);
  }
}
function pV(t, e, n, r, i, s, o) {
  const a = q3(this.events.slice(r), {
      acorn: t,
      tokenTypes: [n],
      acornOptions: e,
      start: i,
      expression: !0,
      allowEmpty: s,
      prefix: o ? "({" : "",
      suffix: o ? "})" : "",
    }),
    l = a.estree;
  if (o && l) {
    const c = l.body[0];
    if (c.type !== "ExpressionStatement" || c.expression.type !== "ObjectExpression") {
      const u = wd(c),
        h = new ct("Unexpected `" + c.type + "` in code: expected an object spread (`{...spread}`)", {
          place: u.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression",
        });
      throw ((h.url = Fa + k2), h);
    }
    if (c.expression.properties[1]) {
      const u = wd(c.expression.properties[1]),
        h = new ct("Unexpected extra content in spread: only a single spread is supported", {
          place: u.start,
          ruleId: "spread-extra",
          source: "micromark-extension-mdx-expression",
        });
      throw ((h.url = Fa + fV), h);
    }
    if (c.expression.properties[0] && c.expression.properties[0].type !== "SpreadElement") {
      const u = wd(c.expression.properties[0]),
        h = new ct("Unexpected `" + c.expression.properties[0].type + "` in code: only spread elements are supported", {
          place: u.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression",
        });
      throw ((h.url = Fa + k2), h);
    }
  }
  if (a.error) {
    const c = new ct("Could not parse expression with acorn", {
      cause: a.error,
      place: { line: a.error.loc.line, column: a.error.loc.column + 1, offset: a.error.pos },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression",
    });
    return (c.url = Fa + dV), { type: "nok", message: c };
  }
  return { type: "ok", estree: l };
}
const C2 = "https://github.com/micromark/micromark-extension-mdx-jsx";
function Y3(t, e, n, r, i, s, o, a, l, c, u, h, f, d, p, m, O, v, g, x, y, S, k, b, _, T, P, M, D, V, Q, N) {
  const G = this;
  let H, te;
  return le;
  function le(I) {
    return t.enter(a), t.enter(l), t.consume(I), t.exit(l), $;
  }
  function $(I) {
    return st(I) ? n(I) : ((H = B), it(I));
  }
  function B(I) {
    if (I === 47) return t.enter(c), t.consume(I), t.exit(c), (H = ie), it;
    if (I === 62) return Lt(I);
    if (I !== null && I >= 0 && Vr(I)) return t.enter(h), t.enter(f), t.consume(I), L;
    K(
      I,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")
    );
  }
  function ie(I) {
    if (I === 62) return Lt(I);
    if (I !== null && I >= 0 && Vr(I)) return t.enter(h), t.enter(f), t.consume(I), L;
    K(
      I,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 42 || I === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function L(I) {
    if (I !== null && I >= 0 && xc(I, { jsx: !0 })) return t.consume(I), L;
    if (I === 46 || I === 47 || I === 58 || I === 62 || I === 123 || st(I) || Xi(I)) return t.exit(f), (H = pe), it(I);
    K(
      I,
      "in name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
        (I === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function pe(I) {
    if (I === 46) return t.enter(d), t.consume(I), t.exit(d), (H = Ce), it;
    if (I === 58) return t.enter(m), t.consume(I), t.exit(m), (H = q), it;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && Vr(I))) return t.exit(h), ve(I);
    K(
      I,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function Ce(I) {
    if (I !== null && I >= 0 && Vr(I)) return t.enter(p), t.consume(I), me;
    K(
      I,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function me(I) {
    if (I !== null && I >= 0 && xc(I, { jsx: !0 })) return t.consume(I), me;
    if (I === 46 || I === 47 || I === 62 || I === 123 || st(I) || Xi(I)) return t.exit(p), (H = Y), it(I);
    K(
      I,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
        (I === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function Y(I) {
    if (I === 46) return t.enter(d), t.consume(I), t.exit(d), (H = Ce), it;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && Vr(I))) return t.exit(h), ve(I);
    K(
      I,
      "after member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function q(I) {
    if (I !== null && I >= 0 && Vr(I)) return t.enter(O), t.consume(I), se;
    K(
      I,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 43 || (I !== null && I > 46 && I < 58) ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function se(I) {
    if (I !== null && I >= 0 && xc(I, { jsx: !0 })) return t.consume(I), se;
    if (I === 47 || I === 62 || I === 123 || st(I) || Xi(I)) return t.exit(O), (H = ue), it(I);
    K(I, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function ue(I) {
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && Vr(I))) return t.exit(h), ve(I);
    K(
      I,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function ve(I) {
    if (I === 47) return t.enter(u), t.consume(I), t.exit(u), (H = Ut), it;
    if (I === 62) return Lt(I);
    if (I === 123) return lp.call(G, t, Pe, v, g, x, r, i, s, !0, !1, o)(I);
    if (I !== null && I >= 0 && Vr(I)) return t.enter(y), t.enter(S), t.enter(k), t.consume(I), Fe;
    K(
      I,
      "before attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function Pe(I) {
    return (H = ve), it(I);
  }
  function Fe(I) {
    if (I !== null && I >= 0 && xc(I, { jsx: !0 })) return t.consume(I), Fe;
    if (I === 47 || I === 58 || I === 61 || I === 62 || I === 123 || st(I) || Xi(I)) return t.exit(k), (H = rt), it(I);
    K(
      I,
      "in attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function rt(I) {
    if (I === 58) return t.enter(b), t.consume(I), t.exit(b), (H = Rt), it;
    if (I === 61) return t.exit(S), t.enter(T), t.consume(I), t.exit(T), (H = Ge), it;
    if (I === 47 || I === 62 || I === 123 || st(I) || Xi(I) || (I !== null && I >= 0 && Vr(I)))
      return t.exit(S), t.exit(y), (H = ve), it(I);
    K(
      I,
      "after attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function Rt(I) {
    if (I !== null && I >= 0 && Vr(I)) return t.enter(_), t.consume(I), Qt;
    K(
      I,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function Qt(I) {
    if (I !== null && I >= 0 && xc(I, { jsx: !0 })) return t.consume(I), Qt;
    if (I === 47 || I === 61 || I === 62 || I === 123 || st(I) || Xi(I)) return t.exit(_), t.exit(S), (H = Ft), it(I);
    K(
      I,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function Ft(I) {
    if (I === 61) return t.enter(T), t.consume(I), t.exit(T), (H = Ge), it;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && Vr(I))) return t.exit(y), ve(I);
    K(
      I,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function Ge(I) {
    if (I === 34 || I === 39) return t.enter(P), t.enter(M), t.consume(I), t.exit(M), (te = I), We;
    if (I === 123) return lp.call(G, t, Ve, V, Q, N, r, i, s, !1, !1, o)(I);
    K(
      I,
      "before attribute value",
      "a character that can start an attribute value, such as `\"`, `'`, or `{`" +
        (I === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")
    );
  }
  function Ve(I) {
    return t.exit(y), (H = ve), it(I);
  }
  function We(I) {
    return (
      I === null && K(I, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(te) + "`"),
      I === te
        ? (t.enter(M), t.consume(I), t.exit(M), t.exit(P), t.exit(y), (te = void 0), (H = ve), it)
        : de(I)
        ? ((H = We), it(I))
        : (t.enter(D), De(I))
    );
  }
  function De(I) {
    return I === null || I === te || de(I) ? (t.exit(D), We(I)) : (t.consume(I), De);
  }
  function Ut(I) {
    if (I === 62) return Lt(I);
    K(
      I,
      "after self-closing slash",
      "`>` to end the tag" + (I === 42 || I === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function Lt(I) {
    return t.enter(l), t.consume(I), t.exit(l), t.exit(a), e;
  }
  function it(I) {
    return de(I)
      ? (t.enter("lineEnding"), t.consume(I), t.exit("lineEnding"), U)
      : Re(I) || Xi(I)
      ? (t.enter("esWhitespace"), hn(I))
      : H(I);
  }
  function hn(I) {
    return de(I) ? (t.exit("esWhitespace"), it(I)) : Re(I) || Xi(I) ? (t.consume(I), hn) : (t.exit("esWhitespace"), H(I));
  }
  function U(I) {
    if (!o && G.parser.lazy[G.now().line]) {
      const $e = new ct(
        "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        G.now(),
        "micromark-extension-mdx-jsx:unexpected-lazy"
      );
      throw (($e.url = C2 + "#unexpected-lazy-line-in-container-expected-line-to-be"), $e);
    }
    return it(I);
  }
  function K(I, $e, je) {
    const wt = new ct(
      "Unexpected " +
        (I === null ? "end of file" : "character `" + (I === 96 ? "` ` `" : String.fromCodePoint(I)) + "` (" + mV(I) + ")") +
        " " +
        $e +
        ", expected " +
        je,
      G.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (I === null ? "eof" : "character")
    );
    throw ((wt.url = C2 + (I === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect")), wt);
  }
}
function mV(t) {
  return "U+" + t.toString(16).toUpperCase().padStart(4, "0");
}
function gV(t, e) {
  return { name: "mdxJsxTextTag", tokenize: n };
  function n(r, i, s) {
    return Y3.call(
      this,
      r,
      i,
      s,
      t,
      e.acornOptions,
      e.addResult,
      !0,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue"
    );
  }
}
function Me(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(l) {
    return Re(l) ? (t.enter(n), a(l)) : e(l);
  }
  function a(l) {
    return Re(l) && s++ < i ? (t.consume(l), a) : (t.exit(n), e(l));
  }
}
function OV(t, e) {
  return { name: "mdxJsxFlowTag", tokenize: n, concrete: !0 };
  function n(r, i, s) {
    const o = this;
    return a;
    function a(h) {
      return l(h);
    }
    function l(h) {
      return Y3.call(
        o,
        r,
        c,
        s,
        t,
        e.acornOptions,
        e.addResult,
        !1,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue"
      )(h);
    }
    function c(h) {
      return Re(h) ? Me(r, u, "whitespace")(h) : u(h);
    }
    function u(h) {
      const f = o.parser.constructs.flow[123],
        p = (Array.isArray(f) ? f : f ? [f] : []).find((m) => m.name === "mdxFlowExpression");
      return h === 60 ? a(h) : h === 123 && p ? r.attempt(p, u, s)(h) : h === null || de(h) ? i(h) : s(h);
    }
  }
}
function G3(t) {
  const e = t || {},
    n = e.acorn;
  let r;
  if (n) {
    if (!n.parse || !n.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    r = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, e.acornOptions, { locations: !0 });
  } else if (e.acornOptions || e.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: { 60: OV(n || void 0, { acornOptions: r, addResult: e.addResult || void 0 }) },
    text: { 60: gV(n || void 0, { acornOptions: r, addResult: e.addResult || void 0 }) },
  };
}
function J3() {
  return { disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] } };
}
const _2 = {}.hasOwnProperty;
function vV(t, e) {
  const n = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const a = r.handlers;
    if (i && _2.call(i, t)) {
      const l = String(i[t]);
      o = _2.call(a, l) ? a[l] : r.unknown;
    }
    if (o) return o.call(this, i, ...s);
  }
  return (r.handlers = n.handlers || {}), (r.invalid = n.invalid), (r.unknown = n.unknown), r;
}
const xV = {}.hasOwnProperty;
function K3(t, e) {
  let n = -1,
    r;
  if (e.extensions) for (; ++n < e.extensions.length; ) K3(t, e.extensions[n]);
  for (r in e)
    if (xV.call(e, r))
      switch (r) {
        case "extensions":
          break;
        case "unsafe": {
          E2(t[r], e[r]);
          break;
        }
        case "join": {
          E2(t[r], e[r]);
          break;
        }
        case "handlers": {
          bV(t[r], e[r]);
          break;
        }
        default:
          t.options[r] = e[r];
      }
  return t;
}
function E2(t, e) {
  e && t.push(...e);
}
function bV(t, e) {
  e && Object.assign(t, e);
}
function yV(t, e, n, r) {
  const i = n.enter("blockquote"),
    s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const o = n.indentLines(n.containerFlow(t, s.current()), wV);
  return i(), o;
}
function wV(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function eA(t, e) {
  return T2(t, e.inConstruct, !0) && !T2(t, e.notInConstruct, !1);
}
function T2(t, e, n) {
  if ((typeof e == "string" && (e = [e]), !e || e.length === 0)) return n;
  let r = -1;
  for (; ++r < e.length; ) if (t.includes(e[r])) return !0;
  return !1;
}
function P2(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (
      n.unsafe[i].character ===
        `
` &&
      eA(n.stack, n.unsafe[i])
    )
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function SV(t, e) {
  const n = String(t);
  let r = n.indexOf(e),
    i = r,
    s = 0,
    o = 0;
  if (typeof e != "string") throw new TypeError("Expected substring");
  for (; r !== -1; ) r === i ? ++s > o && (o = s) : (s = 1), (i = r + e.length), (r = n.indexOf(e, i));
  return o;
}
function CO(t, e) {
  return !!(
    e.options.fences === !1 &&
    t.value &&
    !t.lang &&
    /[^ \r\n]/.test(t.value) &&
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value)
  );
}
function kV(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~") throw new Error("Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`");
  return e;
}
function CV(t, e, n, r) {
  const i = kV(n),
    s = t.value || "",
    o = i === "`" ? "GraveAccent" : "Tilde";
  if (CO(t, n)) {
    const h = n.enter("codeIndented"),
      f = n.indentLines(s, _V);
    return h(), f;
  }
  const a = n.createTracker(r),
    l = i.repeat(Math.max(SV(s, i) + 1, 3)),
    c = n.enter("codeFenced");
  let u = a.move(l);
  if (t.lang) {
    const h = n.enter(`codeFencedLang${o}`);
    (u += a.move(n.safe(t.lang, { before: u, after: " ", encode: ["`"], ...a.current() }))), h();
  }
  if (t.lang && t.meta) {
    const h = n.enter(`codeFencedMeta${o}`);
    (u += a.move(" ")),
      (u += a.move(
        n.safe(t.meta, {
          before: u,
          after: `
`,
          encode: ["`"],
          ...a.current(),
        })
      )),
      h();
  }
  return (
    (u += a.move(`
`)),
    s &&
      (u += a.move(
        s +
          `
`
      )),
    (u += a.move(l)),
    c(),
    u
  );
}
function _V(t, e, n) {
  return (n ? "" : "    ") + t;
}
function Mb(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'") throw new Error("Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`");
  return e;
}
function EV(t, e, n, r) {
  const i = Mb(n),
    s = i === '"' ? "Quote" : "Apostrophe",
    o = n.enter("definition");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return (
    (c += l.move(n.safe(n.associationId(t), { before: c, after: "]", ...l.current() }))),
    (c += l.move("]: ")),
    a(),
    !t.url || /[\0- \u007F]/.test(t.url)
      ? ((a = n.enter("destinationLiteral")),
        (c += l.move("<")),
        (c += l.move(n.safe(t.url, { before: c, after: ">", ...l.current() }))),
        (c += l.move(">")))
      : ((a = n.enter("destinationRaw")),
        (c += l.move(
          n.safe(t.url, {
            before: c,
            after: t.title
              ? " "
              : `
`,
            ...l.current(),
          })
        ))),
    a(),
    t.title &&
      ((a = n.enter(`title${s}`)),
      (c += l.move(" " + i)),
      (c += l.move(n.safe(t.title, { before: c, after: i, ...l.current() }))),
      (c += l.move(i)),
      a()),
    o(),
    c
  );
}
function TV(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_") throw new Error("Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`");
  return e;
}
tA.peek = PV;
function tA(t, e, n, r) {
  const i = TV(n),
    s = n.enter("emphasis"),
    o = n.createTracker(r);
  let a = o.move(i);
  return (a += o.move(n.containerPhrasing(t, { before: a, after: i, ...o.current() }))), (a += o.move(i)), s(), a;
}
function PV(t, e, n) {
  return n.options.emphasis || "*";
}
const Db = function (t) {
  if (t == null) return IV;
  if (typeof t == "function") return zm(t);
  if (typeof t == "object") return Array.isArray(t) ? AV(t) : $V(t);
  if (typeof t == "string") return RV(t);
  throw new Error("Expected function, string, or object as test");
};
function AV(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; ) e[n] = Db(t[n]);
  return zm(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; ) if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function $V(t) {
  const e = t;
  return zm(n);
  function n(r) {
    const i = r;
    let s;
    for (s in t) if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function RV(t) {
  return zm(e);
  function e(n) {
    return n && n.type === t;
  }
}
function zm(t) {
  return e;
  function e(n, r, i) {
    return !!(NV(n) && t.call(this, n, typeof r == "number" ? r : void 0, i || void 0));
  }
}
function IV() {
  return !0;
}
function NV(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const nA = [],
  LV = !0,
  _O = !1,
  MV = "skip";
function rA(t, e, n, r) {
  let i;
  typeof e == "function" && typeof n != "function" ? ((r = n), (n = e)) : (i = e);
  const s = Db(i),
    o = r ? -1 : 1;
  a(t, void 0, [])();
  function a(l, c, u) {
    const h = l && typeof l == "object" ? l : {};
    if (typeof h.type == "string") {
      const d = typeof h.tagName == "string" ? h.tagName : typeof h.name == "string" ? h.name : void 0;
      Object.defineProperty(f, "name", { value: "node (" + (l.type + (d ? "<" + d + ">" : "")) + ")" });
    }
    return f;
    function f() {
      let d = nA,
        p,
        m,
        O;
      if ((!e || s(l, c, u[u.length - 1] || void 0)) && ((d = DV(n(l, u))), d[0] === _O)) return d;
      if ("children" in l && l.children) {
        const v = l;
        if (v.children && d[0] !== MV)
          for (m = (r ? v.children.length : -1) + o, O = u.concat(v); m > -1 && m < v.children.length; ) {
            const g = v.children[m];
            if (((p = a(g, m, O)()), p[0] === _O)) return p;
            m = typeof p[1] == "number" ? p[1] : m + o;
          }
      }
      return d;
    }
  }
}
function DV(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [LV, t] : t == null ? nA : [t];
}
function QV(t, e, n, r) {
  let i, s, o;
  typeof e == "function" && typeof n != "function" ? ((s = void 0), (o = e), (i = n)) : ((s = e), (o = n), (i = r)), rA(t, s, a, i);
  function a(l, c) {
    const u = c[c.length - 1],
      h = u ? u.children.indexOf(l) : void 0;
    return o(l, h, u);
  }
}
const FV = {};
function Qb(t, e) {
  const n = e || FV,
    r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0,
    i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return iA(t, r, i);
}
function iA(t, e, n) {
  if (VV(t)) {
    if ("value" in t) return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt) return t.alt;
    if ("children" in t) return A2(t.children, e, n);
  }
  return Array.isArray(t) ? A2(t, e, n) : "";
}
function A2(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) r[i] = iA(t[i], e, n);
  return r.join("");
}
function VV(t) {
  return !!(t && typeof t == "object");
}
function sA(t, e) {
  let n = !1;
  return (
    QV(t, function (r) {
      if (("value" in r && /\r?\n|\r/.test(r.value)) || r.type === "break") return (n = !0), _O;
    }),
    !!((!t.depth || t.depth < 3) && Qb(t) && (e.options.setext || n))
  );
}
function BV(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1),
    s = n.createTracker(r);
  if (sA(t, n)) {
    const u = n.enter("headingSetext"),
      h = n.enter("phrasing"),
      f = n.containerPhrasing(t, {
        ...s.current(),
        before: `
`,
        after: `
`,
      });
    return (
      h(),
      u(),
      f +
        `
` +
        (i === 1 ? "=" : "-").repeat(
          f.length -
            (Math.max(
              f.lastIndexOf("\r"),
              f.lastIndexOf(`
`)
            ) +
              1)
        )
    );
  }
  const o = "#".repeat(i),
    a = n.enter("headingAtx"),
    l = n.enter("phrasing");
  s.move(o + " ");
  let c = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...s.current(),
  });
  return (
    /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)),
    (c = c ? o + " " + c : o),
    n.options.closeAtx && (c += " " + o),
    l(),
    a(),
    c
  );
}
oA.peek = jV;
function oA(t) {
  return t.value || "";
}
function jV() {
  return "<";
}
aA.peek = ZV;
function aA(t, e, n, r) {
  const i = Mb(n),
    s = i === '"' ? "Quote" : "Apostrophe",
    o = n.enter("image");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return (
    (c += l.move(n.safe(t.alt, { before: c, after: "]", ...l.current() }))),
    (c += l.move("](")),
    a(),
    (!t.url && t.title) || /[\0- \u007F]/.test(t.url)
      ? ((a = n.enter("destinationLiteral")),
        (c += l.move("<")),
        (c += l.move(n.safe(t.url, { before: c, after: ">", ...l.current() }))),
        (c += l.move(">")))
      : ((a = n.enter("destinationRaw")), (c += l.move(n.safe(t.url, { before: c, after: t.title ? " " : ")", ...l.current() })))),
    a(),
    t.title &&
      ((a = n.enter(`title${s}`)),
      (c += l.move(" " + i)),
      (c += l.move(n.safe(t.title, { before: c, after: i, ...l.current() }))),
      (c += l.move(i)),
      a()),
    (c += l.move(")")),
    o(),
    c
  );
}
function ZV() {
  return "!";
}
lA.peek = zV;
function lA(t, e, n, r) {
  const i = t.referenceType,
    s = n.enter("imageReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("![");
  const c = n.safe(t.alt, { before: l, after: "]", ...a.current() });
  (l += a.move(c + "][")), o();
  const u = n.stack;
  (n.stack = []), (o = n.enter("reference"));
  const h = n.safe(n.associationId(t), { before: l, after: "]", ...a.current() });
  return (
    o(),
    (n.stack = u),
    s(),
    i === "full" || !c || c !== h ? (l += a.move(h + "]")) : i === "shortcut" ? (l = l.slice(0, -1)) : (l += a.move("]")),
    l
  );
}
function zV() {
  return "!";
}
cA.peek = WV;
function cA(t, e, n) {
  let r = t.value || "",
    i = "`",
    s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); ) i += "`";
  for (
    /[^ \r\n]/.test(r) && ((/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r)) || /^`|`$/.test(r)) && (r = " " + r + " ");
    ++s < n.unsafe.length;

  ) {
    const o = n.unsafe[s],
      a = n.compilePattern(o);
    let l;
    if (o.atBreak)
      for (; (l = a.exec(r)); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, (r = r.slice(0, c) + " " + r.slice(l.index + 1));
      }
  }
  return i + r + i;
}
function WV() {
  return "`";
}
function uA(t, e) {
  const n = Qb(t);
  return !!(
    !e.options.resourceLink &&
    t.url &&
    !t.title &&
    t.children &&
    t.children.length === 1 &&
    t.children[0].type === "text" &&
    (n === t.url || "mailto:" + n === t.url) &&
    /^[a-z][a-z+.-]+:/i.test(t.url) &&
    !/[\0- <>\u007F]/.test(t.url)
  );
}
hA.peek = UV;
function hA(t, e, n, r) {
  const i = Mb(n),
    s = i === '"' ? "Quote" : "Apostrophe",
    o = n.createTracker(r);
  let a, l;
  if (uA(t, n)) {
    const u = n.stack;
    (n.stack = []), (a = n.enter("autolink"));
    let h = o.move("<");
    return (h += o.move(n.containerPhrasing(t, { before: h, after: ">", ...o.current() }))), (h += o.move(">")), a(), (n.stack = u), h;
  }
  (a = n.enter("link")), (l = n.enter("label"));
  let c = o.move("[");
  return (
    (c += o.move(n.containerPhrasing(t, { before: c, after: "](", ...o.current() }))),
    (c += o.move("](")),
    l(),
    (!t.url && t.title) || /[\0- \u007F]/.test(t.url)
      ? ((l = n.enter("destinationLiteral")),
        (c += o.move("<")),
        (c += o.move(n.safe(t.url, { before: c, after: ">", ...o.current() }))),
        (c += o.move(">")))
      : ((l = n.enter("destinationRaw")), (c += o.move(n.safe(t.url, { before: c, after: t.title ? " " : ")", ...o.current() })))),
    l(),
    t.title &&
      ((l = n.enter(`title${s}`)),
      (c += o.move(" " + i)),
      (c += o.move(n.safe(t.title, { before: c, after: i, ...o.current() }))),
      (c += o.move(i)),
      l()),
    (c += o.move(")")),
    a(),
    c
  );
}
function UV(t, e, n) {
  return uA(t, n) ? "<" : "[";
}
fA.peek = XV;
function fA(t, e, n, r) {
  const i = t.referenceType,
    s = n.enter("linkReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("[");
  const c = n.containerPhrasing(t, { before: l, after: "]", ...a.current() });
  (l += a.move(c + "][")), o();
  const u = n.stack;
  (n.stack = []), (o = n.enter("reference"));
  const h = n.safe(n.associationId(t), { before: l, after: "]", ...a.current() });
  return (
    o(),
    (n.stack = u),
    s(),
    i === "full" || !c || c !== h ? (l += a.move(h + "]")) : i === "shortcut" ? (l = l.slice(0, -1)) : (l += a.move("]")),
    l
  );
}
function XV() {
  return "[";
}
function Fb(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error("Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`");
  return e;
}
function HV(t) {
  const e = Fb(t),
    n = t.options.bulletOther;
  if (!n) return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
  if (n === e) throw new Error("Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different");
  return n;
}
function qV(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")") throw new Error("Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`");
  return e;
}
function dA(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error("Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`");
  return e;
}
function YV(t, e, n, r) {
  const i = n.enter("list"),
    s = n.bulletCurrent;
  let o = t.ordered ? qV(n) : Fb(n);
  const a = t.ordered ? (o === "." ? ")" : ".") : HV(n);
  let l = e && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const u = t.children ? t.children[0] : void 0;
    if (
      ((o === "*" || o === "-") &&
        u &&
        (!u.children || !u.children[0]) &&
        n.stack[n.stack.length - 1] === "list" &&
        n.stack[n.stack.length - 2] === "listItem" &&
        n.stack[n.stack.length - 3] === "list" &&
        n.stack[n.stack.length - 4] === "listItem" &&
        n.indexStack[n.indexStack.length - 1] === 0 &&
        n.indexStack[n.indexStack.length - 2] === 0 &&
        n.indexStack[n.indexStack.length - 3] === 0 &&
        (l = !0),
      dA(n) === o && u)
    ) {
      let h = -1;
      for (; ++h < t.children.length; ) {
        const f = t.children[h];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (o = a), (n.bulletCurrent = o);
  const c = n.containerFlow(t, r);
  return (n.bulletLastUsed = o), (n.bulletCurrent = s), i(), c;
}
function GV(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error("Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  return e;
}
function JV(t, e, n, r) {
  const i = GV(n);
  let s = n.bulletCurrent || Fb(n);
  e &&
    e.type === "list" &&
    e.ordered &&
    (s =
      (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
  let o = s.length + 1;
  (i === "tab" || (i === "mixed" && ((e && e.type === "list" && e.spread) || t.spread))) && (o = Math.ceil(o / 4) * 4);
  const a = n.createTracker(r);
  a.move(s + " ".repeat(o - s.length)), a.shift(o);
  const l = n.enter("listItem"),
    c = n.indentLines(n.containerFlow(t, a.current()), u);
  return l(), c;
  function u(h, f, d) {
    return f ? (d ? "" : " ".repeat(o)) + h : (d ? s : s + " ".repeat(o - s.length)) + h;
  }
}
function KV(t, e, n, r) {
  const i = n.enter("paragraph"),
    s = n.enter("phrasing"),
    o = n.containerPhrasing(t, r);
  return s(), i(), o;
}
const eB = Db([
  "break",
  "delete",
  "emphasis",
  "footnote",
  "footnoteReference",
  "image",
  "imageReference",
  "inlineCode",
  "inlineMath",
  "link",
  "linkReference",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "strong",
  "text",
  "textDirective",
]);
function tB(t, e, n, r) {
  return (
    t.children.some(function (o) {
      return eB(o);
    })
      ? n.containerPhrasing
      : n.containerFlow
  ).call(n, t, r);
}
function nB(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_") throw new Error("Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`");
  return e;
}
pA.peek = rB;
function pA(t, e, n, r) {
  const i = nB(n),
    s = n.enter("strong"),
    o = n.createTracker(r);
  let a = o.move(i + i);
  return (a += o.move(n.containerPhrasing(t, { before: a, after: i, ...o.current() }))), (a += o.move(i + i)), s(), a;
}
function rB(t, e, n) {
  return n.options.strong || "*";
}
function iB(t, e, n, r) {
  return n.safe(t.value, r);
}
function sB(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3) throw new Error("Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more");
  return e;
}
function oB(t, e, n) {
  const r = (dA(n) + (n.options.ruleSpaces ? " " : "")).repeat(sB(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Vb = {
    blockquote: yV,
    break: P2,
    code: CV,
    definition: EV,
    emphasis: tA,
    hardBreak: P2,
    heading: BV,
    html: oA,
    image: aA,
    imageReference: lA,
    inlineCode: cA,
    link: hA,
    linkReference: fA,
    list: YV,
    listItem: JV,
    paragraph: KV,
    root: tB,
    strong: pA,
    text: iB,
    thematicBreak: oB,
  },
  aB = [lB];
function lB(t, e, n, r) {
  if (e.type === "code" && CO(e, r) && (t.type === "list" || (t.type === e.type && CO(t, r)))) return !1;
  if ("spread" in n && typeof n.spread == "boolean")
    return t.type === "paragraph" && (t.type === e.type || e.type === "definition" || (e.type === "heading" && sA(e, r)))
      ? void 0
      : n.spread
      ? 1
      : 0;
}
const ko = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"],
  cB = [
    { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx",
      ],
    },
    {
      character: `
`,
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx",
      ],
    },
    { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] },
    { character: "!", after: "\\[", inConstruct: "phrasing", notInConstruct: ko },
    { character: '"', inConstruct: "titleQuote" },
    { atBreak: !0, character: "#" },
    {
      character: "#",
      inConstruct: "headingAtx",
      after: `(?:[\r
]|$)`,
    },
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    { character: "'", inConstruct: "titleApostrophe" },
    { character: "(", inConstruct: "destinationRaw" },
    { before: "\\]", character: "(", inConstruct: "phrasing", notInConstruct: ko },
    { atBreak: !0, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    {
      atBreak: !0,
      character: "*",
      after: `(?:[ 	\r
*])`,
    },
    { character: "*", inConstruct: "phrasing", notInConstruct: ko },
    {
      atBreak: !0,
      character: "+",
      after: `(?:[ 	\r
])`,
    },
    {
      atBreak: !0,
      character: "-",
      after: `(?:[ 	\r
-])`,
    },
    {
      atBreak: !0,
      before: "\\d+",
      character: ".",
      after: `(?:[ 	\r
]|$)`,
    },
    { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
    { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing", notInConstruct: ko },
    { character: "<", inConstruct: "destinationLiteral" },
    { atBreak: !0, character: "=" },
    { atBreak: !0, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    { atBreak: !0, character: "[" },
    { character: "[", inConstruct: "phrasing", notInConstruct: ko },
    { character: "[", inConstruct: ["label", "reference"] },
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "]", inConstruct: ["label", "reference"] },
    { atBreak: !0, character: "_" },
    { character: "_", inConstruct: "phrasing", notInConstruct: ko },
    { atBreak: !0, character: "`" },
    { character: "`", inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"] },
    { character: "`", inConstruct: "phrasing", notInConstruct: ko },
    { atBreak: !0, character: "~" },
  ];
function mA(t, e) {
  const n = Number.parseInt(t, e);
  return n < 9 ||
    n === 11 ||
    (n > 13 && n < 32) ||
    (n > 126 && n < 160) ||
    (n > 55295 && n < 57344) ||
    (n > 64975 && n < 65008) ||
    (n & 65535) === 65535 ||
    (n & 65535) === 65534 ||
    n > 1114111
    ? "�"
    : String.fromCodePoint(n);
}
const uB = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function gA(t) {
  return t.replace(uB, hB);
}
function hB(t, e, n) {
  if (e) return e;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1),
      s = i === 120 || i === 88;
    return mA(n.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return Cu(n) || t;
}
function fB(t) {
  return t.label || !t.identifier ? t.label || "" : gA(t.identifier);
}
function dB(t) {
  if (!t._compiled) {
    const e = (t.atBreak ? "[\\r\\n][\\t ]*" : "") + (t.before ? "(?:" + t.before + ")" : "");
    t._compiled = new RegExp(
      (e ? "(" + e + ")" : "") +
        (/[|\\{}()[\]^$+*?.-]/.test(t.character) ? "\\" : "") +
        t.character +
        (t.after ? "(?:" + t.after + ")" : ""),
      "g"
    );
  }
  return t._compiled;
}
function pB(t, e, n) {
  const r = e.indexStack,
    i = t.children || [],
    s = [];
  let o = -1,
    a = n.before;
  r.push(-1);
  let l = e.createTracker(n);
  for (; ++o < i.length; ) {
    const c = i[o];
    let u;
    if (((r[r.length - 1] = o), o + 1 < i.length)) {
      let h = e.handle.handlers[i[o + 1].type];
      h && h.peek && (h = h.peek), (u = h ? h(i[o + 1], t, e, { before: "", after: "", ...l.current() }).charAt(0) : "");
    } else u = n.after;
    s.length > 0 &&
      (a === "\r" ||
        a ===
          `
`) &&
      c.type === "html" &&
      ((s[s.length - 1] = s[s.length - 1].replace(/(\r?\n|\r)$/, " ")), (a = " "), (l = e.createTracker(n)), l.move(s.join(""))),
      s.push(l.move(e.handle(c, t, e, { ...l.current(), before: a, after: u }))),
      (a = s[s.length - 1].slice(-1));
  }
  return r.pop(), s.join("");
}
function mB(t, e, n) {
  const r = e.indexStack,
    i = t.children || [],
    s = e.createTracker(n),
    o = [];
  let a = -1;
  for (r.push(-1); ++a < i.length; ) {
    const l = i[a];
    (r[r.length - 1] = a),
      o.push(
        s.move(
          e.handle(l, t, e, {
            before: `
`,
            after: `
`,
            ...s.current(),
          })
        )
      ),
      l.type !== "list" && (e.bulletLastUsed = void 0),
      a < i.length - 1 && o.push(s.move(gB(l, i[a + 1], t, e)));
  }
  return r.pop(), o.join("");
}
function gB(t, e, n, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](t, e, n, r);
    if (s === !0 || s === 1) break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const OB = /\r?\n|\r/g;
function vB(t, e) {
  const n = [];
  let r = 0,
    i = 0,
    s;
  for (; (s = OB.exec(t)); ) o(t.slice(r, s.index)), n.push(s[0]), (r = s.index + s[0].length), i++;
  return o(t.slice(r)), n.join("");
  function o(a) {
    n.push(e(a, i, !a));
  }
}
function xB(t, e, n) {
  const r = (n.before || "") + (e || "") + (n.after || ""),
    i = [],
    s = [],
    o = {};
  let a = -1;
  for (; ++a < t.unsafe.length; ) {
    const u = t.unsafe[a];
    if (!eA(t.stack, u)) continue;
    const h = t.compilePattern(u);
    let f;
    for (; (f = h.exec(r)); ) {
      const d = "before" in u || !!u.atBreak,
        p = "after" in u,
        m = f.index + (d ? f[1].length : 0);
      i.includes(m)
        ? (o[m].before && !d && (o[m].before = !1), o[m].after && !p && (o[m].after = !1))
        : (i.push(m), (o[m] = { before: d, after: p }));
    }
  }
  i.sort(bB);
  let l = n.before ? n.before.length : 0;
  const c = r.length - (n.after ? n.after.length : 0);
  for (a = -1; ++a < i.length; ) {
    const u = i[a];
    u < l ||
      u >= c ||
      (u + 1 < c && i[a + 1] === u + 1 && o[u].after && !o[u + 1].before && !o[u + 1].after) ||
      (i[a - 1] === u - 1 && o[u].before && !o[u - 1].before && !o[u - 1].after) ||
      (l !== u && s.push($2(r.slice(l, u), "\\")),
      (l = u),
      /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!n.encode || !n.encode.includes(r.charAt(u)))
        ? s.push("\\")
        : (s.push("&#x" + r.charCodeAt(u).toString(16).toUpperCase() + ";"), l++));
  }
  return s.push($2(r.slice(l, c), n.after)), s.join("");
}
function bB(t, e) {
  return t - e;
}
function $2(t, e) {
  const n = /\\(?=[!-/:-@[-`{-~])/g,
    r = [],
    i = [],
    s = t + e;
  let o = -1,
    a = 0,
    l;
  for (; (l = n.exec(s)); ) r.push(l.index);
  for (; ++o < r.length; ) a !== r[o] && i.push(t.slice(a, r[o])), i.push("\\"), (a = r[o]);
  return i.push(t.slice(a)), i.join("");
}
function yB(t) {
  const e = t || {},
    n = e.now || {};
  let r = e.lineShift || 0,
    i = n.line || 1,
    s = n.column || 1;
  return { move: l, current: o, shift: a };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function a(c) {
    r += c;
  }
  function l(c) {
    const u = c || "",
      h = u.split(/\r?\n|\r/g),
      f = h[h.length - 1];
    return (i += h.length - 1), (s = h.length === 1 ? s + f.length : 1 + f.length + r), u;
  }
}
function OA(t, e = {}) {
  const n = {
    enter: i,
    indentLines: vB,
    associationId: fB,
    containerPhrasing: CB,
    containerFlow: _B,
    createTracker: yB,
    compilePattern: dB,
    safe: EB,
    stack: [],
    unsafe: [...cB],
    join: [...aB],
    handlers: { ...Vb },
    options: {},
    indexStack: [],
    handle: void 0,
  };
  K3(n, e), n.options.tightDefinitions && n.join.push(kB), (n.handle = vV("type", { invalid: wB, unknown: SB, handlers: n.handlers }));
  let r = n.handle(t, void 0, n, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0,
  });
  return (
    r &&
      r.charCodeAt(r.length - 1) !== 10 &&
      r.charCodeAt(r.length - 1) !== 13 &&
      (r += `
`),
    r
  );
  function i(s) {
    return n.stack.push(s), o;
    function o() {
      n.stack.pop();
    }
  }
}
function wB(t) {
  throw new Error("Cannot handle value `" + t + "`, expected node");
}
function SB(t) {
  const e = t;
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function kB(t, e) {
  if (t.type === "definition" && t.type === e.type) return 0;
}
function CB(t, e) {
  return pB(t, this, e);
}
function _B(t, e) {
  return mB(t, this, e);
}
function EB(t, e) {
  return xB(this, t, e);
}
const TB = ["mdxJsxTextElement", "mdxJsxFlowElement"];
function Bb(t) {
  return TB.includes(t.type) && vA.includes(t.name.toLowerCase());
}
const vA = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
];
function PB(t, e) {
  const n = R2(t),
    r = R2(e),
    i = { ...n, ...r };
  return AB(i);
}
function R2(t) {
  const e = {};
  return (
    t
      .split(";")
      .filter((r) => r.trim() !== "")
      .forEach((r) => {
        const [i, s] = r.split(":").map((o) => o.trim());
        e[i] = s;
      }),
    e
  );
}
function AB(t) {
  return Object.entries(t)
    .map(([e, n]) => `${e}: ${n}`)
    .join("; ");
}
function $B(t) {
  return t.children instanceof Array;
}
function Wm({ root: t, visitors: e, jsxComponentDescriptors: n, jsxIsAvailable: r, addImportStatements: i = !0 }) {
  let s = null;
  const o = new Set();
  (e = e.sort((O, v) => (v.priority ?? 0) - (O.priority ?? 0))), u(t, null);
  function a(O) {
    o.add(O);
  }
  function l(O, v) {
    if (s === null) return (s = v), s;
    if (!$B(O)) throw new Error("Attempting to append children to a non-parent");
    const g = O.children,
      x = g.at(-1);
    if (x) {
      const y = e.find((S) => {
        var k;
        return (k = S.shouldJoin) == null ? void 0 : k.call(S, x, v);
      });
      if (y) {
        const S = y.join(x, v);
        return g.splice(g.length - 1, 1, S), S;
      }
    }
    return g.push(v), v;
  }
  function c(O, v) {
    O.getChildren().forEach((g) => {
      u(g, v);
    });
  }
  function u(O, v) {
    var g;
    const x = e.find((y) => {
      var S;
      return (S = y.testLexicalNode) == null ? void 0 : S.call(y, O);
    });
    if (!x) throw new Error(`no lexical visitor found for ${O.getType()}`, { cause: O });
    (g = x.visitLexicalNode) == null ||
      g.call(x, {
        lexicalNode: O,
        mdastParent: v,
        actions: {
          addAndStepInto(y, S = {}, k = !0) {
            const b = { type: y, ...S, ...(k ? { children: [] } : {}) };
            l(v, b), W(O) && k && c(O, b);
          },
          appendToParent: l,
          visitChildren: c,
          registerReferredComponent: a,
        },
      });
  }
  if (s === null) throw new Error("traversal ended with no root element");
  const h = new Map(),
    f = new Map();
  for (const O of o) {
    const v = n.find((g) => g.name === O);
    if (!v) throw new Error(`Component ${O} is used but not imported`);
    if (v.source)
      if (v.defaultExport) f.set(O, v.source);
      else {
        const { source: g } = v,
          x = h.get(g);
        x ? x.push(O) : h.set(g, [O]);
      }
  }
  const d = Array.from(h).map(([O, v]) => ({ type: "mdxjsEsm", value: `import { ${v.join(", ")} } from '${O}'` }));
  d.push(...Array.from(f).map(([O, v]) => ({ type: "mdxjsEsm", value: `import ${O} from '${v}'` })));
  const p = s,
    m = p.children.find((O) => O.type === "yaml");
  return i && (m ? p.children.splice(p.children.indexOf(m) + 1, 0, ...d) : p.children.unshift(...d)), Sd(p, []), xA(p), r || bA(p), p;
}
function xA(t) {
  if ("children" in t && t.children.length > 0) {
    if (Bb(t) && t.children.length === 1) {
      const e = t.children[0];
      e.type === "mdxJsxTextElement" &&
        e.name === "span" &&
        (e.attributes.forEach((n) => {
          if (n.type === "mdxJsxAttribute") {
            const r = t.attributes.find((i) => i.type === "mdxJsxAttribute" && i.name === n.name);
            if (r)
              if (n.name === "className") {
                const i = new Set([...r.value.split(" "), ...n.value.split(" ")]);
                r.value = Array.from(i).join(" ");
              } else n.name === "style" && (r.value = PB(r.value, n.value));
            else t.attributes.push(n);
          }
        }),
        (t.children = e.children));
    }
    t.children.forEach((e) => {
      xA(e);
    });
  }
}
function bA(t) {
  if (Object.hasOwn(t, "children")) {
    const e = t,
      n = [];
    e.children.forEach((r) => {
      r.type === "mdxJsxTextElement" && r.name === "u"
        ? n.push({ type: "html", value: "<u>" }, ...r.children, { type: "html", value: "</u>" })
        : (n.push(r), bA(r));
    }),
      (e.children = n);
  }
}
const I2 = /\s+$/,
  N2 = /^\s+/;
function Sd(t, e) {
  if (t.type === "strong" || t.type === "emphasis") {
    const n = t.children.at(-1);
    if ((n == null ? void 0 : n.type) === "text") {
      const i = n.value.match(I2);
      if (i) {
        n.value = n.value.replace(I2, "");
        const s = e.at(-1);
        s && (s.children.splice(s.children.indexOf(t) + 1, 0, { type: "text", value: i[0] }), Sd(s, e.slice(0, -1)));
      }
    }
    const r = t.children.at(0);
    if ((r == null ? void 0 : r.type) === "text") {
      const i = r.value.match(N2);
      if (i) {
        r.value = r.value.replace(N2, "");
        const s = e.at(-1);
        s && (s.children.splice(s.children.indexOf(t), 0, { type: "text", value: i[0] }), Sd(s, e.slice(0, -1)));
      }
    }
  }
  if ("children" in t && t.children.length > 0) {
    const n = t;
    n.children.forEach((r) => {
      Sd(r, [...e, n]);
    });
  }
}
function jb({ root: t, toMarkdownOptions: e, toMarkdownExtensions: n, visitors: r, jsxComponentDescriptors: i, jsxIsAvailable: s }) {
  return (
    OA(Wm({ root: t, visitors: r, jsxComponentDescriptors: i, jsxIsAvailable: s }), { extensions: n, ...e }) +
    `
`
  );
}
const L2 = {}.hasOwnProperty;
function yA(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; ) RB(e, t[n]);
  return e;
}
function RB(t, e) {
  let n;
  for (n in e) {
    const i = (L2.call(t, n) ? t[n] : void 0) || (t[n] = {}),
      s = e[n];
    let o;
    if (s)
      for (o in s) {
        L2.call(i, o) || (i[o] = []);
        const a = s[o];
        IB(i[o], Array.isArray(a) ? a : a ? [a] : []);
      }
  }
}
function IB(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; ) (e[n].add === "after" ? t : r).push(e[n]);
  Ir(t, 0, 0, r);
}
function Ya(t) {
  return t
    .replace(/[\t\n\r ]+/g, " ")
    .replace(/^ | $/g, "")
    .toLowerCase()
    .toUpperCase();
}
const NB = { tokenize: LB };
function LB(t) {
  const e = t.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return e;
  function r(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), Me(t, e, "linePrefix");
  }
  function i(a) {
    return t.enter("paragraph"), s(a);
  }
  function s(a) {
    const l = t.enter("chunkText", { contentType: "text", previous: n });
    return n && (n.next = l), (n = l), o(a);
  }
  function o(a) {
    if (a === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(a);
      return;
    }
    return de(a) ? (t.consume(a), t.exit("chunkText"), s) : (t.consume(a), o);
  }
}
const MB = { tokenize: DB },
  M2 = { tokenize: QB };
function DB(t) {
  const e = this,
    n = [];
  let r = 0,
    i,
    s,
    o;
  return a;
  function a(x) {
    if (r < n.length) {
      const y = n[r];
      return (e.containerState = y[1]), t.attempt(y[0].continuation, l, c)(x);
    }
    return c(x);
  }
  function l(x) {
    if ((r++, e.containerState._closeFlow)) {
      (e.containerState._closeFlow = void 0), i && g();
      const y = e.events.length;
      let S = y,
        k;
      for (; S--; )
        if (e.events[S][0] === "exit" && e.events[S][1].type === "chunkFlow") {
          k = e.events[S][1].end;
          break;
        }
      v(r);
      let b = y;
      for (; b < e.events.length; ) (e.events[b][1].end = Object.assign({}, k)), b++;
      return Ir(e.events, S + 1, 0, e.events.slice(y)), (e.events.length = b), c(x);
    }
    return a(x);
  }
  function c(x) {
    if (r === n.length) {
      if (!i) return f(x);
      if (i.currentConstruct && i.currentConstruct.concrete) return p(x);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return (e.containerState = {}), t.check(M2, u, h)(x);
  }
  function u(x) {
    return i && g(), v(r), f(x);
  }
  function h(x) {
    return (e.parser.lazy[e.now().line] = r !== n.length), (o = e.now().offset), p(x);
  }
  function f(x) {
    return (e.containerState = {}), t.attempt(M2, d, p)(x);
  }
  function d(x) {
    return r++, n.push([e.currentConstruct, e.containerState]), f(x);
  }
  function p(x) {
    if (x === null) {
      i && g(), v(0), t.consume(x);
      return;
    }
    return (i = i || e.parser.flow(e.now())), t.enter("chunkFlow", { contentType: "flow", previous: s, _tokenizer: i }), m(x);
  }
  function m(x) {
    if (x === null) {
      O(t.exit("chunkFlow"), !0), v(0), t.consume(x);
      return;
    }
    return de(x) ? (t.consume(x), O(t.exit("chunkFlow")), (r = 0), (e.interrupt = void 0), a) : (t.consume(x), m);
  }
  function O(x, y) {
    const S = e.sliceStream(x);
    if ((y && S.push(null), (x.previous = s), s && (s.next = x), (s = x), i.defineSkip(x.start), i.write(S), e.parser.lazy[x.start.line])) {
      let k = i.events.length;
      for (; k--; ) if (i.events[k][1].start.offset < o && (!i.events[k][1].end || i.events[k][1].end.offset > o)) return;
      const b = e.events.length;
      let _ = b,
        T,
        P;
      for (; _--; )
        if (e.events[_][0] === "exit" && e.events[_][1].type === "chunkFlow") {
          if (T) {
            P = e.events[_][1].end;
            break;
          }
          T = !0;
        }
      for (v(r), k = b; k < e.events.length; ) (e.events[k][1].end = Object.assign({}, P)), k++;
      Ir(e.events, _ + 1, 0, e.events.slice(b)), (e.events.length = k);
    }
  }
  function v(x) {
    let y = n.length;
    for (; y-- > x; ) {
      const S = n[y];
      (e.containerState = S[1]), S[0].exit.call(e, t);
    }
    n.length = x;
  }
  function g() {
    i.write([null]), (s = void 0), (i = void 0), (e.containerState._closeFlow = void 0);
  }
}
function QB(t, e, n) {
  return Me(
    t,
    t.attempt(this.parser.constructs.document, e, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const EO = { name: "attention", tokenize: VB, resolveAll: FB };
function FB(t, e) {
  let n = -1,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u;
  for (; ++n < t.length; )
    if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
      for (r = n; r--; )
        if (
          t[r][0] === "exit" &&
          t[r][1].type === "attentionSequence" &&
          t[r][1]._open &&
          e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)
        ) {
          if (
            (t[r][1]._close || t[n][1]._open) &&
            (t[n][1].end.offset - t[n][1].start.offset) % 3 &&
            !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3)
          )
            continue;
          l = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
          const h = Object.assign({}, t[r][1].end),
            f = Object.assign({}, t[n][1].start);
          D2(h, -l),
            D2(f, l),
            (o = { type: l > 1 ? "strongSequence" : "emphasisSequence", start: h, end: Object.assign({}, t[r][1].end) }),
            (a = { type: l > 1 ? "strongSequence" : "emphasisSequence", start: Object.assign({}, t[n][1].start), end: f }),
            (s = {
              type: l > 1 ? "strongText" : "emphasisText",
              start: Object.assign({}, t[r][1].end),
              end: Object.assign({}, t[n][1].start),
            }),
            (i = { type: l > 1 ? "strong" : "emphasis", start: Object.assign({}, o.start), end: Object.assign({}, a.end) }),
            (t[r][1].end = Object.assign({}, o.start)),
            (t[n][1].start = Object.assign({}, a.end)),
            (c = []),
            t[r][1].end.offset - t[r][1].start.offset &&
              (c = _r(c, [
                ["enter", t[r][1], e],
                ["exit", t[r][1], e],
              ])),
            (c = _r(c, [
              ["enter", i, e],
              ["enter", o, e],
              ["exit", o, e],
              ["enter", s, e],
            ])),
            (c = _r(c, jm(e.parser.constructs.insideSpan.null, t.slice(r + 1, n), e))),
            (c = _r(c, [
              ["exit", s, e],
              ["enter", a, e],
              ["exit", a, e],
              ["exit", i, e],
            ])),
            t[n][1].end.offset - t[n][1].start.offset
              ? ((u = 2),
                (c = _r(c, [
                  ["enter", t[n][1], e],
                  ["exit", t[n][1], e],
                ])))
              : (u = 0),
            Ir(t, r - 1, n - r + 3, c),
            (n = r + c.length - u - 2);
          break;
        }
    }
  for (n = -1; ++n < t.length; ) t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
  return t;
}
function VB(t, e) {
  const n = this.parser.constructs.attentionMarkers.null,
    r = this.previous,
    i = ap(r);
  let s;
  return o;
  function o(l) {
    return (s = l), t.enter("attentionSequence"), a(l);
  }
  function a(l) {
    if (l === s) return t.consume(l), a;
    const c = t.exit("attentionSequence"),
      u = ap(l),
      h = !u || (u === 2 && i) || n.includes(l),
      f = !i || (i === 2 && u) || n.includes(r);
    return (c._open = !!(s === 42 ? h : h && (i || !f))), (c._close = !!(s === 42 ? f : f && (u || !h))), e(l);
  }
}
function D2(t, e) {
  (t.column += e), (t.offset += e), (t._bufferIndex += e);
}
const BB = { name: "autolink", tokenize: jB };
function jB(t, e, n) {
  let r = 0;
  return i;
  function i(d) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(d), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), s;
  }
  function s(d) {
    return fr(d) ? (t.consume(d), o) : d === 64 ? n(d) : c(d);
  }
  function o(d) {
    return d === 43 || d === 45 || d === 46 || pr(d) ? ((r = 1), a(d)) : c(d);
  }
  function a(d) {
    return d === 58
      ? (t.consume(d), (r = 0), l)
      : (d === 43 || d === 45 || d === 46 || pr(d)) && r++ < 32
      ? (t.consume(d), a)
      : ((r = 0), c(d));
  }
  function l(d) {
    return d === 62
      ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(d), t.exit("autolinkMarker"), t.exit("autolink"), e)
      : d === null || d === 32 || d === 60 || wO(d)
      ? n(d)
      : (t.consume(d), l);
  }
  function c(d) {
    return d === 64 ? (t.consume(d), u) : _F(d) ? (t.consume(d), c) : n(d);
  }
  function u(d) {
    return pr(d) ? h(d) : n(d);
  }
  function h(d) {
    return d === 46
      ? (t.consume(d), (r = 0), u)
      : d === 62
      ? ((t.exit("autolinkProtocol").type = "autolinkEmail"),
        t.enter("autolinkMarker"),
        t.consume(d),
        t.exit("autolinkMarker"),
        t.exit("autolink"),
        e)
      : f(d);
  }
  function f(d) {
    if ((d === 45 || pr(d)) && r++ < 63) {
      const p = d === 45 ? f : h;
      return t.consume(d), p;
    }
    return n(d);
  }
}
const Ch = { tokenize: ZB, partial: !0 };
function ZB(t, e, n) {
  return r;
  function r(s) {
    return Re(s) ? Me(t, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || de(s) ? e(s) : n(s);
  }
}
const wA = { name: "blockQuote", tokenize: zB, continuation: { tokenize: WB }, exit: UB };
function zB(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const a = r.containerState;
      return (
        a.open || (t.enter("blockQuote", { _container: !0 }), (a.open = !0)),
        t.enter("blockQuotePrefix"),
        t.enter("blockQuoteMarker"),
        t.consume(o),
        t.exit("blockQuoteMarker"),
        s
      );
    }
    return n(o);
  }
  function s(o) {
    return Re(o)
      ? (t.enter("blockQuotePrefixWhitespace"), t.consume(o), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e)
      : (t.exit("blockQuotePrefix"), e(o));
  }
}
function WB(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return Re(o) ? Me(t, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o);
  }
  function s(o) {
    return t.attempt(wA, e, n)(o);
  }
}
function UB(t) {
  t.exit("blockQuote");
}
const SA = { name: "characterEscape", tokenize: XB };
function XB(t, e, n) {
  return r;
  function r(s) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(s), t.exit("escapeMarker"), i;
  }
  function i(s) {
    return TF(s) ? (t.enter("characterEscapeValue"), t.consume(s), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(s);
  }
}
const kA = { name: "characterReference", tokenize: HB };
function HB(t, e, n) {
  const r = this;
  let i = 0,
    s,
    o;
  return a;
  function a(h) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), l;
  }
  function l(h) {
    return h === 35
      ? (t.enter("characterReferenceMarkerNumeric"), t.consume(h), t.exit("characterReferenceMarkerNumeric"), c)
      : (t.enter("characterReferenceValue"), (s = 31), (o = pr), u(h));
  }
  function c(h) {
    return h === 88 || h === 120
      ? (t.enter("characterReferenceMarkerHexadecimal"),
        t.consume(h),
        t.exit("characterReferenceMarkerHexadecimal"),
        t.enter("characterReferenceValue"),
        (s = 6),
        (o = EF),
        u)
      : (t.enter("characterReferenceValue"), (s = 7), (o = SO), u(h));
  }
  function u(h) {
    if (h === 59 && i) {
      const f = t.exit("characterReferenceValue");
      return o === pr && !Cu(r.sliceSerialize(f))
        ? n(h)
        : (t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), t.exit("characterReference"), e);
    }
    return o(h) && i++ < s ? (t.consume(h), u) : n(h);
  }
}
const Q2 = { tokenize: YB, partial: !0 },
  F2 = { name: "codeFenced", tokenize: qB, concrete: !0 };
function qB(t, e, n) {
  const r = this,
    i = { tokenize: S, partial: !0 };
  let s = 0,
    o = 0,
    a;
  return l;
  function l(k) {
    return c(k);
  }
  function c(k) {
    const b = r.events[r.events.length - 1];
    return (
      (s = b && b[1].type === "linePrefix" ? b[2].sliceSerialize(b[1], !0).length : 0),
      (a = k),
      t.enter("codeFenced"),
      t.enter("codeFencedFence"),
      t.enter("codeFencedFenceSequence"),
      u(k)
    );
  }
  function u(k) {
    return k === a ? (o++, t.consume(k), u) : o < 3 ? n(k) : (t.exit("codeFencedFenceSequence"), Re(k) ? Me(t, h, "whitespace")(k) : h(k));
  }
  function h(k) {
    return k === null || de(k)
      ? (t.exit("codeFencedFence"), r.interrupt ? e(k) : t.check(Q2, m, y)(k))
      : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", { contentType: "string" }), f(k));
  }
  function f(k) {
    return k === null || de(k)
      ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), h(k))
      : Re(k)
      ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), Me(t, d, "whitespace")(k))
      : k === 96 && k === a
      ? n(k)
      : (t.consume(k), f);
  }
  function d(k) {
    return k === null || de(k) ? h(k) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", { contentType: "string" }), p(k));
  }
  function p(k) {
    return k === null || de(k)
      ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), h(k))
      : k === 96 && k === a
      ? n(k)
      : (t.consume(k), p);
  }
  function m(k) {
    return t.attempt(i, y, O)(k);
  }
  function O(k) {
    return t.enter("lineEnding"), t.consume(k), t.exit("lineEnding"), v;
  }
  function v(k) {
    return s > 0 && Re(k) ? Me(t, g, "linePrefix", s + 1)(k) : g(k);
  }
  function g(k) {
    return k === null || de(k) ? t.check(Q2, m, y)(k) : (t.enter("codeFlowValue"), x(k));
  }
  function x(k) {
    return k === null || de(k) ? (t.exit("codeFlowValue"), g(k)) : (t.consume(k), x);
  }
  function y(k) {
    return t.exit("codeFenced"), e(k);
  }
  function S(k, b, _) {
    let T = 0;
    return P;
    function P(N) {
      return k.enter("lineEnding"), k.consume(N), k.exit("lineEnding"), M;
    }
    function M(N) {
      return (
        k.enter("codeFencedFence"),
        Re(N) ? Me(k, D, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(N) : D(N)
      );
    }
    function D(N) {
      return N === a ? (k.enter("codeFencedFenceSequence"), V(N)) : _(N);
    }
    function V(N) {
      return N === a
        ? (T++, k.consume(N), V)
        : T >= o
        ? (k.exit("codeFencedFenceSequence"), Re(N) ? Me(k, Q, "whitespace")(N) : Q(N))
        : _(N);
    }
    function Q(N) {
      return N === null || de(N) ? (k.exit("codeFencedFence"), b(N)) : _(N);
    }
  }
}
function YB(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? n(o) : (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : e(o);
  }
}
const d0 = { name: "codeIndented", tokenize: JB },
  GB = { tokenize: KB, partial: !0 };
function JB(t, e, n) {
  const r = this;
  return i;
  function i(c) {
    return t.enter("codeIndented"), Me(t, s, "linePrefix", 4 + 1)(c);
  }
  function s(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : n(c);
  }
  function o(c) {
    return c === null ? l(c) : de(c) ? t.attempt(GB, o, l)(c) : (t.enter("codeFlowValue"), a(c));
  }
  function a(c) {
    return c === null || de(c) ? (t.exit("codeFlowValue"), o(c)) : (t.consume(c), a);
  }
  function l(c) {
    return t.exit("codeIndented"), e(c);
  }
}
function KB(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line]
      ? n(o)
      : de(o)
      ? (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), i)
      : Me(t, s, "linePrefix", 4 + 1)(o);
  }
  function s(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : de(o) ? i(o) : n(o);
  }
}
const ej = { name: "codeText", tokenize: rj, resolve: tj, previous: nj };
function tj(t) {
  let e = t.length - 4,
    n = 3,
    r,
    i;
  if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
    for (r = n; ++r < e; )
      if (t[r][1].type === "codeTextData") {
        (t[n][1].type = "codeTextPadding"), (t[e][1].type = "codeTextPadding"), (n += 2), (e -= 2);
        break;
      }
  }
  for (r = n - 1, e++; ++r <= e; )
    i === void 0
      ? r !== e && t[r][1].type !== "lineEnding" && (i = r)
      : (r === e || t[r][1].type === "lineEnding") &&
        ((t[i][1].type = "codeTextData"),
        r !== i + 2 && ((t[i][1].end = t[r - 1][1].end), t.splice(i + 2, r - i - 2), (e -= r - i - 2), (r = i + 2)),
        (i = void 0));
  return t;
}
function nj(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function rj(t, e, n) {
  let r = 0,
    i,
    s;
  return o;
  function o(h) {
    return t.enter("codeText"), t.enter("codeTextSequence"), a(h);
  }
  function a(h) {
    return h === 96 ? (t.consume(h), r++, a) : (t.exit("codeTextSequence"), l(h));
  }
  function l(h) {
    return h === null
      ? n(h)
      : h === 32
      ? (t.enter("space"), t.consume(h), t.exit("space"), l)
      : h === 96
      ? ((s = t.enter("codeTextSequence")), (i = 0), u(h))
      : de(h)
      ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), l)
      : (t.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || de(h) ? (t.exit("codeTextData"), l(h)) : (t.consume(h), c);
  }
  function u(h) {
    return h === 96
      ? (t.consume(h), i++, u)
      : i === r
      ? (t.exit("codeTextSequence"), t.exit("codeText"), e(h))
      : ((s.type = "codeTextData"), c(h));
  }
}
class ij {
  constructor(e) {
    (this.left = e ? [...e] : []), (this.right = []);
  }
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  get length() {
    return this.left.length + this.right.length;
  }
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  slice(e, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length
      ? this.left.slice(e, r)
      : e > this.left.length
      ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse()
      : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  splice(e, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && bc(this.left, r), s.reverse();
  }
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), bc(this.left, e);
  }
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  unshiftMany(e) {
    this.setCursor(0), bc(this.right, e.reverse());
  }
  setCursor(e) {
    if (!(e === this.left.length || (e > this.left.length && this.right.length === 0) || (e < 0 && this.left.length === 0)))
      if (e < this.left.length) {
        const n = this.left.splice(e, Number.POSITIVE_INFINITY);
        bc(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        bc(this.left, n.reverse());
      }
  }
}
function bc(t, e) {
  let n = 0;
  if (e.length < 1e4) t.push(...e);
  else for (; n < e.length; ) t.push(...e.slice(n, n + 1e4)), (n += 1e4);
}
function CA(t) {
  const e = {};
  let n = -1,
    r,
    i,
    s,
    o,
    a,
    l,
    c;
  const u = new ij(t);
  for (; ++n < u.length; ) {
    for (; n in e; ) n = e[n];
    if (
      ((r = u.get(n)),
      n &&
        r[1].type === "chunkFlow" &&
        u.get(n - 1)[1].type === "listItemPrefix" &&
        ((l = r[1]._tokenizer.events),
        (s = 0),
        s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2),
        s < l.length && l[s][1].type === "content"))
    )
      for (; ++s < l.length && l[s][1].type !== "content"; )
        l[s][1].type === "chunkText" && ((l[s][1]._isInFirstContentOfListItem = !0), s++);
    if (r[0] === "enter") r[1].contentType && (Object.assign(e, sj(u, n)), (n = e[n]), (c = !0));
    else if (r[1]._container) {
      for (s = n, i = void 0; s-- && ((o = u.get(s)), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), (o[1].type = "lineEnding"), (i = s));
      i && ((r[1].end = Object.assign({}, u.get(i)[1].start)), (a = u.slice(i, n)), a.unshift(r), u.splice(i, n - i + 1, a));
    }
  }
  return Ir(t, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function sj(t, e) {
  const n = t.get(e)[1],
    r = t.get(e)[2];
  let i = e - 1;
  const s = [],
    o = n._tokenizer || r.parser[n.contentType](n.start),
    a = o.events,
    l = [],
    c = {};
  let u,
    h,
    f = -1,
    d = n,
    p = 0,
    m = 0;
  const O = [m];
  for (; d; ) {
    for (; t.get(++i)[1] !== d; );
    s.push(i),
      d._tokenizer ||
        ((u = r.sliceStream(d)),
        d.next || u.push(null),
        h && o.defineSkip(d.start),
        d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0),
        o.write(u),
        d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)),
      (h = d),
      (d = d.next);
  }
  for (d = n; ++f < a.length; )
    a[f][0] === "exit" &&
      a[f - 1][0] === "enter" &&
      a[f][1].type === a[f - 1][1].type &&
      a[f][1].start.line !== a[f][1].end.line &&
      ((m = f + 1), O.push(m), (d._tokenizer = void 0), (d.previous = void 0), (d = d.next));
  for (o.events = [], d ? ((d._tokenizer = void 0), (d.previous = void 0)) : O.pop(), f = O.length; f--; ) {
    const v = a.slice(O[f], O[f + 1]),
      g = s.pop();
    l.push([g, g + v.length - 1]), t.splice(g, 2, v);
  }
  for (l.reverse(), f = -1; ++f < l.length; ) (c[p + l[f][0]] = p + l[f][1]), (p += l[f][1] - l[f][0] - 1);
  return c;
}
const oj = { tokenize: cj, resolve: lj },
  aj = { tokenize: uj, partial: !0 };
function lj(t) {
  return CA(t), t;
}
function cj(t, e) {
  let n;
  return r;
  function r(a) {
    return t.enter("content"), (n = t.enter("chunkContent", { contentType: "content" })), i(a);
  }
  function i(a) {
    return a === null ? s(a) : de(a) ? t.check(aj, o, s)(a) : (t.consume(a), i);
  }
  function s(a) {
    return t.exit("chunkContent"), t.exit("content"), e(a);
  }
  function o(a) {
    return (
      t.consume(a), t.exit("chunkContent"), (n.next = t.enter("chunkContent", { contentType: "content", previous: n })), (n = n.next), i
    );
  }
}
function uj(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), Me(t, s, "linePrefix");
  }
  function s(o) {
    if (o === null || de(o)) return n(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") &&
      a &&
      a[1].type === "linePrefix" &&
      a[2].sliceSerialize(a[1], !0).length >= 4
      ? e(o)
      : t.interrupt(r.parser.constructs.flow, n, e)(o);
  }
}
function _A(t, e, n, r, i, s, o, a, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(v) {
    return v === 60
      ? (t.enter(r), t.enter(i), t.enter(s), t.consume(v), t.exit(s), f)
      : v === null || v === 32 || v === 41 || wO(v)
      ? n(v)
      : (t.enter(r), t.enter(o), t.enter(a), t.enter("chunkString", { contentType: "string" }), m(v));
  }
  function f(v) {
    return v === 62
      ? (t.enter(s), t.consume(v), t.exit(s), t.exit(i), t.exit(r), e)
      : (t.enter(a), t.enter("chunkString", { contentType: "string" }), d(v));
  }
  function d(v) {
    return v === 62 ? (t.exit("chunkString"), t.exit(a), f(v)) : v === null || v === 60 || de(v) ? n(v) : (t.consume(v), v === 92 ? p : d);
  }
  function p(v) {
    return v === 60 || v === 62 || v === 92 ? (t.consume(v), d) : d(v);
  }
  function m(v) {
    return !u && (v === null || v === 41 || st(v))
      ? (t.exit("chunkString"), t.exit(a), t.exit(o), t.exit(r), e(v))
      : u < c && v === 40
      ? (t.consume(v), u++, m)
      : v === 41
      ? (t.consume(v), u--, m)
      : v === null || v === 32 || v === 40 || wO(v)
      ? n(v)
      : (t.consume(v), v === 92 ? O : m);
  }
  function O(v) {
    return v === 40 || v === 41 || v === 92 ? (t.consume(v), m) : m(v);
  }
}
function EA(t, e, n, r, i, s) {
  const o = this;
  let a = 0,
    l;
  return c;
  function c(d) {
    return t.enter(r), t.enter(i), t.consume(d), t.exit(i), t.enter(s), u;
  }
  function u(d) {
    return a > 999 || d === null || d === 91 || (d === 93 && !l) || (d === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs)
      ? n(d)
      : d === 93
      ? (t.exit(s), t.enter(i), t.consume(d), t.exit(i), t.exit(r), e)
      : de(d)
      ? (t.enter("lineEnding"), t.consume(d), t.exit("lineEnding"), u)
      : (t.enter("chunkString", { contentType: "string" }), h(d));
  }
  function h(d) {
    return d === null || d === 91 || d === 93 || de(d) || a++ > 999
      ? (t.exit("chunkString"), u(d))
      : (t.consume(d), l || (l = !Re(d)), d === 92 ? f : h);
  }
  function f(d) {
    return d === 91 || d === 92 || d === 93 ? (t.consume(d), a++, h) : h(d);
  }
}
function TA(t, e, n, r, i, s) {
  let o;
  return a;
  function a(f) {
    return f === 34 || f === 39 || f === 40 ? (t.enter(r), t.enter(i), t.consume(f), t.exit(i), (o = f === 40 ? 41 : f), l) : n(f);
  }
  function l(f) {
    return f === o ? (t.enter(i), t.consume(f), t.exit(i), t.exit(r), e) : (t.enter(s), c(f));
  }
  function c(f) {
    return f === o
      ? (t.exit(s), l(o))
      : f === null
      ? n(f)
      : de(f)
      ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), Me(t, c, "linePrefix"))
      : (t.enter("chunkString", { contentType: "string" }), u(f));
  }
  function u(f) {
    return f === o || f === null || de(f) ? (t.exit("chunkString"), c(f)) : (t.consume(f), f === 92 ? h : u);
  }
  function h(f) {
    return f === o || f === 92 ? (t.consume(f), u) : u(f);
  }
}
function Ki(t, e) {
  let n;
  return r;
  function r(i) {
    return de(i)
      ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), (n = !0), r)
      : Re(i)
      ? Me(t, r, n ? "linePrefix" : "lineSuffix")(i)
      : e(i);
  }
}
const hj = { name: "definition", tokenize: dj },
  fj = { tokenize: pj, partial: !0 };
function dj(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(d) {
    return t.enter("definition"), o(d);
  }
  function o(d) {
    return EA.call(r, t, a, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(d);
  }
  function a(d) {
    return (
      (i = Ya(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))),
      d === 58 ? (t.enter("definitionMarker"), t.consume(d), t.exit("definitionMarker"), l) : n(d)
    );
  }
  function l(d) {
    return st(d) ? Ki(t, c)(d) : c(d);
  }
  function c(d) {
    return _A(
      t,
      u,
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function u(d) {
    return t.attempt(fj, h, h)(d);
  }
  function h(d) {
    return Re(d) ? Me(t, f, "whitespace")(d) : f(d);
  }
  function f(d) {
    return d === null || de(d) ? (t.exit("definition"), r.parser.defined.push(i), e(d)) : n(d);
  }
}
function pj(t, e, n) {
  return r;
  function r(a) {
    return st(a) ? Ki(t, i)(a) : n(a);
  }
  function i(a) {
    return TA(t, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function s(a) {
    return Re(a) ? Me(t, o, "whitespace")(a) : o(a);
  }
  function o(a) {
    return a === null || de(a) ? e(a) : n(a);
  }
}
const mj = { name: "hardBreakEscape", tokenize: gj };
function gj(t, e, n) {
  return r;
  function r(s) {
    return t.enter("hardBreakEscape"), t.consume(s), i;
  }
  function i(s) {
    return de(s) ? (t.exit("hardBreakEscape"), e(s)) : n(s);
  }
}
const Oj = { name: "headingAtx", tokenize: xj, resolve: vj };
function vj(t, e) {
  let n = t.length - 2,
    r = 3,
    i,
    s;
  return (
    t[r][1].type === "whitespace" && (r += 2),
    n - 2 > r && t[n][1].type === "whitespace" && (n -= 2),
    t[n][1].type === "atxHeadingSequence" &&
      (r === n - 1 || (n - 4 > r && t[n - 2][1].type === "whitespace")) &&
      (n -= r + 1 === n ? 2 : 4),
    n > r &&
      ((i = { type: "atxHeadingText", start: t[r][1].start, end: t[n][1].end }),
      (s = { type: "chunkText", start: t[r][1].start, end: t[n][1].end, contentType: "text" }),
      Ir(t, r, n - r + 1, [
        ["enter", i, e],
        ["enter", s, e],
        ["exit", s, e],
        ["exit", i, e],
      ])),
    t
  );
}
function xj(t, e, n) {
  let r = 0;
  return i;
  function i(u) {
    return t.enter("atxHeading"), s(u);
  }
  function s(u) {
    return t.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (t.consume(u), o) : u === null || st(u) ? (t.exit("atxHeadingSequence"), a(u)) : n(u);
  }
  function a(u) {
    return u === 35
      ? (t.enter("atxHeadingSequence"), l(u))
      : u === null || de(u)
      ? (t.exit("atxHeading"), e(u))
      : Re(u)
      ? Me(t, a, "whitespace")(u)
      : (t.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (t.consume(u), l) : (t.exit("atxHeadingSequence"), a(u));
  }
  function c(u) {
    return u === null || u === 35 || st(u) ? (t.exit("atxHeadingText"), a(u)) : (t.consume(u), c);
  }
}
const bj = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul",
  ],
  V2 = ["pre", "script", "style", "textarea"],
  yj = { name: "htmlFlow", tokenize: Cj, resolveTo: kj, concrete: !0 },
  wj = { tokenize: Ej, partial: !0 },
  Sj = { tokenize: _j, partial: !0 };
function kj(t) {
  let e = t.length;
  for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); );
  return (
    e > 1 &&
      t[e - 2][1].type === "linePrefix" &&
      ((t[e][1].start = t[e - 2][1].start), (t[e + 1][1].start = t[e - 2][1].start), t.splice(e - 2, 2)),
    t
  );
}
function Cj(t, e, n) {
  const r = this;
  let i, s, o, a, l;
  return c;
  function c(L) {
    return u(L);
  }
  function u(L) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(L), h;
  }
  function h(L) {
    return L === 33
      ? (t.consume(L), f)
      : L === 47
      ? (t.consume(L), (s = !0), m)
      : L === 63
      ? (t.consume(L), (i = 3), r.interrupt ? e : $)
      : fr(L)
      ? (t.consume(L), (o = String.fromCharCode(L)), O)
      : n(L);
  }
  function f(L) {
    return L === 45
      ? (t.consume(L), (i = 2), d)
      : L === 91
      ? (t.consume(L), (i = 5), (a = 0), p)
      : fr(L)
      ? (t.consume(L), (i = 4), r.interrupt ? e : $)
      : n(L);
  }
  function d(L) {
    return L === 45 ? (t.consume(L), r.interrupt ? e : $) : n(L);
  }
  function p(L) {
    const pe = "CDATA[";
    return L === pe.charCodeAt(a++) ? (t.consume(L), a === pe.length ? (r.interrupt ? e : D) : p) : n(L);
  }
  function m(L) {
    return fr(L) ? (t.consume(L), (o = String.fromCharCode(L)), O) : n(L);
  }
  function O(L) {
    if (L === null || L === 47 || L === 62 || st(L)) {
      const pe = L === 47,
        Ce = o.toLowerCase();
      return !pe && !s && V2.includes(Ce)
        ? ((i = 1), r.interrupt ? e(L) : D(L))
        : bj.includes(o.toLowerCase())
        ? ((i = 6), pe ? (t.consume(L), v) : r.interrupt ? e(L) : D(L))
        : ((i = 7), r.interrupt && !r.parser.lazy[r.now().line] ? n(L) : s ? g(L) : x(L));
    }
    return L === 45 || pr(L) ? (t.consume(L), (o += String.fromCharCode(L)), O) : n(L);
  }
  function v(L) {
    return L === 62 ? (t.consume(L), r.interrupt ? e : D) : n(L);
  }
  function g(L) {
    return Re(L) ? (t.consume(L), g) : P(L);
  }
  function x(L) {
    return L === 47 ? (t.consume(L), P) : L === 58 || L === 95 || fr(L) ? (t.consume(L), y) : Re(L) ? (t.consume(L), x) : P(L);
  }
  function y(L) {
    return L === 45 || L === 46 || L === 58 || L === 95 || pr(L) ? (t.consume(L), y) : S(L);
  }
  function S(L) {
    return L === 61 ? (t.consume(L), k) : Re(L) ? (t.consume(L), S) : x(L);
  }
  function k(L) {
    return L === null || L === 60 || L === 61 || L === 62 || L === 96
      ? n(L)
      : L === 34 || L === 39
      ? (t.consume(L), (l = L), b)
      : Re(L)
      ? (t.consume(L), k)
      : _(L);
  }
  function b(L) {
    return L === l ? (t.consume(L), (l = null), T) : L === null || de(L) ? n(L) : (t.consume(L), b);
  }
  function _(L) {
    return L === null || L === 34 || L === 39 || L === 47 || L === 60 || L === 61 || L === 62 || L === 96 || st(L)
      ? S(L)
      : (t.consume(L), _);
  }
  function T(L) {
    return L === 47 || L === 62 || Re(L) ? x(L) : n(L);
  }
  function P(L) {
    return L === 62 ? (t.consume(L), M) : n(L);
  }
  function M(L) {
    return L === null || de(L) ? D(L) : Re(L) ? (t.consume(L), M) : n(L);
  }
  function D(L) {
    return L === 45 && i === 2
      ? (t.consume(L), G)
      : L === 60 && i === 1
      ? (t.consume(L), H)
      : L === 62 && i === 4
      ? (t.consume(L), B)
      : L === 63 && i === 3
      ? (t.consume(L), $)
      : L === 93 && i === 5
      ? (t.consume(L), le)
      : de(L) && (i === 6 || i === 7)
      ? (t.exit("htmlFlowData"), t.check(wj, ie, V)(L))
      : L === null || de(L)
      ? (t.exit("htmlFlowData"), V(L))
      : (t.consume(L), D);
  }
  function V(L) {
    return t.check(Sj, Q, ie)(L);
  }
  function Q(L) {
    return t.enter("lineEnding"), t.consume(L), t.exit("lineEnding"), N;
  }
  function N(L) {
    return L === null || de(L) ? V(L) : (t.enter("htmlFlowData"), D(L));
  }
  function G(L) {
    return L === 45 ? (t.consume(L), $) : D(L);
  }
  function H(L) {
    return L === 47 ? (t.consume(L), (o = ""), te) : D(L);
  }
  function te(L) {
    if (L === 62) {
      const pe = o.toLowerCase();
      return V2.includes(pe) ? (t.consume(L), B) : D(L);
    }
    return fr(L) && o.length < 8 ? (t.consume(L), (o += String.fromCharCode(L)), te) : D(L);
  }
  function le(L) {
    return L === 93 ? (t.consume(L), $) : D(L);
  }
  function $(L) {
    return L === 62 ? (t.consume(L), B) : L === 45 && i === 2 ? (t.consume(L), $) : D(L);
  }
  function B(L) {
    return L === null || de(L) ? (t.exit("htmlFlowData"), ie(L)) : (t.consume(L), B);
  }
  function ie(L) {
    return t.exit("htmlFlow"), e(L);
  }
}
function _j(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return de(o) ? (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), s) : n(o);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : e(o);
  }
}
function Ej(t, e, n) {
  return r;
  function r(i) {
    return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), t.attempt(Ch, e, n);
  }
}
const Tj = { name: "htmlText", tokenize: Pj };
function Pj(t, e, n) {
  const r = this;
  let i, s, o;
  return a;
  function a($) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume($), l;
  }
  function l($) {
    return $ === 33 ? (t.consume($), c) : $ === 47 ? (t.consume($), S) : $ === 63 ? (t.consume($), x) : fr($) ? (t.consume($), _) : n($);
  }
  function c($) {
    return $ === 45 ? (t.consume($), u) : $ === 91 ? (t.consume($), (s = 0), p) : fr($) ? (t.consume($), g) : n($);
  }
  function u($) {
    return $ === 45 ? (t.consume($), d) : n($);
  }
  function h($) {
    return $ === null ? n($) : $ === 45 ? (t.consume($), f) : de($) ? ((o = h), H($)) : (t.consume($), h);
  }
  function f($) {
    return $ === 45 ? (t.consume($), d) : h($);
  }
  function d($) {
    return $ === 62 ? G($) : $ === 45 ? f($) : h($);
  }
  function p($) {
    const B = "CDATA[";
    return $ === B.charCodeAt(s++) ? (t.consume($), s === B.length ? m : p) : n($);
  }
  function m($) {
    return $ === null ? n($) : $ === 93 ? (t.consume($), O) : de($) ? ((o = m), H($)) : (t.consume($), m);
  }
  function O($) {
    return $ === 93 ? (t.consume($), v) : m($);
  }
  function v($) {
    return $ === 62 ? G($) : $ === 93 ? (t.consume($), v) : m($);
  }
  function g($) {
    return $ === null || $ === 62 ? G($) : de($) ? ((o = g), H($)) : (t.consume($), g);
  }
  function x($) {
    return $ === null ? n($) : $ === 63 ? (t.consume($), y) : de($) ? ((o = x), H($)) : (t.consume($), x);
  }
  function y($) {
    return $ === 62 ? G($) : x($);
  }
  function S($) {
    return fr($) ? (t.consume($), k) : n($);
  }
  function k($) {
    return $ === 45 || pr($) ? (t.consume($), k) : b($);
  }
  function b($) {
    return de($) ? ((o = b), H($)) : Re($) ? (t.consume($), b) : G($);
  }
  function _($) {
    return $ === 45 || pr($) ? (t.consume($), _) : $ === 47 || $ === 62 || st($) ? T($) : n($);
  }
  function T($) {
    return $ === 47
      ? (t.consume($), G)
      : $ === 58 || $ === 95 || fr($)
      ? (t.consume($), P)
      : de($)
      ? ((o = T), H($))
      : Re($)
      ? (t.consume($), T)
      : G($);
  }
  function P($) {
    return $ === 45 || $ === 46 || $ === 58 || $ === 95 || pr($) ? (t.consume($), P) : M($);
  }
  function M($) {
    return $ === 61 ? (t.consume($), D) : de($) ? ((o = M), H($)) : Re($) ? (t.consume($), M) : T($);
  }
  function D($) {
    return $ === null || $ === 60 || $ === 61 || $ === 62 || $ === 96
      ? n($)
      : $ === 34 || $ === 39
      ? (t.consume($), (i = $), V)
      : de($)
      ? ((o = D), H($))
      : Re($)
      ? (t.consume($), D)
      : (t.consume($), Q);
  }
  function V($) {
    return $ === i ? (t.consume($), (i = void 0), N) : $ === null ? n($) : de($) ? ((o = V), H($)) : (t.consume($), V);
  }
  function Q($) {
    return $ === null || $ === 34 || $ === 39 || $ === 60 || $ === 61 || $ === 96
      ? n($)
      : $ === 47 || $ === 62 || st($)
      ? T($)
      : (t.consume($), Q);
  }
  function N($) {
    return $ === 47 || $ === 62 || st($) ? T($) : n($);
  }
  function G($) {
    return $ === 62 ? (t.consume($), t.exit("htmlTextData"), t.exit("htmlText"), e) : n($);
  }
  function H($) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume($), t.exit("lineEnding"), te;
  }
  function te($) {
    return Re($) ? Me(t, le, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)($) : le($);
  }
  function le($) {
    return t.enter("htmlTextData"), o($);
  }
}
const Zb = { name: "labelEnd", tokenize: Lj, resolveTo: Nj, resolveAll: Ij },
  Aj = { tokenize: Mj },
  $j = { tokenize: Dj },
  Rj = { tokenize: Qj };
function Ij(t) {
  let e = -1;
  for (; ++e < t.length; ) {
    const n = t[e][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") &&
      (t.splice(e + 1, n.type === "labelImage" ? 4 : 2), (n.type = "data"), e++);
  }
  return t;
}
function Nj(t, e) {
  let n = t.length,
    r = 0,
    i,
    s,
    o,
    a;
  for (; n--; )
    if (((i = t[n][1]), s)) {
      if (i.type === "link" || (i.type === "labelLink" && i._inactive)) break;
      t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && ((s = n), i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = n);
  const l = {
      type: t[s][1].type === "labelLink" ? "link" : "image",
      start: Object.assign({}, t[s][1].start),
      end: Object.assign({}, t[t.length - 1][1].end),
    },
    c = { type: "label", start: Object.assign({}, t[s][1].start), end: Object.assign({}, t[o][1].end) },
    u = { type: "labelText", start: Object.assign({}, t[s + r + 2][1].end), end: Object.assign({}, t[o - 2][1].start) };
  return (
    (a = [
      ["enter", l, e],
      ["enter", c, e],
    ]),
    (a = _r(a, t.slice(s + 1, s + r + 3))),
    (a = _r(a, [["enter", u, e]])),
    (a = _r(a, jm(e.parser.constructs.insideSpan.null, t.slice(s + r + 4, o - 3), e))),
    (a = _r(a, [["exit", u, e], t[o - 2], t[o - 1], ["exit", c, e]])),
    (a = _r(a, t.slice(o + 1))),
    (a = _r(a, [["exit", l, e]])),
    Ir(t, s, t.length, a),
    t
  );
}
function Lj(t, e, n) {
  const r = this;
  let i = r.events.length,
    s,
    o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return a;
  function a(f) {
    return s
      ? s._inactive
        ? h(f)
        : ((o = r.parser.defined.includes(Ya(r.sliceSerialize({ start: s.end, end: r.now() })))),
          t.enter("labelEnd"),
          t.enter("labelMarker"),
          t.consume(f),
          t.exit("labelMarker"),
          t.exit("labelEnd"),
          l)
      : n(f);
  }
  function l(f) {
    return f === 40 ? t.attempt(Aj, u, o ? u : h)(f) : f === 91 ? t.attempt($j, u, o ? c : h)(f) : o ? u(f) : h(f);
  }
  function c(f) {
    return t.attempt(Rj, u, h)(f);
  }
  function u(f) {
    return e(f);
  }
  function h(f) {
    return (s._balanced = !0), n(f);
  }
}
function Mj(t, e, n) {
  return r;
  function r(h) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), i;
  }
  function i(h) {
    return st(h) ? Ki(t, s)(h) : s(h);
  }
  function s(h) {
    return h === 41
      ? u(h)
      : _A(
          t,
          o,
          a,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          32
        )(h);
  }
  function o(h) {
    return st(h) ? Ki(t, l)(h) : u(h);
  }
  function a(h) {
    return n(h);
  }
  function l(h) {
    return h === 34 || h === 39 || h === 40 ? TA(t, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return st(h) ? Ki(t, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), t.exit("resource"), e) : n(h);
  }
}
function Dj(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return EA.call(r, t, s, o, "reference", "referenceMarker", "referenceString")(a);
  }
  function s(a) {
    return r.parser.defined.includes(Ya(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(a) : n(a);
  }
  function o(a) {
    return n(a);
  }
}
function Qj(t, e, n) {
  return r;
  function r(s) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), t.exit("reference"), e) : n(s);
  }
}
const Fj = { name: "labelStartImage", tokenize: Vj, resolveAll: Zb.resolveAll };
function Vj(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(a), t.exit("labelImageMarker"), s;
  }
  function s(a) {
    return a === 91 ? (t.enter("labelMarker"), t.consume(a), t.exit("labelMarker"), t.exit("labelImage"), o) : n(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : e(a);
  }
}
const Bj = { name: "labelStartLink", tokenize: jj, resolveAll: Zb.resolveAll };
function jj(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(o), t.exit("labelMarker"), t.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : e(o);
  }
}
const p0 = { name: "lineEnding", tokenize: Zj };
function Zj(t, e) {
  return n;
  function n(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), Me(t, e, "linePrefix");
  }
}
const kd = { name: "thematicBreak", tokenize: zj };
function zj(t, e, n) {
  let r = 0,
    i;
  return s;
  function s(c) {
    return t.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return (i = c), a(c);
  }
  function a(c) {
    return c === i ? (t.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || de(c)) ? (t.exit("thematicBreak"), e(c)) : n(c);
  }
  function l(c) {
    return c === i ? (t.consume(c), r++, l) : (t.exit("thematicBreakSequence"), Re(c) ? Me(t, a, "whitespace")(c) : a(c));
  }
}
const Xn = { name: "list", tokenize: Xj, continuation: { tokenize: Hj }, exit: Yj },
  Wj = { tokenize: Gj, partial: !0 },
  Uj = { tokenize: qj, partial: !0 };
function Xj(t, e, n) {
  const r = this,
    i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0,
    o = 0;
  return a;
  function a(d) {
    const p = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : SO(d)) {
      if ((r.containerState.type || ((r.containerState.type = p), t.enter(p, { _container: !0 })), p === "listUnordered"))
        return t.enter("listItemPrefix"), d === 42 || d === 45 ? t.check(kd, n, c)(d) : c(d);
      if (!r.interrupt || d === 49) return t.enter("listItemPrefix"), t.enter("listItemValue"), l(d);
    }
    return n(d);
  }
  function l(d) {
    return SO(d) && ++o < 10
      ? (t.consume(d), l)
      : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46)
      ? (t.exit("listItemValue"), c(d))
      : n(d);
  }
  function c(d) {
    return (
      t.enter("listItemMarker"),
      t.consume(d),
      t.exit("listItemMarker"),
      (r.containerState.marker = r.containerState.marker || d),
      t.check(Ch, r.interrupt ? n : u, t.attempt(Wj, f, h))
    );
  }
  function u(d) {
    return (r.containerState.initialBlankLine = !0), s++, f(d);
  }
  function h(d) {
    return Re(d) ? (t.enter("listItemPrefixWhitespace"), t.consume(d), t.exit("listItemPrefixWhitespace"), f) : n(d);
  }
  function f(d) {
    return (r.containerState.size = s + r.sliceSerialize(t.exit("listItemPrefix"), !0).length), e(d);
  }
}
function Hj(t, e, n) {
  const r = this;
  return (r.containerState._closeFlow = void 0), t.check(Ch, i, s);
  function i(a) {
    return (
      (r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine),
      Me(t, e, "listItemIndent", r.containerState.size + 1)(a)
    );
  }
  function s(a) {
    return r.containerState.furtherBlankLines || !Re(a)
      ? ((r.containerState.furtherBlankLines = void 0), (r.containerState.initialBlankLine = void 0), o(a))
      : ((r.containerState.furtherBlankLines = void 0), (r.containerState.initialBlankLine = void 0), t.attempt(Uj, e, o)(a));
  }
  function o(a) {
    return (
      (r.containerState._closeFlow = !0),
      (r.interrupt = void 0),
      Me(t, t.attempt(Xn, e, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a)
    );
  }
}
function qj(t, e, n) {
  const r = this;
  return Me(t, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : n(s);
  }
}
function Yj(t) {
  t.exit(this.containerState.type);
}
function Gj(t, e, n) {
  const r = this;
  return Me(t, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !Re(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : n(s);
  }
}
const B2 = { name: "setextUnderline", tokenize: Kj, resolveTo: Jj };
function Jj(t, e) {
  let n = t.length,
    r,
    i,
    s;
  for (; n--; )
    if (t[n][0] === "enter") {
      if (t[n][1].type === "content") {
        r = n;
        break;
      }
      t[n][1].type === "paragraph" && (i = n);
    } else t[n][1].type === "content" && t.splice(n, 1), !s && t[n][1].type === "definition" && (s = n);
  const o = { type: "setextHeading", start: Object.assign({}, t[i][1].start), end: Object.assign({}, t[t.length - 1][1].end) };
  return (
    (t[i][1].type = "setextHeadingText"),
    s
      ? (t.splice(i, 0, ["enter", o, e]), t.splice(s + 1, 0, ["exit", t[r][1], e]), (t[r][1].end = Object.assign({}, t[s][1].end)))
      : (t[r][1] = o),
    t.push(["exit", o, e]),
    t
  );
}
function Kj(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(c) {
    let u = r.events.length,
      h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (t.enter("setextHeadingLine"), (i = c), o(c)) : n(c);
  }
  function o(c) {
    return t.enter("setextHeadingLineSequence"), a(c);
  }
  function a(c) {
    return c === i ? (t.consume(c), a) : (t.exit("setextHeadingLineSequence"), Re(c) ? Me(t, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || de(c) ? (t.exit("setextHeadingLine"), e(c)) : n(c);
  }
}
const eZ = { tokenize: tZ };
function tZ(t) {
  const e = this,
    n = t.attempt(
      Ch,
      r,
      t.attempt(this.parser.constructs.flowInitial, i, Me(t, t.attempt(this.parser.constructs.flow, i, t.attempt(oj, i)), "linePrefix"))
    );
  return n;
  function r(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(s), t.exit("lineEndingBlank"), (e.currentConstruct = void 0), n;
  }
  function i(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), (e.currentConstruct = void 0), n;
  }
}
const nZ = { resolveAll: AA() },
  rZ = PA("string"),
  iZ = PA("text");
function PA(t) {
  return { tokenize: e, resolveAll: AA(t === "text" ? sZ : void 0) };
  function e(n) {
    const r = this,
      i = this.parser.constructs[t],
      s = n.attempt(i, o, a);
    return o;
    function o(u) {
      return c(u) ? s(u) : a(u);
    }
    function a(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), l;
    }
    function l(u) {
      return c(u) ? (n.exit("data"), s(u)) : (n.consume(u), l);
    }
    function c(u) {
      if (u === null) return !0;
      const h = i[u];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const d = h[f];
          if (!d.previous || d.previous.call(r, r.previous)) return !0;
        }
      return !1;
    }
  }
}
function AA(t) {
  return e;
  function e(n, r) {
    let i = -1,
      s;
    for (; ++i <= n.length; )
      s === void 0
        ? n[i] && n[i][1].type === "data" && ((s = i), i++)
        : (!n[i] || n[i][1].type !== "data") &&
          (i !== s + 2 && ((n[s][1].end = n[i - 1][1].end), n.splice(s + 2, i - s - 2), (i = s + 2)), (s = void 0));
    return t ? t(n, r) : n;
  }
}
function sZ(t, e) {
  let n = 0;
  for (; ++n <= t.length; )
    if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
      const r = t[n - 1][1],
        i = e.sliceStream(r);
      let s = i.length,
        o = -1,
        a = 0,
        l;
      for (; s--; ) {
        const c = i[s];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; ) a++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2) (l = !0), a++;
        else if (c !== -1) {
          s++;
          break;
        }
      }
      if (a) {
        const c = {
          type: n === t.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a,
            _index: r.start._index + s,
            _bufferIndex: s ? o : r.start._bufferIndex + o,
          },
          end: Object.assign({}, r.end),
        };
        (r.end = Object.assign({}, c.start)),
          r.start.offset === r.end.offset ? Object.assign(r, c) : (t.splice(n, 0, ["enter", c, e], ["exit", c, e]), (n += 2));
      }
      n++;
    }
  return t;
}
function oZ(t, e, n) {
  let r = Object.assign(n ? Object.assign({}, n) : { line: 1, column: 1, offset: 0 }, { _index: 0, _bufferIndex: -1 });
  const i = {},
    s = [];
  let o = [],
    a = [];
  const l = { consume: g, enter: x, exit: y, attempt: b(S), check: b(k), interrupt: b(k, { interrupt: !0 }) },
    c = {
      previous: null,
      code: null,
      containerState: {},
      events: [],
      parser: t,
      sliceStream: d,
      sliceSerialize: f,
      now: p,
      defineSkip: m,
      write: h,
    };
  let u = e.tokenize.call(c, l);
  return e.resolveAll && s.push(e), c;
  function h(M) {
    return (o = _r(o, M)), O(), o[o.length - 1] !== null ? [] : (_(e, 0), (c.events = jm(s, c.events, c)), c.events);
  }
  function f(M, D) {
    return lZ(d(M), D);
  }
  function d(M) {
    return aZ(o, M);
  }
  function p() {
    const { line: M, column: D, offset: V, _index: Q, _bufferIndex: N } = r;
    return { line: M, column: D, offset: V, _index: Q, _bufferIndex: N };
  }
  function m(M) {
    (i[M.line] = M.column), P();
  }
  function O() {
    let M;
    for (; r._index < o.length; ) {
      const D = o[r._index];
      if (typeof D == "string")
        for (M = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === M && r._bufferIndex < D.length; )
          v(D.charCodeAt(r._bufferIndex));
      else v(D);
    }
  }
  function v(M) {
    u = u(M);
  }
  function g(M) {
    de(M) ? (r.line++, (r.column = 1), (r.offset += M === -3 ? 2 : 1), P()) : M !== -1 && (r.column++, r.offset++),
      r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && ((r._bufferIndex = -1), r._index++)),
      (c.previous = M);
  }
  function x(M, D) {
    const V = D || {};
    return (V.type = M), (V.start = p()), c.events.push(["enter", V, c]), a.push(V), V;
  }
  function y(M) {
    const D = a.pop();
    return (D.end = p()), c.events.push(["exit", D, c]), D;
  }
  function S(M, D) {
    _(M, D.from);
  }
  function k(M, D) {
    D.restore();
  }
  function b(M, D) {
    return V;
    function V(Q, N, G) {
      let H, te, le, $;
      return Array.isArray(Q) ? ie(Q) : "tokenize" in Q ? ie([Q]) : B(Q);
      function B(me) {
        return Y;
        function Y(q) {
          const se = q !== null && me[q],
            ue = q !== null && me.null,
            ve = [...(Array.isArray(se) ? se : se ? [se] : []), ...(Array.isArray(ue) ? ue : ue ? [ue] : [])];
          return ie(ve)(q);
        }
      }
      function ie(me) {
        return (H = me), (te = 0), me.length === 0 ? G : L(me[te]);
      }
      function L(me) {
        return Y;
        function Y(q) {
          return (
            ($ = T()),
            (le = me),
            me.partial || (c.currentConstruct = me),
            me.name && c.parser.constructs.disable.null.includes(me.name)
              ? Ce()
              : me.tokenize.call(D ? Object.assign(Object.create(c), D) : c, l, pe, Ce)(q)
          );
        }
      }
      function pe(me) {
        return M(le, $), N;
      }
      function Ce(me) {
        return $.restore(), ++te < H.length ? L(H[te]) : G;
      }
    }
  }
  function _(M, D) {
    M.resolveAll && !s.includes(M) && s.push(M),
      M.resolve && Ir(c.events, D, c.events.length - D, M.resolve(c.events.slice(D), c)),
      M.resolveTo && (c.events = M.resolveTo(c.events, c));
  }
  function T() {
    const M = p(),
      D = c.previous,
      V = c.currentConstruct,
      Q = c.events.length,
      N = Array.from(a);
    return { restore: G, from: Q };
    function G() {
      (r = M), (c.previous = D), (c.currentConstruct = V), (c.events.length = Q), (a = N), P();
    }
  }
  function P() {
    r.line in i && r.column < 2 && ((r.column = i[r.line]), (r.offset += i[r.line] - 1));
  }
}
function aZ(t, e) {
  const n = e.start._index,
    r = e.start._bufferIndex,
    i = e.end._index,
    s = e.end._bufferIndex;
  let o;
  if (n === i) o = [t[n].slice(r, s)];
  else {
    if (((o = t.slice(n, i)), r > -1)) {
      const a = o[0];
      typeof a == "string" ? (o[0] = a.slice(r)) : o.shift();
    }
    s > 0 && o.push(t[i].slice(0, s));
  }
  return o;
}
function lZ(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < t.length; ) {
    const s = t[n];
    let o;
    if (typeof s == "string") o = s;
    else
      switch (s) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = e ? " " : "	";
          break;
        }
        case -1: {
          if (!e && i) continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(s);
      }
    (i = s === -2), r.push(o);
  }
  return r.join("");
}
const cZ = { 42: Xn, 43: Xn, 45: Xn, 48: Xn, 49: Xn, 50: Xn, 51: Xn, 52: Xn, 53: Xn, 54: Xn, 55: Xn, 56: Xn, 57: Xn, 62: wA },
  uZ = { 91: hj },
  hZ = { [-2]: d0, [-1]: d0, 32: d0 },
  fZ = { 35: Oj, 42: kd, 45: [B2, kd], 60: yj, 61: B2, 95: kd, 96: F2, 126: F2 },
  dZ = { 38: kA, 92: SA },
  pZ = { [-5]: p0, [-4]: p0, [-3]: p0, 33: Fj, 38: kA, 42: EO, 60: [BB, Tj], 91: Bj, 92: [mj, SA], 93: Zb, 95: EO, 96: ej },
  mZ = { null: [EO, nZ] },
  gZ = { null: [42, 95] },
  OZ = { null: [] },
  vZ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        attentionMarkers: gZ,
        contentInitial: uZ,
        disable: OZ,
        document: cZ,
        flow: fZ,
        flowInitial: hZ,
        insideSpan: mZ,
        string: dZ,
        text: pZ,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
function xZ(t) {
  const n = yA([vZ, ...((t || {}).extensions || [])]),
    r = { defined: [], lazy: {}, constructs: n, content: i(NB), document: i(MB), flow: i(eZ), string: i(rZ), text: i(iZ) };
  return r;
  function i(s) {
    return o;
    function o(a) {
      return oZ(r, s, a);
    }
  }
}
function bZ(t) {
  for (; !CA(t); );
  return t;
}
const j2 = /[\0\t\n\r]/g;
function yZ() {
  let t = 1,
    e = "",
    n = !0,
    r;
  return i;
  function i(s, o, a) {
    const l = [];
    let c, u, h, f, d;
    for (
      s = e + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)),
        h = 0,
        e = "",
        n && (s.charCodeAt(0) === 65279 && h++, (n = void 0));
      h < s.length;

    ) {
      if (((j2.lastIndex = h), (c = j2.exec(s)), (f = c && c.index !== void 0 ? c.index : s.length), (d = s.charCodeAt(f)), !c)) {
        e = s.slice(h);
        break;
      }
      if (d === 10 && h === f && r) l.push(-3), (r = void 0);
      else
        switch ((r && (l.push(-5), (r = void 0)), h < f && (l.push(s.slice(h, f)), (t += f - h)), d)) {
          case 0: {
            l.push(65533), t++;
            break;
          }
          case 9: {
            for (u = Math.ceil(t / 4) * 4, l.push(-2); t++ < u; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), (t = 1);
            break;
          }
          default:
            (r = !0), (t = 1);
        }
      h = f + 1;
    }
    return a && (r && l.push(-5), e && l.push(e), l.push(null)), l;
  }
}
const $A = {}.hasOwnProperty;
function wZ(t, e, n) {
  return typeof e != "string" && ((n = e), (e = void 0)), SZ(n)(bZ(xZ(n).document().write(yZ()(t, e, !0))));
}
function SZ(t) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(Ve),
      autolinkProtocol: T,
      autolinkEmail: T,
      atxHeading: s(Rt),
      blockQuote: s(ue),
      characterEscape: T,
      characterReference: T,
      codeFenced: s(ve),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: s(ve, o),
      codeText: s(Pe, o),
      codeTextData: T,
      data: T,
      codeFlowValue: T,
      definition: s(Fe),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: s(rt),
      hardBreakEscape: s(Qt),
      hardBreakTrailing: s(Qt),
      htmlFlow: s(Ft, o),
      htmlFlowData: T,
      htmlText: s(Ft, o),
      htmlTextData: T,
      image: s(Ge),
      label: o,
      link: s(Ve),
      listItem: s(De),
      listItemValue: f,
      listOrdered: s(We, h),
      listUnordered: s(We),
      paragraph: s(Ut),
      reference: L,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: s(Rt),
      strong: s(Lt),
      thematicBreak: s(hn),
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: S,
      autolink: l(),
      autolinkEmail: se,
      autolinkProtocol: q,
      blockQuote: l(),
      characterEscapeValue: P,
      characterReferenceMarkerHexadecimal: Ce,
      characterReferenceMarkerNumeric: Ce,
      characterReferenceValue: me,
      characterReference: Y,
      codeFenced: l(O),
      codeFencedFence: m,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: p,
      codeFlowValue: P,
      codeIndented: l(v),
      codeText: l(N),
      codeTextData: P,
      data: P,
      definition: l(),
      definitionDestinationString: y,
      definitionLabelString: g,
      definitionTitleString: x,
      emphasis: l(),
      hardBreakEscape: l(D),
      hardBreakTrailing: l(D),
      htmlFlow: l(V),
      htmlFlowData: P,
      htmlText: l(Q),
      htmlTextData: P,
      image: l(H),
      label: le,
      labelText: te,
      lineEnding: M,
      link: l(G),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: pe,
      resourceDestinationString: $,
      resourceTitleString: B,
      resource: ie,
      setextHeading: l(_),
      setextHeadingLineSequence: b,
      setextHeadingText: k,
      strong: l(),
      thematicBreak: l(),
    },
  };
  RA(e, (t || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(U) {
    let K = { type: "root", children: [] };
    const I = { stack: [K], tokenStack: [], config: e, enter: a, exit: c, buffer: o, resume: u, data: n },
      $e = [];
    let je = -1;
    for (; ++je < U.length; )
      if (U[je][1].type === "listOrdered" || U[je][1].type === "listUnordered")
        if (U[je][0] === "enter") $e.push(je);
        else {
          const wt = $e.pop();
          je = i(U, wt, je);
        }
    for (je = -1; ++je < U.length; ) {
      const wt = e[U[je][0]];
      $A.call(wt, U[je][1].type) && wt[U[je][1].type].call(Object.assign({ sliceSerialize: U[je][2].sliceSerialize }, I), U[je][1]);
    }
    if (I.tokenStack.length > 0) {
      const wt = I.tokenStack[I.tokenStack.length - 1];
      (wt[1] || Z2).call(I, void 0, wt[0]);
    }
    for (
      K.position = {
        start: ys(U.length > 0 ? U[0][1].start : { line: 1, column: 1, offset: 0 }),
        end: ys(U.length > 0 ? U[U.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
      },
        je = -1;
      ++je < e.transforms.length;

    )
      K = e.transforms[je](K) || K;
    return K;
  }
  function i(U, K, I) {
    let $e = K - 1,
      je = -1,
      wt = !1,
      ji,
      Zi,
      pc,
      mc;
    for (; ++$e <= I; ) {
      const or = U[$e];
      switch (or[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          or[0] === "enter" ? je++ : je--, (mc = void 0);
          break;
        }
        case "lineEndingBlank": {
          or[0] === "enter" && (ji && !mc && !je && !pc && (pc = $e), (mc = void 0));
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          mc = void 0;
      }
      if (
        (!je && or[0] === "enter" && or[1].type === "listItemPrefix") ||
        (je === -1 && or[0] === "exit" && (or[1].type === "listUnordered" || or[1].type === "listOrdered"))
      ) {
        if (ji) {
          let Oa = $e;
          for (Zi = void 0; Oa--; ) {
            const zi = U[Oa];
            if (zi[1].type === "lineEnding" || zi[1].type === "lineEndingBlank") {
              if (zi[0] === "exit") continue;
              Zi && ((U[Zi][1].type = "lineEndingBlank"), (wt = !0)), (zi[1].type = "lineEnding"), (Zi = Oa);
            } else if (
              !(
                zi[1].type === "linePrefix" ||
                zi[1].type === "blockQuotePrefix" ||
                zi[1].type === "blockQuotePrefixWhitespace" ||
                zi[1].type === "blockQuoteMarker" ||
                zi[1].type === "listItemIndent"
              )
            )
              break;
          }
          pc && (!Zi || pc < Zi) && (ji._spread = !0),
            (ji.end = Object.assign({}, Zi ? U[Zi][1].start : or[1].end)),
            U.splice(Zi || $e, 0, ["exit", ji, or[2]]),
            $e++,
            I++;
        }
        if (or[1].type === "listItemPrefix") {
          const Oa = { type: "listItem", _spread: !1, start: Object.assign({}, or[1].start), end: void 0 };
          (ji = Oa), U.splice($e, 0, ["enter", Oa, or[2]]), $e++, I++, (pc = void 0), (mc = !0);
        }
      }
    }
    return (U[K][1]._spread = wt), I;
  }
  function s(U, K) {
    return I;
    function I($e) {
      a.call(this, U($e), $e), K && K.call(this, $e);
    }
  }
  function o() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function a(U, K, I) {
    this.stack[this.stack.length - 1].children.push(U),
      this.stack.push(U),
      this.tokenStack.push([K, I]),
      (U.position = { start: ys(K.start), end: void 0 });
  }
  function l(U) {
    return K;
    function K(I) {
      U && U.call(this, I), c.call(this, I);
    }
  }
  function c(U, K) {
    const I = this.stack.pop(),
      $e = this.tokenStack.pop();
    if ($e) $e[0].type !== U.type && (K ? K.call(this, U, $e[0]) : ($e[1] || Z2).call(this, U, $e[0]));
    else throw new Error("Cannot close `" + U.type + "` (" + Ji({ start: U.start, end: U.end }) + "): it’s not open");
    I.position.end = ys(U.end);
  }
  function u() {
    return Qb(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(U) {
    if (this.data.expectingFirstListItemValue) {
      const K = this.stack[this.stack.length - 2];
      (K.start = Number.parseInt(this.sliceSerialize(U), 10)), (this.data.expectingFirstListItemValue = void 0);
    }
  }
  function d() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.lang = U;
  }
  function p() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.meta = U;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), (this.data.flowCodeInside = !0));
  }
  function O() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    (K.value = U.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")), (this.data.flowCodeInside = void 0);
  }
  function v() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.value = U.replace(/(\r?\n|\r)$/g, "");
  }
  function g(U) {
    const K = this.resume(),
      I = this.stack[this.stack.length - 1];
    (I.label = K), (I.identifier = Ya(this.sliceSerialize(U)).toLowerCase());
  }
  function x() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.title = U;
  }
  function y() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.url = U;
  }
  function S(U) {
    const K = this.stack[this.stack.length - 1];
    if (!K.depth) {
      const I = this.sliceSerialize(U).length;
      K.depth = I;
    }
  }
  function k() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function b(U) {
    const K = this.stack[this.stack.length - 1];
    K.depth = this.sliceSerialize(U).codePointAt(0) === 61 ? 1 : 2;
  }
  function _() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function T(U) {
    const I = this.stack[this.stack.length - 1].children;
    let $e = I[I.length - 1];
    (!$e || $e.type !== "text") && (($e = it()), ($e.position = { start: ys(U.start), end: void 0 }), I.push($e)), this.stack.push($e);
  }
  function P(U) {
    const K = this.stack.pop();
    (K.value += this.sliceSerialize(U)), (K.position.end = ys(U.end));
  }
  function M(U) {
    const K = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const I = K.children[K.children.length - 1];
      (I.position.end = ys(U.end)), (this.data.atHardBreak = void 0);
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(K.type) && (T.call(this, U), P.call(this, U));
  }
  function D() {
    this.data.atHardBreak = !0;
  }
  function V() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.value = U;
  }
  function Q() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.value = U;
  }
  function N() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.value = U;
  }
  function G() {
    const U = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const K = this.data.referenceType || "shortcut";
      (U.type += "Reference"), (U.referenceType = K), delete U.url, delete U.title;
    } else delete U.identifier, delete U.label;
    this.data.referenceType = void 0;
  }
  function H() {
    const U = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const K = this.data.referenceType || "shortcut";
      (U.type += "Reference"), (U.referenceType = K), delete U.url, delete U.title;
    } else delete U.identifier, delete U.label;
    this.data.referenceType = void 0;
  }
  function te(U) {
    const K = this.sliceSerialize(U),
      I = this.stack[this.stack.length - 2];
    (I.label = gA(K)), (I.identifier = Ya(K).toLowerCase());
  }
  function le() {
    const U = this.stack[this.stack.length - 1],
      K = this.resume(),
      I = this.stack[this.stack.length - 1];
    if (((this.data.inReference = !0), I.type === "link")) {
      const $e = U.children;
      I.children = $e;
    } else I.alt = K;
  }
  function $() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.url = U;
  }
  function B() {
    const U = this.resume(),
      K = this.stack[this.stack.length - 1];
    K.title = U;
  }
  function ie() {
    this.data.inReference = void 0;
  }
  function L() {
    this.data.referenceType = "collapsed";
  }
  function pe(U) {
    const K = this.resume(),
      I = this.stack[this.stack.length - 1];
    (I.label = K), (I.identifier = Ya(this.sliceSerialize(U)).toLowerCase()), (this.data.referenceType = "full");
  }
  function Ce(U) {
    this.data.characterReferenceType = U.type;
  }
  function me(U) {
    const K = this.sliceSerialize(U),
      I = this.data.characterReferenceType;
    let $e;
    I ? (($e = mA(K, I === "characterReferenceMarkerNumeric" ? 10 : 16)), (this.data.characterReferenceType = void 0)) : ($e = Cu(K));
    const je = this.stack[this.stack.length - 1];
    je.value += $e;
  }
  function Y(U) {
    const K = this.stack.pop();
    K.position.end = ys(U.end);
  }
  function q(U) {
    P.call(this, U);
    const K = this.stack[this.stack.length - 1];
    K.url = this.sliceSerialize(U);
  }
  function se(U) {
    P.call(this, U);
    const K = this.stack[this.stack.length - 1];
    K.url = "mailto:" + this.sliceSerialize(U);
  }
  function ue() {
    return { type: "blockquote", children: [] };
  }
  function ve() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function Pe() {
    return { type: "inlineCode", value: "" };
  }
  function Fe() {
    return { type: "definition", identifier: "", label: null, title: null, url: "" };
  }
  function rt() {
    return { type: "emphasis", children: [] };
  }
  function Rt() {
    return { type: "heading", depth: 0, children: [] };
  }
  function Qt() {
    return { type: "break" };
  }
  function Ft() {
    return { type: "html", value: "" };
  }
  function Ge() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function Ve() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function We(U) {
    return { type: "list", ordered: U.type === "listOrdered", start: null, spread: U._spread, children: [] };
  }
  function De(U) {
    return { type: "listItem", spread: U._spread, checked: null, children: [] };
  }
  function Ut() {
    return { type: "paragraph", children: [] };
  }
  function Lt() {
    return { type: "strong", children: [] };
  }
  function it() {
    return { type: "text", value: "" };
  }
  function hn() {
    return { type: "thematicBreak" };
  }
}
function ys(t) {
  return { line: t.line, column: t.column, offset: t.offset };
}
function RA(t, e) {
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    Array.isArray(r) ? RA(t, r) : kZ(t, r);
  }
}
function kZ(t, e) {
  let n;
  for (n in e)
    if ($A.call(e, n))
      switch (n) {
        case "canContainEols": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "transforms": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[n];
          r && Object.assign(t[n], r);
          break;
        }
      }
}
function Z2(t, e) {
  throw t
    ? new Error(
        "Cannot close `" +
          t.type +
          "` (" +
          Ji({ start: t.start, end: t.end }) +
          "): a different token (`" +
          e.type +
          "`, " +
          Ji({ start: e.start, end: e.end }) +
          ") is open"
      )
    : new Error("Cannot close document, a token (`" + e.type + "`, " + Ji({ start: e.start, end: e.end }) + ") is still open");
}
function yf(t) {
  return t.children instanceof Array;
}
class cp extends Error {
  constructor(e, n) {
    super(e), (this.name = "MarkdownParseError"), (this.cause = n);
  }
}
class up extends Error {
  constructor(e) {
    super(e), (this.name = "UnrecognizedMarkdownConstructError");
  }
}
function IA({ root: t, markdown: e, visitors: n, syntaxExtensions: r, mdastExtensions: i, ...s }) {
  var o;
  let a;
  try {
    a = wZ(e, { extensions: r, mdastExtensions: i });
  } catch (l) {
    throw l instanceof Error ? new cp(`Error parsing markdown: ${l.message}`, l) : new cp(`Error parsing markdown: ${l}`, l);
  }
  a.children.length === 0 && a.children.push({ type: "paragraph", children: [] }),
    ((o = a.children.at(-1)) == null ? void 0 : o.type) !== "paragraph" && a.children.push({ type: "paragraph", children: [] }),
    Um({ root: t, mdastRoot: a, visitors: n, ...s });
}
function Um({ root: t, mdastRoot: e, visitors: n, ...r }) {
  const i = new WeakMap();
  n = n.sort((a, l) => (l.priority ?? 0) - (a.priority ?? 0));
  function s(a, l) {
    if (!yf(a)) throw new Error("Attempting to visit children of a non-parent");
    a.children.forEach((c) => {
      o(c, l, a);
    });
  }
  function o(a, l, c) {
    const u = n.find((h) => (typeof h.testNode == "string" ? h.testNode === a.type : h.testNode(a, r)));
    if (!u)
      try {
        throw new up(`Unsupported markdown syntax: ${OA(a)}`);
      } catch {
        throw new up(
          `Parsing of the following markdown structure failed: ${JSON.stringify({ type: a.type, name: "name" in a ? a.name : "N/A" })}`
        );
      }
    u.visitNode({
      mdastNode: a,
      lexicalParent: l,
      mdastParent: c,
      actions: {
        visitChildren: s,
        addAndStepInto(h) {
          l.append(h), yf(a) && s(a, h);
        },
        addFormatting(h, f) {
          f || (yf(a) && (f = a)), f && i.set(f, h | (i.get(c) ?? 0));
        },
        removeFormatting(h, f) {
          f || (yf(a) && (f = a)), f && i.set(f, h ^ (i.get(c) ?? 0));
        },
        getParentFormatting() {
          return i.get(c) ?? 0;
        },
      },
    });
  }
  o(e, t, null);
}
const zb = typeof window < "u" && typeof window.document.createElement < "u",
  _u = zb && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
function Wb(t, e) {
  return _u ? t : e;
}
var CZ = Object.defineProperty,
  _Z = (t, e, n) => (e in t ? CZ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  m0 = (t, e, n) => (_Z(t, typeof e != "symbol" ? e + "" : e, n), n);
const TO = "generic-html";
class Xl extends ii {
  constructor(e, n, r, i) {
    super(i),
      m0(this, "__tag"),
      m0(this, "__nodeType"),
      m0(this, "__attributes"),
      (this.__tag = e),
      (this.__nodeType = n),
      (this.__attributes = r);
  }
  static getType() {
    return TO;
  }
  static clone(e) {
    return new Xl(e.__tag, e.__nodeType, e.__attributes, e.__key);
  }
  getTag() {
    return this.__tag;
  }
  getNodeType() {
    return this.__nodeType;
  }
  getAttributes() {
    return this.__attributes;
  }
  updateAttributes(e) {
    const n = this.getWritable();
    n.__attributes = e;
  }
  getStyle() {
    var e;
    return (e = this.__attributes.find((n) => n.name === "style")) == null ? void 0 : e.value;
  }
  createDOM() {
    const e = this.__tag,
      n = document.createElement(e);
    return (
      this.__attributes.forEach((r) => {
        n.setAttribute(r.name, r.value);
      }),
      n
    );
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return { element: n };
  }
  static importJSON(e) {
    const n = Ub(e.tag, e.mdxType, e.attributes);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag(), attributes: this.__attributes, mdxType: this.__nodeType, type: TO, version: 1 };
  }
  extractWithChild() {
    return !0;
  }
  isInline() {
    return this.__nodeType === "mdxJsxTextElement";
  }
}
function Ub(t, e, n) {
  return Zn(new Xl(t, e, n));
}
function NA(t) {
  return t instanceof Xl;
}
const EZ = {
    testLexicalNode: NA,
    visitLexicalNode({ actions: t, lexicalNode: e }) {
      t.addAndStepInto("mdxJsxTextElement", { name: e.getTag(), type: e.getNodeType(), attributes: e.getAttributes() });
    },
    priority: -100,
  },
  TZ = {
    testLexicalNode: Hr,
    visitLexicalNode: ({ mdastParent: t, actions: e }) => {
      e.appendToParent(t, {
        type: "text",
        value: `
`,
      });
    },
  },
  PZ = {
    testLexicalNode: cs,
    visitLexicalNode: ({ actions: t }) => {
      t.addAndStepInto("paragraph");
    },
  },
  AZ = {
    testLexicalNode: cn,
    visitLexicalNode: ({ actions: t }) => {
      t.addAndStepInto("root");
    },
  },
  $Z = 0,
  Ga = 1,
  Ja = 2,
  Ka = 4,
  el = 8,
  _h = 16,
  tl = 32,
  nl = 64,
  RZ = 128;
function z2(t) {
  return t.type === "text";
}
const IZ = ["u", "span", "sub", "sup"],
  NZ = {
    shouldJoin: (t, e) => {
      if (["text", "emphasis", "strong"].includes(t.type)) return t.type === e.type;
      if (t.type === "mdxJsxTextElement" && e.type === "mdxJsxTextElement" && IZ.includes(e.name)) {
        const n = e;
        return t.name === n.name && JSON.stringify(t.attributes) === JSON.stringify(n.attributes);
      }
      return !1;
    },
    join(t, e) {
      return z2(t) && z2(e) ? { type: "text", value: t.value + e.value } : { ...t, children: [...t.children, ...e.children] };
    },
    testLexicalNode: ne,
    visitLexicalNode: ({ lexicalNode: t, mdastParent: e, actions: n }) => {
      const r = t.getPreviousSibling(),
        i = ne(r) ? r.getFormat() : 0,
        s = t.getTextContent(),
        o = t.getFormat(),
        a = t.getStyle();
      let l = e;
      if (
        (a &&
          (l = n.appendToParent(l, {
            type: "mdxJsxTextElement",
            name: "span",
            children: [],
            attributes: [{ type: "mdxJsxAttribute", name: "style", value: a }],
          })),
        i & o & Ja && (l = n.appendToParent(l, { type: "emphasis", children: [] })),
        i & o & Ga && (l = n.appendToParent(l, { type: "strong", children: [] })),
        i & o & el && (l = n.appendToParent(l, { type: "mdxJsxTextElement", name: "u", children: [], attributes: [] })),
        i & o & Ka && (l = n.appendToParent(l, { type: "delete", children: [] })),
        i & o & nl && (l = n.appendToParent(l, { type: "mdxJsxTextElement", name: "sup", children: [], attributes: [] })),
        i & o & tl && (l = n.appendToParent(l, { type: "mdxJsxTextElement", name: "sub", children: [], attributes: [] })),
        o & Ja && !(i & Ja) && (l = n.appendToParent(l, { type: "emphasis", children: [] })),
        o & Ga && !(i & Ga) && (l = n.appendToParent(l, { type: "strong", children: [] })),
        o & el && !(i & el) && (l = n.appendToParent(l, { type: "mdxJsxTextElement", name: "u", children: [], attributes: [] })),
        o & Ka && !(i & Ka) && (l = n.appendToParent(l, { type: "delete", children: [] })),
        o & nl && !(i & nl) && (l = n.appendToParent(l, { type: "mdxJsxTextElement", name: "sup", children: [], attributes: [] })),
        o & tl && !(i & tl) && (l = n.appendToParent(l, { type: "mdxJsxTextElement", name: "sub", children: [], attributes: [] })),
        o & _h)
      ) {
        n.appendToParent(l, { type: "inlineCode", value: s });
        return;
      }
      n.appendToParent(l, { type: "text", value: s });
    },
  },
  LZ = {
    testNode: "break",
    visitNode: function ({ lexicalParent: t }) {
      t.append(Ri());
    },
  };
function wf(t, e) {
  return [
    {
      testNode: (n) => n.type === "mdxJsxTextElement" && n.name === t,
      visitNode({ actions: n, mdastNode: r, lexicalParent: i }) {
        n.addFormatting(e), n.visitChildren(r, i);
      },
    },
    {
      testNode: (n) => n.type === "html" && n.value === `<${t}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.addFormatting(e, r);
      },
    },
    {
      testNode: (n) => n.type === "html" && n.value === `</${t}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.removeFormatting(e, r);
      },
    },
  ];
}
const MZ = {
    testNode: "delete",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      e.addFormatting(Ka), e.visitChildren(t, n);
    },
  },
  DZ = {
    testNode: "inlineCode",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(Et(t.value).setFormat(e.getParentFormatting() | _h));
    },
  },
  QZ = {
    testNode: "emphasis",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      e.addFormatting(Ja), e.visitChildren(t, n);
    },
  },
  FZ = {
    testNode: "strong",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      e.addFormatting(Ga), e.visitChildren(t, n);
    },
  },
  VZ = [QZ, FZ, ...wf("u", el), ...wf("code", _h), DZ, MZ, ...wf("sup", nl), ...wf("sub", tl)],
  BZ = {
    testNode: Bb,
    visitNode: function ({ mdastNode: t, actions: e }) {
      e.addAndStepInto(Ub(t.name, t.type, t.attributes));
    },
    priority: -100,
  },
  jZ = ["listitem", "quote", "admonition"],
  ZZ = {
    testNode: "paragraph",
    visitNode: function ({ mdastNode: t, lexicalParent: e, actions: n }) {
      jZ.includes(e.getType()) ? n.visitChildren(t, e) : n.addAndStepInto(at());
    },
  },
  zZ = {
    testNode: "root",
    visitNode({ actions: t, mdastNode: e, lexicalParent: n }) {
      t.visitChildren(e, n);
    },
  },
  WZ = {
    testNode: "text",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(Et(t.value).setFormat(e.getParentFormatting()));
    },
  },
  LA = () => C.createElement(I3, { externalHistoryState: yt(VA) }),
  Br = {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    lf: 10,
    vt: 11,
    ff: 12,
    cr: 13,
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    quotationMark: 34,
    numberSign: 35,
    dollarSign: 36,
    percentSign: 37,
    ampersand: 38,
    apostrophe: 39,
    leftParenthesis: 40,
    rightParenthesis: 41,
    asterisk: 42,
    plusSign: 43,
    comma: 44,
    dash: 45,
    dot: 46,
    slash: 47,
    digit0: 48,
    digit1: 49,
    digit2: 50,
    digit3: 51,
    digit4: 52,
    digit5: 53,
    digit6: 54,
    digit7: 55,
    digit8: 56,
    digit9: 57,
    colon: 58,
    semicolon: 59,
    lessThan: 60,
    equalsTo: 61,
    greaterThan: 62,
    questionMark: 63,
    atSign: 64,
    uppercaseA: 65,
    uppercaseB: 66,
    uppercaseC: 67,
    uppercaseD: 68,
    uppercaseE: 69,
    uppercaseF: 70,
    uppercaseG: 71,
    uppercaseH: 72,
    uppercaseI: 73,
    uppercaseJ: 74,
    uppercaseK: 75,
    uppercaseL: 76,
    uppercaseM: 77,
    uppercaseN: 78,
    uppercaseO: 79,
    uppercaseP: 80,
    uppercaseQ: 81,
    uppercaseR: 82,
    uppercaseS: 83,
    uppercaseT: 84,
    uppercaseU: 85,
    uppercaseV: 86,
    uppercaseW: 87,
    uppercaseX: 88,
    uppercaseY: 89,
    uppercaseZ: 90,
    leftSquareBracket: 91,
    backslash: 92,
    rightSquareBracket: 93,
    caret: 94,
    underscore: 95,
    graveAccent: 96,
    lowercaseA: 97,
    lowercaseB: 98,
    lowercaseC: 99,
    lowercaseD: 100,
    lowercaseE: 101,
    lowercaseF: 102,
    lowercaseG: 103,
    lowercaseH: 104,
    lowercaseI: 105,
    lowercaseJ: 106,
    lowercaseK: 107,
    lowercaseL: 108,
    lowercaseM: 109,
    lowercaseN: 110,
    lowercaseO: 111,
    lowercaseP: 112,
    lowercaseQ: 113,
    lowercaseR: 114,
    lowercaseS: 115,
    lowercaseT: 116,
    lowercaseU: 117,
    lowercaseV: 118,
    lowercaseW: 119,
    lowercaseX: 120,
    lowercaseY: 121,
    lowercaseZ: 122,
    leftCurlyBrace: 123,
    verticalBar: 124,
    rightCurlyBrace: 125,
    tilde: 126,
    del: 127,
    byteOrderMarker: 65279,
    replacementCharacter: 65533,
  },
  Co = {
    data: "data",
    whitespace: "whitespace",
    lineEnding: "lineEnding",
    lineEndingBlank: "lineEndingBlank",
    linePrefix: "linePrefix",
    lineSuffix: "lineSuffix",
    atxHeading: "atxHeading",
    atxHeadingSequence: "atxHeadingSequence",
    atxHeadingText: "atxHeadingText",
    autolink: "autolink",
    autolinkEmail: "autolinkEmail",
    autolinkMarker: "autolinkMarker",
    autolinkProtocol: "autolinkProtocol",
    characterEscape: "characterEscape",
    characterEscapeValue: "characterEscapeValue",
    characterReference: "characterReference",
    characterReferenceMarker: "characterReferenceMarker",
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    characterReferenceValue: "characterReferenceValue",
    codeFenced: "codeFenced",
    codeFencedFence: "codeFencedFence",
    codeFencedFenceSequence: "codeFencedFenceSequence",
    codeFencedFenceInfo: "codeFencedFenceInfo",
    codeFencedFenceMeta: "codeFencedFenceMeta",
    codeFlowValue: "codeFlowValue",
    codeIndented: "codeIndented",
    codeText: "codeText",
    codeTextData: "codeTextData",
    codeTextPadding: "codeTextPadding",
    codeTextSequence: "codeTextSequence",
    content: "content",
    definition: "definition",
    definitionDestination: "definitionDestination",
    definitionDestinationLiteral: "definitionDestinationLiteral",
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    definitionDestinationRaw: "definitionDestinationRaw",
    definitionDestinationString: "definitionDestinationString",
    definitionLabel: "definitionLabel",
    definitionLabelMarker: "definitionLabelMarker",
    definitionLabelString: "definitionLabelString",
    definitionMarker: "definitionMarker",
    definitionTitle: "definitionTitle",
    definitionTitleMarker: "definitionTitleMarker",
    definitionTitleString: "definitionTitleString",
    emphasis: "emphasis",
    emphasisSequence: "emphasisSequence",
    emphasisText: "emphasisText",
    escapeMarker: "escapeMarker",
    hardBreakEscape: "hardBreakEscape",
    hardBreakTrailing: "hardBreakTrailing",
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    image: "image",
    label: "label",
    labelText: "labelText",
    labelLink: "labelLink",
    labelImage: "labelImage",
    labelMarker: "labelMarker",
    labelImageMarker: "labelImageMarker",
    labelEnd: "labelEnd",
    link: "link",
    paragraph: "paragraph",
    reference: "reference",
    referenceMarker: "referenceMarker",
    referenceString: "referenceString",
    resource: "resource",
    resourceDestination: "resourceDestination",
    resourceDestinationLiteral: "resourceDestinationLiteral",
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    resourceDestinationRaw: "resourceDestinationRaw",
    resourceDestinationString: "resourceDestinationString",
    resourceMarker: "resourceMarker",
    resourceTitle: "resourceTitle",
    resourceTitleMarker: "resourceTitleMarker",
    resourceTitleString: "resourceTitleString",
    setextHeading: "setextHeading",
    setextHeadingText: "setextHeadingText",
    setextHeadingLine: "setextHeadingLine",
    setextHeadingLineSequence: "setextHeadingLineSequence",
    strong: "strong",
    strongSequence: "strongSequence",
    strongText: "strongText",
    thematicBreak: "thematicBreak",
    thematicBreakSequence: "thematicBreakSequence",
    blockQuote: "blockQuote",
    blockQuotePrefix: "blockQuotePrefix",
    blockQuoteMarker: "blockQuoteMarker",
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    listOrdered: "listOrdered",
    listUnordered: "listUnordered",
    listItemIndent: "listItemIndent",
    listItemMarker: "listItemMarker",
    listItemPrefix: "listItemPrefix",
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    listItemValue: "listItemValue",
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString",
  };
function UZ(t) {
  return {
    canContainEols: ["comment"],
    enter: {
      comment(e) {
        this.buffer();
      },
    },
    exit: {
      comment(e) {
        const n = this.resume();
        t.ast && (this.enter({ type: "comment", value: "", commentValue: n.slice(0, -2) }, e), this.exit(e));
      },
    },
  };
}
const W2 = (t, e, n) => {
    return r;
    function r(p) {
      return t.enter("comment"), t.consume(p), i;
    }
    function i(p) {
      return p === Br.exclamationMark ? (t.consume(p), s) : n(p);
    }
    function s(p) {
      return p === Br.dash ? (t.consume(p), o) : n(p);
    }
    function o(p) {
      return p === Br.dash ? (t.consume(p), a) : n(p);
    }
    function a(p) {
      return p === Br.greaterThan ? n(p) : de(p) ? u(p) : (t.enter(Co.data), p === Br.dash ? (t.consume(p), l) : c(p));
    }
    function l(p) {
      return p === Br.greaterThan ? n(p) : c(p);
    }
    function c(p) {
      return p === Br.eof ? n(p) : p === Br.dash ? (t.consume(p), f) : de(p) ? (t.exit(Co.data), u(p)) : (t.consume(p), c);
    }
    function u(p) {
      return t.enter(Co.lineEnding), t.consume(p), t.exit(Co.lineEnding), Me(t, h, Co.linePrefix);
    }
    function h(p) {
      return de(p) ? u(p) : (t.enter(Co.data), c(p));
    }
    function f(p) {
      return p === Br.dash ? (t.consume(p), d) : c(p);
    }
    function d(p) {
      return p === Br.greaterThan
        ? (t.exit(Co.data), t.enter("commentEnd"), t.consume(p), t.exit("commentEnd"), t.exit("comment"), e(p))
        : p === Br.dash
        ? (t.consume(p), d)
        : c(p);
    }
  },
  XZ = { flow: { 60: { tokenize: W2, concrete: !0 } }, text: { 60: { tokenize: W2 } } },
  HZ = "_light_1tncs_1",
  qZ = "_light-theme_1tncs_1",
  YZ = "_dark_1tncs_1",
  GZ = "_dark-theme_1tncs_1",
  JZ = "_bold_1tncs_10",
  KZ = "_italic_1tncs_14",
  ez = "_underline_1tncs_18",
  tz = "_strikethrough_1tncs_34",
  nz = "_underlineStrikethrough_1tncs_38",
  rz = "_subscript_1tncs_42",
  iz = "_superscript_1tncs_47",
  sz = "_code_1tncs_52",
  oz = "_nestedListItem_1tncs_59",
  az = "_listitem_1tncs_69",
  lz = "_listItemChecked_1tncs_73",
  cz = "_listItemUnchecked_1tncs_74",
  uz = "_admonitionDanger_1tncs_151",
  hz = "_admonitionInfo_1tncs_152",
  fz = "_admonitionNote_1tncs_153",
  dz = "_admonitionTip_1tncs_154",
  pz = "_admonitionCaution_1tncs_155",
  mz = "_mdxExpression_1tncs_188",
  on = {
    light: HZ,
    lightTheme: qZ,
    dark: YZ,
    darkTheme: GZ,
    bold: JZ,
    italic: KZ,
    underline: ez,
    strikethrough: tz,
    underlineStrikethrough: nz,
    subscript: rz,
    superscript: iz,
    code: sz,
    nestedListItem: oz,
    listitem: az,
    listItemChecked: lz,
    listItemUnchecked: cz,
    admonitionDanger: uz,
    admonitionInfo: hz,
    admonitionNote: fz,
    admonitionTip: dz,
    admonitionCaution: pz,
    mdxExpression: mz,
  },
  Xm = {
    text: {
      bold: on.bold,
      italic: on.italic,
      underline: on.underline,
      code: on.code,
      strikethrough: on.strikethrough,
      subscript: on.subscript,
      superscript: on.superscript,
      underlineStrikethrough: on.underlineStrikethrough,
    },
    list: {
      listitem: on.listitem,
      listitemChecked: on.listItemChecked,
      listitemUnchecked: on.listItemUnchecked,
      nested: { listitem: on.nestedListItem },
    },
    admonition: {
      danger: on.admonitionDanger,
      info: on.admonitionInfo,
      note: on.admonitionNote,
      tip: on.admonitionTip,
      caution: on.admonitionCaution,
    },
  },
  Gs = gs(),
  sr = Se(null),
  At = Se(null),
  hp = Se(""),
  sn = Se(!1, (t) => {
    t.sub(t.pipe(sn, bt(sr)), ([e, n]) => {
      n == null || n.setEditable(!e);
    });
  }),
  fp = Se(""),
  PO = Se(!1),
  gl = Se(!1),
  Hm = Se(0),
  Ol = Se(null),
  dp = $t((t) => {
    t.link(
      t.pipe(
        Ol,
        Vl((e) => e !== null)
      ),
      dp
    );
  }),
  qm = $t((t) => {
    t.sub(t.pipe(qm, bt(At)), ([e, n]) => {
      n == null || n.dispatchCommand(Gi, e);
    });
  }),
  Zo = Se(null, (t) => {
    t.sub(t.pipe(Zo, bt(At)), ([e, n]) => {
      if (!e || !n) return;
      const r = e.anchor.getNode();
      let i =
        r.getKey() === "root"
          ? r
          : Wl(r, (a) => {
              const l = a.getParent();
              return l !== null && rn(l);
            });
      i === null && (i = r.getTopLevelElementOrThrow());
      const s = i.getKey();
      if (n.getElementByKey(s) !== null) {
        const a = Bm(i) ? i.getTag() : i.getType();
        t.pub(oy, a);
      }
    });
  }),
  Xb = Se(""),
  Gr = Se(""),
  Ym = $t((t) => {
    t.link(Gr, Ym), t.link(Xb, Gr);
  }),
  AO = $t((t) => {
    t.link(
      t.pipe(
        Ym,
        bt(mp),
        Vl(([, e]) => !e),
        Rr(([e]) => e)
      ),
      AO
    );
  }),
  Eh = Se([]),
  Th = Se([]),
  Hb = Se([]),
  qb = Se([]),
  Ph = Se([]),
  Yb = Se([]),
  pp = Se({}),
  Ah = Se(!1),
  Js = Se([]),
  zo = Se([]),
  ha = Se([]),
  si = Se(null),
  vr = zn(Th),
  rr = zn(Eh),
  Ks = zn(Hb),
  eo = zn(qb),
  xr = zn(Ph),
  fa = zn(Yb),
  mp = Se(!1),
  Gm = $t((t) => {
    t.sub(
      t.pipe(
        Gm,
        bt(Gr, sr, gl),
        Vl(([e, n]) => e.trim() !== n.trim())
      ),
      ([e, , n, r]) => {
        t.pub(mp, !0),
          n == null ||
            n.update(
              () => {
                Be().clear(), ey(t, Be(), e), r ? n.focus() : yn(null);
              },
              {
                onUpdate: () => {
                  t.pub(mp, !1);
                },
              }
            );
      }
    );
  }),
  Gb = $t((t) => {
    t.sub(t.pipe(Gb, bt(At, gl)), ([e, n, r]) => {
      n == null ||
        n.update(() => {
          const i = ce();
          if (i !== null) {
            const s = {
              children: [],
              append(o) {
                this.children.push(o);
              },
              getType() {
                return i.getNodes()[0].getType();
              },
            };
            ey(t, s, e), Zl(s.children);
          }
          r ? n.focus() : yn(null);
        });
    });
  });
function MA() {
  return Gx(
    (t, [e, n]) => (
      t.forEach((r) => {
        if (!r) throw new Error("You have a subscription that does not return a teardown");
        r();
      }),
      n ? e.map((r) => r(n)) : []
    ),
    []
  );
}
const Jb = Se([], (t) => {
    t.pipe(t.combine(Jb, At), MA());
  }),
  Kb = Se([], (t) => {
    t.pipe(t.combine(Kb, sr), MA());
  }),
  ho = Se(null),
  vl = $t(),
  ft = Se((t) => {
    throw new Error(`No icon component for ${t}`);
  });
function zn(t, e) {
  return $t((n, r) => {
    n.changeWith(t, r, (i, s) => {
      Array.isArray(s) || (s = [s]);
      let o = i;
      for (const a of s) i.includes(a) || (o = [...o, a]);
      return o;
    }),
      e == null || e(n, r);
  });
}
function DA(t) {
  const e = ce();
  ee(e) && t.pubIn({ [Zo]: e, [Hm]: e.format });
}
const $h = zn(Kb, (t, e) => {
    t.pub(e, [
      (n) =>
        n.registerCommand(
          Bl,
          (r, i) => (
            t.pubIn({ [At]: i, [gl]: !0 }),
            i._parentEditor === null &&
              i.getEditorState().read(() => {
                t.pub(ho, { rootNode: Be(), editorType: "lexical" });
              }),
            DA(t),
            !1
          ),
          Gn
        ),
      (n) =>
        n.registerUpdateListener(({ dirtyElements: r, dirtyLeaves: i, editorState: s }) => {
          if (t.getValue(Ol) !== null || (r.size === 0 && i.size === 0)) return;
          let a;
          s.read(() => {
            Be().getLastChild() instanceof Mi &&
              n.update(
                () => {
                  Be().append(at());
                },
                { discrete: !0 }
              ),
              (a = jb({
                root: Be(),
                visitors: t.getValue(Ph),
                jsxComponentDescriptors: t.getValue(Js),
                toMarkdownExtensions: t.getValue(Yb),
                toMarkdownOptions: t.getValue(pp),
                jsxIsAvailable: t.getValue(Ah),
              }));
          }),
            t.pub(Gr, a.trim());
        }),
      (n) => n.registerCommand(lb, () => (t.pub(gl, !0), !1), Gn),
      (n) =>
        n.registerCommand(
          Kx,
          (r) => {
            const { keyCode: i, ctrlKey: s, metaKey: o } = r;
            if (i === 65 && Wb(o, s)) {
              let a = !1;
              if (
                (n.getEditorState().read(() => {
                  a = ht(Be().getFirstChild()) || ht(Be().getLastChild());
                }),
                a)
              )
                return (
                  r.preventDefault(),
                  r.stopImmediatePropagation(),
                  n.update(() => {
                    var l;
                    const c = n.getRootElement();
                    (l = window.getSelection()) == null || l.selectAllChildren(c), c.focus({ preventScroll: !0 });
                  }),
                  !0
                );
            }
            return !1;
          },
          Gn
        ),
    ]);
  }),
  Eu = zn(Jb, (t, e) => {
    t.pub(e, [
      (n) =>
        n.registerUpdateListener(({ editorState: r }) => {
          r.read(() => {
            DA(t);
          });
        }),
      (n) =>
        n.registerCommand(
          Em,
          (r) => {
            var i;
            const s = t.getValue(sr);
            return s && !((i = s.getRootElement()) != null && i.contains(r.relatedTarget)) && t.pubIn({ [gl]: !1, [vl]: r }), !1;
          },
          Gn
        ),
    ]);
  });
function ey(t, e, n) {
  try {
    IA({
      root: e,
      visitors: t.getValue(Eh),
      mdastExtensions: t.getValue(qb),
      markdown: n,
      syntaxExtensions: t.getValue(Hb),
      jsxComponentDescriptors: t.getValue(Js),
      directiveDescriptors: t.getValue(zo),
      codeBlockEditorDescriptors: t.getValue(ha),
    }),
      t.pub(Ol, null);
  } catch (r) {
    if (r instanceof cp || r instanceof up) t.pubIn({ [Gr]: n, [Ol]: { error: r.message, source: n } });
    else throw r;
  }
}
const ty = Se([]),
  fo = zn(ty),
  ny = Se([]),
  QA = zn(ny),
  ry = Se([]),
  FA = zn(ry),
  iy = Se([]),
  sy = zn(iy),
  VA = Se(R3()),
  oy = Se(""),
  gz = $t(),
  Tu = $t((t) => {
    t.sub(t.pipe(Tu, bt(At)), ([e, n]) => {
      n == null ||
        n.update(() => {
          const r = ce();
          ee(r) &&
            (UQ(r, e),
            setTimeout(() => {
              n.focus();
            }));
        });
    });
  }),
  Hl = $t((t) => {
    t.sub(t.pipe(Hl, bt(At)), ([e, n]) => {
      n == null ||
        n.focus(
          () => {
            n.getEditorState().read(() => {
              const r = ce();
              ee(r) &&
                (n.update(() => {
                  const i = e();
                  i.isInline() ? (Zl([i]), rn(i.getParentOrThrow()) && Lb(i, at).selectEnd()) : $3(i),
                    setTimeout(() => {
                      "select" in i && typeof i.select == "function" && i.select();
                    });
                }),
                setTimeout(() => {
                  n.dispatchCommand(Gs, void 0);
                }));
            });
          },
          { defaultSelection: "rootEnd" }
        );
    });
  }),
  to = Se("rich-text", (t) => {
    function e() {
      return Gx((n, r) => ({ current: n.next, next: r }), { current: "rich-text", next: "rich-text" });
    }
    t.sub(t.pipe(to, e(), bt(Wo)), ([{ current: n }, r]) => {
      (n === "source" || n === "diff") && t.pub(Gm, r);
    }),
      t.sub(
        t.pipe(
          to,
          e(),
          Vl((n) => n.current === "rich-text"),
          bt(At)
        ),
        ([, n]) => {
          n == null || n.dispatchCommand(Gs, void 0);
        }
      );
  }),
  Wo = Se("", (t) => {
    t.link(Gr, Wo), t.link(Wo, Ym);
  }),
  Jm = Se([]),
  ql = zn(Jm),
  ay = Se(() => {
    throw new Error("No translation function provided");
  }),
  BA = en({
    init(t, e) {
      t.register($h),
        t.register(Eu),
        t.register(Ym),
        t.pubIn({
          [Xb]: e == null ? void 0 : e.initialMarkdown.trim(),
          [ft]: e == null ? void 0 : e.iconComponentFor,
          [rr]: [zZ, ZZ, WZ, LZ, ...VZ],
          [vr]: [ua, Os, Xl],
          [xr]: [AZ, PZ, NZ, TZ, EZ],
          [fo]: LA,
          [hp]: e == null ? void 0 : e.contentEditableClassName,
          [pp]: e == null ? void 0 : e.toMarkdownOptions,
          [PO]: e == null ? void 0 : e.autoFocus,
          [fp]: e == null ? void 0 : e.placeholder,
          [sn]: e == null ? void 0 : e.readOnly,
          [ay]: e == null ? void 0 : e.translation,
          [eo]: RF(),
          [Ks]: AF(),
          [fa]: [U3(), IF()],
        }),
        t.singletonSub(dp, e == null ? void 0 : e.onError),
        t.singletonSub(AO, e == null ? void 0 : e.onChange),
        t.singletonSub(vl, e == null ? void 0 : e.onBlur),
        (e != null && e.suppressHtmlProcessing) || t.pubIn({ [eo]: [W3(), UZ({ ast: !1 })], [Ks]: [G3(), J3(), XZ], [rr]: BZ });
    },
    postInit(t, e) {
      const n = Rb({
        editable: (e == null ? void 0 : e.readOnly) !== !0,
        namespace: "MDXEditor",
        nodes: t.getValue(Th),
        onError: (r) => {
          throw r;
        },
        theme: Xm,
      });
      n.update(() => {
        const r = (e == null ? void 0 : e.initialMarkdown.trim()) ?? "";
        ey(t, Be(), r);
        const i = e == null ? void 0 : e.autoFocus;
        if (i) {
          if (i === !0) {
            setTimeout(() => {
              n.focus(Zs, { defaultSelection: "rootStart" });
            });
            return;
          }
          setTimeout(() => {
            n.focus(Zs, { defaultSelection: i.defaultSelection ?? "rootStart" });
          });
        }
      }),
        t.pub(sr, n),
        t.pub(At, n);
    },
    update(t, e) {
      t.pubIn({
        [hp]: e == null ? void 0 : e.contentEditableClassName,
        [pp]: e == null ? void 0 : e.toMarkdownOptions,
        [PO]: e == null ? void 0 : e.autoFocus,
        [fp]: e == null ? void 0 : e.placeholder,
        [sn]: e == null ? void 0 : e.readOnly,
      }),
        t.singletonSub(AO, e == null ? void 0 : e.onChange),
        t.singletonSub(vl, e == null ? void 0 : e.onBlur),
        t.singletonSub(dp, e == null ? void 0 : e.onError);
    },
  });
function lt() {
  return yt(ay);
}
const Oz = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? w.useLayoutEffect : w.useEffect;
function ly({
  ariaActiveDescendant: t,
  ariaAutoComplete: e,
  ariaControls: n,
  ariaDescribedBy: r,
  ariaExpanded: i,
  ariaLabel: s,
  ariaLabelledBy: o,
  ariaMultiline: a,
  ariaOwns: l,
  ariaRequired: c,
  autoCapitalize: u,
  className: h,
  id: f,
  role: d = "textbox",
  spellCheck: p = !0,
  style: m,
  tabIndex: O,
  "data-testid": v,
  ...g
}) {
  const [x] = jn(),
    [y, S] = w.useState(!1),
    k = w.useCallback(
      (b) => {
        b && b.ownerDocument && b.ownerDocument.defaultView && x.setRootElement(b);
      },
      [x]
    );
  return (
    Oz(
      () => (
        S(x.isEditable()),
        x.registerEditableListener((b) => {
          S(b);
        })
      ),
      [x]
    ),
    E.jsx("div", {
      ...g,
      "aria-activedescendant": y ? t : void 0,
      "aria-autocomplete": y ? e : "none",
      "aria-controls": y ? n : void 0,
      "aria-describedby": r,
      "aria-expanded": y && d === "combobox" ? !!i : void 0,
      "aria-label": s,
      "aria-labelledby": o,
      "aria-multiline": a,
      "aria-owns": y ? l : void 0,
      "aria-readonly": !y || void 0,
      "aria-required": c,
      autoCapitalize: u,
      className: h,
      contentEditable: y,
      "data-testid": v,
      id: f,
      ref: k,
      role: d,
      spellCheck: p,
      style: m,
      tabIndex: O,
    })
  );
}
function $O(t, e) {
  return (
    ($O = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, r) {
          return (n.__proto__ = r), n;
        }),
    $O(t, e)
  );
}
var U2 = { error: null },
  vz = (function (t) {
    var e, n;
    function r() {
      for (var s, o = arguments.length, a = new Array(o), l = 0; l < o; l++) a[l] = arguments[l];
      return (
        ((s = t.call.apply(t, [this].concat(a)) || this).state = U2),
        (s.resetErrorBoundary = function () {
          for (var c, u = arguments.length, h = new Array(u), f = 0; f < u; f++) h[f] = arguments[f];
          s.props.onReset == null || (c = s.props).onReset.apply(c, h), s.reset();
        }),
        s
      );
    }
    (n = t),
      ((e = r).prototype = Object.create(n.prototype)),
      (e.prototype.constructor = e),
      $O(e, n),
      (r.getDerivedStateFromError = function (s) {
        return { error: s };
      });
    var i = r.prototype;
    return (
      (i.reset = function () {
        this.setState(U2);
      }),
      (i.componentDidCatch = function (s, o) {
        var a, l;
        (a = (l = this.props).onError) == null || a.call(l, s, o);
      }),
      (i.componentDidUpdate = function (s, o) {
        var a,
          l,
          c,
          u,
          h = this.state.error,
          f = this.props.resetKeys;
        h !== null &&
          o.error !== null &&
          ((c = s.resetKeys) === void 0 && (c = []),
          (u = f) === void 0 && (u = []),
          c.length !== u.length ||
            c.some(function (d, p) {
              return !Object.is(d, u[p]);
            })) &&
          ((a = (l = this.props).onResetKeysChange) == null || a.call(l, s.resetKeys, f), this.reset());
      }),
      (i.render = function () {
        var s = this.state.error,
          o = this.props,
          a = o.fallbackRender,
          l = o.FallbackComponent,
          c = o.fallback;
        if (s !== null) {
          var u = { error: s, resetErrorBoundary: this.resetErrorBoundary };
          if (w.isValidElement(c)) return c;
          if (typeof a == "function") return a(u);
          if (l) return w.createElement(l, u);
          throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
        }
        return this.props.children;
      }),
      r
    );
  })(w.Component);
function cy({ children: t, onError: e }) {
  return E.jsx(vz, {
    fallback: E.jsx("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" }, children: "An error was thrown." }),
    onError: e,
    children: t,
  });
}
const xz = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? w.useLayoutEffect : w.useEffect;
function bz(t) {
  return { initialValueFn: () => t.isEditable(), subscribe: (e) => t.registerEditableListener(e) };
}
function yz() {
  return (function (t) {
    const [e] = jn(),
      n = w.useMemo(() => t(e), [e, t]),
      r = w.useRef(n.initialValueFn()),
      [i, s] = w.useState(r.current);
    return (
      xz(() => {
        const { initialValueFn: o, subscribe: a } = n,
          l = o();
        return (
          r.current !== l && ((r.current = l), s(l)),
          a((c) => {
            (r.current = c), s(c);
          })
        );
      }, [n, t]),
      i
    );
  })(bz);
}
function wz() {
  return Be().getTextContent();
}
function Sz(t, e = !0) {
  if (t) return !1;
  let n = wz();
  return e && (n = n.trim()), n === "";
}
function kz(t) {
  if (!Sz(t, !1)) return !1;
  const e = Be().getChildren(),
    n = e.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const i = e[r];
    if (ht(i)) return !1;
    if (W(i)) {
      if (!cs(i) || i.__indent !== 0) return !1;
      const s = i.getChildren(),
        o = s.length;
      for (let a = 0; a < o; a++) {
        const l = s[r];
        if (!ne(l)) return !1;
      }
    }
  }
  return !0;
}
function Cz(t) {
  return () => kz(t);
}
function _z(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
_z(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function Ez(t) {
  const e = window.location.origin,
    n = (r) => {
      if (r.origin !== e) return;
      const i = t.getRootElement();
      if (document.activeElement !== i) return;
      const s = r.data;
      if (typeof s == "string") {
        let o;
        try {
          o = JSON.parse(s);
        } catch {
          return;
        }
        if (o && o.protocol === "nuanria_messaging" && o.type === "request") {
          const a = o.payload;
          if (a && a.functionId === "makeChanges") {
            const l = a.args;
            if (l) {
              const [c, u, h, f, d, p] = l;
              t.update(() => {
                const m = ce();
                if (ee(m)) {
                  const O = m.anchor;
                  let v = O.getNode(),
                    g = 0,
                    x = 0;
                  if (
                    (ne(v) && c >= 0 && u >= 0 && ((g = c), (x = c + u), m.setTextNodeRange(v, g, v, x)),
                    (g === x && h === "") || (m.insertRawText(h), (v = O.getNode())),
                    ne(v))
                  ) {
                    (g = f), (x = f + d);
                    const y = v.getTextContentSize();
                    (g = g > y ? y : g), (x = x > y ? y : x), m.setTextNodeRange(v, g, v, x);
                  }
                  r.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
  return (
    window.addEventListener("message", n, !0),
    () => {
      window.removeEventListener("message", n, !0);
    }
  );
}
const RO = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? w.useLayoutEffect : w.useEffect;
function X2(t) {
  return t.getEditorState().read(Cz(t.isComposing()));
}
function uy({ contentEditable: t, placeholder: e, ErrorBoundary: n }) {
  const [r] = jn(),
    i = (function (s, o) {
      const [a, l] = w.useState(() => s.getDecorators());
      return (
        RO(
          () =>
            s.registerDecoratorListener((c) => {
              os.flushSync(() => {
                l(c);
              });
            }),
          [s]
        ),
        w.useEffect(() => {
          l(s.getDecorators());
        }, [s]),
        w.useMemo(() => {
          const c = [],
            u = Object.keys(a);
          for (let h = 0; h < u.length; h++) {
            const f = u[h],
              d = E.jsx(o, { onError: (m) => s._onError(m), children: E.jsx(w.Suspense, { fallback: null, children: a[f] }) }),
              p = s.getElementByKey(f);
            p !== null && c.push(os.createPortal(d, p, f));
          }
          return c;
        }, [o, a, s])
      );
    })(r, n);
  return (
    (function (s) {
      RO(() => ir(CF(s), Ez(s)), [s]);
    })(r),
    E.jsxs(E.Fragment, { children: [t, E.jsx(Tz, { content: e }), i] })
  );
}
function Tz({ content: t }) {
  const [e] = jn(),
    n = (function (i) {
      const [s, o] = w.useState(() => X2(i));
      return (
        RO(() => {
          function a() {
            const l = X2(i);
            o(l);
          }
          return (
            a(),
            ir(
              i.registerUpdateListener(() => {
                a();
              }),
              i.registerEditableListener(() => {
                a();
              })
            )
          );
        }, [i]),
        s
      );
    })(e),
    r = yz();
  return n ? (typeof t == "function" ? t(r) : t) : null;
}
var jA = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (t) {
  (function () {
    var e = {}.hasOwnProperty;
    function n() {
      for (var s = "", o = 0; o < arguments.length; o++) {
        var a = arguments[o];
        a && (s = i(s, r(a)));
      }
      return s;
    }
    function r(s) {
      if (typeof s == "string" || typeof s == "number") return s;
      if (typeof s != "object") return "";
      if (Array.isArray(s)) return n.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) return s.toString();
      var o = "";
      for (var a in s) e.call(s, a) && s[a] && (o = i(o, a));
      return o;
    }
    function i(s, o) {
      return o ? (s ? s + " " + o : s + o) : s;
    }
    t.exports ? ((n.default = n), (t.exports = n)) : (window.classNames = n);
  })();
})(jA);
var Pz = jA.exports;
const Ze = Ql(Pz),
  Az = "_editorRoot_yms4a_53",
  $z = "_editorWrapper_yms4a_154",
  Rz = "_nestedListItem_yms4a_156",
  Iz = "_toolbarRoot_yms4a_160",
  Nz = "_readOnlyToolbarRoot_yms4a_187",
  Lz = "_toolbarModeSwitch_yms4a_196",
  Mz = "_toolbarToggleItem_yms4a_206",
  Dz = "_toolbarGroupOfGroups_yms4a_217",
  Qz = "_toolbarToggleSingleGroup_yms4a_222",
  Fz = "_toolbarButton_yms4a_237",
  Vz = "_activeToolbarButton_yms4a_274",
  Bz = "_toolbarNodeKindSelectContainer_yms4a_284",
  jz = "_toolbarButtonDropdownContainer_yms4a_285",
  Zz = "_toolbarCodeBlockLanguageSelectContent_yms4a_286",
  zz = "_selectContainer_yms4a_287",
  Wz = "_selectItem_yms4a_300",
  Uz = "_toolbarNodeKindSelectTrigger_yms4a_305",
  Xz = "_toolbarButtonSelectTrigger_yms4a_306",
  Hz = "_selectTrigger_yms4a_307",
  qz = "_toolbarCodeBlockLanguageSelectTrigger_yms4a_342",
  Yz = "_toolbarNodeKindSelectItem_yms4a_347",
  Gz = "_toolbarNodeKindSelectDropdownArrow_yms4a_372",
  Jz = "_selectDropdownArrow_yms4a_373",
  Kz = "_contentEditable_yms4a_379",
  eW = "_codeMirrorWrapper_yms4a_391",
  tW = "_sandPackWrapper_yms4a_400",
  nW = "_codeMirrorToolbar_yms4a_408",
  rW = "_frontmatterWrapper_yms4a_412",
  iW = "_frontmatterToggleButton_yms4a_422",
  sW = "_propertyPanelTitle_yms4a_430",
  oW = "_propertyEditorTable_yms4a_438",
  aW = "_iconButton_yms4a_456",
  lW = "_readOnlyColumnCell_yms4a_461",
  cW = "_propertyEditorLabelCell_yms4a_466",
  uW = "_buttonsFooter_yms4a_474",
  hW = "_propertyEditorInput_yms4a_480",
  fW = "_primaryButton_yms4a_506",
  dW = "_secondaryButton_yms4a_507",
  pW = "_smallButton_yms4a_522",
  mW = "_dialogForm_yms4a_534",
  gW = "_linkDialogEditForm_yms4a_540",
  OW = "_linkDialogInputContainer_yms4a_548",
  vW = "_linkDialogInputWrapper_yms4a_554",
  xW = "_linkDialogInput_yms4a_548",
  bW = "_dialogInput_yms4a_575",
  yW = "_linkDialogAnchor_yms4a_586",
  wW = "_linkDialogPopoverContent_yms4a_600",
  SW = "_tableColumnEditorPopoverContent_yms4a_601",
  kW = "_dialogContent_yms4a_602",
  CW = "_largeDialogContent_yms4a_614",
  _W = "_dialogTitle_yms4a_624",
  EW = "_dialogCloseButton_yms4a_630",
  TW = "_popoverContent_yms4a_637",
  PW = "_popoverArrow_yms4a_649",
  AW = "_linkDialogPreviewAnchor_yms4a_653",
  $W = "_tooltipTrigger_yms4a_676",
  RW = "_tooltipContent_yms4a_680",
  IW = "_actionButton_yms4a_694",
  NW = "_primaryActionButton_yms4a_701",
  LW = "_tableEditor_yms4a_713",
  MW = "_toolCell_yms4a_724",
  DW = "_tableColumnEditorTrigger_yms4a_743",
  QW = "_tableRowEditorTrigger_yms4a_744",
  FW = "_addRowButton_yms4a_745",
  VW = "_addColumnButton_yms4a_746",
  BW = "_tableColumnEditorToolbar_yms4a_789",
  jW = "_toggleGroupRoot_yms4a_803",
  ZW = "_tableToolsColumn_yms4a_821",
  zW = "_leftAlignedCell_yms4a_830",
  WW = "_rightAlignedCell_yms4a_834",
  UW = "_centeredCell_yms4a_838",
  XW = "_dialogOverlay_yms4a_871",
  HW = "_overlayShow_yms4a_1",
  qW = "_contentShow_yms4a_1",
  YW = "_focusedImage_yms4a_918",
  GW = "_imageWrapper_yms4a_922",
  JW = "_editImageToolbar_yms4a_935",
  KW = "_editImageButton_yms4a_939",
  eU = "_inlineEditor_yms4a_945",
  tU = "_blockEditor_yms4a_954",
  nU = "_nestedEditor_yms4a_963",
  rU = "_genericComponentName_yms4a_982",
  iU = "_diffSourceToggle_yms4a_988",
  sU = "_selectWithLabel_yms4a_1002",
  oU = "_toolbarTitleMode_yms4a_1017",
  aU = "_imageControlWrapperResizing_yms4a_1023",
  lU = "_imageResizer_yms4a_1027",
  cU = "_imageResizerN_yms4a_1036",
  uU = "_imageResizerNe_yms4a_1042",
  hU = "_imageResizerE_yms4a_1048",
  fU = "_imageResizerSe_yms4a_1054",
  dU = "_imageResizerS_yms4a_1054",
  pU = "_imageResizerSw_yms4a_1066",
  mU = "_imageResizerW_yms4a_1072",
  gU = "_imageResizerNw_yms4a_1078",
  OU = "_placeholder_yms4a_1084",
  vU = "_rootContentEditableWrapper_yms4a_1097",
  xU = "_downshiftContainer_yms4a_1103",
  bU = "_downshiftInputWrapper_yms4a_1109",
  yU = "_downshiftInput_yms4a_1109",
  wU = "_downshiftAutocompleteContainer_yms4a_1140",
  SU = "_textInput_yms4a_1186",
  kU = "_multiFieldForm_yms4a_1194",
  CU = "_formField_yms4a_1200",
  _U = "_markdownParseError_yms4a_1211",
  EU = "_popupContainer_yms4a_1220",
  TU = "_inputSizer_yms4a_1225",
  F = {
    editorRoot: Az,
    editorWrapper: $z,
    nestedListItem: Rz,
    toolbarRoot: Iz,
    readOnlyToolbarRoot: Nz,
    toolbarModeSwitch: Lz,
    toolbarToggleItem: Mz,
    toolbarGroupOfGroups: Dz,
    toolbarToggleSingleGroup: Qz,
    toolbarButton: Fz,
    activeToolbarButton: Vz,
    toolbarNodeKindSelectContainer: Bz,
    toolbarButtonDropdownContainer: jz,
    toolbarCodeBlockLanguageSelectContent: Zz,
    selectContainer: zz,
    selectItem: Wz,
    toolbarNodeKindSelectTrigger: Uz,
    toolbarButtonSelectTrigger: Xz,
    selectTrigger: Hz,
    toolbarCodeBlockLanguageSelectTrigger: qz,
    toolbarNodeKindSelectItem: Yz,
    toolbarNodeKindSelectDropdownArrow: Gz,
    selectDropdownArrow: Jz,
    contentEditable: Kz,
    codeMirrorWrapper: eW,
    sandPackWrapper: tW,
    codeMirrorToolbar: nW,
    frontmatterWrapper: rW,
    frontmatterToggleButton: iW,
    propertyPanelTitle: sW,
    propertyEditorTable: oW,
    iconButton: aW,
    readOnlyColumnCell: lW,
    propertyEditorLabelCell: cW,
    buttonsFooter: uW,
    propertyEditorInput: hW,
    primaryButton: fW,
    secondaryButton: dW,
    smallButton: pW,
    dialogForm: mW,
    linkDialogEditForm: gW,
    linkDialogInputContainer: OW,
    linkDialogInputWrapper: vW,
    linkDialogInput: xW,
    dialogInput: bW,
    linkDialogAnchor: yW,
    linkDialogPopoverContent: wW,
    tableColumnEditorPopoverContent: SW,
    dialogContent: kW,
    largeDialogContent: CW,
    dialogTitle: _W,
    dialogCloseButton: EW,
    popoverContent: TW,
    popoverArrow: PW,
    linkDialogPreviewAnchor: AW,
    tooltipTrigger: $W,
    tooltipContent: RW,
    actionButton: IW,
    primaryActionButton: NW,
    tableEditor: LW,
    toolCell: MW,
    tableColumnEditorTrigger: DW,
    tableRowEditorTrigger: QW,
    addRowButton: FW,
    addColumnButton: VW,
    tableColumnEditorToolbar: BW,
    toggleGroupRoot: jW,
    tableToolsColumn: ZW,
    leftAlignedCell: zW,
    rightAlignedCell: WW,
    centeredCell: UW,
    dialogOverlay: XW,
    overlayShow: HW,
    contentShow: qW,
    focusedImage: YW,
    imageWrapper: GW,
    editImageToolbar: JW,
    editImageButton: KW,
    inlineEditor: eU,
    blockEditor: tU,
    nestedEditor: nU,
    genericComponentName: rU,
    diffSourceToggle: iU,
    selectWithLabel: sU,
    toolbarTitleMode: oU,
    imageControlWrapperResizing: aU,
    imageResizer: lU,
    imageResizerN: cU,
    imageResizerNe: uU,
    imageResizerE: hU,
    imageResizerSe: fU,
    imageResizerS: dU,
    imageResizerSw: pU,
    imageResizerW: mU,
    imageResizerNw: gU,
    placeholder: OU,
    rootContentEditableWrapper: vU,
    downshiftContainer: xU,
    downshiftInputWrapper: bU,
    downshiftInput: yU,
    downshiftAutocompleteContainer: wU,
    textInput: SU,
    multiFieldForm: kU,
    formField: CU,
    markdownParseError: _U,
    popupContainer: EU,
    inputSizer: TU,
  },
  PU = {
    undo: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.202 18.5V17H14.3788C15.4224 17 16.3205 16.6554 17.073 15.9663C17.8257 15.2773 18.202 14.4263 18.202 13.4135C18.202 12.4007 17.8257 11.5512 17.073 10.8652C16.3205 10.1794 15.4224 9.8365 14.3788 9.8365H7.35775L10.1402 12.6193L9.0865 13.673L4.5 9.0865L9.0865 4.5L10.1402 5.55375L7.35775 8.3365H14.3788C15.8416 8.3365 17.0945 8.82467 18.1375 9.801C19.1805 10.7773 19.702 11.9815 19.702 13.4135C19.702 14.8455 19.1805 16.0513 18.1375 17.0308C17.0945 18.0103 15.8416 18.5 14.3788 18.5H7.202Z",
        fill: "currentColor",
      })
    ),
    redo: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.6211 18.5C8.15827 18.5 6.90535 18.0103 5.86235 17.0308C4.81935 16.0513 4.29785 14.8455 4.29785 13.4135C4.29785 11.9815 4.81935 10.7773 5.86235 9.801C6.90535 8.82467 8.15827 8.3365 9.6211 8.3365H16.6421L13.8596 5.55375L14.9134 4.5L19.4999 9.0865L14.9134 13.673L13.8596 12.6193L16.6421 9.8365H9.6211C8.57744 9.8365 7.67935 10.1794 6.92685 10.8652C6.17418 11.5512 5.79785 12.4007 5.79785 13.4135C5.79785 14.4263 6.17418 15.2773 6.92685 15.9663C7.67935 16.6554 8.57744 17 9.6211 17H16.7979V18.5H9.6211Z",
        fill: "currentColor",
      })
    ),
    format_bold: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.33838 18.625V5.375H12.1999C13.219 5.375 14.1405 5.69233 14.9644 6.327C15.788 6.9615 16.1999 7.816 16.1999 8.8905C16.1999 9.63783 16.0194 10.2471 15.6584 10.7182C15.2975 11.1894 14.9088 11.5314 14.4921 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3158 16.6614 14.0193 16.6614 14.9038C16.6614 16.1819 16.1902 17.1217 15.2479 17.723C14.3055 18.3243 13.3562 18.625 12.3999 18.625H7.33838ZM9.48838 16.6328H12.3191C13.1063 16.6328 13.6627 16.4142 13.9884 15.977C14.314 15.5398 14.4769 15.1206 14.4769 14.7192C14.4769 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8058 12.2729 12.8058H9.48838V16.6328ZM9.48838 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5279 10.3538C13.8835 10.0064 14.0614 9.59042 14.0614 9.10575C14.0614 8.59042 13.8733 8.16925 13.4971 7.84225C13.1208 7.51542 12.6595 7.352 12.1134 7.352H9.48838V10.875Z",
        fill: "currentColor",
      })
    ),
    format_italic: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.39404 18.625V16.8173H9.21129L12.4518 7.18275H8.63454V5.375H17.7883V7.18275H14.2785L11.0383 16.8173H14.5478V18.625H5.39404Z",
        fill: "currentColor",
      })
    ),
    format_underlined: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.34619 22.125V20.625H18.6537V22.125H5.34619ZM11.9999 18.5287C10.4448 18.5287 9.23102 18.0566 8.35869 17.1125C7.48619 16.1683 7.04994 14.9032 7.04994 13.3172V5.41345H8.90369V13.4095C8.90369 14.4198 9.17228 15.2295 9.70944 15.8385C10.2466 16.4475 11.0101 16.752 11.9999 16.752C12.9898 16.752 13.7533 16.4475 14.2904 15.8385C14.8276 15.2295 15.0962 14.4198 15.0962 13.4095V5.41345H16.9499V13.3172C16.9499 14.9032 16.5137 16.1683 15.6412 17.1125C14.7689 18.0566 13.5551 18.5287 11.9999 18.5287Z",
        fill: "currentColor",
      })
    ),
    code: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.99994 17.6537L2.34619 11.9999L7.99994 6.34619L9.06919 7.41544L4.46919 12.0154L9.05369 16.5999L7.99994 17.6537ZM15.9999 17.6537L14.9307 16.5844L19.5307 11.9844L14.9462 7.39994L15.9999 6.34619L21.6537 11.9999L15.9999 17.6537Z",
        fill: "currentColor",
      })
    ),
    strikeThrough: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12.15 19.6923C10.9732 19.6923 9.9315 19.359 9.025 18.6923C8.11867 18.0256 7.45525 17.1128 7.03475 15.9538L8.6385 15.2635C8.91667 16.0444 9.3545 16.6867 9.952 17.1905C10.5493 17.6944 11.2923 17.9463 12.1808 17.9463C12.9578 17.9463 13.6744 17.7508 14.3307 17.3598C14.9872 16.9686 15.3155 16.3487 15.3155 15.5C15.3155 15.123 15.2555 14.7968 15.1355 14.5213C15.0157 14.2456 14.8462 13.9885 14.627 13.75H16.677C16.7987 13.9705 16.8932 14.2256 16.9605 14.5153C17.0278 14.8051 17.0615 15.1334 17.0615 15.5C17.0615 16.8372 16.5747 17.8702 15.601 18.599C14.6272 19.3279 13.4768 19.6923 12.15 19.6923ZM2.25 11.75V10.25H21.75V11.75H2.25ZM12.05 4.19629C13.0475 4.19629 13.9123 4.42704 14.6443 4.88854C15.3763 5.35004 15.9673 6.05896 16.4173 7.01529L14.823 7.73079C14.6218 7.26029 14.2978 6.84462 13.851 6.48379C13.4042 6.12279 12.8141 5.94229 12.0808 5.94229C11.2244 5.94229 10.5392 6.16221 10.025 6.60204C9.51083 7.04171 9.264 7.59104 9.2845 8.25004H7.5385C7.50133 7.16421 7.89783 6.21712 8.728 5.40879C9.558 4.60046 10.6653 4.19629 12.05 4.19629Z",
        fill: "currentColor",
      })
    ),
    superscript: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M16.6924 8V6.2115C16.6924 5.95383 16.7786 5.73875 16.9511 5.56625C17.1235 5.39392 17.3385 5.30775 17.5961 5.30775H19.5001V4.38475H16.6924V3.5H19.4809C19.7385 3.5 19.9536 3.58625 20.1261 3.75875C20.2985 3.93108 20.3846 4.14617 20.3846 4.404V5.2885C20.3846 5.54617 20.2985 5.76125 20.1261 5.93375C19.9536 6.10608 19.7385 6.19225 19.4809 6.19225H17.5771V7.1155H20.3846V8H16.6924ZM4.44238 18.5L8.84638 11.6287L4.77713 5.30775H6.74438L9.95963 10.404H10.0214L13.2501 5.30775H15.2329L11.1194 11.6287L15.5579 18.5H13.5751L10.0214 12.9308H9.95963L6.42513 18.5H4.44238Z",
        fill: "currentColor",
      })
    ),
    subscript: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M16.6924 20.5V18.7115C16.6924 18.4538 16.7786 18.2387 16.9511 18.0662C17.1235 17.8939 17.3385 17.8077 17.5961 17.8077H19.5001V16.8845H16.6924V16H19.4809C19.7385 16 19.9536 16.0863 20.1261 16.2587C20.2985 16.4311 20.3846 16.6461 20.3846 16.9038V17.7885C20.3846 18.0462 20.2985 18.2612 20.1261 18.4337C19.9536 18.6061 19.7385 18.6923 19.4809 18.6923H17.5771V19.6152H20.3846V20.5H16.6924ZM4.44238 18.6923L8.84638 11.8212L4.77713 5.5H6.74438L9.95963 10.5962H10.0214L13.2501 5.5H15.2329L11.1194 11.8212L15.5579 18.6923H13.5751L10.0214 13.123H9.95963L6.42513 18.6923H4.44238Z",
        fill: "currentColor",
      })
    ),
    format_list_bulleted: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75005V5.25005H20.5V6.75005H9.30775ZM5.1635 19.6635C4.706 19.6635 4.31442 19.5006 3.98875 19.1748C3.66292 18.8491 3.5 18.4575 3.5 18C3.5 17.5425 3.66292 17.151 3.98875 16.8253C4.31442 16.4995 4.706 16.3365 5.1635 16.3365C5.621 16.3365 6.01258 16.4995 6.33825 16.8253C6.66408 17.151 6.827 17.5425 6.827 18C6.827 18.4575 6.66408 18.8491 6.33825 19.1748C6.01258 19.5006 5.621 19.6635 5.1635 19.6635ZM5.1635 13.6635C4.706 13.6635 4.31442 13.5006 3.98875 13.1748C3.66292 12.8491 3.5 12.4575 3.5 12C3.5 11.5425 3.66292 11.151 3.98875 10.8253C4.31442 10.4995 4.706 10.3365 5.1635 10.3365C5.621 10.3365 6.01258 10.4995 6.33825 10.8253C6.66408 11.151 6.827 11.5425 6.827 12C6.827 12.4575 6.66408 12.8491 6.33825 13.1748C6.01258 13.5006 5.621 13.6635 5.1635 13.6635ZM5.1635 7.66355C4.706 7.66355 4.31442 7.50063 3.98875 7.1748C3.66292 6.84913 3.5 6.45755 3.5 6.00005C3.5 5.54255 3.66292 5.15096 3.98875 4.8253C4.31442 4.49946 4.706 4.33655 5.1635 4.33655C5.621 4.33655 6.01258 4.49946 6.33825 4.8253C6.66408 5.15096 6.827 5.54255 6.827 6.00005C6.827 6.45755 6.66408 6.84913 6.33825 7.1748C6.01258 7.50063 5.621 7.66355 5.1635 7.66355Z",
        fill: "currentColor",
      })
    ),
    format_list_numbered: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 21.5V20.3078H6V19.25H4.5V18.0577H6V17H3.5V15.8077H6.34625C6.58592 15.8077 6.78683 15.8888 6.949 16.051C7.11117 16.2132 7.19225 16.4141 7.19225 16.6538V17.8462C7.19225 18.0859 7.11117 18.2868 6.949 18.449C6.78683 18.6112 6.58592 18.6923 6.34625 18.6923C6.58592 18.6923 6.78683 18.7733 6.949 18.9355C7.11117 19.0977 7.19225 19.2987 7.19225 19.5385V20.6538C7.19225 20.8936 7.11117 21.0946 6.949 21.2568C6.78683 21.4189 6.58592 21.5 6.34625 21.5H3.5ZM3.5 14.8463V12.25C3.5 12.0103 3.58108 11.8093 3.74325 11.647C3.90542 11.4848 4.10642 11.4038 4.34625 11.4038H6V10.3462H3.5V9.15375H6.34625C6.58592 9.15375 6.78683 9.23483 6.949 9.397C7.11117 9.55933 7.19225 9.76033 7.19225 10V11.75C7.19225 11.9897 7.11117 12.1907 6.949 12.353C6.78683 12.5152 6.58592 12.5963 6.34625 12.5963H4.69225V13.6538H7.19225V14.8463H3.5ZM5 8.19225V3.69225H3.5V2.5H6.19225V8.19225H5ZM9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75V5.25H20.5V6.75H9.30775Z",
        fill: "currentColor",
      })
    ),
    format_list_checked: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.69425 18.452L2.5 15.2578L3.54425 14.2135L5.66925 16.3385L9.91925 12.0885L10.9635 13.1578L5.69425 18.452ZM5.69425 10.8365L2.5 7.64227L3.54425 6.59802L5.66925 8.72302L9.91925 4.47302L10.9635 5.54227L5.69425 10.8365ZM13.0095 16.5578V15.0578H21.5095V16.5578H13.0095ZM13.0095 8.94227V7.44227H21.5095V8.94227H13.0095Z",
        fill: "currentColor",
      })
    ),
    link: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M10.8077 16.5385H7.0385C5.78283 16.5385 4.7125 16.096 3.8275 15.211C2.9425 14.3262 2.5 13.256 2.5 12.0005C2.5 10.745 2.9425 9.67471 3.8275 8.78955C4.7125 7.90421 5.78283 7.46155 7.0385 7.46155H10.8077V8.96155H7.0385C6.19867 8.96155 5.48233 9.25805 4.8895 9.85105C4.2965 10.444 4 11.1604 4 12C4 12.8397 4.2965 13.556 4.8895 14.149C5.48233 14.742 6.19867 15.0385 7.0385 15.0385H10.8077V16.5385ZM8.25 12.75V11.25H15.75V12.75H8.25ZM13.1923 16.5385V15.0385H16.9615C17.8013 15.0385 18.5177 14.742 19.1105 14.149C19.7035 13.556 20 12.8397 20 12C20 11.1604 19.7035 10.444 19.1105 9.85105C18.5177 9.25805 17.8013 8.96155 16.9615 8.96155H13.1923V7.46155H16.9615C18.2172 7.46155 19.2875 7.90405 20.1725 8.78905C21.0575 9.67388 21.5 10.744 21.5 11.9995C21.5 13.255 21.0575 14.3254 20.1725 15.2105C19.2875 16.0959 18.2172 16.5385 16.9615 16.5385H13.1923Z",
        fill: "currentColor",
      })
    ),
    add_photo: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.11537 20.5C4.6182 20.5 4.19262 20.323 3.83862 19.969C3.48462 19.615 3.30762 19.1894 3.30762 18.6922V5.30773C3.30762 4.81056 3.48462 4.38498 3.83862 4.03098C4.19262 3.67698 4.6182 3.49998 5.11537 3.49998H13.8076V4.99998H5.11537C5.02553 4.99998 4.95178 5.02881 4.89412 5.08648C4.83645 5.14415 4.80762 5.2179 4.80762 5.30773V18.6922C4.80762 18.7821 4.83645 18.8558 4.89412 18.9135C4.95178 18.9711 5.02553 19 5.11537 19H18.4999C18.5895 19 18.6633 18.9711 18.7211 18.9135C18.7788 18.8558 18.8076 18.7821 18.8076 18.6922V9.99998H20.3076V18.6922C20.3076 19.1894 20.1306 19.615 19.7766 19.969C19.4226 20.323 18.997 20.5 18.4999 20.5H5.11537ZM17.1921 8.61523V6.61523H15.1921V5.11548H17.1921V3.11548H18.6921V5.11548H20.6921V6.61523H18.6921V8.61523H17.1921ZM6.55762 16.75H17.1344L13.8459 12.3655L11.0384 16.0192L9.03837 13.4615L6.55762 16.75Z",
        fill: "currentColor",
      })
    ),
    table: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 18.6923V5.30775C3.5 4.81058 3.677 4.385 4.031 4.031C4.385 3.677 4.81058 3.5 5.30775 3.5H18.6923C19.1894 3.5 19.615 3.677 19.969 4.031C20.323 4.385 20.5 4.81058 20.5 5.30775V18.6923C20.5 19.1894 20.323 19.615 19.969 19.969C19.615 20.323 19.1894 20.5 18.6923 20.5H5.30775C4.81058 20.5 4.385 20.323 4.031 19.969C3.677 19.615 3.5 19.1894 3.5 18.6923ZM5 9.077H19V5.30775C19 5.21792 18.9712 5.14417 18.9135 5.0865C18.8558 5.02883 18.7821 5 18.6923 5H5.30775C5.21792 5 5.14417 5.02883 5.0865 5.0865C5.02883 5.14417 5 5.21792 5 5.30775V9.077ZM10.1615 14.0385H13.8385V10.577H10.1615V14.0385ZM10.1615 19H13.8385V15.5385H10.1615V19ZM5 14.0385H8.6615V10.577H5V14.0385ZM15.3385 14.0385H19V10.577H15.3385V14.0385ZM5.30775 19H8.6615V15.5385H5V18.6923C5 18.7821 5.02883 18.8558 5.0865 18.9135C5.14417 18.9712 5.21792 19 5.30775 19ZM15.3385 19H18.6923C18.7821 19 18.8558 18.9712 18.9135 18.9135C18.9712 18.8558 19 18.7821 19 18.6923V15.5385H15.3385V19Z",
        fill: "currentColor",
      })
    ),
    horizontal_rule: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", { d: "M4.5 12.75V11.25H19.5V12.75H4.5Z", fill: "currentColor" })
    ),
    frontmatter: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", { d: "M4.5 8.75V7.25H8.5V8.75H4.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M4.5 14.75V13.25H8.5V14.75H4.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M9.5 8.75V7.25H13.5V8.75H9.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M9.5 14.75V13.25H13.5V14.75H9.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M14.5 8.75V7.25H18.5V8.75H14.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M14.5 14.75V13.25H18.5V14.75H14.5Z", fill: "currentColor" })
    ),
    frame_source: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M8.6 15.2443L5.35575 12L8.6 8.75575L9.64425 9.825L7.46925 12L9.64425 14.175L8.6 15.2443ZM15.4 15.2443L14.3558 14.175L16.5307 12L14.3558 9.825L15.4 8.75575L18.6443 12L15.4 15.2443ZM5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V15H5V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H9V20.5H5.30775ZM15 20.5V19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V15H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H15ZM3.5 9V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H9V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V9H3.5ZM19 9V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H15V3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V9H19Z",
        fill: "currentColor",
      })
    ),
    arrow_drop_down: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", { d: "M11.9999 14.6537L7.59619 10.25H16.4037L11.9999 14.6537Z", fill: "currentColor" })
    ),
    admonition: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12.0001 21.4C11.7654 21.4 11.5385 21.3548 11.3193 21.2645C11.1002 21.174 10.9002 21.0435 10.7193 20.873L3.1271 13.2807C2.9566 13.0999 2.8261 12.8999 2.7356 12.6807C2.64526 12.4616 2.6001 12.2346 2.6001 12C2.6001 11.7653 2.64526 11.5358 2.7356 11.3115C2.8261 11.0871 2.9566 10.8897 3.1271 10.7192L10.7193 3.12698C10.9002 2.94614 11.1002 2.81314 11.3193 2.72798C11.5385 2.64264 11.7654 2.59998 12.0001 2.59998C12.2348 2.59998 12.4643 2.64264 12.6886 2.72798C12.9129 2.81314 13.1103 2.94614 13.2808 3.12698L20.8731 10.7192C21.0539 10.8897 21.1869 11.0871 21.2721 11.3115C21.3574 11.5358 21.4001 11.7653 21.4001 12C21.4001 12.2346 21.3574 12.4616 21.2721 12.6807C21.1869 12.8999 21.0539 13.0999 20.8731 13.2807L13.2808 20.873C13.1103 21.0435 12.9129 21.174 12.6886 21.2645C12.4643 21.3548 12.2348 21.4 12.0001 21.4ZM12.2213 19.8037L19.8039 12.2212C19.8552 12.1699 19.8808 12.0961 19.8808 12C19.8808 11.9038 19.8552 11.8301 19.8039 11.7787L12.2213 4.19623C12.17 4.14489 12.0963 4.11923 12.0001 4.11923C11.9039 4.11923 11.8302 4.14489 11.7788 4.19623L4.19635 11.7787C4.14501 11.8301 4.11935 11.9038 4.11935 12C4.11935 12.0961 4.14501 12.1699 4.19635 12.2212L11.7788 19.8037C11.8302 19.8551 11.9039 19.8807 12.0001 19.8807C12.0963 19.8807 12.17 19.8551 12.2213 19.8037ZM11.2501 13.0865H12.7501V7.47123H11.2501V13.0865ZM12.0001 15.702C12.2258 15.702 12.4168 15.6237 12.5731 15.4672C12.7296 15.3109 12.8078 15.1199 12.8078 14.8942C12.8078 14.6686 12.7296 14.4776 12.5731 14.3212C12.4168 14.1647 12.2258 14.0865 12.0001 14.0865C11.7744 14.0865 11.5834 14.1647 11.4271 14.3212C11.2706 14.4776 11.1923 14.6686 11.1923 14.8942C11.1923 15.1199 11.2706 15.3109 11.4271 15.4672C11.5834 15.6237 11.7744 15.702 12.0001 15.702Z",
        fill: "currentColor",
      })
    ),
    sandpack: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12.9999 22.5C12.4947 22.5 12.0671 22.325 11.7171 21.975C11.3671 21.625 11.1921 21.1974 11.1921 20.6922V7.30775C11.1921 6.80258 11.3671 6.375 11.7171 6.025C12.0671 5.675 12.4947 5.5 12.9999 5.5H16.3844C16.8895 5.5 17.3171 5.675 17.6671 6.025C18.0171 6.375 18.1921 6.80258 18.1921 7.30775V20.6922C18.1921 21.1974 18.0171 21.625 17.6671 21.975C17.3171 22.325 16.8895 22.5 16.3844 22.5H12.9999ZM12.6921 7.30775V20.6922C12.6921 20.7692 12.7242 20.8398 12.7884 20.9038C12.8524 20.9679 12.9229 21 12.9999 21H16.3844C16.4614 21 16.5319 20.9679 16.5959 20.9038C16.66 20.8398 16.6921 20.7692 16.6921 20.6922V7.30775C16.6921 7.23075 16.66 7.16025 16.5959 7.09625C16.5319 7.03208 16.4614 7 16.3844 7H12.9999C12.9229 7 12.8524 7.03208 12.7884 7.09625C12.7242 7.16025 12.6921 7.23075 12.6921 7.30775ZM6.61537 18.5C6.1102 18.5 5.68262 18.325 5.33262 17.975C4.98262 17.625 4.80762 17.1974 4.80762 16.6923V3.30775C4.80762 2.80258 4.98262 2.375 5.33262 2.025C5.68262 1.675 6.1102 1.5 6.61537 1.5H9.99987C10.505 1.5 10.9326 1.675 11.2826 2.025C11.6326 2.375 11.8076 2.80258 11.8076 3.30775V16.6923C11.8076 17.1974 11.6326 17.625 11.2826 17.975C10.9326 18.325 10.505 18.5 9.99987 18.5H6.61537ZM6.30762 3.30775V16.6923C6.30762 16.7692 6.3397 16.8398 6.40387 16.9038C6.46787 16.9679 6.53837 17 6.61537 17H9.99987C10.0769 17 10.1474 16.9679 10.2114 16.9038C10.2755 16.8398 10.3076 16.7692 10.3076 16.6923V3.30775C10.3076 3.23075 10.2755 3.16025 10.2114 3.09625C10.1474 3.03208 10.0769 3 9.99987 3H6.61537C6.53837 3 6.46787 3.03208 6.40387 3.09625C6.3397 3.16025 6.30762 3.23075 6.30762 3.30775Z",
        fill: "currentColor",
      })
    ),
    rich_text: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19ZM6.75 17H17.3268L14 12.3655L11.2308 16.0192L9 13.4615L6.75 17Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6 12V6.5H9.1925C9.5925 6.5 9.9425 6.65 10.2425 6.95C10.5425 7.25 10.6925 7.6 10.6925 8V8.6925C10.6925 9.03733 10.605 9.32675 10.43 9.56075C10.255 9.79458 10.0168 9.97817 9.7155 10.1115L10.6155 12H9.404L8.504 10.1925H7.1925V12H6ZM9.1925 9H7.1925V7.6925H9.1925C9.26933 7.6925 9.33983 7.7245 9.404 7.7885C9.468 7.85267 9.5 7.92317 9.5 8V8.6925C9.5 8.76933 9.468 8.83983 9.404 8.904C9.33983 8.968 9.26933 9 9.1925 9Z",
        fill: "currentColor",
      }),
      C.createElement("path", { d: "M12.5 7H17.5V8.25H12.5V7Z", fill: "currentColor" }),
      C.createElement("path", { d: "M12.5 9.25H17.5V10.5H12.5V9.25Z", fill: "currentColor" })
    ),
    difference: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
        fill: "currentColor",
      }),
      C.createElement("rect", { x: "9", y: "10", width: "5.5", height: "1.5", fill: "currentColor" }),
      C.createElement("rect", { x: "9", y: "15", width: "5.5", height: "1.5", fill: "currentColor" }),
      C.createElement("rect", { x: "11", y: "8", width: "1.5", height: "5.5", fill: "currentColor" })
    ),
    markdown: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
        fill: "currentColor",
      }),
      C.createElement("path", { d: "M13 15H11.5V11L9.5 14L7.5 11V15H6V8H7.5L9.5 11L11.5 8H13V15Z", fill: "currentColor" }),
      C.createElement("path", {
        d: "M15.9921 15.5833L13.2886 12.8797L14.0546 12.1137L15.4504 13.5016V7.99597L16.5336 7.99993V13.5016L17.9296 12.1137L18.6954 12.8797L15.9921 15.5833Z",
        fill: "currentColor",
      })
    ),
    open_in_new: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H11.6152V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V12.3848H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM9.71925 15.3345L8.6655 14.2808L17.9462 5H14V3.5H20.5V10H19V6.05375L9.71925 15.3345Z",
        fill: "currentColor",
      })
    ),
    link_off: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M18.8843 16.1038L17.7498 14.9385C18.4228 14.7552 18.9661 14.3946 19.3796 13.8568C19.7931 13.319 19.9998 12.7 19.9998 12C19.9998 11.1604 19.705 10.444 19.1153 9.85105C18.5255 9.25805 17.8139 8.96155 16.9806 8.96155H13.1728V7.46155H16.9806C18.2293 7.46155 19.2947 7.90422 20.1768 8.78955C21.0588 9.67472 21.4998 10.7449 21.4998 12C21.4998 12.8859 21.262 13.6951 20.7863 14.4278C20.3107 15.1606 19.6767 15.7193 18.8843 16.1038ZM15.5806 12.75L14.0806 11.25H15.7306V12.75H15.5806ZM20.1461 22.2538L1.74609 3.8538L2.79984 2.80005L21.1998 21.2L20.1461 22.2538ZM10.8268 16.5386H7.03834C5.78318 16.5386 4.71301 16.0959 3.82784 15.2105C2.94251 14.3254 2.49984 13.2552 2.49984 12C2.49984 10.8885 2.85784 9.91322 3.57384 9.07405C4.28984 8.23505 5.18826 7.72838 6.26909 7.55405H6.49984L7.90759 8.96155H7.03834C6.19851 8.96155 5.48218 9.25805 4.88934 9.85105C4.29634 10.444 3.99984 11.1604 3.99984 12C3.99984 12.8397 4.29634 13.556 4.88934 14.149C5.48218 14.742 6.19851 15.0385 7.03834 15.0385H10.8268V16.5386ZM8.26909 12.75V11.25H10.2113L11.6863 12.75H8.26909Z",
        fill: "currentColor",
      })
    ),
    edit: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5 19H6.2615L16.498 8.7635L15.2365 7.502L5 17.7385V19ZM3.5 20.5V17.1155L16.6905 3.93075C16.8417 3.79342 17.0086 3.68733 17.1913 3.6125C17.3741 3.5375 17.5658 3.5 17.7663 3.5C17.9668 3.5 18.1609 3.53558 18.3488 3.60675C18.5367 3.67792 18.7032 3.79108 18.848 3.94625L20.0693 5.18275C20.2244 5.32758 20.335 5.49425 20.401 5.68275C20.467 5.87125 20.5 6.05975 20.5 6.24825C20.5 6.44942 20.4657 6.64133 20.397 6.824C20.3283 7.00683 20.2191 7.17383 20.0693 7.325L6.8845 20.5H3.5ZM15.8562 8.14375L15.2365 7.502L16.498 8.7635L15.8562 8.14375Z",
        fill: "currentColor",
      })
    ),
    content_copy: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.05775 17.5C8.55258 17.5 8.125 17.325 7.775 16.975C7.425 16.625 7.25 16.1974 7.25 15.6923V4.30775C7.25 3.80258 7.425 3.375 7.775 3.025C8.125 2.675 8.55258 2.5 9.05775 2.5H17.4423C17.9474 2.5 18.375 2.675 18.725 3.025C19.075 3.375 19.25 3.80258 19.25 4.30775V15.6923C19.25 16.1974 19.075 16.625 18.725 16.975C18.375 17.325 17.9474 17.5 17.4423 17.5H9.05775ZM9.05775 16H17.4423C17.5192 16 17.5898 15.9679 17.6538 15.9038C17.7179 15.8398 17.75 15.7692 17.75 15.6923V4.30775C17.75 4.23075 17.7179 4.16025 17.6538 4.09625C17.5898 4.03208 17.5192 4 17.4423 4H9.05775C8.98075 4 8.91025 4.03208 8.84625 4.09625C8.78208 4.16025 8.75 4.23075 8.75 4.30775V15.6923C8.75 15.7692 8.78208 15.8398 8.84625 15.9038C8.91025 15.9679 8.98075 16 9.05775 16ZM5.55775 21C5.05258 21 4.625 20.825 4.275 20.475C3.925 20.125 3.75 19.6974 3.75 19.1923V6.30775H5.25V19.1923C5.25 19.2693 5.28208 19.3398 5.34625 19.4038C5.41025 19.4679 5.48075 19.5 5.55775 19.5H15.4423V21H5.55775Z",
        fill: "currentColor",
      })
    ),
    more_horiz: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M6.23096 13.5C5.81846 13.5 5.46537 13.3531 5.17171 13.0592C4.87787 12.7656 4.73096 12.4125 4.73096 12C4.73096 11.5875 4.87787 11.2344 5.17171 10.9408C5.46537 10.6469 5.81846 10.5 6.23096 10.5C6.64346 10.5 6.99662 10.6469 7.29046 10.9408C7.58412 11.2344 7.73096 11.5875 7.73096 12C7.73096 12.4125 7.58412 12.7656 7.29046 13.0592C6.99662 13.3531 6.64346 13.5 6.23096 13.5ZM12.0002 13.5C11.5877 13.5 11.2346 13.3531 10.941 13.0592C10.6471 12.7656 10.5002 12.4125 10.5002 12C10.5002 11.5875 10.6471 11.2344 10.941 10.9408C11.2346 10.6469 11.5877 10.5 12.0002 10.5C12.4127 10.5 12.7658 10.6469 13.0595 10.9408C13.3533 11.2344 13.5002 11.5875 13.5002 12C13.5002 12.4125 13.3533 12.7656 13.0595 13.0592C12.7658 13.3531 12.4127 13.5 12.0002 13.5ZM17.7695 13.5C17.357 13.5 17.0038 13.3531 16.71 13.0592C16.4163 12.7656 16.2695 12.4125 16.2695 12C16.2695 11.5875 16.4163 11.2344 16.71 10.9408C17.0038 10.6469 17.357 10.5 17.7695 10.5C18.182 10.5 18.535 10.6469 18.8287 10.9408C19.1225 11.2344 19.2695 11.5875 19.2695 12C19.2695 12.4125 19.1225 12.7656 18.8287 13.0592C18.535 13.3531 18.182 13.5 17.7695 13.5Z",
        fill: "currentColor",
      })
    ),
    more_vert: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12 19.2692C11.5875 19.2692 11.2344 19.1223 10.9408 18.8285C10.6469 18.5348 10.5 18.1817 10.5 17.7692C10.5 17.3567 10.6469 17.0035 10.9408 16.7097C11.2344 16.416 11.5875 16.2692 12 16.2692C12.4125 16.2692 12.7656 16.416 13.0592 16.7097C13.3531 17.0035 13.5 17.3567 13.5 17.7692C13.5 18.1817 13.3531 18.5348 13.0592 18.8285C12.7656 19.1223 12.4125 19.2692 12 19.2692ZM12 13.5C11.5875 13.5 11.2344 13.353 10.9408 13.0592C10.6469 12.7655 10.5 12.4125 10.5 12C10.5 11.5875 10.6469 11.2344 10.9408 10.9407C11.2344 10.6469 11.5875 10.5 12 10.5C12.4125 10.5 12.7656 10.6469 13.0592 10.9407C13.3531 11.2344 13.5 11.5875 13.5 12C13.5 12.4125 13.3531 12.7655 13.0592 13.0592C12.7656 13.353 12.4125 13.5 12 13.5ZM12 7.73071C11.5875 7.73071 11.2344 7.58388 10.9408 7.29021C10.6469 6.99638 10.5 6.64321 10.5 6.23071C10.5 5.81821 10.6469 5.46513 10.9408 5.17146C11.2344 4.87763 11.5875 4.73071 12 4.73071C12.4125 4.73071 12.7656 4.87763 13.0592 5.17146C13.3531 5.46513 13.5 5.81821 13.5 6.23071C13.5 6.64321 13.3531 6.99638 13.0592 7.29021C12.7656 7.58388 12.4125 7.73071 12 7.73071Z",
        fill: "currentColor",
      })
    ),
    close: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M6.39994 18.6538L5.34619 17.6L10.9462 12L5.34619 6.4L6.39994 5.34625L11.9999 10.9463L17.5999 5.34625L18.6537 6.4L13.0537 12L18.6537 17.6L17.5999 18.6538L11.9999 13.0538L6.39994 18.6538Z",
        fill: "currentColor",
      })
    ),
    settings: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.69225 21.5L9.3115 18.4538C9.04367 18.3641 8.769 18.2385 8.4875 18.077C8.20617 17.9153 7.95459 17.7422 7.73275 17.5577L4.9115 18.75L2.604 14.75L5.04425 12.9058C5.02125 12.7571 5.00492 12.6077 4.99525 12.4578C4.98559 12.3078 4.98075 12.1583 4.98075 12.0095C4.98075 11.8673 4.98559 11.7228 4.99525 11.576C5.00492 11.4292 5.02125 11.2686 5.04425 11.0943L2.604 9.25L4.9115 5.26925L7.723 6.452C7.96417 6.261 8.22159 6.08633 8.49525 5.928C8.76892 5.76967 9.03784 5.64242 9.302 5.54625L9.69225 2.5H14.3078L14.6885 5.55575C14.9885 5.66475 15.2599 5.792 15.5028 5.9375C15.7458 6.083 15.991 6.2545 16.2385 6.452L19.0885 5.26925L21.396 9.25L18.9173 11.123C18.9531 11.2845 18.9727 11.4355 18.976 11.576C18.9792 11.7163 18.9808 11.8577 18.9808 12C18.9808 12.1358 18.9775 12.274 18.971 12.4145C18.9647 12.5548 18.9417 12.7154 18.902 12.8963L21.3615 14.75L19.0538 18.75L16.2385 17.548C15.991 17.7455 15.7384 17.9202 15.4808 18.072C15.2231 18.224 14.959 18.3481 14.6885 18.4443L14.3078 21.5H9.69225ZM11 20H12.9655L13.325 17.3212C13.8353 17.1879 14.3017 16.9985 14.724 16.753C15.1465 16.5073 15.5539 16.1916 15.9463 15.8057L18.4308 16.85L19.4155 15.15L17.2463 13.5155C17.3296 13.2565 17.3863 13.0026 17.4163 12.7537C17.4464 12.5051 17.4615 12.2538 17.4615 12C17.4615 11.7397 17.4464 11.4884 17.4163 11.2463C17.3863 11.0039 17.3296 10.7564 17.2463 10.5038L19.4345 8.85L18.45 7.15L15.9365 8.2095C15.6018 7.85183 15.2009 7.53583 14.7338 7.2615C14.2664 6.98717 13.7937 6.79292 13.3155 6.67875L13 4H11.0155L10.6845 6.66925C10.1743 6.78975 9.70325 6.97433 9.27125 7.223C8.83909 7.47183 8.42684 7.79233 8.0345 8.1845L5.55 7.15L4.5655 8.85L6.725 10.4595C6.64167 10.6968 6.58334 10.9437 6.55 11.2C6.51667 11.4563 6.5 11.7262 6.5 12.0095C6.5 12.2698 6.51667 12.525 6.55 12.775C6.58334 13.025 6.6385 13.2718 6.7155 13.5155L4.5655 15.15L5.55 16.85L8.025 15.8C8.4045 16.1897 8.81025 16.5089 9.24225 16.7578C9.67442 17.0064 10.152 17.1974 10.675 17.3307L11 20ZM12.0115 15C12.8435 15 13.5515 14.708 14.1355 14.124C14.7195 13.54 15.0115 12.832 15.0115 12C15.0115 11.168 14.7195 10.46 14.1355 9.876C13.5515 9.292 12.8435 9 12.0115 9C11.1692 9 10.4586 9.292 9.87975 9.876C9.30092 10.46 9.0115 11.168 9.0115 12C9.0115 12.832 9.30092 13.54 9.87975 14.124C10.4586 14.708 11.1692 15 12.0115 15Z",
        fill: "currentColor",
      })
    ),
    delete_big: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
        fill: "currentColor",
      })
    ),
    delete_small: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
        fill: "currentColor",
      })
    ),
    format_align_center: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 20.5V19H20.5V20.5H3.5ZM7.5 16.625V15.125H16.5V16.625H7.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM7.5 8.875V7.375H16.5V8.875H7.5ZM3.5 5V3.5H20.5V5H3.5Z",
        fill: "currentColor",
      })
    ),
    format_align_left: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 20.5V19H20.5V20.5H3.5ZM3.5 16.625V15.125H14.5V16.625H3.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM3.5 8.875V7.375H14.5V8.875H3.5ZM3.5 5V3.5H20.5V5H3.5Z",
        fill: "currentColor",
      })
    ),
    format_align_right: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 5V3.5H20.5V5H3.5ZM9.5 8.875V7.375H20.5V8.875H9.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM9.5 16.625V15.125H20.5V16.625H9.5ZM3.5 20.5V19H20.5V20.5H3.5Z",
        fill: "currentColor",
      })
    ),
    add_row: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M4.025 10.2077C4.375 9.85775 4.80258 9.68275 5.30775 9.68275H6.5V11.1827H5.30775C5.21792 11.1827 5.14417 11.2116 5.0865 11.2693C5.02883 11.3269 5 11.4007 5 11.4905V16.1923C5 16.2821 5.02883 16.3558 5.0865 16.4135C5.14417 16.4712 5.21792 16.5 5.30775 16.5H18.6923C18.7821 16.5 18.8558 16.4712 18.9135 16.4135C18.9712 16.3558 19 16.2821 19 16.1923V11.4905C19 11.4007 18.9712 11.3269 18.9135 11.2693C18.8558 11.2116 18.7821 11.1827 18.6923 11.1827H17.6923V9.68275H18.6923C19.1974 9.68275 19.625 9.85775 19.975 10.2077C20.325 10.5577 20.5 10.9853 20.5 11.4905V16.1923C20.5 16.6974 20.325 17.125 19.975 17.475C19.625 17.825 19.1974 18 18.6923 18H5.30775C4.80258 18 4.375 17.825 4.025 17.475C3.675 17.125 3.5 16.6974 3.5 16.1923V11.4905C3.5 10.9853 3.675 10.5577 4.025 10.2077Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        d: "M11.3848 9.68275V7.5H12.8848V9.68275H15V11.1827H12.8848V13.2307H11.3848V11.1827H9.26925V9.68275H11.3848Z",
        fill: "currentColor",
      })
    ),
    add_column: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9.70775 4.025C9.35775 4.375 9.18275 4.80258 9.18275 5.30775V6.5H10.6827V5.30775C10.6827 5.21792 10.7116 5.14417 10.7693 5.0865C10.8269 5.02883 10.9007 5 10.9905 5H15.6923C15.7821 5 15.8558 5.02883 15.9135 5.0865C15.9712 5.14417 16 5.21792 16 5.30775V18.6923C16 18.7821 15.9712 18.8558 15.9135 18.9135C15.8558 18.9712 15.7821 19 15.6923 19H10.9905C10.9007 19 10.8269 18.9712 10.7693 18.9135C10.7116 18.8558 10.6827 18.7821 10.6827 18.6923V17.6923H9.18275V18.6923C9.18275 19.1974 9.35775 19.625 9.70775 19.975C10.0577 20.325 10.4853 20.5 10.9905 20.5H15.6923C16.1974 20.5 16.625 20.325 16.975 19.975C17.325 19.625 17.5 19.1974 17.5 18.6923V5.30775C17.5 4.80258 17.325 4.375 16.975 4.025C16.625 3.675 16.1974 3.5 15.6923 3.5H10.9905C10.4853 3.5 10.0577 3.675 9.70775 4.025Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        d: "M9.18275 11.3848H7V12.8848H9.18275V15H10.6827V12.8848H12.7307V11.3848H10.6827V9.26925H9.18275V11.3848Z",
        fill: "currentColor",
      })
    ),
    insert_col_left: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M13.0001 20.1152H8.67713H8.75388H8.69238H13.0001ZM7.19238 19.8075C7.19238 20.3127 7.36738 20.7402 7.71738 21.0902C8.06738 21.4402 8.49497 21.6152 9.00013 21.6152H12.6924C13.1975 21.6152 13.6251 21.4402 13.9751 21.0902C14.3251 20.7402 14.5001 20.3127 14.5001 19.8075V10.423H13.0001V19.8075C13.0001 19.8973 12.9713 19.9711 12.9136 20.0287C12.856 20.0864 12.7822 20.1152 12.6924 20.1152H9.00013C8.9103 20.1152 8.83655 20.0864 8.77888 20.0287C8.72122 19.9711 8.69238 19.8973 8.69238 19.8075V4.69223C8.26422 4.74357 7.90722 4.93299 7.62138 5.26048C7.33538 5.58798 7.19238 5.97548 7.19238 6.42298V19.8075ZM13.0001 2.49998V4.61523H10.8846V6.11523H13.0001V8.23073H14.5001V6.11523H16.6154V4.61523H14.5001V2.49998H13.0001Z",
        fill: "currentColor",
      })
    ),
    insert_row_above: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M20.1152 9.99987V14.3229V14.2461V14.3076V9.99987ZM19.8075 15.8076C20.3127 15.8076 20.7402 15.6326 21.0902 15.2826C21.4402 14.9326 21.6152 14.505 21.6152 13.9999V10.3076C21.6152 9.80245 21.4402 9.37487 21.0902 9.02487C20.7402 8.67487 20.3127 8.49987 19.8075 8.49987H10.423V9.99987H19.8075C19.8973 9.99987 19.9711 10.0287 20.0287 10.0864C20.0864 10.144 20.1152 10.2178 20.1152 10.3076V13.9999C20.1152 14.0897 20.0864 14.1635 20.0287 14.2211C19.9711 14.2788 19.8973 14.3076 19.8075 14.3076H4.69223C4.74357 14.7358 4.93299 15.0928 5.26048 15.3786C5.58798 15.6646 5.97548 15.8076 6.42298 15.8076H19.8075ZM2.49998 9.99987H4.61523V12.1154H6.11523V9.99987H8.23073V8.49987H6.11523V6.38462H4.61523V8.49987H2.49998V9.99987Z",
        fill: "currentColor",
      })
    ),
    insert_row_below: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M20.1152 14.1924V9.86939V9.94614V9.88464V14.1924ZM19.8075 8.38464C20.3127 8.38464 20.7402 8.55964 21.0902 8.90964C21.4402 9.25964 21.6152 9.68723 21.6152 10.1924V13.8846C21.6152 14.3898 21.4402 14.8174 21.0902 15.1674C20.7402 15.5174 20.3127 15.6924 19.8075 15.6924H10.423V14.1924H19.8075C19.8973 14.1924 19.9711 14.1636 20.0287 14.1059C20.0864 14.0482 20.1152 13.9745 20.1152 13.8846V10.1924C20.1152 10.1026 20.0864 10.0288 20.0287 9.97114C19.9711 9.91348 19.8973 9.88464 19.8075 9.88464H4.69223C4.74357 9.45648 4.93299 9.09948 5.26048 8.81364C5.58798 8.52764 5.97548 8.38464 6.42298 8.38464H19.8075ZM2.49998 14.1924H4.61523V12.0769H6.11523V14.1924H8.23073V15.6924H6.11523V17.8076H4.61523V15.6924H2.49998V14.1924Z",
        fill: "currentColor",
      })
    ),
    insert_col_right: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M10.8075 20.1152H15.1305H15.0537H15.1152H10.8075ZM16.6152 19.8075C16.6152 20.3127 16.4402 20.7402 16.0902 21.0902C15.7402 21.4402 15.3127 21.6152 14.8075 21.6152H11.1152C10.6101 21.6152 10.1825 21.4402 9.83248 21.0902C9.48248 20.7402 9.30748 20.3127 9.30748 19.8075V10.423H10.8075V19.8075C10.8075 19.8973 10.8363 19.9711 10.894 20.0287C10.9517 20.0864 11.0254 20.1152 11.1152 20.1152H14.8075C14.8973 20.1152 14.9711 20.0864 15.0287 20.0287C15.0864 19.9711 15.1152 19.8973 15.1152 19.8075V4.69223C15.5434 4.74357 15.9004 4.93299 16.1862 5.26048C16.4722 5.58798 16.6152 5.97548 16.6152 6.42298V19.8075ZM10.8075 2.49998V4.61523H12.923V6.11523H10.8075V8.23073H9.30748V6.11523H7.19223V4.61523H9.30748V2.49998H10.8075Z",
        fill: "currentColor",
      })
    ),
    check: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.54983 17.6537L4.21533 12.3192L5.28433 11.25L9.54983 15.5155L18.7153 6.34998L19.7843 7.41923L9.54983 17.6537Z",
        fill: "currentColor",
      })
    ),
  },
  AU = ({ children: t }) => {
    const e = yt(sr),
      n = C.useMemo(() => [e, IP(null, Xm)], [e]);
    return C.createElement(zd.Provider, { value: n }, t);
  },
  $U = () => {
    const t = lt(),
      [e, n, r, i, s] = nt(hp, ty, ny, ry, fp);
    return C.createElement(
      C.Fragment,
      null,
      r.map((o, a) => C.createElement(o, { key: a })),
      C.createElement(
        ZA,
        { wrappers: i },
        C.createElement(
          "div",
          { className: Ze(F.rootContentEditableWrapper, "mdxeditor-root-contenteditable") },
          C.createElement(uy, {
            contentEditable: C.createElement(ly, {
              className: Ze(F.contentEditable, e),
              ariaLabel: t("contentArea.editableMarkdown", "editable markdown"),
            }),
            placeholder: C.createElement("div", { className: Ze(F.contentEditable, F.placeholder, e) }, C.createElement("p", null, s)),
            ErrorBoundary: cy,
          })
        )
      ),
      n.map((o, a) => C.createElement(o, { key: a }))
    );
  },
  RU = { listItemIndent: "one" },
  IU = (t) => PU[t];
function NU(t, e, n = {}) {
  let r = e;
  for (const [i, s] of Object.entries(n)) r = r.replaceAll(`{{${i}}}`, String(s));
  return r;
}
const ZA = ({ wrappers: t, children: e }) => {
    if (t.length === 0) return C.createElement(C.Fragment, null, e);
    const n = t[0];
    return C.createElement(n, null, C.createElement(ZA, { wrappers: t.slice(1) }, e));
  },
  LU = ({ children: t, className: e }) => {
    const n = C.useRef(null),
      r = tt(si);
    return (
      C.useEffect(() => {
        const i = document.createElement("div");
        return (
          i.classList.add("mdxeditor-popup-container", F.editorRoot, F.popupContainer, ...(e ?? "").trim().split(" ").filter(Boolean)),
          document.body.appendChild(i),
          (n.current = i),
          r(n),
          () => {
            i.remove();
          }
        );
      }, [e, n, r]),
      C.createElement("div", { className: Ze("mdxeditor", F.editorRoot, F.editorWrapper, e) }, t)
    );
  },
  MU = ({ mdxRef: t }) => {
    const e = Fl();
    return (
      C.useImperativeHandle(
        t,
        () => ({
          getMarkdown: () => (e.getValue(to) === "source" ? e.getValue(Wo) : e.getValue(Gr)),
          setMarkdown: (n) => {
            e.pub(Gm, n);
          },
          insertMarkdown: (n) => {
            e.pub(Gb, n);
          },
          focus: (n, r) => {
            var i;
            (i = e.getValue(sr)) == null || i.focus(n, r);
          },
        }),
        [e]
      ),
      null
    );
  },
  DU = C.forwardRef((t, e) =>
    C.createElement(
      RP,
      {
        plugins: [
          BA({
            contentEditableClassName: t.contentEditableClassName ?? "",
            initialMarkdown: t.markdown,
            onChange: t.onChange ?? Zs,
            onBlur: t.onBlur ?? Zs,
            toMarkdownOptions: t.toMarkdownOptions ?? RU,
            autoFocus: t.autoFocus ?? !1,
            placeholder: t.placeholder ?? "",
            readOnly: !!t.readOnly,
            iconComponentFor: t.iconComponentFor ?? IU,
            suppressHtmlProcessing: t.suppressHtmlProcessing ?? !1,
            onError: t.onError ?? Zs,
            translation: t.translation ?? NU,
          }),
          ...(t.plugins ?? []),
        ],
      },
      C.createElement(LU, { className: t.className }, C.createElement(AU, null, C.createElement($U, null))),
      C.createElement(MU, { mdxRef: e })
    )
  ),
  QU = {
    testLexicalNode: Bm,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      const n = parseInt(t.getTag()[1], 10);
      e.addAndStepInto("heading", { depth: n });
    },
  },
  FU = {
    testNode: "heading",
    visitNode: function ({ mdastNode: t, actions: e }) {
      e.addAndStepInto(Si(`h${t.depth}`));
    },
  },
  VU = [48, 49, 50, 51, 52, 53, 54],
  hy = [1, 2, 3, 4, 5, 6],
  BU = { 49: 1, 50: 2, 51: 3, 52: 4, 53: 5, 54: 6 },
  Rh = Se(hy, (t) => {
    t.pub($h, (e) =>
      e.registerCommand(
        Kx,
        (n) => {
          const { keyCode: r, ctrlKey: i, metaKey: s, altKey: o } = n;
          return VU.includes(r) && Wb(s, i) && o
            ? (n.preventDefault(),
              e.update(() => {
                if (r === 48) t.pub(Tu, () => at());
                else {
                  const a = t.getValue(Rh),
                    l = BU[r];
                  a.includes(l) || t.pub(Tu, () => Si(`h${l}`));
                }
              }),
              !0)
            : !1;
        },
        Ot
      )
    );
  }),
  jU = en({
    init(t) {
      t.pubIn({ [ql]: "headings", [rr]: FU, [vr]: kh, [xr]: QU });
    },
    update(t, e) {
      t.pub(Rh, (e == null ? void 0 : e.allowedHeadingLevels) ?? hy);
    },
  });
function H2(t, e) {
  return t.getEditorState().read(() => {
    const n = vt(e);
    return n !== null && n.isSelected();
  });
}
function zA(t) {
  const [e] = jn(),
    [n, r] = w.useState(() => H2(e, t));
  return (
    w.useEffect(() => {
      let i = !0;
      const s = e.registerUpdateListener(() => {
        i && r(H2(e, t));
      });
      return () => {
        (i = !1), s();
      };
    }, [e, t]),
    [
      n,
      w.useCallback(
        (i) => {
          e.update(() => {
            let s = ce();
            Ht(s) || ((s = vO()), yn(s)), Ht(s) && (i ? s.add(t) : s.delete(t));
          });
        },
        [e, t]
      ),
      w.useCallback(() => {
        e.update(() => {
          const i = ce();
          Ht(i) && i.clear();
        });
      }, [e]),
    ]
  );
}
const WA = gs();
function ZU({ nodeKey: t }) {
  const [e] = jn(),
    [n, r, i] = zA(t),
    s = w.useCallback(
      (o) => {
        if (n && Ht(ce())) {
          o.preventDefault();
          const a = vt(t);
          if (fy(a)) return a.remove(), !0;
        }
        return !1;
      },
      [n, t]
    );
  return (
    w.useEffect(
      () =>
        ir(
          e.registerCommand(
            ym,
            (o) => {
              const a = e.getElementByKey(t);
              return o.target === a && (o.shiftKey || i(), r(!n), !0);
            },
            Ot
          ),
          e.registerCommand(km, s, Ot),
          e.registerCommand(gh, s, Ot)
        ),
      [i, e, n, t, s, r]
    ),
    w.useEffect(() => {
      const o = e.getElementByKey(t),
        a = "selected";
      o !== null && (n ? Yr(o, a) : Fm(o, a));
    }, [e, n, t]),
    null
  );
}
let Km = class UA extends Mi {
  static getType() {
    return "horizontalrule";
  }
  static clone(e) {
    return new UA(e.__key);
  }
  static importJSON(e) {
    return Ih();
  }
  static importDOM() {
    return { hr: () => ({ conversion: zU, priority: 0 }) };
  }
  exportJSON() {
    return { type: "horizontalrule", version: 1 };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM(e) {
    const n = document.createElement("hr");
    return Yr(n, e.theme.hr), n;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return E.jsx(ZU, { nodeKey: this.__key });
  }
};
function zU() {
  return { node: Ih() };
}
function Ih() {
  return Zn(new Km());
}
function fy(t) {
  return t instanceof Km;
}
function WU() {
  const [t] = jn();
  return (
    w.useEffect(
      () =>
        t.registerCommand(
          WA,
          (e) => {
            const n = ce();
            if (!ee(n)) return !1;
            if (n.focus.getNode() !== null) {
              const r = Ih();
              $3(r);
            }
            return !0;
          },
          Ue
        ),
      [t]
    ),
    null
  );
}
const UU = {
    testLexicalNode: fy,
    visitLexicalNode({ actions: t }) {
      t.addAndStepInto("thematicBreak");
    },
  },
  XU = {
    testNode: "thematicBreak",
    visitNode({ actions: t }) {
      t.addAndStepInto(Ih());
    },
  },
  dy = ni((t) => {
    t.sub(t.pipe(dy, bt(At)), ([, e]) => {
      e == null || e.dispatchCommand(WA, void 0);
    });
  }),
  HU = en({
    init(t) {
      t.pubIn({ [rr]: XU, [vr]: Km, [xr]: UU, [fo]: WU });
    },
  });
function qU(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var es = qU(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function IO(t) {
  let e = 1,
    n = t.getParent();
  for (; n != null; ) {
    if (et(n)) {
      const r = n.getParent();
      if (Le(r)) {
        e++, (n = r.getParent());
        continue;
      }
      es(40);
    }
    return e;
  }
  return e;
}
function NO(t) {
  let e = t.getParent();
  Le(e) || es(40);
  let n = e;
  for (; n !== null; ) (n = n.getParent()), Le(n) && (e = n);
  return e;
}
function XA(t) {
  let e = [];
  const n = t.getChildren().filter(et);
  for (let r = 0; r < n.length; r++) {
    const i = n[r],
      s = i.getFirstChild();
    Le(s) ? (e = e.concat(XA(s))) : e.push(i);
  }
  return e;
}
function vi(t) {
  return et(t) && Le(t.getFirstChild());
}
function q2(t) {
  return Pn().append(t);
}
function HA(t, e) {
  return et(t) && (e.length === 0 || (e.length === 1 && t.is(e[0]) && t.getChildrenSize() === 0));
}
function LO(t, e) {
  t.update(() => {
    const n = ce();
    if (n !== null) {
      const r = n.getNodes();
      if (ee(n)) {
        const s = n.getStartEndPoints();
        s === null && es(143);
        const [o] = s,
          a = o.getNode(),
          l = a.getParent();
        if (HA(a, r)) {
          const c = _n(e);
          if (rn(l)) {
            a.replace(c);
            const u = Pn();
            W(a) && (u.setFormat(a.getFormatType()), u.setIndent(a.getIndent())), c.append(u);
          } else if (et(a)) {
            const u = a.getParentOrThrow();
            Uo(c, u.getChildren()), u.replace(c);
          }
          return;
        }
      }
      const i = new Set();
      for (let s = 0; s < r.length; s++) {
        const o = r[s];
        if (!W(o) || !o.isEmpty() || et(o) || i.has(o.getKey())) {
          if (UP(o)) {
            let a = o.getParent();
            for (; a != null; ) {
              const l = a.getKey();
              if (Le(a)) {
                if (!i.has(l)) {
                  const c = _n(e);
                  Uo(c, a.getChildren()), a.replace(c), i.add(l);
                }
                break;
              }
              {
                const c = a.getParent();
                if (rn(c) && !i.has(l)) {
                  i.add(l), Y2(a, e);
                  break;
                }
                a = c;
              }
            }
          }
        } else Y2(o, e);
      }
    }
  });
}
function Uo(t, e) {
  t.splice(t.getChildrenSize(), 0, e);
}
function Y2(t, e) {
  if (Le(t)) return t;
  const n = t.getPreviousSibling(),
    r = t.getNextSibling(),
    i = Pn();
  if ((i.setFormat(t.getFormatType()), i.setIndent(t.getIndent()), Uo(i, t.getChildren()), Le(n) && e === n.getListType()))
    return n.append(i), t.remove(), Le(r) && e === r.getListType() && (Uo(n, r.getChildren()), r.remove()), n;
  if (Le(r) && e === r.getListType()) return r.getFirstChildOrThrow().insertBefore(i), t.remove(), r;
  {
    const s = _n(e);
    return s.append(i), t.replace(s), s;
  }
}
function py(t, e) {
  const n = t.getLastChild(),
    r = e.getFirstChild();
  n && r && vi(n) && vi(r) && (py(n.getFirstChild(), r.getFirstChild()), r.remove());
  const i = e.getChildren();
  i.length > 0 && t.append(...i), e.remove();
}
function YU(t) {
  t.update(() => {
    const e = ce();
    if (ee(e)) {
      const n = new Set(),
        r = e.getNodes(),
        i = e.anchor.getNode();
      if (HA(i, r)) n.add(NO(i));
      else
        for (let s = 0; s < r.length; s++) {
          const o = r[s];
          if (UP(o)) {
            const a = P3(o, po);
            a != null && n.add(NO(a));
          }
        }
      for (const s of n) {
        let o = s;
        const a = XA(s);
        for (const l of a) {
          const c = at();
          Uo(c, l.getChildren()),
            o.insertAfter(c),
            (o = c),
            l.__key === e.anchor.key && e.anchor.set(c.getKey(), 0, "element"),
            l.__key === e.focus.key && e.focus.set(c.getKey(), 0, "element"),
            l.remove();
        }
        s.remove();
      }
    }
  });
}
function GU(t) {
  const e = new Set();
  if (vi(t) || e.has(t.getKey())) return;
  const n = t.getParent(),
    r = t.getNextSibling(),
    i = t.getPreviousSibling();
  if (vi(r) && vi(i)) {
    const s = i.getFirstChild();
    if (Le(s)) {
      s.append(t);
      const o = r.getFirstChild();
      Le(o) && (Uo(s, o.getChildren()), r.remove(), e.add(r.getKey()));
    }
  } else if (vi(r)) {
    const s = r.getFirstChild();
    if (Le(s)) {
      const o = s.getFirstChild();
      o !== null && o.insertBefore(t);
    }
  } else if (vi(i)) {
    const s = i.getFirstChild();
    Le(s) && s.append(t);
  } else if (Le(n)) {
    const s = Pn(),
      o = _n(n.getListType());
    s.append(o), o.append(t), i ? i.insertAfter(s) : r ? r.insertBefore(s) : n.append(s);
  }
}
function JU(t) {
  if (vi(t)) return;
  const e = t.getParent(),
    n = e ? e.getParent() : void 0;
  if (Le(n ? n.getParent() : void 0) && et(n) && Le(e)) {
    const r = e ? e.getFirstChild() : void 0,
      i = e ? e.getLastChild() : void 0;
    if (t.is(r)) n.insertBefore(t), e.isEmpty() && n.remove();
    else if (t.is(i)) n.insertAfter(t), e.isEmpty() && n.remove();
    else {
      const s = e.getListType(),
        o = Pn(),
        a = _n(s);
      o.append(a), t.getPreviousSiblings().forEach((u) => a.append(u));
      const l = Pn(),
        c = _n(s);
      l.append(c), Uo(c, t.getNextSiblings()), n.insertBefore(o), n.insertAfter(l), n.replace(t);
    }
  }
}
function KU() {
  const t = ce();
  if (!ee(t) || !t.isCollapsed()) return !1;
  const e = t.anchor.getNode();
  if (!et(e) || e.getChildrenSize() !== 0) return !1;
  const n = NO(e),
    r = e.getParent();
  Le(r) || es(40);
  const i = r.getParent();
  let s;
  if (rn(i)) (s = at()), n.insertAfter(s);
  else {
    if (!et(i)) return !1;
    (s = Pn()), i.insertAfter(s);
  }
  s.select();
  const o = e.getNextSiblings();
  if (o.length > 0) {
    const a = _n(r.getListType());
    if (cs(s)) s.insertAfter(a);
    else {
      const l = Pn();
      l.append(a), s.insertAfter(l);
    }
    o.forEach((l) => {
      l.remove(), a.append(l);
    });
  }
  return (
    (function (a) {
      let l = a;
      for (; l.getNextSibling() == null && l.getPreviousSibling() == null; ) {
        const c = l.getParent();
        if (c == null || (!et(l) && !Le(l))) break;
        l = c;
      }
      l.remove();
    })(e),
    !0
  );
}
function gp(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
let po = class qA extends ii {
  static getType() {
    return "listitem";
  }
  static clone(e) {
    return new qA(e.__value, e.__checked, e.__key);
  }
  constructor(e, n, r) {
    super(r), (this.__value = e === void 0 ? 1 : e), (this.__checked = n);
  }
  createDOM(e) {
    const n = document.createElement("li"),
      r = this.getParent();
    return Le(r) && r.getListType() === "check" && J2(n, this, null), (n.value = this.__value), G2(n, e.theme, this), n;
  }
  updateDOM(e, n, r) {
    const i = this.getParent();
    return Le(i) && i.getListType() === "check" && J2(n, this, e), (n.value = this.__value), G2(n, r.theme, this), !1;
  }
  static transform() {
    return (e) => {
      if ((et(e) || es(144), e.__checked == null)) return;
      const n = e.getParent();
      Le(n) && n.getListType() !== "check" && e.getChecked() != null && e.setChecked(void 0);
    };
  }
  static importDOM() {
    return { li: () => ({ conversion: eX, priority: 0 }) };
  }
  static importJSON(e) {
    const n = Pn();
    return n.setChecked(e.checked), n.setValue(e.value), n.setFormat(e.format), n.setDirection(e.direction), n;
  }
  exportDOM(e) {
    const n = this.createDOM(e._config);
    return (n.style.textAlign = this.getFormatType()), { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), checked: this.getChecked(), type: "listitem", value: this.getValue(), version: 1 };
  }
  append(...e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (W(r) && this.canMergeWith(r)) {
        const i = r.getChildren();
        this.append(...i), r.remove();
      } else super.append(r);
    }
    return this;
  }
  replace(e, n) {
    if (et(e)) return super.replace(e);
    this.setIndent(0);
    const r = this.getParentOrThrow();
    if (!Le(r)) return e;
    if (r.__first === this.getKey()) r.insertBefore(e);
    else if (r.__last === this.getKey()) r.insertAfter(e);
    else {
      const i = _n(r.getListType());
      let s = this.getNextSibling();
      for (; s; ) {
        const o = s;
        (s = s.getNextSibling()), i.append(o);
      }
      r.insertAfter(e), e.insertAfter(i);
    }
    return (
      n &&
        (W(e) || es(139),
        this.getChildren().forEach((i) => {
          e.append(i);
        })),
      this.remove(),
      r.getChildrenSize() === 0 && r.remove(),
      e
    );
  }
  insertAfter(e, n = !0) {
    const r = this.getParentOrThrow();
    if ((Le(r) || es(39), et(e))) return super.insertAfter(e, n);
    const i = this.getNextSiblings();
    if ((r.insertAfter(e, n), i.length !== 0)) {
      const s = _n(r.getListType());
      i.forEach((o) => s.append(o)), e.insertAfter(s, n);
    }
    return e;
  }
  remove(e) {
    const n = this.getPreviousSibling(),
      r = this.getNextSibling();
    super.remove(e), n && r && vi(n) && vi(r) && (py(n.getFirstChild(), r.getFirstChild()), r.remove());
  }
  insertNewAfter(e, n = !0) {
    const r = Pn(this.__checked == null && void 0);
    return this.insertAfter(r, n), r;
  }
  collapseAtStart(e) {
    const n = at();
    this.getChildren().forEach((o) => n.append(o));
    const r = this.getParentOrThrow(),
      i = r.getParentOrThrow(),
      s = et(i);
    if (r.getChildrenSize() === 1)
      if (s) r.remove(), i.select();
      else {
        r.insertBefore(n), r.remove();
        const o = e.anchor,
          a = e.focus,
          l = n.getKey();
        o.type === "element" && o.getNode().is(this) && o.set(l, o.offset, "element"),
          a.type === "element" && a.getNode().is(this) && a.set(l, a.offset, "element");
      }
    else r.insertBefore(n), this.remove();
    return !0;
  }
  getValue() {
    return this.getLatest().__value;
  }
  setValue(e) {
    this.getWritable().__value = e;
  }
  getChecked() {
    return this.getLatest().__checked;
  }
  setChecked(e) {
    this.getWritable().__checked = e;
  }
  toggleChecked() {
    this.setChecked(!this.__checked);
  }
  getIndent() {
    const e = this.getParent();
    if (e === null) return this.getLatest().__indent;
    let n = e.getParentOrThrow(),
      r = 0;
    for (; et(n); ) (n = n.getParentOrThrow().getParentOrThrow()), r++;
    return r;
  }
  setIndent(e) {
    (typeof e == "number" && e > -1) || es(117);
    let n = this.getIndent();
    for (; n !== e; ) n < e ? (GU(this), n++) : (JU(this), n--);
    return this;
  }
  canInsertAfter(e) {
    return et(e);
  }
  canReplaceWith(e) {
    return et(e);
  }
  canMergeWith(e) {
    return cs(e) || et(e);
  }
  extractWithChild(e, n) {
    if (!ee(n)) return !1;
    const r = n.anchor.getNode(),
      i = n.focus.getNode();
    return this.isParentOf(r) && this.isParentOf(i) && this.getTextContent().length === n.getTextContent().length;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return _n("bullet");
  }
};
function G2(t, e, n) {
  const r = [],
    i = [],
    s = e.list,
    o = s ? s.listitem : void 0;
  let a;
  if ((s && s.nested && (a = s.nested.listitem), o !== void 0 && r.push(...gp(o)), s)) {
    const l = n.getParent(),
      c = Le(l) && l.getListType() === "check",
      u = n.getChecked();
    (c && !u) || i.push(s.listitemUnchecked),
      (c && u) || i.push(s.listitemChecked),
      c && r.push(u ? s.listitemChecked : s.listitemUnchecked);
  }
  if (a !== void 0) {
    const l = gp(a);
    n.getChildren().some((c) => Le(c)) ? r.push(...l) : i.push(...l);
  }
  i.length > 0 && Fm(t, ...i), r.length > 0 && Yr(t, ...r);
}
function J2(t, e, n, r) {
  Le(e.getFirstChild())
    ? (t.removeAttribute("role"), t.removeAttribute("tabIndex"), t.removeAttribute("aria-checked"))
    : (t.setAttribute("role", "checkbox"),
      t.setAttribute("tabIndex", "-1"),
      (n && e.__checked === n.__checked) || t.setAttribute("aria-checked", e.getChecked() ? "true" : "false"));
}
function eX(t) {
  if (t.classList.contains("task-list-item")) {
    for (const n of t.children) if (n.tagName === "INPUT") return tX(n);
  }
  const e = t.getAttribute("aria-checked");
  return { node: Pn(e === "true" || (e !== "false" && void 0)) };
}
function tX(t) {
  return t.getAttribute("type") !== "checkbox" ? { node: null } : { node: Pn(t.hasAttribute("checked")) };
}
function Pn(t) {
  return Zn(new po(void 0, t));
}
function et(t) {
  return t instanceof po;
}
let mo = class YA extends ii {
  static getType() {
    return "list";
  }
  static clone(e) {
    const n = e.__listType || tC[e.__tag];
    return new YA(n, e.__start, e.__key);
  }
  constructor(e, n, r) {
    super(r);
    const i = tC[e] || e;
    (this.__listType = i), (this.__tag = i === "number" ? "ol" : "ul"), (this.__start = n);
  }
  getTag() {
    return this.__tag;
  }
  setListType(e) {
    const n = this.getWritable();
    (n.__listType = e), (n.__tag = e === "number" ? "ol" : "ul");
  }
  getListType() {
    return this.__listType;
  }
  getStart() {
    return this.__start;
  }
  createDOM(e, n) {
    const r = this.__tag,
      i = document.createElement(r);
    return (
      this.__start !== 1 && i.setAttribute("start", String(this.__start)), (i.__lexicalListType = this.__listType), K2(i, e.theme, this), i
    );
  }
  updateDOM(e, n, r) {
    return e.__tag !== this.__tag || (K2(n, r.theme, this), !1);
  }
  static transform() {
    return (e) => {
      Le(e) || es(163),
        (function (n) {
          const r = n.getNextSibling();
          Le(r) && n.getListType() === r.getListType() && py(n, r);
        })(e),
        (function (n) {
          const r = n.getListType() !== "check";
          let i = n.getStart();
          for (const s of n.getChildren())
            et(s) &&
              (s.getValue() !== i && s.setValue(i), r && s.getChecked() != null && s.setChecked(void 0), Le(s.getFirstChild()) || i++);
        })(e);
    };
  }
  static importDOM() {
    return { ol: () => ({ conversion: eC, priority: 0 }), ul: () => ({ conversion: eC, priority: 0 }) };
  }
  static importJSON(e) {
    const n = _n(e.listType, e.start);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return (
      n &&
        qr(n) &&
        (this.__start !== 1 && n.setAttribute("start", String(this.__start)),
        this.__listType === "check" && n.setAttribute("__lexicalListType", "check")),
      { element: n }
    );
  }
  exportJSON() {
    return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
  append(...e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (et(r)) super.append(r);
      else {
        const i = Pn();
        if (Le(r)) i.append(r);
        else if (W(r)) {
          const s = Et(r.getTextContent());
          i.append(s);
        } else i.append(r);
        super.append(i);
      }
    }
    return this;
  }
  extractWithChild(e) {
    return et(e);
  }
};
function K2(t, e, n) {
  const r = [],
    i = [],
    s = e.list;
  if (s !== void 0) {
    const o = s[`${n.__tag}Depth`] || [],
      a = IO(n) - 1,
      l = a % o.length,
      c = o[l],
      u = s[n.__tag];
    let h;
    const f = s.nested,
      d = s.checklist;
    if (
      (f !== void 0 && f.list && (h = f.list),
      u !== void 0 && r.push(u),
      d !== void 0 && n.__listType === "check" && r.push(d),
      c !== void 0)
    ) {
      r.push(...gp(c));
      for (let p = 0; p < o.length; p++) p !== l && i.push(n.__tag + p);
    }
    if (h !== void 0) {
      const p = gp(h);
      a > 1 ? r.push(...p) : i.push(...p);
    }
  }
  i.length > 0 && Fm(t, ...i), r.length > 0 && Yr(t, ...r);
}
function nX(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (et(r)) {
      e.push(r);
      const i = r.getChildren();
      i.length > 1 &&
        i.forEach((s) => {
          Le(s) && e.push(q2(s));
        });
    } else e.push(q2(r));
  }
  return e;
}
function eC(t) {
  const e = t.nodeName.toLowerCase();
  let n = null;
  return (
    e === "ol"
      ? (n = _n("number", t.start))
      : e === "ul" &&
        (n = (function (r) {
          if (r.getAttribute("__lexicallisttype") === "check" || r.classList.contains("contains-task-list")) return !0;
          for (const i of r.childNodes) if (qr(i) && i.hasAttribute("aria-checked")) return !0;
          return !1;
        })(t)
          ? _n("check")
          : _n("bullet")),
    { after: nX, node: n }
  );
}
const tC = { ol: "number", ul: "bullet" };
function _n(t, e = 1) {
  return Zn(new mo(t, e));
}
function Le(t) {
  return t instanceof mo;
}
const GA = gs(),
  JA = gs(),
  KA = gs(),
  e$ = gs(),
  rX = {
    testNode: "list",
    visitNode: function ({ mdastNode: t, lexicalParent: e, actions: n }) {
      const r = t.children.some((s) => typeof s.checked == "boolean") ? "check" : t.ordered ? "number" : "bullet",
        i = _n(r);
      if (et(e)) {
        const s = Pn();
        s.append(i), e.insertAfter(s);
      } else e.append(i);
      n.visitChildren(t, i);
    },
  },
  iX = {
    testNode: "listItem",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      const r = n.getListType() === "check" ? t.checked ?? !1 : void 0;
      e.addAndStepInto(Pn(r));
    },
  },
  sX = {
    testLexicalNode: Le,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      e.addAndStepInto("list", { ordered: t.getListType() === "number", spread: !1 });
    },
  },
  oX = {
    testLexicalNode: et,
    visitLexicalNode: ({ lexicalNode: t, mdastParent: e, actions: n }) => {
      const r = t.getChildren(),
        i = r[0];
      if (r.length === 1 && Le(i)) {
        const s = e.children.at(-1);
        n.visitChildren(t, s);
      } else {
        const s = t.getParent(),
          o = n.appendToParent(e, {
            type: "listItem",
            checked: s.getListType() === "check" ? !!t.getChecked() : void 0,
            spread: !1,
            children: [{ type: "paragraph", children: [] }],
          });
        n.visitChildren(t, o.children[0]);
      }
    },
  };
function aX(t) {
  return t.registerCommand(
    rb,
    (e) => {
      const n = ce();
      if (!ee(n)) return !1;
      e.preventDefault();
      const r = (function (i) {
        const s = i.getNodes();
        if (tF(s, (h) => (np(h) && h.canIndent() ? h : null)).length > 0) return !0;
        const o = i.anchor,
          a = i.focus,
          l = a.isBefore(o) ? a : o,
          c = l.getNode(),
          u = A3(c);
        if (u.canIndent()) {
          const h = u.getKey();
          let f = Dm();
          if ((f.anchor.set(h, 0, "element"), f.focus.set(h, 0, "element"), (f = xb(f)), f.anchor.is(l))) return !0;
        }
        return !1;
      })(n)
        ? e.shiftKey
          ? tO
          : ib
        : MP;
      return t.dispatchCommand(r, void 0);
    },
    Ue
  );
}
function nC() {
  const [t] = jn();
  return w.useEffect(() => aX(t)), null;
}
function rC() {
  const [t] = jn();
  return (
    w.useEffect(() =>
      ir(
        t.registerCommand(KA, () => (LO(t, "check"), !0), Ot),
        t.registerCommand(nb, (e) => oC(e, t, !1), Ot),
        t.registerCommand(tb, (e) => oC(e, t, !0), Ot),
        t.registerCommand(
          Oh,
          (e) => {
            if (MO() != null) {
              const n = t.getRootElement();
              return n != null && n.focus(), !0;
            }
            return !1;
          },
          Ot
        ),
        t.registerCommand(
          LP,
          (e) => {
            const n = MO();
            return (
              !(n == null || !t.isEditable()) &&
              (t.update(() => {
                const r = Ai(n);
                et(r) && (e.preventDefault(), r.toggleChecked());
              }),
              !0)
            );
          },
          Ot
        ),
        t.registerCommand(
          eb,
          (e) =>
            t.getEditorState().read(() => {
              const n = ce();
              if (ee(n) && n.isCollapsed()) {
                const { anchor: r } = n,
                  i = r.type === "element";
                if (i || r.offset === 0) {
                  const s = r.getNode(),
                    o = Wl(s, (a) => W(a) && !a.isInline());
                  if (et(o)) {
                    const a = o.getParent();
                    if (Le(a) && a.getListType() === "check" && (i || o.getFirstDescendant() === s)) {
                      const l = t.getElementByKey(o.__key);
                      if (l != null && document.activeElement !== l) return l.focus(), e.preventDefault(), !0;
                    }
                  }
                }
              }
              return !1;
            }),
          Ot
        ),
        t.registerRootListener((e, n) => {
          e !== null && (e.addEventListener("click", iC), e.addEventListener("pointerdown", sC)),
            n !== null && (n.removeEventListener("click", iC), n.removeEventListener("pointerdown", sC));
        })
      )
    ),
    null
  );
}
function t$(t, e) {
  const n = t.target;
  if (n === null || !qr(n)) return;
  const r = n.firstChild;
  if (r != null && qr(r) && (r.tagName === "UL" || r.tagName === "OL")) return;
  const i = n.parentNode;
  if (!i || i.__lexicalListType !== "check") return;
  const s = n.getBoundingClientRect(),
    o = t.pageX / nF(n);
  (n.dir === "rtl" ? o < s.right && o > s.right - 20 : o > s.left && o < s.left + 20) && e();
}
function iC(t) {
  t$(t, () => {
    const e = t.target,
      n = (function (r) {
        let i = r;
        for (; i; ) {
          if (i.__lexicalEditor) return i.__lexicalEditor;
          i = i.parentNode;
        }
        return null;
      })(e);
    n != null &&
      n.isEditable() &&
      n.update(() => {
        if (t.target) {
          const r = Ai(e);
          et(r) && (e.focus(), r.toggleChecked());
        }
      });
  });
}
function sC(t) {
  t$(t, () => {
    t.preventDefault();
  });
}
function MO() {
  const t = document.activeElement;
  return t != null && t.tagName === "LI" && t.parentNode != null && t.parentNode.__lexicalListType === "check" ? t : null;
}
function oC(t, e, n) {
  const r = MO();
  return (
    r != null &&
      e.update(() => {
        const i = Ai(r);
        if (!et(i)) return;
        const s = (function (o, a) {
          let l = a ? o.getPreviousSibling() : o.getNextSibling(),
            c = o;
          for (; l == null && et(c); )
            (c = c.getParentOrThrow().getParent()), c != null && (l = a ? c.getPreviousSibling() : c.getNextSibling());
          for (; et(l); ) {
            const u = a ? l.getLastChild() : l.getFirstChild();
            if (!Le(u)) return l;
            l = a ? u.getLastChild() : u.getFirstChild();
          }
          return null;
        })(i, n);
        if (s != null) {
          s.selectStart();
          const o = e.getElementByKey(s.__key);
          o != null &&
            (t.preventDefault(),
            setTimeout(() => {
              o.focus();
            }, 0));
        }
      }),
    !1
  );
}
function aC() {
  const [t] = jn();
  return (
    w.useEffect(() => {
      if (!t.hasNodes([mo, po])) throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [t]),
    (function (e) {
      w.useEffect(
        () =>
          ir(
            e.registerCommand(JA, () => (LO(e, "number"), !0), Ot),
            e.registerCommand(GA, () => (LO(e, "bullet"), !0), Ot),
            e.registerCommand(e$, () => (YU(e), !0), Ot),
            e.registerCommand(xu, () => !!KU(), Ot)
          ),
        [e]
      );
    })(t),
    null
  );
}
const lX = { name: "tasklistCheck", tokenize: uX };
function cX() {
  return { text: { 91: lX } };
}
function uX(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return r.previous !== null || !r._gfmTasklistFirstContentOfListItem
      ? n(l)
      : (t.enter("taskListCheck"), t.enter("taskListCheckMarker"), t.consume(l), t.exit("taskListCheckMarker"), s);
  }
  function s(l) {
    return st(l)
      ? (t.enter("taskListCheckValueUnchecked"), t.consume(l), t.exit("taskListCheckValueUnchecked"), o)
      : l === 88 || l === 120
      ? (t.enter("taskListCheckValueChecked"), t.consume(l), t.exit("taskListCheckValueChecked"), o)
      : n(l);
  }
  function o(l) {
    return l === 93 ? (t.enter("taskListCheckMarker"), t.consume(l), t.exit("taskListCheckMarker"), t.exit("taskListCheck"), a) : n(l);
  }
  function a(l) {
    return de(l) ? e(l) : Re(l) ? t.check({ tokenize: hX }, e, n)(l) : n(l);
  }
}
function hX(t, e, n) {
  return Me(t, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : e(i);
  }
}
function fX() {
  return { exit: { taskListCheckValueChecked: lC, taskListCheckValueUnchecked: lC, paragraph: pX } };
}
function dX() {
  return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: mX } };
}
function lC(t) {
  const e = this.stack[this.stack.length - 2];
  e.type, (e.checked = t.type === "taskListCheckValueChecked");
}
function pX(t) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1,
        o;
      for (; ++s < i.length; ) {
        const a = i[s];
        if (a.type === "paragraph") {
          o = a;
          break;
        }
      }
      o === n &&
        ((r.value = r.value.slice(1)),
        r.value.length === 0
          ? n.children.shift()
          : n.position &&
            r.position &&
            typeof r.position.start.offset == "number" &&
            (r.position.start.column++, r.position.start.offset++, (n.position.start = Object.assign({}, r.position.start))));
    }
  }
  this.exit(t);
}
function mX(t, e, n, r) {
  const i = t.children[0],
    s = typeof t.checked == "boolean" && i && i.type === "paragraph",
    o = "[" + (t.checked ? "x" : " ") + "] ",
    a = n.createTracker(r);
  s && a.move(o);
  let l = Vb.listItem(t, e, n, { ...r, ...a.current() });
  return s && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + o;
  }
}
const gX = new Map([
    ["number", JA],
    ["bullet", GA],
    ["check", KA],
    ["", e$],
  ]),
  Op = Se("", (t) => {
    t.sub(t.pipe(Zo, bt(At)), ([e, n]) => {
      if (!e || !n) return;
      const r = e.anchor.getNode();
      let i =
        r.getKey() === "root"
          ? r
          : Wl(r, (a) => {
              const l = a.getParent();
              return l !== null && rn(l);
            });
      i === null && (i = r.getTopLevelElementOrThrow());
      const s = i.getKey();
      if (n.getElementByKey(s) !== null)
        if (Le(i)) {
          const a = P3(r, mo),
            l = a ? a.getListType() : i.getListType();
          t.pub(Op, l);
        } else t.pub(Op, "");
    });
  }),
  my = $t((t) => {
    t.sub(t.pipe(my, bt(At)), ([e, n]) => {
      n == null || n.dispatchCommand(gX.get(e), void 0);
    });
  }),
  OX = en({
    init(t) {
      var e;
      (e = t.getValue(sr)) == null || e.registerCommand(ib, () => !xX(7), Gn),
        t.pubIn({
          [ql]: "lists",
          [eo]: fX(),
          [Ks]: cX(),
          [rr]: [rX, iX],
          [vr]: [po, mo],
          [xr]: [sX, oX],
          [fa]: dX(),
          [fo]: [nC, aC, rC],
          [sy]: [nC, aC, rC],
        });
    },
  });
function vX(t) {
  const e = t.getNodes();
  return e.length === 0
    ? new Set([t.anchor.getNode().getParentOrThrow(), t.focus.getNode().getParentOrThrow()])
    : new Set(e.map((n) => (W(n) ? n : n.getParentOrThrow())));
}
function xX(t) {
  const e = ce();
  if (!ee(e)) return !1;
  const n = vX(e);
  let r = 0;
  for (const i of n)
    if (Le(i)) r = Math.max(IO(i) + 1, r);
    else if (et(i)) {
      const s = i.getParent();
      if ((s == null ? void 0 : s.getChildren().length) === 1) {
        const o = s.getParent();
        if (et(o) && o.getChildren().length === 1) return !1;
      }
      if (!Le(s)) throw new Error("ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.");
      r = Math.max(IO(s) + 1, r);
    }
  return r <= t;
}
function bX(t, e = {}) {
  const n = (e.align || []).concat(),
    r = e.stringLength || wX,
    i = [],
    s = [],
    o = [],
    a = [];
  let l = 0,
    c = -1;
  for (; ++c < t.length; ) {
    const p = [],
      m = [];
    let O = -1;
    for (t[c].length > l && (l = t[c].length); ++O < t[c].length; ) {
      const v = yX(t[c][O]);
      if (e.alignDelimiters !== !1) {
        const g = r(v);
        (m[O] = g), (a[O] === void 0 || g > a[O]) && (a[O] = g);
      }
      p.push(v);
    }
    (s[c] = p), (o[c] = m);
  }
  let u = -1;
  if (typeof n == "object" && "length" in n) for (; ++u < l; ) i[u] = cC(n[u]);
  else {
    const p = cC(n);
    for (; ++u < l; ) i[u] = p;
  }
  u = -1;
  const h = [],
    f = [];
  for (; ++u < l; ) {
    const p = i[u];
    let m = "",
      O = "";
    p === 99 ? ((m = ":"), (O = ":")) : p === 108 ? (m = ":") : p === 114 && (O = ":");
    let v = e.alignDelimiters === !1 ? 1 : Math.max(1, a[u] - m.length - O.length);
    const g = m + "-".repeat(v) + O;
    e.alignDelimiters !== !1 && ((v = m.length + v + O.length), v > a[u] && (a[u] = v), (f[u] = v)), (h[u] = g);
  }
  s.splice(1, 0, h), o.splice(1, 0, f), (c = -1);
  const d = [];
  for (; ++c < s.length; ) {
    const p = s[c],
      m = o[c];
    u = -1;
    const O = [];
    for (; ++u < l; ) {
      const v = p[u] || "";
      let g = "",
        x = "";
      if (e.alignDelimiters !== !1) {
        const y = a[u] - (m[u] || 0),
          S = i[u];
        S === 114
          ? (g = " ".repeat(y))
          : S === 99
          ? y % 2
            ? ((g = " ".repeat(y / 2 + 0.5)), (x = " ".repeat(y / 2 - 0.5)))
            : ((g = " ".repeat(y / 2)), (x = g))
          : (x = " ".repeat(y));
      }
      e.delimiterStart !== !1 && !u && O.push("|"),
        e.padding !== !1 && !(e.alignDelimiters === !1 && v === "") && (e.delimiterStart !== !1 || u) && O.push(" "),
        e.alignDelimiters !== !1 && O.push(g),
        O.push(v),
        e.alignDelimiters !== !1 && O.push(x),
        e.padding !== !1 && O.push(" "),
        (e.delimiterEnd !== !1 || u !== l - 1) && O.push("|");
    }
    d.push(e.delimiterEnd === !1 ? O.join("").replace(/ +$/, "") : O.join(""));
  }
  return d.join(`
`);
}
function yX(t) {
  return t == null ? "" : String(t);
}
function wX(t) {
  return t.length;
}
function cC(t) {
  const e = typeof t == "string" ? t.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function SX() {
  return {
    enter: { table: kX, tableData: uC, tableHeader: uC, tableRow: _X },
    exit: { codeText: EX, table: CX, tableData: g0, tableHeader: g0, tableRow: g0 },
  };
}
function kX(t) {
  const e = t._align;
  this.enter(
    {
      type: "table",
      align: e.map(function (n) {
        return n === "none" ? null : n;
      }),
      children: [],
    },
    t
  ),
    (this.data.inTable = !0);
}
function CX(t) {
  this.exit(t), (this.data.inTable = void 0);
}
function _X(t) {
  this.enter({ type: "tableRow", children: [] }, t);
}
function g0(t) {
  this.exit(t);
}
function uC(t) {
  this.enter({ type: "tableCell", children: [] }, t);
}
function EX(t) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, TX));
  const n = this.stack[this.stack.length - 1];
  n.type, (n.value = e), this.exit(t);
}
function TX(t, e) {
  return e === "|" ? e : t;
}
function PX(t) {
  const e = t || {},
    n = e.tableCellPadding,
    r = e.tablePipeAlign,
    i = e.stringLength,
    s = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      {
        character: `
`,
        inConstruct: "tableCell",
      },
      { atBreak: !0, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: !0, character: ":", after: "-" },
      { atBreak: !0, character: "-", after: "[:|-]" },
    ],
    handlers: { inlineCode: f, table: o, tableCell: l, tableRow: a },
  };
  function o(d, p, m, O) {
    return c(u(d, m, O), d.align);
  }
  function a(d, p, m, O) {
    const v = h(d, m, O),
      g = c([v]);
    return g.slice(
      0,
      g.indexOf(`
`)
    );
  }
  function l(d, p, m, O) {
    const v = m.enter("tableCell"),
      g = m.enter("phrasing"),
      x = m.containerPhrasing(d, { ...O, before: s, after: s });
    return g(), v(), x;
  }
  function c(d, p) {
    return bX(d, { align: p, alignDelimiters: r, padding: n, stringLength: i });
  }
  function u(d, p, m) {
    const O = d.children;
    let v = -1;
    const g = [],
      x = p.enter("table");
    for (; ++v < O.length; ) g[v] = h(O[v], p, m);
    return x(), g;
  }
  function h(d, p, m) {
    const O = d.children;
    let v = -1;
    const g = [],
      x = p.enter("tableRow");
    for (; ++v < O.length; ) g[v] = l(O[v], d, p, m);
    return x(), g;
  }
  function f(d, p, m) {
    let O = Vb.inlineCode(d, p, m);
    return m.stack.includes("tableCell") && (O = O.replace(/\|/g, "\\$&")), O;
  }
}
class AX {
  constructor() {
    this.map = [];
  }
  add(e, n, r) {
    $X(this, e, n, r);
  }
  consume(e) {
    if (
      (this.map.sort(function (s, o) {
        return s[0] - o[0];
      }),
      this.map.length === 0)
    )
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; ) (n -= 1), r.push(e.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), (e.length = this.map[n][0]);
    r.push([...e]), (e.length = 0);
    let i = r.pop();
    for (; i; ) e.push(...i), (i = r.pop());
    this.map.length = 0;
  }
}
function $X(t, e, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < t.map.length; ) {
      if (t.map[i][0] === e) {
        (t.map[i][1] += n), t.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    t.map.push([e, n, r]);
  }
}
function RX(t, e) {
  let n = !1;
  const r = [];
  for (; e < t.length; ) {
    const i = t[e];
    if (n) {
      if (i[0] === "enter") i[1].type === "tableContent" && r.push(t[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (t[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow") break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    e += 1;
  }
  return r;
}
function IX() {
  return { flow: { null: { name: "table", tokenize: NX, resolveAll: LX } } };
}
function NX(t, e, n) {
  const r = this;
  let i = 0,
    s = 0,
    o;
  return a;
  function a(P) {
    let M = r.events.length - 1;
    for (; M > -1; ) {
      const Q = r.events[M][1].type;
      if (Q === "lineEnding" || Q === "linePrefix") M--;
      else break;
    }
    const D = M > -1 ? r.events[M][1].type : null,
      V = D === "tableHead" || D === "tableRow" ? k : l;
    return V === k && r.parser.lazy[r.now().line] ? n(P) : V(P);
  }
  function l(P) {
    return t.enter("tableHead"), t.enter("tableRow"), c(P);
  }
  function c(P) {
    return P === 124 || ((o = !0), (s += 1)), u(P);
  }
  function u(P) {
    return P === null
      ? n(P)
      : de(P)
      ? s > 1
        ? ((s = 0), (r.interrupt = !0), t.exit("tableRow"), t.enter("lineEnding"), t.consume(P), t.exit("lineEnding"), d)
        : n(P)
      : Re(P)
      ? Me(t, u, "whitespace")(P)
      : ((s += 1),
        o && ((o = !1), (i += 1)),
        P === 124 ? (t.enter("tableCellDivider"), t.consume(P), t.exit("tableCellDivider"), (o = !0), u) : (t.enter("data"), h(P)));
  }
  function h(P) {
    return P === null || P === 124 || st(P) ? (t.exit("data"), u(P)) : (t.consume(P), P === 92 ? f : h);
  }
  function f(P) {
    return P === 92 || P === 124 ? (t.consume(P), h) : h(P);
  }
  function d(P) {
    return (
      (r.interrupt = !1),
      r.parser.lazy[r.now().line]
        ? n(P)
        : (t.enter("tableDelimiterRow"),
          (o = !1),
          Re(P) ? Me(t, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(P) : p(P))
    );
  }
  function p(P) {
    return P === 45 || P === 58
      ? O(P)
      : P === 124
      ? ((o = !0), t.enter("tableCellDivider"), t.consume(P), t.exit("tableCellDivider"), m)
      : S(P);
  }
  function m(P) {
    return Re(P) ? Me(t, O, "whitespace")(P) : O(P);
  }
  function O(P) {
    return P === 58
      ? ((s += 1), (o = !0), t.enter("tableDelimiterMarker"), t.consume(P), t.exit("tableDelimiterMarker"), v)
      : P === 45
      ? ((s += 1), v(P))
      : P === null || de(P)
      ? y(P)
      : S(P);
  }
  function v(P) {
    return P === 45 ? (t.enter("tableDelimiterFiller"), g(P)) : S(P);
  }
  function g(P) {
    return P === 45
      ? (t.consume(P), g)
      : P === 58
      ? ((o = !0), t.exit("tableDelimiterFiller"), t.enter("tableDelimiterMarker"), t.consume(P), t.exit("tableDelimiterMarker"), x)
      : (t.exit("tableDelimiterFiller"), x(P));
  }
  function x(P) {
    return Re(P) ? Me(t, y, "whitespace")(P) : y(P);
  }
  function y(P) {
    return P === 124
      ? p(P)
      : P === null || de(P)
      ? !o || i !== s
        ? S(P)
        : (t.exit("tableDelimiterRow"), t.exit("tableHead"), e(P))
      : S(P);
  }
  function S(P) {
    return n(P);
  }
  function k(P) {
    return t.enter("tableRow"), b(P);
  }
  function b(P) {
    return P === 124
      ? (t.enter("tableCellDivider"), t.consume(P), t.exit("tableCellDivider"), b)
      : P === null || de(P)
      ? (t.exit("tableRow"), e(P))
      : Re(P)
      ? Me(t, b, "whitespace")(P)
      : (t.enter("data"), _(P));
  }
  function _(P) {
    return P === null || P === 124 || st(P) ? (t.exit("data"), b(P)) : (t.consume(P), P === 92 ? T : _);
  }
  function T(P) {
    return P === 92 || P === 124 ? (t.consume(P), _) : _(P);
  }
}
function LX(t, e) {
  let n = -1,
    r = !0,
    i = 0,
    s = [0, 0, 0, 0],
    o = [0, 0, 0, 0],
    a = !1,
    l = 0,
    c,
    u,
    h;
  const f = new AX();
  for (; ++n < t.length; ) {
    const d = t[n],
      p = d[1];
    d[0] === "enter"
      ? p.type === "tableHead"
        ? ((a = !1),
          l !== 0 && (hC(f, e, l, c, u), (u = void 0), (l = 0)),
          (c = { type: "table", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }),
          f.add(n, 0, [["enter", c, e]]))
        : p.type === "tableRow" || p.type === "tableDelimiterRow"
        ? ((r = !0),
          (h = void 0),
          (s = [0, 0, 0, 0]),
          (o = [0, n + 1, 0, 0]),
          a &&
            ((a = !1),
            (u = { type: "tableBody", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }),
            f.add(n, 0, [["enter", u, e]])),
          (i = p.type === "tableDelimiterRow" ? 2 : u ? 3 : 1))
        : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller")
        ? ((r = !1), o[2] === 0 && (s[1] !== 0 && ((o[0] = o[1]), (h = Sf(f, e, s, i, void 0, h)), (s = [0, 0, 0, 0])), (o[2] = n)))
        : p.type === "tableCellDivider" &&
          (r ? (r = !1) : (s[1] !== 0 && ((o[0] = o[1]), (h = Sf(f, e, s, i, void 0, h))), (s = o), (o = [s[1], n, 0, 0])))
      : p.type === "tableHead"
      ? ((a = !0), (l = n))
      : p.type === "tableRow" || p.type === "tableDelimiterRow"
      ? ((l = n), s[1] !== 0 ? ((o[0] = o[1]), (h = Sf(f, e, s, i, n, h))) : o[1] !== 0 && (h = Sf(f, e, o, i, n, h)), (i = 0))
      : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") && (o[3] = n);
  }
  for (l !== 0 && hC(f, e, l, c, u), f.consume(e.events), n = -1; ++n < e.events.length; ) {
    const d = e.events[n];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = RX(e.events, n));
  }
  return t;
}
function Sf(t, e, n, r, i, s) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData",
    a = "tableContent";
  n[0] !== 0 && ((s.end = Object.assign({}, Ra(e.events, n[0]))), t.add(n[0], 0, [["exit", s, e]]));
  const l = Ra(e.events, n[1]);
  if (((s = { type: o, start: Object.assign({}, l), end: Object.assign({}, l) }), t.add(n[1], 0, [["enter", s, e]]), n[2] !== 0)) {
    const c = Ra(e.events, n[2]),
      u = Ra(e.events, n[3]),
      h = { type: a, start: Object.assign({}, c), end: Object.assign({}, u) };
    if ((t.add(n[2], 0, [["enter", h, e]]), r !== 2)) {
      const f = e.events[n[2]],
        d = e.events[n[3]];
      if (((f[1].end = Object.assign({}, d[1].end)), (f[1].type = "chunkText"), (f[1].contentType = "text"), n[3] > n[2] + 1)) {
        const p = n[2] + 1,
          m = n[3] - n[2] - 1;
        t.add(p, m, []);
      }
    }
    t.add(n[3] + 1, 0, [["exit", h, e]]);
  }
  return i !== void 0 && ((s.end = Object.assign({}, Ra(e.events, i))), t.add(i, 0, [["exit", s, e]]), (s = void 0)), s;
}
function hC(t, e, n, r, i) {
  const s = [],
    o = Ra(e.events, n);
  i && ((i.end = Object.assign({}, o)), s.push(["exit", i, e])), (r.end = Object.assign({}, o)), s.push(["exit", r, e]), t.add(n + 1, 0, s);
}
function Ra(t, e) {
  const n = t[e],
    r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const fC = [
    ["Cat", "rgb(125, 50, 0)"],
    ["Dog", "rgb(100, 0, 0)"],
    ["Rabbit", "rgb(150, 0, 0)"],
    ["Frog", "rgb(200, 0, 0)"],
    ["Fox", "rgb(200, 75, 0)"],
    ["Hedgehog", "rgb(0, 75, 0)"],
    ["Pigeon", "rgb(0, 125, 0)"],
    ["Squirrel", "rgb(75, 100, 0)"],
    ["Bear", "rgb(125, 100, 0)"],
    ["Tiger", "rgb(0, 0, 150)"],
    ["Leopard", "rgb(0, 0, 200)"],
    ["Zebra", "rgb(0, 0, 250)"],
    ["Wolf", "rgb(0, 100, 150)"],
    ["Owl", "rgb(0, 100, 100)"],
    ["Gull", "rgb(100, 0, 100)"],
    ["Squid", "rgb(150, 0, 150)"],
  ],
  dC = fC[Math.floor(Math.random() * fC.length)],
  MX = w.createContext({ clientID: 0, color: dC[1], isCollabActive: !1, name: dC[0], yjsDocMap: new Map() });
function DX(t, e) {
  const n = w.useContext(MX);
  return t != null && (n.name = t), e != null && (n.color = e), n;
}
function QX(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var FX = QX(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function pC(t) {
  const e = t.transform();
  return e !== null ? new Set([e]) : new Set();
}
function n$({ initialEditor: t, children: e, initialNodes: n, initialTheme: r, skipCollabChecks: i }) {
  const s = w.useRef(!1),
    o = w.useContext(zd);
  o == null && FX(9);
  const [a, { getTheme: l }] = o,
    c = w.useMemo(() => {
      const d = r || l() || void 0,
        p = IP(o, d);
      if ((d !== void 0 && (t._config.theme = d), (t._parentEditor = a), n))
        for (let m of n) {
          let O = null,
            v = null;
          if (typeof m != "function") {
            const x = m;
            (m = x.replace), (O = x.with), (v = x.withKlass || null);
          }
          const g = t._nodes.get(m.getType());
          t._nodes.set(m.getType(), { exportDOM: g ? g.exportDOM : void 0, klass: m, replace: O, replaceWithKlass: v, transforms: pC(m) });
        }
      else {
        const m = (t._nodes = new Map(a._nodes));
        for (const [O, v] of m)
          t._nodes.set(O, {
            exportDOM: v.exportDOM,
            klass: v.klass,
            replace: v.replace,
            replaceWithKlass: v.replaceWithKlass,
            transforms: pC(v.klass),
          });
      }
      return (t._config.namespace = a._config.namespace), (t._editable = a._editable), [t, p];
    }, []),
    { isCollabActive: u, yjsDocMap: h } = DX(),
    f = i || s.current || h.has(t.getKey());
  return (
    w.useEffect(() => {
      f && (s.current = !0);
    }, [f]),
    w.useEffect(
      () =>
        a.registerEditableListener((d) => {
          t.setEditable(d);
        }),
      [t, a]
    ),
    E.jsx(zd.Provider, { value: c, children: !u || f ? e : null })
  );
}
function Ye(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (i) {
    if ((t == null || t(i), n === !1 || !i.defaultPrevented)) return e == null ? void 0 : e(i);
  };
}
function da(t, e = []) {
  let n = [];
  function r(s, o) {
    const a = w.createContext(o),
      l = n.length;
    n = [...n, o];
    function c(h) {
      const { scope: f, children: d, ...p } = h,
        m = (f == null ? void 0 : f[t][l]) || a,
        O = w.useMemo(() => p, Object.values(p));
      return E.jsx(m.Provider, { value: O, children: d });
    }
    function u(h, f) {
      const d = (f == null ? void 0 : f[t][l]) || a,
        p = w.useContext(d);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${h}\` must be used within \`${s}\``);
    }
    return (c.displayName = s + "Provider"), [c, u];
  }
  const i = () => {
    const s = n.map((o) => w.createContext(o));
    return function (a) {
      const l = (a == null ? void 0 : a[t]) || s;
      return w.useMemo(() => ({ [`__scope${t}`]: { ...a, [t]: l } }), [a, l]);
    };
  };
  return (i.scopeName = t), [r, VX(i, ...e)];
}
function VX(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((i) => ({ useScope: i(), scopeName: i.scopeName }));
    return function (s) {
      const o = r.reduce((a, { useScope: l, scopeName: c }) => {
        const h = l(s)[`__scope${c}`];
        return { ...a, ...h };
      }, {});
      return w.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return (n.scopeName = e.scopeName), n;
}
function BX(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function r$(...t) {
  return (e) => t.forEach((n) => BX(n, e));
}
function mC(...t) {
  return w.useCallback(r$(...t), t);
}
var DO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(ZX);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(QO, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(QO, { ...r, ref: e, children: n });
});
DO.displayName = "Slot";
var QO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = WX(n);
    return w.cloneElement(n, { ...zX(r, n.props), ref: e ? r$(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
QO.displayName = "SlotClone";
var jX = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function ZX(t) {
  return w.isValidElement(t) && t.type === jX;
}
function zX(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function WX(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
function i$(t) {
  const e = t + "CollectionProvider",
    [n, r] = da(e),
    [i, s] = n(e, { collectionRef: { current: null }, itemMap: new Map() }),
    o = (d) => {
      const { scope: p, children: m } = d,
        O = C.useRef(null),
        v = C.useRef(new Map()).current;
      return E.jsx(i, { scope: p, itemMap: v, collectionRef: O, children: m });
    };
  o.displayName = e;
  const a = t + "CollectionSlot",
    l = C.forwardRef((d, p) => {
      const { scope: m, children: O } = d,
        v = s(a, m),
        g = mC(p, v.collectionRef);
      return E.jsx(DO, { ref: g, children: O });
    });
  l.displayName = a;
  const c = t + "CollectionItemSlot",
    u = "data-radix-collection-item",
    h = C.forwardRef((d, p) => {
      const { scope: m, children: O, ...v } = d,
        g = C.useRef(null),
        x = mC(p, g),
        y = s(c, m);
      return (
        C.useEffect(() => (y.itemMap.set(g, { ref: g, ...v }), () => void y.itemMap.delete(g))), E.jsx(DO, { [u]: "", ref: x, children: O })
      );
    });
  h.displayName = c;
  function f(d) {
    const p = s(t + "CollectionConsumer", d);
    return C.useCallback(() => {
      const O = p.collectionRef.current;
      if (!O) return [];
      const v = Array.from(O.querySelectorAll(`[${u}]`));
      return Array.from(p.itemMap.values()).sort((y, S) => v.indexOf(y.ref.current) - v.indexOf(S.ref.current));
    }, [p.collectionRef, p.itemMap]);
  }
  return [{ Provider: o, Slot: l, ItemSlot: h }, f, r];
}
function UX(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function s$(...t) {
  return (e) => t.forEach((n) => UX(n, e));
}
function XX(...t) {
  return w.useCallback(s$(...t), t);
}
var o$ = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(qX);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(FO, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(FO, { ...r, ref: e, children: n });
});
o$.displayName = "Slot";
var FO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = GX(n);
    return w.cloneElement(n, { ...YX(r, n.props), ref: e ? s$(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
FO.displayName = "SlotClone";
var HX = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function qX(t) {
  return w.isValidElement(t) && t.type === HX;
}
function YX(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function GX(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var JX = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  a$ = JX.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? o$ : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {}),
  KX = w.createContext(void 0);
function eg(t) {
  const e = w.useContext(KX);
  return t || e || "ltr";
}
var O0 = "rovingFocusGroup.onEntryFocus",
  eH = { bubbles: !1, cancelable: !0 },
  tg = "RovingFocusGroup",
  [VO, l$, tH] = i$(tg),
  [nH, ng] = da(tg, [tH]),
  [rH, iH] = nH(tg),
  c$ = w.forwardRef((t, e) =>
    E.jsx(VO.Provider, {
      scope: t.__scopeRovingFocusGroup,
      children: E.jsx(VO.Slot, { scope: t.__scopeRovingFocusGroup, children: E.jsx(sH, { ...t, ref: e }) }),
    })
  );
c$.displayName = tg;
var sH = w.forwardRef((t, e) => {
    const {
        __scopeRovingFocusGroup: n,
        orientation: r,
        loop: i = !1,
        dir: s,
        currentTabStopId: o,
        defaultCurrentTabStopId: a,
        onCurrentTabStopIdChange: l,
        onEntryFocus: c,
        preventScrollOnEntryFocus: u = !1,
        ...h
      } = t,
      f = w.useRef(null),
      d = XX(e, f),
      p = eg(s),
      [m = null, O] = Vo({ prop: o, defaultProp: a, onChange: l }),
      [v, g] = w.useState(!1),
      x = as(c),
      y = l$(n),
      S = w.useRef(!1),
      [k, b] = w.useState(0);
    return (
      w.useEffect(() => {
        const _ = f.current;
        if (_) return _.addEventListener(O0, x), () => _.removeEventListener(O0, x);
      }, [x]),
      E.jsx(rH, {
        scope: n,
        orientation: r,
        dir: p,
        loop: i,
        currentTabStopId: m,
        onItemFocus: w.useCallback((_) => O(_), [O]),
        onItemShiftTab: w.useCallback(() => g(!0), []),
        onFocusableItemAdd: w.useCallback(() => b((_) => _ + 1), []),
        onFocusableItemRemove: w.useCallback(() => b((_) => _ - 1), []),
        children: E.jsx(a$.div, {
          tabIndex: v || k === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: d,
          style: { outline: "none", ...t.style },
          onMouseDown: Ye(t.onMouseDown, () => {
            S.current = !0;
          }),
          onFocus: Ye(t.onFocus, (_) => {
            const T = !S.current;
            if (_.target === _.currentTarget && T && !v) {
              const P = new CustomEvent(O0, eH);
              if ((_.currentTarget.dispatchEvent(P), !P.defaultPrevented)) {
                const M = y().filter((G) => G.focusable),
                  D = M.find((G) => G.active),
                  V = M.find((G) => G.id === m),
                  N = [D, V, ...M].filter(Boolean).map((G) => G.ref.current);
                f$(N, u);
              }
            }
            S.current = !1;
          }),
          onBlur: Ye(t.onBlur, () => g(!1)),
        }),
      })
    );
  }),
  u$ = "RovingFocusGroupItem",
  h$ = w.forwardRef((t, e) => {
    const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: s, ...o } = t,
      a = ph(),
      l = s || a,
      c = iH(u$, n),
      u = c.currentTabStopId === l,
      h = l$(n),
      { onFocusableItemAdd: f, onFocusableItemRemove: d } = c;
    return (
      w.useEffect(() => {
        if (r) return f(), () => d();
      }, [r, f, d]),
      E.jsx(VO.ItemSlot, {
        scope: n,
        id: l,
        focusable: r,
        active: i,
        children: E.jsx(a$.span, {
          tabIndex: u ? 0 : -1,
          "data-orientation": c.orientation,
          ...o,
          ref: e,
          onMouseDown: Ye(t.onMouseDown, (p) => {
            r ? c.onItemFocus(l) : p.preventDefault();
          }),
          onFocus: Ye(t.onFocus, () => c.onItemFocus(l)),
          onKeyDown: Ye(t.onKeyDown, (p) => {
            if (p.key === "Tab" && p.shiftKey) {
              c.onItemShiftTab();
              return;
            }
            if (p.target !== p.currentTarget) return;
            const m = lH(p, c.orientation, c.dir);
            if (m !== void 0) {
              if (p.metaKey || p.ctrlKey || p.altKey || p.shiftKey) return;
              p.preventDefault();
              let v = h()
                .filter((g) => g.focusable)
                .map((g) => g.ref.current);
              if (m === "last") v.reverse();
              else if (m === "prev" || m === "next") {
                m === "prev" && v.reverse();
                const g = v.indexOf(p.currentTarget);
                v = c.loop ? cH(v, g + 1) : v.slice(g + 1);
              }
              setTimeout(() => f$(v));
            }
          }),
        }),
      })
    );
  });
h$.displayName = u$;
var oH = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last",
};
function aH(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function lH(t, e, n) {
  const r = aH(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return oH[r];
}
function f$(t, e = !1) {
  const n = document.activeElement;
  for (const r of t) if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function cH(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var d$ = c$,
  gy = h$;
function uH(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function hH(...t) {
  return (e) => t.forEach((n) => uH(n, e));
}
var p$ = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(dH);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(BO, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(BO, { ...r, ref: e, children: n });
});
p$.displayName = "Slot";
var BO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = mH(n);
    return w.cloneElement(n, { ...pH(r, n.props), ref: e ? hH(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
BO.displayName = "SlotClone";
var fH = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function dH(t) {
  return w.isValidElement(t) && t.type === fH;
}
function pH(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function mH(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var gH = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  Oy = gH.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? p$ : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function OH(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function vH(...t) {
  return (e) => t.forEach((n) => OH(n, e));
}
var m$ = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(bH);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(jO, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(jO, { ...r, ref: e, children: n });
});
m$.displayName = "Slot";
var jO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = wH(n);
    return w.cloneElement(n, { ...yH(r, n.props), ref: e ? vH(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
jO.displayName = "SlotClone";
var xH = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function bH(t) {
  return w.isValidElement(t) && t.type === xH;
}
function yH(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function wH(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var SH = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  kH = SH.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? m$ : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {}),
  CH = "Separator",
  gC = "horizontal",
  _H = ["horizontal", "vertical"],
  g$ = w.forwardRef((t, e) => {
    const { decorative: n, orientation: r = gC, ...i } = t,
      s = EH(r) ? r : gC,
      a = n ? { role: "none" } : { "aria-orientation": s === "vertical" ? s : void 0, role: "separator" };
    return E.jsx(kH.div, { "data-orientation": s, ...a, ...i, ref: e });
  });
g$.displayName = CH;
function EH(t) {
  return _H.includes(t);
}
var TH = g$;
function PH(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function AH(...t) {
  return (e) => t.forEach((n) => PH(n, e));
}
var O$ = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(RH);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(ZO, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(ZO, { ...r, ref: e, children: n });
});
O$.displayName = "Slot";
var ZO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = NH(n);
    return w.cloneElement(n, { ...IH(r, n.props), ref: e ? AH(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
ZO.displayName = "SlotClone";
var $H = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function RH(t) {
  return w.isValidElement(t) && t.type === $H;
}
function IH(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function NH(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var LH = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  OC = LH.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? O$ : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function MH(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function DH(...t) {
  return (e) => t.forEach((n) => MH(n, e));
}
var v$ = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(FH);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(zO, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(zO, { ...r, ref: e, children: n });
});
v$.displayName = "Slot";
var zO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = BH(n);
    return w.cloneElement(n, { ...VH(r, n.props), ref: e ? DH(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
zO.displayName = "SlotClone";
var QH = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function FH(t) {
  return w.isValidElement(t) && t.type === QH;
}
function VH(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function BH(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var jH = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  ZH = jH.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? v$ : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {}),
  zH = "Toggle",
  x$ = w.forwardRef((t, e) => {
    const { pressed: n, defaultPressed: r = !1, onPressedChange: i, ...s } = t,
      [o = !1, a] = Vo({ prop: n, onChange: i, defaultProp: r });
    return E.jsx(ZH.button, {
      type: "button",
      "aria-pressed": o,
      "data-state": o ? "on" : "off",
      "data-disabled": t.disabled ? "" : void 0,
      ...s,
      ref: e,
      onClick: Ye(t.onClick, () => {
        t.disabled || a(!o);
      }),
    });
  });
x$.displayName = zH;
var Yl = "ToggleGroup",
  [b$, y$] = da(Yl, [ng]),
  w$ = ng(),
  vy = C.forwardRef((t, e) => {
    const { type: n, ...r } = t;
    if (n === "single") {
      const i = r;
      return E.jsx(WH, { ...i, ref: e });
    }
    if (n === "multiple") {
      const i = r;
      return E.jsx(UH, { ...i, ref: e });
    }
    throw new Error(`Missing prop \`type\` expected on \`${Yl}\``);
  });
vy.displayName = Yl;
var [S$, k$] = b$(Yl),
  WH = C.forwardRef((t, e) => {
    const { value: n, defaultValue: r, onValueChange: i = () => {}, ...s } = t,
      [o, a] = Vo({ prop: n, defaultProp: r, onChange: i });
    return E.jsx(S$, {
      scope: t.__scopeToggleGroup,
      type: "single",
      value: o ? [o] : [],
      onItemActivate: a,
      onItemDeactivate: C.useCallback(() => a(""), [a]),
      children: E.jsx(C$, { ...s, ref: e }),
    });
  }),
  UH = C.forwardRef((t, e) => {
    const { value: n, defaultValue: r, onValueChange: i = () => {}, ...s } = t,
      [o = [], a] = Vo({ prop: n, defaultProp: r, onChange: i }),
      l = C.useCallback((u) => a((h = []) => [...h, u]), [a]),
      c = C.useCallback((u) => a((h = []) => h.filter((f) => f !== u)), [a]);
    return E.jsx(S$, {
      scope: t.__scopeToggleGroup,
      type: "multiple",
      value: o,
      onItemActivate: l,
      onItemDeactivate: c,
      children: E.jsx(C$, { ...s, ref: e }),
    });
  });
vy.displayName = Yl;
var [XH, HH] = b$(Yl),
  C$ = C.forwardRef((t, e) => {
    const { __scopeToggleGroup: n, disabled: r = !1, rovingFocus: i = !0, orientation: s, dir: o, loop: a = !0, ...l } = t,
      c = w$(n),
      u = eg(o),
      h = { role: "group", dir: u, ...l };
    return E.jsx(XH, {
      scope: n,
      rovingFocus: i,
      disabled: r,
      children: i
        ? E.jsx(d$, { asChild: !0, ...c, orientation: s, dir: u, loop: a, children: E.jsx(OC.div, { ...h, ref: e }) })
        : E.jsx(OC.div, { ...h, ref: e }),
    });
  }),
  vp = "ToggleGroupItem",
  _$ = C.forwardRef((t, e) => {
    const n = k$(vp, t.__scopeToggleGroup),
      r = HH(vp, t.__scopeToggleGroup),
      i = w$(t.__scopeToggleGroup),
      s = n.value.includes(t.value),
      o = r.disabled || t.disabled,
      a = { ...t, pressed: s, disabled: o },
      l = C.useRef(null);
    return r.rovingFocus
      ? E.jsx(gy, { asChild: !0, ...i, focusable: !o, active: s, ref: l, children: E.jsx(vC, { ...a, ref: e }) })
      : E.jsx(vC, { ...a, ref: e });
  });
_$.displayName = vp;
var vC = C.forwardRef((t, e) => {
    const { __scopeToggleGroup: n, value: r, ...i } = t,
      s = k$(vp, n),
      o = { role: "radio", "aria-checked": t.pressed, "aria-pressed": void 0 },
      a = s.type === "single" ? o : void 0;
    return E.jsx(x$, {
      ...a,
      ...i,
      ref: e,
      onPressedChange: (l) => {
        l ? s.onItemActivate(r) : s.onItemDeactivate(r);
      },
    });
  }),
  qH = vy,
  YH = _$,
  xy = "Toolbar",
  [GH, Vve] = da(xy, [ng, y$]),
  by = ng(),
  E$ = y$(),
  [JH, T$] = GH(xy),
  P$ = w.forwardRef((t, e) => {
    const { __scopeToolbar: n, orientation: r = "horizontal", dir: i, loop: s = !0, ...o } = t,
      a = by(n),
      l = eg(i);
    return E.jsx(JH, {
      scope: n,
      orientation: r,
      dir: l,
      children: E.jsx(d$, {
        asChild: !0,
        ...a,
        orientation: r,
        dir: l,
        loop: s,
        children: E.jsx(Oy.div, { role: "toolbar", "aria-orientation": r, dir: l, ...o, ref: e }),
      }),
    });
  });
P$.displayName = xy;
var A$ = "ToolbarSeparator",
  $$ = w.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = T$(A$, n);
    return E.jsx(TH, { orientation: i.orientation === "horizontal" ? "vertical" : "horizontal", ...r, ref: e });
  });
$$.displayName = A$;
var KH = "ToolbarButton",
  yy = w.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = by(n);
    return E.jsx(gy, { asChild: !0, ...i, focusable: !t.disabled, children: E.jsx(Oy.button, { type: "button", ...r, ref: e }) });
  });
yy.displayName = KH;
var eq = "ToolbarLink",
  tq = w.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = by(n);
    return E.jsx(gy, {
      asChild: !0,
      ...i,
      focusable: !0,
      children: E.jsx(Oy.a, {
        ...r,
        ref: e,
        onKeyDown: Ye(t.onKeyDown, (s) => {
          s.key === " " && s.currentTarget.click();
        }),
      }),
    });
  });
tq.displayName = eq;
var R$ = "ToolbarToggleGroup",
  I$ = w.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = T$(R$, n),
      s = E$(n);
    return E.jsx(qH, { "data-orientation": i.orientation, dir: i.dir, ...s, ...r, ref: e, rovingFocus: !1 });
  });
I$.displayName = R$;
var nq = "ToolbarToggleItem",
  N$ = w.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = E$(n),
      s = { __scopeToolbar: t.__scopeToolbar };
    return E.jsx(yy, { asChild: !0, ...s, children: E.jsx(YH, { ...i, ...r, ref: e }) });
  });
N$.displayName = nq;
var wy = P$,
  L$ = $$,
  ns = yy,
  rg = I$,
  Cd = N$;
function ig(t, e) {
  return t === null || t === e
    ? !1
    : t.dataset.editorDialog !== void 0 || t.dataset.toolbarItem !== void 0 || t.dataset.editorDropdown
    ? !0
    : ig(t.parentElement, e);
}
function M$() {
  const t = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0")),
    e = crypto.getRandomValues(new Uint8Array(16));
  return (
    (e[6] = (e[6] & 15) | 64),
    (e[8] = (e[8] & 63) | 128),
    [...e.entries()].map(([n, r]) => ([4, 6, 8, 10].includes(n) ? `-${t[r]}` : t[r])).join("")
  );
}
const D$ = (t) => (t === 0 ? "th" : "td"),
  Q$ = { center: F.centeredCell, left: F.leftAlignedCell, right: F.rightAlignedCell },
  rq = ({ mdastNode: t, parentEditor: e, lexicalTable: n }) => {
    const [r, i] = C.useState(null),
      [s, o] = nt(ft, sn),
      a = C.useMemo(() => (m) => (m.__cacheKey || (m.__cacheKey = M$()), m.__cacheKey), []),
      l = C.useCallback(
        (m) => {
          const O = n.getColCount();
          if (m === null) {
            i(null);
            return;
          }
          let [v, g] = m;
          if ((v > O - 1 && ((v = 0), g++), v < 0 && ((v = O - 1), (g -= 1)), g > n.getRowCount() - 1)) {
            i(null),
              e.update(() => {
                if (n.getLatest().getNextSibling()) n.getLatest().selectNext();
                else {
                  const y = at();
                  n.insertAfter(y), y.select();
                }
              });
            return;
          }
          if (g < 0) {
            i(null),
              e.update(() => {
                n.getLatest().selectPrevious();
              });
            return;
          }
          i([v, g]);
        },
        [n, e]
      );
    C.useEffect(() => {
      n.focusEmitter.subscribe(l);
    }, [n, l]);
    const c = C.useCallback(
        (m) => {
          m.preventDefault(),
            e.update(() => {
              n.addRowToBottom(), i([0, n.getRowCount()]);
            });
        },
        [e, n]
      ),
      u = C.useCallback(
        (m) => {
          m.preventDefault(),
            e.update(() => {
              n.addColumnToRight(), i([n.getColCount(), 0]);
            });
        },
        [e, n]
      ),
      [h, f] = C.useState([-1, -1]),
      d = C.useCallback((m) => {
        let O = m.target;
        for (; O && !["TH", "TD"].includes(O.tagName); ) {
          if (O === m.currentTarget) return;
          O = O.parentElement;
        }
        if (O === null) return;
        const v = O.parentElement,
          x = v.parentElement.tagName === "TFOOT" ? -1 : Array.from(v.children).indexOf(O),
          y = O.tagName === "TH" ? -1 : Array.from(v.parentElement.children).indexOf(v);
        f([x, y]);
      }, []),
      p = lt();
    return C.createElement(
      "table",
      {
        className: F.tableEditor,
        onMouseOver: d,
        onMouseLeave: () => {
          f([-1, -1]);
        },
      },
      C.createElement(
        "colgroup",
        null,
        o ? null : C.createElement("col", null),
        Array.from({ length: t.children[0].children.length }, (m, O) => {
          const g = (t.align ?? [])[O] ?? "left",
            x = Q$[g];
          return C.createElement("col", { key: O, className: x });
        }),
        o ? null : C.createElement("col", null)
      ),
      o ||
        C.createElement(
          "thead",
          null,
          C.createElement(
            "tr",
            null,
            C.createElement("th", { className: F.tableToolsColumn }),
            Array.from({ length: t.children[0].children.length }, (m, O) =>
              C.createElement(
                "th",
                { key: O, "data-tool-cell": !0 },
                C.createElement(oq, {
                  setActiveCellWithBoundaries: l,
                  parentEditor: e,
                  colIndex: O,
                  highlightedCoordinates: h,
                  lexicalTable: n,
                  align: (t.align ?? [])[O],
                })
              )
            ),
            C.createElement(
              "th",
              { className: F.tableToolsColumn, "data-tool-cell": !0 },
              C.createElement(
                "button",
                {
                  className: F.iconButton,
                  type: "button",
                  title: p("table.deleteTable", "Delete table"),
                  onClick: (m) => {
                    m.preventDefault(),
                      e.update(() => {
                        n.selectNext(), n.remove();
                      });
                  },
                },
                s("delete_small")
              )
            )
          )
        ),
      C.createElement(
        "tbody",
        null,
        t.children.map((m, O) => {
          const v = D$(O);
          return C.createElement(
            "tr",
            { key: O },
            o ||
              C.createElement(
                v,
                { className: F.toolCell, "data-tool-cell": !0 },
                C.createElement(aq, {
                  setActiveCellWithBoundaries: l,
                  parentEditor: e,
                  rowIndex: O,
                  highlightedCoordinates: h,
                  lexicalTable: n,
                })
              ),
            m.children.map((g, x) => {
              var y;
              return C.createElement(iq, {
                align: (y = t.align) == null ? void 0 : y[x],
                key: a(g),
                contents: g.children,
                setActiveCell: l,
                rowIndex: O,
                colIndex: x,
                lexicalTable: n,
                parentEditor: e,
                activeCell: o ? [-1, -1] : r,
              });
            }),
            o ||
              (O === 0 &&
                C.createElement(
                  "th",
                  { rowSpan: n.getRowCount(), "data-tool-cell": !0 },
                  C.createElement("button", { type: "button", className: F.addColumnButton, onClick: u }, s("add_column"))
                ))
          );
        })
      ),
      o ||
        C.createElement(
          "tfoot",
          null,
          C.createElement(
            "tr",
            null,
            C.createElement("th", null),
            C.createElement(
              "th",
              { colSpan: n.getColCount() },
              C.createElement("button", { type: "button", className: F.addRowButton, onClick: c }, s("add_row"))
            ),
            C.createElement("th", null)
          )
        )
    );
  },
  iq = ({ align: t, ...e }) => {
    const { activeCell: n, setActiveCell: r } = e,
      i = !!(n && n[0] === e.colIndex && n[1] === e.rowIndex),
      s = Q$[t ?? "left"],
      o = D$(e.rowIndex);
    return C.createElement(
      o,
      {
        className: s,
        "data-active": i,
        onClick: () => {
          r([e.colIndex, e.rowIndex]);
        },
      },
      C.createElement(sq, { ...e, focus: i })
    );
  },
  sq = ({ focus: t, setActiveCell: e, parentEditor: n, lexicalTable: r, contents: i, colIndex: s, rowIndex: o }) => {
    const [a, l, c, u, h, f, d, p] = nt(Eh, Ph, Th, Js, zo, ha, Ah, sr),
      [m] = C.useState(() => {
        const v = Rb({ nodes: c, theme: Xm });
        return (
          v.update(() => {
            Um({
              root: Be(),
              mdastRoot: { type: "root", children: [{ type: "paragraph", children: i }] },
              visitors: a,
              jsxComponentDescriptors: u,
              directiveDescriptors: h,
              codeBlockEditorDescriptors: f,
            });
          }),
          v
        );
      }),
      O = C.useCallback(
        (v) => {
          m.getEditorState().read(() => {
            const g = Wm({ root: Be(), jsxComponentDescriptors: u, visitors: l, jsxIsAvailable: d });
            n.update(
              () => {
                r.updateCellContents(s, o, g.children[0].children);
              },
              { discrete: !0 }
            ),
              n.dispatchCommand(Gs, void 0);
          }),
            e(v);
        },
        [s, m, l, u, d, r, n, o, e]
      );
    return (
      C.useEffect(
        () =>
          ir(
            m.registerCommand(
              rb,
              (v) => {
                v.preventDefault();
                const g = v.shiftKey ? [s - 1, o] : [s + 1, o];
                return O(g), !0;
              },
              Gn
            ),
            m.registerCommand(lb, () => (e([s, o]), !1), Ot),
            m.registerCommand(
              pl,
              (v) => {
                v == null || v.preventDefault();
                const g = v != null && v.shiftKey ? [s, o - 1] : [s, o + 1];
                return O(g), !0;
              },
              Gn
            ),
            m.registerCommand(
              Em,
              (v) => {
                const g = v.relatedTarget;
                return ig(g, p.getRootElement()) ? !1 : (O(null), !0);
              },
              Gn
            ),
            m.registerCommand(Gs, () => (O(null), !0), Gn)
          ),
        [s, m, p, o, O, e]
      ),
      C.useEffect(() => {
        t && m.focus();
      }, [t, m]),
      C.createElement(
        n$,
        { initialEditor: m },
        C.createElement(uy, { contentEditable: C.createElement(ly, null), placeholder: C.createElement("div", null), ErrorBoundary: cy }),
        C.createElement(I3, null)
      )
    );
  },
  oq = ({ parentEditor: t, highlightedCoordinates: e, align: n, lexicalTable: r, colIndex: i, setActiveCellWithBoundaries: s }) => {
    const [o, a] = nt(si, ft),
      l = C.useCallback(
        (f) => {
          t.update(() => {
            r.insertColumnAt(f);
          }),
            s([f, 0]);
        },
        [t, r, s]
      ),
      c = C.useCallback(
        (f) => {
          t.update(() => {
            r.deleteColumnAt(f);
          });
        },
        [t, r]
      ),
      u = C.useCallback(
        (f, d) => {
          t.update(() => {
            r.setColumnAlign(f, d);
          });
        },
        [t, r]
      ),
      h = lt();
    return C.createElement(
      mm,
      null,
      C.createElement(
        bP,
        { className: F.tableColumnEditorTrigger, "data-active": e[0] === i + 1, title: h("table.columnMenu", "Column menu") },
        a("more_horiz")
      ),
      C.createElement(
        gm,
        { container: o == null ? void 0 : o.current },
        C.createElement(
          yP,
          {
            className: Ze(F.tableColumnEditorPopoverContent),
            onOpenAutoFocus: (f) => {
              f.preventDefault();
            },
            sideOffset: 5,
            side: "top",
          },
          C.createElement(
            wy,
            { className: F.tableColumnEditorToolbar },
            C.createElement(
              rg,
              {
                className: F.toggleGroupRoot,
                onValueChange: (f) => {
                  u(i, f);
                },
                value: n ?? "left",
                type: "single",
                "aria-label": h("table.textAlignment", "Text alignment"),
              },
              C.createElement(Cd, { value: "left", title: h("table.alignLeft", "Align left") }, a("format_align_left")),
              C.createElement(Cd, { value: "center", title: h("table.alignCenter", "Align center") }, a("format_align_center")),
              C.createElement(Cd, { value: "right", title: h("table.alignRight", "Align right") }, a("format_align_right"))
            ),
            C.createElement(L$, null),
            C.createElement(
              ns,
              { onClick: l.bind(null, i), title: h("table.insertColumnLeft", "Insert a column to the left of this one") },
              a("insert_col_left")
            ),
            C.createElement(
              ns,
              { onClick: l.bind(null, i + 1), title: h("table.insertColumnRight", "Insert a column to the right of this one") },
              a("insert_col_right")
            ),
            C.createElement(ns, { onClick: c.bind(null, i), title: h("table.deleteColumn", "Delete this column") }, a("delete_small"))
          ),
          C.createElement(Om, { className: F.popoverArrow })
        )
      )
    );
  },
  aq = ({ parentEditor: t, highlightedCoordinates: e, lexicalTable: n, rowIndex: r, setActiveCellWithBoundaries: i }) => {
    const [s, o] = nt(si, ft),
      a = C.useCallback(
        (u) => {
          t.update(() => {
            n.insertRowAt(u);
          }),
            i([0, u]);
        },
        [t, n, i]
      ),
      l = C.useCallback(
        (u) => {
          t.update(() => {
            n.deleteRowAt(u);
          });
        },
        [t, n]
      ),
      c = lt();
    return C.createElement(
      mm,
      null,
      C.createElement(
        bP,
        { className: F.tableColumnEditorTrigger, "data-active": e[1] === r, title: c("table.rowMenu", "Row menu") },
        o("more_horiz")
      ),
      C.createElement(
        gm,
        { container: s == null ? void 0 : s.current },
        C.createElement(
          yP,
          {
            className: Ze(F.tableColumnEditorPopoverContent),
            onOpenAutoFocus: (u) => {
              u.preventDefault();
            },
            sideOffset: 5,
            side: "bottom",
          },
          C.createElement(
            wy,
            { className: F.tableColumnEditorToolbar },
            C.createElement(
              ns,
              { onClick: a.bind(null, r), title: c("table.insertRowAbove", "Insert a row above this one") },
              o("insert_row_above")
            ),
            C.createElement(
              ns,
              { onClick: a.bind(null, r + 1), title: c("table.insertRowBelow", "Insert a row below this one") },
              o("insert_row_below")
            ),
            C.createElement(ns, { onClick: l.bind(null, r), title: c("table.deleteRow", "Delete this row") }, o("delete_small"))
          ),
          C.createElement(Om, { className: F.popoverArrow })
        )
      )
    );
  };
var lq = Object.defineProperty,
  cq = (t, e, n) => (e in t ? lq(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  xC = (t, e, n) => (cq(t, typeof e != "symbol" ? e + "" : e, n), n);
const bC = { type: "tableCell", children: [] };
function uq() {
  let t = Zs;
  return {
    publish: (e) => {
      t(e);
    },
    subscribe: (e) => {
      t = e;
    },
  };
}
class Gl extends Mi {
  constructor(e, n) {
    super(n), xC(this, "__mdastNode"), xC(this, "focusEmitter", uq()), (this.__mdastNode = e ?? { type: "table", children: [] });
  }
  static getType() {
    return "table";
  }
  static clone(e) {
    return new Gl(structuredClone(e.__mdastNode), e.__key);
  }
  static importJSON(e) {
    return sg(e.mdastNode);
  }
  exportJSON() {
    return { mdastNode: structuredClone(this.__mdastNode), type: "table", version: 1 };
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  getRowCount() {
    return this.__mdastNode.children.length;
  }
  getColCount() {
    var e;
    return ((e = this.__mdastNode.children[0]) == null ? void 0 : e.children.length) || 0;
  }
  createDOM() {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  updateCellContents(e, n, r) {
    const s = this.getWritable().__mdastNode,
      o = s.children[n],
      a = o.children,
      l = a[e],
      c = Array.from(a),
      u = { ...l, children: r },
      h = { ...o, children: c };
    (c[e] = u), (s.children[n] = h);
  }
  insertColumnAt(e) {
    const r = this.getWritable().__mdastNode;
    for (let i = 0; i < r.children.length; i++) {
      const s = r.children[i],
        o = s.children,
        a = Array.from(o),
        l = { ...s, children: a };
      a.splice(e, 0, structuredClone(bC)), (r.children[i] = l);
    }
    r.align && r.align.length > 0 && r.align.splice(e, 0, "left");
  }
  deleteColumnAt(e) {
    const r = this.getWritable().__mdastNode;
    for (let i = 0; i < r.children.length; i++) {
      const s = r.children[i],
        o = s.children,
        a = Array.from(o),
        l = { ...s, children: a };
      a.splice(e, 1), (r.children[i] = l);
    }
  }
  insertRowAt(e) {
    const r = this.getWritable().__mdastNode,
      i = { type: "tableRow", children: Array.from({ length: this.getColCount() }, () => structuredClone(bC)) };
    r.children.splice(e, 0, i);
  }
  deleteRowAt(e) {
    this.getRowCount() === 1 ? (this.selectNext(), this.remove()) : this.getWritable().__mdastNode.children.splice(e, 1);
  }
  addRowToBottom() {
    this.insertRowAt(this.getRowCount());
  }
  addColumnToRight() {
    this.insertColumnAt(this.getColCount());
  }
  setColumnAlign(e, n) {
    const i = this.getWritable().__mdastNode;
    i.align == null && (i.align = []), (i.align[e] = n);
  }
  decorate(e) {
    return C.createElement(rq, { lexicalTable: this, mdastNode: this.__mdastNode, parentEditor: e });
  }
  select(e) {
    this.focusEmitter.publish(e ?? [0, 0]);
  }
  isInline() {
    return !1;
  }
}
function F$(t) {
  return t instanceof Gl;
}
function sg(t) {
  return new Gl(t);
}
const hq = {
    testLexicalNode: F$,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      t.appendToParent(e, n.getMdastNode());
    },
  },
  fq = {
    testNode: "table",
    visitNode({ mdastNode: t, lexicalParent: e }) {
      e.append(sg(t));
    },
  };
function dq(t = 1, e = 1) {
  const n = { type: "table", children: [] };
  for (let r = 0; r < t; r++) {
    const i = { type: "tableRow", children: [] };
    for (let s = 0; s < e; s++) {
      const o = { type: "tableCell", children: [] };
      i.children.push(o);
    }
    n.children.push(i);
  }
  return n;
}
const Sy = $t((t) => {
    t.link(
      t.pipe(
        Sy,
        Rr(
          ({ rows: e, columns: n }) =>
            () =>
              sg(dq(e, n))
        )
      ),
      Hl
    );
  }),
  pq = en({
    init(t) {
      t.pubIn({ [eo]: SX(), [Ks]: IX(), [rr]: fq, [vr]: Gl, [xr]: hq, [fa]: PX({ tableCellPadding: !0, tablePipeAlign: !0 }) });
    },
  }),
  mq = new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
let Jl = class V$ extends ii {
  static getType() {
    return "link";
  }
  static clone(e) {
    return new V$(e.__url, { rel: e.__rel, target: e.__target, title: e.__title }, e.__key);
  }
  constructor(e, n = {}, r) {
    super(r);
    const { target: i = null, rel: s = null, title: o = null } = n;
    (this.__url = e), (this.__target = i), (this.__rel = s), (this.__title = o);
  }
  createDOM(e) {
    const n = document.createElement("a");
    return (
      (n.href = this.sanitizeUrl(this.__url)),
      this.__target !== null && (n.target = this.__target),
      this.__rel !== null && (n.rel = this.__rel),
      this.__title !== null && (n.title = this.__title),
      Yr(n, e.theme.link),
      n
    );
  }
  updateDOM(e, n, r) {
    if (n instanceof HTMLAnchorElement) {
      const i = this.__url,
        s = this.__target,
        o = this.__rel,
        a = this.__title;
      i !== e.__url && (n.href = i),
        s !== e.__target && (s ? (n.target = s) : n.removeAttribute("target")),
        o !== e.__rel && (o ? (n.rel = o) : n.removeAttribute("rel")),
        a !== e.__title && (a ? (n.title = a) : n.removeAttribute("title"));
    }
    return !1;
  }
  static importDOM() {
    return { a: (e) => ({ conversion: gq, priority: 1 }) };
  }
  static importJSON(e) {
    const n = Xo(e.url, { rel: e.rel, target: e.target, title: e.title });
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  sanitizeUrl(e) {
    try {
      const n = new URL(e);
      if (!mq.has(n.protocol)) return "about:blank";
    } catch {
      return e;
    }
    return e;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      rel: this.getRel(),
      target: this.getTarget(),
      title: this.getTitle(),
      type: "link",
      url: this.getURL(),
      version: 1,
    };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(e) {
    this.getWritable().__url = e;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(e) {
    this.getWritable().__target = e;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(e) {
    this.getWritable().__rel = e;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(e) {
    this.getWritable().__title = e;
  }
  insertNewAfter(e, n = !0) {
    const r = Xo(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!ee(n)) return !1;
    const i = n.anchor.getNode(),
      s = n.focus.getNode();
    return this.isParentOf(i) && this.isParentOf(s) && n.getTextContent().length > 0;
  }
};
function gq(t) {
  let e = null;
  if (yQ(t)) {
    const n = t.textContent;
    ((n !== null && n !== "") || t.children.length > 0) &&
      (e = Xo(t.getAttribute("href") || "", {
        rel: t.getAttribute("rel"),
        target: t.getAttribute("target"),
        title: t.getAttribute("title"),
      }));
  }
  return { node: e };
}
function Xo(t, e) {
  return Zn(new Jl(t, e));
}
function xi(t) {
  return t instanceof Jl;
}
let og = class B$ extends Jl {
  constructor(e, n = {}, r) {
    super(e, n, r), (this.__isUnlinked = n.isUnlinked !== void 0 && n.isUnlinked !== null && n.isUnlinked);
  }
  static getType() {
    return "autolink";
  }
  static clone(e) {
    return new B$(e.__url, { isUnlinked: e.__isUnlinked, rel: e.__rel, target: e.__target, title: e.__title }, e.__key);
  }
  getIsUnlinked() {
    return this.__isUnlinked;
  }
  setIsUnlinked(e) {
    const n = this.getWritable();
    return (n.__isUnlinked = e), n;
  }
  createDOM(e) {
    return this.__isUnlinked ? document.createElement("span") : super.createDOM(e);
  }
  updateDOM(e, n, r) {
    return super.updateDOM(e, n, r) || e.__isUnlinked !== this.__isUnlinked;
  }
  static importJSON(e) {
    const n = WO(e.url, { isUnlinked: e.isUnlinked, rel: e.rel, target: e.target, title: e.title });
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return { ...super.exportJSON(), isUnlinked: this.__isUnlinked, type: "autolink", version: 1 };
  }
  insertNewAfter(e, n = !0) {
    const r = this.getParentOrThrow().insertNewAfter(e, n);
    if (W(r)) {
      const i = WO(this.__url, { isUnlinked: this.__isUnlinked, rel: this.__rel, target: this.__target, title: this.__title });
      return r.append(i), i;
    }
    return null;
  }
};
function WO(t, e) {
  return Zn(new og(t, e));
}
function Ia(t) {
  return t instanceof og;
}
const xl = gs();
function v0(t, e = {}) {
  const { target: n, title: r } = e,
    i = e.rel === void 0 ? "noreferrer" : e.rel,
    s = ce();
  if (!ee(s)) return;
  const o = s.extract();
  if (t === null)
    o.forEach((a) => {
      const l = a.getParent();
      if (!Ia(l) && xi(l)) {
        const c = l.getChildren();
        for (let u = 0; u < c.length; u++) l.insertBefore(c[u]);
        l.remove();
      }
    });
  else {
    if (o.length === 1) {
      const c = (function (u, h) {
        let f = u;
        for (; f !== null && f.getParent() !== null && !h(f); ) f = f.getParentOrThrow();
        return h(f) ? f : null;
      })(o[0], xi);
      if (c !== null) return c.setURL(t), n !== void 0 && c.setTarget(n), i !== null && c.setRel(i), void (r !== void 0 && c.setTitle(r));
    }
    let a = null,
      l = null;
    o.forEach((c) => {
      const u = c.getParent();
      if (u !== l && u !== null && (!W(c) || c.isInline())) {
        if (xi(u))
          return (l = u), u.setURL(t), n !== void 0 && u.setTarget(n), i !== null && l.setRel(i), void (r !== void 0 && l.setTitle(r));
        if (
          (u.is(a) ||
            ((a = u),
            (l = Xo(t, { rel: i, target: n, title: r })),
            xi(u) ? (c.getPreviousSibling() === null ? u.insertBefore(l) : u.insertAfter(l)) : c.insertBefore(l)),
          xi(c))
        ) {
          if (c.is(l)) return;
          if (l !== null) {
            const h = c.getChildren();
            for (let f = 0; f < h.length; f++) l.append(h[f]);
          }
          c.remove();
        } else l !== null && l.append(c);
      }
    });
  }
}
const Oq = {
    testNode: "link",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(Xo(t.url, { title: t.title }));
    },
  },
  vq = {
    testLexicalNode: xi,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      e.addAndStepInto("link", { url: t.getURL(), title: t.getTitle() });
    },
  };
function xq({ validateUrl: t }) {
  const [e] = jn();
  return (
    w.useEffect(() => {
      if (!e.hasNodes([Jl])) throw new Error("LinkPlugin: LinkNode not registered on editor");
      return ir(
        e.registerCommand(
          xl,
          (n) => {
            if (n === null) return v0(n), !0;
            if (typeof n == "string") return !(t !== void 0 && !t(n)) && (v0(n), !0);
            {
              const { url: r, target: i, rel: s, title: o } = n;
              return v0(r, { rel: s, target: i, title: o }), !0;
            }
          },
          Ot
        ),
        t !== void 0
          ? e.registerCommand(
              mh,
              (n) => {
                const r = ce();
                if (!ee(r) || r.isCollapsed() || !Ms(n, ClipboardEvent)) return !1;
                const i = n;
                if (i.clipboardData === null) return !1;
                const s = i.clipboardData.getData("text");
                return !!t(s) && !r.getNodes().some((o) => W(o)) && (e.dispatchCommand(xl, s), n.preventDefault(), !0);
              },
              Ot
            )
          : () => {}
      );
    }, [e, t]),
    null
  );
}
function bq(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var yq = bq(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function yC(t, e = (n) => n) {
  return (n) => {
    const r = t.exec(n);
    return r === null ? null : { index: r.index, length: r[0].length, text: r[0], url: e(r[0]) };
  };
}
function j$(t, e) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n](t);
    if (r) return r;
  }
  return null;
}
const wq = /[.,;\s]/;
function xp(t) {
  return wq.test(t);
}
function Z$(t) {
  return xp(t[t.length - 1]);
}
function UO(t) {
  return xp(t[0]);
}
function z$(t) {
  let e = t.getPreviousSibling();
  return W(e) && (e = e.getLastDescendant()), e === null || Hr(e) || (ne(e) && Z$(e.getTextContent()));
}
function W$(t) {
  let e = t.getNextSibling();
  return W(e) && (e = e.getFirstDescendant()), e === null || Hr(e) || (ne(e) && UO(e.getTextContent()));
}
function Sq(t, e, n, r) {
  return (t > 0 ? xp(n[t - 1]) : z$(r[0])) ? (e < n.length ? xp(n[e]) : W$(r[r.length - 1])) : !1;
}
function kq(t, e, n) {
  const r = [],
    i = [],
    s = [];
  let o = 0,
    a = 0;
  const l = [...t];
  for (; l.length > 0; ) {
    const c = l[0],
      u = c.getTextContent().length,
      h = a;
    a + u <= e ? (r.push(c), (o += u)) : h >= n ? s.push(c) : i.push(c), (a += u), l.shift();
  }
  return [o, r, i, s];
}
function Cq(t, e, n, r) {
  const i = WO(r.url, r.attributes);
  if (t.length === 1) {
    let s,
      o = t[0];
    e === 0 ? ([s, o] = o.splitText(n)) : ([, s, o] = o.splitText(e, n));
    const a = Et(r.text);
    return a.setFormat(s.getFormat()), a.setDetail(s.getDetail()), a.setStyle(s.getStyle()), i.append(a), s.replace(i), o;
  }
  if (t.length > 1) {
    const s = t[0];
    let o,
      a = s.getTextContent().length;
    e === 0 ? (o = s) : ([, o] = s.splitText(e));
    const l = [];
    let c;
    for (let d = 1; d < t.length; d++) {
      const p = t[d],
        m = p.getTextContent().length,
        O = a;
      if (O < n)
        if (a + m <= n) l.push(p);
        else {
          const [v, g] = p.splitText(n - O);
          l.push(v), (c = g);
        }
      a += m;
    }
    const u = ce(),
      h = u ? u.getNodes().find(ne) : void 0,
      f = Et(o.getTextContent());
    return (
      f.setFormat(o.getFormat()),
      f.setDetail(o.getDetail()),
      f.setStyle(o.getStyle()),
      i.append(f, ...l),
      h && h === o && (ee(u) ? f.select(u.anchor.offset, u.focus.offset) : Ht(u) && f.select(0, f.getTextContent().length)),
      o.replace(i),
      c
    );
  }
}
function x0(t, e, n) {
  const r = t.getChildren(),
    i = r.length;
  for (let l = 0; l < i; l++) {
    const c = r[l];
    if (!ne(c) || !c.isSimpleText()) return _d(t), void n(null, t.getURL());
  }
  const s = t.getTextContent(),
    o = j$(s, e);
  if (o === null || o.text !== s || !z$(t) || !W$(t)) return _d(t), void n(null, t.getURL());
  const a = t.getURL();
  if ((a !== o.url && (t.setURL(o.url), n(o.url, a)), o.attributes)) {
    const l = t.getRel();
    l !== o.attributes.rel && (t.setRel(o.attributes.rel || null), n(o.attributes.rel || null, l));
    const c = t.getTarget();
    c !== o.attributes.target && (t.setTarget(o.attributes.target || null), n(o.attributes.target || null, c));
  }
}
function _d(t) {
  const e = t.getChildren();
  for (let n = e.length - 1; n >= 0; n--) t.insertAfter(e[n]);
  return t.remove(), e.map((n) => n.getLatest());
}
function _q(t, e, n) {
  w.useEffect(() => {
    t.hasNodes([og]) || yq(77);
    const r = (i, s) => {
      n && n(i, s);
    };
    return ir(
      t.registerNodeTransform(Os, (i) => {
        const s = i.getParentOrThrow(),
          o = i.getPreviousSibling();
        if (Ia(s) && !s.getIsUnlinked()) x0(s, e, r);
        else if (!xi(s)) {
          if (i.isSimpleText() && (UO(i.getTextContent()) || !Ia(o))) {
            const a = (function (l) {
              const c = [l];
              let u = l.getNextSibling();
              for (; u !== null && ne(u) && u.isSimpleText() && (c.push(u), !/[\s]/.test(u.getTextContent())); ) u = u.getNextSibling();
              return c;
            })(i);
            (function (l, c, u) {
              let h = [...l];
              const f = h.map((O) => O.getTextContent()).join("");
              let d,
                p = f,
                m = 0;
              for (; (d = j$(p, c)) && d !== null; ) {
                const O = d.index,
                  v = O + d.length;
                if (Sq(m + O, m + v, f, h)) {
                  const [g, , x, y] = kq(h, m + O, m + v),
                    S = Cq(x, m + O - g, m + v - g, d);
                  (h = S ? [S, ...y] : y), u(d.url, null), (m = 0);
                } else m += v;
                p = p.substring(v);
              }
            })(a, e, r);
          }
          (function (a, l, c) {
            const u = a.getPreviousSibling(),
              h = a.getNextSibling(),
              f = a.getTextContent();
            !Ia(u) || u.getIsUnlinked() || (UO(f) && !/^\.[a-zA-Z0-9]{1,}/.test(f)) || (u.append(a), x0(u, l, c), c(null, u.getURL())),
              !Ia(h) || h.getIsUnlinked() || Z$(f) || (_d(h), x0(h, l, c), c(null, h.getURL()));
          })(i, e, r);
        }
      }),
      t.registerCommand(
        xl,
        (i) => {
          const s = ce();
          return (
            i !== null ||
              !ee(s) ||
              s.extract().forEach((o) => {
                const a = o.getParent();
                if (Ia(a)) return a.setIsUnlinked(!a.getIsUnlinked()), a.markDirty(), !0;
              }),
            !1
          );
        },
        Ot
      )
    );
  }, [t, e, n]);
}
function Eq({ matchers: t, onChange: e }) {
  const [n] = jn();
  return _q(n, t, e), null;
}
const Tq = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/,
  Pq =
    /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/,
  Aq = [yC(Tq, (t) => (t.startsWith("http") ? t : `https://${t}`)), yC(Pq, (t) => `mailto:${t}`)],
  $q = () => C.createElement(Eq, { matchers: Aq }),
  U$ = Se(!1),
  Rq = en({
    init(t, e) {
      const n = !!(e != null && e.disableAutoLink),
        r = e != null && e.validateUrl ? { validateUrl: e.validateUrl } : {};
      t.pubIn({
        [ql]: "link",
        [rr]: Oq,
        [vr]: [Jl, og],
        [xr]: vq,
        [U$]: n,
        [fo]: () => C.createElement(C.Fragment, null, C.createElement(xq, { ...r }), n ? null : C.createElement($q, null)),
      });
    },
  });
function Ws(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (i) {
    if ((t == null || t(i), n === !1 || !i.defaultPrevented)) return e == null ? void 0 : e(i);
  };
}
function Iq(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function X$(...t) {
  return (e) => t.forEach((n) => Iq(n, e));
}
function Kl(...t) {
  return w.useCallback(X$(...t), t);
}
function Nq(t, e = []) {
  let n = [];
  function r(s, o) {
    const a = w.createContext(o),
      l = n.length;
    n = [...n, o];
    function c(h) {
      const { scope: f, children: d, ...p } = h,
        m = (f == null ? void 0 : f[t][l]) || a,
        O = w.useMemo(() => p, Object.values(p));
      return w.createElement(m.Provider, { value: O }, d);
    }
    function u(h, f) {
      const d = (f == null ? void 0 : f[t][l]) || a,
        p = w.useContext(d);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${h}\` must be used within \`${s}\``);
    }
    return (c.displayName = s + "Provider"), [c, u];
  }
  const i = () => {
    const s = n.map((o) => w.createContext(o));
    return function (a) {
      const l = (a == null ? void 0 : a[t]) || s;
      return w.useMemo(() => ({ [`__scope${t}`]: { ...a, [t]: l } }), [a, l]);
    };
  };
  return (i.scopeName = t), [r, Lq(i, ...e)];
}
function Lq(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((i) => ({ useScope: i(), scopeName: i.scopeName }));
    return function (s) {
      const o = r.reduce((a, { useScope: l, scopeName: c }) => {
        const h = l(s)[`__scope${c}`];
        return { ...a, ...h };
      }, {});
      return w.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return (n.scopeName = e.scopeName), n;
}
const XO = globalThis != null && globalThis.document ? w.useLayoutEffect : () => {},
  Mq = XM["useId".toString()] || (() => {});
let Dq = 0;
function b0(t) {
  const [e, n] = w.useState(Mq());
  return (
    XO(() => {
      t || n((r) => r ?? String(Dq++));
    }, [t]),
    t || (e ? `radix-${e}` : "")
  );
}
function Ho(t) {
  const e = w.useRef(t);
  return (
    w.useEffect(() => {
      e.current = t;
    }),
    w.useMemo(
      () =>
        (...n) => {
          var r;
          return (r = e.current) === null || r === void 0 ? void 0 : r.call(e, ...n);
        },
      []
    )
  );
}
function Qq({ prop: t, defaultProp: e, onChange: n = () => {} }) {
  const [r, i] = Fq({ defaultProp: e, onChange: n }),
    s = t !== void 0,
    o = s ? t : r,
    a = Ho(n),
    l = w.useCallback(
      (c) => {
        if (s) {
          const h = typeof c == "function" ? c(t) : c;
          h !== t && a(h);
        } else i(c);
      },
      [s, t, i, a]
    );
  return [o, l];
}
function Fq({ defaultProp: t, onChange: e }) {
  const n = w.useState(t),
    [r] = n,
    i = w.useRef(r),
    s = Ho(e);
  return (
    w.useEffect(() => {
      i.current !== r && (s(r), (i.current = r));
    }, [r, i, s]),
    n
  );
}
const ky = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(Bq);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return w.createElement(HO, Tn({}, r, { ref: e }), w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null);
  }
  return w.createElement(HO, Tn({}, r, { ref: e }), n);
});
ky.displayName = "Slot";
const HO = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  return w.isValidElement(n)
    ? w.cloneElement(n, { ...jq(r, n.props), ref: e ? X$(e, n.ref) : n.ref })
    : w.Children.count(n) > 1
    ? w.Children.only(null)
    : null;
});
HO.displayName = "SlotClone";
const Vq = ({ children: t }) => w.createElement(w.Fragment, null, t);
function Bq(t) {
  return w.isValidElement(t) && t.type === Vq;
}
function jq(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
const Zq = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  pa = Zq.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? ky : e;
      return (
        w.useEffect(() => {
          window[Symbol.for("radix-ui")] = !0;
        }, []),
        w.createElement(a, Tn({}, o, { ref: i }))
      );
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function zq(t, e) {
  t && os.flushSync(() => t.dispatchEvent(e));
}
function Wq(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Ho(t);
  w.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return e.addEventListener("keydown", r), () => e.removeEventListener("keydown", r);
  }, [n, e]);
}
const qO = "dismissableLayer.update",
  Uq = "dismissableLayer.pointerDownOutside",
  Xq = "dismissableLayer.focusOutside";
let wC;
const Hq = w.createContext({ layers: new Set(), layersWithOutsidePointerEventsDisabled: new Set(), branches: new Set() }),
  qq = w.forwardRef((t, e) => {
    var n;
    const {
        disableOutsidePointerEvents: r = !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: s,
        onFocusOutside: o,
        onInteractOutside: a,
        onDismiss: l,
        ...c
      } = t,
      u = w.useContext(Hq),
      [h, f] = w.useState(null),
      d = (n = h == null ? void 0 : h.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document,
      [, p] = w.useState({}),
      m = Kl(e, (_) => f(_)),
      O = Array.from(u.layers),
      [v] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1),
      g = O.indexOf(v),
      x = h ? O.indexOf(h) : -1,
      y = u.layersWithOutsidePointerEventsDisabled.size > 0,
      S = x >= g,
      k = Yq((_) => {
        const T = _.target,
          P = [...u.branches].some((M) => M.contains(T));
        !S || P || (s == null || s(_), a == null || a(_), _.defaultPrevented || l == null || l());
      }, d),
      b = Gq((_) => {
        const T = _.target;
        [...u.branches].some((M) => M.contains(T)) || (o == null || o(_), a == null || a(_), _.defaultPrevented || l == null || l());
      }, d);
    return (
      Wq((_) => {
        x === u.layers.size - 1 && (i == null || i(_), !_.defaultPrevented && l && (_.preventDefault(), l()));
      }, d),
      w.useEffect(() => {
        if (h)
          return (
            r &&
              (u.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((wC = d.body.style.pointerEvents), (d.body.style.pointerEvents = "none")),
              u.layersWithOutsidePointerEventsDisabled.add(h)),
            u.layers.add(h),
            SC(),
            () => {
              r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = wC);
            }
          );
      }, [h, d, r, u]),
      w.useEffect(
        () => () => {
          h && (u.layers.delete(h), u.layersWithOutsidePointerEventsDisabled.delete(h), SC());
        },
        [h, u]
      ),
      w.useEffect(() => {
        const _ = () => p({});
        return document.addEventListener(qO, _), () => document.removeEventListener(qO, _);
      }, []),
      w.createElement(
        pa.div,
        Tn({}, c, {
          ref: m,
          style: { pointerEvents: y ? (S ? "auto" : "none") : void 0, ...t.style },
          onFocusCapture: Ws(t.onFocusCapture, b.onFocusCapture),
          onBlurCapture: Ws(t.onBlurCapture, b.onBlurCapture),
          onPointerDownCapture: Ws(t.onPointerDownCapture, k.onPointerDownCapture),
        })
      )
    );
  });
function Yq(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Ho(t),
    r = w.useRef(!1),
    i = w.useRef(() => {});
  return (
    w.useEffect(() => {
      const s = (a) => {
          if (a.target && !r.current) {
            let c = function () {
              H$(Uq, n, l, { discrete: !0 });
            };
            const l = { originalEvent: a };
            a.pointerType === "touch"
              ? (e.removeEventListener("click", i.current), (i.current = c), e.addEventListener("click", i.current, { once: !0 }))
              : c();
          } else e.removeEventListener("click", i.current);
          r.current = !1;
        },
        o = window.setTimeout(() => {
          e.addEventListener("pointerdown", s);
        }, 0);
      return () => {
        window.clearTimeout(o), e.removeEventListener("pointerdown", s), e.removeEventListener("click", i.current);
      };
    }, [e, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function Gq(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Ho(t),
    r = w.useRef(!1);
  return (
    w.useEffect(() => {
      const i = (s) => {
        s.target && !r.current && H$(Xq, n, { originalEvent: s }, { discrete: !1 });
      };
      return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
    }, [e, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  );
}
function SC() {
  const t = new CustomEvent(qO);
  document.dispatchEvent(t);
}
function H$(t, e, n, { discrete: r }) {
  const i = n.originalEvent.target,
    s = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && i.addEventListener(t, e, { once: !0 }), r ? zq(i, s) : i.dispatchEvent(s);
}
const y0 = "focusScope.autoFocusOnMount",
  w0 = "focusScope.autoFocusOnUnmount",
  kC = { bubbles: !1, cancelable: !0 },
  Jq = w.forwardRef((t, e) => {
    const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: s, ...o } = t,
      [a, l] = w.useState(null),
      c = Ho(i),
      u = Ho(s),
      h = w.useRef(null),
      f = Kl(e, (m) => l(m)),
      d = w.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    w.useEffect(() => {
      if (r) {
        let m = function (x) {
            if (d.paused || !a) return;
            const y = x.target;
            a.contains(y) ? (h.current = y) : Es(h.current, { select: !0 });
          },
          O = function (x) {
            if (d.paused || !a) return;
            const y = x.relatedTarget;
            y !== null && (a.contains(y) || Es(h.current, { select: !0 }));
          },
          v = function (x) {
            if (document.activeElement === document.body) for (const S of x) S.removedNodes.length > 0 && Es(a);
          };
        document.addEventListener("focusin", m), document.addEventListener("focusout", O);
        const g = new MutationObserver(v);
        return (
          a && g.observe(a, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", m), document.removeEventListener("focusout", O), g.disconnect();
          }
        );
      }
    }, [r, a, d.paused]),
      w.useEffect(() => {
        if (a) {
          _C.add(d);
          const m = document.activeElement;
          if (!a.contains(m)) {
            const v = new CustomEvent(y0, kC);
            a.addEventListener(y0, c),
              a.dispatchEvent(v),
              v.defaultPrevented || (Kq(iY(q$(a)), { select: !0 }), document.activeElement === m && Es(a));
          }
          return () => {
            a.removeEventListener(y0, c),
              setTimeout(() => {
                const v = new CustomEvent(w0, kC);
                a.addEventListener(w0, u),
                  a.dispatchEvent(v),
                  v.defaultPrevented || Es(m ?? document.body, { select: !0 }),
                  a.removeEventListener(w0, u),
                  _C.remove(d);
              }, 0);
          };
        }
      }, [a, c, u, d]);
    const p = w.useCallback(
      (m) => {
        if ((!n && !r) || d.paused) return;
        const O = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey,
          v = document.activeElement;
        if (O && v) {
          const g = m.currentTarget,
            [x, y] = eY(g);
          x && y
            ? !m.shiftKey && v === y
              ? (m.preventDefault(), n && Es(x, { select: !0 }))
              : m.shiftKey && v === x && (m.preventDefault(), n && Es(y, { select: !0 }))
            : v === g && m.preventDefault();
        }
      },
      [n, r, d.paused]
    );
    return w.createElement(pa.div, Tn({ tabIndex: -1 }, o, { ref: f, onKeyDown: p }));
  });
function Kq(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t) if ((Es(r, { select: e }), document.activeElement !== n)) return;
}
function eY(t) {
  const e = q$(t),
    n = CC(e, t),
    r = CC(e.reverse(), t);
  return [n, r];
}
function q$(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      },
    });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function CC(t, e) {
  for (const n of t) if (!tY(n, { upTo: e })) return n;
}
function tY(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function nY(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Es(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && nY(t) && e && t.select();
  }
}
const _C = rY();
function rY() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), (t = EC(t, e)), t.unshift(e);
    },
    remove(e) {
      var n;
      (t = EC(t, e)), (n = t[0]) === null || n === void 0 || n.resume();
    },
  };
}
function EC(t, e) {
  const n = [...t],
    r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function iY(t) {
  return t.filter((e) => e.tagName !== "A");
}
const sY = w.forwardRef((t, e) => {
  var n;
  const { container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body, ...i } = t;
  return r ? Ux.createPortal(w.createElement(pa.div, Tn({}, i, { ref: e })), r) : null;
});
function oY(t, e) {
  return w.useReducer((n, r) => {
    const i = e[n][r];
    return i ?? n;
  }, t);
}
const ag = (t) => {
  const { present: e, children: n } = t,
    r = aY(e),
    i = typeof n == "function" ? n({ present: r.isPresent }) : w.Children.only(n),
    s = Kl(r.ref, i.ref);
  return typeof n == "function" || r.isPresent ? w.cloneElement(i, { ref: s }) : null;
};
ag.displayName = "Presence";
function aY(t) {
  const [e, n] = w.useState(),
    r = w.useRef({}),
    i = w.useRef(t),
    s = w.useRef("none"),
    o = t ? "mounted" : "unmounted",
    [a, l] = oY(o, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    w.useEffect(() => {
      const c = kf(r.current);
      s.current = a === "mounted" ? c : "none";
    }, [a]),
    XO(() => {
      const c = r.current,
        u = i.current;
      if (u !== t) {
        const f = s.current,
          d = kf(c);
        t
          ? l("MOUNT")
          : d === "none" || (c == null ? void 0 : c.display) === "none"
          ? l("UNMOUNT")
          : l(u && f !== d ? "ANIMATION_OUT" : "UNMOUNT"),
          (i.current = t);
      }
    }, [t, l]),
    XO(() => {
      if (e) {
        const c = (h) => {
            const d = kf(r.current).includes(h.animationName);
            h.target === e && d && os.flushSync(() => l("ANIMATION_END"));
          },
          u = (h) => {
            h.target === e && (s.current = kf(r.current));
          };
        return (
          e.addEventListener("animationstart", u),
          e.addEventListener("animationcancel", c),
          e.addEventListener("animationend", c),
          () => {
            e.removeEventListener("animationstart", u),
              e.removeEventListener("animationcancel", c),
              e.removeEventListener("animationend", c);
          }
        );
      } else l("ANIMATION_END");
    }, [e, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(a),
      ref: w.useCallback((c) => {
        c && (r.current = getComputedStyle(c)), n(c);
      }, []),
    }
  );
}
function kf(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
let S0 = 0;
function lY() {
  w.useEffect(() => {
    var t, e;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement("afterbegin", (t = n[0]) !== null && t !== void 0 ? t : TC()),
      document.body.insertAdjacentElement("beforeend", (e = n[1]) !== null && e !== void 0 ? e : TC()),
      S0++,
      () => {
        S0 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((r) => r.remove()), S0--;
      }
    );
  }, []);
}
function TC() {
  const t = document.createElement("span");
  return (
    t.setAttribute("data-radix-focus-guard", ""),
    (t.tabIndex = 0),
    (t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none"),
    t
  );
}
var ru = "right-scroll-bar-position",
  iu = "width-before-scroll-bar",
  cY = "with-scroll-bars-hidden",
  uY = "--removed-body-scroll-bar-size";
function k0(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function hY(t, e) {
  var n = w.useState(function () {
    return {
      value: t,
      callback: e,
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && ((n.value = r), n.callback(r, i));
        },
      },
    };
  })[0];
  return (n.callback = e), n.facade;
}
var fY = typeof window < "u" ? w.useLayoutEffect : w.useEffect,
  PC = new WeakMap();
function Y$(t, e) {
  var n = hY(e || null, function (r) {
    return t.forEach(function (i) {
      return k0(i, r);
    });
  });
  return (
    fY(
      function () {
        var r = PC.get(n);
        if (r) {
          var i = new Set(r),
            s = new Set(t),
            o = n.current;
          i.forEach(function (a) {
            s.has(a) || k0(a, null);
          }),
            s.forEach(function (a) {
              i.has(a) || k0(a, o);
            });
        }
        PC.set(n, t);
      },
      [t]
    ),
    n
  );
}
function dY(t) {
  return t;
}
function pY(t, e) {
  e === void 0 && (e = dY);
  var n = [],
    r = !1,
    i = {
      read: function () {
        if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        return n.length ? n[n.length - 1] : t;
      },
      useMedium: function (s) {
        var o = e(s, r);
        return (
          n.push(o),
          function () {
            n = n.filter(function (a) {
              return a !== o;
            });
          }
        );
      },
      assignSyncMedium: function (s) {
        for (r = !0; n.length; ) {
          var o = n;
          (n = []), o.forEach(s);
        }
        n = {
          push: function (a) {
            return s(a);
          },
          filter: function () {
            return n;
          },
        };
      },
      assignMedium: function (s) {
        r = !0;
        var o = [];
        if (n.length) {
          var a = n;
          (n = []), a.forEach(s), (o = n);
        }
        var l = function () {
            var u = o;
            (o = []), u.forEach(s);
          },
          c = function () {
            return Promise.resolve().then(l);
          };
        c(),
          (n = {
            push: function (u) {
              o.push(u), c();
            },
            filter: function (u) {
              return (o = o.filter(u)), n;
            },
          });
      },
    };
  return i;
}
function G$(t) {
  t === void 0 && (t = {});
  var e = pY(null);
  return (e.options = kn({ async: !0, ssr: !1 }, t)), e;
}
var J$ = function (t) {
  var e = t.sideCar,
    n = Xx(t, ["sideCar"]);
  if (!e) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r) throw new Error("Sidecar medium not found");
  return w.createElement(r, kn({}, n));
};
J$.isSideCarExport = !0;
function K$(t, e) {
  return t.useMedium(e), J$;
}
var e9 = G$(),
  C0 = function () {},
  lg = w.forwardRef(function (t, e) {
    var n = w.useRef(null),
      r = w.useState({ onScrollCapture: C0, onWheelCapture: C0, onTouchMoveCapture: C0 }),
      i = r[0],
      s = r[1],
      o = t.forwardProps,
      a = t.children,
      l = t.className,
      c = t.removeScrollBar,
      u = t.enabled,
      h = t.shards,
      f = t.sideCar,
      d = t.noIsolation,
      p = t.inert,
      m = t.allowPinchZoom,
      O = t.as,
      v = O === void 0 ? "div" : O,
      g = Xx(t, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
      ]),
      x = f,
      y = Y$([n, e]),
      S = kn(kn({}, g), i);
    return w.createElement(
      w.Fragment,
      null,
      u &&
        w.createElement(x, {
          sideCar: e9,
          removeScrollBar: c,
          shards: h,
          noIsolation: d,
          inert: p,
          setCallbacks: s,
          allowPinchZoom: !!m,
          lockRef: n,
        }),
      o ? w.cloneElement(w.Children.only(a), kn(kn({}, S), { ref: y })) : w.createElement(v, kn({}, S, { className: l, ref: y }), a)
    );
  });
lg.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
lg.classNames = { fullWidth: iu, zeroRight: ru };
var mY = { left: 0, top: 0, right: 0, gap: 0 },
  _0 = function (t) {
    return parseInt(t || "", 10) || 0;
  },
  gY = function (t) {
    var e = window.getComputedStyle(document.body),
      n = e[t === "padding" ? "paddingLeft" : "marginLeft"],
      r = e[t === "padding" ? "paddingTop" : "marginTop"],
      i = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [_0(n), _0(r), _0(i)];
  },
  OY = function (t) {
    if ((t === void 0 && (t = "margin"), typeof window > "u")) return mY;
    var e = gY(t),
      n = document.documentElement.clientWidth,
      r = window.innerWidth;
    return { left: e[0], top: e[1], right: e[2], gap: Math.max(0, r - n + e[2] - e[0]) };
  },
  vY = qM(),
  rl = "data-scroll-locked",
  xY = function (t, e, n, r) {
    var i = t.left,
      s = t.top,
      o = t.right,
      a = t.gap;
    return (
      n === void 0 && (n = "margin"),
      `
  .`
        .concat(
          cY,
          ` {
   overflow: hidden `
        )
        .concat(
          r,
          `;
   padding-right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  body[`
        )
        .concat(
          rl,
          `] {
    overflow: hidden `
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            e && "position: relative ".concat(r, ";"),
            n === "margin" &&
              `
    padding-left: `
                .concat(
                  i,
                  `px;
    padding-top: `
                )
                .concat(
                  s,
                  `px;
    padding-right: `
                )
                .concat(
                  o,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(a, "px ")
                .concat(
                  r,
                  `;
    `
                ),
            n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";"),
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`
        )
        .concat(
          ru,
          ` {
    right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(
          iu,
          ` {
    margin-right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(ru, " .")
        .concat(
          ru,
          ` {
    right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(iu, " .")
        .concat(
          iu,
          ` {
    margin-right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  body[`
        )
        .concat(
          rl,
          `] {
    `
        )
        .concat(uY, ": ")
        .concat(
          a,
          `px;
  }
`
        )
    );
  },
  AC = function () {
    var t = parseInt(document.body.getAttribute(rl) || "0", 10);
    return isFinite(t) ? t : 0;
  },
  bY = function () {
    w.useEffect(function () {
      return (
        document.body.setAttribute(rl, (AC() + 1).toString()),
        function () {
          var t = AC() - 1;
          t <= 0 ? document.body.removeAttribute(rl) : document.body.setAttribute(rl, t.toString());
        }
      );
    }, []);
  },
  t9 = function (t) {
    var e = t.noRelative,
      n = t.noImportant,
      r = t.gapMode,
      i = r === void 0 ? "margin" : r;
    bY();
    var s = w.useMemo(
      function () {
        return OY(i);
      },
      [i]
    );
    return w.createElement(vY, { styles: xY(s, !e, i, n ? "" : "!important") });
  };
function yY() {
  if (!document) return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = wP();
  return e && t.setAttribute("nonce", e), t;
}
function wY(t, e) {
  t.styleSheet ? (t.styleSheet.cssText = e) : t.appendChild(document.createTextNode(e));
}
function SY(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var kY = function () {
    var t = 0,
      e = null;
    return {
      add: function (n) {
        t == 0 && (e = yY()) && (wY(e, n), SY(e)), t++;
      },
      remove: function () {
        t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), (e = null));
      },
    };
  },
  CY = function () {
    var t = kY();
    return function (e, n) {
      w.useEffect(
        function () {
          return (
            t.add(e),
            function () {
              t.remove();
            }
          );
        },
        [e && n]
      );
    };
  },
  _Y = function () {
    var t = CY(),
      e = function (n) {
        var r = n.styles,
          i = n.dynamic;
        return t(r, i), null;
      };
    return e;
  },
  YO = !1;
if (typeof window < "u")
  try {
    var Cf = Object.defineProperty({}, "passive", {
      get: function () {
        return (YO = !0), !0;
      },
    });
    window.addEventListener("test", Cf, Cf), window.removeEventListener("test", Cf, Cf);
  } catch {
    YO = !1;
  }
var ya = YO ? { passive: !1 } : !1,
  EY = function (t) {
    return t.tagName === "TEXTAREA";
  },
  n9 = function (t, e) {
    var n = window.getComputedStyle(t);
    return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !EY(t) && n[e] === "visible");
  },
  TY = function (t) {
    return n9(t, "overflowY");
  },
  PY = function (t) {
    return n9(t, "overflowX");
  },
  $C = function (t, e) {
    var n = e;
    do {
      typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
      var r = r9(t, n);
      if (r) {
        var i = i9(t, n),
          s = i[1],
          o = i[2];
        if (s > o) return !0;
      }
      n = n.parentNode;
    } while (n && n !== document.body);
    return !1;
  },
  AY = function (t) {
    var e = t.scrollTop,
      n = t.scrollHeight,
      r = t.clientHeight;
    return [e, n, r];
  },
  $Y = function (t) {
    var e = t.scrollLeft,
      n = t.scrollWidth,
      r = t.clientWidth;
    return [e, n, r];
  },
  r9 = function (t, e) {
    return t === "v" ? TY(e) : PY(e);
  },
  i9 = function (t, e) {
    return t === "v" ? AY(e) : $Y(e);
  },
  RY = function (t, e) {
    return t === "h" && e === "rtl" ? -1 : 1;
  },
  IY = function (t, e, n, r, i) {
    var s = RY(t, window.getComputedStyle(e).direction),
      o = s * r,
      a = n.target,
      l = e.contains(a),
      c = !1,
      u = o > 0,
      h = 0,
      f = 0;
    do {
      var d = i9(t, a),
        p = d[0],
        m = d[1],
        O = d[2],
        v = m - O - s * p;
      (p || v) && r9(t, a) && ((h += v), (f += p)), (a = a.parentNode);
    } while ((!l && a !== document.body) || (l && (e.contains(a) || e === a)));
    return ((u && ((i && h === 0) || (!i && o > h))) || (!u && ((i && f === 0) || (!i && -o > f)))) && (c = !0), c;
  },
  _f = function (t) {
    return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
  },
  RC = function (t) {
    return [t.deltaX, t.deltaY];
  },
  IC = function (t) {
    return t && "current" in t ? t.current : t;
  },
  NY = function (t, e) {
    return t[0] === e[0] && t[1] === e[1];
  },
  LY = function (t) {
    return `
  .block-interactivity-`
      .concat(
        t,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        t,
        ` {pointer-events: all;}
`
      );
  },
  MY = 0,
  wa = [];
function DY(t) {
  var e = w.useRef([]),
    n = w.useRef([0, 0]),
    r = w.useRef(),
    i = w.useState(MY++)[0],
    s = w.useState(function () {
      return _Y();
    })[0],
    o = w.useRef(t);
  w.useEffect(
    function () {
      o.current = t;
    },
    [t]
  ),
    w.useEffect(
      function () {
        if (t.inert) {
          document.body.classList.add("block-interactivity-".concat(i));
          var m = SP([t.lockRef.current], (t.shards || []).map(IC), !0).filter(Boolean);
          return (
            m.forEach(function (O) {
              return O.classList.add("allow-interactivity-".concat(i));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(i)),
                m.forEach(function (O) {
                  return O.classList.remove("allow-interactivity-".concat(i));
                });
            }
          );
        }
      },
      [t.inert, t.lockRef.current, t.shards]
    );
  var a = w.useCallback(function (m, O) {
      if ("touches" in m && m.touches.length === 2) return !o.current.allowPinchZoom;
      var v = _f(m),
        g = n.current,
        x = "deltaX" in m ? m.deltaX : g[0] - v[0],
        y = "deltaY" in m ? m.deltaY : g[1] - v[1],
        S,
        k = m.target,
        b = Math.abs(x) > Math.abs(y) ? "h" : "v";
      if ("touches" in m && b === "h" && k.type === "range") return !1;
      var _ = $C(b, k);
      if (!_) return !0;
      if ((_ ? (S = b) : ((S = b === "v" ? "h" : "v"), (_ = $C(b, k))), !_)) return !1;
      if ((!r.current && "changedTouches" in m && (x || y) && (r.current = S), !S)) return !0;
      var T = r.current || S;
      return IY(T, O, m, T === "h" ? x : y, !0);
    }, []),
    l = w.useCallback(function (m) {
      var O = m;
      if (!(!wa.length || wa[wa.length - 1] !== s)) {
        var v = "deltaY" in O ? RC(O) : _f(O),
          g = e.current.filter(function (S) {
            return S.name === O.type && S.target === O.target && NY(S.delta, v);
          })[0];
        if (g && g.should) {
          O.cancelable && O.preventDefault();
          return;
        }
        if (!g) {
          var x = (o.current.shards || [])
              .map(IC)
              .filter(Boolean)
              .filter(function (S) {
                return S.contains(O.target);
              }),
            y = x.length > 0 ? a(O, x[0]) : !o.current.noIsolation;
          y && O.cancelable && O.preventDefault();
        }
      }
    }, []),
    c = w.useCallback(function (m, O, v, g) {
      var x = { name: m, delta: O, target: v, should: g };
      e.current.push(x),
        setTimeout(function () {
          e.current = e.current.filter(function (y) {
            return y !== x;
          });
        }, 1);
    }, []),
    u = w.useCallback(function (m) {
      (n.current = _f(m)), (r.current = void 0);
    }, []),
    h = w.useCallback(function (m) {
      c(m.type, RC(m), m.target, a(m, t.lockRef.current));
    }, []),
    f = w.useCallback(function (m) {
      c(m.type, _f(m), m.target, a(m, t.lockRef.current));
    }, []);
  w.useEffect(function () {
    return (
      wa.push(s),
      t.setCallbacks({ onScrollCapture: h, onWheelCapture: h, onTouchMoveCapture: f }),
      document.addEventListener("wheel", l, ya),
      document.addEventListener("touchmove", l, ya),
      document.addEventListener("touchstart", u, ya),
      function () {
        (wa = wa.filter(function (m) {
          return m !== s;
        })),
          document.removeEventListener("wheel", l, ya),
          document.removeEventListener("touchmove", l, ya),
          document.removeEventListener("touchstart", u, ya);
      }
    );
  }, []);
  var d = t.removeScrollBar,
    p = t.inert;
  return w.createElement(
    w.Fragment,
    null,
    p ? w.createElement(s, { styles: LY(i) }) : null,
    d ? w.createElement(t9, { gapMode: "margin" }) : null
  );
}
const QY = K$(e9, DY);
var s9 = w.forwardRef(function (t, e) {
  return w.createElement(lg, kn({}, t, { ref: e, sideCar: QY }));
});
s9.classNames = lg.classNames;
const FY = s9,
  o9 = "Dialog",
  [a9, Bve] = Nq(o9),
  [VY, Di] = a9(o9),
  BY = (t) => {
    const { __scopeDialog: e, children: n, open: r, defaultOpen: i, onOpenChange: s, modal: o = !0 } = t,
      a = w.useRef(null),
      l = w.useRef(null),
      [c = !1, u] = Qq({ prop: r, defaultProp: i, onChange: s });
    return w.createElement(
      VY,
      {
        scope: e,
        triggerRef: a,
        contentRef: l,
        contentId: b0(),
        titleId: b0(),
        descriptionId: b0(),
        open: c,
        onOpenChange: u,
        onOpenToggle: w.useCallback(() => u((h) => !h), [u]),
        modal: o,
      },
      n
    );
  },
  jY = "DialogTrigger",
  ZY = w.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      i = Di(jY, n),
      s = Kl(e, i.triggerRef);
    return w.createElement(
      pa.button,
      Tn(
        { type: "button", "aria-haspopup": "dialog", "aria-expanded": i.open, "aria-controls": i.contentId, "data-state": Cy(i.open) },
        r,
        { ref: s, onClick: Ws(t.onClick, i.onOpenToggle) }
      )
    );
  }),
  l9 = "DialogPortal",
  [zY, c9] = a9(l9, { forceMount: void 0 }),
  WY = (t) => {
    const { __scopeDialog: e, forceMount: n, children: r, container: i } = t,
      s = Di(l9, e);
    return w.createElement(
      zY,
      { scope: e, forceMount: n },
      w.Children.map(r, (o) => w.createElement(ag, { present: n || s.open }, w.createElement(sY, { asChild: !0, container: i }, o)))
    );
  },
  GO = "DialogOverlay",
  UY = w.forwardRef((t, e) => {
    const n = c9(GO, t.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = t,
      s = Di(GO, t.__scopeDialog);
    return s.modal ? w.createElement(ag, { present: r || s.open }, w.createElement(XY, Tn({}, i, { ref: e }))) : null;
  }),
  XY = w.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      i = Di(GO, n);
    return w.createElement(
      FY,
      { as: ky, allowPinchZoom: !0, shards: [i.contentRef] },
      w.createElement(pa.div, Tn({ "data-state": Cy(i.open) }, r, { ref: e, style: { pointerEvents: "auto", ...r.style } }))
    );
  }),
  Pu = "DialogContent",
  HY = w.forwardRef((t, e) => {
    const n = c9(Pu, t.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = t,
      s = Di(Pu, t.__scopeDialog);
    return w.createElement(
      ag,
      { present: r || s.open },
      s.modal ? w.createElement(qY, Tn({}, i, { ref: e })) : w.createElement(YY, Tn({}, i, { ref: e }))
    );
  }),
  qY = w.forwardRef((t, e) => {
    const n = Di(Pu, t.__scopeDialog),
      r = w.useRef(null),
      i = Kl(e, n.contentRef, r);
    return (
      w.useEffect(() => {
        const s = r.current;
        if (s) return kP(s);
      }, []),
      w.createElement(
        u9,
        Tn({}, t, {
          ref: i,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Ws(t.onCloseAutoFocus, (s) => {
            var o;
            s.preventDefault(), (o = n.triggerRef.current) === null || o === void 0 || o.focus();
          }),
          onPointerDownOutside: Ws(t.onPointerDownOutside, (s) => {
            const o = s.detail.originalEvent,
              a = o.button === 0 && o.ctrlKey === !0;
            (o.button === 2 || a) && s.preventDefault();
          }),
          onFocusOutside: Ws(t.onFocusOutside, (s) => s.preventDefault()),
        })
      )
    );
  }),
  YY = w.forwardRef((t, e) => {
    const n = Di(Pu, t.__scopeDialog),
      r = w.useRef(!1),
      i = w.useRef(!1);
    return w.createElement(
      u9,
      Tn({}, t, {
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var o;
          if (((o = t.onCloseAutoFocus) === null || o === void 0 || o.call(t, s), !s.defaultPrevented)) {
            var a;
            r.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus(), s.preventDefault();
          }
          (r.current = !1), (i.current = !1);
        },
        onInteractOutside: (s) => {
          var o, a;
          (o = t.onInteractOutside) === null || o === void 0 || o.call(t, s),
            s.defaultPrevented || ((r.current = !0), s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const l = s.target;
          ((a = n.triggerRef.current) === null || a === void 0 ? void 0 : a.contains(l)) && s.preventDefault(),
            s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        },
      })
    );
  }),
  u9 = w.forwardRef((t, e) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: s, ...o } = t,
      a = Di(Pu, n),
      l = w.useRef(null),
      c = Kl(e, l);
    return (
      lY(),
      w.createElement(
        w.Fragment,
        null,
        w.createElement(
          Jq,
          { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: i, onUnmountAutoFocus: s },
          w.createElement(
            qq,
            Tn(
              {
                role: "dialog",
                id: a.contentId,
                "aria-describedby": a.descriptionId,
                "aria-labelledby": a.titleId,
                "data-state": Cy(a.open),
              },
              o,
              { ref: c, onDismiss: () => a.onOpenChange(!1) }
            )
          )
        ),
        !1
      )
    );
  }),
  GY = "DialogTitle",
  JY = w.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      i = Di(GY, n);
    return w.createElement(pa.h2, Tn({ id: i.titleId }, r, { ref: e }));
  }),
  KY = "DialogClose",
  eG = w.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      i = Di(KY, n);
    return w.createElement(pa.button, Tn({ type: "button" }, r, { ref: e, onClick: Ws(t.onClick, () => i.onOpenChange(!1)) }));
  });
function Cy(t) {
  return t ? "open" : "closed";
}
const _y = BY,
  tG = ZY,
  Ey = WY,
  Ty = UY,
  Py = HY,
  nG = JY,
  Ay = eG;
function Qc(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r)) {
      if (e.indexOf(r) >= 0) continue;
      n[r] = t[r];
    }
  return n;
}
function It() {
  return (
    (It = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    It.apply(null, arguments)
  );
}
var Ct = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cg = 60103,
  ug = 60106,
  Nh = 60107,
  Lh = 60108,
  Mh = 60114,
  Dh = 60109,
  Qh = 60110,
  Fh = 60112,
  Vh = 60113,
  $y = 60120,
  Bh = 60115,
  jh = 60116,
  h9 = 60121,
  f9 = 60122,
  d9 = 60117,
  p9 = 60129,
  m9 = 60131;
if (typeof Symbol == "function" && Symbol.for) {
  var fn = Symbol.for;
  (cg = fn("react.element")),
    (ug = fn("react.portal")),
    (Nh = fn("react.fragment")),
    (Lh = fn("react.strict_mode")),
    (Mh = fn("react.profiler")),
    (Dh = fn("react.provider")),
    (Qh = fn("react.context")),
    (Fh = fn("react.forward_ref")),
    (Vh = fn("react.suspense")),
    ($y = fn("react.suspense_list")),
    (Bh = fn("react.memo")),
    (jh = fn("react.lazy")),
    (h9 = fn("react.block")),
    (f9 = fn("react.server.block")),
    (d9 = fn("react.fundamental")),
    (p9 = fn("react.debug_trace_mode")),
    (m9 = fn("react.legacy_hidden"));
}
function oi(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case cg:
        switch (((t = t.type), t)) {
          case Nh:
          case Mh:
          case Lh:
          case Vh:
          case $y:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case Qh:
              case Fh:
              case jh:
              case Bh:
              case Dh:
                return t;
              default:
                return e;
            }
        }
      case ug:
        return e;
    }
  }
}
var rG = Dh,
  iG = cg,
  sG = Fh,
  oG = Nh,
  aG = jh,
  lG = Bh,
  cG = ug,
  uG = Mh,
  hG = Lh,
  fG = Vh;
Ct.ContextConsumer = Qh;
Ct.ContextProvider = rG;
Ct.Element = iG;
Ct.ForwardRef = sG;
Ct.Fragment = oG;
Ct.Lazy = aG;
Ct.Memo = lG;
Ct.Portal = cG;
Ct.Profiler = uG;
Ct.StrictMode = hG;
Ct.Suspense = fG;
Ct.isAsyncMode = function () {
  return !1;
};
Ct.isConcurrentMode = function () {
  return !1;
};
Ct.isContextConsumer = function (t) {
  return oi(t) === Qh;
};
Ct.isContextProvider = function (t) {
  return oi(t) === Dh;
};
Ct.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === cg;
};
Ct.isForwardRef = function (t) {
  return oi(t) === Fh;
};
Ct.isFragment = function (t) {
  return oi(t) === Nh;
};
Ct.isLazy = function (t) {
  return oi(t) === jh;
};
Ct.isMemo = function (t) {
  return oi(t) === Bh;
};
Ct.isPortal = function (t) {
  return oi(t) === ug;
};
Ct.isProfiler = function (t) {
  return oi(t) === Mh;
};
Ct.isStrictMode = function (t) {
  return oi(t) === Lh;
};
Ct.isSuspense = function (t) {
  return oi(t) === Vh;
};
Ct.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === Nh ||
    t === Mh ||
    t === p9 ||
    t === Lh ||
    t === Vh ||
    t === $y ||
    t === m9 ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === jh ||
        t.$$typeof === Bh ||
        t.$$typeof === Dh ||
        t.$$typeof === Qh ||
        t.$$typeof === Fh ||
        t.$$typeof === d9 ||
        t.$$typeof === h9 ||
        t[0] === f9))
  );
};
Ct.typeOf = oi;
let NC = (t) => typeof t == "object" && t != null && t.nodeType === 1,
  LC = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip",
  E0 = (t, e) => {
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
      let n = getComputedStyle(t, null);
      return (
        LC(n.overflowY, e) ||
        LC(n.overflowX, e) ||
        ((r) => {
          let i = ((s) => {
            if (!s.ownerDocument || !s.ownerDocument.defaultView) return null;
            try {
              return s.ownerDocument.defaultView.frameElement;
            } catch {
              return null;
            }
          })(r);
          return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth);
        })(t)
      );
    }
    return !1;
  },
  Ef = (t, e, n, r, i, s, o, a) =>
    (s < t && o > e) || (s > t && o < e)
      ? 0
      : (s <= t && a <= n) || (o >= e && a >= n)
      ? s - t - r
      : (o > e && a < n) || (s < t && a > n)
      ? o - e + i
      : 0,
  dG = (t) => {
    let e = t.parentElement;
    return e ?? (t.getRootNode().host || null);
  };
var pG = (t, e) => {
    var n, r, i, s, o, a;
    if (typeof document > "u") return [];
    let { scrollMode: l, block: c, inline: u, boundary: h, skipOverflowHiddenElements: f } = e,
      d = typeof h == "function" ? h : (Q) => Q !== h;
    if (!NC(t)) throw new TypeError("Invalid target");
    let p = document.scrollingElement || document.documentElement,
      m = [],
      O = t;
    for (; NC(O) && d(O); ) {
      if (((O = dG(O)), O === p)) {
        m.push(O);
        break;
      }
      (O != null && O === document.body && E0(O) && !E0(document.documentElement)) || (O != null && E0(O, f) && m.push(O));
    }
    let v = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth,
      g = (s = (i = window.visualViewport) == null ? void 0 : i.height) != null ? s : innerHeight,
      x = (o = window.scrollX) != null ? o : pageXOffset,
      y = (a = window.scrollY) != null ? a : pageYOffset,
      { height: S, width: k, top: b, right: _, bottom: T, left: P } = t.getBoundingClientRect(),
      M = c === "start" || c === "nearest" ? b : c === "end" ? T : b + S / 2,
      D = u === "center" ? P + k / 2 : u === "end" ? _ : P,
      V = [];
    for (let Q = 0; Q < m.length; Q++) {
      let N = m[Q],
        { height: G, width: H, top: te, right: le, bottom: $, left: B } = N.getBoundingClientRect();
      if (l === "if-needed" && b >= 0 && P >= 0 && T <= g && _ <= v && b >= te && T <= $ && P >= B && _ <= le) return V;
      let ie = getComputedStyle(N),
        L = parseInt(ie.borderLeftWidth, 10),
        pe = parseInt(ie.borderTopWidth, 10),
        Ce = parseInt(ie.borderRightWidth, 10),
        me = parseInt(ie.borderBottomWidth, 10),
        Y = 0,
        q = 0,
        se = "offsetWidth" in N ? N.offsetWidth - N.clientWidth - L - Ce : 0,
        ue = "offsetHeight" in N ? N.offsetHeight - N.clientHeight - pe - me : 0,
        ve = "offsetWidth" in N ? (N.offsetWidth === 0 ? 0 : H / N.offsetWidth) : 0,
        Pe = "offsetHeight" in N ? (N.offsetHeight === 0 ? 0 : G / N.offsetHeight) : 0;
      if (p === N)
        (Y = c === "start" ? M : c === "end" ? M - g : c === "nearest" ? Ef(y, y + g, g, pe, me, y + M, y + M + S, S) : M - g / 2),
          (q = u === "start" ? D : u === "center" ? D - v / 2 : u === "end" ? D - v : Ef(x, x + v, v, L, Ce, x + D, x + D + k, k)),
          (Y = Math.max(0, Y + y)),
          (q = Math.max(0, q + x));
      else {
        (Y =
          c === "start"
            ? M - te - pe
            : c === "end"
            ? M - $ + me + ue
            : c === "nearest"
            ? Ef(te, $, G, pe, me + ue, M, M + S, S)
            : M - (te + G / 2) + ue / 2),
          (q =
            u === "start"
              ? D - B - L
              : u === "center"
              ? D - (B + H / 2) + se / 2
              : u === "end"
              ? D - le + Ce + se
              : Ef(B, le, H, L, Ce + se, D, D + k, k));
        let { scrollLeft: Fe, scrollTop: rt } = N;
        (Y = Math.max(0, Math.min(rt + Y / Pe, N.scrollHeight - G / Pe + ue))),
          (q = Math.max(0, Math.min(Fe + q / ve, N.scrollWidth - H / ve + se))),
          (M += rt - Y),
          (D += Fe - q);
      }
      V.push({ el: N, top: Y, left: q });
    }
    return V;
  },
  mG = 0;
function Ry() {}
function gG(t, e) {
  if (t) {
    var n = pG(t, { boundary: e, block: "nearest", scrollMode: "if-needed" });
    n.forEach(function (r) {
      var i = r.el,
        s = r.top,
        o = r.left;
      (i.scrollTop = s), (i.scrollLeft = o);
    });
  }
}
function MC(t, e, n) {
  var r = t === e || (e instanceof n.Node && t.contains && t.contains(e));
  return r;
}
function g9(t, e) {
  var n;
  function r() {
    n && clearTimeout(n);
  }
  function i() {
    for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++) o[a] = arguments[a];
    r(),
      (n = setTimeout(function () {
        (n = null), t.apply(void 0, o);
      }, e));
  }
  return (i.cancel = r), i;
}
function Ui() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
  return function (r) {
    for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) s[o - 1] = arguments[o];
    return e.some(function (a) {
      return (
        a && a.apply(void 0, [r].concat(s)),
        r.preventDownshiftDefault || (r.hasOwnProperty("nativeEvent") && r.nativeEvent.preventDownshiftDefault)
      );
    });
  };
}
function Tf() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
  return function (r) {
    e.forEach(function (i) {
      typeof i == "function" ? i(r) : i && (i.current = r);
    });
  };
}
function OG() {
  return String(mG++);
}
function vG(t) {
  var e = t.isOpen,
    n = t.resultCount,
    r = t.previousResultCount;
  return e
    ? n
      ? n !== r
        ? n + " result" + (n === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select."
        : ""
      : "No results are available."
    : "";
}
function JO(t, e) {
  return Object.keys(t).reduce(function (n, r) {
    return (n[r] = O9(e, r) ? e[r] : t[r]), n;
  }, {});
}
function O9(t, e) {
  return t[e] !== void 0;
}
function xG(t) {
  var e = t.key,
    n = t.keyCode;
  return n >= 37 && n <= 40 && e.indexOf("Arrow") !== 0 ? "Arrow" + e : e;
}
function Pf(t, e, n, r, i) {
  if ((i === void 0 && (i = !0), n === 0)) return -1;
  var s = n - 1;
  (typeof e != "number" || e < 0 || e >= n) && (e = t > 0 ? -1 : s + 1);
  var o = e + t;
  o < 0 ? (o = i ? s : 0) : o > s && (o = i ? 0 : s);
  var a = Au(t, o, n, r, i);
  return a === -1 ? (e >= n ? -1 : e) : a;
}
function Au(t, e, n, r, i) {
  var s = r(e);
  if (!s || !s.hasAttribute("disabled")) return e;
  if (t > 0) {
    for (var o = e + 1; o < n; o++) if (!r(o).hasAttribute("disabled")) return o;
  } else for (var a = e - 1; a >= 0; a--) if (!r(a).hasAttribute("disabled")) return a;
  return i ? (t > 0 ? Au(1, 0, n, r, !1) : Au(-1, n - 1, n, r, !1)) : -1;
}
function DC(t, e, n, r) {
  return (
    r === void 0 && (r = !0),
    e.some(function (i) {
      return i && (MC(i, t, n) || (r && MC(i, n.document.activeElement, n)));
    })
  );
}
var bG = g9(function (t) {
  v9(t).textContent = "";
}, 500);
function yG(t, e) {
  var n = v9(e);
  t && ((n.textContent = t), bG(e));
}
function v9(t) {
  t === void 0 && (t = document);
  var e = t.getElementById("a11y-status-message");
  return (
    e ||
    ((e = t.createElement("div")),
    e.setAttribute("id", "a11y-status-message"),
    e.setAttribute("role", "status"),
    e.setAttribute("aria-live", "polite"),
    e.setAttribute("aria-relevant", "additions text"),
    Object.assign(e.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
    }),
    t.body.appendChild(e),
    e)
  );
}
var wG = ["isInitialMount", "highlightedIndex", "items", "environment"],
  x9 = { highlightedIndex: -1, isOpen: !1, selectedItem: null, inputValue: "" };
function SG(t, e, n) {
  var r = t.props,
    i = t.type,
    s = {};
  Object.keys(e).forEach(function (o) {
    kG(o, t, e, n), n[o] !== e[o] && (s[o] = n[o]);
  }),
    r.onStateChange && Object.keys(s).length && r.onStateChange(It({ type: i }, s));
}
function kG(t, e, n, r) {
  var i = e.props,
    s = e.type,
    o = "on" + Iy(t) + "Change";
  i[o] && r[t] !== void 0 && r[t] !== n[t] && i[o](It({ type: s }, r));
}
function CG(t, e) {
  return e.changes;
}
function _G(t) {
  var e = t.selectedItem,
    n = t.itemToString;
  return e ? n(e) + " has been selected." : "";
}
var EG = g9(function (t, e) {
    yG(t(), e);
  }, 200),
  TG = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? w.useLayoutEffect : w.useEffect;
function PG(t) {
  var e = t.id,
    n = e === void 0 ? "downshift-" + OG() : e,
    r = t.labelId,
    i = t.menuId,
    s = t.getItemId,
    o = t.toggleButtonId,
    a = t.inputId,
    l = w.useRef({
      labelId: r || n + "-label",
      menuId: i || n + "-menu",
      getItemId:
        s ||
        function (c) {
          return n + "-item-" + c;
        },
      toggleButtonId: o || n + "-toggle-button",
      inputId: a || n + "-input",
    });
  return l.current;
}
function AG(t, e, n, r) {
  var i, s;
  if (t === void 0) {
    if (e === void 0) throw new Error(r);
    (i = n[e]), (s = e);
  } else (s = e === void 0 ? n.indexOf(t) : e), (i = t);
  return [i, s];
}
function $G(t) {
  return t ? String(t) : "";
}
function Iy(t) {
  return "" + t.slice(0, 1).toUpperCase() + t.slice(1);
}
function b9(t) {
  var e = w.useRef(t);
  return (e.current = t), e;
}
function RG(t, e, n) {
  var r = w.useRef(),
    i = w.useRef(),
    s = w.useCallback(
      function (f, d) {
        (i.current = d), (f = JO(f, d.props));
        var p = t(f, d),
          m = d.props.stateReducer(f, It({}, d, { changes: p }));
        return m;
      },
      [t]
    ),
    o = w.useReducer(s, e),
    a = o[0],
    l = o[1],
    c = b9(n),
    u = w.useCallback(
      function (f) {
        return l(It({ props: c.current }, f));
      },
      [c]
    ),
    h = i.current;
  return (
    w.useEffect(
      function () {
        h && r.current && r.current !== a && SG(h, JO(r.current, h.props), a), (r.current = a);
      },
      [a, n, h]
    ),
    [a, u]
  );
}
var su = {
  itemToString: $G,
  stateReducer: CG,
  getA11ySelectionMessage: _G,
  scrollIntoView: gG,
  environment: typeof window > "u" ? {} : window,
};
function ki(t, e, n) {
  n === void 0 && (n = x9);
  var r = t["default" + Iy(e)];
  return r !== void 0 ? r : n[e];
}
function Af(t, e, n) {
  n === void 0 && (n = x9);
  var r = t[e];
  if (r !== void 0) return r;
  var i = t["initial" + Iy(e)];
  return i !== void 0 ? i : ki(t, e, n);
}
function IG(t) {
  var e = Af(t, "selectedItem"),
    n = Af(t, "isOpen"),
    r = Af(t, "highlightedIndex"),
    i = Af(t, "inputValue");
  return { highlightedIndex: r < 0 && e && n ? t.items.indexOf(e) : r, isOpen: n, selectedItem: e, inputValue: i };
}
function ou(t, e, n) {
  var r = t.items,
    i = t.initialHighlightedIndex,
    s = t.defaultHighlightedIndex,
    o = e.selectedItem,
    a = e.highlightedIndex;
  return r.length === 0 ? -1 : i !== void 0 && a === i ? i : s !== void 0 ? s : o ? r.indexOf(o) : n === 0 ? -1 : n < 0 ? r.length - 1 : 0;
}
function NG(t, e, n, r) {
  var i = w.useRef({ isMouseDown: !1, isTouchMove: !1 });
  return (
    w.useEffect(
      function () {
        if ((n == null ? void 0 : n.addEventListener) != null) {
          var s = function () {
              i.current.isMouseDown = !0;
            },
            o = function (h) {
              (i.current.isMouseDown = !1),
                t &&
                  !DC(
                    h.target,
                    e.map(function (f) {
                      return f.current;
                    }),
                    n
                  ) &&
                  r();
            },
            a = function () {
              i.current.isTouchMove = !1;
            },
            l = function () {
              i.current.isTouchMove = !0;
            },
            c = function (h) {
              t &&
                !i.current.isTouchMove &&
                !DC(
                  h.target,
                  e.map(function (f) {
                    return f.current;
                  }),
                  n,
                  !1
                ) &&
                r();
            };
          return (
            n.addEventListener("mousedown", s),
            n.addEventListener("mouseup", o),
            n.addEventListener("touchstart", a),
            n.addEventListener("touchmove", l),
            n.addEventListener("touchend", c),
            function () {
              n.removeEventListener("mousedown", s),
                n.removeEventListener("mouseup", o),
                n.removeEventListener("touchstart", a),
                n.removeEventListener("touchmove", l),
                n.removeEventListener("touchend", c);
            }
          );
        }
      },
      [t, n]
    ),
    i
  );
}
var LG = function () {
  return Ry;
};
function QC(t, e, n) {
  var r = n.isInitialMount,
    i = n.highlightedIndex,
    s = n.items,
    o = n.environment,
    a = Qc(n, wG);
  w.useEffect(function () {
    r ||
      EG(function () {
        return t(It({ highlightedIndex: i, highlightedItem: s[i], resultCount: s.length }, a));
      }, o.document);
  }, e);
}
function MG(t) {
  var e = t.highlightedIndex,
    n = t.isOpen,
    r = t.itemRefs,
    i = t.getItemNodeFromIndex,
    s = t.menuElement,
    o = t.scrollIntoView,
    a = w.useRef(!0);
  return (
    TG(
      function () {
        e < 0 || !n || !Object.keys(r.current).length || (a.current === !1 ? (a.current = !0) : o(i(e), s));
      },
      [e]
    ),
    a
  );
}
var DG = Ry;
function FC(t, e, n) {
  var r;
  n === void 0 && (n = !0);
  var i = ((r = t.items) == null ? void 0 : r.length) && e >= 0;
  return It(
    { isOpen: !1, highlightedIndex: -1 },
    i &&
      It(
        { selectedItem: t.items[e], isOpen: ki(t, "isOpen"), highlightedIndex: ki(t, "highlightedIndex") },
        n && { inputValue: t.itemToString(t.items[e]) }
      )
  );
}
function QG(t, e, n) {
  var r = e.type,
    i = e.props,
    s;
  switch (r) {
    case n.ItemMouseMove:
      s = { highlightedIndex: e.disabled ? -1 : e.index };
      break;
    case n.MenuMouseLeave:
      s = { highlightedIndex: -1 };
      break;
    case n.ToggleButtonClick:
    case n.FunctionToggleMenu:
      s = { isOpen: !t.isOpen, highlightedIndex: t.isOpen ? -1 : ou(i, t, 0) };
      break;
    case n.FunctionOpenMenu:
      s = { isOpen: !0, highlightedIndex: ou(i, t, 0) };
      break;
    case n.FunctionCloseMenu:
      s = { isOpen: !1 };
      break;
    case n.FunctionSetHighlightedIndex:
      s = { highlightedIndex: e.highlightedIndex };
      break;
    case n.FunctionSetInputValue:
      s = { inputValue: e.inputValue };
      break;
    case n.FunctionReset:
      s = {
        highlightedIndex: ki(i, "highlightedIndex"),
        isOpen: ki(i, "isOpen"),
        selectedItem: ki(i, "selectedItem"),
        inputValue: ki(i, "inputValue"),
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return It({}, t, s);
}
ae.array.isRequired,
  ae.func,
  ae.func,
  ae.func,
  ae.number,
  ae.number,
  ae.number,
  ae.bool,
  ae.bool,
  ae.bool,
  ae.any,
  ae.any,
  ae.any,
  ae.string,
  ae.string,
  ae.string,
  ae.func,
  ae.string,
  ae.func,
  ae.func,
  ae.func,
  ae.func,
  ae.func,
  ae.shape({
    addEventListener: ae.func,
    removeEventListener: ae.func,
    document: ae.shape({ getElementById: ae.func, activeElement: ae.any, body: ae.any }),
  });
function FG(t) {
  var e = t.isOpen,
    n = t.resultCount,
    r = t.previousResultCount;
  return e
    ? n
      ? n !== r
        ? ""
            .concat(n, " result")
            .concat(
              n === 1 ? " is" : "s are",
              " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select."
            )
        : ""
      : "No results are available."
    : "";
}
kn(kn({}, su), { getA11yStatusMessage: FG });
var Ny = 0,
  Ly = 1,
  My = 2,
  Dy = 3,
  Qy = 4,
  Fy = 5,
  Vy = 6,
  By = 7,
  jy = 8,
  bp = 9,
  Zy = 10,
  y9 = 11,
  w9 = 12,
  zy = 13,
  S9 = 14,
  k9 = 15,
  C9 = 16,
  _9 = 17,
  E9 = 18,
  Wy = 19,
  T9 = 20,
  P9 = 21,
  Uy = 22,
  A9 = Object.freeze({
    __proto__: null,
    InputKeyDownArrowDown: Ny,
    InputKeyDownArrowUp: Ly,
    InputKeyDownEscape: My,
    InputKeyDownHome: Dy,
    InputKeyDownEnd: Qy,
    InputKeyDownPageUp: Fy,
    InputKeyDownPageDown: Vy,
    InputKeyDownEnter: By,
    InputChange: jy,
    InputBlur: bp,
    InputFocus: Zy,
    MenuMouseLeave: y9,
    ItemMouseMove: w9,
    ItemClick: zy,
    ToggleButtonClick: S9,
    FunctionToggleMenu: k9,
    FunctionOpenMenu: C9,
    FunctionCloseMenu: _9,
    FunctionSetHighlightedIndex: E9,
    FunctionSelectItem: Wy,
    FunctionSetInputValue: T9,
    FunctionReset: P9,
    ControlledPropUpdatedSelectedItem: Uy,
  });
function VG(t) {
  var e = IG(t),
    n = e.selectedItem,
    r = e.inputValue;
  return (
    r === "" && n && t.defaultInputValue === void 0 && t.initialInputValue === void 0 && t.inputValue === void 0 && (r = t.itemToString(n)),
    It({}, e, { inputValue: r })
  );
}
ae.array.isRequired,
  ae.func,
  ae.func,
  ae.func,
  ae.func,
  ae.number,
  ae.number,
  ae.number,
  ae.bool,
  ae.bool,
  ae.bool,
  ae.any,
  ae.any,
  ae.any,
  ae.string,
  ae.string,
  ae.string,
  ae.string,
  ae.string,
  ae.string,
  ae.func,
  ae.string,
  ae.string,
  ae.func,
  ae.func,
  ae.func,
  ae.func,
  ae.func,
  ae.func,
  ae.shape({
    addEventListener: ae.func,
    removeEventListener: ae.func,
    document: ae.shape({ getElementById: ae.func, activeElement: ae.any, body: ae.any }),
  });
function BG(t, e, n) {
  var r = w.useRef(),
    i = RG(t, e, n),
    s = i[0],
    o = i[1];
  return (
    w.useEffect(
      function () {
        O9(n, "selectedItem") &&
          (n.selectedItemChanged(r.current, n.selectedItem) && o({ type: Uy, inputValue: n.itemToString(n.selectedItem) }),
          (r.current = s.selectedItem === r.current ? n.selectedItem : s.selectedItem));
      },
      [s.selectedItem, n.selectedItem]
    ),
    [JO(s, n), o]
  );
}
var jG = Ry,
  ZG = It({}, su, {
    selectedItemChanged: function (e, n) {
      return e !== n;
    },
    getA11yStatusMessage: vG,
  });
function zG(t, e) {
  var n,
    r = e.type,
    i = e.props,
    s = e.altKey,
    o;
  switch (r) {
    case zy:
      o = {
        isOpen: ki(i, "isOpen"),
        highlightedIndex: ki(i, "highlightedIndex"),
        selectedItem: i.items[e.index],
        inputValue: i.itemToString(i.items[e.index]),
      };
      break;
    case Ny:
      t.isOpen
        ? (o = { highlightedIndex: Pf(1, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !0) })
        : (o = { highlightedIndex: s && t.selectedItem == null ? -1 : ou(i, t, 1, e.getItemNodeFromIndex), isOpen: i.items.length >= 0 });
      break;
    case Ly:
      t.isOpen
        ? s
          ? (o = FC(i, t.highlightedIndex))
          : (o = { highlightedIndex: Pf(-1, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !0) })
        : (o = { highlightedIndex: ou(i, t, -1, e.getItemNodeFromIndex), isOpen: i.items.length >= 0 });
      break;
    case By:
      o = FC(i, t.highlightedIndex);
      break;
    case My:
      o = It({ isOpen: !1, highlightedIndex: -1 }, !t.isOpen && { selectedItem: null, inputValue: "" });
      break;
    case Fy:
      o = { highlightedIndex: Pf(-10, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case Vy:
      o = { highlightedIndex: Pf(10, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case Dy:
      o = { highlightedIndex: Au(1, 0, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case Qy:
      o = { highlightedIndex: Au(-1, i.items.length - 1, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case bp:
      o = It(
        { isOpen: !1, highlightedIndex: -1 },
        t.highlightedIndex >= 0 &&
          ((n = i.items) == null ? void 0 : n.length) &&
          e.selectItem && { selectedItem: i.items[t.highlightedIndex], inputValue: i.itemToString(i.items[t.highlightedIndex]) }
      );
      break;
    case jy:
      o = { isOpen: !0, highlightedIndex: ki(i, "highlightedIndex"), inputValue: e.inputValue };
      break;
    case Zy:
      o = { isOpen: !0, highlightedIndex: ou(i, t, 0) };
      break;
    case Wy:
      o = { selectedItem: e.selectedItem, inputValue: i.itemToString(e.selectedItem) };
      break;
    case Uy:
      o = { inputValue: e.inputValue };
      break;
    default:
      return QG(t, e, A9);
  }
  return It({}, t, o);
}
var WG = ["onMouseLeave", "refKey", "ref"],
  UG = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"],
  XG = ["onClick", "onPress", "refKey", "ref"],
  HG = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
Xy.stateChangeTypes = A9;
function Xy(t) {
  t === void 0 && (t = {}), jG();
  var e = It({}, ZG, t),
    n = e.initialIsOpen,
    r = e.defaultIsOpen,
    i = e.items,
    s = e.scrollIntoView,
    o = e.environment,
    a = e.getA11yStatusMessage,
    l = e.getA11ySelectionMessage,
    c = e.itemToString,
    u = VG(e),
    h = BG(zG, u, e),
    f = h[0],
    d = h[1],
    p = f.isOpen,
    m = f.highlightedIndex,
    O = f.selectedItem,
    v = f.inputValue,
    g = w.useRef(null),
    x = w.useRef({}),
    y = w.useRef(null),
    S = w.useRef(null),
    k = w.useRef(!0),
    b = PG(e),
    _ = w.useRef(),
    T = b9({ state: f, props: e }),
    P = w.useCallback(
      function (Y) {
        return x.current[b.getItemId(Y)];
      },
      [b]
    );
  QC(a, [p, m, v, i], It({ isInitialMount: k.current, previousResultCount: _.current, items: i, environment: o, itemToString: c }, f)),
    QC(l, [O], It({ isInitialMount: k.current, previousResultCount: _.current, items: i, environment: o, itemToString: c }, f));
  var M = MG({ menuElement: g.current, highlightedIndex: m, isOpen: p, itemRefs: x, scrollIntoView: s, getItemNodeFromIndex: P });
  DG({ isInitialMount: k.current, props: e, state: f }),
    w.useEffect(function () {
      var Y = n || r || p;
      Y && y.current && y.current.focus();
    }, []),
    w.useEffect(function () {
      k.current || (_.current = i.length);
    });
  var D = NG(p, [y, g, S], o, function () {
      d({ type: bp, selectItem: !1 });
    }),
    V = LG();
  w.useEffect(function () {
    return (
      (k.current = !1),
      function () {
        k.current = !0;
      }
    );
  }, []),
    w.useEffect(
      function () {
        var Y;
        if (!p) x.current = {};
        else if (((Y = o.document) == null ? void 0 : Y.activeElement) !== y.current) {
          var q;
          y == null || (q = y.current) == null || q.focus();
        }
      },
      [p, o]
    );
  var Q = w.useMemo(
      function () {
        return {
          ArrowDown: function (q) {
            q.preventDefault(), d({ type: Ny, altKey: q.altKey, getItemNodeFromIndex: P });
          },
          ArrowUp: function (q) {
            q.preventDefault(), d({ type: Ly, altKey: q.altKey, getItemNodeFromIndex: P });
          },
          Home: function (q) {
            T.current.state.isOpen && (q.preventDefault(), d({ type: Dy, getItemNodeFromIndex: P }));
          },
          End: function (q) {
            T.current.state.isOpen && (q.preventDefault(), d({ type: Qy, getItemNodeFromIndex: P }));
          },
          Escape: function (q) {
            var se = T.current.state;
            (se.isOpen || se.inputValue || se.selectedItem || se.highlightedIndex > -1) && (q.preventDefault(), d({ type: My }));
          },
          Enter: function (q) {
            var se = T.current.state;
            !se.isOpen || q.which === 229 || (q.preventDefault(), d({ type: By, getItemNodeFromIndex: P }));
          },
          PageUp: function (q) {
            T.current.state.isOpen && (q.preventDefault(), d({ type: Fy, getItemNodeFromIndex: P }));
          },
          PageDown: function (q) {
            T.current.state.isOpen && (q.preventDefault(), d({ type: Vy, getItemNodeFromIndex: P }));
          },
        };
      },
      [d, T, P]
    ),
    N = w.useCallback(
      function (Y) {
        return It({ id: b.labelId, htmlFor: b.inputId }, Y);
      },
      [b]
    ),
    G = w.useCallback(
      function (Y, q) {
        var se,
          ue = Y === void 0 ? {} : Y,
          ve = ue.onMouseLeave,
          Pe = ue.refKey,
          Fe = Pe === void 0 ? "ref" : Pe,
          rt = ue.ref,
          Rt = Qc(ue, WG),
          Qt = q === void 0 ? {} : q;
        return (
          Qt.suppressRefError,
          It(
            ((se = {}),
            (se[Fe] = Tf(rt, function (Ft) {
              g.current = Ft;
            })),
            (se.id = b.menuId),
            (se.role = "listbox"),
            (se["aria-labelledby"] = Rt && Rt["aria-label"] ? void 0 : "" + b.labelId),
            (se.onMouseLeave = Ui(ve, function () {
              d({ type: y9 });
            })),
            se),
            Rt
          )
        );
      },
      [d, V, b]
    ),
    H = w.useCallback(
      function (Y) {
        var q,
          se,
          ue = Y === void 0 ? {} : Y,
          ve = ue.item,
          Pe = ue.index,
          Fe = ue.refKey,
          rt = Fe === void 0 ? "ref" : Fe,
          Rt = ue.ref,
          Qt = ue.onMouseMove,
          Ft = ue.onMouseDown,
          Ge = ue.onClick;
        ue.onPress;
        var Ve = ue.disabled,
          We = Qc(ue, UG),
          De = T.current,
          Ut = De.props,
          Lt = De.state,
          it = AG(ve, Pe, Ut.items, "Pass either item or index to getItemProps!"),
          hn = it[1],
          U = "onClick",
          K = Ge,
          I = function () {
            hn !== Lt.highlightedIndex && ((M.current = !1), d({ type: w9, index: hn, disabled: Ve }));
          },
          $e = function () {
            d({ type: zy, index: hn });
          },
          je = function (ji) {
            return ji.preventDefault();
          };
        return It(
          ((q = {}),
          (q[rt] = Tf(Rt, function (wt) {
            wt && (x.current[b.getItemId(hn)] = wt);
          })),
          (q.disabled = Ve),
          (q.role = "option"),
          (q["aria-selected"] = "" + (hn === Lt.highlightedIndex)),
          (q.id = b.getItemId(hn)),
          q),
          !Ve && ((se = {}), (se[U] = Ui(K, $e)), se),
          { onMouseMove: Ui(Qt, I), onMouseDown: Ui(Ft, je) },
          We
        );
      },
      [d, T, M, b]
    ),
    te = w.useCallback(
      function (Y) {
        var q,
          se = Y === void 0 ? {} : Y,
          ue = se.onClick;
        se.onPress;
        var ve = se.refKey,
          Pe = ve === void 0 ? "ref" : ve,
          Fe = se.ref,
          rt = Qc(se, XG),
          Rt = T.current.state,
          Qt = function () {
            d({ type: S9 });
          };
        return It(
          ((q = {}),
          (q[Pe] = Tf(Fe, function (Ft) {
            S.current = Ft;
          })),
          (q["aria-controls"] = b.menuId),
          (q["aria-expanded"] = Rt.isOpen),
          (q.id = b.toggleButtonId),
          (q.tabIndex = -1),
          q),
          !rt.disabled && It({}, { onClick: Ui(ue, Qt) }),
          rt
        );
      },
      [d, T, b]
    ),
    le = w.useCallback(
      function (Y, q) {
        var se,
          ue = Y === void 0 ? {} : Y,
          ve = ue.onKeyDown,
          Pe = ue.onChange,
          Fe = ue.onInput,
          rt = ue.onFocus,
          Rt = ue.onBlur;
        ue.onChangeText;
        var Qt = ue.refKey,
          Ft = Qt === void 0 ? "ref" : Qt,
          Ge = ue.ref,
          Ve = Qc(ue, HG),
          We = q === void 0 ? {} : q;
        We.suppressRefError;
        var De = T.current.state,
          Ut = function (je) {
            var wt = xG(je);
            wt && Q[wt] && Q[wt](je);
          },
          Lt = function (je) {
            d({ type: jy, inputValue: je.target.value });
          },
          it = function (je) {
            if (De.isOpen && !D.current.isMouseDown) {
              var wt = je.relatedTarget === null && o.document.activeElement !== o.document.body;
              d({ type: bp, selectItem: !wt });
            }
          },
          hn = function () {
            De.isOpen || d({ type: Zy });
          },
          U = "onChange",
          K = {};
        if (!Ve.disabled) {
          var I;
          K = ((I = {}), (I[U] = Ui(Pe, Fe, Lt)), (I.onKeyDown = Ui(ve, Ut)), (I.onBlur = Ui(Rt, it)), (I.onFocus = Ui(rt, hn)), I);
        }
        return It(
          ((se = {}),
          (se[Ft] = Tf(Ge, function ($e) {
            y.current = $e;
          })),
          (se["aria-activedescendant"] = De.isOpen && De.highlightedIndex > -1 ? b.getItemId(De.highlightedIndex) : ""),
          (se["aria-autocomplete"] = "list"),
          (se["aria-controls"] = b.menuId),
          (se["aria-expanded"] = De.isOpen),
          (se["aria-labelledby"] = Ve && Ve["aria-label"] ? void 0 : "" + b.labelId),
          (se.autoComplete = "off"),
          (se.id = b.inputId),
          (se.role = "combobox"),
          (se.value = De.inputValue),
          se),
          K,
          Ve
        );
      },
      [V, T, b, Q, d, D, o]
    ),
    $ = w.useCallback(
      function () {
        d({ type: k9 });
      },
      [d]
    ),
    B = w.useCallback(
      function () {
        d({ type: _9 });
      },
      [d]
    ),
    ie = w.useCallback(
      function () {
        d({ type: C9 });
      },
      [d]
    ),
    L = w.useCallback(
      function (Y) {
        d({ type: E9, highlightedIndex: Y });
      },
      [d]
    ),
    pe = w.useCallback(
      function (Y) {
        d({ type: Wy, selectedItem: Y });
      },
      [d]
    ),
    Ce = w.useCallback(
      function (Y) {
        d({ type: T9, inputValue: Y });
      },
      [d]
    ),
    me = w.useCallback(
      function () {
        d({ type: P9 });
      },
      [d]
    );
  return {
    getItemProps: H,
    getLabelProps: N,
    getMenuProps: G,
    getInputProps: le,
    getToggleButtonProps: te,
    toggleMenu: $,
    openMenu: ie,
    closeMenu: B,
    setHighlightedIndex: L,
    setInputValue: Ce,
    selectItem: pe,
    reset: me,
    highlightedIndex: m,
    isOpen: p,
    selectedItem: O,
    inputValue: v,
  };
}
function qG(t) {
  var e = t.removedSelectedItem,
    n = t.itemToString;
  return n(e) + " has been removed.";
}
ae.array,
  ae.array,
  ae.array,
  ae.func,
  ae.func,
  ae.func,
  ae.number,
  ae.number,
  ae.number,
  ae.func,
  ae.func,
  ae.string,
  ae.string,
  ae.shape({
    addEventListener: ae.func,
    removeEventListener: ae.func,
    document: ae.shape({ getElementById: ae.func, activeElement: ae.any, body: ae.any }),
  });
su.itemToString, su.stateReducer, su.environment;
const VC = 20,
  $9 = (t) =>
    t.suggestions.length > 0
      ? C.createElement(YG, { ...t })
      : C.createElement("input", { className: F.textInput, size: 40, autoFocus: !0, ...t.register(t.inputName) }),
  YG = ({ autofocus: t, suggestions: e, control: n, inputName: r, placeholder: i, initialInputValue: s, setValue: o }) => {
    const [a, l] = C.useState(e.slice(0, VC)),
      c = yt(ft),
      u = e.length > 0,
      {
        isOpen: h,
        getToggleButtonProps: f,
        getMenuProps: d,
        getInputProps: p,
        highlightedIndex: m,
        getItemProps: O,
        selectedItem: v,
      } = Xy({
        initialInputValue: s,
        onInputValueChange({ inputValue: x = "" }) {
          o(r, x), (x = x.toLowerCase() || "");
          const y = [];
          for (const S of e) if (S.toLowerCase().includes(x) && (y.push(S), y.length >= VC)) break;
          l(y);
        },
        items: a,
        itemToString(x) {
          return x ?? "";
        },
      }),
      g = h && a.length > 0;
    return C.createElement(
      "div",
      { className: F.downshiftAutocompleteContainer },
      C.createElement(
        "div",
        { "data-visible-dropdown": g, className: F.downshiftInputWrapper },
        C.createElement(cD, {
          name: r,
          control: n,
          render: ({ field: x }) => {
            const y = p();
            return C.createElement("input", {
              ...y,
              name: x.name,
              placeholder: i,
              className: F.downshiftInput,
              size: 30,
              "data-editor-dialog": !0,
              autoFocus: t,
            });
          },
        }),
        u && C.createElement("button", { "aria-label": "toggle menu", type: "button", ...f() }, c("arrow_drop_down"))
      ),
      C.createElement(
        "div",
        { className: F.downshiftAutocompleteContainer },
        C.createElement(
          "ul",
          { ...d(), "data-visible": g },
          a.map((x, y) =>
            C.createElement(
              "li",
              { "data-selected": v === x, "data-highlighted": m === y, key: `${x}${y}`, ...O({ item: x, index: y }) },
              x
            )
          )
        )
      )
    );
  },
  GG = () => {
    const [t, e, n] = nt(yp, Us, si),
      r = tt(Ky),
      i = tt(Gy),
      s = lt(),
      { register: o, handleSubmit: a, control: l, setValue: c, reset: u } = vm({ values: e.type === "editing" ? e.initialValues : {} });
    return C.createElement(
      _y,
      {
        open: e.type !== "inactive",
        onOpenChange: (h) => {
          h || (i(), u({ src: "", title: "", altText: "" }));
        },
      },
      C.createElement(
        Ey,
        { container: n == null ? void 0 : n.current },
        C.createElement(Ty, { className: F.dialogOverlay }),
        C.createElement(
          Py,
          {
            className: F.dialogContent,
            onOpenAutoFocus: (h) => {
              h.preventDefault();
            },
          },
          C.createElement(
            "form",
            {
              onSubmit: (h) => {
                a(r)(h), u({ src: "", title: "", altText: "" }), h.preventDefault(), h.stopPropagation();
              },
              className: F.multiFieldForm,
            },
            C.createElement(
              "div",
              { className: F.formField },
              C.createElement("label", { htmlFor: "file" }, s("uploadImage.uploadInstructions", "Upload an image from your device:")),
              C.createElement("input", { type: "file", accept: "image/*", ...o("file") })
            ),
            C.createElement(
              "div",
              { className: F.formField },
              C.createElement("label", { htmlFor: "src" }, s("uploadImage.addViaUrlInstructions", "Or add an image from an URL:")),
              C.createElement($9, {
                register: o,
                initialInputValue: e.type === "editing" ? e.initialValues.src ?? "" : "",
                inputName: "src",
                suggestions: t,
                setValue: c,
                control: l,
                placeholder: s("uploadImage.autoCompletePlaceholder", "Select or paste an image src"),
              })
            ),
            C.createElement(
              "div",
              { className: F.formField },
              C.createElement("label", { htmlFor: "alt" }, s("uploadImage.alt", "Alt:")),
              C.createElement("input", { type: "text", ...o("altText"), className: F.textInput })
            ),
            C.createElement(
              "div",
              { className: F.formField },
              C.createElement("label", { htmlFor: "title" }, s("uploadImage.title", "Title:")),
              C.createElement("input", { type: "text", ...o("title"), className: F.textInput })
            ),
            C.createElement(
              "div",
              { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
              C.createElement(
                "button",
                {
                  type: "submit",
                  title: s("dialogControls.save", "Save"),
                  "aria-label": s("dialogControls.save", "Save"),
                  className: Ze(F.primaryButton),
                },
                s("dialogControls.save", "Save")
              ),
              C.createElement(
                Ay,
                { asChild: !0 },
                C.createElement(
                  "button",
                  {
                    type: "reset",
                    title: s("dialogControls.cancel", "Cancel"),
                    "aria-label": s("dialogControls.cancel", "Cancel"),
                    className: Ze(F.secondaryButton),
                  },
                  s("dialogControls.cancel", "Cancel")
                )
              )
            )
          )
        )
      )
    );
  };
function T0(t, e, n) {
  return Math.min(Math.max(t, e), n);
}
const mt = { east: 1, north: 8, south: 2, west: 4 };
function JG({ onResizeStart: t, onResizeEnd: e, imageRef: n, maxWidth: r, editor: i }) {
  const s = w.useRef(null),
    o = w.useRef({ priority: "", value: "default" }),
    a = w.useRef({
      currentHeight: 0,
      currentWidth: 0,
      direction: 0,
      isResizing: !1,
      ratio: 0,
      startHeight: 0,
      startWidth: 0,
      startX: 0,
      startY: 0,
    }),
    l = i.getRootElement(),
    c = r || (l !== null ? l.getBoundingClientRect().width - 20 : 100),
    u = l !== null ? l.getBoundingClientRect().height - 20 : 100,
    h = 100,
    f = 100,
    d = (g) => {
      const x = g === mt.east || g === mt.west,
        y = g === mt.north || g === mt.south,
        S = (g & mt.north && g & mt.west) || (g & mt.south && g & mt.east),
        k = x ? "ew" : y ? "ns" : S ? "nwse" : "nesw";
      l !== null && l.style.setProperty("cursor", `${k}-resize`, "important"),
        document.body !== null &&
          (document.body.style.setProperty("cursor", `${k}-resize`, "important"),
          (o.current.value = document.body.style.getPropertyValue("-webkit-user-select")),
          (o.current.priority = document.body.style.getPropertyPriority("-webkit-user-select")),
          document.body.style.setProperty("-webkit-user-select", "none", "important"));
    },
    p = () => {
      l !== null && l.style.setProperty("cursor", "text"),
        document.body !== null &&
          (document.body.style.setProperty("cursor", "default"),
          document.body.style.setProperty("-webkit-user-select", o.current.value, o.current.priority));
    },
    m = (g, x) => {
      if (!i.isEditable()) return;
      const y = n.current,
        S = s.current;
      if (y !== null && S !== null) {
        g.preventDefault();
        const { width: k, height: b } = y.getBoundingClientRect(),
          _ = a.current;
        (_.startWidth = k),
          (_.startHeight = b),
          (_.ratio = k / b),
          (_.currentWidth = k),
          (_.currentHeight = b),
          (_.startX = g.clientX),
          (_.startY = g.clientY),
          (_.isResizing = !0),
          (_.direction = x),
          d(x),
          t(),
          S.classList.add(F.imageControlWrapperResizing),
          (y.style.height = `${b}px`),
          (y.style.width = `${k}px`),
          document.addEventListener("pointermove", O),
          document.addEventListener("pointerup", v);
      }
    },
    O = (g) => {
      const x = n.current,
        y = a.current,
        S = y.direction & (mt.east | mt.west),
        k = y.direction & (mt.south | mt.north);
      if (x !== null && y.isResizing)
        if (S && k) {
          let b = Math.floor(y.startX - g.clientX);
          b = y.direction & mt.east ? -b : b;
          const _ = T0(y.startWidth + b, h, c),
            T = _ / y.ratio;
          (x.style.width = `${_}px`), (x.style.height = `${T}px`), (y.currentHeight = T), (y.currentWidth = _);
        } else if (k) {
          let b = Math.floor(y.startY - g.clientY);
          b = y.direction & mt.south ? -b : b;
          const _ = T0(y.startHeight + b, f, u);
          (x.style.height = `${_}px`), (y.currentHeight = _);
        } else {
          let b = Math.floor(y.startX - g.clientX);
          b = y.direction & mt.east ? -b : b;
          const _ = T0(y.startWidth + b, h, c);
          (x.style.width = `${_}px`), (y.currentWidth = _);
        }
    },
    v = () => {
      const g = n.current,
        x = a.current,
        y = s.current;
      if (g !== null && y !== null && x.isResizing) {
        const S = x.currentWidth,
          k = x.currentHeight;
        (x.startWidth = 0),
          (x.startHeight = 0),
          (x.ratio = 0),
          (x.startX = 0),
          (x.startY = 0),
          (x.currentWidth = 0),
          (x.currentHeight = 0),
          (x.isResizing = !1),
          y.classList.remove(F.imageControlWrapperResizing),
          p(),
          e(S, k),
          document.removeEventListener("pointermove", O),
          document.removeEventListener("pointerup", v);
      }
    };
  return w.createElement(
    "div",
    { ref: s },
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerN),
      onPointerDown: (g) => {
        m(g, mt.north);
      },
    }),
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerNe),
      onPointerDown: (g) => {
        m(g, mt.north | mt.east);
      },
    }),
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerE),
      onPointerDown: (g) => {
        m(g, mt.east);
      },
    }),
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerSe),
      onPointerDown: (g) => {
        m(g, mt.south | mt.east);
      },
    }),
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerS),
      onPointerDown: (g) => {
        m(g, mt.south);
      },
    }),
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerSw),
      onPointerDown: (g) => {
        m(g, mt.south | mt.west);
      },
    }),
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerW),
      onPointerDown: (g) => {
        m(g, mt.west);
      },
    }),
    w.createElement("div", {
      className: Ze(F.imageResizer, F.imageResizerNw),
      onPointerDown: (g) => {
        m(g, mt.north | mt.west);
      },
    })
  );
}
const BC = new Set();
function KG(t) {
  if (!BC.has(t))
    throw new Promise((e) => {
      const n = new Image();
      (n.src = t),
        (n.onerror = n.onload =
          () => {
            BC.add(t), e(null);
          });
    });
}
function eJ({ title: t, alt: e, className: n, imageRef: r, src: i, width: s, height: o }) {
  return (
    KG(i), C.createElement("img", { className: n ?? void 0, alt: e, src: i, title: t, ref: r, draggable: "false", width: s, height: o })
  );
}
function tJ({ src: t, title: e, alt: n, nodeKey: r, width: i, height: s }) {
  const [o, a, l, c, u] = nt(wp, Jy, Sp, ft, sn),
    h = tt(Yy),
    f = C.useRef(null),
    d = C.useRef(null),
    [p, m, O] = zA(r),
    [v] = jn(),
    [g, x] = C.useState(null),
    y = C.useRef(null),
    [S, k] = C.useState(!1),
    [b, _] = C.useState(null),
    [T, P] = C.useState(null),
    M = lt(),
    D = C.useCallback(
      (le) => {
        if (p && Ht(ce())) {
          le.preventDefault();
          const B = vt(r);
          $u(B) && B.remove();
        }
        return !1;
      },
      [p, r]
    ),
    V = C.useCallback(
      (le) => {
        const $ = ce(),
          B = d.current;
        return p && Ht($) && $.getNodes().length === 1 && B !== null && B !== document.activeElement
          ? (le.preventDefault(), B.focus(), !0)
          : !1;
      },
      [p]
    ),
    Q = C.useCallback(
      (le) =>
        d.current === le.target
          ? (yn(null),
            v.update(() => {
              m(!0);
              const $ = v.getRootElement();
              $ !== null && $.focus();
            }),
            !0)
          : !1,
      [v, m]
    );
  C.useEffect(() => {
    l
      ? (async () => {
          T || P(t);
          const $ = await l(t);
          _($);
        })().catch(($) => {
          console.error($);
        })
      : _(t);
  }, [t, l, T]),
    C.useEffect(() => {
      let le = !0;
      const $ = ir(
        v.registerUpdateListener(({ editorState: B }) => {
          le && x(B.read(() => ce()));
        }),
        v.registerCommand(Bl, (B, ie) => ((y.current = ie), !1), Ot),
        v.registerCommand(
          ym,
          (B) => {
            const ie = B;
            return S ? !0 : ie.target === f.current ? (ie.shiftKey ? m(!p) : (O(), m(!0)), !0) : !1;
          },
          Ot
        ),
        v.registerCommand(Cm, (B) => (B.target === f.current ? (B.preventDefault(), !0) : !1), Ot),
        v.registerCommand(km, D, Ot),
        v.registerCommand(gh, D, Ot),
        v.registerCommand(pl, V, Ot),
        v.registerCommand(Oh, Q, Ot)
      );
      return () => {
        (le = !1), $();
      };
    }, [O, v, S, p, r, D, V, Q, m]);
  const N = (le, $) => {
      setTimeout(() => {
        k(!1);
      }, 200),
        v.update(() => {
          const B = vt(r);
          $u(B) && B.setWidthAndHeight(le, $);
        });
    },
    G = () => {
      k(!0);
    },
    H = Ht(g),
    te = p;
  return b !== null
    ? C.createElement(
        C.Suspense,
        { fallback: null },
        C.createElement(
          "div",
          { className: F.imageWrapper, "data-editor-block-type": "image" },
          C.createElement(
            "div",
            { draggable: H },
            C.createElement(eJ, {
              width: i,
              height: s,
              className: Ze({ [F.focusedImage]: te }),
              src: b,
              title: e ?? "",
              alt: n ?? "",
              imageRef: f,
            })
          ),
          H && te && !o && C.createElement(JG, { editor: v, imageRef: f, onResizeStart: G, onResizeEnd: N }),
          C.createElement(
            "div",
            { className: F.editImageToolbar },
            C.createElement(
              "button",
              {
                className: F.iconButton,
                type: "button",
                title: M("image.delete", "Delete image"),
                onClick: (le) => {
                  le.preventDefault(),
                    v.update(() => {
                      var $;
                      ($ = vt(r)) == null || $.remove();
                    });
                },
              },
              c("delete_small")
            ),
            !a &&
              C.createElement(
                "button",
                {
                  type: "button",
                  className: Ze(F.iconButton, F.editImageButton),
                  title: M("imageEditor.editImage", "Edit image"),
                  disabled: u,
                  onClick: () => {
                    h({ nodeKey: r, initialValues: { src: T || b, title: e ?? "", altText: n ?? "" } });
                  },
                },
                c("settings")
              )
          )
        )
      )
    : null;
}
var nJ = Object.defineProperty,
  rJ = (t, e, n) => (e in t ? nJ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  yc = (t, e, n) => (rJ(t, typeof e != "symbol" ? e + "" : e, n), n);
function iJ(t) {
  if (t instanceof HTMLImageElement) {
    const { alt: e, src: n, title: r, width: i, height: s } = t;
    return { node: go({ altText: e, src: n, title: r, width: i, height: s }) };
  }
  return null;
}
class ec extends Mi {
  constructor(e, n, r, i, s, o) {
    super(o),
      yc(this, "__src"),
      yc(this, "__altText"),
      yc(this, "__title"),
      yc(this, "__width"),
      yc(this, "__height"),
      (this.__src = e),
      (this.__title = r),
      (this.__altText = n),
      (this.__width = i ?? "inherit"),
      (this.__height = s ?? "inherit");
  }
  static getType() {
    return "image";
  }
  static clone(e) {
    return new ec(e.__src, e.__altText, e.__title, e.__width, e.__height, e.__key);
  }
  static importJSON(e) {
    const { altText: n, title: r, src: i, width: s, height: o } = e;
    return go({ altText: n, title: r, src: i, height: o, width: s });
  }
  exportDOM() {
    const e = document.createElement("img");
    return (
      e.setAttribute("src", this.__src),
      e.setAttribute("alt", this.__altText),
      this.__title && e.setAttribute("title", this.__title),
      this.__width && e.setAttribute("width", this.__width.toString()),
      this.__height && e.setAttribute("height", this.__height.toString()),
      { element: e }
    );
  }
  static importDOM() {
    return { img: () => ({ conversion: iJ, priority: 0 }) };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      title: this.getTitle(),
      height: this.__height === "inherit" ? 0 : this.__height,
      width: this.__width === "inherit" ? 0 : this.__width,
      src: this.getSrc(),
      type: "image",
      version: 1,
    };
  }
  setWidthAndHeight(e, n) {
    const r = this.getWritable();
    (r.__width = e), (r.__height = n);
  }
  createDOM(e) {
    const n = document.createElement("span"),
      i = e.theme.image;
    return i !== void 0 && (n.className = i), n;
  }
  updateDOM() {
    return !1;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  getTitle() {
    return this.__title;
  }
  getHeight() {
    return this.__height;
  }
  getWidth() {
    return this.__width;
  }
  setTitle(e) {
    this.getWritable().__title = e;
  }
  setSrc(e) {
    this.getWritable().__src = e;
  }
  setAltText(e) {
    this.getWritable().__altText = e ?? "";
  }
  hasExplicitDimensions() {
    return this.__width !== "inherit" || this.__height !== "inherit";
  }
  decorate(e) {
    return C.createElement(tJ, {
      src: this.getSrc(),
      title: this.getTitle(),
      nodeKey: this.getKey(),
      width: this.__width,
      height: this.__height,
      alt: this.__altText,
    });
  }
}
function go(t) {
  const { altText: e, title: n, src: r, key: i, width: s, height: o } = t;
  return new ec(r, e, n, s, o, i);
}
function $u(t) {
  return t instanceof ec;
}
const sJ = {
    testLexicalNode: $u,
    visitLexicalNode({ mdastParent: t, lexicalNode: e, actions: n }) {
      if (e.hasExplicitDimensions()) {
        const r = new Image();
        e.getHeight() !== "inherit" && (r.height = e.getHeight()),
          e.getWidth() !== "inherit" && (r.width = e.getWidth()),
          e.getAltText() && (r.alt = e.getAltText()),
          e.getTitle() && (r.title = e.getTitle()),
          n.appendToParent(t, { type: "html", value: r.outerHTML.replace(/>$/, ` src="${e.getSrc()}" />`) });
      } else n.appendToParent(t, { type: "image", url: e.getSrc(), alt: e.getAltText(), title: e.getTitle() });
    },
  },
  oJ = {
    testNode: "image",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(go({ src: t.url, altText: t.alt ?? "", title: t.title ?? "" }));
    },
  },
  aJ = {
    testNode: (t) => t.type === "html" && t.value.trim().startsWith("<img"),
    visitNode({ mdastNode: t, lexicalParent: e }) {
      const n = document.createElement("div");
      n.innerHTML = t.value;
      const r = n.querySelector("img");
      if (!r) throw new Error("Invalid HTML image");
      const i = r.src,
        s = r.alt,
        o = r.title,
        a = r.width,
        l = r.height,
        c = go({ src: i || "", altText: s, title: o, width: a, height: l });
      if (e.getType() === "root") {
        const u = at();
        u.append(c), e.append(u);
      } else e.append(c);
    },
  };
function wc(t, e) {
  const n = t.attributes.find((r) => r.type === "mdxJsxAttribute" && r.name === e);
  if (n) return n.value;
}
const lJ = {
    testNode: (t) => (t.type === "mdxJsxTextElement" || t.type === "mdxJsxFlowElement") && t.name === "img",
    visitNode({ mdastNode: t, lexicalParent: e }) {
      const n = wc(t, "src");
      if (!n) return;
      const r = wc(t, "alt") ?? "",
        i = wc(t, "title"),
        s = wc(t, "height"),
        o = wc(t, "width"),
        a = go({ src: n, altText: r, title: i, width: o ? parseInt(o, 10) : void 0, height: s ? parseInt(s, 10) : void 0 });
      if (e.getType() === "root") {
        const l = at();
        l.append(a), e.append(l);
      } else e.append(a);
    },
  },
  Hy = $t((t) => {
    t.sub(t.pipe(Hy, bt(At)), ([e, n]) => {
      n == null ||
        n.update(() => {
          const r = go({ altText: e.altText ?? "", src: e.src, title: e.title ?? "" });
          Zl([r]), rn(r.getParentOrThrow()) && Lb(r, at).selectEnd();
        });
    });
  }),
  R9 = $t((t) => {
    t.sub(t.pipe(R9, bt(Ds)), ([e, n]) => {
      const r = (i) => {
        t.pub(Hy, { ...e, src: i });
      };
      "file" in e
        ? n == null ||
          n(e.file)
            .then(r)
            .catch((i) => {
              throw i;
            })
        : r(e.src);
    });
  }),
  yp = Se([]),
  wp = Se(!1),
  Ds = Se(null),
  Sp = Se(null),
  Us = Se({ type: "inactive" }, (t) => {
    t.sub(t.pipe(Ky, bt(At, Ds, Us)), ([e, n, r, i]) => {
      const s =
        i.type === "editing"
          ? (o) => {
              n == null ||
                n.update(() => {
                  const { nodeKey: a } = i,
                    l = vt(a);
                  l.setTitle(e.title), l.setAltText(e.altText), l.setSrc(o);
                }),
                t.pub(Us, { type: "inactive" });
            }
          : (o) => {
              t.pub(Hy, { ...e, src: o }), t.pub(Us, { type: "inactive" });
            };
      e.file.length > 0
        ? r == null ||
          r(e.file.item(0))
            .then(s)
            .catch((o) => {
              throw o;
            })
        : e.src && s(e.src);
    }),
      t.pub(Eu, (e) => {
        const n = t.getValue(Ds);
        return ir(
          e.registerCommand(
            Ru,
            (r) => {
              const i = go(r);
              return Zl([i]), rn(i.getParentOrThrow()) && Lb(i, at).selectEnd(), !0;
            },
            Ue
          ),
          e.registerCommand(Cm, (r) => fJ(r), sp),
          e.registerCommand(ob, (r) => dJ(r), Ot),
          e.registerCommand(sb, (r) => pJ(r, e, t.getValue(Ds)), sp),
          ...(n !== null
            ? [
                e.registerCommand(
                  mh,
                  (r) => {
                    var i;
                    let s = Array.from(((i = r.clipboardData) == null ? void 0 : i.items) ?? []);
                    if (((s = s.filter((a) => a.type.includes("image"))), !s.length || s.length === 0)) return !1;
                    const o = t.getValue(Ds);
                    return (
                      Promise.all(s.map((a) => o(a.getAsFile())))
                        .then((a) => {
                          a.forEach((l) => {
                            e.dispatchCommand(Ru, { src: l, altText: "" });
                          });
                        })
                        .catch((a) => {
                          throw a;
                        }),
                      !0
                    );
                  },
                  Gn
                ),
              ]
            : [])
        );
      });
  }),
  qy = ni((t) => {
    t.link(t.pipe(qy, Yx({ type: "new" })), Us);
  }),
  Yy = $t((t) => {
    t.link(
      t.pipe(
        Yy,
        Rr((e) => ({ type: "editing", ...e }))
      ),
      Us
    );
  }),
  Gy = ni((t) => {
    t.link(t.pipe(Gy, Yx({ type: "inactive" })), Us);
  }),
  Jy = Se(!1),
  Ky = $t(),
  cJ = en({
    init(t, e) {
      t.pubIn({
        [rr]: [oJ, aJ, lJ],
        [vr]: ec,
        [xr]: sJ,
        [fo]: (e == null ? void 0 : e.ImageDialog) ?? GG,
        [Ds]: (e == null ? void 0 : e.imageUploadHandler) ?? null,
        [yp]: (e == null ? void 0 : e.imageAutocompleteSuggestions) ?? [],
        [wp]: !!(e != null && e.disableImageResize),
        [Jy]: !!(e != null && e.disableImageSettingsButton),
        [Sp]: (e == null ? void 0 : e.imagePreviewHandler) ?? null,
      });
    },
    update(t, e) {
      t.pubIn({
        [Ds]: (e == null ? void 0 : e.imageUploadHandler) ?? null,
        [yp]: (e == null ? void 0 : e.imageAutocompleteSuggestions) ?? [],
        [wp]: !!(e != null && e.disableImageResize),
        [Sp]: (e == null ? void 0 : e.imagePreviewHandler) ?? null,
      });
    },
  }),
  uJ = (t) => (zb ? (t ?? window).getSelection() : null),
  Ru = gs(),
  hJ = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
function fJ(t) {
  const e = ew();
  if (!e) return !1;
  const n = t.dataTransfer;
  if (!n) return !1;
  n.setData("text/plain", "_");
  const r = document.createElement("img");
  return (
    (r.src = hJ),
    n.setDragImage(r, 0, 0),
    n.setData(
      "application/x-lexical-drag",
      JSON.stringify({ data: { altText: e.__altText, title: e.__title, key: e.getKey(), src: e.__src }, type: "image" })
    ),
    !0
  );
}
function dJ(t) {
  var e;
  let n = Array.from(((e = t.dataTransfer) == null ? void 0 : e.items) ?? []);
  return (
    (n = n.filter((i) => i.type.includes("image"))), n.length > 0 ? (t.preventDefault(), !0) : ew() ? (I9(t) || t.preventDefault(), !0) : !1
  );
}
function pJ(t, e, n) {
  var r;
  let i = Array.from(((r = t.dataTransfer) == null ? void 0 : r.items) ?? []);
  if (((i = i.filter((a) => a.type.includes("image"))), i.length > 0 && n !== null))
    return (
      t.preventDefault(),
      Promise.all(i.map((a) => n(a.getAsFile())))
        .then((a) => {
          a.forEach((l) => {
            e.dispatchCommand(Ru, { src: l, altText: "" });
          });
        })
        .catch((a) => {
          throw a;
        }),
      !0
    );
  const s = ew();
  if (!s) return !1;
  const o = mJ(t);
  if (!o) return !1;
  if ((t.preventDefault(), I9(t))) {
    const a = gJ(t);
    s.remove();
    const l = Dm();
    a != null && l.applyDOMRange(a), yn(l), e.dispatchCommand(Ru, o);
  }
  return !0;
}
function ew() {
  const t = ce();
  if (!Ht(t)) return null;
  const n = t.getNodes()[0];
  return $u(n) ? n : null;
}
function mJ(t) {
  var e;
  const n = (e = t.dataTransfer) == null ? void 0 : e.getData("application/x-lexical-drag");
  if (!n) return null;
  const { type: r, data: i } = JSON.parse(n);
  return r !== "image" ? null : i;
}
function I9(t) {
  const e = t.target;
  return !!(e && e instanceof HTMLElement && e.parentElement);
}
function gJ(t) {
  let e;
  const n = t.target,
    r = n == null ? null : n.nodeType === 9 ? n.defaultView : n.ownerDocument.defaultView,
    i = uJ(r);
  if (document.caretRangeFromPoint) e = document.caretRangeFromPoint(t.clientX, t.clientY);
  else if (t.rangeParent && i !== null) i.collapse(t.rangeParent, t.rangeOffset ?? 0), (e = i.getRangeAt(0));
  else throw Error("Cannot get the selection when dragging");
  return e;
}
var N9 = { exports: {} };
(function (t) {
  (function () {
    var e;
    (e = t.exports = i), (e.format = i), (e.vsprintf = r), typeof console < "u" && typeof console.log == "function" && (e.printf = n);
    function n() {
      console.log(i.apply(null, arguments));
    }
    function r(s, o) {
      return i.apply(null, [s].concat(o));
    }
    function i(s) {
      for (
        var o = 1,
          a = [].slice.call(arguments),
          l = 0,
          c = s.length,
          u = "",
          h,
          f = !1,
          d,
          p,
          m = !1,
          O,
          v = function () {
            return a[o++];
          },
          g = function () {
            for (var x = ""; /\d/.test(s[l]); ) (x += s[l++]), (h = s[l]);
            return x.length > 0 ? parseInt(x) : null;
          };
        l < c;
        ++l
      )
        if (((h = s[l]), f))
          switch (
            ((f = !1),
            h == "." ? ((m = !1), (h = s[++l])) : h == "0" && s[l + 1] == "." ? ((m = !0), (l += 2), (h = s[l])) : (m = !0),
            (O = g()),
            h)
          ) {
            case "b":
              u += parseInt(v(), 10).toString(2);
              break;
            case "c":
              (d = v()), typeof d == "string" || d instanceof String ? (u += d) : (u += String.fromCharCode(parseInt(d, 10)));
              break;
            case "d":
              u += parseInt(v(), 10);
              break;
            case "f":
              (p = String(parseFloat(v()).toFixed(O || 6))), (u += m ? p : p.replace(/^0/, ""));
              break;
            case "j":
              u += JSON.stringify(v());
              break;
            case "o":
              u += "0" + parseInt(v(), 10).toString(8);
              break;
            case "s":
              u += v();
              break;
            case "x":
              u += "0x" + parseInt(v(), 10).toString(16);
              break;
            case "X":
              u += "0x" + parseInt(v(), 10).toString(16).toUpperCase();
              break;
            default:
              u += h;
              break;
          }
        else h === "%" ? (f = !0) : (u += h);
      return u;
    }
  })();
})(N9);
var OJ = N9.exports;
const vJ = Ql(OJ),
  $f = Object.assign(_o(Error), {
    eval: _o(EvalError),
    range: _o(RangeError),
    reference: _o(ReferenceError),
    syntax: _o(SyntaxError),
    type: _o(TypeError),
    uri: _o(URIError),
  });
function _o(t) {
  return (e.displayName = t.displayName || t.name), e;
  function e(n, ...r) {
    const i = n && vJ(n, ...r);
    return new t(i);
  }
}
const Rf = {}.hasOwnProperty,
  jC = { yaml: "-", toml: "+" };
function tw(t) {
  const e = [];
  let n = -1;
  const r = Array.isArray(t) ? t : t ? [t] : ["yaml"];
  for (; ++n < r.length; ) e[n] = xJ(r[n]);
  return e;
}
function xJ(t) {
  let e = t;
  if (typeof e == "string") {
    if (!Rf.call(jC, e)) throw $f("Missing matter definition for `%s`", e);
    e = { type: e, marker: jC[e] };
  } else if (typeof e != "object") throw $f("Expected matter to be an object, not `%j`", e);
  if (!Rf.call(e, "type")) throw $f("Missing `type` in matter `%j`", e);
  if (!Rf.call(e, "fence") && !Rf.call(e, "marker")) throw $f("Missing `marker` or `fence` in matter `%j`", e);
  return e;
}
function bJ(t) {
  const e = tw(t),
    n = {};
  let r = -1;
  for (; ++r < e.length; ) {
    const i = e[r],
      s = KO(i, "open").charCodeAt(0),
      o = yJ(i),
      a = n[s];
    Array.isArray(a) ? a.push(o) : (n[s] = [o]);
  }
  return { flow: n };
}
function yJ(t) {
  const e = t.anywhere,
    n = t.type,
    r = n + "Fence",
    i = r + "Sequence",
    s = n + "Value",
    o = { tokenize: u, partial: !0 };
  let a,
    l = 0;
  return { tokenize: c, concrete: !0 };
  function c(h, f, d) {
    const p = this;
    return m;
    function m(b) {
      const _ = p.now();
      return _.column === 1 && (_.line === 1 || e) && ((a = KO(t, "open")), (l = 0), b === a.charCodeAt(l))
        ? (h.enter(n), h.enter(r), h.enter(i), O(b))
        : d(b);
    }
    function O(b) {
      return l === a.length
        ? (h.exit(i), Re(b) ? (h.enter("whitespace"), v(b)) : g(b))
        : b === a.charCodeAt(l++)
        ? (h.consume(b), O)
        : d(b);
    }
    function v(b) {
      return Re(b) ? (h.consume(b), v) : (h.exit("whitespace"), g(b));
    }
    function g(b) {
      return de(b)
        ? (h.exit(r), h.enter("lineEnding"), h.consume(b), h.exit("lineEnding"), (a = KO(t, "close")), (l = 0), h.attempt(o, k, x))
        : d(b);
    }
    function x(b) {
      return b === null || de(b) ? S(b) : (h.enter(s), y(b));
    }
    function y(b) {
      return b === null || de(b) ? (h.exit(s), S(b)) : (h.consume(b), y);
    }
    function S(b) {
      return b === null ? d(b) : (h.enter("lineEnding"), h.consume(b), h.exit("lineEnding"), h.attempt(o, k, x));
    }
    function k(b) {
      return h.exit(n), f(b);
    }
  }
  function u(h, f, d) {
    let p = 0;
    return m;
    function m(x) {
      return x === a.charCodeAt(p) ? (h.enter(r), h.enter(i), O(x)) : d(x);
    }
    function O(x) {
      return p === a.length
        ? (h.exit(i), Re(x) ? (h.enter("whitespace"), v(x)) : g(x))
        : x === a.charCodeAt(p++)
        ? (h.consume(x), O)
        : d(x);
    }
    function v(x) {
      return Re(x) ? (h.consume(x), v) : (h.exit("whitespace"), g(x));
    }
    function g(x) {
      return x === null || de(x) ? (h.exit(r), f(x)) : d(x);
    }
  }
}
function KO(t, e) {
  return t.marker ? ZC(t.marker, e).repeat(3) : ZC(t.fence, e);
}
function ZC(t, e) {
  return typeof t == "string" ? t : t[e];
}
function wJ(t) {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function SJ(t) {
  const e = tw(t),
    n = {},
    r = {};
  let i = -1;
  for (; ++i < e.length; ) {
    const s = e[i];
    (n[s.type] = kJ(s)), (r[s.type] = CJ), (r[s.type + "Value"] = _J);
  }
  return { enter: n, exit: r };
}
function kJ(t) {
  return e;
  function e(n) {
    this.enter({ type: t.type, value: "" }, n), this.buffer();
  }
}
function CJ(t) {
  const e = this.resume(),
    n = this.stack[this.stack.length - 1];
  this.exit(t), (n.value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""));
}
function _J(t) {
  this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function EJ(t) {
  const e = [],
    n = {},
    r = tw(t);
  let i = -1;
  for (; ++i < r.length; ) {
    const s = r[i];
    n[s.type] = TJ(s);
    const o = ev(s, "open");
    e.push({ atBreak: !0, character: o.charAt(0), after: wJ(o.charAt(1)) });
  }
  return { unsafe: e, handlers: n };
}
function TJ(t) {
  const e = ev(t, "open"),
    n = ev(t, "close");
  return r;
  function r(i) {
    return (
      e +
      (i.value
        ? `
` + i.value
        : "") +
      `
` +
      n
    );
  }
}
function ev(t, e) {
  return t.marker ? zC(t.marker, e).repeat(3) : zC(t.fence, e);
}
function zC(t, e) {
  return typeof t == "string" ? t : t[e];
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ function L9(t) {
  return typeof t > "u" || t === null;
}
function PJ(t) {
  return typeof t == "object" && t !== null;
}
function AJ(t) {
  return Array.isArray(t) ? t : L9(t) ? [] : [t];
}
function $J(t, e) {
  var n, r, i, s;
  if (e) for (s = Object.keys(e), n = 0, r = s.length; n < r; n += 1) (i = s[n]), (t[i] = e[i]);
  return t;
}
function RJ(t, e) {
  var n = "",
    r;
  for (r = 0; r < e; r += 1) n += t;
  return n;
}
function IJ(t) {
  return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
var NJ = L9,
  LJ = PJ,
  MJ = AJ,
  DJ = RJ,
  QJ = IJ,
  FJ = $J,
  nn = { isNothing: NJ, isObject: LJ, toArray: MJ, repeat: DJ, isNegativeZero: QJ, extend: FJ };
function M9(t, e) {
  var n = "",
    r = t.reason || "(unknown reason)";
  return t.mark
    ? (t.mark.name && (n += 'in "' + t.mark.name + '" '),
      (n += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")"),
      !e &&
        t.mark.snippet &&
        (n +=
          `

` + t.mark.snippet),
      r + " " + n)
    : r;
}
function Iu(t, e) {
  Error.call(this),
    (this.name = "YAMLException"),
    (this.reason = t),
    (this.mark = e),
    (this.message = M9(this, !1)),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack || "");
}
Iu.prototype = Object.create(Error.prototype);
Iu.prototype.constructor = Iu;
Iu.prototype.toString = function (e) {
  return this.name + ": " + M9(this, e);
};
var Mn = Iu;
function P0(t, e, n, r, i) {
  var s = "",
    o = "",
    a = Math.floor(i / 2) - 1;
  return (
    r - e > a && ((s = " ... "), (e = r - a + s.length)),
    n - r > a && ((o = " ..."), (n = r + a - o.length)),
    { str: s + t.slice(e, n).replace(/\t/g, "→") + o, pos: r - e + s.length }
  );
}
function A0(t, e) {
  return nn.repeat(" ", e - t.length) + t;
}
function VJ(t, e) {
  if (((e = Object.create(e || null)), !t.buffer)) return null;
  e.maxLength || (e.maxLength = 79),
    typeof e.indent != "number" && (e.indent = 1),
    typeof e.linesBefore != "number" && (e.linesBefore = 3),
    typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], s, o = -1; (s = n.exec(t.buffer)); )
    i.push(s.index), r.push(s.index + s[0].length), t.position <= s.index && o < 0 && (o = r.length - 2);
  o < 0 && (o = r.length - 1);
  var a = "",
    l,
    c,
    u = Math.min(t.line + e.linesAfter, i.length).toString().length,
    h = e.maxLength - (e.indent + u + 3);
  for (l = 1; l <= e.linesBefore && !(o - l < 0); l++)
    (c = P0(t.buffer, r[o - l], i[o - l], t.position - (r[o] - r[o - l]), h)),
      (a =
        nn.repeat(" ", e.indent) +
        A0((t.line - l + 1).toString(), u) +
        " | " +
        c.str +
        `
` +
        a);
  for (
    c = P0(t.buffer, r[o], i[o], t.position, h),
      a +=
        nn.repeat(" ", e.indent) +
        A0((t.line + 1).toString(), u) +
        " | " +
        c.str +
        `
`,
      a +=
        nn.repeat("-", e.indent + u + 3 + c.pos) +
        `^
`,
      l = 1;
    l <= e.linesAfter && !(o + l >= i.length);
    l++
  )
    (c = P0(t.buffer, r[o + l], i[o + l], t.position - (r[o] - r[o + l]), h)),
      (a +=
        nn.repeat(" ", e.indent) +
        A0((t.line + l + 1).toString(), u) +
        " | " +
        c.str +
        `
`);
  return a.replace(/\n$/, "");
}
var BJ = VJ,
  jJ = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"],
  ZJ = ["scalar", "sequence", "mapping"];
function zJ(t) {
  var e = {};
  return (
    t !== null &&
      Object.keys(t).forEach(function (n) {
        t[n].forEach(function (r) {
          e[String(r)] = n;
        });
      }),
    e
  );
}
function WJ(t, e) {
  if (
    ((e = e || {}),
    Object.keys(e).forEach(function (n) {
      if (jJ.indexOf(n) === -1) throw new Mn('Unknown option "' + n + '" is met in definition of "' + t + '" YAML type.');
    }),
    (this.options = e),
    (this.tag = t),
    (this.kind = e.kind || null),
    (this.resolve =
      e.resolve ||
      function () {
        return !0;
      }),
    (this.construct =
      e.construct ||
      function (n) {
        return n;
      }),
    (this.instanceOf = e.instanceOf || null),
    (this.predicate = e.predicate || null),
    (this.represent = e.represent || null),
    (this.representName = e.representName || null),
    (this.defaultStyle = e.defaultStyle || null),
    (this.multi = e.multi || !1),
    (this.styleAliases = zJ(e.styleAliases || null)),
    ZJ.indexOf(this.kind) === -1)
  )
    throw new Mn('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
}
var bn = WJ;
function WC(t, e) {
  var n = [];
  return (
    t[e].forEach(function (r) {
      var i = n.length;
      n.forEach(function (s, o) {
        s.tag === r.tag && s.kind === r.kind && s.multi === r.multi && (i = o);
      }),
        (n[i] = r);
    }),
    n
  );
}
function UJ() {
  var t = { scalar: {}, sequence: {}, mapping: {}, fallback: {}, multi: { scalar: [], sequence: [], mapping: [], fallback: [] } },
    e,
    n;
  function r(i) {
    i.multi ? (t.multi[i.kind].push(i), t.multi.fallback.push(i)) : (t[i.kind][i.tag] = t.fallback[i.tag] = i);
  }
  for (e = 0, n = arguments.length; e < n; e += 1) arguments[e].forEach(r);
  return t;
}
function tv(t) {
  return this.extend(t);
}
tv.prototype.extend = function (e) {
  var n = [],
    r = [];
  if (e instanceof bn) r.push(e);
  else if (Array.isArray(e)) r = r.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (n = n.concat(e.implicit)), e.explicit && (r = r.concat(e.explicit));
  else throw new Mn("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function (s) {
    if (!(s instanceof bn)) throw new Mn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Mn("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi) throw new Mn("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }),
    r.forEach(function (s) {
      if (!(s instanceof bn)) throw new Mn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
  var i = Object.create(tv.prototype);
  return (
    (i.implicit = (this.implicit || []).concat(n)),
    (i.explicit = (this.explicit || []).concat(r)),
    (i.compiledImplicit = WC(i, "implicit")),
    (i.compiledExplicit = WC(i, "explicit")),
    (i.compiledTypeMap = UJ(i.compiledImplicit, i.compiledExplicit)),
    i
  );
};
var D9 = tv,
  Q9 = new bn("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function (t) {
      return t !== null ? t : "";
    },
  }),
  F9 = new bn("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function (t) {
      return t !== null ? t : [];
    },
  }),
  V9 = new bn("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function (t) {
      return t !== null ? t : {};
    },
  }),
  B9 = new D9({ explicit: [Q9, F9, V9] });
function XJ(t) {
  if (t === null) return !0;
  var e = t.length;
  return (e === 1 && t === "~") || (e === 4 && (t === "null" || t === "Null" || t === "NULL"));
}
function HJ() {
  return null;
}
function qJ(t) {
  return t === null;
}
var j9 = new bn("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: XJ,
  construct: HJ,
  predicate: qJ,
  represent: {
    canonical: function () {
      return "~";
    },
    lowercase: function () {
      return "null";
    },
    uppercase: function () {
      return "NULL";
    },
    camelcase: function () {
      return "Null";
    },
    empty: function () {
      return "";
    },
  },
  defaultStyle: "lowercase",
});
function YJ(t) {
  if (t === null) return !1;
  var e = t.length;
  return (e === 4 && (t === "true" || t === "True" || t === "TRUE")) || (e === 5 && (t === "false" || t === "False" || t === "FALSE"));
}
function GJ(t) {
  return t === "true" || t === "True" || t === "TRUE";
}
function JJ(t) {
  return Object.prototype.toString.call(t) === "[object Boolean]";
}
var Z9 = new bn("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: YJ,
  construct: GJ,
  predicate: JJ,
  represent: {
    lowercase: function (t) {
      return t ? "true" : "false";
    },
    uppercase: function (t) {
      return t ? "TRUE" : "FALSE";
    },
    camelcase: function (t) {
      return t ? "True" : "False";
    },
  },
  defaultStyle: "lowercase",
});
function KJ(t) {
  return (48 <= t && t <= 57) || (65 <= t && t <= 70) || (97 <= t && t <= 102);
}
function eK(t) {
  return 48 <= t && t <= 55;
}
function tK(t) {
  return 48 <= t && t <= 57;
}
function nK(t) {
  if (t === null) return !1;
  var e = t.length,
    n = 0,
    r = !1,
    i;
  if (!e) return !1;
  if (((i = t[n]), (i === "-" || i === "+") && (i = t[++n]), i === "0")) {
    if (n + 1 === e) return !0;
    if (((i = t[++n]), i === "b")) {
      for (n++; n < e; n++)
        if (((i = t[n]), i !== "_")) {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < e; n++)
        if (((i = t[n]), i !== "_")) {
          if (!KJ(t.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < e; n++)
        if (((i = t[n]), i !== "_")) {
          if (!eK(t.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < e; n++)
    if (((i = t[n]), i !== "_")) {
      if (!tK(t.charCodeAt(n))) return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function rK(t) {
  var e = t,
    n = 1,
    r;
  if (
    (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")),
    (r = e[0]),
    (r === "-" || r === "+") && (r === "-" && (n = -1), (e = e.slice(1)), (r = e[0])),
    e === "0")
  )
    return 0;
  if (r === "0") {
    if (e[1] === "b") return n * parseInt(e.slice(2), 2);
    if (e[1] === "x") return n * parseInt(e.slice(2), 16);
    if (e[1] === "o") return n * parseInt(e.slice(2), 8);
  }
  return n * parseInt(e, 10);
}
function iK(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !nn.isNegativeZero(t);
}
var z9 = new bn("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: nK,
    construct: rK,
    predicate: iK,
    represent: {
      binary: function (t) {
        return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
      },
      octal: function (t) {
        return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
      },
      decimal: function (t) {
        return t.toString(10);
      },
      hexadecimal: function (t) {
        return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
      },
    },
    defaultStyle: "decimal",
    styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] },
  }),
  sK = new RegExp(
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
function oK(t) {
  return !(t === null || !sK.test(t) || t[t.length - 1] === "_");
}
function aK(t) {
  var e, n;
  return (
    (e = t.replace(/_/g, "").toLowerCase()),
    (n = e[0] === "-" ? -1 : 1),
    "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)),
    e === ".inf" ? (n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY) : e === ".nan" ? NaN : n * parseFloat(e, 10)
  );
}
var lK = /^[-+]?[0-9]+e/;
function cK(t, e) {
  var n;
  if (isNaN(t))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (nn.isNegativeZero(t)) return "-0.0";
  return (n = t.toString(10)), lK.test(n) ? n.replace("e", ".e") : n;
}
function uK(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || nn.isNegativeZero(t));
}
var W9 = new bn("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: oK,
    construct: aK,
    predicate: uK,
    represent: cK,
    defaultStyle: "lowercase",
  }),
  U9 = B9.extend({ implicit: [j9, Z9, z9, W9] }),
  X9 = U9,
  H9 = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
  q9 = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
function hK(t) {
  return t === null ? !1 : H9.exec(t) !== null || q9.exec(t) !== null;
}
function fK(t) {
  var e,
    n,
    r,
    i,
    s,
    o,
    a,
    l = 0,
    c = null,
    u,
    h,
    f;
  if (((e = H9.exec(t)), e === null && (e = q9.exec(t)), e === null)) throw new Error("Date resolve error");
  if (((n = +e[1]), (r = +e[2] - 1), (i = +e[3]), !e[4])) return new Date(Date.UTC(n, r, i));
  if (((s = +e[4]), (o = +e[5]), (a = +e[6]), e[7])) {
    for (l = e[7].slice(0, 3); l.length < 3; ) l += "0";
    l = +l;
  }
  return (
    e[9] && ((u = +e[10]), (h = +(e[11] || 0)), (c = (u * 60 + h) * 6e4), e[9] === "-" && (c = -c)),
    (f = new Date(Date.UTC(n, r, i, s, o, a, l))),
    c && f.setTime(f.getTime() - c),
    f
  );
}
function dK(t) {
  return t.toISOString();
}
var Y9 = new bn("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: hK, construct: fK, instanceOf: Date, represent: dK });
function pK(t) {
  return t === "<<" || t === null;
}
var G9 = new bn("tag:yaml.org,2002:merge", { kind: "scalar", resolve: pK }),
  nw = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function mK(t) {
  if (t === null) return !1;
  var e,
    n,
    r = 0,
    i = t.length,
    s = nw;
  for (n = 0; n < i; n++)
    if (((e = s.indexOf(t.charAt(n))), !(e > 64))) {
      if (e < 0) return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function gK(t) {
  var e,
    n,
    r = t.replace(/[\r\n=]/g, ""),
    i = r.length,
    s = nw,
    o = 0,
    a = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (a.push((o >> 16) & 255), a.push((o >> 8) & 255), a.push(o & 255)), (o = (o << 6) | s.indexOf(r.charAt(e)));
  return (
    (n = (i % 4) * 6),
    n === 0
      ? (a.push((o >> 16) & 255), a.push((o >> 8) & 255), a.push(o & 255))
      : n === 18
      ? (a.push((o >> 10) & 255), a.push((o >> 2) & 255))
      : n === 12 && a.push((o >> 4) & 255),
    new Uint8Array(a)
  );
}
function OK(t) {
  var e = "",
    n = 0,
    r,
    i,
    s = t.length,
    o = nw;
  for (r = 0; r < s; r++)
    r % 3 === 0 && r && ((e += o[(n >> 18) & 63]), (e += o[(n >> 12) & 63]), (e += o[(n >> 6) & 63]), (e += o[n & 63])),
      (n = (n << 8) + t[r]);
  return (
    (i = s % 3),
    i === 0
      ? ((e += o[(n >> 18) & 63]), (e += o[(n >> 12) & 63]), (e += o[(n >> 6) & 63]), (e += o[n & 63]))
      : i === 2
      ? ((e += o[(n >> 10) & 63]), (e += o[(n >> 4) & 63]), (e += o[(n << 2) & 63]), (e += o[64]))
      : i === 1 && ((e += o[(n >> 2) & 63]), (e += o[(n << 4) & 63]), (e += o[64]), (e += o[64])),
    e
  );
}
function vK(t) {
  return Object.prototype.toString.call(t) === "[object Uint8Array]";
}
var J9 = new bn("tag:yaml.org,2002:binary", { kind: "scalar", resolve: mK, construct: gK, predicate: vK, represent: OK }),
  xK = Object.prototype.hasOwnProperty,
  bK = Object.prototype.toString;
function yK(t) {
  if (t === null) return !0;
  var e = [],
    n,
    r,
    i,
    s,
    o,
    a = t;
  for (n = 0, r = a.length; n < r; n += 1) {
    if (((i = a[n]), (o = !1), bK.call(i) !== "[object Object]")) return !1;
    for (s in i)
      if (xK.call(i, s))
        if (!o) o = !0;
        else return !1;
    if (!o) return !1;
    if (e.indexOf(s) === -1) e.push(s);
    else return !1;
  }
  return !0;
}
function wK(t) {
  return t !== null ? t : [];
}
var K9 = new bn("tag:yaml.org,2002:omap", { kind: "sequence", resolve: yK, construct: wK }),
  SK = Object.prototype.toString;
function kK(t) {
  if (t === null) return !0;
  var e,
    n,
    r,
    i,
    s,
    o = t;
  for (s = new Array(o.length), e = 0, n = o.length; e < n; e += 1) {
    if (((r = o[e]), SK.call(r) !== "[object Object]" || ((i = Object.keys(r)), i.length !== 1))) return !1;
    s[e] = [i[0], r[i[0]]];
  }
  return !0;
}
function CK(t) {
  if (t === null) return [];
  var e,
    n,
    r,
    i,
    s,
    o = t;
  for (s = new Array(o.length), e = 0, n = o.length; e < n; e += 1) (r = o[e]), (i = Object.keys(r)), (s[e] = [i[0], r[i[0]]]);
  return s;
}
var e7 = new bn("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: kK, construct: CK }),
  _K = Object.prototype.hasOwnProperty;
function EK(t) {
  if (t === null) return !0;
  var e,
    n = t;
  for (e in n) if (_K.call(n, e) && n[e] !== null) return !1;
  return !0;
}
function TK(t) {
  return t !== null ? t : {};
}
var t7 = new bn("tag:yaml.org,2002:set", { kind: "mapping", resolve: EK, construct: TK }),
  rw = X9.extend({ implicit: [Y9, G9], explicit: [J9, K9, e7, t7] }),
  no = Object.prototype.hasOwnProperty,
  kp = 1,
  n7 = 2,
  r7 = 3,
  Cp = 4,
  $0 = 1,
  PK = 2,
  UC = 3,
  AK =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  $K = /[\x85\u2028\u2029]/,
  RK = /[,\[\]\{\}]/,
  i7 = /^(?:!|!!|![a-z\-]+!)$/i,
  s7 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function XC(t) {
  return Object.prototype.toString.call(t);
}
function Ti(t) {
  return t === 10 || t === 13;
}
function Do(t) {
  return t === 9 || t === 32;
}
function Jn(t) {
  return t === 9 || t === 32 || t === 10 || t === 13;
}
function Va(t) {
  return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
function IK(t) {
  var e;
  return 48 <= t && t <= 57 ? t - 48 : ((e = t | 32), 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function NK(t) {
  return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
function LK(t) {
  return 48 <= t && t <= 57 ? t - 48 : -1;
}
function HC(t) {
  return t === 48
    ? "\0"
    : t === 97
    ? "\x07"
    : t === 98
    ? "\b"
    : t === 116 || t === 9
    ? "	"
    : t === 110
    ? `
`
    : t === 118
    ? "\v"
    : t === 102
    ? "\f"
    : t === 114
    ? "\r"
    : t === 101
    ? "\x1B"
    : t === 32
    ? " "
    : t === 34
    ? '"'
    : t === 47
    ? "/"
    : t === 92
    ? "\\"
    : t === 78
    ? ""
    : t === 95
    ? " "
    : t === 76
    ? "\u2028"
    : t === 80
    ? "\u2029"
    : "";
}
function MK(t) {
  return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode(((t - 65536) >> 10) + 55296, ((t - 65536) & 1023) + 56320);
}
var o7 = new Array(256),
  a7 = new Array(256);
for (var Sa = 0; Sa < 256; Sa++) (o7[Sa] = HC(Sa) ? 1 : 0), (a7[Sa] = HC(Sa));
function DK(t, e) {
  (this.input = t),
    (this.filename = e.filename || null),
    (this.schema = e.schema || rw),
    (this.onWarning = e.onWarning || null),
    (this.legacy = e.legacy || !1),
    (this.json = e.json || !1),
    (this.listener = e.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = t.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = []);
}
function l7(t, e) {
  var n = { name: t.filename, buffer: t.input.slice(0, -1), position: t.position, line: t.line, column: t.position - t.lineStart };
  return (n.snippet = BJ(n)), new Mn(e, n);
}
function Te(t, e) {
  throw l7(t, e);
}
function _p(t, e) {
  t.onWarning && t.onWarning.call(null, l7(t, e));
}
var qC = {
  YAML: function (e, n, r) {
    var i, s, o;
    e.version !== null && Te(e, "duplication of %YAML directive"),
      r.length !== 1 && Te(e, "YAML directive accepts exactly one argument"),
      (i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])),
      i === null && Te(e, "ill-formed argument of the YAML directive"),
      (s = parseInt(i[1], 10)),
      (o = parseInt(i[2], 10)),
      s !== 1 && Te(e, "unacceptable YAML version of the document"),
      (e.version = r[0]),
      (e.checkLineBreaks = o < 2),
      o !== 1 && o !== 2 && _p(e, "unsupported YAML version of the document");
  },
  TAG: function (e, n, r) {
    var i, s;
    r.length !== 2 && Te(e, "TAG directive accepts exactly two arguments"),
      (i = r[0]),
      (s = r[1]),
      i7.test(i) || Te(e, "ill-formed tag handle (first argument) of the TAG directive"),
      no.call(e.tagMap, i) && Te(e, 'there is a previously declared suffix for "' + i + '" tag handle'),
      s7.test(s) || Te(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      Te(e, "tag prefix is malformed: " + s);
    }
    e.tagMap[i] = s;
  },
};
function Xs(t, e, n, r) {
  var i, s, o, a;
  if (e < n) {
    if (((a = t.input.slice(e, n)), r))
      for (i = 0, s = a.length; i < s; i += 1)
        (o = a.charCodeAt(i)), o === 9 || (32 <= o && o <= 1114111) || Te(t, "expected valid JSON character");
    else AK.test(a) && Te(t, "the stream contains non-printable characters");
    t.result += a;
  }
}
function YC(t, e, n, r) {
  var i, s, o, a;
  for (
    nn.isObject(n) || Te(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), o = 0, a = i.length;
    o < a;
    o += 1
  )
    (s = i[o]), no.call(e, s) || ((e[s] = n[s]), (r[s] = !0));
}
function Ba(t, e, n, r, i, s, o, a, l) {
  var c, u;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, u = i.length; c < u; c += 1)
      Array.isArray(i[c]) && Te(t, "nested arrays are not supported inside keys"),
        typeof i == "object" && XC(i[c]) === "[object Object]" && (i[c] = "[object Object]");
  if (
    (typeof i == "object" && XC(i) === "[object Object]" && (i = "[object Object]"),
    (i = String(i)),
    e === null && (e = {}),
    r === "tag:yaml.org,2002:merge")
  )
    if (Array.isArray(s)) for (c = 0, u = s.length; c < u; c += 1) YC(t, e, s[c], n);
    else YC(t, e, s, n);
  else
    !t.json &&
      !no.call(n, i) &&
      no.call(e, i) &&
      ((t.line = o || t.line), (t.lineStart = a || t.lineStart), (t.position = l || t.position), Te(t, "duplicated mapping key")),
      i === "__proto__" ? Object.defineProperty(e, i, { configurable: !0, enumerable: !0, writable: !0, value: s }) : (e[i] = s),
      delete n[i];
  return e;
}
function iw(t) {
  var e;
  (e = t.input.charCodeAt(t.position)),
    e === 10
      ? t.position++
      : e === 13
      ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++)
      : Te(t, "a line break is expected"),
    (t.line += 1),
    (t.lineStart = t.position),
    (t.firstTabInLine = -1);
}
function Yt(t, e, n) {
  for (var r = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
    for (; Do(i); ) i === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), (i = t.input.charCodeAt(++t.position));
    if (e && i === 35)
      do i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (Ti(i))
      for (iw(t), i = t.input.charCodeAt(t.position), r++, t.lineIndent = 0; i === 32; )
        t.lineIndent++, (i = t.input.charCodeAt(++t.position));
    else break;
  }
  return n !== -1 && r !== 0 && t.lineIndent < n && _p(t, "deficient indentation"), r;
}
function hg(t) {
  var e = t.position,
    n;
  return (
    (n = t.input.charCodeAt(e)),
    !!(
      (n === 45 || n === 46) &&
      n === t.input.charCodeAt(e + 1) &&
      n === t.input.charCodeAt(e + 2) &&
      ((e += 3), (n = t.input.charCodeAt(e)), n === 0 || Jn(n))
    )
  );
}
function sw(t, e) {
  e === 1
    ? (t.result += " ")
    : e > 1 &&
      (t.result += nn.repeat(
        `
`,
        e - 1
      ));
}
function QK(t, e, n) {
  var r,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    h = t.kind,
    f = t.result,
    d;
  if (
    ((d = t.input.charCodeAt(t.position)),
    Jn(d) ||
      Va(d) ||
      d === 35 ||
      d === 38 ||
      d === 42 ||
      d === 33 ||
      d === 124 ||
      d === 62 ||
      d === 39 ||
      d === 34 ||
      d === 37 ||
      d === 64 ||
      d === 96 ||
      ((d === 63 || d === 45) && ((i = t.input.charCodeAt(t.position + 1)), Jn(i) || (n && Va(i)))))
  )
    return !1;
  for (t.kind = "scalar", t.result = "", s = o = t.position, a = !1; d !== 0; ) {
    if (d === 58) {
      if (((i = t.input.charCodeAt(t.position + 1)), Jn(i) || (n && Va(i)))) break;
    } else if (d === 35) {
      if (((r = t.input.charCodeAt(t.position - 1)), Jn(r))) break;
    } else {
      if ((t.position === t.lineStart && hg(t)) || (n && Va(d))) break;
      if (Ti(d))
        if (((l = t.line), (c = t.lineStart), (u = t.lineIndent), Yt(t, !1, -1), t.lineIndent >= e)) {
          (a = !0), (d = t.input.charCodeAt(t.position));
          continue;
        } else {
          (t.position = o), (t.line = l), (t.lineStart = c), (t.lineIndent = u);
          break;
        }
    }
    a && (Xs(t, s, o, !1), sw(t, t.line - l), (s = o = t.position), (a = !1)),
      Do(d) || (o = t.position + 1),
      (d = t.input.charCodeAt(++t.position));
  }
  return Xs(t, s, o, !1), t.result ? !0 : ((t.kind = h), (t.result = f), !1);
}
function FK(t, e) {
  var n, r, i;
  if (((n = t.input.charCodeAt(t.position)), n !== 39)) return !1;
  for (t.kind = "scalar", t.result = "", t.position++, r = i = t.position; (n = t.input.charCodeAt(t.position)) !== 0; )
    if (n === 39)
      if ((Xs(t, r, t.position, !0), (n = t.input.charCodeAt(++t.position)), n === 39)) (r = t.position), t.position++, (i = t.position);
      else return !0;
    else
      Ti(n)
        ? (Xs(t, r, i, !0), sw(t, Yt(t, !1, e)), (r = i = t.position))
        : t.position === t.lineStart && hg(t)
        ? Te(t, "unexpected end of the document within a single quoted scalar")
        : (t.position++, (i = t.position));
  Te(t, "unexpected end of the stream within a single quoted scalar");
}
function VK(t, e) {
  var n, r, i, s, o, a;
  if (((a = t.input.charCodeAt(t.position)), a !== 34)) return !1;
  for (t.kind = "scalar", t.result = "", t.position++, n = r = t.position; (a = t.input.charCodeAt(t.position)) !== 0; ) {
    if (a === 34) return Xs(t, n, t.position, !0), t.position++, !0;
    if (a === 92) {
      if ((Xs(t, n, t.position, !0), (a = t.input.charCodeAt(++t.position)), Ti(a))) Yt(t, !1, e);
      else if (a < 256 && o7[a]) (t.result += a7[a]), t.position++;
      else if ((o = NK(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          (a = t.input.charCodeAt(++t.position)), (o = IK(a)) >= 0 ? (s = (s << 4) + o) : Te(t, "expected hexadecimal character");
        (t.result += MK(s)), t.position++;
      } else Te(t, "unknown escape sequence");
      n = r = t.position;
    } else
      Ti(a)
        ? (Xs(t, n, r, !0), sw(t, Yt(t, !1, e)), (n = r = t.position))
        : t.position === t.lineStart && hg(t)
        ? Te(t, "unexpected end of the document within a double quoted scalar")
        : (t.position++, (r = t.position));
  }
  Te(t, "unexpected end of the stream within a double quoted scalar");
}
function BK(t, e) {
  var n = !0,
    r,
    i,
    s,
    o = t.tag,
    a,
    l = t.anchor,
    c,
    u,
    h,
    f,
    d,
    p = Object.create(null),
    m,
    O,
    v,
    g;
  if (((g = t.input.charCodeAt(t.position)), g === 91)) (u = 93), (d = !1), (a = []);
  else if (g === 123) (u = 125), (d = !0), (a = {});
  else return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = a), g = t.input.charCodeAt(++t.position); g !== 0; ) {
    if ((Yt(t, !0, e), (g = t.input.charCodeAt(t.position)), g === u))
      return t.position++, (t.tag = o), (t.anchor = l), (t.kind = d ? "mapping" : "sequence"), (t.result = a), !0;
    n ? g === 44 && Te(t, "expected the node content, but found ','") : Te(t, "missed comma between flow collection entries"),
      (O = m = v = null),
      (h = f = !1),
      g === 63 && ((c = t.input.charCodeAt(t.position + 1)), Jn(c) && ((h = f = !0), t.position++, Yt(t, !0, e))),
      (r = t.line),
      (i = t.lineStart),
      (s = t.position),
      bl(t, e, kp, !1, !0),
      (O = t.tag),
      (m = t.result),
      Yt(t, !0, e),
      (g = t.input.charCodeAt(t.position)),
      (f || t.line === r) &&
        g === 58 &&
        ((h = !0), (g = t.input.charCodeAt(++t.position)), Yt(t, !0, e), bl(t, e, kp, !1, !0), (v = t.result)),
      d ? Ba(t, a, p, O, m, v, r, i, s) : h ? a.push(Ba(t, null, p, O, m, v, r, i, s)) : a.push(m),
      Yt(t, !0, e),
      (g = t.input.charCodeAt(t.position)),
      g === 44 ? ((n = !0), (g = t.input.charCodeAt(++t.position))) : (n = !1);
  }
  Te(t, "unexpected end of the stream within a flow collection");
}
function jK(t, e) {
  var n,
    r,
    i = $0,
    s = !1,
    o = !1,
    a = e,
    l = 0,
    c = !1,
    u,
    h;
  if (((h = t.input.charCodeAt(t.position)), h === 124)) r = !1;
  else if (h === 62) r = !0;
  else return !1;
  for (t.kind = "scalar", t.result = ""; h !== 0; )
    if (((h = t.input.charCodeAt(++t.position)), h === 43 || h === 45))
      $0 === i ? (i = h === 43 ? UC : PK) : Te(t, "repeat of a chomping mode identifier");
    else if ((u = LK(h)) >= 0)
      u === 0
        ? Te(t, "bad explicit indentation width of a block scalar; it cannot be less than one")
        : o
        ? Te(t, "repeat of an indentation width identifier")
        : ((a = e + u - 1), (o = !0));
    else break;
  if (Do(h)) {
    do h = t.input.charCodeAt(++t.position);
    while (Do(h));
    if (h === 35)
      do h = t.input.charCodeAt(++t.position);
      while (!Ti(h) && h !== 0);
  }
  for (; h !== 0; ) {
    for (iw(t), t.lineIndent = 0, h = t.input.charCodeAt(t.position); (!o || t.lineIndent < a) && h === 32; )
      t.lineIndent++, (h = t.input.charCodeAt(++t.position));
    if ((!o && t.lineIndent > a && (a = t.lineIndent), Ti(h))) {
      l++;
      continue;
    }
    if (t.lineIndent < a) {
      i === UC
        ? (t.result += nn.repeat(
            `
`,
            s ? 1 + l : l
          ))
        : i === $0 &&
          s &&
          (t.result += `
`);
      break;
    }
    for (
      r
        ? Do(h)
          ? ((c = !0),
            (t.result += nn.repeat(
              `
`,
              s ? 1 + l : l
            )))
          : c
          ? ((c = !1),
            (t.result += nn.repeat(
              `
`,
              l + 1
            )))
          : l === 0
          ? s && (t.result += " ")
          : (t.result += nn.repeat(
              `
`,
              l
            ))
        : (t.result += nn.repeat(
            `
`,
            s ? 1 + l : l
          )),
        s = !0,
        o = !0,
        l = 0,
        n = t.position;
      !Ti(h) && h !== 0;

    )
      h = t.input.charCodeAt(++t.position);
    Xs(t, n, t.position, !1);
  }
  return !0;
}
function GC(t, e) {
  var n,
    r = t.tag,
    i = t.anchor,
    s = [],
    o,
    a = !1,
    l;
  if (t.firstTabInLine !== -1) return !1;
  for (
    t.anchor !== null && (t.anchorMap[t.anchor] = s), l = t.input.charCodeAt(t.position);
    l !== 0 &&
    (t.firstTabInLine !== -1 && ((t.position = t.firstTabInLine), Te(t, "tab characters must not be used in indentation")),
    !(l !== 45 || ((o = t.input.charCodeAt(t.position + 1)), !Jn(o))));

  ) {
    if (((a = !0), t.position++, Yt(t, !0, -1) && t.lineIndent <= e)) {
      s.push(null), (l = t.input.charCodeAt(t.position));
      continue;
    }
    if (
      ((n = t.line),
      bl(t, e, r7, !1, !0),
      s.push(t.result),
      Yt(t, !0, -1),
      (l = t.input.charCodeAt(t.position)),
      (t.line === n || t.lineIndent > e) && l !== 0)
    )
      Te(t, "bad indentation of a sequence entry");
    else if (t.lineIndent < e) break;
  }
  return a ? ((t.tag = r), (t.anchor = i), (t.kind = "sequence"), (t.result = s), !0) : !1;
}
function ZK(t, e, n) {
  var r,
    i,
    s,
    o,
    a,
    l,
    c = t.tag,
    u = t.anchor,
    h = {},
    f = Object.create(null),
    d = null,
    p = null,
    m = null,
    O = !1,
    v = !1,
    g;
  if (t.firstTabInLine !== -1) return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = h), g = t.input.charCodeAt(t.position); g !== 0; ) {
    if (
      (!O && t.firstTabInLine !== -1 && ((t.position = t.firstTabInLine), Te(t, "tab characters must not be used in indentation")),
      (r = t.input.charCodeAt(t.position + 1)),
      (s = t.line),
      (g === 63 || g === 58) && Jn(r))
    )
      g === 63
        ? (O && (Ba(t, h, f, d, p, null, o, a, l), (d = p = m = null)), (v = !0), (O = !0), (i = !0))
        : O
        ? ((O = !1), (i = !0))
        : Te(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"),
        (t.position += 1),
        (g = r);
    else {
      if (((o = t.line), (a = t.lineStart), (l = t.position), !bl(t, n, n7, !1, !0))) break;
      if (t.line === s) {
        for (g = t.input.charCodeAt(t.position); Do(g); ) g = t.input.charCodeAt(++t.position);
        if (g === 58)
          (g = t.input.charCodeAt(++t.position)),
            Jn(g) || Te(t, "a whitespace character is expected after the key-value separator within a block mapping"),
            O && (Ba(t, h, f, d, p, null, o, a, l), (d = p = m = null)),
            (v = !0),
            (O = !1),
            (i = !1),
            (d = t.tag),
            (p = t.result);
        else if (v) Te(t, "can not read an implicit mapping pair; a colon is missed");
        else return (t.tag = c), (t.anchor = u), !0;
      } else if (v) Te(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else return (t.tag = c), (t.anchor = u), !0;
    }
    if (
      ((t.line === s || t.lineIndent > e) &&
        (O && ((o = t.line), (a = t.lineStart), (l = t.position)),
        bl(t, e, Cp, !0, i) && (O ? (p = t.result) : (m = t.result)),
        O || (Ba(t, h, f, d, p, m, o, a, l), (d = p = m = null)),
        Yt(t, !0, -1),
        (g = t.input.charCodeAt(t.position))),
      (t.line === s || t.lineIndent > e) && g !== 0)
    )
      Te(t, "bad indentation of a mapping entry");
    else if (t.lineIndent < e) break;
  }
  return O && Ba(t, h, f, d, p, null, o, a, l), v && ((t.tag = c), (t.anchor = u), (t.kind = "mapping"), (t.result = h)), v;
}
function zK(t) {
  var e,
    n = !1,
    r = !1,
    i,
    s,
    o;
  if (((o = t.input.charCodeAt(t.position)), o !== 33)) return !1;
  if (
    (t.tag !== null && Te(t, "duplication of a tag property"),
    (o = t.input.charCodeAt(++t.position)),
    o === 60
      ? ((n = !0), (o = t.input.charCodeAt(++t.position)))
      : o === 33
      ? ((r = !0), (i = "!!"), (o = t.input.charCodeAt(++t.position)))
      : (i = "!"),
    (e = t.position),
    n)
  ) {
    do o = t.input.charCodeAt(++t.position);
    while (o !== 0 && o !== 62);
    t.position < t.length
      ? ((s = t.input.slice(e, t.position)), (o = t.input.charCodeAt(++t.position)))
      : Te(t, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !Jn(o); )
      o === 33 &&
        (r
          ? Te(t, "tag suffix cannot contain exclamation marks")
          : ((i = t.input.slice(e - 1, t.position + 1)),
            i7.test(i) || Te(t, "named tag handle cannot contain such characters"),
            (r = !0),
            (e = t.position + 1))),
        (o = t.input.charCodeAt(++t.position));
    (s = t.input.slice(e, t.position)), RK.test(s) && Te(t, "tag suffix cannot contain flow indicator characters");
  }
  s && !s7.test(s) && Te(t, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    Te(t, "tag name is malformed: " + s);
  }
  return (
    n
      ? (t.tag = s)
      : no.call(t.tagMap, i)
      ? (t.tag = t.tagMap[i] + s)
      : i === "!"
      ? (t.tag = "!" + s)
      : i === "!!"
      ? (t.tag = "tag:yaml.org,2002:" + s)
      : Te(t, 'undeclared tag handle "' + i + '"'),
    !0
  );
}
function WK(t) {
  var e, n;
  if (((n = t.input.charCodeAt(t.position)), n !== 38)) return !1;
  for (
    t.anchor !== null && Te(t, "duplication of an anchor property"), n = t.input.charCodeAt(++t.position), e = t.position;
    n !== 0 && !Jn(n) && !Va(n);

  )
    n = t.input.charCodeAt(++t.position);
  return (
    t.position === e && Te(t, "name of an anchor node must contain at least one character"), (t.anchor = t.input.slice(e, t.position)), !0
  );
}
function UK(t) {
  var e, n, r;
  if (((r = t.input.charCodeAt(t.position)), r !== 42)) return !1;
  for (r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !Jn(r) && !Va(r); ) r = t.input.charCodeAt(++t.position);
  return (
    t.position === e && Te(t, "name of an alias node must contain at least one character"),
    (n = t.input.slice(e, t.position)),
    no.call(t.anchorMap, n) || Te(t, 'unidentified alias "' + n + '"'),
    (t.result = t.anchorMap[n]),
    Yt(t, !0, -1),
    !0
  );
}
function bl(t, e, n, r, i) {
  var s,
    o,
    a,
    l = 1,
    c = !1,
    u = !1,
    h,
    f,
    d,
    p,
    m,
    O;
  if (
    (t.listener !== null && t.listener("open", t),
    (t.tag = null),
    (t.anchor = null),
    (t.kind = null),
    (t.result = null),
    (s = o = a = Cp === n || r7 === n),
    r && Yt(t, !0, -1) && ((c = !0), t.lineIndent > e ? (l = 1) : t.lineIndent === e ? (l = 0) : t.lineIndent < e && (l = -1)),
    l === 1)
  )
    for (; zK(t) || WK(t); )
      Yt(t, !0, -1)
        ? ((c = !0), (a = s), t.lineIndent > e ? (l = 1) : t.lineIndent === e ? (l = 0) : t.lineIndent < e && (l = -1))
        : (a = !1);
  if (
    (a && (a = c || i),
    (l === 1 || Cp === n) &&
      (kp === n || n7 === n ? (m = e) : (m = e + 1),
      (O = t.position - t.lineStart),
      l === 1
        ? (a && (GC(t, O) || ZK(t, O, m))) || BK(t, m)
          ? (u = !0)
          : ((o && jK(t, m)) || FK(t, m) || VK(t, m)
              ? (u = !0)
              : UK(t)
              ? ((u = !0), (t.tag !== null || t.anchor !== null) && Te(t, "alias node should not have any properties"))
              : QK(t, m, kp === n) && ((u = !0), t.tag === null && (t.tag = "?")),
            t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
        : l === 0 && (u = a && GC(t, O))),
    t.tag === null)
  )
    t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
  else if (t.tag === "?") {
    for (
      t.result !== null && t.kind !== "scalar" && Te(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'),
        h = 0,
        f = t.implicitTypes.length;
      h < f;
      h += 1
    )
      if (((p = t.implicitTypes[h]), p.resolve(t.result))) {
        (t.result = p.construct(t.result)), (t.tag = p.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
  } else if (t.tag !== "!") {
    if (no.call(t.typeMap[t.kind || "fallback"], t.tag)) p = t.typeMap[t.kind || "fallback"][t.tag];
    else
      for (p = null, d = t.typeMap.multi[t.kind || "fallback"], h = 0, f = d.length; h < f; h += 1)
        if (t.tag.slice(0, d[h].tag.length) === d[h].tag) {
          p = d[h];
          break;
        }
    p || Te(t, "unknown tag !<" + t.tag + ">"),
      t.result !== null &&
        p.kind !== t.kind &&
        Te(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + p.kind + '", not "' + t.kind + '"'),
      p.resolve(t.result, t.tag)
        ? ((t.result = p.construct(t.result, t.tag)), t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
        : Te(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
  }
  return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || u;
}
function XK(t) {
  var e = t.position,
    n,
    r,
    i,
    s = !1,
    o;
  for (
    t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = Object.create(null), t.anchorMap = Object.create(null);
    (o = t.input.charCodeAt(t.position)) !== 0 && (Yt(t, !0, -1), (o = t.input.charCodeAt(t.position)), !(t.lineIndent > 0 || o !== 37));

  ) {
    for (s = !0, o = t.input.charCodeAt(++t.position), n = t.position; o !== 0 && !Jn(o); ) o = t.input.charCodeAt(++t.position);
    for (
      r = t.input.slice(n, t.position), i = [], r.length < 1 && Te(t, "directive name must not be less than one character in length");
      o !== 0;

    ) {
      for (; Do(o); ) o = t.input.charCodeAt(++t.position);
      if (o === 35) {
        do o = t.input.charCodeAt(++t.position);
        while (o !== 0 && !Ti(o));
        break;
      }
      if (Ti(o)) break;
      for (n = t.position; o !== 0 && !Jn(o); ) o = t.input.charCodeAt(++t.position);
      i.push(t.input.slice(n, t.position));
    }
    o !== 0 && iw(t), no.call(qC, r) ? qC[r](t, r, i) : _p(t, 'unknown document directive "' + r + '"');
  }
  if (
    (Yt(t, !0, -1),
    t.lineIndent === 0 &&
    t.input.charCodeAt(t.position) === 45 &&
    t.input.charCodeAt(t.position + 1) === 45 &&
    t.input.charCodeAt(t.position + 2) === 45
      ? ((t.position += 3), Yt(t, !0, -1))
      : s && Te(t, "directives end mark is expected"),
    bl(t, t.lineIndent - 1, Cp, !1, !0),
    Yt(t, !0, -1),
    t.checkLineBreaks && $K.test(t.input.slice(e, t.position)) && _p(t, "non-ASCII line breaks are interpreted as content"),
    t.documents.push(t.result),
    t.position === t.lineStart && hg(t))
  ) {
    t.input.charCodeAt(t.position) === 46 && ((t.position += 3), Yt(t, !0, -1));
    return;
  }
  if (t.position < t.length - 1) Te(t, "end of the stream or a document separator is expected");
  else return;
}
function c7(t, e) {
  (t = String(t)),
    (e = e || {}),
    t.length !== 0 &&
      (t.charCodeAt(t.length - 1) !== 10 &&
        t.charCodeAt(t.length - 1) !== 13 &&
        (t += `
`),
      t.charCodeAt(0) === 65279 && (t = t.slice(1)));
  var n = new DK(t, e),
    r = t.indexOf("\0");
  for (r !== -1 && ((n.position = r), Te(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    (n.lineIndent += 1), (n.position += 1);
  for (; n.position < n.length - 1; ) XK(n);
  return n.documents;
}
function HK(t, e, n) {
  e !== null && typeof e == "object" && typeof n > "u" && ((n = e), (e = null));
  var r = c7(t, n);
  if (typeof e != "function") return r;
  for (var i = 0, s = r.length; i < s; i += 1) e(r[i]);
}
function qK(t, e) {
  var n = c7(t, e);
  if (n.length !== 0) {
    if (n.length === 1) return n[0];
    throw new Mn("expected a single document in the stream, but found more");
  }
}
var YK = HK,
  GK = qK,
  u7 = { loadAll: YK, load: GK },
  h7 = Object.prototype.toString,
  f7 = Object.prototype.hasOwnProperty,
  ow = 65279,
  JK = 9,
  Nu = 10,
  KK = 13,
  eee = 32,
  tee = 33,
  nee = 34,
  nv = 35,
  ree = 37,
  iee = 38,
  see = 39,
  oee = 42,
  d7 = 44,
  aee = 45,
  Ep = 58,
  lee = 61,
  cee = 62,
  uee = 63,
  hee = 64,
  p7 = 91,
  m7 = 93,
  fee = 96,
  g7 = 123,
  dee = 124,
  O7 = 125,
  An = {};
An[0] = "\\0";
An[7] = "\\a";
An[8] = "\\b";
An[9] = "\\t";
An[10] = "\\n";
An[11] = "\\v";
An[12] = "\\f";
An[13] = "\\r";
An[27] = "\\e";
An[34] = '\\"';
An[92] = "\\\\";
An[133] = "\\N";
An[160] = "\\_";
An[8232] = "\\L";
An[8233] = "\\P";
var pee = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
  mee = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function gee(t, e) {
  var n, r, i, s, o, a, l;
  if (e === null) return {};
  for (n = {}, r = Object.keys(e), i = 0, s = r.length; i < s; i += 1)
    (o = r[i]),
      (a = String(e[o])),
      o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)),
      (l = t.compiledTypeMap.fallback[o]),
      l && f7.call(l.styleAliases, a) && (a = l.styleAliases[a]),
      (n[o] = a);
  return n;
}
function Oee(t) {
  var e, n, r;
  if (((e = t.toString(16).toUpperCase()), t <= 255)) (n = "x"), (r = 2);
  else if (t <= 65535) (n = "u"), (r = 4);
  else if (t <= 4294967295) (n = "U"), (r = 8);
  else throw new Mn("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + nn.repeat("0", r - e.length) + e;
}
var vee = 1,
  Lu = 2;
function xee(t) {
  (this.schema = t.schema || rw),
    (this.indent = Math.max(1, t.indent || 2)),
    (this.noArrayIndent = t.noArrayIndent || !1),
    (this.skipInvalid = t.skipInvalid || !1),
    (this.flowLevel = nn.isNothing(t.flowLevel) ? -1 : t.flowLevel),
    (this.styleMap = gee(this.schema, t.styles || null)),
    (this.sortKeys = t.sortKeys || !1),
    (this.lineWidth = t.lineWidth || 80),
    (this.noRefs = t.noRefs || !1),
    (this.noCompatMode = t.noCompatMode || !1),
    (this.condenseFlow = t.condenseFlow || !1),
    (this.quotingType = t.quotingType === '"' ? Lu : vee),
    (this.forceQuotes = t.forceQuotes || !1),
    (this.replacer = typeof t.replacer == "function" ? t.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ""),
    (this.duplicates = []),
    (this.usedDuplicates = null);
}
function JC(t, e) {
  for (var n = nn.repeat(" ", e), r = 0, i = -1, s = "", o, a = t.length; r < a; )
    (i = t.indexOf(
      `
`,
      r
    )),
      i === -1 ? ((o = t.slice(r)), (r = a)) : ((o = t.slice(r, i + 1)), (r = i + 1)),
      o.length &&
        o !==
          `
` &&
        (s += n),
      (s += o);
  return s;
}
function rv(t, e) {
  return (
    `
` + nn.repeat(" ", t.indent * e)
  );
}
function bee(t, e) {
  var n, r, i;
  for (n = 0, r = t.implicitTypes.length; n < r; n += 1) if (((i = t.implicitTypes[n]), i.resolve(e))) return !0;
  return !1;
}
function Tp(t) {
  return t === eee || t === JK;
}
function Mu(t) {
  return (
    (32 <= t && t <= 126) ||
    (161 <= t && t <= 55295 && t !== 8232 && t !== 8233) ||
    (57344 <= t && t <= 65533 && t !== ow) ||
    (65536 <= t && t <= 1114111)
  );
}
function KC(t) {
  return Mu(t) && t !== ow && t !== KK && t !== Nu;
}
function e_(t, e, n) {
  var r = KC(t),
    i = r && !Tp(t);
  return (
    ((n ? r : r && t !== d7 && t !== p7 && t !== m7 && t !== g7 && t !== O7) && t !== nv && !(e === Ep && !i)) ||
    (KC(e) && !Tp(e) && t === nv) ||
    (e === Ep && i)
  );
}
function yee(t) {
  return (
    Mu(t) &&
    t !== ow &&
    !Tp(t) &&
    t !== aee &&
    t !== uee &&
    t !== Ep &&
    t !== d7 &&
    t !== p7 &&
    t !== m7 &&
    t !== g7 &&
    t !== O7 &&
    t !== nv &&
    t !== iee &&
    t !== oee &&
    t !== tee &&
    t !== dee &&
    t !== lee &&
    t !== cee &&
    t !== see &&
    t !== nee &&
    t !== ree &&
    t !== hee &&
    t !== fee
  );
}
function wee(t) {
  return !Tp(t) && t !== Ep;
}
function Fc(t, e) {
  var n = t.charCodeAt(e),
    r;
  return n >= 55296 && n <= 56319 && e + 1 < t.length && ((r = t.charCodeAt(e + 1)), r >= 56320 && r <= 57343)
    ? (n - 55296) * 1024 + r - 56320 + 65536
    : n;
}
function v7(t) {
  var e = /^\n* /;
  return e.test(t);
}
var x7 = 1,
  iv = 2,
  b7 = 3,
  y7 = 4,
  Na = 5;
function See(t, e, n, r, i, s, o, a) {
  var l,
    c = 0,
    u = null,
    h = !1,
    f = !1,
    d = r !== -1,
    p = -1,
    m = yee(Fc(t, 0)) && wee(Fc(t, t.length - 1));
  if (e || o)
    for (l = 0; l < t.length; c >= 65536 ? (l += 2) : l++) {
      if (((c = Fc(t, l)), !Mu(c))) return Na;
      (m = m && e_(c, u, a)), (u = c);
    }
  else {
    for (l = 0; l < t.length; c >= 65536 ? (l += 2) : l++) {
      if (((c = Fc(t, l)), c === Nu)) (h = !0), d && ((f = f || (l - p - 1 > r && t[p + 1] !== " ")), (p = l));
      else if (!Mu(c)) return Na;
      (m = m && e_(c, u, a)), (u = c);
    }
    f = f || (d && l - p - 1 > r && t[p + 1] !== " ");
  }
  return !h && !f ? (m && !o && !i(t) ? x7 : s === Lu ? Na : iv) : n > 9 && v7(t) ? Na : o ? (s === Lu ? Na : iv) : f ? y7 : b7;
}
function kee(t, e, n, r, i) {
  t.dump = (function () {
    if (e.length === 0) return t.quotingType === Lu ? '""' : "''";
    if (!t.noCompatMode && (pee.indexOf(e) !== -1 || mee.test(e))) return t.quotingType === Lu ? '"' + e + '"' : "'" + e + "'";
    var s = t.indent * Math.max(1, n),
      o = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - s),
      a = r || (t.flowLevel > -1 && n >= t.flowLevel);
    function l(c) {
      return bee(t, c);
    }
    switch (See(e, a, t.indent, o, l, t.quotingType, t.forceQuotes && !r, i)) {
      case x7:
        return e;
      case iv:
        return "'" + e.replace(/'/g, "''") + "'";
      case b7:
        return "|" + t_(e, t.indent) + n_(JC(e, s));
      case y7:
        return ">" + t_(e, t.indent) + n_(JC(Cee(e, o), s));
      case Na:
        return '"' + _ee(e) + '"';
      default:
        throw new Mn("impossible error: invalid scalar style");
    }
  })();
}
function t_(t, e) {
  var n = v7(t) ? String(e) : "",
    r =
      t[t.length - 1] ===
      `
`,
    i =
      r &&
      (t[t.length - 2] ===
        `
` ||
        t ===
          `
`),
    s = i ? "+" : r ? "" : "-";
  return (
    n +
    s +
    `
`
  );
}
function n_(t) {
  return t[t.length - 1] ===
    `
`
    ? t.slice(0, -1)
    : t;
}
function Cee(t, e) {
  for (
    var n = /(\n+)([^\n]*)/g,
      r = (function () {
        var c = t.indexOf(`
`);
        return (c = c !== -1 ? c : t.length), (n.lastIndex = c), r_(t.slice(0, c), e);
      })(),
      i =
        t[0] ===
          `
` || t[0] === " ",
      s,
      o;
    (o = n.exec(t));

  ) {
    var a = o[1],
      l = o[2];
    (s = l[0] === " "),
      (r +=
        a +
        (!i && !s && l !== ""
          ? `
`
          : "") +
        r_(l, e)),
      (i = s);
  }
  return r;
}
function r_(t, e) {
  if (t === "" || t[0] === " ") return t;
  for (var n = / [^ ]/g, r, i = 0, s, o = 0, a = 0, l = ""; (r = n.exec(t)); )
    (a = r.index),
      a - i > e &&
        ((s = o > i ? o : a),
        (l +=
          `
` + t.slice(i, s)),
        (i = s + 1)),
      (o = a);
  return (
    (l += `
`),
    t.length - i > e && o > i
      ? (l +=
          t.slice(i, o) +
          `
` +
          t.slice(o + 1))
      : (l += t.slice(i)),
    l.slice(1)
  );
}
function _ee(t) {
  for (var e = "", n = 0, r, i = 0; i < t.length; n >= 65536 ? (i += 2) : i++)
    (n = Fc(t, i)), (r = An[n]), !r && Mu(n) ? ((e += t[i]), n >= 65536 && (e += t[i + 1])) : (e += r || Oee(n));
  return e;
}
function Eee(t, e, n) {
  var r = "",
    i = t.tag,
    s,
    o,
    a;
  for (s = 0, o = n.length; s < o; s += 1)
    (a = n[s]),
      t.replacer && (a = t.replacer.call(n, String(s), a)),
      (us(t, e, a, !1, !1) || (typeof a > "u" && us(t, e, null, !1, !1))) &&
        (r !== "" && (r += "," + (t.condenseFlow ? "" : " ")), (r += t.dump));
  (t.tag = i), (t.dump = "[" + r + "]");
}
function i_(t, e, n, r) {
  var i = "",
    s = t.tag,
    o,
    a,
    l;
  for (o = 0, a = n.length; o < a; o += 1)
    (l = n[o]),
      t.replacer && (l = t.replacer.call(n, String(o), l)),
      (us(t, e + 1, l, !0, !0, !1, !0) || (typeof l > "u" && us(t, e + 1, null, !0, !0, !1, !0))) &&
        ((!r || i !== "") && (i += rv(t, e)), t.dump && Nu === t.dump.charCodeAt(0) ? (i += "-") : (i += "- "), (i += t.dump));
  (t.tag = s), (t.dump = i || "[]");
}
function Tee(t, e, n) {
  var r = "",
    i = t.tag,
    s = Object.keys(n),
    o,
    a,
    l,
    c,
    u;
  for (o = 0, a = s.length; o < a; o += 1)
    (u = ""),
      r !== "" && (u += ", "),
      t.condenseFlow && (u += '"'),
      (l = s[o]),
      (c = n[l]),
      t.replacer && (c = t.replacer.call(n, l, c)),
      us(t, e, l, !1, !1) &&
        (t.dump.length > 1024 && (u += "? "),
        (u += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " ")),
        us(t, e, c, !1, !1) && ((u += t.dump), (r += u)));
  (t.tag = i), (t.dump = "{" + r + "}");
}
function Pee(t, e, n, r) {
  var i = "",
    s = t.tag,
    o = Object.keys(n),
    a,
    l,
    c,
    u,
    h,
    f;
  if (t.sortKeys === !0) o.sort();
  else if (typeof t.sortKeys == "function") o.sort(t.sortKeys);
  else if (t.sortKeys) throw new Mn("sortKeys must be a boolean or a function");
  for (a = 0, l = o.length; a < l; a += 1)
    (f = ""),
      (!r || i !== "") && (f += rv(t, e)),
      (c = o[a]),
      (u = n[c]),
      t.replacer && (u = t.replacer.call(n, c, u)),
      us(t, e + 1, c, !0, !0, !0) &&
        ((h = (t.tag !== null && t.tag !== "?") || (t.dump && t.dump.length > 1024)),
        h && (t.dump && Nu === t.dump.charCodeAt(0) ? (f += "?") : (f += "? ")),
        (f += t.dump),
        h && (f += rv(t, e)),
        us(t, e + 1, u, !0, h) && (t.dump && Nu === t.dump.charCodeAt(0) ? (f += ":") : (f += ": "), (f += t.dump), (i += f)));
  (t.tag = s), (t.dump = i || "{}");
}
function s_(t, e, n) {
  var r, i, s, o, a, l;
  for (i = n ? t.explicitTypes : t.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (
      ((a = i[s]),
      (a.instanceOf || a.predicate) &&
        (!a.instanceOf || (typeof e == "object" && e instanceof a.instanceOf)) &&
        (!a.predicate || a.predicate(e)))
    ) {
      if ((n ? (a.multi && a.representName ? (t.tag = a.representName(e)) : (t.tag = a.tag)) : (t.tag = "?"), a.represent)) {
        if (((l = t.styleMap[a.tag] || a.defaultStyle), h7.call(a.represent) === "[object Function]")) r = a.represent(e, l);
        else if (f7.call(a.represent, l)) r = a.represent[l](e, l);
        else throw new Mn("!<" + a.tag + '> tag resolver accepts not "' + l + '" style');
        t.dump = r;
      }
      return !0;
    }
  return !1;
}
function us(t, e, n, r, i, s, o) {
  (t.tag = null), (t.dump = n), s_(t, n, !1) || s_(t, n, !0);
  var a = h7.call(t.dump),
    l = r,
    c;
  r && (r = t.flowLevel < 0 || t.flowLevel > e);
  var u = a === "[object Object]" || a === "[object Array]",
    h,
    f;
  if (
    (u && ((h = t.duplicates.indexOf(n)), (f = h !== -1)),
    ((t.tag !== null && t.tag !== "?") || f || (t.indent !== 2 && e > 0)) && (i = !1),
    f && t.usedDuplicates[h])
  )
    t.dump = "*ref_" + h;
  else {
    if ((u && f && !t.usedDuplicates[h] && (t.usedDuplicates[h] = !0), a === "[object Object]"))
      r && Object.keys(t.dump).length !== 0
        ? (Pee(t, e, t.dump, i), f && (t.dump = "&ref_" + h + t.dump))
        : (Tee(t, e, t.dump), f && (t.dump = "&ref_" + h + " " + t.dump));
    else if (a === "[object Array]")
      r && t.dump.length !== 0
        ? (t.noArrayIndent && !o && e > 0 ? i_(t, e - 1, t.dump, i) : i_(t, e, t.dump, i), f && (t.dump = "&ref_" + h + t.dump))
        : (Eee(t, e, t.dump), f && (t.dump = "&ref_" + h + " " + t.dump));
    else if (a === "[object String]") t.tag !== "?" && kee(t, t.dump, e, s, l);
    else {
      if (a === "[object Undefined]") return !1;
      if (t.skipInvalid) return !1;
      throw new Mn("unacceptable kind of an object to dump " + a);
    }
    t.tag !== null &&
      t.tag !== "?" &&
      ((c = encodeURI(t.tag[0] === "!" ? t.tag.slice(1) : t.tag).replace(/!/g, "%21")),
      t.tag[0] === "!" ? (c = "!" + c) : c.slice(0, 18) === "tag:yaml.org,2002:" ? (c = "!!" + c.slice(18)) : (c = "!<" + c + ">"),
      (t.dump = c + " " + t.dump));
  }
  return !0;
}
function Aee(t, e) {
  var n = [],
    r = [],
    i,
    s;
  for (sv(t, n, r), i = 0, s = r.length; i < s; i += 1) e.duplicates.push(n[r[i]]);
  e.usedDuplicates = new Array(s);
}
function sv(t, e, n) {
  var r, i, s;
  if (t !== null && typeof t == "object")
    if (((i = e.indexOf(t)), i !== -1)) n.indexOf(i) === -1 && n.push(i);
    else if ((e.push(t), Array.isArray(t))) for (i = 0, s = t.length; i < s; i += 1) sv(t[i], e, n);
    else for (r = Object.keys(t), i = 0, s = r.length; i < s; i += 1) sv(t[r[i]], e, n);
}
function $ee(t, e) {
  e = e || {};
  var n = new xee(e);
  n.noRefs || Aee(t, n);
  var r = t;
  return (
    n.replacer && (r = n.replacer.call({ "": r }, "", r)),
    us(n, 0, r, !0, !0)
      ? n.dump +
        `
`
      : ""
  );
}
var Ree = $ee,
  Iee = { dump: Ree };
function aw(t, e) {
  return function () {
    throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
var Nee = bn,
  Lee = D9,
  Mee = B9,
  Dee = U9,
  Qee = X9,
  Fee = rw,
  Vee = u7.load,
  Bee = u7.loadAll,
  jee = Iee.dump,
  Zee = Mn,
  zee = {
    binary: J9,
    float: W9,
    map: V9,
    null: j9,
    pairs: e7,
    set: t7,
    timestamp: Y9,
    bool: Z9,
    int: z9,
    merge: G9,
    omap: K9,
    seq: F9,
    str: Q9,
  },
  Wee = aw("safeLoad", "load"),
  Uee = aw("safeLoadAll", "loadAll"),
  Xee = aw("safeDump", "dump"),
  o_ = {
    Type: Nee,
    Schema: Lee,
    FAILSAFE_SCHEMA: Mee,
    JSON_SCHEMA: Dee,
    CORE_SCHEMA: Qee,
    DEFAULT_SCHEMA: Fee,
    load: Vee,
    loadAll: Bee,
    dump: jee,
    YAMLException: Zee,
    types: zee,
    safeLoad: Wee,
    safeLoadAll: Uee,
    safeDump: Xee,
  };
const Hee = ({ yaml: t, onChange: e }) => {
    const [n, r, i, s] = nt(sn, si, ft, Du),
      o = lt(),
      a = tt(Du),
      l = tt(uw),
      c = C.useMemo(() => (t ? Object.entries(o_.load(t)).map(([v, g]) => ({ key: v, value: g })) : []), [t]),
      { register: u, control: h, handleSubmit: f } = vm({ defaultValues: { yamlConfig: c } }),
      { fields: d, append: p, remove: m } = uD({ control: h, name: "yamlConfig" }),
      O = C.useCallback(
        ({ yamlConfig: v }) => {
          if (v.length === 0) {
            l(), a(!1);
            return;
          }
          const g = v.reduce((x, { key: y, value: S }) => (y && S && (x[y] = S), x), {});
          e(o_.dump(g).trim()), a(!1);
        },
        [e, a, l]
      );
    return C.createElement(
      C.Fragment,
      null,
      C.createElement(
        _y,
        {
          open: s,
          onOpenChange: (v) => {
            a(v);
          },
        },
        C.createElement(
          Ey,
          { container: r == null ? void 0 : r.current },
          C.createElement(Ty, { className: F.dialogOverlay }),
          C.createElement(
            Py,
            { className: F.largeDialogContent, "data-editor-type": "frontmatter" },
            C.createElement(nG, { className: F.dialogTitle }, o("frontmatterEditor.title", "Edit document frontmatter")),
            C.createElement(
              "form",
              {
                onSubmit: (v) => {
                  f(O)(v), v.stopPropagation();
                },
                onReset: (v) => {
                  v.stopPropagation(), a(!1);
                },
              },
              C.createElement(
                "table",
                { className: F.propertyEditorTable },
                C.createElement("colgroup", null, C.createElement("col", null), C.createElement("col", null), C.createElement("col", null)),
                C.createElement(
                  "thead",
                  null,
                  C.createElement(
                    "tr",
                    null,
                    C.createElement("th", null, o("frontmatterEditor.key", "Key")),
                    C.createElement("th", null, o("frontmatterEditor.value", "Value")),
                    C.createElement("th", null)
                  )
                ),
                C.createElement(
                  "tbody",
                  null,
                  d.map((v, g) =>
                    C.createElement(
                      "tr",
                      { key: v.id },
                      C.createElement(
                        "td",
                        null,
                        C.createElement(a_, { ...u(`yamlConfig.${g}.key`, { required: !0 }), autofocusIfEmpty: !0, readOnly: n })
                      ),
                      C.createElement("td", null, C.createElement(a_, { ...u(`yamlConfig.${g}.value`, { required: !0 }), readOnly: n })),
                      C.createElement(
                        "td",
                        null,
                        C.createElement(
                          "button",
                          {
                            type: "button",
                            onClick: () => {
                              m(g);
                            },
                            className: F.iconButton,
                            disabled: n,
                          },
                          i("delete_big")
                        )
                      )
                    )
                  )
                ),
                C.createElement(
                  "tfoot",
                  null,
                  C.createElement(
                    "tr",
                    null,
                    C.createElement(
                      "td",
                      null,
                      C.createElement(
                        "button",
                        {
                          disabled: n,
                          className: Ze(F.primaryButton, F.smallButton),
                          type: "button",
                          onClick: () => {
                            p({ key: "", value: "" });
                          },
                        },
                        o("frontmatterEditor.addEntry", "Add entry")
                      )
                    )
                  )
                )
              ),
              C.createElement(
                "div",
                { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
                C.createElement("button", { type: "submit", className: F.primaryButton }, o("dialogControls.save", "Save")),
                C.createElement("button", { type: "reset", className: F.secondaryButton }, o("dialogControls.cancel", "Cancel"))
              )
            ),
            C.createElement(
              Ay,
              { asChild: !0 },
              C.createElement("button", { className: F.dialogCloseButton, "aria-label": o("dialogControls.cancel", "Cancel") }, i("close"))
            )
          )
        )
      )
    );
  },
  a_ = C.forwardRef(({ className: t, autofocusIfEmpty: e, ...n }, r) =>
    C.createElement("input", { className: Ze(F.propertyEditorInput, t), ...n, ref: r })
  );
var qee = Object.defineProperty,
  Yee = (t, e, n) => (e in t ? qee(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  Gee = (t, e, n) => (Yee(t, typeof e != "symbol" ? e + "" : e, n), n);
class Zh extends Mi {
  constructor(e, n) {
    super(n), Gee(this, "__yaml"), (this.__yaml = e);
  }
  static getType() {
    return "frontmatter";
  }
  static clone(e) {
    return new Zh(e.__yaml, e.__key);
  }
  static importJSON(e) {
    const { yaml: n } = e;
    return lw(n);
  }
  exportJSON() {
    return { yaml: this.getYaml(), type: "frontmatter", version: 1 };
  }
  createDOM(e) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getYaml() {
    return this.getLatest().__yaml;
  }
  setYaml(e) {
    e !== this.__yaml && (this.getWritable().__yaml = e);
  }
  decorate(e) {
    return C.createElement(Hee, {
      yaml: this.getYaml(),
      onChange: (n) => {
        e.update(() => {
          this.setYaml(n);
        });
      },
    });
  }
}
function lw(t) {
  return new Zh(t);
}
function fg(t) {
  return t instanceof Zh;
}
const Jee = {
    testLexicalNode: fg,
    visitLexicalNode: ({ actions: t, lexicalNode: e }) => {
      t.addAndStepInto("yaml", { value: e.getYaml() });
    },
  },
  Kee = {
    testNode: "yaml",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(lw(t.value));
    },
  },
  Du = Se(!1),
  cw = ni((t) => {
    t.sub(t.pipe(cw, bt(sr)), ([, e]) => {
      e == null ||
        e.update(() => {
          const n = Be().getFirstChild();
          if (!fg(n)) {
            const r = lw('"": ""');
            n ? n.insertBefore(r) : Be().append(r);
          }
        }),
        t.pub(Du, !0);
    });
  }),
  uw = ni((t) => {
    t.sub(t.pipe(uw, bt(sr)), ([, e]) => {
      e == null ||
        e.update(() => {
          const n = Be().getFirstChild();
          fg(n) && n.remove();
        }),
        t.pub(Du, !1);
    });
  }),
  hw = Se(!1, (t) => {
    t.pub($h, (e) =>
      e.registerUpdateListener(({ editorState: n }) => {
        n.read(() => {
          t.pub(hw, fg(Be().getFirstChild()));
        });
      })
    );
  }),
  ete = en({
    init: (t) => {
      t.pubIn({ [eo]: SJ("yaml"), [Ks]: bJ(), [vr]: Zh, [rr]: Kee, [xr]: Jee, [fa]: EJ("yaml") });
    },
  }),
  tte = {
    testNode: "blockquote",
    visitNode({ actions: t }) {
      t.addAndStepInto(Sh());
    },
  },
  nte = {
    testLexicalNode: yO,
    visitLexicalNode: ({ lexicalNode: t, mdastParent: e, actions: n }) => {
      const r = { type: "paragraph", children: [] };
      n.appendToParent(e, { type: "blockquote", children: [r] }), n.visitChildren(t, r);
    },
  },
  rte = en({
    init(t) {
      t.pubIn({ [ql]: "quote", [rr]: tte, [vr]: Vm, [xr]: nte });
    },
  }),
  ite = en({
    init: (t, e = 1 / 0) => {
      t.pub($h, (n) => {
        let r = null;
        return n.registerNodeTransform(zl, (i) => {
          const s = ce();
          if (!ee(s) || !s.isCollapsed()) return;
          const o = n.getEditorState(),
            a = o.read(() => i.getTextContentSize()),
            l = i.getTextContentSize();
          if (a !== l) {
            const c = l - e,
              u = s.anchor;
            c > 0 && (a === e && r !== o ? ((r = o), eF(n, o)) : qQ(n, u, c));
          }
        });
      });
    },
  });
function ste() {
  return {
    enter: { mdxFlowExpression: ate, mdxTextExpression: lte },
    exit: { mdxFlowExpression: l_, mdxFlowExpressionChunk: c_, mdxTextExpression: l_, mdxTextExpressionChunk: c_ },
  };
}
function ote() {
  return {
    handlers: { mdxFlowExpression: u_, mdxTextExpression: u_ },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "{" },
    ],
  };
}
function ate(t) {
  this.enter({ type: "mdxFlowExpression", value: "" }, t), this.buffer();
}
function lte(t) {
  this.enter({ type: "mdxTextExpression", value: "" }, t), this.buffer();
}
function l_(t) {
  const e = this.resume(),
    n = t.estree,
    r = this.stack[this.stack.length - 1];
  r.type === "mdxFlowExpression" || r.type, this.exit(t), (r.value = e), n && (r.data = { estree: n });
}
function c_(t) {
  this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function u_(t) {
  return "{" + (t.value || "") + "}";
}
function cte() {
  return { enter: { mdxjsEsm: hte }, exit: { mdxjsEsm: fte, mdxjsEsmData: dte } };
}
function ute() {
  return { handlers: { mdxjsEsm: pte } };
}
function hte(t) {
  this.enter({ type: "mdxjsEsm", value: "" }, t), this.buffer();
}
function fte(t) {
  const e = this.resume(),
    n = this.stack[this.stack.length - 1];
  n.type, this.exit(t);
  const r = t.estree;
  (n.value = e), r && (n.data = { estree: r });
}
function dte(t) {
  this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function pte(t) {
  return t.value || "";
}
function mte() {
  return [ste(), W3(), cte()];
}
function gte(t) {
  return { extensions: [ote(), U3(t), ute()] };
}
var Ote = [
    509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14,
    32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6,
    9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82,
    12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47,
    15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4,
    14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4,
    5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10,
    9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239,
  ],
  w7 = [
    0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19,
    35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
    2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
    2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13,
    52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3,
    2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42,
    3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2,
    0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15,
    0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18,
    29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290,
    16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2,
    3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845,
    30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2,
    1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6,
    2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6,
    4191,
  ],
  vte =
    "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･",
  S7 =
    "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
  R0 = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments",
  },
  I0 =
    "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",
  xte = { 5: I0, "5module": I0 + " export import", 6: I0 + " const class extends export import super" },
  bte = /^in(stanceof)?$/,
  yte = new RegExp("[" + S7 + "]"),
  wte = new RegExp("[" + S7 + vte + "]");
function ov(t, e) {
  for (var n = 65536, r = 0; r < e.length; r += 2) {
    if (((n += e[r]), n > t)) return !1;
    if (((n += e[r + 1]), n >= t)) return !0;
  }
  return !1;
}
function Ni(t, e) {
  return t < 65
    ? t === 36
    : t < 91
    ? !0
    : t < 97
    ? t === 95
    : t < 123
    ? !0
    : t <= 65535
    ? t >= 170 && yte.test(String.fromCharCode(t))
    : e === !1
    ? !1
    : ov(t, w7);
}
function qo(t, e) {
  return t < 48
    ? t === 36
    : t < 58
    ? !0
    : t < 65
    ? !1
    : t < 91
    ? !0
    : t < 97
    ? t === 95
    : t < 123
    ? !0
    : t <= 65535
    ? t >= 170 && wte.test(String.fromCharCode(t))
    : e === !1
    ? !1
    : ov(t, w7) || ov(t, Ote);
}
var Je = function (e, n) {
  n === void 0 && (n = {}),
    (this.label = e),
    (this.keyword = n.keyword),
    (this.beforeExpr = !!n.beforeExpr),
    (this.startsExpr = !!n.startsExpr),
    (this.isLoop = !!n.isLoop),
    (this.isAssign = !!n.isAssign),
    (this.prefix = !!n.prefix),
    (this.postfix = !!n.postfix),
    (this.binop = n.binop || null),
    (this.updateContext = null);
};
function wr(t, e) {
  return new Je(t, { beforeExpr: !0, binop: e });
}
var Sr = { beforeExpr: !0 },
  Un = { startsExpr: !0 },
  dg = {};
function qe(t, e) {
  return e === void 0 && (e = {}), (e.keyword = t), (dg[t] = new Je(t, e));
}
var A = {
    num: new Je("num", Un),
    regexp: new Je("regexp", Un),
    string: new Je("string", Un),
    name: new Je("name", Un),
    privateId: new Je("privateId", Un),
    eof: new Je("eof"),
    bracketL: new Je("[", { beforeExpr: !0, startsExpr: !0 }),
    bracketR: new Je("]"),
    braceL: new Je("{", { beforeExpr: !0, startsExpr: !0 }),
    braceR: new Je("}"),
    parenL: new Je("(", { beforeExpr: !0, startsExpr: !0 }),
    parenR: new Je(")"),
    comma: new Je(",", Sr),
    semi: new Je(";", Sr),
    colon: new Je(":", Sr),
    dot: new Je("."),
    question: new Je("?", Sr),
    questionDot: new Je("?."),
    arrow: new Je("=>", Sr),
    template: new Je("template"),
    invalidTemplate: new Je("invalidTemplate"),
    ellipsis: new Je("...", Sr),
    backQuote: new Je("`", Un),
    dollarBraceL: new Je("${", { beforeExpr: !0, startsExpr: !0 }),
    eq: new Je("=", { beforeExpr: !0, isAssign: !0 }),
    assign: new Je("_=", { beforeExpr: !0, isAssign: !0 }),
    incDec: new Je("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
    prefix: new Je("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    logicalOR: wr("||", 1),
    logicalAND: wr("&&", 2),
    bitwiseOR: wr("|", 3),
    bitwiseXOR: wr("^", 4),
    bitwiseAND: wr("&", 5),
    equality: wr("==/!=/===/!==", 6),
    relational: wr("</>/<=/>=", 7),
    bitShift: wr("<</>>/>>>", 8),
    plusMin: new Je("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
    modulo: wr("%", 10),
    star: wr("*", 10),
    slash: wr("/", 10),
    starstar: new Je("**", { beforeExpr: !0 }),
    coalesce: wr("??", 1),
    _break: qe("break"),
    _case: qe("case", Sr),
    _catch: qe("catch"),
    _continue: qe("continue"),
    _debugger: qe("debugger"),
    _default: qe("default", Sr),
    _do: qe("do", { isLoop: !0, beforeExpr: !0 }),
    _else: qe("else", Sr),
    _finally: qe("finally"),
    _for: qe("for", { isLoop: !0 }),
    _function: qe("function", Un),
    _if: qe("if"),
    _return: qe("return", Sr),
    _switch: qe("switch"),
    _throw: qe("throw", Sr),
    _try: qe("try"),
    _var: qe("var"),
    _const: qe("const"),
    _while: qe("while", { isLoop: !0 }),
    _with: qe("with"),
    _new: qe("new", { beforeExpr: !0, startsExpr: !0 }),
    _this: qe("this", Un),
    _super: qe("super", Un),
    _class: qe("class", Un),
    _extends: qe("extends", Sr),
    _export: qe("export"),
    _import: qe("import", Un),
    _null: qe("null", Un),
    _true: qe("true", Un),
    _false: qe("false", Un),
    _in: qe("in", { beforeExpr: !0, binop: 7 }),
    _instanceof: qe("instanceof", { beforeExpr: !0, binop: 7 }),
    _typeof: qe("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _void: qe("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _delete: qe("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  },
  br = /\r\n?|\n|\u2028|\u2029/,
  k7 = new RegExp(br.source, "g");
function ma(t) {
  return t === 10 || t === 13 || t === 8232 || t === 8233;
}
function C7(t, e, n) {
  n === void 0 && (n = t.length);
  for (var r = e; r < n; r++) {
    var i = t.charCodeAt(r);
    if (ma(i)) return r < n - 1 && i === 13 && t.charCodeAt(r + 1) === 10 ? r + 2 : r + 1;
  }
  return -1;
}
var fw = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
  Er = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
  _7 = Object.prototype,
  Ste = _7.hasOwnProperty,
  kte = _7.toString,
  zh =
    Object.hasOwn ||
    function (t, e) {
      return Ste.call(t, e);
    },
  h_ =
    Array.isArray ||
    function (t) {
      return kte.call(t) === "[object Array]";
    },
  f_ = Object.create(null);
function Qs(t) {
  return f_[t] || (f_[t] = new RegExp("^(?:" + t.replace(/ /g, "|") + ")$"));
}
function ro(t) {
  return t <= 65535 ? String.fromCharCode(t) : ((t -= 65536), String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
var Cte = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
  yl = function (e, n) {
    (this.line = e), (this.column = n);
  };
yl.prototype.offset = function (e) {
  return new yl(this.line, this.column + e);
};
var Wh = function (e, n, r) {
  (this.start = n), (this.end = r), e.sourceFile !== null && (this.source = e.sourceFile);
};
function dw(t, e) {
  for (var n = 1, r = 0; ; ) {
    var i = C7(t, r, e);
    if (i < 0) return new yl(n, e - r);
    ++n, (r = i);
  }
}
var Pp = {
    ecmaVersion: null,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowAwaitOutsideFunction: null,
    allowSuperOutsideMethod: null,
    allowHashBang: !1,
    checkPrivateFields: !0,
    locations: !1,
    onToken: null,
    onComment: null,
    ranges: !1,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: !1,
  },
  d_ = !1;
function _te(t) {
  var e = {};
  for (var n in Pp) e[n] = t && zh(t, n) ? t[n] : Pp[n];
  if (
    (e.ecmaVersion === "latest"
      ? (e.ecmaVersion = 1e8)
      : e.ecmaVersion == null
      ? (!d_ &&
          typeof console == "object" &&
          console.warn &&
          ((d_ = !0),
          console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)),
        (e.ecmaVersion = 11))
      : e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009),
    e.allowReserved == null && (e.allowReserved = e.ecmaVersion < 5),
    (!t || t.allowHashBang == null) && (e.allowHashBang = e.ecmaVersion >= 14),
    h_(e.onToken))
  ) {
    var r = e.onToken;
    e.onToken = function (i) {
      return r.push(i);
    };
  }
  return h_(e.onComment) && (e.onComment = Ete(e, e.onComment)), e;
}
function Ete(t, e) {
  return function (n, r, i, s, o, a) {
    var l = { type: n ? "Block" : "Line", value: r, start: i, end: s };
    t.locations && (l.loc = new Wh(this, o, a)), t.ranges && (l.range = [i, s]), e.push(l);
  };
}
var Qu = 1,
  tc = 2,
  pw = 4,
  E7 = 8,
  T7 = 16,
  P7 = 32,
  mw = 64,
  A7 = 128,
  Uh = 256,
  gw = Qu | tc | Uh;
function Ow(t, e) {
  return tc | (t ? pw : 0) | (e ? E7 : 0);
}
var Ap = 0,
  vw = 1,
  xs = 2,
  $7 = 3,
  R7 = 4,
  I7 = 5,
  Mt = function (e, n, r) {
    (this.options = e = _te(e)),
      (this.sourceFile = e.sourceFile),
      (this.keywords = Qs(xte[e.ecmaVersion >= 6 ? 6 : e.sourceType === "module" ? "5module" : 5]));
    var i = "";
    e.allowReserved !== !0 &&
      ((i = R0[e.ecmaVersion >= 6 ? 6 : e.ecmaVersion === 5 ? 5 : 3]), e.sourceType === "module" && (i += " await")),
      (this.reservedWords = Qs(i));
    var s = (i ? i + " " : "") + R0.strict;
    (this.reservedWordsStrict = Qs(s)),
      (this.reservedWordsStrictBind = Qs(s + " " + R0.strictBind)),
      (this.input = String(n)),
      (this.containsEsc = !1),
      r
        ? ((this.pos = r),
          (this.lineStart =
            this.input.lastIndexOf(
              `
`,
              r - 1
            ) + 1),
          (this.curLine = this.input.slice(0, this.lineStart).split(br).length))
        : ((this.pos = this.lineStart = 0), (this.curLine = 1)),
      (this.type = A.eof),
      (this.value = null),
      (this.start = this.end = this.pos),
      (this.startLoc = this.endLoc = this.curPosition()),
      (this.lastTokEndLoc = this.lastTokStartLoc = null),
      (this.lastTokStart = this.lastTokEnd = this.pos),
      (this.context = this.initialContext()),
      (this.exprAllowed = !0),
      (this.inModule = e.sourceType === "module"),
      (this.strict = this.inModule || this.strictDirective(this.pos)),
      (this.potentialArrowAt = -1),
      (this.potentialArrowInForAwait = !1),
      (this.yieldPos = this.awaitPos = this.awaitIdentPos = 0),
      (this.labels = []),
      (this.undefinedExports = Object.create(null)),
      this.pos === 0 && e.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2),
      (this.scopeStack = []),
      this.enterScope(Qu),
      (this.regexpState = null),
      (this.privateNameStack = []);
  },
  Qi = {
    inFunction: { configurable: !0 },
    inGenerator: { configurable: !0 },
    inAsync: { configurable: !0 },
    canAwait: { configurable: !0 },
    allowSuper: { configurable: !0 },
    allowDirectSuper: { configurable: !0 },
    treatFunctionsAsVar: { configurable: !0 },
    allowNewDotTarget: { configurable: !0 },
    inClassStaticBlock: { configurable: !0 },
  };
Mt.prototype.parse = function () {
  var e = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(e);
};
Qi.inFunction.get = function () {
  return (this.currentVarScope().flags & tc) > 0;
};
Qi.inGenerator.get = function () {
  return (this.currentVarScope().flags & E7) > 0 && !this.currentVarScope().inClassFieldInit;
};
Qi.inAsync.get = function () {
  return (this.currentVarScope().flags & pw) > 0 && !this.currentVarScope().inClassFieldInit;
};
Qi.canAwait.get = function () {
  for (var t = this.scopeStack.length - 1; t >= 0; t--) {
    var e = this.scopeStack[t];
    if (e.inClassFieldInit || e.flags & Uh) return !1;
    if (e.flags & tc) return (e.flags & pw) > 0;
  }
  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction;
};
Qi.allowSuper.get = function () {
  var t = this.currentThisScope(),
    e = t.flags,
    n = t.inClassFieldInit;
  return (e & mw) > 0 || n || this.options.allowSuperOutsideMethod;
};
Qi.allowDirectSuper.get = function () {
  return (this.currentThisScope().flags & A7) > 0;
};
Qi.treatFunctionsAsVar.get = function () {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
Qi.allowNewDotTarget.get = function () {
  var t = this.currentThisScope(),
    e = t.flags,
    n = t.inClassFieldInit;
  return (e & (tc | Uh)) > 0 || n;
};
Qi.inClassStaticBlock.get = function () {
  return (this.currentVarScope().flags & Uh) > 0;
};
Mt.extend = function () {
  for (var e = [], n = arguments.length; n--; ) e[n] = arguments[n];
  for (var r = this, i = 0; i < e.length; i++) r = e[i](r);
  return r;
};
Mt.parse = function (e, n) {
  return new this(n, e).parse();
};
Mt.parseExpressionAt = function (e, n, r) {
  var i = new this(r, e, n);
  return i.nextToken(), i.parseExpression();
};
Mt.tokenizer = function (e, n) {
  return new this(n, e);
};
Object.defineProperties(Mt.prototype, Qi);
var Wn = Mt.prototype,
  Tte = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
Wn.strictDirective = function (t) {
  if (this.options.ecmaVersion < 5) return !1;
  for (;;) {
    (Er.lastIndex = t), (t += Er.exec(this.input)[0].length);
    var e = Tte.exec(this.input.slice(t));
    if (!e) return !1;
    if ((e[1] || e[2]) === "use strict") {
      Er.lastIndex = t + e[0].length;
      var n = Er.exec(this.input),
        r = n.index + n[0].length,
        i = this.input.charAt(r);
      return (
        i === ";" || i === "}" || (br.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(i) || (i === "!" && this.input.charAt(r + 1) === "=")))
      );
    }
    (t += e[0].length), (Er.lastIndex = t), (t += Er.exec(this.input)[0].length), this.input[t] === ";" && t++;
  }
};
Wn.eat = function (t) {
  return this.type === t ? (this.next(), !0) : !1;
};
Wn.isContextual = function (t) {
  return this.type === A.name && this.value === t && !this.containsEsc;
};
Wn.eatContextual = function (t) {
  return this.isContextual(t) ? (this.next(), !0) : !1;
};
Wn.expectContextual = function (t) {
  this.eatContextual(t) || this.unexpected();
};
Wn.canInsertSemicolon = function () {
  return this.type === A.eof || this.type === A.braceR || br.test(this.input.slice(this.lastTokEnd, this.start));
};
Wn.insertSemicolon = function () {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
Wn.semicolon = function () {
  !this.eat(A.semi) && !this.insertSemicolon() && this.unexpected();
};
Wn.afterTrailingComma = function (t, e) {
  if (this.type === t)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0;
};
Wn.expect = function (t) {
  this.eat(t) || this.unexpected();
};
Wn.unexpected = function (t) {
  this.raise(t ?? this.start, "Unexpected token");
};
var pg = function () {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
Wn.checkPatternErrors = function (t, e) {
  if (t) {
    t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element");
    var n = e ? t.parenthesizedAssign : t.parenthesizedBind;
    n > -1 && this.raiseRecoverable(n, e ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
Wn.checkExpressionErrors = function (t, e) {
  if (!t) return !1;
  var n = t.shorthandAssign,
    r = t.doubleProto;
  if (!e) return n >= 0 || r >= 0;
  n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"),
    r >= 0 && this.raiseRecoverable(r, "Redefinition of __proto__ property");
};
Wn.checkYieldAwaitInDefaultParams = function () {
  this.yieldPos &&
    (!this.awaitPos || this.yieldPos < this.awaitPos) &&
    this.raise(this.yieldPos, "Yield expression cannot be a default value"),
    this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
Wn.isSimpleAssignTarget = function (t) {
  return t.type === "ParenthesizedExpression"
    ? this.isSimpleAssignTarget(t.expression)
    : t.type === "Identifier" || t.type === "MemberExpression";
};
var Ee = Mt.prototype;
Ee.parseTopLevel = function (t) {
  var e = Object.create(null);
  for (t.body || (t.body = []); this.type !== A.eof; ) {
    var n = this.parseStatement(null, !0, e);
    t.body.push(n);
  }
  if (this.inModule)
    for (var r = 0, i = Object.keys(this.undefinedExports); r < i.length; r += 1) {
      var s = i[r];
      this.raiseRecoverable(this.undefinedExports[s].start, "Export '" + s + "' is not defined");
    }
  return this.adaptDirectivePrologue(t.body), this.next(), (t.sourceType = this.options.sourceType), this.finishNode(t, "Program");
};
var xw = { kind: "loop" },
  Pte = { kind: "switch" };
Ee.isLet = function (t) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
  Er.lastIndex = this.pos;
  var e = Er.exec(this.input),
    n = this.pos + e[0].length,
    r = this.input.charCodeAt(n);
  if (r === 91 || r === 92) return !0;
  if (t) return !1;
  if (r === 123 || (r > 55295 && r < 56320)) return !0;
  if (Ni(r, !0)) {
    for (var i = n + 1; qo((r = this.input.charCodeAt(i)), !0); ) ++i;
    if (r === 92 || (r > 55295 && r < 56320)) return !0;
    var s = this.input.slice(n, i);
    if (!bte.test(s)) return !0;
  }
  return !1;
};
Ee.isAsyncFunction = function () {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
  Er.lastIndex = this.pos;
  var t = Er.exec(this.input),
    e = this.pos + t[0].length,
    n;
  return (
    !br.test(this.input.slice(this.pos, e)) &&
    this.input.slice(e, e + 8) === "function" &&
    (e + 8 === this.input.length || !(qo((n = this.input.charCodeAt(e + 8))) || (n > 55295 && n < 56320)))
  );
};
Ee.parseStatement = function (t, e, n) {
  var r = this.type,
    i = this.startNode(),
    s;
  switch ((this.isLet(t) && ((r = A._var), (s = "let")), r)) {
    case A._break:
    case A._continue:
      return this.parseBreakContinueStatement(i, r.keyword);
    case A._debugger:
      return this.parseDebuggerStatement(i);
    case A._do:
      return this.parseDoStatement(i);
    case A._for:
      return this.parseForStatement(i);
    case A._function:
      return (
        t && (this.strict || (t !== "if" && t !== "label")) && this.options.ecmaVersion >= 6 && this.unexpected(),
        this.parseFunctionStatement(i, !1, !t)
      );
    case A._class:
      return t && this.unexpected(), this.parseClass(i, !0);
    case A._if:
      return this.parseIfStatement(i);
    case A._return:
      return this.parseReturnStatement(i);
    case A._switch:
      return this.parseSwitchStatement(i);
    case A._throw:
      return this.parseThrowStatement(i);
    case A._try:
      return this.parseTryStatement(i);
    case A._const:
    case A._var:
      return (s = s || this.value), t && s !== "var" && this.unexpected(), this.parseVarStatement(i, s);
    case A._while:
      return this.parseWhileStatement(i);
    case A._with:
      return this.parseWithStatement(i);
    case A.braceL:
      return this.parseBlock(!0, i);
    case A.semi:
      return this.parseEmptyStatement(i);
    case A._export:
    case A._import:
      if (this.options.ecmaVersion > 10 && r === A._import) {
        Er.lastIndex = this.pos;
        var o = Er.exec(this.input),
          a = this.pos + o[0].length,
          l = this.input.charCodeAt(a);
        if (l === 40 || l === 46) return this.parseExpressionStatement(i, this.parseExpression());
      }
      return (
        this.options.allowImportExportEverywhere ||
          (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"),
          this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")),
        r === A._import ? this.parseImport(i) : this.parseExport(i, n)
      );
    default:
      if (this.isAsyncFunction()) return t && this.unexpected(), this.next(), this.parseFunctionStatement(i, !0, !t);
      var c = this.value,
        u = this.parseExpression();
      return r === A.name && u.type === "Identifier" && this.eat(A.colon)
        ? this.parseLabeledStatement(i, c, u, t)
        : this.parseExpressionStatement(i, u);
  }
};
Ee.parseBreakContinueStatement = function (t, e) {
  var n = e === "break";
  this.next(),
    this.eat(A.semi) || this.insertSemicolon()
      ? (t.label = null)
      : this.type !== A.name
      ? this.unexpected()
      : ((t.label = this.parseIdent()), this.semicolon());
  for (var r = 0; r < this.labels.length; ++r) {
    var i = this.labels[r];
    if ((t.label == null || i.name === t.label.name) && ((i.kind != null && (n || i.kind === "loop")) || (t.label && n))) break;
  }
  return (
    r === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, n ? "BreakStatement" : "ContinueStatement")
  );
};
Ee.parseDebuggerStatement = function (t) {
  return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
};
Ee.parseDoStatement = function (t) {
  return (
    this.next(),
    this.labels.push(xw),
    (t.body = this.parseStatement("do")),
    this.labels.pop(),
    this.expect(A._while),
    (t.test = this.parseParenExpression()),
    this.options.ecmaVersion >= 6 ? this.eat(A.semi) : this.semicolon(),
    this.finishNode(t, "DoWhileStatement")
  );
};
Ee.parseForStatement = function (t) {
  this.next();
  var e = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  if ((this.labels.push(xw), this.enterScope(0), this.expect(A.parenL), this.type === A.semi))
    return e > -1 && this.unexpected(e), this.parseFor(t, null);
  var n = this.isLet();
  if (this.type === A._var || this.type === A._const || n) {
    var r = this.startNode(),
      i = n ? "let" : this.value;
    return (
      this.next(),
      this.parseVar(r, !0, i),
      this.finishNode(r, "VariableDeclaration"),
      (this.type === A._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && r.declarations.length === 1
        ? (this.options.ecmaVersion >= 9 && (this.type === A._in ? e > -1 && this.unexpected(e) : (t.await = e > -1)),
          this.parseForIn(t, r))
        : (e > -1 && this.unexpected(e), this.parseFor(t, r))
    );
  }
  var s = this.isContextual("let"),
    o = !1,
    a = new pg(),
    l = this.parseExpression(e > -1 ? "await" : !0, a);
  return this.type === A._in || (o = this.options.ecmaVersion >= 6 && this.isContextual("of"))
    ? (this.options.ecmaVersion >= 9 && (this.type === A._in ? e > -1 && this.unexpected(e) : (t.await = e > -1)),
      s && o && this.raise(l.start, "The left-hand side of a for-of loop may not start with 'let'."),
      this.toAssignable(l, !1, a),
      this.checkLValPattern(l),
      this.parseForIn(t, l))
    : (this.checkExpressionErrors(a, !0), e > -1 && this.unexpected(e), this.parseFor(t, l));
};
Ee.parseFunctionStatement = function (t, e, n) {
  return this.next(), this.parseFunction(t, au | (n ? 0 : av), !1, e);
};
Ee.parseIfStatement = function (t) {
  return (
    this.next(),
    (t.test = this.parseParenExpression()),
    (t.consequent = this.parseStatement("if")),
    (t.alternate = this.eat(A._else) ? this.parseStatement("if") : null),
    this.finishNode(t, "IfStatement")
  );
};
Ee.parseReturnStatement = function (t) {
  return (
    !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"),
    this.next(),
    this.eat(A.semi) || this.insertSemicolon() ? (t.argument = null) : ((t.argument = this.parseExpression()), this.semicolon()),
    this.finishNode(t, "ReturnStatement")
  );
};
Ee.parseSwitchStatement = function (t) {
  this.next(),
    (t.discriminant = this.parseParenExpression()),
    (t.cases = []),
    this.expect(A.braceL),
    this.labels.push(Pte),
    this.enterScope(0);
  for (var e, n = !1; this.type !== A.braceR; )
    if (this.type === A._case || this.type === A._default) {
      var r = this.type === A._case;
      e && this.finishNode(e, "SwitchCase"),
        t.cases.push((e = this.startNode())),
        (e.consequent = []),
        this.next(),
        r
          ? (e.test = this.parseExpression())
          : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), (n = !0), (e.test = null)),
        this.expect(A.colon);
    } else e || this.unexpected(), e.consequent.push(this.parseStatement(null));
  return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement");
};
Ee.parseThrowStatement = function (t) {
  return (
    this.next(),
    br.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"),
    (t.argument = this.parseExpression()),
    this.semicolon(),
    this.finishNode(t, "ThrowStatement")
  );
};
var Ate = [];
Ee.parseCatchClauseParam = function () {
  var t = this.parseBindingAtom(),
    e = t.type === "Identifier";
  return this.enterScope(e ? P7 : 0), this.checkLValPattern(t, e ? R7 : xs), this.expect(A.parenR), t;
};
Ee.parseTryStatement = function (t) {
  if ((this.next(), (t.block = this.parseBlock()), (t.handler = null), this.type === A._catch)) {
    var e = this.startNode();
    this.next(),
      this.eat(A.parenL)
        ? (e.param = this.parseCatchClauseParam())
        : (this.options.ecmaVersion < 10 && this.unexpected(), (e.param = null), this.enterScope(0)),
      (e.body = this.parseBlock(!1)),
      this.exitScope(),
      (t.handler = this.finishNode(e, "CatchClause"));
  }
  return (
    (t.finalizer = this.eat(A._finally) ? this.parseBlock() : null),
    !t.handler && !t.finalizer && this.raise(t.start, "Missing catch or finally clause"),
    this.finishNode(t, "TryStatement")
  );
};
Ee.parseVarStatement = function (t, e, n) {
  return this.next(), this.parseVar(t, !1, e, n), this.semicolon(), this.finishNode(t, "VariableDeclaration");
};
Ee.parseWhileStatement = function (t) {
  return (
    this.next(),
    (t.test = this.parseParenExpression()),
    this.labels.push(xw),
    (t.body = this.parseStatement("while")),
    this.labels.pop(),
    this.finishNode(t, "WhileStatement")
  );
};
Ee.parseWithStatement = function (t) {
  return (
    this.strict && this.raise(this.start, "'with' in strict mode"),
    this.next(),
    (t.object = this.parseParenExpression()),
    (t.body = this.parseStatement("with")),
    this.finishNode(t, "WithStatement")
  );
};
Ee.parseEmptyStatement = function (t) {
  return this.next(), this.finishNode(t, "EmptyStatement");
};
Ee.parseLabeledStatement = function (t, e, n, r) {
  for (var i = 0, s = this.labels; i < s.length; i += 1) {
    var o = s[i];
    o.name === e && this.raise(n.start, "Label '" + e + "' is already declared");
  }
  for (var a = this.type.isLoop ? "loop" : this.type === A._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
    var c = this.labels[l];
    if (c.statementStart === t.start) (c.statementStart = this.start), (c.kind = a);
    else break;
  }
  return (
    this.labels.push({ name: e, kind: a, statementStart: this.start }),
    (t.body = this.parseStatement(r ? (r.indexOf("label") === -1 ? r + "label" : r) : "label")),
    this.labels.pop(),
    (t.label = n),
    this.finishNode(t, "LabeledStatement")
  );
};
Ee.parseExpressionStatement = function (t, e) {
  return (t.expression = e), this.semicolon(), this.finishNode(t, "ExpressionStatement");
};
Ee.parseBlock = function (t, e, n) {
  for (
    t === void 0 && (t = !0), e === void 0 && (e = this.startNode()), e.body = [], this.expect(A.braceL), t && this.enterScope(0);
    this.type !== A.braceR;

  ) {
    var r = this.parseStatement(null);
    e.body.push(r);
  }
  return n && (this.strict = !1), this.next(), t && this.exitScope(), this.finishNode(e, "BlockStatement");
};
Ee.parseFor = function (t, e) {
  return (
    (t.init = e),
    this.expect(A.semi),
    (t.test = this.type === A.semi ? null : this.parseExpression()),
    this.expect(A.semi),
    (t.update = this.type === A.parenR ? null : this.parseExpression()),
    this.expect(A.parenR),
    (t.body = this.parseStatement("for")),
    this.exitScope(),
    this.labels.pop(),
    this.finishNode(t, "ForStatement")
  );
};
Ee.parseForIn = function (t, e) {
  var n = this.type === A._in;
  return (
    this.next(),
    e.type === "VariableDeclaration" &&
      e.declarations[0].init != null &&
      (!n || this.options.ecmaVersion < 8 || this.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") &&
      this.raise(e.start, (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"),
    (t.left = e),
    (t.right = n ? this.parseExpression() : this.parseMaybeAssign()),
    this.expect(A.parenR),
    (t.body = this.parseStatement("for")),
    this.exitScope(),
    this.labels.pop(),
    this.finishNode(t, n ? "ForInStatement" : "ForOfStatement")
  );
};
Ee.parseVar = function (t, e, n, r) {
  for (t.declarations = [], t.kind = n; ; ) {
    var i = this.startNode();
    if (
      (this.parseVarId(i, n),
      this.eat(A.eq)
        ? (i.init = this.parseMaybeAssign(e))
        : !r && n === "const" && !(this.type === A._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))
        ? this.unexpected()
        : !r && i.id.type !== "Identifier" && !(e && (this.type === A._in || this.isContextual("of")))
        ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value")
        : (i.init = null),
      t.declarations.push(this.finishNode(i, "VariableDeclarator")),
      !this.eat(A.comma))
    )
      break;
  }
  return t;
};
Ee.parseVarId = function (t, e) {
  (t.id = this.parseBindingAtom()), this.checkLValPattern(t.id, e === "var" ? vw : xs, !1);
};
var au = 1,
  av = 2,
  N7 = 4;
Ee.parseFunction = function (t, e, n, r, i) {
  this.initFunction(t),
    (this.options.ecmaVersion >= 9 || (this.options.ecmaVersion >= 6 && !r)) &&
      (this.type === A.star && e & av && this.unexpected(), (t.generator = this.eat(A.star))),
    this.options.ecmaVersion >= 8 && (t.async = !!r),
    e & au &&
      ((t.id = e & N7 && this.type !== A.name ? null : this.parseIdent()),
      t.id && !(e & av) && this.checkLValSimple(t.id, this.strict || t.generator || t.async ? (this.treatFunctionsAsVar ? vw : xs) : $7));
  var s = this.yieldPos,
    o = this.awaitPos,
    a = this.awaitIdentPos;
  return (
    (this.yieldPos = 0),
    (this.awaitPos = 0),
    (this.awaitIdentPos = 0),
    this.enterScope(Ow(t.async, t.generator)),
    e & au || (t.id = this.type === A.name ? this.parseIdent() : null),
    this.parseFunctionParams(t),
    this.parseFunctionBody(t, n, !1, i),
    (this.yieldPos = s),
    (this.awaitPos = o),
    (this.awaitIdentPos = a),
    this.finishNode(t, e & au ? "FunctionDeclaration" : "FunctionExpression")
  );
};
Ee.parseFunctionParams = function (t) {
  this.expect(A.parenL),
    (t.params = this.parseBindingList(A.parenR, !1, this.options.ecmaVersion >= 8)),
    this.checkYieldAwaitInDefaultParams();
};
Ee.parseClass = function (t, e) {
  this.next();
  var n = this.strict;
  (this.strict = !0), this.parseClassId(t, e), this.parseClassSuper(t);
  var r = this.enterClassBody(),
    i = this.startNode(),
    s = !1;
  for (i.body = [], this.expect(A.braceL); this.type !== A.braceR; ) {
    var o = this.parseClassElement(t.superClass !== null);
    o &&
      (i.body.push(o),
      o.type === "MethodDefinition" && o.kind === "constructor"
        ? (s && this.raiseRecoverable(o.start, "Duplicate constructor in the same class"), (s = !0))
        : o.key &&
          o.key.type === "PrivateIdentifier" &&
          $te(r, o) &&
          this.raiseRecoverable(o.key.start, "Identifier '#" + o.key.name + "' has already been declared"));
  }
  return (
    (this.strict = n),
    this.next(),
    (t.body = this.finishNode(i, "ClassBody")),
    this.exitClassBody(),
    this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression")
  );
};
Ee.parseClassElement = function (t) {
  if (this.eat(A.semi)) return null;
  var e = this.options.ecmaVersion,
    n = this.startNode(),
    r = "",
    i = !1,
    s = !1,
    o = "method",
    a = !1;
  if (this.eatContextual("static")) {
    if (e >= 13 && this.eat(A.braceL)) return this.parseClassStaticBlock(n), n;
    this.isClassElementNameStart() || this.type === A.star ? (a = !0) : (r = "static");
  }
  if (
    ((n.static = a),
    !r &&
      e >= 8 &&
      this.eatContextual("async") &&
      ((this.isClassElementNameStart() || this.type === A.star) && !this.canInsertSemicolon() ? (s = !0) : (r = "async")),
    !r && (e >= 9 || !s) && this.eat(A.star) && (i = !0),
    !r && !s && !i)
  ) {
    var l = this.value;
    (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? (o = l) : (r = l));
  }
  if (
    (r
      ? ((n.computed = !1),
        (n.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc)),
        (n.key.name = r),
        this.finishNode(n.key, "Identifier"))
      : this.parseClassElementName(n),
    e < 13 || this.type === A.parenL || o !== "method" || i || s)
  ) {
    var c = !n.static && $p(n, "constructor"),
      u = c && t;
    c && o !== "method" && this.raise(n.key.start, "Constructor can't have get/set modifier"),
      (n.kind = c ? "constructor" : o),
      this.parseClassMethod(n, i, s, u);
  } else this.parseClassField(n);
  return n;
};
Ee.isClassElementNameStart = function () {
  return (
    this.type === A.name ||
    this.type === A.privateId ||
    this.type === A.num ||
    this.type === A.string ||
    this.type === A.bracketL ||
    this.type.keyword
  );
};
Ee.parseClassElementName = function (t) {
  this.type === A.privateId
    ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"),
      (t.computed = !1),
      (t.key = this.parsePrivateIdent()))
    : this.parsePropertyName(t);
};
Ee.parseClassMethod = function (t, e, n, r) {
  var i = t.key;
  t.kind === "constructor"
    ? (e && this.raise(i.start, "Constructor can't be a generator"), n && this.raise(i.start, "Constructor can't be an async method"))
    : t.static && $p(t, "prototype") && this.raise(i.start, "Classes may not have a static property named prototype");
  var s = (t.value = this.parseMethod(e, n, r));
  return (
    t.kind === "get" && s.params.length !== 0 && this.raiseRecoverable(s.start, "getter should have no params"),
    t.kind === "set" && s.params.length !== 1 && this.raiseRecoverable(s.start, "setter should have exactly one param"),
    t.kind === "set" && s.params[0].type === "RestElement" && this.raiseRecoverable(s.params[0].start, "Setter cannot use rest params"),
    this.finishNode(t, "MethodDefinition")
  );
};
Ee.parseClassField = function (t) {
  if (
    ($p(t, "constructor")
      ? this.raise(t.key.start, "Classes can't have a field named 'constructor'")
      : t.static && $p(t, "prototype") && this.raise(t.key.start, "Classes can't have a static field named 'prototype'"),
    this.eat(A.eq))
  ) {
    var e = this.currentThisScope(),
      n = e.inClassFieldInit;
    (e.inClassFieldInit = !0), (t.value = this.parseMaybeAssign()), (e.inClassFieldInit = n);
  } else t.value = null;
  return this.semicolon(), this.finishNode(t, "PropertyDefinition");
};
Ee.parseClassStaticBlock = function (t) {
  t.body = [];
  var e = this.labels;
  for (this.labels = [], this.enterScope(Uh | mw); this.type !== A.braceR; ) {
    var n = this.parseStatement(null);
    t.body.push(n);
  }
  return this.next(), this.exitScope(), (this.labels = e), this.finishNode(t, "StaticBlock");
};
Ee.parseClassId = function (t, e) {
  this.type === A.name
    ? ((t.id = this.parseIdent()), e && this.checkLValSimple(t.id, xs, !1))
    : (e === !0 && this.unexpected(), (t.id = null));
};
Ee.parseClassSuper = function (t) {
  t.superClass = this.eat(A._extends) ? this.parseExprSubscripts(null, !1) : null;
};
Ee.enterClassBody = function () {
  var t = { declared: Object.create(null), used: [] };
  return this.privateNameStack.push(t), t.declared;
};
Ee.exitClassBody = function () {
  var t = this.privateNameStack.pop(),
    e = t.declared,
    n = t.used;
  if (this.options.checkPrivateFields)
    for (var r = this.privateNameStack.length, i = r === 0 ? null : this.privateNameStack[r - 1], s = 0; s < n.length; ++s) {
      var o = n[s];
      zh(e, o.name) ||
        (i ? i.used.push(o) : this.raiseRecoverable(o.start, "Private field '#" + o.name + "' must be declared in an enclosing class"));
    }
};
function $te(t, e) {
  var n = e.key.name,
    r = t[n],
    i = "true";
  return (
    e.type === "MethodDefinition" && (e.kind === "get" || e.kind === "set") && (i = (e.static ? "s" : "i") + e.kind),
    (r === "iget" && i === "iset") || (r === "iset" && i === "iget") || (r === "sget" && i === "sset") || (r === "sset" && i === "sget")
      ? ((t[n] = "true"), !1)
      : r
      ? !0
      : ((t[n] = i), !1)
  );
}
function $p(t, e) {
  var n = t.computed,
    r = t.key;
  return !n && ((r.type === "Identifier" && r.name === e) || (r.type === "Literal" && r.value === e));
}
Ee.parseExportAllDeclaration = function (t, e) {
  return (
    this.options.ecmaVersion >= 11 &&
      (this.eatContextual("as")
        ? ((t.exported = this.parseModuleExportName()), this.checkExport(e, t.exported, this.lastTokStart))
        : (t.exported = null)),
    this.expectContextual("from"),
    this.type !== A.string && this.unexpected(),
    (t.source = this.parseExprAtom()),
    this.semicolon(),
    this.finishNode(t, "ExportAllDeclaration")
  );
};
Ee.parseExport = function (t, e) {
  if ((this.next(), this.eat(A.star))) return this.parseExportAllDeclaration(t, e);
  if (this.eat(A._default))
    return (
      this.checkExport(e, "default", this.lastTokStart),
      (t.declaration = this.parseExportDefaultDeclaration()),
      this.finishNode(t, "ExportDefaultDeclaration")
    );
  if (this.shouldParseExportStatement())
    (t.declaration = this.parseExportDeclaration(t)),
      t.declaration.type === "VariableDeclaration"
        ? this.checkVariableExport(e, t.declaration.declarations)
        : this.checkExport(e, t.declaration.id, t.declaration.id.start),
      (t.specifiers = []),
      (t.source = null);
  else {
    if (((t.declaration = null), (t.specifiers = this.parseExportSpecifiers(e)), this.eatContextual("from")))
      this.type !== A.string && this.unexpected(), (t.source = this.parseExprAtom());
    else {
      for (var n = 0, r = t.specifiers; n < r.length; n += 1) {
        var i = r[n];
        this.checkUnreserved(i.local),
          this.checkLocalExport(i.local),
          i.local.type === "Literal" && this.raise(i.local.start, "A string literal cannot be used as an exported binding without `from`.");
      }
      t.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(t, "ExportNamedDeclaration");
};
Ee.parseExportDeclaration = function (t) {
  return this.parseStatement(null);
};
Ee.parseExportDefaultDeclaration = function () {
  var t;
  if (this.type === A._function || (t = this.isAsyncFunction())) {
    var e = this.startNode();
    return this.next(), t && this.next(), this.parseFunction(e, au | N7, !1, t);
  } else if (this.type === A._class) {
    var n = this.startNode();
    return this.parseClass(n, "nullableID");
  } else {
    var r = this.parseMaybeAssign();
    return this.semicolon(), r;
  }
};
Ee.checkExport = function (t, e, n) {
  t &&
    (typeof e != "string" && (e = e.type === "Identifier" ? e.name : e.value),
    zh(t, e) && this.raiseRecoverable(n, "Duplicate export '" + e + "'"),
    (t[e] = !0));
};
Ee.checkPatternExport = function (t, e) {
  var n = e.type;
  if (n === "Identifier") this.checkExport(t, e, e.start);
  else if (n === "ObjectPattern")
    for (var r = 0, i = e.properties; r < i.length; r += 1) {
      var s = i[r];
      this.checkPatternExport(t, s);
    }
  else if (n === "ArrayPattern")
    for (var o = 0, a = e.elements; o < a.length; o += 1) {
      var l = a[o];
      l && this.checkPatternExport(t, l);
    }
  else
    n === "Property"
      ? this.checkPatternExport(t, e.value)
      : n === "AssignmentPattern"
      ? this.checkPatternExport(t, e.left)
      : n === "RestElement" && this.checkPatternExport(t, e.argument);
};
Ee.checkVariableExport = function (t, e) {
  if (t)
    for (var n = 0, r = e; n < r.length; n += 1) {
      var i = r[n];
      this.checkPatternExport(t, i.id);
    }
};
Ee.shouldParseExportStatement = function () {
  return (
    this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
  );
};
Ee.parseExportSpecifier = function (t) {
  var e = this.startNode();
  return (
    (e.local = this.parseModuleExportName()),
    (e.exported = this.eatContextual("as") ? this.parseModuleExportName() : e.local),
    this.checkExport(t, e.exported, e.exported.start),
    this.finishNode(e, "ExportSpecifier")
  );
};
Ee.parseExportSpecifiers = function (t) {
  var e = [],
    n = !0;
  for (this.expect(A.braceL); !this.eat(A.braceR); ) {
    if (n) n = !1;
    else if ((this.expect(A.comma), this.afterTrailingComma(A.braceR))) break;
    e.push(this.parseExportSpecifier(t));
  }
  return e;
};
Ee.parseImport = function (t) {
  return (
    this.next(),
    this.type === A.string
      ? ((t.specifiers = Ate), (t.source = this.parseExprAtom()))
      : ((t.specifiers = this.parseImportSpecifiers()),
        this.expectContextual("from"),
        (t.source = this.type === A.string ? this.parseExprAtom() : this.unexpected())),
    this.semicolon(),
    this.finishNode(t, "ImportDeclaration")
  );
};
Ee.parseImportSpecifier = function () {
  var t = this.startNode();
  return (
    (t.imported = this.parseModuleExportName()),
    this.eatContextual("as") ? (t.local = this.parseIdent()) : (this.checkUnreserved(t.imported), (t.local = t.imported)),
    this.checkLValSimple(t.local, xs),
    this.finishNode(t, "ImportSpecifier")
  );
};
Ee.parseImportDefaultSpecifier = function () {
  var t = this.startNode();
  return (t.local = this.parseIdent()), this.checkLValSimple(t.local, xs), this.finishNode(t, "ImportDefaultSpecifier");
};
Ee.parseImportNamespaceSpecifier = function () {
  var t = this.startNode();
  return (
    this.next(),
    this.expectContextual("as"),
    (t.local = this.parseIdent()),
    this.checkLValSimple(t.local, xs),
    this.finishNode(t, "ImportNamespaceSpecifier")
  );
};
Ee.parseImportSpecifiers = function () {
  var t = [],
    e = !0;
  if (this.type === A.name && (t.push(this.parseImportDefaultSpecifier()), !this.eat(A.comma))) return t;
  if (this.type === A.star) return t.push(this.parseImportNamespaceSpecifier()), t;
  for (this.expect(A.braceL); !this.eat(A.braceR); ) {
    if (e) e = !1;
    else if ((this.expect(A.comma), this.afterTrailingComma(A.braceR))) break;
    t.push(this.parseImportSpecifier());
  }
  return t;
};
Ee.parseModuleExportName = function () {
  if (this.options.ecmaVersion >= 13 && this.type === A.string) {
    var t = this.parseLiteral(this.value);
    return Cte.test(t.value) && this.raise(t.start, "An export name cannot include a lone surrogate."), t;
  }
  return this.parseIdent(!0);
};
Ee.adaptDirectivePrologue = function (t) {
  for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e) t[e].directive = t[e].expression.raw.slice(1, -1);
};
Ee.isDirectiveCandidate = function (t) {
  return (
    this.options.ecmaVersion >= 5 &&
    t.type === "ExpressionStatement" &&
    t.expression.type === "Literal" &&
    typeof t.expression.value == "string" &&
    (this.input[t.start] === '"' || this.input[t.start] === "'")
  );
};
var Dr = Mt.prototype;
Dr.toAssignable = function (t, e, n) {
  if (this.options.ecmaVersion >= 6 && t)
    switch (t.type) {
      case "Identifier":
        this.inAsync && t.name === "await" && this.raise(t.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        (t.type = "ObjectPattern"), n && this.checkPatternErrors(n, !0);
        for (var r = 0, i = t.properties; r < i.length; r += 1) {
          var s = i[r];
          this.toAssignable(s, e),
            s.type === "RestElement" &&
              (s.argument.type === "ArrayPattern" || s.argument.type === "ObjectPattern") &&
              this.raise(s.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        t.kind !== "init" && this.raise(t.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(t.value, e);
        break;
      case "ArrayExpression":
        (t.type = "ArrayPattern"), n && this.checkPatternErrors(n, !0), this.toAssignableList(t.elements, e);
        break;
      case "SpreadElement":
        (t.type = "RestElement"),
          this.toAssignable(t.argument, e),
          t.argument.type === "AssignmentPattern" && this.raise(t.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(t.left.end, "Only '=' operator can be used for specifying default value."),
          (t.type = "AssignmentPattern"),
          delete t.operator,
          this.toAssignable(t.left, e);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(t.expression, e, n);
        break;
      case "ChainExpression":
        this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!e) break;
      default:
        this.raise(t.start, "Assigning to rvalue");
    }
  else n && this.checkPatternErrors(n, !0);
  return t;
};
Dr.toAssignableList = function (t, e) {
  for (var n = t.length, r = 0; r < n; r++) {
    var i = t[r];
    i && this.toAssignable(i, e);
  }
  if (n) {
    var s = t[n - 1];
    this.options.ecmaVersion === 6 &&
      e &&
      s &&
      s.type === "RestElement" &&
      s.argument.type !== "Identifier" &&
      this.unexpected(s.argument.start);
  }
  return t;
};
Dr.parseSpread = function (t) {
  var e = this.startNode();
  return this.next(), (e.argument = this.parseMaybeAssign(!1, t)), this.finishNode(e, "SpreadElement");
};
Dr.parseRestBinding = function () {
  var t = this.startNode();
  return (
    this.next(),
    this.options.ecmaVersion === 6 && this.type !== A.name && this.unexpected(),
    (t.argument = this.parseBindingAtom()),
    this.finishNode(t, "RestElement")
  );
};
Dr.parseBindingAtom = function () {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case A.bracketL:
        var t = this.startNode();
        return this.next(), (t.elements = this.parseBindingList(A.bracketR, !0, !0)), this.finishNode(t, "ArrayPattern");
      case A.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
Dr.parseBindingList = function (t, e, n, r) {
  for (var i = [], s = !0; !this.eat(t); )
    if ((s ? (s = !1) : this.expect(A.comma), e && this.type === A.comma)) i.push(null);
    else {
      if (n && this.afterTrailingComma(t)) break;
      if (this.type === A.ellipsis) {
        var o = this.parseRestBinding();
        this.parseBindingListItem(o),
          i.push(o),
          this.type === A.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"),
          this.expect(t);
        break;
      } else i.push(this.parseAssignableListItem(r));
    }
  return i;
};
Dr.parseAssignableListItem = function (t) {
  var e = this.parseMaybeDefault(this.start, this.startLoc);
  return this.parseBindingListItem(e), e;
};
Dr.parseBindingListItem = function (t) {
  return t;
};
Dr.parseMaybeDefault = function (t, e, n) {
  if (((n = n || this.parseBindingAtom()), this.options.ecmaVersion < 6 || !this.eat(A.eq))) return n;
  var r = this.startNodeAt(t, e);
  return (r.left = n), (r.right = this.parseMaybeAssign()), this.finishNode(r, "AssignmentPattern");
};
Dr.checkLValSimple = function (t, e, n) {
  e === void 0 && (e = Ap);
  var r = e !== Ap;
  switch (t.type) {
    case "Identifier":
      this.strict &&
        this.reservedWordsStrictBind.test(t.name) &&
        this.raiseRecoverable(t.start, (r ? "Binding " : "Assigning to ") + t.name + " in strict mode"),
        r &&
          (e === xs && t.name === "let" && this.raiseRecoverable(t.start, "let is disallowed as a lexically bound name"),
          n && (zh(n, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), (n[t.name] = !0)),
          e !== I7 && this.declareName(t.name, e, t.start));
      break;
    case "ChainExpression":
      this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      r && this.raiseRecoverable(t.start, "Binding member expression");
      break;
    case "ParenthesizedExpression":
      return r && this.raiseRecoverable(t.start, "Binding parenthesized expression"), this.checkLValSimple(t.expression, e, n);
    default:
      this.raise(t.start, (r ? "Binding" : "Assigning to") + " rvalue");
  }
};
Dr.checkLValPattern = function (t, e, n) {
  switch ((e === void 0 && (e = Ap), t.type)) {
    case "ObjectPattern":
      for (var r = 0, i = t.properties; r < i.length; r += 1) {
        var s = i[r];
        this.checkLValInnerPattern(s, e, n);
      }
      break;
    case "ArrayPattern":
      for (var o = 0, a = t.elements; o < a.length; o += 1) {
        var l = a[o];
        l && this.checkLValInnerPattern(l, e, n);
      }
      break;
    default:
      this.checkLValSimple(t, e, n);
  }
};
Dr.checkLValInnerPattern = function (t, e, n) {
  switch ((e === void 0 && (e = Ap), t.type)) {
    case "Property":
      this.checkLValInnerPattern(t.value, e, n);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(t.left, e, n);
      break;
    case "RestElement":
      this.checkLValPattern(t.argument, e, n);
      break;
    default:
      this.checkLValPattern(t, e, n);
  }
};
var kr = function (e, n, r, i, s) {
    (this.token = e), (this.isExpr = !!n), (this.preserveSpace = !!r), (this.override = i), (this.generator = !!s);
  },
  Tt = {
    b_stat: new kr("{", !1),
    b_expr: new kr("{", !0),
    b_tmpl: new kr("${", !1),
    p_stat: new kr("(", !1),
    p_expr: new kr("(", !0),
    q_tmpl: new kr("`", !0, !0, function (t) {
      return t.tryReadTemplateToken();
    }),
    f_stat: new kr("function", !1),
    f_expr: new kr("function", !0),
    f_expr_gen: new kr("function", !0, !1, null, !0),
    f_gen: new kr("function", !1, !1, null, !0),
  },
  nc = Mt.prototype;
nc.initialContext = function () {
  return [Tt.b_stat];
};
nc.curContext = function () {
  return this.context[this.context.length - 1];
};
nc.braceIsBlock = function (t) {
  var e = this.curContext();
  return e === Tt.f_expr || e === Tt.f_stat
    ? !0
    : t === A.colon && (e === Tt.b_stat || e === Tt.b_expr)
    ? !e.isExpr
    : t === A._return || (t === A.name && this.exprAllowed)
    ? br.test(this.input.slice(this.lastTokEnd, this.start))
    : t === A._else || t === A.semi || t === A.eof || t === A.parenR || t === A.arrow
    ? !0
    : t === A.braceL
    ? e === Tt.b_stat
    : t === A._var || t === A._const || t === A.name
    ? !1
    : !this.exprAllowed;
};
nc.inGeneratorContext = function () {
  for (var t = this.context.length - 1; t >= 1; t--) {
    var e = this.context[t];
    if (e.token === "function") return e.generator;
  }
  return !1;
};
nc.updateContext = function (t) {
  var e,
    n = this.type;
  n.keyword && t === A.dot ? (this.exprAllowed = !1) : (e = n.updateContext) ? e.call(this, t) : (this.exprAllowed = n.beforeExpr);
};
nc.overrideContext = function (t) {
  this.curContext() !== t && (this.context[this.context.length - 1] = t);
};
A.parenR.updateContext = A.braceR.updateContext = function () {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var t = this.context.pop();
  t === Tt.b_stat && this.curContext().token === "function" && (t = this.context.pop()), (this.exprAllowed = !t.isExpr);
};
A.braceL.updateContext = function (t) {
  this.context.push(this.braceIsBlock(t) ? Tt.b_stat : Tt.b_expr), (this.exprAllowed = !0);
};
A.dollarBraceL.updateContext = function () {
  this.context.push(Tt.b_tmpl), (this.exprAllowed = !0);
};
A.parenL.updateContext = function (t) {
  var e = t === A._if || t === A._for || t === A._with || t === A._while;
  this.context.push(e ? Tt.p_stat : Tt.p_expr), (this.exprAllowed = !0);
};
A.incDec.updateContext = function () {};
A._function.updateContext = A._class.updateContext = function (t) {
  t.beforeExpr &&
  t !== A._else &&
  !(t === A.semi && this.curContext() !== Tt.p_stat) &&
  !(t === A._return && br.test(this.input.slice(this.lastTokEnd, this.start))) &&
  !((t === A.colon || t === A.braceL) && this.curContext() === Tt.b_stat)
    ? this.context.push(Tt.f_expr)
    : this.context.push(Tt.f_stat),
    (this.exprAllowed = !1);
};
A.colon.updateContext = function () {
  this.curContext().token === "function" && this.context.pop(), (this.exprAllowed = !0);
};
A.backQuote.updateContext = function () {
  this.curContext() === Tt.q_tmpl ? this.context.pop() : this.context.push(Tt.q_tmpl), (this.exprAllowed = !1);
};
A.star.updateContext = function (t) {
  if (t === A._function) {
    var e = this.context.length - 1;
    this.context[e] === Tt.f_expr ? (this.context[e] = Tt.f_expr_gen) : (this.context[e] = Tt.f_gen);
  }
  this.exprAllowed = !0;
};
A.name.updateContext = function (t) {
  var e = !1;
  this.options.ecmaVersion >= 6 &&
    t !== A.dot &&
    ((this.value === "of" && !this.exprAllowed) || (this.value === "yield" && this.inGeneratorContext())) &&
    (e = !0),
    (this.exprAllowed = e);
};
var Ne = Mt.prototype;
Ne.checkPropClash = function (t, e, n) {
  if (
    !(this.options.ecmaVersion >= 9 && t.type === "SpreadElement") &&
    !(this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))
  ) {
    var r = t.key,
      i;
    switch (r.type) {
      case "Identifier":
        i = r.name;
        break;
      case "Literal":
        i = String(r.value);
        break;
      default:
        return;
    }
    var s = t.kind;
    if (this.options.ecmaVersion >= 6) {
      i === "__proto__" &&
        s === "init" &&
        (e.proto &&
          (n ? n.doubleProto < 0 && (n.doubleProto = r.start) : this.raiseRecoverable(r.start, "Redefinition of __proto__ property")),
        (e.proto = !0));
      return;
    }
    i = "$" + i;
    var o = e[i];
    if (o) {
      var a;
      s === "init" ? (a = (this.strict && o.init) || o.get || o.set) : (a = o.init || o[s]),
        a && this.raiseRecoverable(r.start, "Redefinition of property");
    } else o = e[i] = { init: !1, get: !1, set: !1 };
    o[s] = !0;
  }
};
Ne.parseExpression = function (t, e) {
  var n = this.start,
    r = this.startLoc,
    i = this.parseMaybeAssign(t, e);
  if (this.type === A.comma) {
    var s = this.startNodeAt(n, r);
    for (s.expressions = [i]; this.eat(A.comma); ) s.expressions.push(this.parseMaybeAssign(t, e));
    return this.finishNode(s, "SequenceExpression");
  }
  return i;
};
Ne.parseMaybeAssign = function (t, e, n) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) return this.parseYield(t);
    this.exprAllowed = !1;
  }
  var r = !1,
    i = -1,
    s = -1,
    o = -1;
  e
    ? ((i = e.parenthesizedAssign), (s = e.trailingComma), (o = e.doubleProto), (e.parenthesizedAssign = e.trailingComma = -1))
    : ((e = new pg()), (r = !0));
  var a = this.start,
    l = this.startLoc;
  (this.type === A.parenL || this.type === A.name) &&
    ((this.potentialArrowAt = this.start), (this.potentialArrowInForAwait = t === "await"));
  var c = this.parseMaybeConditional(t, e);
  if ((n && (c = n.call(this, c, a, l)), this.type.isAssign)) {
    var u = this.startNodeAt(a, l);
    return (
      (u.operator = this.value),
      this.type === A.eq && (c = this.toAssignable(c, !1, e)),
      r || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1),
      e.shorthandAssign >= c.start && (e.shorthandAssign = -1),
      this.type === A.eq ? this.checkLValPattern(c) : this.checkLValSimple(c),
      (u.left = c),
      this.next(),
      (u.right = this.parseMaybeAssign(t)),
      o > -1 && (e.doubleProto = o),
      this.finishNode(u, "AssignmentExpression")
    );
  } else r && this.checkExpressionErrors(e, !0);
  return i > -1 && (e.parenthesizedAssign = i), s > -1 && (e.trailingComma = s), c;
};
Ne.parseMaybeConditional = function (t, e) {
  var n = this.start,
    r = this.startLoc,
    i = this.parseExprOps(t, e);
  if (this.checkExpressionErrors(e)) return i;
  if (this.eat(A.question)) {
    var s = this.startNodeAt(n, r);
    return (
      (s.test = i),
      (s.consequent = this.parseMaybeAssign()),
      this.expect(A.colon),
      (s.alternate = this.parseMaybeAssign(t)),
      this.finishNode(s, "ConditionalExpression")
    );
  }
  return i;
};
Ne.parseExprOps = function (t, e) {
  var n = this.start,
    r = this.startLoc,
    i = this.parseMaybeUnary(e, !1, !1, t);
  return this.checkExpressionErrors(e) || (i.start === n && i.type === "ArrowFunctionExpression") ? i : this.parseExprOp(i, n, r, -1, t);
};
Ne.parseExprOp = function (t, e, n, r, i) {
  var s = this.type.binop;
  if (s != null && (!i || this.type !== A._in) && s > r) {
    var o = this.type === A.logicalOR || this.type === A.logicalAND,
      a = this.type === A.coalesce;
    a && (s = A.logicalAND.binop);
    var l = this.value;
    this.next();
    var c = this.start,
      u = this.startLoc,
      h = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, i), c, u, s, i),
      f = this.buildBinary(e, n, t, h, l, o || a);
    return (
      ((o && this.type === A.coalesce) || (a && (this.type === A.logicalOR || this.type === A.logicalAND))) &&
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),
      this.parseExprOp(f, e, n, r, i)
    );
  }
  return t;
};
Ne.buildBinary = function (t, e, n, r, i, s) {
  r.type === "PrivateIdentifier" && this.raise(r.start, "Private identifier can only be left side of binary expression");
  var o = this.startNodeAt(t, e);
  return (o.left = n), (o.operator = i), (o.right = r), this.finishNode(o, s ? "LogicalExpression" : "BinaryExpression");
};
Ne.parseMaybeUnary = function (t, e, n, r) {
  var i = this.start,
    s = this.startLoc,
    o;
  if (this.isContextual("await") && this.canAwait) (o = this.parseAwait(r)), (e = !0);
  else if (this.type.prefix) {
    var a = this.startNode(),
      l = this.type === A.incDec;
    (a.operator = this.value),
      (a.prefix = !0),
      this.next(),
      (a.argument = this.parseMaybeUnary(null, !0, l, r)),
      this.checkExpressionErrors(t, !0),
      l
        ? this.checkLValSimple(a.argument)
        : this.strict && a.operator === "delete" && a.argument.type === "Identifier"
        ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode")
        : a.operator === "delete" && L7(a.argument)
        ? this.raiseRecoverable(a.start, "Private fields can not be deleted")
        : (e = !0),
      (o = this.finishNode(a, l ? "UpdateExpression" : "UnaryExpression"));
  } else if (!e && this.type === A.privateId)
    (r || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(),
      (o = this.parsePrivateIdent()),
      this.type !== A._in && this.unexpected();
  else {
    if (((o = this.parseExprSubscripts(t, r)), this.checkExpressionErrors(t))) return o;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var c = this.startNodeAt(i, s);
      (c.operator = this.value),
        (c.prefix = !1),
        (c.argument = o),
        this.checkLValSimple(o),
        this.next(),
        (o = this.finishNode(c, "UpdateExpression"));
    }
  }
  if (!n && this.eat(A.starstar))
    if (e) this.unexpected(this.lastTokStart);
    else return this.buildBinary(i, s, o, this.parseMaybeUnary(null, !1, !1, r), "**", !1);
  else return o;
};
function L7(t) {
  return (t.type === "MemberExpression" && t.property.type === "PrivateIdentifier") || (t.type === "ChainExpression" && L7(t.expression));
}
Ne.parseExprSubscripts = function (t, e) {
  var n = this.start,
    r = this.startLoc,
    i = this.parseExprAtom(t, e);
  if (i.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return i;
  var s = this.parseSubscripts(i, n, r, !1, e);
  return (
    t &&
      s.type === "MemberExpression" &&
      (t.parenthesizedAssign >= s.start && (t.parenthesizedAssign = -1),
      t.parenthesizedBind >= s.start && (t.parenthesizedBind = -1),
      t.trailingComma >= s.start && (t.trailingComma = -1)),
    s
  );
};
Ne.parseSubscripts = function (t, e, n, r, i) {
  for (
    var s =
        this.options.ecmaVersion >= 8 &&
        t.type === "Identifier" &&
        t.name === "async" &&
        this.lastTokEnd === t.end &&
        !this.canInsertSemicolon() &&
        t.end - t.start === 5 &&
        this.potentialArrowAt === t.start,
      o = !1;
    ;

  ) {
    var a = this.parseSubscript(t, e, n, r, s, o, i);
    if ((a.optional && (o = !0), a === t || a.type === "ArrowFunctionExpression")) {
      if (o) {
        var l = this.startNodeAt(e, n);
        (l.expression = a), (a = this.finishNode(l, "ChainExpression"));
      }
      return a;
    }
    t = a;
  }
};
Ne.shouldParseAsyncArrow = function () {
  return !this.canInsertSemicolon() && this.eat(A.arrow);
};
Ne.parseSubscriptAsyncArrow = function (t, e, n, r) {
  return this.parseArrowExpression(this.startNodeAt(t, e), n, !0, r);
};
Ne.parseSubscript = function (t, e, n, r, i, s, o) {
  var a = this.options.ecmaVersion >= 11,
    l = a && this.eat(A.questionDot);
  r && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var c = this.eat(A.bracketL);
  if (c || (l && this.type !== A.parenL && this.type !== A.backQuote) || this.eat(A.dot)) {
    var u = this.startNodeAt(e, n);
    (u.object = t),
      c
        ? ((u.property = this.parseExpression()), this.expect(A.bracketR))
        : this.type === A.privateId && t.type !== "Super"
        ? (u.property = this.parsePrivateIdent())
        : (u.property = this.parseIdent(this.options.allowReserved !== "never")),
      (u.computed = !!c),
      a && (u.optional = l),
      (t = this.finishNode(u, "MemberExpression"));
  } else if (!r && this.eat(A.parenL)) {
    var h = new pg(),
      f = this.yieldPos,
      d = this.awaitPos,
      p = this.awaitIdentPos;
    (this.yieldPos = 0), (this.awaitPos = 0), (this.awaitIdentPos = 0);
    var m = this.parseExprList(A.parenR, this.options.ecmaVersion >= 8, !1, h);
    if (i && !l && this.shouldParseAsyncArrow())
      return (
        this.checkPatternErrors(h, !1),
        this.checkYieldAwaitInDefaultParams(),
        this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"),
        (this.yieldPos = f),
        (this.awaitPos = d),
        (this.awaitIdentPos = p),
        this.parseSubscriptAsyncArrow(e, n, m, o)
      );
    this.checkExpressionErrors(h, !0),
      (this.yieldPos = f || this.yieldPos),
      (this.awaitPos = d || this.awaitPos),
      (this.awaitIdentPos = p || this.awaitIdentPos);
    var O = this.startNodeAt(e, n);
    (O.callee = t), (O.arguments = m), a && (O.optional = l), (t = this.finishNode(O, "CallExpression"));
  } else if (this.type === A.backQuote) {
    (l || s) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var v = this.startNodeAt(e, n);
    (v.tag = t), (v.quasi = this.parseTemplate({ isTagged: !0 })), (t = this.finishNode(v, "TaggedTemplateExpression"));
  }
  return t;
};
Ne.parseExprAtom = function (t, e, n) {
  this.type === A.slash && this.readRegexp();
  var r,
    i = this.potentialArrowAt === this.start;
  switch (this.type) {
    case A._super:
      return (
        this.allowSuper || this.raise(this.start, "'super' keyword outside a method"),
        (r = this.startNode()),
        this.next(),
        this.type === A.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"),
        this.type !== A.dot && this.type !== A.bracketL && this.type !== A.parenL && this.unexpected(),
        this.finishNode(r, "Super")
      );
    case A._this:
      return (r = this.startNode()), this.next(), this.finishNode(r, "ThisExpression");
    case A.name:
      var s = this.start,
        o = this.startLoc,
        a = this.containsEsc,
        l = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !a && l.name === "async" && !this.canInsertSemicolon() && this.eat(A._function))
        return this.overrideContext(Tt.f_expr), this.parseFunction(this.startNodeAt(s, o), 0, !1, !0, e);
      if (i && !this.canInsertSemicolon()) {
        if (this.eat(A.arrow)) return this.parseArrowExpression(this.startNodeAt(s, o), [l], !1, e);
        if (
          this.options.ecmaVersion >= 8 &&
          l.name === "async" &&
          this.type === A.name &&
          !a &&
          (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)
        )
          return (
            (l = this.parseIdent(!1)),
            (this.canInsertSemicolon() || !this.eat(A.arrow)) && this.unexpected(),
            this.parseArrowExpression(this.startNodeAt(s, o), [l], !0, e)
          );
      }
      return l;
    case A.regexp:
      var c = this.value;
      return (r = this.parseLiteral(c.value)), (r.regex = { pattern: c.pattern, flags: c.flags }), r;
    case A.num:
    case A.string:
      return this.parseLiteral(this.value);
    case A._null:
    case A._true:
    case A._false:
      return (
        (r = this.startNode()),
        (r.value = this.type === A._null ? null : this.type === A._true),
        (r.raw = this.type.keyword),
        this.next(),
        this.finishNode(r, "Literal")
      );
    case A.parenL:
      var u = this.start,
        h = this.parseParenAndDistinguishExpression(i, e);
      return (
        t &&
          (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(h) && (t.parenthesizedAssign = u),
          t.parenthesizedBind < 0 && (t.parenthesizedBind = u)),
        h
      );
    case A.bracketL:
      return (
        (r = this.startNode()), this.next(), (r.elements = this.parseExprList(A.bracketR, !0, !0, t)), this.finishNode(r, "ArrayExpression")
      );
    case A.braceL:
      return this.overrideContext(Tt.b_expr), this.parseObj(!1, t);
    case A._function:
      return (r = this.startNode()), this.next(), this.parseFunction(r, 0);
    case A._class:
      return this.parseClass(this.startNode(), !1);
    case A._new:
      return this.parseNew();
    case A.backQuote:
      return this.parseTemplate();
    case A._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport(n) : this.unexpected();
    default:
      return this.parseExprAtomDefault();
  }
};
Ne.parseExprAtomDefault = function () {
  this.unexpected();
};
Ne.parseExprImport = function (t) {
  var e = this.startNode();
  if (
    (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === A.parenL && !t)
  )
    return this.parseDynamicImport(e);
  if (this.type === A.dot) {
    var n = this.startNodeAt(e.start, e.loc && e.loc.start);
    return (n.name = "import"), (e.meta = this.finishNode(n, "Identifier")), this.parseImportMeta(e);
  } else this.unexpected();
};
Ne.parseDynamicImport = function (t) {
  if ((this.next(), (t.source = this.parseMaybeAssign()), !this.eat(A.parenR))) {
    var e = this.start;
    this.eat(A.comma) && this.eat(A.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e);
  }
  return this.finishNode(t, "ImportExpression");
};
Ne.parseImportMeta = function (t) {
  this.next();
  var e = this.containsEsc;
  return (
    (t.property = this.parseIdent(!0)),
    t.property.name !== "meta" && this.raiseRecoverable(t.property.start, "The only valid meta property for import is 'import.meta'"),
    e && this.raiseRecoverable(t.start, "'import.meta' must not contain escaped characters"),
    this.options.sourceType !== "module" &&
      !this.options.allowImportExportEverywhere &&
      this.raiseRecoverable(t.start, "Cannot use 'import.meta' outside a module"),
    this.finishNode(t, "MetaProperty")
  );
};
Ne.parseLiteral = function (t) {
  var e = this.startNode();
  return (
    (e.value = t),
    (e.raw = this.input.slice(this.start, this.end)),
    e.raw.charCodeAt(e.raw.length - 1) === 110 && (e.bigint = e.raw.slice(0, -1).replace(/_/g, "")),
    this.next(),
    this.finishNode(e, "Literal")
  );
};
Ne.parseParenExpression = function () {
  this.expect(A.parenL);
  var t = this.parseExpression();
  return this.expect(A.parenR), t;
};
Ne.shouldParseArrow = function (t) {
  return !this.canInsertSemicolon();
};
Ne.parseParenAndDistinguishExpression = function (t, e) {
  var n = this.start,
    r = this.startLoc,
    i,
    s = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var o = this.start,
      a = this.startLoc,
      l = [],
      c = !0,
      u = !1,
      h = new pg(),
      f = this.yieldPos,
      d = this.awaitPos,
      p;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== A.parenR; )
      if ((c ? (c = !1) : this.expect(A.comma), s && this.afterTrailingComma(A.parenR, !0))) {
        u = !0;
        break;
      } else if (this.type === A.ellipsis) {
        (p = this.start),
          l.push(this.parseParenItem(this.parseRestBinding())),
          this.type === A.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        break;
      } else l.push(this.parseMaybeAssign(!1, h, this.parseParenItem));
    var m = this.lastTokEnd,
      O = this.lastTokEndLoc;
    if ((this.expect(A.parenR), t && this.shouldParseArrow(l) && this.eat(A.arrow)))
      return (
        this.checkPatternErrors(h, !1),
        this.checkYieldAwaitInDefaultParams(),
        (this.yieldPos = f),
        (this.awaitPos = d),
        this.parseParenArrowList(n, r, l, e)
      );
    (!l.length || u) && this.unexpected(this.lastTokStart),
      p && this.unexpected(p),
      this.checkExpressionErrors(h, !0),
      (this.yieldPos = f || this.yieldPos),
      (this.awaitPos = d || this.awaitPos),
      l.length > 1 ? ((i = this.startNodeAt(o, a)), (i.expressions = l), this.finishNodeAt(i, "SequenceExpression", m, O)) : (i = l[0]);
  } else i = this.parseParenExpression();
  if (this.options.preserveParens) {
    var v = this.startNodeAt(n, r);
    return (v.expression = i), this.finishNode(v, "ParenthesizedExpression");
  } else return i;
};
Ne.parseParenItem = function (t) {
  return t;
};
Ne.parseParenArrowList = function (t, e, n, r) {
  return this.parseArrowExpression(this.startNodeAt(t, e), n, !1, r);
};
var Rte = [];
Ne.parseNew = function () {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var t = this.startNode();
  if ((this.next(), this.options.ecmaVersion >= 6 && this.type === A.dot)) {
    var e = this.startNodeAt(t.start, t.loc && t.loc.start);
    (e.name = "new"), (t.meta = this.finishNode(e, "Identifier")), this.next();
    var n = this.containsEsc;
    return (
      (t.property = this.parseIdent(!0)),
      t.property.name !== "target" && this.raiseRecoverable(t.property.start, "The only valid meta property for new is 'new.target'"),
      n && this.raiseRecoverable(t.start, "'new.target' must not contain escaped characters"),
      this.allowNewDotTarget || this.raiseRecoverable(t.start, "'new.target' can only be used in functions and class static block"),
      this.finishNode(t, "MetaProperty")
    );
  }
  var r = this.start,
    i = this.startLoc;
  return (
    (t.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), r, i, !0, !1)),
    this.eat(A.parenL) ? (t.arguments = this.parseExprList(A.parenR, this.options.ecmaVersion >= 8, !1)) : (t.arguments = Rte),
    this.finishNode(t, "NewExpression")
  );
};
Ne.parseTemplateElement = function (t) {
  var e = t.isTagged,
    n = this.startNode();
  return (
    this.type === A.invalidTemplate
      ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"),
        (n.value = { raw: this.value, cooked: null }))
      : (n.value = {
          raw: this.input.slice(this.start, this.end).replace(
            /\r\n?/g,
            `
`
          ),
          cooked: this.value,
        }),
    this.next(),
    (n.tail = this.type === A.backQuote),
    this.finishNode(n, "TemplateElement")
  );
};
Ne.parseTemplate = function (t) {
  t === void 0 && (t = {});
  var e = t.isTagged;
  e === void 0 && (e = !1);
  var n = this.startNode();
  this.next(), (n.expressions = []);
  var r = this.parseTemplateElement({ isTagged: e });
  for (n.quasis = [r]; !r.tail; )
    this.type === A.eof && this.raise(this.pos, "Unterminated template literal"),
      this.expect(A.dollarBraceL),
      n.expressions.push(this.parseExpression()),
      this.expect(A.braceR),
      n.quasis.push((r = this.parseTemplateElement({ isTagged: e })));
  return this.next(), this.finishNode(n, "TemplateLiteral");
};
Ne.isAsyncProp = function (t) {
  return (
    !t.computed &&
    t.key.type === "Identifier" &&
    t.key.name === "async" &&
    (this.type === A.name ||
      this.type === A.num ||
      this.type === A.string ||
      this.type === A.bracketL ||
      this.type.keyword ||
      (this.options.ecmaVersion >= 9 && this.type === A.star)) &&
    !br.test(this.input.slice(this.lastTokEnd, this.start))
  );
};
Ne.parseObj = function (t, e) {
  var n = this.startNode(),
    r = !0,
    i = {};
  for (n.properties = [], this.next(); !this.eat(A.braceR); ) {
    if (r) r = !1;
    else if ((this.expect(A.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(A.braceR))) break;
    var s = this.parseProperty(t, e);
    t || this.checkPropClash(s, i, e), n.properties.push(s);
  }
  return this.finishNode(n, t ? "ObjectPattern" : "ObjectExpression");
};
Ne.parseProperty = function (t, e) {
  var n = this.startNode(),
    r,
    i,
    s,
    o;
  if (this.options.ecmaVersion >= 9 && this.eat(A.ellipsis))
    return t
      ? ((n.argument = this.parseIdent(!1)),
        this.type === A.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"),
        this.finishNode(n, "RestElement"))
      : ((n.argument = this.parseMaybeAssign(!1, e)),
        this.type === A.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start),
        this.finishNode(n, "SpreadElement"));
  this.options.ecmaVersion >= 6 &&
    ((n.method = !1), (n.shorthand = !1), (t || e) && ((s = this.start), (o = this.startLoc)), t || (r = this.eat(A.star)));
  var a = this.containsEsc;
  return (
    this.parsePropertyName(n),
    !t && !a && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(n)
      ? ((i = !0), (r = this.options.ecmaVersion >= 9 && this.eat(A.star)), this.parsePropertyName(n))
      : (i = !1),
    this.parsePropertyValue(n, t, r, i, s, o, e, a),
    this.finishNode(n, "Property")
  );
};
Ne.parseGetterSetter = function (t) {
  (t.kind = t.key.name), this.parsePropertyName(t), (t.value = this.parseMethod(!1));
  var e = t.kind === "get" ? 0 : 1;
  if (t.value.params.length !== e) {
    var n = t.value.start;
    t.kind === "get"
      ? this.raiseRecoverable(n, "getter should have no params")
      : this.raiseRecoverable(n, "setter should have exactly one param");
  } else
    t.kind === "set" &&
      t.value.params[0].type === "RestElement" &&
      this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params");
};
Ne.parsePropertyValue = function (t, e, n, r, i, s, o, a) {
  (n || r) && this.type === A.colon && this.unexpected(),
    this.eat(A.colon)
      ? ((t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, o)), (t.kind = "init"))
      : this.options.ecmaVersion >= 6 && this.type === A.parenL
      ? (e && this.unexpected(), (t.kind = "init"), (t.method = !0), (t.value = this.parseMethod(n, r)))
      : !e &&
        !a &&
        this.options.ecmaVersion >= 5 &&
        !t.computed &&
        t.key.type === "Identifier" &&
        (t.key.name === "get" || t.key.name === "set") &&
        this.type !== A.comma &&
        this.type !== A.braceR &&
        this.type !== A.eq
      ? ((n || r) && this.unexpected(), this.parseGetterSetter(t))
      : this.options.ecmaVersion >= 6 && !t.computed && t.key.type === "Identifier"
      ? ((n || r) && this.unexpected(),
        this.checkUnreserved(t.key),
        t.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = i),
        (t.kind = "init"),
        e
          ? (t.value = this.parseMaybeDefault(i, s, this.copyNode(t.key)))
          : this.type === A.eq && o
          ? (o.shorthandAssign < 0 && (o.shorthandAssign = this.start), (t.value = this.parseMaybeDefault(i, s, this.copyNode(t.key))))
          : (t.value = this.copyNode(t.key)),
        (t.shorthand = !0))
      : this.unexpected();
};
Ne.parsePropertyName = function (t) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(A.bracketL)) return (t.computed = !0), (t.key = this.parseMaybeAssign()), this.expect(A.bracketR), t.key;
    t.computed = !1;
  }
  return (t.key =
    this.type === A.num || this.type === A.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"));
};
Ne.initFunction = function (t) {
  (t.id = null), this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1);
};
Ne.parseMethod = function (t, e, n) {
  var r = this.startNode(),
    i = this.yieldPos,
    s = this.awaitPos,
    o = this.awaitIdentPos;
  return (
    this.initFunction(r),
    this.options.ecmaVersion >= 6 && (r.generator = t),
    this.options.ecmaVersion >= 8 && (r.async = !!e),
    (this.yieldPos = 0),
    (this.awaitPos = 0),
    (this.awaitIdentPos = 0),
    this.enterScope(Ow(e, r.generator) | mw | (n ? A7 : 0)),
    this.expect(A.parenL),
    (r.params = this.parseBindingList(A.parenR, !1, this.options.ecmaVersion >= 8)),
    this.checkYieldAwaitInDefaultParams(),
    this.parseFunctionBody(r, !1, !0, !1),
    (this.yieldPos = i),
    (this.awaitPos = s),
    (this.awaitIdentPos = o),
    this.finishNode(r, "FunctionExpression")
  );
};
Ne.parseArrowExpression = function (t, e, n, r) {
  var i = this.yieldPos,
    s = this.awaitPos,
    o = this.awaitIdentPos;
  return (
    this.enterScope(Ow(n, !1) | T7),
    this.initFunction(t),
    this.options.ecmaVersion >= 8 && (t.async = !!n),
    (this.yieldPos = 0),
    (this.awaitPos = 0),
    (this.awaitIdentPos = 0),
    (t.params = this.toAssignableList(e, !0)),
    this.parseFunctionBody(t, !0, !1, r),
    (this.yieldPos = i),
    (this.awaitPos = s),
    (this.awaitIdentPos = o),
    this.finishNode(t, "ArrowFunctionExpression")
  );
};
Ne.parseFunctionBody = function (t, e, n, r) {
  var i = e && this.type !== A.braceL,
    s = this.strict,
    o = !1;
  if (i) (t.body = this.parseMaybeAssign(r)), (t.expression = !0), this.checkParams(t, !1);
  else {
    var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);
    (!s || a) &&
      ((o = this.strictDirective(this.end)),
      o && a && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var l = this.labels;
    (this.labels = []),
      o && (this.strict = !0),
      this.checkParams(t, !s && !o && !e && !n && this.isSimpleParamList(t.params)),
      this.strict && t.id && this.checkLValSimple(t.id, I7),
      (t.body = this.parseBlock(!1, void 0, o && !s)),
      (t.expression = !1),
      this.adaptDirectivePrologue(t.body.body),
      (this.labels = l);
  }
  this.exitScope();
};
Ne.isSimpleParamList = function (t) {
  for (var e = 0, n = t; e < n.length; e += 1) {
    var r = n[e];
    if (r.type !== "Identifier") return !1;
  }
  return !0;
};
Ne.checkParams = function (t, e) {
  for (var n = Object.create(null), r = 0, i = t.params; r < i.length; r += 1) {
    var s = i[r];
    this.checkLValInnerPattern(s, vw, e ? null : n);
  }
};
Ne.parseExprList = function (t, e, n, r) {
  for (var i = [], s = !0; !this.eat(t); ) {
    if (s) s = !1;
    else if ((this.expect(A.comma), e && this.afterTrailingComma(t))) break;
    var o = void 0;
    n && this.type === A.comma
      ? (o = null)
      : this.type === A.ellipsis
      ? ((o = this.parseSpread(r)), r && this.type === A.comma && r.trailingComma < 0 && (r.trailingComma = this.start))
      : (o = this.parseMaybeAssign(!1, r)),
      i.push(o);
  }
  return i;
};
Ne.checkUnreserved = function (t) {
  var e = t.start,
    n = t.end,
    r = t.name;
  if (
    (this.inGenerator && r === "yield" && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"),
    this.inAsync && r === "await" && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"),
    this.currentThisScope().inClassFieldInit &&
      r === "arguments" &&
      this.raiseRecoverable(e, "Cannot use 'arguments' in class field initializer"),
    this.inClassStaticBlock &&
      (r === "arguments" || r === "await") &&
      this.raise(e, "Cannot use " + r + " in class static initialization block"),
    this.keywords.test(r) && this.raise(e, "Unexpected keyword '" + r + "'"),
    !(this.options.ecmaVersion < 6 && this.input.slice(e, n).indexOf("\\") !== -1))
  ) {
    var i = this.strict ? this.reservedWordsStrict : this.reservedWords;
    i.test(r) &&
      (!this.inAsync && r === "await" && this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"),
      this.raiseRecoverable(e, "The keyword '" + r + "' is reserved"));
  }
};
Ne.parseIdent = function (t) {
  var e = this.parseIdentNode();
  return (
    this.next(!!t),
    this.finishNode(e, "Identifier"),
    t || (this.checkUnreserved(e), e.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = e.start)),
    e
  );
};
Ne.parseIdentNode = function () {
  var t = this.startNode();
  return (
    this.type === A.name
      ? (t.name = this.value)
      : this.type.keyword
      ? ((t.name = this.type.keyword),
        (t.name === "class" || t.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) &&
          this.context.pop(),
        (this.type = A.name))
      : this.unexpected(),
    t
  );
};
Ne.parsePrivateIdent = function () {
  var t = this.startNode();
  return (
    this.type === A.privateId ? (t.name = this.value) : this.unexpected(),
    this.next(),
    this.finishNode(t, "PrivateIdentifier"),
    this.options.checkPrivateFields &&
      (this.privateNameStack.length === 0
        ? this.raise(t.start, "Private field '#" + t.name + "' must be declared in an enclosing class")
        : this.privateNameStack[this.privateNameStack.length - 1].used.push(t)),
    t
  );
};
Ne.parseYield = function (t) {
  this.yieldPos || (this.yieldPos = this.start);
  var e = this.startNode();
  return (
    this.next(),
    this.type === A.semi || this.canInsertSemicolon() || (this.type !== A.star && !this.type.startsExpr)
      ? ((e.delegate = !1), (e.argument = null))
      : ((e.delegate = this.eat(A.star)), (e.argument = this.parseMaybeAssign(t))),
    this.finishNode(e, "YieldExpression")
  );
};
Ne.parseAwait = function (t) {
  this.awaitPos || (this.awaitPos = this.start);
  var e = this.startNode();
  return this.next(), (e.argument = this.parseMaybeUnary(null, !0, !1, t)), this.finishNode(e, "AwaitExpression");
};
var Rp = Mt.prototype;
Rp.raise = function (t, e) {
  var n = dw(this.input, t);
  e += " (" + n.line + ":" + n.column + ")";
  var r = new SyntaxError(e);
  throw ((r.pos = t), (r.loc = n), (r.raisedAt = this.pos), r);
};
Rp.raiseRecoverable = Rp.raise;
Rp.curPosition = function () {
  if (this.options.locations) return new yl(this.curLine, this.pos - this.lineStart);
};
var Oo = Mt.prototype,
  Ite = function (e) {
    (this.flags = e), (this.var = []), (this.lexical = []), (this.functions = []), (this.inClassFieldInit = !1);
  };
Oo.enterScope = function (t) {
  this.scopeStack.push(new Ite(t));
};
Oo.exitScope = function () {
  this.scopeStack.pop();
};
Oo.treatFunctionsAsVarInScope = function (t) {
  return t.flags & tc || (!this.inModule && t.flags & Qu);
};
Oo.declareName = function (t, e, n) {
  var r = !1;
  if (e === xs) {
    var i = this.currentScope();
    (r = i.lexical.indexOf(t) > -1 || i.functions.indexOf(t) > -1 || i.var.indexOf(t) > -1),
      i.lexical.push(t),
      this.inModule && i.flags & Qu && delete this.undefinedExports[t];
  } else if (e === R7) {
    var s = this.currentScope();
    s.lexical.push(t);
  } else if (e === $7) {
    var o = this.currentScope();
    this.treatFunctionsAsVar ? (r = o.lexical.indexOf(t) > -1) : (r = o.lexical.indexOf(t) > -1 || o.var.indexOf(t) > -1),
      o.functions.push(t);
  } else
    for (var a = this.scopeStack.length - 1; a >= 0; --a) {
      var l = this.scopeStack[a];
      if (
        (l.lexical.indexOf(t) > -1 && !(l.flags & P7 && l.lexical[0] === t)) ||
        (!this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(t) > -1)
      ) {
        r = !0;
        break;
      }
      if ((l.var.push(t), this.inModule && l.flags & Qu && delete this.undefinedExports[t], l.flags & gw)) break;
    }
  r && this.raiseRecoverable(n, "Identifier '" + t + "' has already been declared");
};
Oo.checkLocalExport = function (t) {
  this.scopeStack[0].lexical.indexOf(t.name) === -1 && this.scopeStack[0].var.indexOf(t.name) === -1 && (this.undefinedExports[t.name] = t);
};
Oo.currentScope = function () {
  return this.scopeStack[this.scopeStack.length - 1];
};
Oo.currentVarScope = function () {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & gw) return e;
  }
};
Oo.currentThisScope = function () {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & gw && !(e.flags & T7)) return e;
  }
};
var Xh = function (e, n, r) {
    (this.type = ""),
      (this.start = n),
      (this.end = 0),
      e.options.locations && (this.loc = new Wh(e, r)),
      e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile),
      e.options.ranges && (this.range = [n, 0]);
  },
  Hh = Mt.prototype;
Hh.startNode = function () {
  return new Xh(this, this.start, this.startLoc);
};
Hh.startNodeAt = function (t, e) {
  return new Xh(this, t, e);
};
function M7(t, e, n, r) {
  return (t.type = e), (t.end = n), this.options.locations && (t.loc.end = r), this.options.ranges && (t.range[1] = n), t;
}
Hh.finishNode = function (t, e) {
  return M7.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc);
};
Hh.finishNodeAt = function (t, e, n, r) {
  return M7.call(this, t, e, n, r);
};
Hh.copyNode = function (t) {
  var e = new Xh(this, t.start, this.startLoc);
  for (var n in t) e[n] = t[n];
  return e;
};
var D7 =
    "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",
  Q7 = D7 + " Extended_Pictographic",
  F7 = Q7,
  V7 = F7 + " EBase EComp EMod EPres ExtPict",
  B7 = V7,
  Nte = B7,
  Lte = { 9: D7, 10: Q7, 11: F7, 12: V7, 13: B7, 14: Nte },
  Mte =
    "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji",
  Dte = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: Mte },
  p_ =
    "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",
  j7 =
    "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",
  Z7 = j7 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",
  z7 = Z7 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",
  W7 = z7 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",
  U7 = W7 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",
  Qte = U7 + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz",
  Fte = { 9: j7, 10: Z7, 11: z7, 12: W7, 13: U7, 14: Qte },
  X7 = {};
function Vte(t) {
  var e = (X7[t] = {
    binary: Qs(Lte[t] + " " + p_),
    binaryOfStrings: Qs(Dte[t]),
    nonBinary: { General_Category: Qs(p_), Script: Qs(Fte[t]) },
  });
  (e.nonBinary.Script_Extensions = e.nonBinary.Script),
    (e.nonBinary.gc = e.nonBinary.General_Category),
    (e.nonBinary.sc = e.nonBinary.Script),
    (e.nonBinary.scx = e.nonBinary.Script_Extensions);
}
for (var N0 = 0, m_ = [9, 10, 11, 12, 13, 14]; N0 < m_.length; N0 += 1) {
  var Bte = m_[N0];
  Vte(Bte);
}
var ke = Mt.prototype,
  Fi = function (e) {
    (this.parser = e),
      (this.validFlags =
        "gim" +
        (e.options.ecmaVersion >= 6 ? "uy" : "") +
        (e.options.ecmaVersion >= 9 ? "s" : "") +
        (e.options.ecmaVersion >= 13 ? "d" : "") +
        (e.options.ecmaVersion >= 15 ? "v" : "")),
      (this.unicodeProperties = X7[e.options.ecmaVersion >= 14 ? 14 : e.options.ecmaVersion]),
      (this.source = ""),
      (this.flags = ""),
      (this.start = 0),
      (this.switchU = !1),
      (this.switchV = !1),
      (this.switchN = !1),
      (this.pos = 0),
      (this.lastIntValue = 0),
      (this.lastStringValue = ""),
      (this.lastAssertionIsQuantifiable = !1),
      (this.numCapturingParens = 0),
      (this.maxBackReference = 0),
      (this.groupNames = []),
      (this.backReferenceNames = []);
  };
Fi.prototype.reset = function (e, n, r) {
  var i = r.indexOf("v") !== -1,
    s = r.indexOf("u") !== -1;
  (this.start = e | 0),
    (this.source = n + ""),
    (this.flags = r),
    i && this.parser.options.ecmaVersion >= 15
      ? ((this.switchU = !0), (this.switchV = !0), (this.switchN = !0))
      : ((this.switchU = s && this.parser.options.ecmaVersion >= 6),
        (this.switchV = !1),
        (this.switchN = s && this.parser.options.ecmaVersion >= 9));
};
Fi.prototype.raise = function (e) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e);
};
Fi.prototype.at = function (e, n) {
  n === void 0 && (n = !1);
  var r = this.source,
    i = r.length;
  if (e >= i) return -1;
  var s = r.charCodeAt(e);
  if (!(n || this.switchU) || s <= 55295 || s >= 57344 || e + 1 >= i) return s;
  var o = r.charCodeAt(e + 1);
  return o >= 56320 && o <= 57343 ? (s << 10) + o - 56613888 : s;
};
Fi.prototype.nextIndex = function (e, n) {
  n === void 0 && (n = !1);
  var r = this.source,
    i = r.length;
  if (e >= i) return i;
  var s = r.charCodeAt(e),
    o;
  return !(n || this.switchU) || s <= 55295 || s >= 57344 || e + 1 >= i || (o = r.charCodeAt(e + 1)) < 56320 || o > 57343 ? e + 1 : e + 2;
};
Fi.prototype.current = function (e) {
  return e === void 0 && (e = !1), this.at(this.pos, e);
};
Fi.prototype.lookahead = function (e) {
  return e === void 0 && (e = !1), this.at(this.nextIndex(this.pos, e), e);
};
Fi.prototype.advance = function (e) {
  e === void 0 && (e = !1), (this.pos = this.nextIndex(this.pos, e));
};
Fi.prototype.eat = function (e, n) {
  return n === void 0 && (n = !1), this.current(n) === e ? (this.advance(n), !0) : !1;
};
Fi.prototype.eatChars = function (e, n) {
  n === void 0 && (n = !1);
  for (var r = this.pos, i = 0, s = e; i < s.length; i += 1) {
    var o = s[i],
      a = this.at(r, n);
    if (a === -1 || a !== o) return !1;
    r = this.nextIndex(r, n);
  }
  return (this.pos = r), !0;
};
ke.validateRegExpFlags = function (t) {
  for (var e = t.validFlags, n = t.flags, r = !1, i = !1, s = 0; s < n.length; s++) {
    var o = n.charAt(s);
    e.indexOf(o) === -1 && this.raise(t.start, "Invalid regular expression flag"),
      n.indexOf(o, s + 1) > -1 && this.raise(t.start, "Duplicate regular expression flag"),
      o === "u" && (r = !0),
      o === "v" && (i = !0);
  }
  this.options.ecmaVersion >= 15 && r && i && this.raise(t.start, "Invalid regular expression flag");
};
ke.validateRegExpPattern = function (t) {
  this.regexp_pattern(t),
    !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && ((t.switchN = !0), this.regexp_pattern(t));
};
ke.regexp_pattern = function (t) {
  (t.pos = 0),
    (t.lastIntValue = 0),
    (t.lastStringValue = ""),
    (t.lastAssertionIsQuantifiable = !1),
    (t.numCapturingParens = 0),
    (t.maxBackReference = 0),
    (t.groupNames.length = 0),
    (t.backReferenceNames.length = 0),
    this.regexp_disjunction(t),
    t.pos !== t.source.length && (t.eat(41) && t.raise("Unmatched ')'"), (t.eat(93) || t.eat(125)) && t.raise("Lone quantifier brackets")),
    t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape");
  for (var e = 0, n = t.backReferenceNames; e < n.length; e += 1) {
    var r = n[e];
    t.groupNames.indexOf(r) === -1 && t.raise("Invalid named capture referenced");
  }
};
ke.regexp_disjunction = function (t) {
  for (this.regexp_alternative(t); t.eat(124); ) this.regexp_alternative(t);
  this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"), t.eat(123) && t.raise("Lone quantifier brackets");
};
ke.regexp_alternative = function (t) {
  for (; t.pos < t.source.length && this.regexp_eatTerm(t); );
};
ke.regexp_eatTerm = function (t) {
  return this.regexp_eatAssertion(t)
    ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise("Invalid quantifier"), !0)
    : (t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t))
    ? (this.regexp_eatQuantifier(t), !0)
    : !1;
};
ke.regexp_eatAssertion = function (t) {
  var e = t.pos;
  if (((t.lastAssertionIsQuantifiable = !1), t.eat(94) || t.eat(36))) return !0;
  if (t.eat(92)) {
    if (t.eat(66) || t.eat(98)) return !0;
    t.pos = e;
  }
  if (t.eat(40) && t.eat(63)) {
    var n = !1;
    if ((this.options.ecmaVersion >= 9 && (n = t.eat(60)), t.eat(61) || t.eat(33)))
      return this.regexp_disjunction(t), t.eat(41) || t.raise("Unterminated group"), (t.lastAssertionIsQuantifiable = !n), !0;
  }
  return (t.pos = e), !1;
};
ke.regexp_eatQuantifier = function (t, e) {
  return e === void 0 && (e = !1), this.regexp_eatQuantifierPrefix(t, e) ? (t.eat(63), !0) : !1;
};
ke.regexp_eatQuantifierPrefix = function (t, e) {
  return t.eat(42) || t.eat(43) || t.eat(63) || this.regexp_eatBracedQuantifier(t, e);
};
ke.regexp_eatBracedQuantifier = function (t, e) {
  var n = t.pos;
  if (t.eat(123)) {
    var r = 0,
      i = -1;
    if (
      this.regexp_eatDecimalDigits(t) &&
      ((r = t.lastIntValue), t.eat(44) && this.regexp_eatDecimalDigits(t) && (i = t.lastIntValue), t.eat(125))
    )
      return i !== -1 && i < r && !e && t.raise("numbers out of order in {} quantifier"), !0;
    t.switchU && !e && t.raise("Incomplete quantifier"), (t.pos = n);
  }
  return !1;
};
ke.regexp_eatAtom = function (t) {
  return (
    this.regexp_eatPatternCharacters(t) ||
    t.eat(46) ||
    this.regexp_eatReverseSolidusAtomEscape(t) ||
    this.regexp_eatCharacterClass(t) ||
    this.regexp_eatUncapturingGroup(t) ||
    this.regexp_eatCapturingGroup(t)
  );
};
ke.regexp_eatReverseSolidusAtomEscape = function (t) {
  var e = t.pos;
  if (t.eat(92)) {
    if (this.regexp_eatAtomEscape(t)) return !0;
    t.pos = e;
  }
  return !1;
};
ke.regexp_eatUncapturingGroup = function (t) {
  var e = t.pos;
  if (t.eat(40)) {
    if (t.eat(63) && t.eat(58)) {
      if ((this.regexp_disjunction(t), t.eat(41))) return !0;
      t.raise("Unterminated group");
    }
    t.pos = e;
  }
  return !1;
};
ke.regexp_eatCapturingGroup = function (t) {
  if (t.eat(40)) {
    if (
      (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : t.current() === 63 && t.raise("Invalid group"),
      this.regexp_disjunction(t),
      t.eat(41))
    )
      return (t.numCapturingParens += 1), !0;
    t.raise("Unterminated group");
  }
  return !1;
};
ke.regexp_eatExtendedAtom = function (t) {
  return (
    t.eat(46) ||
    this.regexp_eatReverseSolidusAtomEscape(t) ||
    this.regexp_eatCharacterClass(t) ||
    this.regexp_eatUncapturingGroup(t) ||
    this.regexp_eatCapturingGroup(t) ||
    this.regexp_eatInvalidBracedQuantifier(t) ||
    this.regexp_eatExtendedPatternCharacter(t)
  );
};
ke.regexp_eatInvalidBracedQuantifier = function (t) {
  return this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"), !1;
};
ke.regexp_eatSyntaxCharacter = function (t) {
  var e = t.current();
  return H7(e) ? ((t.lastIntValue = e), t.advance(), !0) : !1;
};
function H7(t) {
  return t === 36 || (t >= 40 && t <= 43) || t === 46 || t === 63 || (t >= 91 && t <= 94) || (t >= 123 && t <= 125);
}
ke.regexp_eatPatternCharacters = function (t) {
  for (var e = t.pos, n = 0; (n = t.current()) !== -1 && !H7(n); ) t.advance();
  return t.pos !== e;
};
ke.regexp_eatExtendedPatternCharacter = function (t) {
  var e = t.current();
  return e !== -1 && e !== 36 && !(e >= 40 && e <= 43) && e !== 46 && e !== 63 && e !== 91 && e !== 94 && e !== 124
    ? (t.advance(), !0)
    : !1;
};
ke.regexp_groupSpecifier = function (t) {
  if (t.eat(63)) {
    if (this.regexp_eatGroupName(t)) {
      t.groupNames.indexOf(t.lastStringValue) !== -1 && t.raise("Duplicate capture group name"), t.groupNames.push(t.lastStringValue);
      return;
    }
    t.raise("Invalid group");
  }
};
ke.regexp_eatGroupName = function (t) {
  if (((t.lastStringValue = ""), t.eat(60))) {
    if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62)) return !0;
    t.raise("Invalid capture group name");
  }
  return !1;
};
ke.regexp_eatRegExpIdentifierName = function (t) {
  if (((t.lastStringValue = ""), this.regexp_eatRegExpIdentifierStart(t))) {
    for (t.lastStringValue += ro(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t); ) t.lastStringValue += ro(t.lastIntValue);
    return !0;
  }
  return !1;
};
ke.regexp_eatRegExpIdentifierStart = function (t) {
  var e = t.pos,
    n = this.options.ecmaVersion >= 11,
    r = t.current(n);
  return (
    t.advance(n),
    r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t, n) && (r = t.lastIntValue),
    jte(r) ? ((t.lastIntValue = r), !0) : ((t.pos = e), !1)
  );
};
function jte(t) {
  return Ni(t, !0) || t === 36 || t === 95;
}
ke.regexp_eatRegExpIdentifierPart = function (t) {
  var e = t.pos,
    n = this.options.ecmaVersion >= 11,
    r = t.current(n);
  return (
    t.advance(n),
    r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t, n) && (r = t.lastIntValue),
    Zte(r) ? ((t.lastIntValue = r), !0) : ((t.pos = e), !1)
  );
};
function Zte(t) {
  return qo(t, !0) || t === 36 || t === 95 || t === 8204 || t === 8205;
}
ke.regexp_eatAtomEscape = function (t) {
  return this.regexp_eatBackReference(t) ||
    this.regexp_eatCharacterClassEscape(t) ||
    this.regexp_eatCharacterEscape(t) ||
    (t.switchN && this.regexp_eatKGroupName(t))
    ? !0
    : (t.switchU && (t.current() === 99 && t.raise("Invalid unicode escape"), t.raise("Invalid escape")), !1);
};
ke.regexp_eatBackReference = function (t) {
  var e = t.pos;
  if (this.regexp_eatDecimalEscape(t)) {
    var n = t.lastIntValue;
    if (t.switchU) return n > t.maxBackReference && (t.maxBackReference = n), !0;
    if (n <= t.numCapturingParens) return !0;
    t.pos = e;
  }
  return !1;
};
ke.regexp_eatKGroupName = function (t) {
  if (t.eat(107)) {
    if (this.regexp_eatGroupName(t)) return t.backReferenceNames.push(t.lastStringValue), !0;
    t.raise("Invalid named reference");
  }
  return !1;
};
ke.regexp_eatCharacterEscape = function (t) {
  return (
    this.regexp_eatControlEscape(t) ||
    this.regexp_eatCControlLetter(t) ||
    this.regexp_eatZero(t) ||
    this.regexp_eatHexEscapeSequence(t) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(t, !1) ||
    (!t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t)) ||
    this.regexp_eatIdentityEscape(t)
  );
};
ke.regexp_eatCControlLetter = function (t) {
  var e = t.pos;
  if (t.eat(99)) {
    if (this.regexp_eatControlLetter(t)) return !0;
    t.pos = e;
  }
  return !1;
};
ke.regexp_eatZero = function (t) {
  return t.current() === 48 && !mg(t.lookahead()) ? ((t.lastIntValue = 0), t.advance(), !0) : !1;
};
ke.regexp_eatControlEscape = function (t) {
  var e = t.current();
  return e === 116
    ? ((t.lastIntValue = 9), t.advance(), !0)
    : e === 110
    ? ((t.lastIntValue = 10), t.advance(), !0)
    : e === 118
    ? ((t.lastIntValue = 11), t.advance(), !0)
    : e === 102
    ? ((t.lastIntValue = 12), t.advance(), !0)
    : e === 114
    ? ((t.lastIntValue = 13), t.advance(), !0)
    : !1;
};
ke.regexp_eatControlLetter = function (t) {
  var e = t.current();
  return q7(e) ? ((t.lastIntValue = e % 32), t.advance(), !0) : !1;
};
function q7(t) {
  return (t >= 65 && t <= 90) || (t >= 97 && t <= 122);
}
ke.regexp_eatRegExpUnicodeEscapeSequence = function (t, e) {
  e === void 0 && (e = !1);
  var n = t.pos,
    r = e || t.switchU;
  if (t.eat(117)) {
    if (this.regexp_eatFixedHexDigits(t, 4)) {
      var i = t.lastIntValue;
      if (r && i >= 55296 && i <= 56319) {
        var s = t.pos;
        if (t.eat(92) && t.eat(117) && this.regexp_eatFixedHexDigits(t, 4)) {
          var o = t.lastIntValue;
          if (o >= 56320 && o <= 57343) return (t.lastIntValue = (i - 55296) * 1024 + (o - 56320) + 65536), !0;
        }
        (t.pos = s), (t.lastIntValue = i);
      }
      return !0;
    }
    if (r && t.eat(123) && this.regexp_eatHexDigits(t) && t.eat(125) && zte(t.lastIntValue)) return !0;
    r && t.raise("Invalid unicode escape"), (t.pos = n);
  }
  return !1;
};
function zte(t) {
  return t >= 0 && t <= 1114111;
}
ke.regexp_eatIdentityEscape = function (t) {
  if (t.switchU) return this.regexp_eatSyntaxCharacter(t) ? !0 : t.eat(47) ? ((t.lastIntValue = 47), !0) : !1;
  var e = t.current();
  return e !== 99 && (!t.switchN || e !== 107) ? ((t.lastIntValue = e), t.advance(), !0) : !1;
};
ke.regexp_eatDecimalEscape = function (t) {
  t.lastIntValue = 0;
  var e = t.current();
  if (e >= 49 && e <= 57) {
    do (t.lastIntValue = 10 * t.lastIntValue + (e - 48)), t.advance();
    while ((e = t.current()) >= 48 && e <= 57);
    return !0;
  }
  return !1;
};
var Y7 = 0,
  hs = 1,
  Tr = 2;
ke.regexp_eatCharacterClassEscape = function (t) {
  var e = t.current();
  if (Wte(e)) return (t.lastIntValue = -1), t.advance(), hs;
  var n = !1;
  if (t.switchU && this.options.ecmaVersion >= 9 && ((n = e === 80) || e === 112)) {
    (t.lastIntValue = -1), t.advance();
    var r;
    if (t.eat(123) && (r = this.regexp_eatUnicodePropertyValueExpression(t)) && t.eat(125))
      return n && r === Tr && t.raise("Invalid property name"), r;
    t.raise("Invalid property name");
  }
  return Y7;
};
function Wte(t) {
  return t === 100 || t === 68 || t === 115 || t === 83 || t === 119 || t === 87;
}
ke.regexp_eatUnicodePropertyValueExpression = function (t) {
  var e = t.pos;
  if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
    var n = t.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(t)) {
      var r = t.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(t, n, r), hs;
    }
  }
  if (((t.pos = e), this.regexp_eatLoneUnicodePropertyNameOrValue(t))) {
    var i = t.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(t, i);
  }
  return Y7;
};
ke.regexp_validateUnicodePropertyNameAndValue = function (t, e, n) {
  zh(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"),
    t.unicodeProperties.nonBinary[e].test(n) || t.raise("Invalid property value");
};
ke.regexp_validateUnicodePropertyNameOrValue = function (t, e) {
  if (t.unicodeProperties.binary.test(e)) return hs;
  if (t.switchV && t.unicodeProperties.binaryOfStrings.test(e)) return Tr;
  t.raise("Invalid property name");
};
ke.regexp_eatUnicodePropertyName = function (t) {
  var e = 0;
  for (t.lastStringValue = ""; G7((e = t.current())); ) (t.lastStringValue += ro(e)), t.advance();
  return t.lastStringValue !== "";
};
function G7(t) {
  return q7(t) || t === 95;
}
ke.regexp_eatUnicodePropertyValue = function (t) {
  var e = 0;
  for (t.lastStringValue = ""; Ute((e = t.current())); ) (t.lastStringValue += ro(e)), t.advance();
  return t.lastStringValue !== "";
};
function Ute(t) {
  return G7(t) || mg(t);
}
ke.regexp_eatLoneUnicodePropertyNameOrValue = function (t) {
  return this.regexp_eatUnicodePropertyValue(t);
};
ke.regexp_eatCharacterClass = function (t) {
  if (t.eat(91)) {
    var e = t.eat(94),
      n = this.regexp_classContents(t);
    return (
      t.eat(93) || t.raise("Unterminated character class"), e && n === Tr && t.raise("Negated character class may contain strings"), !0
    );
  }
  return !1;
};
ke.regexp_classContents = function (t) {
  return t.current() === 93 ? hs : t.switchV ? this.regexp_classSetExpression(t) : (this.regexp_nonEmptyClassRanges(t), hs);
};
ke.regexp_nonEmptyClassRanges = function (t) {
  for (; this.regexp_eatClassAtom(t); ) {
    var e = t.lastIntValue;
    if (t.eat(45) && this.regexp_eatClassAtom(t)) {
      var n = t.lastIntValue;
      t.switchU && (e === -1 || n === -1) && t.raise("Invalid character class"),
        e !== -1 && n !== -1 && e > n && t.raise("Range out of order in character class");
    }
  }
};
ke.regexp_eatClassAtom = function (t) {
  var e = t.pos;
  if (t.eat(92)) {
    if (this.regexp_eatClassEscape(t)) return !0;
    if (t.switchU) {
      var n = t.current();
      (n === 99 || e6(n)) && t.raise("Invalid class escape"), t.raise("Invalid escape");
    }
    t.pos = e;
  }
  var r = t.current();
  return r !== 93 ? ((t.lastIntValue = r), t.advance(), !0) : !1;
};
ke.regexp_eatClassEscape = function (t) {
  var e = t.pos;
  if (t.eat(98)) return (t.lastIntValue = 8), !0;
  if (t.switchU && t.eat(45)) return (t.lastIntValue = 45), !0;
  if (!t.switchU && t.eat(99)) {
    if (this.regexp_eatClassControlLetter(t)) return !0;
    t.pos = e;
  }
  return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t);
};
ke.regexp_classSetExpression = function (t) {
  var e = hs,
    n;
  if (!this.regexp_eatClassSetRange(t))
    if ((n = this.regexp_eatClassSetOperand(t))) {
      n === Tr && (e = Tr);
      for (var r = t.pos; t.eatChars([38, 38]); ) {
        if (t.current() !== 38 && (n = this.regexp_eatClassSetOperand(t))) {
          n !== Tr && (e = hs);
          continue;
        }
        t.raise("Invalid character in character class");
      }
      if (r !== t.pos) return e;
      for (; t.eatChars([45, 45]); ) this.regexp_eatClassSetOperand(t) || t.raise("Invalid character in character class");
      if (r !== t.pos) return e;
    } else t.raise("Invalid character in character class");
  for (;;)
    if (!this.regexp_eatClassSetRange(t)) {
      if (((n = this.regexp_eatClassSetOperand(t)), !n)) return e;
      n === Tr && (e = Tr);
    }
};
ke.regexp_eatClassSetRange = function (t) {
  var e = t.pos;
  if (this.regexp_eatClassSetCharacter(t)) {
    var n = t.lastIntValue;
    if (t.eat(45) && this.regexp_eatClassSetCharacter(t)) {
      var r = t.lastIntValue;
      return n !== -1 && r !== -1 && n > r && t.raise("Range out of order in character class"), !0;
    }
    t.pos = e;
  }
  return !1;
};
ke.regexp_eatClassSetOperand = function (t) {
  return this.regexp_eatClassSetCharacter(t) ? hs : this.regexp_eatClassStringDisjunction(t) || this.regexp_eatNestedClass(t);
};
ke.regexp_eatNestedClass = function (t) {
  var e = t.pos;
  if (t.eat(91)) {
    var n = t.eat(94),
      r = this.regexp_classContents(t);
    if (t.eat(93)) return n && r === Tr && t.raise("Negated character class may contain strings"), r;
    t.pos = e;
  }
  if (t.eat(92)) {
    var i = this.regexp_eatCharacterClassEscape(t);
    if (i) return i;
    t.pos = e;
  }
  return null;
};
ke.regexp_eatClassStringDisjunction = function (t) {
  var e = t.pos;
  if (t.eatChars([92, 113])) {
    if (t.eat(123)) {
      var n = this.regexp_classStringDisjunctionContents(t);
      if (t.eat(125)) return n;
    } else t.raise("Invalid escape");
    t.pos = e;
  }
  return null;
};
ke.regexp_classStringDisjunctionContents = function (t) {
  for (var e = this.regexp_classString(t); t.eat(124); ) this.regexp_classString(t) === Tr && (e = Tr);
  return e;
};
ke.regexp_classString = function (t) {
  for (var e = 0; this.regexp_eatClassSetCharacter(t); ) e++;
  return e === 1 ? hs : Tr;
};
ke.regexp_eatClassSetCharacter = function (t) {
  var e = t.pos;
  if (t.eat(92))
    return this.regexp_eatCharacterEscape(t) || this.regexp_eatClassSetReservedPunctuator(t)
      ? !0
      : t.eat(98)
      ? ((t.lastIntValue = 8), !0)
      : ((t.pos = e), !1);
  var n = t.current();
  return n < 0 || (n === t.lookahead() && Xte(n)) || Hte(n) ? !1 : (t.advance(), (t.lastIntValue = n), !0);
};
function Xte(t) {
  return t === 33 || (t >= 35 && t <= 38) || (t >= 42 && t <= 44) || t === 46 || (t >= 58 && t <= 64) || t === 94 || t === 96 || t === 126;
}
function Hte(t) {
  return t === 40 || t === 41 || t === 45 || t === 47 || (t >= 91 && t <= 93) || (t >= 123 && t <= 125);
}
ke.regexp_eatClassSetReservedPunctuator = function (t) {
  var e = t.current();
  return qte(e) ? ((t.lastIntValue = e), t.advance(), !0) : !1;
};
function qte(t) {
  return t === 33 || t === 35 || t === 37 || t === 38 || t === 44 || t === 45 || (t >= 58 && t <= 62) || t === 64 || t === 96 || t === 126;
}
ke.regexp_eatClassControlLetter = function (t) {
  var e = t.current();
  return mg(e) || e === 95 ? ((t.lastIntValue = e % 32), t.advance(), !0) : !1;
};
ke.regexp_eatHexEscapeSequence = function (t) {
  var e = t.pos;
  if (t.eat(120)) {
    if (this.regexp_eatFixedHexDigits(t, 2)) return !0;
    t.switchU && t.raise("Invalid escape"), (t.pos = e);
  }
  return !1;
};
ke.regexp_eatDecimalDigits = function (t) {
  var e = t.pos,
    n = 0;
  for (t.lastIntValue = 0; mg((n = t.current())); ) (t.lastIntValue = 10 * t.lastIntValue + (n - 48)), t.advance();
  return t.pos !== e;
};
function mg(t) {
  return t >= 48 && t <= 57;
}
ke.regexp_eatHexDigits = function (t) {
  var e = t.pos,
    n = 0;
  for (t.lastIntValue = 0; J7((n = t.current())); ) (t.lastIntValue = 16 * t.lastIntValue + K7(n)), t.advance();
  return t.pos !== e;
};
function J7(t) {
  return (t >= 48 && t <= 57) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102);
}
function K7(t) {
  return t >= 65 && t <= 70 ? 10 + (t - 65) : t >= 97 && t <= 102 ? 10 + (t - 97) : t - 48;
}
ke.regexp_eatLegacyOctalEscapeSequence = function (t) {
  if (this.regexp_eatOctalDigit(t)) {
    var e = t.lastIntValue;
    if (this.regexp_eatOctalDigit(t)) {
      var n = t.lastIntValue;
      e <= 3 && this.regexp_eatOctalDigit(t) ? (t.lastIntValue = e * 64 + n * 8 + t.lastIntValue) : (t.lastIntValue = e * 8 + n);
    } else t.lastIntValue = e;
    return !0;
  }
  return !1;
};
ke.regexp_eatOctalDigit = function (t) {
  var e = t.current();
  return e6(e) ? ((t.lastIntValue = e - 48), t.advance(), !0) : ((t.lastIntValue = 0), !1);
};
function e6(t) {
  return t >= 48 && t <= 55;
}
ke.regexp_eatFixedHexDigits = function (t, e) {
  var n = t.pos;
  t.lastIntValue = 0;
  for (var r = 0; r < e; ++r) {
    var i = t.current();
    if (!J7(i)) return (t.pos = n), !1;
    (t.lastIntValue = 16 * t.lastIntValue + K7(i)), t.advance();
  }
  return !0;
};
var gg = function (e) {
    (this.type = e.type),
      (this.value = e.value),
      (this.start = e.start),
      (this.end = e.end),
      e.options.locations && (this.loc = new Wh(e, e.startLoc, e.endLoc)),
      e.options.ranges && (this.range = [e.start, e.end]);
  },
  He = Mt.prototype;
He.next = function (t) {
  !t && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword),
    this.options.onToken && this.options.onToken(new gg(this)),
    (this.lastTokEnd = this.end),
    (this.lastTokStart = this.start),
    (this.lastTokEndLoc = this.endLoc),
    (this.lastTokStartLoc = this.startLoc),
    this.nextToken();
};
He.getToken = function () {
  return this.next(), new gg(this);
};
typeof Symbol < "u" &&
  (He[Symbol.iterator] = function () {
    var t = this;
    return {
      next: function () {
        var e = t.getToken();
        return { done: e.type === A.eof, value: e };
      },
    };
  });
He.nextToken = function () {
  var t = this.curContext();
  if (
    ((!t || !t.preserveSpace) && this.skipSpace(),
    (this.start = this.pos),
    this.options.locations && (this.startLoc = this.curPosition()),
    this.pos >= this.input.length)
  )
    return this.finishToken(A.eof);
  if (t.override) return t.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
He.readToken = function (t) {
  return Ni(t, this.options.ecmaVersion >= 6) || t === 92 ? this.readWord() : this.getTokenFromCode(t);
};
He.fullCharCodeAtPos = function () {
  var t = this.input.charCodeAt(this.pos);
  if (t <= 55295 || t >= 56320) return t;
  var e = this.input.charCodeAt(this.pos + 1);
  return e <= 56319 || e >= 57344 ? t : (t << 10) + e - 56613888;
};
He.skipBlockComment = function () {
  var t = this.options.onComment && this.curPosition(),
    e = this.pos,
    n = this.input.indexOf("*/", (this.pos += 2));
  if ((n === -1 && this.raise(this.pos - 2, "Unterminated comment"), (this.pos = n + 2), this.options.locations))
    for (var r = void 0, i = e; (r = C7(this.input, i, this.pos)) > -1; ) ++this.curLine, (i = this.lineStart = r);
  this.options.onComment && this.options.onComment(!0, this.input.slice(e + 2, n), e, this.pos, t, this.curPosition());
};
He.skipLineComment = function (t) {
  for (
    var e = this.pos, n = this.options.onComment && this.curPosition(), r = this.input.charCodeAt((this.pos += t));
    this.pos < this.input.length && !ma(r);

  )
    r = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, n, this.curPosition());
};
He.skipSpace = function () {
  e: for (; this.pos < this.input.length; ) {
    var t = this.input.charCodeAt(this.pos);
    switch (t) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
      case 10:
      case 8232:
      case 8233:
        ++this.pos, this.options.locations && (++this.curLine, (this.lineStart = this.pos));
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break e;
        }
        break;
      default:
        if ((t > 8 && t < 14) || (t >= 5760 && fw.test(String.fromCharCode(t)))) ++this.pos;
        else break e;
    }
  }
};
He.finishToken = function (t, e) {
  (this.end = this.pos), this.options.locations && (this.endLoc = this.curPosition());
  var n = this.type;
  (this.type = t), (this.value = e), this.updateContext(n);
};
He.readToken_dot = function () {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t >= 48 && t <= 57) return this.readNumber(!0);
  var e = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && t === 46 && e === 46
    ? ((this.pos += 3), this.finishToken(A.ellipsis))
    : (++this.pos, this.finishToken(A.dot));
};
He.readToken_slash = function () {
  var t = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : t === 61 ? this.finishOp(A.assign, 2) : this.finishOp(A.slash, 1);
};
He.readToken_mult_modulo_exp = function (t) {
  var e = this.input.charCodeAt(this.pos + 1),
    n = 1,
    r = t === 42 ? A.star : A.modulo;
  return (
    this.options.ecmaVersion >= 7 && t === 42 && e === 42 && (++n, (r = A.starstar), (e = this.input.charCodeAt(this.pos + 2))),
    e === 61 ? this.finishOp(A.assign, n + 1) : this.finishOp(r, n)
  );
};
He.readToken_pipe_amp = function (t) {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e === t) {
    if (this.options.ecmaVersion >= 12) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n === 61) return this.finishOp(A.assign, 3);
    }
    return this.finishOp(t === 124 ? A.logicalOR : A.logicalAND, 2);
  }
  return e === 61 ? this.finishOp(A.assign, 2) : this.finishOp(t === 124 ? A.bitwiseOR : A.bitwiseAND, 1);
};
He.readToken_caret = function () {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(A.assign, 2) : this.finishOp(A.bitwiseXOR, 1);
};
He.readToken_plus_min = function (t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === t
    ? e === 45 &&
      !this.inModule &&
      this.input.charCodeAt(this.pos + 2) === 62 &&
      (this.lastTokEnd === 0 || br.test(this.input.slice(this.lastTokEnd, this.pos)))
      ? (this.skipLineComment(3), this.skipSpace(), this.nextToken())
      : this.finishOp(A.incDec, 2)
    : e === 61
    ? this.finishOp(A.assign, 2)
    : this.finishOp(A.plusMin, 1);
};
He.readToken_lt_gt = function (t) {
  var e = this.input.charCodeAt(this.pos + 1),
    n = 1;
  return e === t
    ? ((n = t === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2),
      this.input.charCodeAt(this.pos + n) === 61 ? this.finishOp(A.assign, n + 1) : this.finishOp(A.bitShift, n))
    : e === 33 && t === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45
    ? (this.skipLineComment(4), this.skipSpace(), this.nextToken())
    : (e === 61 && (n = 2), this.finishOp(A.relational, n));
};
He.readToken_eq_excl = function (t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61
    ? this.finishOp(A.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
    : t === 61 && e === 62 && this.options.ecmaVersion >= 6
    ? ((this.pos += 2), this.finishToken(A.arrow))
    : this.finishOp(t === 61 ? A.eq : A.prefix, 1);
};
He.readToken_question = function () {
  var t = this.options.ecmaVersion;
  if (t >= 11) {
    var e = this.input.charCodeAt(this.pos + 1);
    if (e === 46) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n < 48 || n > 57) return this.finishOp(A.questionDot, 2);
    }
    if (e === 63) {
      if (t >= 12) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r === 61) return this.finishOp(A.assign, 3);
      }
      return this.finishOp(A.coalesce, 2);
    }
  }
  return this.finishOp(A.question, 1);
};
He.readToken_numberSign = function () {
  var t = this.options.ecmaVersion,
    e = 35;
  if (t >= 13 && (++this.pos, (e = this.fullCharCodeAtPos()), Ni(e, !0) || e === 92))
    return this.finishToken(A.privateId, this.readWord1());
  this.raise(this.pos, "Unexpected character '" + ro(e) + "'");
};
He.getTokenFromCode = function (t) {
  switch (t) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken(A.parenL);
    case 41:
      return ++this.pos, this.finishToken(A.parenR);
    case 59:
      return ++this.pos, this.finishToken(A.semi);
    case 44:
      return ++this.pos, this.finishToken(A.comma);
    case 91:
      return ++this.pos, this.finishToken(A.bracketL);
    case 93:
      return ++this.pos, this.finishToken(A.bracketR);
    case 123:
      return ++this.pos, this.finishToken(A.braceL);
    case 125:
      return ++this.pos, this.finishToken(A.braceR);
    case 58:
      return ++this.pos, this.finishToken(A.colon);
    case 96:
      if (this.options.ecmaVersion < 6) break;
      return ++this.pos, this.finishToken(A.backQuote);
    case 48:
      var e = this.input.charCodeAt(this.pos + 1);
      if (e === 120 || e === 88) return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (e === 111 || e === 79) return this.readRadixNumber(8);
        if (e === 98 || e === 66) return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    case 34:
    case 39:
      return this.readString(t);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(t);
    case 124:
    case 38:
      return this.readToken_pipe_amp(t);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(t);
    case 60:
    case 62:
      return this.readToken_lt_gt(t);
    case 61:
    case 33:
      return this.readToken_eq_excl(t);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(A.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + ro(t) + "'");
};
He.finishOp = function (t, e) {
  var n = this.input.slice(this.pos, this.pos + e);
  return (this.pos += e), this.finishToken(t, n);
};
He.readRegexp = function () {
  for (var t, e, n = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
    var r = this.input.charAt(this.pos);
    if ((br.test(r) && this.raise(n, "Unterminated regular expression"), t)) t = !1;
    else {
      if (r === "[") e = !0;
      else if (r === "]" && e) e = !1;
      else if (r === "/" && !e) break;
      t = r === "\\";
    }
    ++this.pos;
  }
  var i = this.input.slice(n, this.pos);
  ++this.pos;
  var s = this.pos,
    o = this.readWord1();
  this.containsEsc && this.unexpected(s);
  var a = this.regexpState || (this.regexpState = new Fi(this));
  a.reset(n, i, o), this.validateRegExpFlags(a), this.validateRegExpPattern(a);
  var l = null;
  try {
    l = new RegExp(i, o);
  } catch {}
  return this.finishToken(A.regexp, { pattern: i, flags: o, value: l });
};
He.readInt = function (t, e, n) {
  for (
    var r = this.options.ecmaVersion >= 12 && e === void 0,
      i = n && this.input.charCodeAt(this.pos) === 48,
      s = this.pos,
      o = 0,
      a = 0,
      l = 0,
      c = e ?? 1 / 0;
    l < c;
    ++l, ++this.pos
  ) {
    var u = this.input.charCodeAt(this.pos),
      h = void 0;
    if (r && u === 95) {
      i && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"),
        a === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"),
        l === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"),
        (a = u);
      continue;
    }
    if ((u >= 97 ? (h = u - 97 + 10) : u >= 65 ? (h = u - 65 + 10) : u >= 48 && u <= 57 ? (h = u - 48) : (h = 1 / 0), h >= t)) break;
    (a = u), (o = o * t + h);
  }
  return (
    r && a === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"),
    this.pos === s || (e != null && this.pos - s !== e) ? null : o
  );
};
function Yte(t, e) {
  return e ? parseInt(t, 8) : parseFloat(t.replace(/_/g, ""));
}
function t6(t) {
  return typeof BigInt != "function" ? null : BigInt(t.replace(/_/g, ""));
}
He.readRadixNumber = function (t) {
  var e = this.pos;
  this.pos += 2;
  var n = this.readInt(t);
  return (
    n == null && this.raise(this.start + 2, "Expected number in radix " + t),
    this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110
      ? ((n = t6(this.input.slice(e, this.pos))), ++this.pos)
      : Ni(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"),
    this.finishToken(A.num, n)
  );
};
He.readNumber = function (t) {
  var e = this.pos;
  !t && this.readInt(10, void 0, !0) === null && this.raise(e, "Invalid number");
  var n = this.pos - e >= 2 && this.input.charCodeAt(e) === 48;
  n && this.strict && this.raise(e, "Invalid number");
  var r = this.input.charCodeAt(this.pos);
  if (!n && !t && this.options.ecmaVersion >= 11 && r === 110) {
    var i = t6(this.input.slice(e, this.pos));
    return ++this.pos, Ni(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(A.num, i);
  }
  n && /[89]/.test(this.input.slice(e, this.pos)) && (n = !1),
    r === 46 && !n && (++this.pos, this.readInt(10), (r = this.input.charCodeAt(this.pos))),
    (r === 69 || r === 101) &&
      !n &&
      ((r = this.input.charCodeAt(++this.pos)),
      (r === 43 || r === 45) && ++this.pos,
      this.readInt(10) === null && this.raise(e, "Invalid number")),
    Ni(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = Yte(this.input.slice(e, this.pos), n);
  return this.finishToken(A.num, s);
};
He.readCodePoint = function () {
  var t = this.input.charCodeAt(this.pos),
    e;
  if (t === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var n = ++this.pos;
    (e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos)),
      ++this.pos,
      e > 1114111 && this.invalidStringToken(n, "Code point out of bounds");
  } else e = this.readHexChar(4);
  return e;
};
He.readString = function (t) {
  for (var e = "", n = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var r = this.input.charCodeAt(this.pos);
    if (r === t) break;
    r === 92
      ? ((e += this.input.slice(n, this.pos)), (e += this.readEscapedChar(!1)), (n = this.pos))
      : r === 8232 || r === 8233
      ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"),
        ++this.pos,
        this.options.locations && (this.curLine++, (this.lineStart = this.pos)))
      : (ma(r) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return (e += this.input.slice(n, this.pos++)), this.finishToken(A.string, e);
};
var n6 = {};
He.tryReadTemplateToken = function () {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (t) {
    if (t === n6) this.readInvalidTemplateToken();
    else throw t;
  }
  this.inTemplateElement = !1;
};
He.invalidStringToken = function (t, e) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw n6;
  this.raise(t, e);
};
He.readTmplToken = function () {
  for (var t = "", e = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var n = this.input.charCodeAt(this.pos);
    if (n === 96 || (n === 36 && this.input.charCodeAt(this.pos + 1) === 123))
      return this.pos === this.start && (this.type === A.template || this.type === A.invalidTemplate)
        ? n === 36
          ? ((this.pos += 2), this.finishToken(A.dollarBraceL))
          : (++this.pos, this.finishToken(A.backQuote))
        : ((t += this.input.slice(e, this.pos)), this.finishToken(A.template, t));
    if (n === 92) (t += this.input.slice(e, this.pos)), (t += this.readEscapedChar(!0)), (e = this.pos);
    else if (ma(n)) {
      switch (((t += this.input.slice(e, this.pos)), ++this.pos, n)) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          t += `
`;
          break;
        default:
          t += String.fromCharCode(n);
          break;
      }
      this.options.locations && (++this.curLine, (this.lineStart = this.pos)), (e = this.pos);
    } else ++this.pos;
  }
};
He.readInvalidTemplateToken = function () {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") break;
      case "`":
        return this.finishToken(A.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
He.readEscapedChar = function (t) {
  var e = this.input.charCodeAt(++this.pos);
  switch ((++this.pos, e)) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return ro(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && ((this.lineStart = this.pos), ++this.curLine), "";
    case 56:
    case 57:
      if ((this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), t)) {
        var n = this.pos - 1;
        this.invalidStringToken(n, "Invalid escape sequence in template string");
      }
    default:
      if (e >= 48 && e <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
          i = parseInt(r, 8);
        return (
          i > 255 && ((r = r.slice(0, -1)), (i = parseInt(r, 8))),
          (this.pos += r.length - 1),
          (e = this.input.charCodeAt(this.pos)),
          (r !== "0" || e === 56 || e === 57) &&
            (this.strict || t) &&
            this.invalidStringToken(this.pos - 1 - r.length, t ? "Octal literal in template string" : "Octal literal in strict mode"),
          String.fromCharCode(i)
        );
      }
      return ma(e) ? "" : String.fromCharCode(e);
  }
};
He.readHexChar = function (t) {
  var e = this.pos,
    n = this.readInt(16, t);
  return n === null && this.invalidStringToken(e, "Bad character escape sequence"), n;
};
He.readWord1 = function () {
  this.containsEsc = !1;
  for (var t = "", e = !0, n = this.pos, r = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var i = this.fullCharCodeAtPos();
    if (qo(i, r)) this.pos += i <= 65535 ? 1 : 2;
    else if (i === 92) {
      (this.containsEsc = !0), (t += this.input.slice(n, this.pos));
      var s = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"),
        ++this.pos;
      var o = this.readCodePoint();
      (e ? Ni : qo)(o, r) || this.invalidStringToken(s, "Invalid Unicode escape"), (t += ro(o)), (n = this.pos);
    } else break;
    e = !1;
  }
  return t + this.input.slice(n, this.pos);
};
He.readWord = function () {
  var t = this.readWord1(),
    e = A.name;
  return this.keywords.test(t) && (e = dg[t]), this.finishToken(e, t);
};
var r6 = "8.11.3";
Mt.acorn = {
  Parser: Mt,
  version: r6,
  defaultOptions: Pp,
  Position: yl,
  SourceLocation: Wh,
  getLineInfo: dw,
  Node: Xh,
  TokenType: Je,
  tokTypes: A,
  keywordTypes: dg,
  TokContext: kr,
  tokContexts: Tt,
  isIdentifierChar: qo,
  isIdentifierStart: Ni,
  Token: gg,
  isNewLine: ma,
  lineBreak: br,
  lineBreakG: k7,
  nonASCIIwhitespace: fw,
};
function Gte(t, e) {
  return Mt.parse(t, e);
}
function Jte(t, e, n) {
  return Mt.parseExpressionAt(t, e, n);
}
function Kte(t, e) {
  return Mt.tokenizer(t, e);
}
const ene = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      Node: Xh,
      Parser: Mt,
      Position: yl,
      SourceLocation: Wh,
      TokContext: kr,
      Token: gg,
      TokenType: Je,
      defaultOptions: Pp,
      getLineInfo: dw,
      isIdentifierChar: qo,
      isIdentifierStart: Ni,
      isNewLine: ma,
      keywordTypes: dg,
      lineBreak: br,
      lineBreakG: k7,
      nonASCIIwhitespace: fw,
      parse: Gte,
      parseExpressionAt: Jte,
      tokContexts: Tt,
      tokTypes: A,
      tokenizer: Kte,
      version: r6,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var i6 = { exports: {} },
  tne = {
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦",
  };
const g_ = HM(ene);
(function (t) {
  const e = tne,
    n = /^[\da-fA-F]+$/,
    r = /^\d+$/,
    i = new WeakMap();
  function s(l) {
    l = l.Parser.acorn || l;
    let c = i.get(l);
    if (!c) {
      const u = l.tokTypes,
        h = l.TokContext,
        f = l.TokenType,
        d = new h("<tag", !1),
        p = new h("</tag", !1),
        m = new h("<tag>...</tag>", !0, !0),
        O = { tc_oTag: d, tc_cTag: p, tc_expr: m },
        v = {
          jsxName: new f("jsxName"),
          jsxText: new f("jsxText", { beforeExpr: !0 }),
          jsxTagStart: new f("jsxTagStart", { startsExpr: !0 }),
          jsxTagEnd: new f("jsxTagEnd"),
        };
      (v.jsxTagStart.updateContext = function () {
        this.context.push(m), this.context.push(d), (this.exprAllowed = !1);
      }),
        (v.jsxTagEnd.updateContext = function (g) {
          let x = this.context.pop();
          (x === d && g === u.slash) || x === p
            ? (this.context.pop(), (this.exprAllowed = this.curContext() === m))
            : (this.exprAllowed = !0);
        }),
        (c = { tokContexts: O, tokTypes: v }),
        i.set(l, c);
    }
    return c;
  }
  function o(l) {
    if (!l) return l;
    if (l.type === "JSXIdentifier") return l.name;
    if (l.type === "JSXNamespacedName") return l.namespace.name + ":" + l.name.name;
    if (l.type === "JSXMemberExpression") return o(l.object) + "." + o(l.property);
  }
  (t.exports = function (l) {
    return (
      (l = l || {}),
      function (c) {
        return a({ allowNamespaces: l.allowNamespaces !== !1, allowNamespacedObjects: !!l.allowNamespacedObjects }, c);
      }
    );
  }),
    Object.defineProperty(t.exports, "tokTypes", {
      get: function () {
        return s(g_).tokTypes;
      },
      configurable: !0,
      enumerable: !0,
    });
  function a(l, c) {
    const u = c.acorn || g_,
      h = s(u),
      f = u.tokTypes,
      d = h.tokTypes,
      p = u.tokContexts,
      m = h.tokContexts.tc_oTag,
      O = h.tokContexts.tc_cTag,
      v = h.tokContexts.tc_expr,
      g = u.isNewLine,
      x = u.isIdentifierStart,
      y = u.isIdentifierChar;
    return class extends c {
      static get acornJsx() {
        return h;
      }
      jsx_readToken() {
        let S = "",
          k = this.pos;
        for (;;) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
          let b = this.input.charCodeAt(this.pos);
          switch (b) {
            case 60:
            case 123:
              return this.pos === this.start
                ? b === 60 && this.exprAllowed
                  ? (++this.pos, this.finishToken(d.jsxTagStart))
                  : this.getTokenFromCode(b)
                : ((S += this.input.slice(k, this.pos)), this.finishToken(d.jsxText, S));
            case 38:
              (S += this.input.slice(k, this.pos)), (S += this.jsx_readEntity()), (k = this.pos);
              break;
            case 62:
            case 125:
              this.raise(
                this.pos,
                "Unexpected token `" +
                  this.input[this.pos] +
                  "`. Did you mean `" +
                  (b === 62 ? "&gt;" : "&rbrace;") +
                  '` or `{"' +
                  this.input[this.pos] +
                  '"}`?'
              );
            default:
              g(b) ? ((S += this.input.slice(k, this.pos)), (S += this.jsx_readNewLine(!0)), (k = this.pos)) : ++this.pos;
          }
        }
      }
      jsx_readNewLine(S) {
        let k = this.input.charCodeAt(this.pos),
          b;
        return (
          ++this.pos,
          k === 13 && this.input.charCodeAt(this.pos) === 10
            ? (++this.pos,
              (b = S
                ? `
`
                : `\r
`))
            : (b = String.fromCharCode(k)),
          this.options.locations && (++this.curLine, (this.lineStart = this.pos)),
          b
        );
      }
      jsx_readString(S) {
        let k = "",
          b = ++this.pos;
        for (;;) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          let _ = this.input.charCodeAt(this.pos);
          if (_ === S) break;
          _ === 38
            ? ((k += this.input.slice(b, this.pos)), (k += this.jsx_readEntity()), (b = this.pos))
            : g(_)
            ? ((k += this.input.slice(b, this.pos)), (k += this.jsx_readNewLine(!1)), (b = this.pos))
            : ++this.pos;
        }
        return (k += this.input.slice(b, this.pos++)), this.finishToken(f.string, k);
      }
      jsx_readEntity() {
        let S = "",
          k = 0,
          b,
          _ = this.input[this.pos];
        _ !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
        let T = ++this.pos;
        for (; this.pos < this.input.length && k++ < 10; ) {
          if (((_ = this.input[this.pos++]), _ === ";")) {
            S[0] === "#"
              ? S[1] === "x"
                ? ((S = S.substr(2)), n.test(S) && (b = String.fromCharCode(parseInt(S, 16))))
                : ((S = S.substr(1)), r.test(S) && (b = String.fromCharCode(parseInt(S, 10))))
              : (b = e[S]);
            break;
          }
          S += _;
        }
        return b || ((this.pos = T), "&");
      }
      jsx_readWord() {
        let S,
          k = this.pos;
        do S = this.input.charCodeAt(++this.pos);
        while (y(S) || S === 45);
        return this.finishToken(d.jsxName, this.input.slice(k, this.pos));
      }
      jsx_parseIdentifier() {
        let S = this.startNode();
        return (
          this.type === d.jsxName ? (S.name = this.value) : this.type.keyword ? (S.name = this.type.keyword) : this.unexpected(),
          this.next(),
          this.finishNode(S, "JSXIdentifier")
        );
      }
      jsx_parseNamespacedName() {
        let S = this.start,
          k = this.startLoc,
          b = this.jsx_parseIdentifier();
        if (!l.allowNamespaces || !this.eat(f.colon)) return b;
        var _ = this.startNodeAt(S, k);
        return (_.namespace = b), (_.name = this.jsx_parseIdentifier()), this.finishNode(_, "JSXNamespacedName");
      }
      jsx_parseElementName() {
        if (this.type === d.jsxTagEnd) return "";
        let S = this.start,
          k = this.startLoc,
          b = this.jsx_parseNamespacedName();
        for (this.type === f.dot && b.type === "JSXNamespacedName" && !l.allowNamespacedObjects && this.unexpected(); this.eat(f.dot); ) {
          let _ = this.startNodeAt(S, k);
          (_.object = b), (_.property = this.jsx_parseIdentifier()), (b = this.finishNode(_, "JSXMemberExpression"));
        }
        return b;
      }
      jsx_parseAttributeValue() {
        switch (this.type) {
          case f.braceL:
            let S = this.jsx_parseExpressionContainer();
            return (
              S.expression.type === "JSXEmptyExpression" &&
                this.raise(S.start, "JSX attributes must only be assigned a non-empty expression"),
              S
            );
          case d.jsxTagStart:
          case f.string:
            return this.parseExprAtom();
          default:
            this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
        }
      }
      jsx_parseEmptyExpression() {
        let S = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
        return this.finishNodeAt(S, "JSXEmptyExpression", this.start, this.startLoc);
      }
      jsx_parseExpressionContainer() {
        let S = this.startNode();
        return (
          this.next(),
          (S.expression = this.type === f.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression()),
          this.expect(f.braceR),
          this.finishNode(S, "JSXExpressionContainer")
        );
      }
      jsx_parseAttribute() {
        let S = this.startNode();
        return this.eat(f.braceL)
          ? (this.expect(f.ellipsis),
            (S.argument = this.parseMaybeAssign()),
            this.expect(f.braceR),
            this.finishNode(S, "JSXSpreadAttribute"))
          : ((S.name = this.jsx_parseNamespacedName()),
            (S.value = this.eat(f.eq) ? this.jsx_parseAttributeValue() : null),
            this.finishNode(S, "JSXAttribute"));
      }
      jsx_parseOpeningElementAt(S, k) {
        let b = this.startNodeAt(S, k);
        b.attributes = [];
        let _ = this.jsx_parseElementName();
        for (_ && (b.name = _); this.type !== f.slash && this.type !== d.jsxTagEnd; ) b.attributes.push(this.jsx_parseAttribute());
        return (
          (b.selfClosing = this.eat(f.slash)), this.expect(d.jsxTagEnd), this.finishNode(b, _ ? "JSXOpeningElement" : "JSXOpeningFragment")
        );
      }
      jsx_parseClosingElementAt(S, k) {
        let b = this.startNodeAt(S, k),
          _ = this.jsx_parseElementName();
        return _ && (b.name = _), this.expect(d.jsxTagEnd), this.finishNode(b, _ ? "JSXClosingElement" : "JSXClosingFragment");
      }
      jsx_parseElementAt(S, k) {
        let b = this.startNodeAt(S, k),
          _ = [],
          T = this.jsx_parseOpeningElementAt(S, k),
          P = null;
        if (!T.selfClosing) {
          e: for (;;)
            switch (this.type) {
              case d.jsxTagStart:
                if (((S = this.start), (k = this.startLoc), this.next(), this.eat(f.slash))) {
                  P = this.jsx_parseClosingElementAt(S, k);
                  break e;
                }
                _.push(this.jsx_parseElementAt(S, k));
                break;
              case d.jsxText:
                _.push(this.parseExprAtom());
                break;
              case f.braceL:
                _.push(this.jsx_parseExpressionContainer());
                break;
              default:
                this.unexpected();
            }
          o(P.name) !== o(T.name) && this.raise(P.start, "Expected corresponding JSX closing tag for <" + o(T.name) + ">");
        }
        let M = T.name ? "Element" : "Fragment";
        return (
          (b["opening" + M] = T),
          (b["closing" + M] = P),
          (b.children = _),
          this.type === f.relational &&
            this.value === "<" &&
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"),
          this.finishNode(b, "JSX" + M)
        );
      }
      jsx_parseText() {
        let S = this.parseLiteral(this.value);
        return (S.type = "JSXText"), S;
      }
      jsx_parseElement() {
        let S = this.start,
          k = this.startLoc;
        return this.next(), this.jsx_parseElementAt(S, k);
      }
      parseExprAtom(S) {
        return this.type === d.jsxText
          ? this.jsx_parseText()
          : this.type === d.jsxTagStart
          ? this.jsx_parseElement()
          : super.parseExprAtom(S);
      }
      readToken(S) {
        let k = this.curContext();
        if (k === v) return this.jsx_readToken();
        if (k === m || k === O) {
          if (x(S)) return this.jsx_readWord();
          if (S == 62) return ++this.pos, this.finishToken(d.jsxTagEnd);
          if ((S === 34 || S === 39) && k == m) return this.jsx_readString(S);
        }
        return S === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33
          ? (++this.pos, this.finishToken(d.jsxTagStart))
          : super.readToken(S);
      }
      updateContext(S) {
        if (this.type == f.braceL) {
          var k = this.curContext();
          k == m ? this.context.push(p.b_expr) : k == v ? this.context.push(p.b_tmpl) : super.updateContext(S), (this.exprAllowed = !0);
        } else if (this.type === f.slash && S === d.jsxTagStart) (this.context.length -= 2), this.context.push(O), (this.exprAllowed = !1);
        else return super.updateContext(S);
      }
    };
  }
})(i6);
var nne = i6.exports;
const rne = Ql(nne);
function ine(t) {
  const e = t || {},
    n = e.addResult,
    r = e.acorn,
    i = e.spread;
  let s = e.allowEmpty,
    o;
  if ((s == null && (s = !0), r)) {
    if (!r.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    o = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, e.acornOptions);
  } else if (e.acornOptions || e.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: { 123: { name: "mdxFlowExpression", tokenize: a, concrete: !0 } },
    text: { 123: { name: "mdxTextExpression", tokenize: l } },
  };
  function a(c, u, h) {
    const f = this;
    return d;
    function d(v) {
      return p(v);
    }
    function p(v) {
      return lp.call(f, c, m, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", r, o, n, i, s)(v);
    }
    function m(v) {
      return Re(v) ? Me(c, O, "whitespace")(v) : O(v);
    }
    function O(v) {
      const g = f.parser.constructs.flow[60],
        y = (Array.isArray(g) ? g : g ? [g] : []).find(function (S) {
          return S.name === "mdxJsxFlowTag";
        });
      return v === 60 && y ? c.attempt(y, O, h)(v) : v === null || de(v) ? u(v) : h(v);
    }
  }
  function l(c, u) {
    const h = this;
    return f;
    function f(d) {
      return lp.call(h, c, u, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", r, o, n, i, s, !0)(d);
    }
  }
}
const sne = { tokenize: lne, partial: !0 },
  O_ = "https://github.com/micromark/micromark-extension-mdxjs-esm",
  one = new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]);
function ane(t) {
  const e = { tokenize: i, concrete: !0 };
  if (!t || !t.acorn || !t.acorn.parse) throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  const n = t.acorn,
    r = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, t.acornOptions, { locations: !0 });
  return { flow: { 101: e, 105: e } };
  function i(s, o, a) {
    const l = this,
      c = l.parser.definedModuleSpecifiers || (l.parser.definedModuleSpecifiers = []),
      u = this.events.length + 1;
    let h = "";
    return l.interrupt ? a : f;
    function f(g) {
      return l.now().column > 1 ? a(g) : (s.enter("mdxjsEsm"), s.enter("mdxjsEsmData"), s.consume(g), (h += String.fromCharCode(g)), d);
    }
    function d(g) {
      return fr(g)
        ? (s.consume(g), (h += String.fromCharCode(g)), d)
        : (h === "import" || h === "export") && g === 32
        ? (s.consume(g), p)
        : a(g);
    }
    function p(g) {
      return g === null || de(g) ? (s.exit("mdxjsEsmData"), m(g)) : (s.consume(g), p);
    }
    function m(g) {
      return g === null ? v(g) : de(g) ? s.check(sne, v, O)(g) : (s.enter("mdxjsEsmData"), p(g));
    }
    function O(g) {
      return s.enter("lineEnding"), s.consume(g), s.exit("lineEnding"), m;
    }
    function v(g) {
      const x = q3(l.events.slice(u), {
        acorn: n,
        acornOptions: r,
        tokenTypes: ["mdxjsEsmData"],
        prefix:
          c.length > 0
            ? "var " +
              c.join(",") +
              `
`
            : "",
      });
      if (x.error) {
        if (g !== null && x.swallow) return O(g);
        const S = new ct("Could not parse import/exports with acorn", {
          cause: x.error,
          place: { line: x.error.loc.line, column: x.error.loc.column + 1, offset: x.error.pos },
          ruleId: "acorn",
          source: "micromark-extension-mdxjs-esm",
        });
        throw ((S.url = O_ + "#could-not-parse-importexports-with-acorn"), S);
      }
      c.length > 0 && x.estree.body.shift();
      let y = -1;
      for (; ++y < x.estree.body.length; ) {
        const S = x.estree.body[y];
        if (!one.has(S.type)) {
          const k = new ct("Unexpected `" + S.type + "` in code: only import/exports are supported", {
            place: wd(S),
            ruleId: "non-esm",
            source: "micromark-extension-mdxjs-esm",
          });
          throw ((k.url = O_ + "#unexpected-type-in-code-only-importexports-are-supported"), k);
        }
        if (S.type === "ImportDeclaration" && !l.interrupt) {
          let k = -1;
          for (; ++k < S.specifiers.length; ) {
            const b = S.specifiers[k];
            c.push(b.local.name);
          }
        }
      }
      return Object.assign(s.exit("mdxjsEsm"), t.addResult ? { estree: x.estree } : void 0), o(g);
    }
  }
}
function lne(t, e, n) {
  return r;
  function r(i) {
    return t.enter("lineEndingBlank"), t.consume(i), t.exit("lineEndingBlank"), t.attempt(Ch, e, n);
  }
}
function cne(t) {
  const e = Object.assign({ acorn: Mt.extend(rne()), acornOptions: { ecmaVersion: 2024, sourceType: "module" }, addResult: !0 }, t);
  return yA([ane(e), ine(e), G3(e), J3()]);
}
const Og = C.createContext(void 0);
function qh() {
  const t = C.useContext(Og);
  if (!t) throw new Error("useNestedEditor must be used within a NestedEditorsProvider");
  return t;
}
function vg() {
  const { parentEditor: t, mdastNode: e, lexicalNode: n } = qh();
  return function (i) {
    t.update(
      () => {
        gQ("history-push");
        const s = vt(n.getKey());
        s && s.setMdastNode({ ...e, ...i });
      },
      { discrete: !0 }
    ),
      t.dispatchCommand(Gs, void 0);
  };
}
function s6() {
  const { parentEditor: t, lexicalNode: e } = qh();
  return () => {
    t.update(() => {
      const n = vt(e.getKey());
      n.selectNext(), n.remove();
    });
  };
}
const xg = function (t) {
  const { getContent: e, getUpdatedMdastNode: n, contentEditableProps: r, block: i = !1 } = t,
    { mdastNode: s, lexicalNode: o, focusEmitter: a } = qh(),
    l = vg(),
    c = s6(),
    u = e(s),
    [h, f, d, p, m, O, v, g, x] = nt(sr, Eh, Ph, Th, Js, zo, ha, Ah, iy),
    y = tt(ho),
    [S] = C.useState(() => Rb({ nodes: p, theme: Xm }));
  return (
    C.useEffect(() => {
      a.subscribe(() => {
        S.focus();
      });
    }, [S, a]),
    C.useEffect(() => {
      S.update(() => {
        Be().clear();
        let k = u;
        i ? k.length === 0 && (k = [{ type: "paragraph", children: [] }]) : (k = [{ type: "paragraph", children: u }]),
          Um({
            root: Be(),
            mdastRoot: { type: "root", children: k },
            visitors: f,
            directiveDescriptors: O,
            codeBlockEditorDescriptors: v,
            jsxComponentDescriptors: m,
          });
      });
    }, [S, i, f]),
    C.useEffect(() => {
      function k() {
        S.getEditorState().read(() => {
          const b = Wm({ root: Be(), visitors: d, jsxComponentDescriptors: m, jsxIsAvailable: g, addImportStatements: !1 }),
            _ = i ? b.children : b.children[0].children;
          l(n(structuredClone(s), _));
        });
      }
      return ir(
        S.registerCommand(
          Em,
          (b) => {
            const _ = b.relatedTarget;
            return ig(_, h.getRootElement()) ? !1 : (k(), y(null), !0);
          },
          Ue
        ),
        S.registerCommand(Gs, () => (k(), !0), Ue),
        S.registerCommand(Bl, () => (y({ editorType: "lexical", rootNode: o }), !1), sp),
        S.registerCommand(
          gh,
          (b, _) => {
            const T = _.getRootElement();
            return (T == null ? void 0 : T.innerText) ===
              `
`
              ? (c(), !0)
              : !1;
          },
          Gn
        )
      );
    }, [i, S, d, n, m, g, o, s, c, y, l, h]),
    C.createElement(
      n$,
      { initialEditor: S },
      C.createElement(uy, {
        contentEditable: C.createElement(ly, { ...r, className: Ze(F.nestedEditor, r == null ? void 0 : r.className) }),
        placeholder: null,
        ErrorBoundary: cy,
      }),
      C.createElement(LA, null),
      x.map((k, b) => C.createElement(k, { key: b }))
    )
  );
};
function bg() {
  let t = Zs;
  return {
    publish: () => {
      t();
    },
    subscribe: (e) => {
      t = e;
    },
  };
}
var une = Object.defineProperty,
  hne = (t, e, n) => (e in t ? une(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  L0 = (t, e, n) => (hne(t, typeof e != "symbol" ? e + "" : e, n), n);
class Yh extends Mi {
  constructor(e, n) {
    super(n),
      L0(this, "__mdastNode"),
      L0(this, "__focusEmitter", bg()),
      L0(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__mdastNode = e);
  }
  static getType() {
    return "jsx";
  }
  static clone(e) {
    return new Yh(structuredClone(e.__mdastNode));
  }
  static importJSON(e) {
    return Ip(e.mdastNode);
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  exportJSON() {
    return { mdastNode: this.getMdastNode(), type: "jsx", version: 1 };
  }
  createDOM() {
    return document.createElement(this.__mdastNode.type === "mdxJsxTextElement" ? "span" : "div");
  }
  updateDOM() {
    return !1;
  }
  setMdastNode(e) {
    this.getWritable().__mdastNode = e;
  }
  decorate(e, n) {
    return C.createElement(fne, {
      lexicalJsxNode: this,
      config: n,
      mdastNode: this.getMdastNode(),
      parentEditor: e,
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return this.__mdastNode.type === "mdxJsxTextElement";
  }
  isKeyboardSelectable() {
    return !0;
  }
}
function fne(t) {
  const { mdastNode: e } = t,
    r = yt(Js).find((s) => s.name === e.name);
  if (!r) throw new Error(`No JSX descriptor found for ${e.name}`);
  const i = r.Editor;
  return C.createElement(
    Og.Provider,
    {
      value: { config: t.config, focusEmitter: t.focusEmitter, mdastNode: e, parentEditor: t.parentEditor, lexicalNode: t.lexicalJsxNode },
    },
    C.createElement(i, { descriptor: r, mdastNode: e })
  );
}
function Ip(t) {
  return new Yh(t);
}
function dne(t) {
  return t instanceof Yh;
}
const pne = {
    testLexicalNode: dne,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      function r(s) {
        "children" in s &&
          s.children instanceof Array &&
          s.children.forEach((o) => {
            l6(o) && t.registerReferredComponent(o.name), r(o);
          });
      }
      const i = n.getMdastNode();
      t.registerReferredComponent(i.name), r(i), t.appendToParent(e, i);
    },
    priority: -200,
  },
  mne = { testNode: "mdxjsEsm", visitNode() {} },
  gne = {
    testNode: (t, { jsxComponentDescriptors: e }) =>
      t.type === "mdxJsxTextElement" || t.type === "mdxJsxFlowElement" ? e.find((r) => r.name === t.name) !== void 0 : !1,
    visitNode({ lexicalParent: t, mdastNode: e }) {
      t.append(Ip(e));
    },
    priority: -200,
  };
var One = Object.defineProperty,
  vne = (t, e, n) => (e in t ? One(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  v_ = (t, e, n) => (vne(t, typeof e != "symbol" ? e + "" : e, n), n);
class Gh extends Mi {
  constructor(e, n, r) {
    super(r), v_(this, "__value"), v_(this, "__mdastType"), (this.__value = e), (this.__mdastType = n);
  }
  static getType() {
    return "mdx-expression";
  }
  static clone(e) {
    return new Gh(e.__value, e.__mdastType, e.__key);
  }
  getValue() {
    return this.__value;
  }
  getMdastType() {
    return this.__mdastType;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.classList.add(on.mdxExpression), e;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return { element: n };
  }
  static importJSON(e) {
    return o6(e.value, e.mdastType);
  }
  exportJSON() {
    return { ...super.exportJSON(), value: this.getValue(), mdastType: this.getMdastType(), type: "mdx-expression", version: 1 };
  }
  extractWithChild() {
    return !0;
  }
  isInline() {
    return this.__mdastType === "mdxTextExpression";
  }
  decorate(e) {
    return C.createElement(
      C.Fragment,
      null,
      "{",
      C.createElement(
        "span",
        { className: F.inputSizer, "data-value": this.getValue() },
        C.createElement("input", {
          size: 1,
          onKeyDown: (n) => {
            ((n.target.value === "" && n.key === "Backspace") || n.key === "Delete") &&
              (n.stopPropagation(),
              n.nativeEvent.stopImmediatePropagation(),
              n.preventDefault(),
              e.update(() => {
                this.selectPrevious(), this.remove();
              }));
          },
          onChange: (n) => {
            (n.target.parentElement.dataset.value = n.target.value),
              e.update(() => {
                this.getWritable().__value = n.target.value;
              });
          },
          type: "text",
          value: this.getValue(),
        })
      ),
      "}"
    );
  }
}
function o6(t, e) {
  return Zn(new Gh(t, e));
}
function xne(t) {
  return t instanceof Gh;
}
const bne = {
    testNode: (t) => t.type === "mdxTextExpression" || t.type === "mdxFlowExpression",
    visitNode({ lexicalParent: t, mdastNode: e }) {
      t.append(o6(e.value, e.type));
    },
    priority: -200,
  },
  yne = {
    testLexicalNode: xne,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      const r = { type: n.getMdastType(), value: n.getValue() };
      t.appendToParent(e, r);
    },
  },
  wne = (t) => {
    const e = yt(si);
    return C.createElement(gm, { ...t, container: e == null ? void 0 : e.current });
  },
  Sne = C.forwardRef((t, e) =>
    C.createElement(
      CP,
      { ...t, className: F.popoverContent, sideOffset: 5, side: "top", ref: e },
      C.createElement("span", { className: F.popoverArrow }, C.createElement(Om, null)),
      t.children
    )
  ),
  bw = ({ title: t, properties: e, onChange: n }) => {
    const [r, i] = C.useState(!1),
      s = yt(ft),
      { register: o, handleSubmit: a, reset: l } = vm({ defaultValues: e });
    return C.createElement(
      mm,
      {
        open: r,
        onOpenChange: (c) => {
          i(c);
        },
      },
      C.createElement(YM, { className: F.iconButton }, C.createElement("div", null, s("settings"))),
      C.createElement(
        wne,
        null,
        C.createElement(
          Sne,
          null,
          C.createElement(
            "form",
            {
              onSubmit: (c) => {
                a(n)(c), i(!1), c.preventDefault(), c.stopPropagation();
              },
            },
            C.createElement("h3", { className: F.propertyPanelTitle }, t, " Attributes"),
            C.createElement(
              "table",
              { className: F.propertyEditorTable },
              C.createElement(
                "thead",
                null,
                C.createElement(
                  "tr",
                  null,
                  C.createElement("th", { className: F.readOnlyColumnCell }, "Attribute"),
                  C.createElement("th", null, "Value")
                )
              ),
              C.createElement(
                "tbody",
                null,
                Object.keys(e).map((c) =>
                  C.createElement(
                    "tr",
                    { key: c },
                    C.createElement("th", { className: F.readOnlyColumnCell }, " ", c, " "),
                    C.createElement("td", null, C.createElement("input", { ...o(c), className: F.propertyEditorInput }))
                  )
                )
              ),
              C.createElement(
                "tfoot",
                null,
                C.createElement(
                  "tr",
                  null,
                  C.createElement(
                    "td",
                    { colSpan: 2 },
                    C.createElement(
                      "div",
                      { className: F.buttonsFooter },
                      C.createElement("button", { type: "submit", className: F.primaryButton }, "Save"),
                      C.createElement(
                        "button",
                        {
                          type: "reset",
                          className: F.secondaryButton,
                          onClick: (c) => {
                            c.preventDefault(), l(e), i(!1);
                          },
                        },
                        "Cancel"
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
  },
  kne = (t) => t !== null && typeof t == "object" && "type" in t && "value" in t && typeof t.value == "string",
  Cne = (t) => typeof t == "string",
  _ne = (t) => t.type === "mdxJsxAttribute" && typeof t.name == "string",
  a6 = ({ mdastNode: t, descriptor: e }) => {
    const n = vg(),
      r = C.useMemo(
        () =>
          e.props.reduce((o, { name: a }) => {
            const l = t.attributes.find((c) => (_ne(c) ? c.name === a : !1));
            if (l) {
              if (kne(l.value)) return (o[a] = l.value.value), o;
              if (Cne(l.value)) return (o[a] = l.value), o;
            }
            return (o[a] = ""), o;
          }, {}),
        [t, e]
      ),
      i = C.useCallback(
        (o) => {
          const a = Object.entries(o).reduce((l, [c, u]) => {
            if (u === "") return l;
            const h = e.props.find((f) => f.name === c);
            return (h == null ? void 0 : h.type) === "expression"
              ? (l.push({ type: "mdxJsxAttribute", name: c, value: { type: "mdxJsxAttributeValueExpression", value: u } }), l)
              : (l.push({ type: "mdxJsxAttribute", name: c, value: u }), l);
          }, []);
          n({ attributes: a });
        },
        [t, n, e]
      ),
      s = e.props.length == 0 && e.hasChildren && e.kind === "flow";
    return C.createElement(
      "div",
      { className: e.kind === "text" ? F.inlineEditor : F.blockEditor },
      s ? C.createElement("span", { className: F.genericComponentName }, t.name ?? "Fragment") : null,
      e.props.length > 0 ? C.createElement(bw, { properties: r, title: t.name ?? "", onChange: i }) : null,
      e.hasChildren
        ? C.createElement(xg, {
            block: e.kind === "flow",
            getContent: (o) => o.children,
            getUpdatedMdastNode: (o, a) => ({ ...o, children: a }),
          })
        : C.createElement("span", { className: F.genericComponentName }, t.name)
    );
  };
function l6(t) {
  return t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement";
}
const Ene = (t) => t !== null && typeof t == "object" && "type" in t && "value" in t && typeof t.value == "string",
  Tne = (t) =>
    Object.entries(t).map(([e, n]) => ({
      type: "mdxJsxAttribute",
      name: e,
      value: Ene(n) ? { type: "mdxJsxAttributeValueExpression", value: n.value } : n,
    })),
  c6 = $t((t) => {
    t.link(
      t.pipe(
        c6,
        Rr(({ kind: e, name: n, children: r, props: i }) => () => {
          const s = Tne(i);
          return Ip(
            e === "flow"
              ? { type: "mdxJsxFlowElement", name: n, children: r ?? [], attributes: s }
              : { type: "mdxJsxTextElement", name: n, children: r ?? [], attributes: s }
          );
        })
      ),
      Hl
    );
  }),
  x_ = { name: null, kind: "flow", props: [], hasChildren: !0, Editor: a6 },
  b_ = (t) => (t ? (t.allowFragment ?? !0 ? [x_, ...t.jsxComponentDescriptors] : t.jsxComponentDescriptors) : [x_]),
  Pne = en({
    init: (t, e) => {
      t.pubIn({ [Ah]: !0, [eo]: mte(), [Ks]: cne(), [rr]: [gne, mne, bne], [vr]: [Yh, Gh], [xr]: [pne, yne], [fa]: gte(), [Js]: b_(e) });
    },
    update(t, e) {
      t.pub(Js, b_(e));
    },
  });
var Ane = Object.defineProperty,
  $ne = (t, e, n) => (e in t ? Ane(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  ws = (t, e, n) => ($ne(t, typeof e != "symbol" ? e + "" : e, n), n);
class ga extends Mi {
  constructor(e, n, r, i) {
    super(i),
      ws(this, "__code"),
      ws(this, "__meta"),
      ws(this, "__language"),
      ws(this, "__focusEmitter", bg()),
      ws(this, "setCode", (s) => {
        s !== this.__code && (this.getWritable().__code = s);
      }),
      ws(this, "setMeta", (s) => {
        s !== this.__meta && (this.getWritable().__meta = s);
      }),
      ws(this, "setLanguage", (s) => {
        s !== this.__language && (this.getWritable().__language = s);
      }),
      ws(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__code = e),
      (this.__meta = r),
      (this.__language = n);
  }
  static getType() {
    return "codeblock";
  }
  static clone(e) {
    return new ga(e.__code, e.__language, e.__meta, e.__key);
  }
  static importJSON(e) {
    const { code: n, meta: r, language: i } = e;
    return Jh({ code: n, language: i, meta: r });
  }
  exportJSON() {
    return { code: this.getCode(), language: this.getLanguage(), meta: this.getMeta(), type: "codeblock", version: 1 };
  }
  createDOM(e) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getCode() {
    return this.__code;
  }
  getMeta() {
    return this.__meta;
  }
  getLanguage() {
    return this.__language;
  }
  decorate(e) {
    return C.createElement(Ine, {
      parentEditor: e,
      code: this.getCode(),
      meta: this.getMeta(),
      language: this.getLanguage(),
      codeBlockNode: this,
      nodeKey: this.getKey(),
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return !1;
  }
}
const u6 = C.createContext(null),
  Rne = ({ parentEditor: t, lexicalNode: e, children: n }) => {
    const r = C.useMemo(
      () => ({
        lexicalNode: e,
        parentEditor: t,
        setCode: (i) => {
          t.update(() => {
            e.setCode(i),
              setTimeout(() => {
                t.dispatchCommand(Gs, void 0);
              }, 0);
          });
        },
        setLanguage: (i) => {
          t.update(() => {
            e.setLanguage(i);
          });
        },
        setMeta: (i) => {
          t.update(() => {
            e.setMeta(i);
          });
        },
      }),
      [e, t]
    );
    return C.createElement(u6.Provider, { value: r }, n);
  };
function wl() {
  const t = C.useContext(u6);
  if (!t) throw new Error("useCodeBlockEditor must be used within a CodeBlockEditor");
  return t;
}
const Ine = (t) => {
  const e = yt(ha),
    n = yt(yg);
  let r = e.sort((l, c) => c.priority - l.priority).find((l) => l.match(t.language || "", t.meta || ""));
  if ((r || (r = e.find((l) => l.match(n || "", t.meta || ""))), !r))
    throw new Error(`No CodeBlockEditor registered for language=${t.language} meta=${t.meta}`);
  const i = r.Editor,
    { codeBlockNode: s, parentEditor: o, ...a } = t;
  return C.createElement(Rne, { parentEditor: t.parentEditor, lexicalNode: t.codeBlockNode }, C.createElement(i, { ...a }));
};
function Jh(t) {
  const { code: e = "", language: n = "", meta: r = "" } = t;
  return new ga(e, n, r);
}
function h6(t) {
  return t instanceof ga;
}
const Nne = {
    testLexicalNode: h6,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      e.addAndStepInto("code", { value: t.getCode(), lang: t.getLanguage(), meta: t.getMeta() });
    },
  },
  Lne = {
    testNode: (t, { codeBlockEditorDescriptors: e }) => (t.type === "code" ? e.find((r) => r.match(t.lang, t.meta)) !== void 0 : !1),
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(Jh({ code: t.value, language: t.lang, meta: t.meta }));
    },
  },
  yg = Se(""),
  Kh = $t((t) => {
    t.link(
      t.pipe(
        Kh,
        bt(yg),
        Rr(
          ([e, n]) =>
            () =>
              Jh({ language: n, ...e })
        )
      ),
      Hl
    );
  }),
  yw = zn(ha),
  Mne = en({
    update(t, e) {
      t.pub(yg, (e == null ? void 0 : e.defaultCodeBlockLanguage) ?? "");
    },
    init(t, e) {
      t.pubIn({ [ql]: "codeblock", [ha]: (e == null ? void 0 : e.codeBlockEditorDescriptors) ?? [], [rr]: Lne, [vr]: ga, [xr]: Nne });
    },
  });
var dt = "colors",
  In = "sizes",
  we = "space",
  Dne = {
    gap: we,
    gridGap: we,
    columnGap: we,
    gridColumnGap: we,
    rowGap: we,
    gridRowGap: we,
    inset: we,
    insetBlock: we,
    insetBlockEnd: we,
    insetBlockStart: we,
    insetInline: we,
    insetInlineEnd: we,
    insetInlineStart: we,
    margin: we,
    marginTop: we,
    marginRight: we,
    marginBottom: we,
    marginLeft: we,
    marginBlock: we,
    marginBlockEnd: we,
    marginBlockStart: we,
    marginInline: we,
    marginInlineEnd: we,
    marginInlineStart: we,
    padding: we,
    paddingTop: we,
    paddingRight: we,
    paddingBottom: we,
    paddingLeft: we,
    paddingBlock: we,
    paddingBlockEnd: we,
    paddingBlockStart: we,
    paddingInline: we,
    paddingInlineEnd: we,
    paddingInlineStart: we,
    top: we,
    right: we,
    bottom: we,
    left: we,
    scrollMargin: we,
    scrollMarginTop: we,
    scrollMarginRight: we,
    scrollMarginBottom: we,
    scrollMarginLeft: we,
    scrollMarginX: we,
    scrollMarginY: we,
    scrollMarginBlock: we,
    scrollMarginBlockEnd: we,
    scrollMarginBlockStart: we,
    scrollMarginInline: we,
    scrollMarginInlineEnd: we,
    scrollMarginInlineStart: we,
    scrollPadding: we,
    scrollPaddingTop: we,
    scrollPaddingRight: we,
    scrollPaddingBottom: we,
    scrollPaddingLeft: we,
    scrollPaddingX: we,
    scrollPaddingY: we,
    scrollPaddingBlock: we,
    scrollPaddingBlockEnd: we,
    scrollPaddingBlockStart: we,
    scrollPaddingInline: we,
    scrollPaddingInlineEnd: we,
    scrollPaddingInlineStart: we,
    fontSize: "fontSizes",
    background: dt,
    backgroundColor: dt,
    backgroundImage: dt,
    borderImage: dt,
    border: dt,
    borderBlock: dt,
    borderBlockEnd: dt,
    borderBlockStart: dt,
    borderBottom: dt,
    borderBottomColor: dt,
    borderColor: dt,
    borderInline: dt,
    borderInlineEnd: dt,
    borderInlineStart: dt,
    borderLeft: dt,
    borderLeftColor: dt,
    borderRight: dt,
    borderRightColor: dt,
    borderTop: dt,
    borderTopColor: dt,
    caretColor: dt,
    color: dt,
    columnRuleColor: dt,
    fill: dt,
    outline: dt,
    outlineColor: dt,
    stroke: dt,
    textDecorationColor: dt,
    fontFamily: "fonts",
    fontWeight: "fontWeights",
    lineHeight: "lineHeights",
    letterSpacing: "letterSpacings",
    blockSize: In,
    minBlockSize: In,
    maxBlockSize: In,
    inlineSize: In,
    minInlineSize: In,
    maxInlineSize: In,
    width: In,
    minWidth: In,
    maxWidth: In,
    height: In,
    minHeight: In,
    maxHeight: In,
    flexBasis: In,
    gridTemplateColumns: In,
    gridTemplateRows: In,
    borderWidth: "borderWidths",
    borderTopWidth: "borderWidths",
    borderRightWidth: "borderWidths",
    borderBottomWidth: "borderWidths",
    borderLeftWidth: "borderWidths",
    borderStyle: "borderStyles",
    borderTopStyle: "borderStyles",
    borderRightStyle: "borderStyles",
    borderBottomStyle: "borderStyles",
    borderLeftStyle: "borderStyles",
    borderRadius: "radii",
    borderTopLeftRadius: "radii",
    borderTopRightRadius: "radii",
    borderBottomRightRadius: "radii",
    borderBottomLeftRadius: "radii",
    boxShadow: "shadows",
    textShadow: "shadows",
    transition: "transitions",
    zIndex: "zIndices",
  },
  Qne = (t, e) => (typeof e == "function" ? { "()": Function.prototype.toString.call(e) } : e),
  ef = () => {
    const t = Object.create(null);
    return (e, n, ...r) => {
      const i = ((s) => JSON.stringify(s, Qne))(e);
      return i in t ? t[i] : (t[i] = n(e, ...r));
    };
  },
  Ed = Symbol.for("sxs.internal"),
  ww = (t, e) => Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)),
  y_ = (t) => {
    for (const e in t) return !0;
    return !1;
  },
  { hasOwnProperty: Fne } = Object.prototype,
  lv = (t) => (t.includes("-") ? t : t.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase())),
  Vne = /\s+(?![^()]*\))/,
  ka = (t) => (e) => t(...(typeof e == "string" ? String(e).split(Vne) : [e])),
  w_ = {
    appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
    backfaceVisibility: (t) => ({ WebkitBackfaceVisibility: t, backfaceVisibility: t }),
    backdropFilter: (t) => ({ WebkitBackdropFilter: t, backdropFilter: t }),
    backgroundClip: (t) => ({ WebkitBackgroundClip: t, backgroundClip: t }),
    boxDecorationBreak: (t) => ({ WebkitBoxDecorationBreak: t, boxDecorationBreak: t }),
    clipPath: (t) => ({ WebkitClipPath: t, clipPath: t }),
    content: (t) => ({
      content:
        t.includes('"') || t.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(t)
          ? t
          : `"${t}"`,
    }),
    hyphens: (t) => ({ WebkitHyphens: t, hyphens: t }),
    maskImage: (t) => ({ WebkitMaskImage: t, maskImage: t }),
    maskSize: (t) => ({ WebkitMaskSize: t, maskSize: t }),
    tabSize: (t) => ({ MozTabSize: t, tabSize: t }),
    textSizeAdjust: (t) => ({ WebkitTextSizeAdjust: t, textSizeAdjust: t }),
    userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
    marginBlock: ka((t, e) => ({ marginBlockStart: t, marginBlockEnd: e || t })),
    marginInline: ka((t, e) => ({ marginInlineStart: t, marginInlineEnd: e || t })),
    maxSize: ka((t, e) => ({ maxBlockSize: t, maxInlineSize: e || t })),
    minSize: ka((t, e) => ({ minBlockSize: t, minInlineSize: e || t })),
    paddingBlock: ka((t, e) => ({ paddingBlockStart: t, paddingBlockEnd: e || t })),
    paddingInline: ka((t, e) => ({ paddingInlineStart: t, paddingInlineEnd: e || t })),
  },
  M0 = /([\d.]+)([^]*)/,
  Bne = (t, e) =>
    t.length
      ? t.reduce(
          (n, r) => (
            n.push(
              ...e.map((i) => (i.includes("&") ? i.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(i) ? `:is(${r})` : r) : r + " " + i))
            ),
            n
          ),
          []
        )
      : e,
  jne = (t, e) =>
    t in Zne && typeof e == "string"
      ? e.replace(
          /^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,
          (n, r, i, s) =>
            r +
            (i === "stretch" ? `-moz-available${s};${lv(t)}:${r}-webkit-fill-available` : `-moz-fit-content${s};${lv(t)}:${r}fit-content`) +
            s
        )
      : String(e),
  Zne = {
    blockSize: 1,
    height: 1,
    inlineSize: 1,
    maxBlockSize: 1,
    maxHeight: 1,
    maxInlineSize: 1,
    maxWidth: 1,
    minBlockSize: 1,
    minHeight: 1,
    minInlineSize: 1,
    minWidth: 1,
    width: 1,
  },
  fs = (t) => (t ? t + "-" : ""),
  f6 = (t, e, n) =>
    t.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, i, s, o, a) =>
      (o == "$") == !!s
        ? r
        : (i || o == "--" ? "calc(" : "") +
          "var(--" +
          (o === "$" ? fs(e) + (a.includes("$") ? "" : fs(n)) + a.replace(/\$/g, "-") : a) +
          ")" +
          (i || o == "--" ? "*" + (i || "") + (s || "1") + ")" : "")
    ),
  zne = /\s*,\s*(?![^()]*\))/,
  Wne = Object.prototype.toString,
  ja = (t, e, n, r, i) => {
    let s, o, a;
    const l = (c, u, h) => {
      let f, d;
      const p = (m) => {
        for (f in m) {
          const g = f.charCodeAt(0) === 64,
            x = g && Array.isArray(m[f]) ? m[f] : [m[f]];
          for (d of x) {
            const y = /[A-Z]/.test((v = f)) ? v : v.replace(/-[^]/g, (k) => k[1].toUpperCase()),
              S = typeof d == "object" && d && d.toString === Wne && (!r.utils[y] || !u.length);
            if (y in r.utils && !S) {
              const k = r.utils[y];
              if (k !== o) {
                (o = k), p(k(d)), (o = null);
                continue;
              }
            } else if (y in w_) {
              const k = w_[y];
              if (k !== a) {
                (a = k), p(k(d)), (a = null);
                continue;
              }
            }
            if (
              (g &&
                ((O = f.slice(1) in r.media ? "@media " + r.media[f.slice(1)] : f),
                (f = O.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (k, b, _, T, P, M) => {
                  const D = M0.test(b),
                    V = 0.0625 * (D ? -1 : 1),
                    [Q, N] = D ? [T, b] : [b, T];
                  return (
                    "(" +
                    (_[0] === "=" ? "" : (_[0] === ">") === D ? "max-" : "min-") +
                    Q +
                    ":" +
                    (_[0] !== "=" && _.length === 1 ? N.replace(M0, (G, H, te) => Number(H) + V * (_ === ">" ? 1 : -1) + te) : N) +
                    (P
                      ? ") and (" +
                        (P[0] === ">" ? "min-" : "max-") +
                        Q +
                        ":" +
                        (P.length === 1 ? M.replace(M0, (G, H, te) => Number(H) + V * (P === ">" ? -1 : 1) + te) : M)
                      : "") +
                    ")"
                  );
                }))),
              S)
            ) {
              const k = g ? h.concat(f) : [...h],
                b = g ? [...u] : Bne(u, f.split(zne));
              s !== void 0 && i(S_(...s)), (s = void 0), l(d, b, k);
            } else
              s === void 0 && (s = [[], u, h]),
                (f = g || f.charCodeAt(0) !== 36 ? f : `--${fs(r.prefix)}${f.slice(1).replace(/\$/g, "-")}`),
                (d = S
                  ? d
                  : typeof d == "number"
                  ? d && y in Une
                    ? String(d) + "px"
                    : String(d)
                  : f6(jne(y, d ?? ""), r.prefix, r.themeMap[y])),
                s[0].push(`${g ? `${f} ` : `${lv(f)}:`}${d}`);
          }
        }
        var O, v;
      };
      p(c), s !== void 0 && i(S_(...s)), (s = void 0);
    };
    l(t, e, n);
  },
  S_ = (t, e, n) =>
    `${n.map((r) => `${r}{`).join("")}${e.length ? `${e.join(",")}{` : ""}${t.join(";")}${e.length ? "}" : ""}${Array(
      n.length ? n.length + 1 : 0
    ).join("}")}`,
  Une = {
    animationDelay: 1,
    animationDuration: 1,
    backgroundSize: 1,
    blockSize: 1,
    border: 1,
    borderBlock: 1,
    borderBlockEnd: 1,
    borderBlockEndWidth: 1,
    borderBlockStart: 1,
    borderBlockStartWidth: 1,
    borderBlockWidth: 1,
    borderBottom: 1,
    borderBottomLeftRadius: 1,
    borderBottomRightRadius: 1,
    borderBottomWidth: 1,
    borderEndEndRadius: 1,
    borderEndStartRadius: 1,
    borderInlineEnd: 1,
    borderInlineEndWidth: 1,
    borderInlineStart: 1,
    borderInlineStartWidth: 1,
    borderInlineWidth: 1,
    borderLeft: 1,
    borderLeftWidth: 1,
    borderRadius: 1,
    borderRight: 1,
    borderRightWidth: 1,
    borderSpacing: 1,
    borderStartEndRadius: 1,
    borderStartStartRadius: 1,
    borderTop: 1,
    borderTopLeftRadius: 1,
    borderTopRightRadius: 1,
    borderTopWidth: 1,
    borderWidth: 1,
    bottom: 1,
    columnGap: 1,
    columnRule: 1,
    columnRuleWidth: 1,
    columnWidth: 1,
    containIntrinsicSize: 1,
    flexBasis: 1,
    fontSize: 1,
    gap: 1,
    gridAutoColumns: 1,
    gridAutoRows: 1,
    gridTemplateColumns: 1,
    gridTemplateRows: 1,
    height: 1,
    inlineSize: 1,
    inset: 1,
    insetBlock: 1,
    insetBlockEnd: 1,
    insetBlockStart: 1,
    insetInline: 1,
    insetInlineEnd: 1,
    insetInlineStart: 1,
    left: 1,
    letterSpacing: 1,
    margin: 1,
    marginBlock: 1,
    marginBlockEnd: 1,
    marginBlockStart: 1,
    marginBottom: 1,
    marginInline: 1,
    marginInlineEnd: 1,
    marginInlineStart: 1,
    marginLeft: 1,
    marginRight: 1,
    marginTop: 1,
    maxBlockSize: 1,
    maxHeight: 1,
    maxInlineSize: 1,
    maxWidth: 1,
    minBlockSize: 1,
    minHeight: 1,
    minInlineSize: 1,
    minWidth: 1,
    offsetDistance: 1,
    offsetRotate: 1,
    outline: 1,
    outlineOffset: 1,
    outlineWidth: 1,
    overflowClipMargin: 1,
    padding: 1,
    paddingBlock: 1,
    paddingBlockEnd: 1,
    paddingBlockStart: 1,
    paddingBottom: 1,
    paddingInline: 1,
    paddingInlineEnd: 1,
    paddingInlineStart: 1,
    paddingLeft: 1,
    paddingRight: 1,
    paddingTop: 1,
    perspective: 1,
    right: 1,
    rowGap: 1,
    scrollMargin: 1,
    scrollMarginBlock: 1,
    scrollMarginBlockEnd: 1,
    scrollMarginBlockStart: 1,
    scrollMarginBottom: 1,
    scrollMarginInline: 1,
    scrollMarginInlineEnd: 1,
    scrollMarginInlineStart: 1,
    scrollMarginLeft: 1,
    scrollMarginRight: 1,
    scrollMarginTop: 1,
    scrollPadding: 1,
    scrollPaddingBlock: 1,
    scrollPaddingBlockEnd: 1,
    scrollPaddingBlockStart: 1,
    scrollPaddingBottom: 1,
    scrollPaddingInline: 1,
    scrollPaddingInlineEnd: 1,
    scrollPaddingInlineStart: 1,
    scrollPaddingLeft: 1,
    scrollPaddingRight: 1,
    scrollPaddingTop: 1,
    shapeMargin: 1,
    textDecoration: 1,
    textDecorationThickness: 1,
    textIndent: 1,
    textUnderlineOffset: 1,
    top: 1,
    transitionDelay: 1,
    transitionDuration: 1,
    verticalAlign: 1,
    width: 1,
    wordSpacing: 1,
  },
  k_ = (t) => String.fromCharCode(t + (t > 25 ? 39 : 97)),
  Qo = (t) =>
    ((e) => {
      let n,
        r = "";
      for (n = Math.abs(e); n > 52; n = (n / 52) | 0) r = k_(n % 52) + r;
      return k_(n % 52) + r;
    })(
      ((e, n) => {
        let r = n.length;
        for (; r; ) e = (33 * e) ^ n.charCodeAt(--r);
        return e;
      })(5381, JSON.stringify(t)) >>> 0
    ),
  Vc = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"],
  Xne = (t) => {
    if (t.href && !t.href.startsWith(location.origin)) return !1;
    try {
      return !!t.cssRules;
    } catch {
      return !1;
    }
  },
  Hne = (t) => {
    let e;
    const n = () => {
        const { cssRules: i } = e.sheet;
        return [].map
          .call(i, (s, o) => {
            const { cssText: a } = s;
            let l = "";
            if (a.startsWith("--sxs")) return "";
            if (i[o - 1] && (l = i[o - 1].cssText).startsWith("--sxs")) {
              if (!s.cssRules.length) return "";
              for (const c in e.rules) if (e.rules[c].group === s) return `--sxs{--sxs:${[...e.rules[c].cache].join(" ")}}${a}`;
              return s.cssRules.length ? `${l}${a}` : "";
            }
            return a;
          })
          .join("");
      },
      r = () => {
        if (e) {
          const { rules: a, sheet: l } = e;
          if (!l.deleteRule) {
            for (; Object(Object(l.cssRules)[0]).type === 3; ) l.cssRules.splice(0, 1);
            l.cssRules = [];
          }
          for (const c in a) delete a[c];
        }
        const i = Object(t).styleSheets || [];
        for (const a of i)
          if (Xne(a)) {
            for (let l = 0, c = a.cssRules; c[l]; ++l) {
              const u = Object(c[l]);
              if (u.type !== 1) continue;
              const h = Object(c[l + 1]);
              if (h.type !== 4) continue;
              ++l;
              const { cssText: f } = u;
              if (!f.startsWith("--sxs")) continue;
              const d = f.slice(14, -3).trim().split(/\s+/),
                p = Vc[d[0]];
              p && (e || (e = { sheet: a, reset: r, rules: {}, toString: n }), (e.rules[p] = { group: h, index: l, cache: new Set(d) }));
            }
            if (e) break;
          }
        if (!e) {
          const a = (l, c) => ({
            type: c,
            cssRules: [],
            insertRule(u, h) {
              this.cssRules.splice(h, 0, a(u, { import: 3, undefined: 1 }[(u.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
            },
            get cssText() {
              return l === "@media{}" ? `@media{${[].map.call(this.cssRules, (u) => u.cssText).join("")}}` : l;
            },
          });
          e = {
            sheet: t ? (t.head || t).appendChild(document.createElement("style")).sheet : a("", "text/css"),
            rules: {},
            reset: r,
            toString: n,
          };
        }
        const { sheet: s, rules: o } = e;
        for (let a = Vc.length - 1; a >= 0; --a) {
          const l = Vc[a];
          if (!o[l]) {
            const c = Vc[a + 1],
              u = o[c] ? o[c].index : s.cssRules.length;
            s.insertRule("@media{}", u),
              s.insertRule(`--sxs{--sxs:${a}}`, u),
              (o[l] = { group: s.cssRules[u + 1], index: u, cache: new Set([a]) });
          }
          qne(o[l]);
        }
      };
    return r(), e;
  },
  qne = (t) => {
    const e = t.group;
    let n = e.cssRules.length;
    t.apply = (r) => {
      try {
        e.insertRule(r, n), ++n;
      } catch {}
    };
  },
  Sc = Symbol(),
  Yne = ef(),
  Gne = (t, e) =>
    Yne(t, () => (...n) => {
      let r = { type: null, composers: new Set() };
      for (const i of n)
        if (i != null)
          if (i[Ed]) {
            r.type == null && (r.type = i[Ed].type);
            for (const s of i[Ed].composers) r.composers.add(s);
          } else i.constructor !== Object || i.$$typeof ? r.type == null && (r.type = i) : r.composers.add(Jne(i, t));
      return r.type == null && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), Kne(t, r, e);
    }),
  Jne = ({ variants: t, compoundVariants: e, defaultVariants: n, ...r }, i) => {
    const s = `${fs(i.prefix)}c-${Qo(r)}`,
      o = [],
      a = [],
      l = Object.create(null),
      c = [];
    for (const f in n) l[f] = String(n[f]);
    if (typeof t == "object" && t)
      for (const f in t) {
        (u = l), (h = f), Fne.call(u, h) || (l[f] = "undefined");
        const d = t[f];
        for (const p in d) {
          const m = { [f]: String(p) };
          String(p) === "undefined" && c.push(f);
          const O = d[p],
            v = [m, O, !y_(O)];
          o.push(v);
        }
      }
    var u, h;
    if (typeof e == "object" && e)
      for (const f of e) {
        let { css: d, ...p } = f;
        d = (typeof d == "object" && d) || {};
        for (const O in p) p[O] = String(p[O]);
        const m = [p, d, !y_(d)];
        a.push(m);
      }
    return [s, r, o, a, l, c];
  },
  Kne = (t, e, n) => {
    const [r, i, s, o] = ere(e.composers),
      a =
        typeof e.type == "function" || e.type.$$typeof
          ? ((h) => {
              function f() {
                for (let d = 0; d < f[Sc].length; d++) {
                  const [p, m] = f[Sc][d];
                  h.rules[p].apply(m);
                }
                return (f[Sc] = []), null;
              }
              return (f[Sc] = []), (f.rules = {}), Vc.forEach((d) => (f.rules[d] = { apply: (p) => f[Sc].push([d, p]) })), f;
            })(n)
          : null,
      l = (a || n).rules,
      c = `.${r}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`,
      u = (h) => {
        h = (typeof h == "object" && h) || tre;
        const { css: f, ...d } = h,
          p = {};
        for (const v in s)
          if ((delete d[v], v in h)) {
            let g = h[v];
            typeof g == "object" && g
              ? (p[v] = { "@initial": s[v], ...g })
              : ((g = String(g)), (p[v] = g !== "undefined" || o.has(v) ? g : s[v]));
          } else p[v] = s[v];
        const m = new Set([...i]);
        for (const [v, g, x, y] of e.composers) {
          n.rules.styled.cache.has(v) ||
            (n.rules.styled.cache.add(v),
            ja(g, [`.${v}`], [], t, (b) => {
              l.styled.apply(b);
            }));
          const S = C_(x, p, t.media),
            k = C_(y, p, t.media, !0);
          for (const b of S)
            if (b !== void 0)
              for (const [_, T, P] of b) {
                const M = `${v}-${Qo(T)}-${_}`;
                m.add(M);
                const D = (P ? n.rules.resonevar : n.rules.onevar).cache,
                  V = P ? l.resonevar : l.onevar;
                D.has(M) ||
                  (D.add(M),
                  ja(T, [`.${M}`], [], t, (Q) => {
                    V.apply(Q);
                  }));
              }
          for (const b of k)
            if (b !== void 0)
              for (const [_, T] of b) {
                const P = `${v}-${Qo(T)}-${_}`;
                m.add(P),
                  n.rules.allvar.cache.has(P) ||
                    (n.rules.allvar.cache.add(P),
                    ja(T, [`.${P}`], [], t, (M) => {
                      l.allvar.apply(M);
                    }));
              }
        }
        if (typeof f == "object" && f) {
          const v = `${r}-i${Qo(f)}-css`;
          m.add(v),
            n.rules.inline.cache.has(v) ||
              (n.rules.inline.cache.add(v),
              ja(f, [`.${v}`], [], t, (g) => {
                l.inline.apply(g);
              }));
        }
        for (const v of String(h.className || "")
          .trim()
          .split(/\s+/))
          v && m.add(v);
        const O = (d.className = [...m].join(" "));
        return { type: e.type, className: O, selector: c, props: d, toString: () => O, deferredInjector: a };
      };
    return ww(u, { className: r, selector: c, [Ed]: e, toString: () => (n.rules.styled.cache.has(r) || u(), r) });
  },
  ere = (t) => {
    let e = "";
    const n = [],
      r = {},
      i = [];
    for (const [s, , , , o, a] of t) {
      e === "" && (e = s), n.push(s), i.push(...a);
      for (const l in o) {
        const c = o[l];
        (r[l] === void 0 || c !== "undefined" || a.includes(c)) && (r[l] = c);
      }
    }
    return [e, n, r, new Set(i)];
  },
  C_ = (t, e, n, r) => {
    const i = [];
    e: for (let [s, o, a] of t) {
      if (a) continue;
      let l,
        c = 0,
        u = !1;
      for (l in s) {
        const h = s[l];
        let f = e[l];
        if (f !== h) {
          if (typeof f != "object" || !f) continue e;
          {
            let d,
              p,
              m = 0;
            for (const O in f) {
              if (h === String(f[O])) {
                if (O !== "@initial") {
                  const v = O.slice(1);
                  (p = p || []).push(v in n ? n[v] : O.replace(/^@media ?/, "")), (u = !0);
                }
                (c += m), (d = !0);
              }
              ++m;
            }
            if ((p && p.length && (o = { ["@media " + p.join(", ")]: o }), !d)) continue e;
          }
        }
      }
      (i[c] = i[c] || []).push([r ? "cv" : `${l}-${s[l]}`, o, u]);
    }
    return i;
  },
  tre = {},
  nre = ef(),
  rre = (t, e) =>
    nre(t, () => (...n) => {
      const r = () => {
        for (let i of n) {
          i = (typeof i == "object" && i) || {};
          let s = Qo(i);
          if (!e.rules.global.cache.has(s)) {
            if ((e.rules.global.cache.add(s), "@import" in i)) {
              let o = [].indexOf.call(e.sheet.cssRules, e.rules.themed.group) - 1;
              for (let a of [].concat(i["@import"]))
                (a = a.includes('"') || a.includes("'") ? a : `"${a}"`), e.sheet.insertRule(`@import ${a};`, o++);
              delete i["@import"];
            }
            ja(i, [], [], t, (o) => {
              e.rules.global.apply(o);
            });
          }
        }
        return "";
      };
      return ww(r, { toString: r });
    }),
  ire = ef(),
  sre = (t, e) =>
    ire(t, () => (n) => {
      const r = `${fs(t.prefix)}k-${Qo(n)}`,
        i = () => {
          if (!e.rules.global.cache.has(r)) {
            e.rules.global.cache.add(r);
            const s = [];
            ja(n, [], [], t, (a) => s.push(a));
            const o = `@keyframes ${r}{${s.join("")}}`;
            e.rules.global.apply(o);
          }
          return r;
        };
      return ww(i, {
        get name() {
          return i();
        },
        toString: i,
      });
    }),
  ore = class {
    constructor(e, n, r, i) {
      (this.token = e == null ? "" : String(e)),
        (this.value = n == null ? "" : String(n)),
        (this.scale = r == null ? "" : String(r)),
        (this.prefix = i == null ? "" : String(i));
    }
    get computedValue() {
      return "var(" + this.variable + ")";
    }
    get variable() {
      return "--" + fs(this.prefix) + fs(this.scale) + this.token;
    }
    toString() {
      return this.computedValue;
    }
  },
  are = ef(),
  lre = (t, e) =>
    are(t, () => (n, r) => {
      r = (typeof n == "object" && n) || Object(r);
      const i = `.${(n = (n = typeof n == "string" ? n : "") || `${fs(t.prefix)}t-${Qo(r)}`)}`,
        s = {},
        o = [];
      for (const l in r) {
        s[l] = {};
        for (const c in r[l]) {
          const u = `--${fs(t.prefix)}${l}-${c}`,
            h = f6(String(r[l][c]), t.prefix, l);
          (s[l][c] = new ore(c, h, l, t.prefix)), o.push(`${u}:${h}`);
        }
      }
      const a = () => {
        if (o.length && !e.rules.themed.cache.has(n)) {
          e.rules.themed.cache.add(n);
          const l = `${r === t.theme ? ":root," : ""}.${n}{${o.join(";")}}`;
          e.rules.themed.apply(l);
        }
        return n;
      };
      return {
        ...s,
        get className() {
          return a();
        },
        selector: i,
        toString: a,
      };
    }),
  cre = ef(),
  ure = (t) => {
    let e = !1;
    const n = cre(t, (r) => {
      e = !0;
      const i = "prefix" in (r = (typeof r == "object" && r) || {}) ? String(r.prefix) : "",
        s = (typeof r.media == "object" && r.media) || {},
        o = typeof r.root == "object" ? r.root || null : globalThis.document || null,
        a = (typeof r.theme == "object" && r.theme) || {},
        l = {
          prefix: i,
          media: s,
          theme: a,
          themeMap: (typeof r.themeMap == "object" && r.themeMap) || { ...Dne },
          utils: (typeof r.utils == "object" && r.utils) || {},
        },
        c = Hne(o),
        u = {
          css: Gne(l, c),
          globalCss: rre(l, c),
          keyframes: sre(l, c),
          createTheme: lre(l, c),
          reset() {
            c.reset(), u.theme.toString();
          },
          theme: {},
          sheet: c,
          config: l,
          prefix: i,
          getCssText: c.toString,
          toString: c.toString,
        };
      return String((u.theme = u.createTheme(a))), u;
    });
    return e || n.reset(), n;
  },
  __ = Object.prototype.hasOwnProperty;
function E_(t, e, n) {
  for (n of t.keys()) if (lu(n, e)) return n;
}
function lu(t, e) {
  var n, r, i;
  if (t === e) return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date) return t.getTime() === e.getTime();
    if (n === RegExp) return t.toString() === e.toString();
    if (n === Array) {
      if ((r = t.length) === e.length) for (; r-- && lu(t[r], e[r]); );
      return r === -1;
    }
    if (n === Set) {
      if (t.size !== e.size) return !1;
      for (r of t) if (((i = r), (i && typeof i == "object" && ((i = E_(e, i)), !i)) || !e.has(i))) return !1;
      return !0;
    }
    if (n === Map) {
      if (t.size !== e.size) return !1;
      for (r of t) if (((i = r[0]), (i && typeof i == "object" && ((i = E_(e, i)), !i)) || !lu(r[1], e.get(i)))) return !1;
      return !0;
    }
    if (n === ArrayBuffer) (t = new Uint8Array(t)), (e = new Uint8Array(e));
    else if (n === DataView) {
      if ((r = t.byteLength) === e.byteLength) for (; r-- && t.getInt8(r) === e.getInt8(r); );
      return r === -1;
    }
    if (ArrayBuffer.isView(t)) {
      if ((r = t.byteLength) === e.byteLength) for (; r-- && t[r] === e[r]; );
      return r === -1;
    }
    if (!n || typeof t == "object") {
      r = 0;
      for (n in t) if ((__.call(t, n) && ++r && !__.call(e, n)) || !(n in e) || !lu(t[n], e[n])) return !1;
      return Object.keys(e).length === r;
    }
  }
  return t !== t && e !== e;
}
var hre = /(%?)(%([sdjo]))/g;
function fre(t, e) {
  switch (e) {
    case "s":
      return t;
    case "d":
    case "i":
      return Number(t);
    case "j":
      return JSON.stringify(t);
    case "o": {
      if (typeof t == "string") return t;
      const n = JSON.stringify(t);
      return n === "{}" || n === "[]" || /^\[object .+?\]$/.test(n) ? t : n;
    }
  }
}
function cv(t, ...e) {
  if (e.length === 0) return t;
  let n = 0,
    r = t.replace(hre, (i, s, o, a) => {
      const l = e[n],
        c = fre(l, a);
      return s ? i : (n++, c);
    });
  return n < e.length && (r += ` ${e.slice(n).join(" ")}`), (r = r.replace(/%{2,2}/g, "%")), r;
}
var dre = 2;
function pre(t) {
  if (!t.stack) return;
  const e = t.stack.split(`
`);
  e.splice(1, dre),
    (t.stack = e.join(`
`));
}
var mre = class extends Error {
    constructor(t, ...e) {
      super(t), (this.message = t), (this.name = "Invariant Violation"), (this.message = cv(t, ...e)), pre(this);
    }
  },
  d6 = (t, e, ...n) => {
    if (!t) throw new mre(e, ...n);
  };
d6.as = (t, e, n, ...r) => {
  if (!e) throw t.prototype.name != null ? new t(cv(n, r)) : t(cv(n, r));
};
var uv = function (t, e) {
  return (
    (uv =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r;
        }) ||
      function (n, r) {
        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }),
    uv(t, e)
  );
};
function Zve(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  uv(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n());
}
var Za = function () {
  return (
    (Za =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    Za.apply(this, arguments)
  );
};
function gre(t, e, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (h) {
        o(h);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (h) {
        o(h);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(t, e || [])).next());
  });
}
function Ore(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    o;
  return (
    (o = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function a(c) {
    return function (u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (
          ((r = 1),
          i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done)
        )
          return s;
        switch (((i = 0), s && (c = [c[0] & 2, s.value]), c[0])) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return n.label++, { value: c[1], done: !1 };
          case 5:
            n.label++, (i = c[1]), (c = [0]);
            continue;
          case 7:
            (c = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2))) {
              n = 0;
              continue;
            }
            if (c[0] === 3 && (!s || (c[1] > s[0] && c[1] < s[3]))) {
              n.label = c[1];
              break;
            }
            if (c[0] === 6 && n.label < s[1]) {
              (n.label = s[1]), (s = c);
              break;
            }
            if (s && n.label < s[2]) {
              (n.label = s[2]), n.ops.push(c);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        c = e.call(t, n);
      } catch (u) {
        (c = [6, u]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function zve(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++) (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]));
  return t.concat(s || Array.prototype.slice.call(e));
}
var T_;
(function (t) {
  (t[(t.None = 0)] = "None"),
    (t[(t.Error = 10)] = "Error"),
    (t[(t.Warning = 20)] = "Warning"),
    (t[(t.Info = 30)] = "Info"),
    (t[(t.Debug = 40)] = "Debug");
})(T_ || (T_ = {}));
var vre = function (t) {
  return "[sandpack-client]: ".concat(t);
};
function D0(t, e) {
  return e === void 0 && (e = "Value is nullish"), d6(t != null, vre(e)), t;
}
var xre = '"dependencies" was not specified - provide either a package.json or a "dependencies" value',
  P_ = '"entry" was not specified - provide either a package.json with the "main" field or an "entry" value';
function bre(t, e, n) {
  return (
    t === void 0 && (t = {}),
    e === void 0 && (e = {}),
    n === void 0 && (n = "/index.js"),
    JSON.stringify({ name: "sandpack-project", main: n, dependencies: t, devDependencies: e }, null, 2)
  );
}
function yre(t, e, n, r) {
  var i,
    s,
    o = Yo(t),
    a = o["/package.json"];
  if (!a) return D0(e, xre), D0(r, P_), (o["/package.json"] = { code: bre(e, n, r) }), o;
  if (a) {
    var l = JSON.parse(a.code);
    D0(!(!e && !l.dependencies), P_),
      e && (l.dependencies = Za(Za({}, (i = l.dependencies) !== null && i !== void 0 ? i : {}), e ?? {})),
      n && (l.devDependencies = Za(Za({}, (s = l.devDependencies) !== null && s !== void 0 ? s : {}), n ?? {})),
      r && (l.main = r),
      (o["/package.json"] = { code: JSON.stringify(l, null, 2) });
  }
  return o;
}
function wre(t) {
  var e;
  if (t.title === "SyntaxError") {
    var n = t.title,
      r = t.path,
      i = t.message,
      s = t.line,
      o = t.column;
    return { title: n, path: r, message: i, line: s, column: o };
  }
  var a = Sre((e = t.payload) === null || e === void 0 ? void 0 : e.frames);
  if (!a) return { message: t.message };
  var l = Cre(a),
    c = kre(a),
    u = _re(a._originalFileName, t.message, c, l);
  return { message: u, title: t.title, path: a._originalFileName, line: a._originalLineNumber, column: a._originalColumnNumber };
}
function Sre(t) {
  if (t)
    return t.find(function (e) {
      return !!e._originalFileName;
    });
}
function kre(t) {
  return t ? " (".concat(t._originalLineNumber, ":").concat(t._originalColumnNumber, ")") : "";
}
function Cre(t) {
  var e = t._originalScriptCode[t._originalScriptCode.length - 1],
    n = e.lineNumber.toString().length,
    r = 2,
    i = 3,
    s = r + n + i + t._originalColumnNumber;
  return t._originalScriptCode.reduce(function (o, a) {
    var l = a.highlight ? ">" : " ",
      c = a.lineNumber.toString().length === n ? "".concat(a.lineNumber) : " ".concat(a.lineNumber),
      u = a.highlight
        ? `
` +
          " ".repeat(s) +
          "^"
        : "";
    return (
      o +
      `
` +
      l +
      " " +
      c +
      " | " +
      a.content +
      u
    );
  }, "");
}
function _re(t, e, n, r) {
  return ""
    .concat(t, ": ")
    .concat(e)
    .concat(
      n,
      `
`
    )
    .concat(r);
}
var Yo = function (t) {
  return typeof t == "string"
    ? t.startsWith("/")
      ? t
      : "/".concat(t)
    : Array.isArray(t)
    ? t.map(function (e) {
        return e.startsWith("/") ? e : "/".concat(e);
      })
    : typeof t == "object" && t !== null
    ? Object.entries(t).reduce(function (e, n) {
        var r = n[0],
          i = n[1],
          s = r.startsWith("/") ? r : "/".concat(r);
        return (e[s] = i), e;
      }, {})
    : null;
};
function Ere(t, e, n) {
  var r;
  return (
    n === void 0 && (n = {}),
    gre(this, void 0, void 0, function () {
      var i, s, o;
      return Ore(this, function (a) {
        switch (a.label) {
          case 0:
            switch (((i = (r = e.template) !== null && r !== void 0 ? r : "parcel"), (o = i), o)) {
              case "node":
                return [3, 1];
              case "static":
                return [3, 3];
            }
            return [3, 5];
          case 1:
            return [
              4,
              z(
                () => import("./index-e94c2046.js"),
                [
                  "./index-e94c2046.js",
                  "./base-80a1f760-3e486e45.js",
                  "./consoleHook-59e792cb-48d57bb9.js",
                  "./index-7c191284.js",
                  "./useResultBannerController-cd95b20f.js",
                  "./apis-0c1c184f.js",
                  "./iframe-35b6cbe2.js",
                  "./useAction-f9651b8b.js",
                  "./jsx-runtime-69eee039.js",
                  "./index-363833c6.js",
                  "./index-f0f16ed8.js",
                  "./extends-98964cd2.js",
                  "./dateTimeUtils-a817f99d.js",
                ],
                import.meta.url
              ).then(function (l) {
                return l.SandpackNode;
              }),
            ];
          case 2:
            return (s = a.sent()), [3, 7];
          case 3:
            return [
              4,
              z(
                () => import("./index-585bceb7-0d2607bb.js"),
                [
                  "./index-585bceb7-0d2607bb.js",
                  "./consoleHook-59e792cb-48d57bb9.js",
                  "./base-80a1f760-3e486e45.js",
                  "./index-7c191284.js",
                  "./useResultBannerController-cd95b20f.js",
                  "./apis-0c1c184f.js",
                  "./iframe-35b6cbe2.js",
                  "./useAction-f9651b8b.js",
                  "./jsx-runtime-69eee039.js",
                  "./index-363833c6.js",
                  "./index-f0f16ed8.js",
                  "./extends-98964cd2.js",
                  "./dateTimeUtils-a817f99d.js",
                ],
                import.meta.url
              ).then(function (l) {
                return l.SandpackStatic;
              }),
            ];
          case 4:
            return (s = a.sent()), [3, 7];
          case 5:
            return [
              4,
              z(
                () => import("./index-e01d1793.js"),
                [
                  "./index-e01d1793.js",
                  "./base-80a1f760-3e486e45.js",
                  "./index-7c191284.js",
                  "./useResultBannerController-cd95b20f.js",
                  "./apis-0c1c184f.js",
                  "./iframe-35b6cbe2.js",
                  "./useAction-f9651b8b.js",
                  "./jsx-runtime-69eee039.js",
                  "./index-363833c6.js",
                  "./index-f0f16ed8.js",
                  "./extends-98964cd2.js",
                  "./dateTimeUtils-a817f99d.js",
                ],
                import.meta.url
              ).then(function (l) {
                return l.SandpackRuntime;
              }),
            ];
          case 6:
            (s = a.sent()), (a.label = 7);
          case 7:
            return [2, new s(t, e, n)];
        }
      });
    })
  );
}
let ot = class p6 {
  lineAt(e) {
    if (e < 0 || e > this.length) throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  line(e) {
    if (e < 1 || e > this.lines) throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  replace(e, n, r) {
    [e, n] = Sl(this, e, n);
    let i = [];
    return (
      this.decompose(0, e, i, 2),
      r.length && r.decompose(0, r.length, i, 3),
      this.decompose(n, this.length, i, 1),
      bi.from(i, this.length - (n - e) + r.length)
    );
  }
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  slice(e, n = this.length) {
    [e, n] = Sl(this, e, n);
    let r = [];
    return this.decompose(e, n, r, 0), bi.from(r, n - e);
  }
  eq(e) {
    if (e == this) return !0;
    if (e.length != this.length || e.lines != this.lines) return !1;
    let n = this.scanIdentical(e, 1),
      r = this.length - this.scanIdentical(e, -1),
      i = new cu(this),
      s = new cu(e);
    for (let o = n, a = n; ; ) {
      if ((i.next(o), s.next(o), (o = 0), i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)) return !1;
      if (((a += i.value.length), i.done || a >= r)) return !0;
    }
  }
  iter(e = 1) {
    return new cu(this, e);
  }
  iterRange(e, n = this.length) {
    return new m6(this, e, n);
  }
  iterLines(e, n) {
    let r;
    if (e == null) r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new g6(r);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  constructor() {}
  static of(e) {
    if (e.length == 0) throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? p6.empty : e.length <= 32 ? new jt(e) : bi.from(jt.split(e, []));
  }
};
class jt extends ot {
  constructor(e, n = Tre(e)) {
    super(), (this.text = e), (this.length = n);
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s],
        a = i + o.length;
      if ((n ? r : a) >= e) return new Pre(i, a, r, o);
      (i = a + 1), r++;
    }
  }
  decompose(e, n, r, i) {
    let s = e <= 0 && n >= this.length ? this : new jt(A_(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(),
        a = Td(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32) r.push(new jt(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        r.push(new jt(a.slice(0, l)), new jt(a.slice(l)));
      }
    } else r.push(s);
  }
  replace(e, n, r) {
    if (!(r instanceof jt)) return super.replace(e, n, r);
    [e, n] = Sl(this, e, n);
    let i = Td(this.text, Td(r.text, A_(this.text, 0, e)), n),
      s = this.length + r.length - (n - e);
    return i.length <= 32 ? new jt(i, s) : bi.from(jt.split(i, []), s);
  }
  sliceString(
    e,
    n = this.length,
    r = `
`
  ) {
    [e, n] = Sl(this, e, n);
    let i = "";
    for (let s = 0, o = 0; s <= n && o < this.text.length; o++) {
      let a = this.text[o],
        l = s + a.length;
      s > e && o && (i += r), e < l && n > s && (i += a.slice(Math.max(0, e - s), n - s)), (s = l + 1);
    }
    return i;
  }
  flatten(e) {
    for (let n of this.text) e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let r = [],
      i = -1;
    for (let s of e) r.push(s), (i += s.length + 1), r.length == 32 && (n.push(new jt(r, i)), (r = []), (i = -1));
    return i > -1 && n.push(new jt(r, i)), n;
  }
}
class bi extends ot {
  constructor(e, n) {
    super(), (this.children = e), (this.length = n), (this.lines = 0);
    for (let r of e) this.lines += r.lines;
  }
  lineInner(e, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s],
        a = i + o.length,
        l = r + o.lines - 1;
      if ((n ? l : a) >= e) return o.lineInner(e, n, r, i);
      (i = a + 1), (r = l + 1);
    }
  }
  decompose(e, n, r, i) {
    for (let s = 0, o = 0; o <= n && s < this.children.length; s++) {
      let a = this.children[s],
        l = o + a.length;
      if (e <= l && n >= o) {
        let c = i & ((o <= e ? 1 : 0) | (l >= n ? 2 : 0));
        o >= e && l <= n && !c ? r.push(a) : a.decompose(e - o, n - o, r, c);
      }
      o = l + 1;
    }
  }
  replace(e, n, r) {
    if ((([e, n] = Sl(this, e, n)), r.lines < this.lines))
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i],
          a = s + o.length;
        if (e >= s && n <= a) {
          let l = o.replace(e - s, n - s, r),
            c = this.lines - o.lines + l.lines;
          if (l.lines < c >> (5 - 1) && l.lines > c >> (5 + 1)) {
            let u = this.children.slice();
            return (u[i] = l), new bi(u, this.length - (n - e) + r.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, n, r);
  }
  sliceString(
    e,
    n = this.length,
    r = `
`
  ) {
    [e, n] = Sl(this, e, n);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= n; s++) {
      let a = this.children[s],
        l = o + a.length;
      o > e && s && (i += r), e < l && n > o && (i += a.sliceString(e - o, n - o, r)), (o = l + 1);
    }
    return i;
  }
  flatten(e) {
    for (let n of this.children) n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof bi)) return 0;
    let r = 0,
      [i, s, o, a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += n, s += n) {
      if (i == o || s == a) return r;
      let l = this.children[i],
        c = e.children[s];
      if (l != c) return r + l.scanIdentical(c, n);
      r += l.length + 1;
    }
  }
  static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let d of e) r += d.lines;
    if (r < 32) {
      let d = [];
      for (let p of e) p.flatten(d);
      return new jt(d, n);
    }
    let i = Math.max(32, r >> 5),
      s = i << 1,
      o = i >> 1,
      a = [],
      l = 0,
      c = -1,
      u = [];
    function h(d) {
      let p;
      if (d.lines > s && d instanceof bi) for (let m of d.children) h(m);
      else
        d.lines > o && (l > o || !l)
          ? (f(), a.push(d))
          : d instanceof jt && l && (p = u[u.length - 1]) instanceof jt && d.lines + p.lines <= 32
          ? ((l += d.lines), (c += d.length + 1), (u[u.length - 1] = new jt(p.text.concat(d.text), p.length + 1 + d.length)))
          : (l + d.lines > i && f(), (l += d.lines), (c += d.length + 1), u.push(d));
    }
    function f() {
      l != 0 && (a.push(u.length == 1 ? u[0] : bi.from(u, c)), (c = -1), (l = u.length = 0));
    }
    for (let d of e) h(d);
    return f(), a.length == 1 ? a[0] : new bi(a, n);
  }
}
ot.empty = new jt([""], 0);
function Tre(t) {
  let e = -1;
  for (let n of t) e += n.length + 1;
  return e;
}
function Td(t, e, n = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < t.length && i <= r; s++) {
    let a = t[s],
      l = i + a.length;
    l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), o ? ((e[e.length - 1] += a), (o = !1)) : e.push(a)),
      (i = l + 1);
  }
  return e;
}
function A_(t, e, n) {
  return Td(t, [""], e, n);
}
class cu {
  constructor(e, n = 1) {
    (this.dir = n),
      (this.done = !1),
      (this.lineBreak = !1),
      (this.value = ""),
      (this.nodes = [e]),
      (this.offsets = [n > 0 ? 1 : (e instanceof jt ? e.text.length : e.children.length) << 1]);
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1,
        i = this.nodes[r],
        s = this.offsets[r],
        o = s >> 1,
        a = i instanceof jt ? i.text.length : i.children.length;
      if (o == (n > 0 ? a : 0)) {
        if (r == 0) return (this.done = !0), (this.value = ""), this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (n > 0 ? 0 : 1)) {
        if (((this.offsets[r] += n), e == 0))
          return (
            (this.lineBreak = !0),
            (this.value = `
`),
            this
          );
        e--;
      } else if (i instanceof jt) {
        let l = i.text[o + (n < 0 ? -1 : 0)];
        if (((this.offsets[r] += n), l.length > Math.max(0, e)))
          return (this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e)), this;
        e -= l.length;
      } else {
        let l = i.children[o + (n < 0 ? -1 : 0)];
        e > l.length
          ? ((e -= l.length), (this.offsets[r] += n))
          : (n < 0 && this.offsets[r]--,
            this.nodes.push(l),
            this.offsets.push(n > 0 ? 1 : (l instanceof jt ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), (e = this.value.length)), this.nextInner(e, this.dir);
  }
}
class m6 {
  constructor(e, n, r) {
    (this.value = ""),
      (this.done = !1),
      (this.cursor = new cu(e, n > r ? -1 : 1)),
      (this.pos = n > r ? e.length : 0),
      (this.from = Math.min(n, r)),
      (this.to = Math.max(n, r));
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to) return (this.value = ""), (this.done = !0), this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), (r -= e);
    let { value: i } = this.cursor.next(e);
    return (
      (this.pos += (i.length + e) * n),
      (this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r)),
      (this.done = !this.value),
      this
    );
  }
  next(e = 0) {
    return (
      e < 0 ? (e = Math.max(e, this.from - this.pos)) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir)
    );
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class g6 {
  constructor(e) {
    (this.inner = e), (this.afterBreak = !0), (this.value = ""), (this.done = !1);
  }
  next(e = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(e);
    return (
      n && this.afterBreak
        ? ((this.value = ""), (this.afterBreak = !1))
        : n
        ? ((this.done = !0), (this.value = ""))
        : r
        ? this.afterBreak
          ? (this.value = "")
          : ((this.afterBreak = !0), this.next())
        : ((this.value = i), (this.afterBreak = !1)),
      this
    );
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" &&
  ((ot.prototype[Symbol.iterator] = function () {
    return this.iter();
  }),
  (cu.prototype[Symbol.iterator] =
    m6.prototype[Symbol.iterator] =
    g6.prototype[Symbol.iterator] =
      function () {
        return this;
      }));
let Pre = class {
  constructor(e, n, r, i) {
    (this.from = e), (this.to = n), (this.number = r), (this.text = i);
  }
  get length() {
    return this.to - this.from;
  }
};
function Sl(t, e, n) {
  return (e = Math.max(0, Math.min(t.length, e))), [e, Math.max(e, Math.min(t.length, n))];
}
let il =
  "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o"
    .split(",")
    .map((t) => (t ? parseInt(t, 36) : 1));
for (let t = 1; t < il.length; t++) il[t] += il[t - 1];
function Are(t) {
  for (let e = 1; e < il.length; e += 2) if (il[e] > t) return il[e - 1] <= t;
  return !1;
}
function $_(t) {
  return t >= 127462 && t <= 127487;
}
const R_ = 8205;
function xn(t, e, n = !0, r = !0) {
  return (n ? O6 : $re)(t, e, r);
}
function O6(t, e, n) {
  if (e == t.length) return e;
  e && v6(t.charCodeAt(e)) && x6(t.charCodeAt(e - 1)) && e--;
  let r = mn(t, e);
  for (e += Pr(r); e < t.length; ) {
    let i = mn(t, e);
    if (r == R_ || i == R_ || (n && Are(i))) (e += Pr(i)), (r = i);
    else if ($_(i)) {
      let s = 0,
        o = e - 2;
      for (; o >= 0 && $_(mn(t, o)); ) s++, (o -= 2);
      if (s % 2 == 0) break;
      e += 2;
    } else break;
  }
  return e;
}
function $re(t, e, n) {
  for (; e > 0; ) {
    let r = O6(t, e - 2, n);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function v6(t) {
  return t >= 56320 && t < 57344;
}
function x6(t) {
  return t >= 55296 && t < 56320;
}
function mn(t, e) {
  let n = t.charCodeAt(e);
  if (!x6(n) || e + 1 == t.length) return n;
  let r = t.charCodeAt(e + 1);
  return v6(r) ? ((n - 55296) << 10) + (r - 56320) + 65536 : n;
}
function Sw(t) {
  return t <= 65535 ? String.fromCharCode(t) : ((t -= 65536), String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Pr(t) {
  return t < 65536 ? 1 : 2;
}
const hv = /\r\n?|\n/;
var On = (function (t) {
  return (
    (t[(t.Simple = 0)] = "Simple"),
    (t[(t.TrackDel = 1)] = "TrackDel"),
    (t[(t.TrackBefore = 2)] = "TrackBefore"),
    (t[(t.TrackAfter = 3)] = "TrackAfter"),
    t
  );
})(On || (On = {}));
class Pi {
  constructor(e) {
    this.sections = e;
  }
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) e += this.sections[n];
    return e;
  }
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      e += r < 0 ? this.sections[n] : r;
    }
    return e;
  }
  get empty() {
    return this.sections.length == 0 || (this.sections.length == 2 && this.sections[1] < 0);
  }
  iterGaps(e) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let s = this.sections[n++],
        o = this.sections[n++];
      o < 0 ? (e(r, i, s), (i += s)) : (i += o), (r += s);
    }
  }
  iterChangedRanges(e, n = !1) {
    fv(this, e, n);
  }
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++],
        i = this.sections[n++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new Pi(e);
  }
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : b6(this, e);
  }
  mapDesc(e, n = !1) {
    return e.empty ? this : dv(this, e, n);
  }
  mapPos(e, n = -1, r = On.Simple) {
    let i = 0,
      s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++],
        l = this.sections[o++],
        c = i + a;
      if (l < 0) {
        if (c > e) return s + (e - i);
        s += a;
      } else {
        if (
          r != On.Simple &&
          c >= e &&
          ((r == On.TrackDel && i < e && c > e) || (r == On.TrackBefore && i < e) || (r == On.TrackAfter && c > e))
        )
          return null;
        if (c > e || (c == e && n < 0 && !a)) return e == i || n < 0 ? s : s + l;
        s += l;
      }
      i = c;
    }
    if (e > i) throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  touchesRange(e, n = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let s = this.sections[r++],
        o = this.sections[r++],
        a = i + s;
      if (o >= 0 && i <= n && a >= e) return i < e && a > n ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++],
        i = this.sections[n++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Pi(e);
  }
  static create(e) {
    return new Pi(e);
  }
}
class qt extends Pi {
  constructor(e, n) {
    super(e), (this.inserted = n);
  }
  apply(e) {
    if (this.length != e.length) throw new RangeError("Applying change set to a document with the wrong length");
    return fv(this, (n, r, i, s, o) => (e = e.replace(i, i + (r - n), o)), !1), e;
  }
  mapDesc(e, n = !1) {
    return dv(this, e, n, !0);
  }
  invert(e) {
    let n = this.sections.slice(),
      r = [];
    for (let i = 0, s = 0; i < n.length; i += 2) {
      let o = n[i],
        a = n[i + 1];
      if (a >= 0) {
        (n[i] = a), (n[i + 1] = o);
        let l = i >> 1;
        for (; r.length < l; ) r.push(ot.empty);
        r.push(o ? e.slice(s, s + o) : ot.empty);
      }
      s += o;
    }
    return new qt(n, r);
  }
  compose(e) {
    return this.empty ? e : e.empty ? this : b6(this, e, !0);
  }
  map(e, n = !1) {
    return e.empty ? this : dv(this, e, n, !0);
  }
  iterChanges(e, n = !1) {
    fv(this, e, n);
  }
  get desc() {
    return Pi.create(this.sections);
  }
  filter(e) {
    let n = [],
      r = [],
      i = [],
      s = new Fu(this);
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++];
      for (; a < l || (a == l && s.len == 0); ) {
        if (s.done) break e;
        let u = Math.min(s.len, l - a);
        Sn(i, u, -1);
        let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        Sn(n, u, h), h > 0 && Fs(r, n, s.text), s.forward(u), (a += u);
      }
      let c = e[o++];
      for (; a < c; ) {
        if (s.done) break e;
        let u = Math.min(s.len, c - a);
        Sn(n, u, -1), Sn(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), (a += u);
      }
    }
    return { changes: new qt(n, r), filtered: Pi.create(i) };
  }
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n],
        i = this.sections[n + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  static of(e, n, r) {
    let i = [],
      s = [],
      o = 0,
      a = null;
    function l(u = !1) {
      if (!u && !i.length) return;
      o < n && Sn(i, n - o, -1);
      let h = new qt(i, s);
      (a = a ? a.compose(h.map(a)) : h), (i = []), (s = []), (o = 0);
    }
    function c(u) {
      if (Array.isArray(u)) for (let h of u) c(h);
      else if (u instanceof qt) {
        if (u.length != n) throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
        l(), (a = a ? a.compose(u.map(a)) : u);
      } else {
        let { from: h, to: f = h, insert: d } = u;
        if (h > f || h < 0 || f > n) throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${n})`);
        let p = d ? (typeof d == "string" ? ot.of(d.split(r || hv)) : d) : ot.empty,
          m = p.length;
        if (h == f && m == 0) return;
        h < o && l(), h > o && Sn(i, h - o, -1), Sn(i, f - h, m), Fs(s, i, p), (o = f);
      }
    }
    return c(e), l(!a), a;
  }
  static empty(e) {
    return new qt(e ? [e, -1] : [], []);
  }
  static fromJSON(e) {
    if (!Array.isArray(e)) throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [],
      r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number") n.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1) n.push(s[0], 0);
        else {
          for (; r.length < i; ) r.push(ot.empty);
          (r[i] = ot.of(s.slice(1))), n.push(s[0], r[i].length);
        }
      }
    }
    return new qt(n, r);
  }
  static createSet(e, n) {
    return new qt(e, n);
  }
}
function Sn(t, e, n, r = !1) {
  if (e == 0 && n <= 0) return;
  let i = t.length - 2;
  i >= 0 && n <= 0 && n == t[i + 1]
    ? (t[i] += e)
    : e == 0 && t[i] == 0
    ? (t[i + 1] += n)
    : r
    ? ((t[i] += e), (t[i + 1] += n))
    : t.push(e, n);
}
function Fs(t, e, n) {
  if (n.length == 0) return;
  let r = (e.length - 2) >> 1;
  if (r < t.length) t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < r; ) t.push(ot.empty);
    t.push(n);
  }
}
function fv(t, e, n) {
  let r = t.inserted;
  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
    let a = t.sections[o++],
      l = t.sections[o++];
    if (l < 0) (i += a), (s += a);
    else {
      let c = i,
        u = s,
        h = ot.empty;
      for (; (c += a), (u += l), l && r && (h = h.append(r[(o - 2) >> 1])), !(n || o == t.sections.length || t.sections[o + 1] < 0); )
        (a = t.sections[o++]), (l = t.sections[o++]);
      e(i, c, s, u, h), (i = c), (s = u);
    }
  }
}
function dv(t, e, n, r = !1) {
  let i = [],
    s = r ? [] : null,
    o = new Fu(t),
    a = new Fu(e);
  for (let l = -1; ; )
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      Sn(i, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || (o.off == 0 && (a.len < o.len || (a.len == o.len && !n))))) {
      let c = a.len;
      for (Sn(i, a.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= u && (Sn(i, 0, o.ins), s && Fs(s, i, o.text), (l = o.i)), o.forward(u), (c -= u);
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0,
        u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let h = Math.min(u, a.len);
          (c += h), (u -= h), a.forward(h);
        } else if (a.ins == 0 && a.len < u) (u -= a.len), a.next();
        else break;
      Sn(i, c, l < o.i ? o.ins : 0), s && l < o.i && Fs(s, i, o.text), (l = o.i), o.forward(o.len - u);
    } else {
      if (o.done && a.done) return s ? qt.createSet(i, s) : Pi.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function b6(t, e, n = !1) {
  let r = [],
    i = n ? [] : null,
    s = new Fu(t),
    o = new Fu(e);
  for (let a = !1; ; ) {
    if (s.done && o.done) return i ? qt.createSet(r, i) : Pi.create(r);
    if (s.ins == 0) Sn(r, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done) Sn(r, 0, o.ins, a), i && Fs(i, r, o.text), o.next();
    else {
      if (s.done || o.done) throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len),
          c = r.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Sn(r, l, u, a), i && u && Fs(i, r, o.text);
        } else
          o.ins == -1
            ? (Sn(r, s.off ? 0 : s.len, l, a), i && Fs(i, r, s.textBit(l)))
            : (Sn(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), i && !o.off && Fs(i, r, o.text));
        (a = (s.ins > l || (o.ins >= 0 && o.len > l)) && (a || r.length > c)), s.forward2(l), o.forward(l);
      }
    }
  }
}
class Fu {
  constructor(e) {
    (this.set = e), (this.i = 0), this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? ((this.len = e[this.i++]), (this.ins = e[this.i++])) : ((this.len = 0), (this.ins = -2)), (this.off = 0);
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set,
      n = (this.i - 2) >> 1;
    return n >= e.length ? ot.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set,
      r = (this.i - 2) >> 1;
    return r >= n.length && !e ? ot.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : ((this.len -= e), (this.off += e));
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : ((this.ins -= e), (this.off += e));
  }
}
class Ro {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.flags = r);
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  map(e, n = -1) {
    let r, i;
    return (
      this.empty ? (r = i = e.mapPos(this.from, n)) : ((r = e.mapPos(this.from, 1)), (i = e.mapPos(this.to, -1))),
      r == this.from && i == this.to ? this : new Ro(r, i, this.flags)
    );
  }
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor) return X.range(e, n);
    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return X.range(this.anchor, r);
  }
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return X.range(e.anchor, e.head);
  }
  static create(e, n, r) {
    return new Ro(e, n, r);
  }
}
class X {
  constructor(e, n) {
    (this.ranges = e), (this.mainIndex = n);
  }
  map(e, n = -1) {
    return e.empty
      ? this
      : X.create(
          this.ranges.map((r) => r.map(e, n)),
          this.mainIndex
        );
  }
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1;
    for (let r = 0; r < this.ranges.length; r++) if (!this.ranges[r].eq(e.ranges[r], n)) return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new X([this.main], 0);
  }
  addRange(e, n = !0) {
    return X.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  replaceRange(e, n = this.mainIndex) {
    let r = this.ranges.slice();
    return (r[n] = e), X.create(r, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new X(
      e.ranges.map((n) => Ro.fromJSON(n)),
      e.main
    );
  }
  static single(e, n = e) {
    return new X([X.range(e, n)], 0);
  }
  static create(e, n = 0) {
    if (e.length == 0) throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r) return X.normalized(e.slice(), n);
      r = s.to;
    }
    return new X(e, n);
  }
  static cursor(e, n = 0, r, i) {
    return Ro.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | ((i ?? 16777215) << 6));
  }
  static range(e, n, r, i) {
    let s = ((r ?? 16777215) << 6) | (i == null ? 7 : Math.min(6, i));
    return n < e ? Ro.create(n, e, 48 | s) : Ro.create(e, n, (n > e ? 8 : 0) | s);
  }
  static normalized(e, n = 0) {
    let r = e[n];
    e.sort((i, s) => i.from - s.from), (n = e.indexOf(r));
    for (let i = 1; i < e.length; i++) {
      let s = e[i],
        o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from,
          l = Math.max(s.to, o.to);
        i <= n && n--, e.splice(--i, 2, s.anchor > s.head ? X.range(l, a) : X.range(a, l));
      }
    }
    return new X(e, n);
  }
}
function y6(t, e) {
  for (let n of t.ranges) if (n.to > e) throw new RangeError("Selection points outside of document");
}
let kw = 0;
class ye {
  constructor(e, n, r, i, s) {
    (this.combine = e),
      (this.compareInput = n),
      (this.compare = r),
      (this.isStatic = i),
      (this.id = kw++),
      (this.default = e([])),
      (this.extensions = typeof s == "function" ? s(this) : s);
  }
  get reader() {
    return this;
  }
  static define(e = {}) {
    return new ye(
      e.combine || ((n) => n),
      e.compareInput || ((n, r) => n === r),
      e.compare || (e.combine ? (n, r) => n === r : Cw),
      !!e.static,
      e.enables
    );
  }
  of(e) {
    return new Pd([], this, 0, e);
  }
  compute(e, n) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new Pd(e, this, 1, n);
  }
  computeN(e, n) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new Pd(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));
  }
}
function Cw(t, e) {
  return t == e || (t.length == e.length && t.every((n, r) => n === e[r]));
}
class Pd {
  constructor(e, n, r, i) {
    (this.dependencies = e), (this.facet = n), (this.type = r), (this.value = i), (this.id = kw++);
  }
  dynamicSlot(e) {
    var n;
    let r = this.value,
      i = this.facet.compareInput,
      s = this.id,
      o = e[s] >> 1,
      a = this.type == 2,
      l = !1,
      c = !1,
      u = [];
    for (let h of this.dependencies)
      h == "doc" ? (l = !0) : h == "selection" ? (c = !0) : ((n = e[h.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[h.id]);
    return {
      create(h) {
        return (h.values[o] = r(h)), 1;
      },
      update(h, f) {
        if ((l && f.docChanged) || (c && (f.docChanged || f.selection)) || pv(h, u)) {
          let d = r(h);
          if (a ? !I_(d, h.values[o], i) : !i(d, h.values[o])) return (h.values[o] = d), 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d,
          p = f.config.address[s];
        if (p != null) {
          let m = Lp(f, p);
          if (
            this.dependencies.every((O) =>
              O instanceof ye ? f.facet(O) === h.facet(O) : O instanceof zt ? f.field(O, !1) == h.field(O, !1) : !0
            ) ||
            (a ? I_((d = r(h)), m, i) : i((d = r(h)), m))
          )
            return (h.values[o] = m), 0;
        } else d = r(h);
        return (h.values[o] = d), 1;
      },
    };
  }
}
function I_(t, e, n) {
  if (t.length != e.length) return !1;
  for (let r = 0; r < t.length; r++) if (!n(t[r], e[r])) return !1;
  return !0;
}
function pv(t, e) {
  let n = !1;
  for (let r of e) uu(t, r) & 1 && (n = !0);
  return n;
}
function Rre(t, e, n) {
  let r = n.map((l) => t[l.id]),
    i = n.map((l) => l.type),
    s = r.filter((l) => !(l & 1)),
    o = t[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = Lp(l, r[u]);
      if (i[u] == 2) for (let f of h) c.push(f);
      else c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of r) uu(l, c);
      return (l.values[o] = a(l)), 1;
    },
    update(l, c) {
      if (!pv(l, s)) return 0;
      let u = a(l);
      return e.compare(u, l.values[o]) ? 0 : ((l.values[o] = u), 1);
    },
    reconfigure(l, c) {
      let u = pv(l, r),
        h = c.config.facets[e.id],
        f = c.facet(e);
      if (h && !u && Cw(n, h)) return (l.values[o] = f), 0;
      let d = a(l);
      return e.compare(d, f) ? ((l.values[o] = f), 0) : ((l.values[o] = d), 1);
    },
  };
}
const N_ = ye.define({ static: !0 });
class zt {
  constructor(e, n, r, i, s) {
    (this.id = e), (this.createF = n), (this.updateF = r), (this.compareF = i), (this.spec = s), (this.provides = void 0);
  }
  static define(e) {
    let n = new zt(kw++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(N_).find((r) => r.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (r) => ((r.values[n] = this.create(r)), 1),
      update: (r, i) => {
        let s = r.values[n],
          o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : ((r.values[n] = o), 1);
      },
      reconfigure: (r, i) => (i.config.address[this.id] != null ? ((r.values[n] = i.field(this)), 0) : ((r.values[n] = this.create(r)), 1)),
    };
  }
  init(e) {
    return [this, N_.of({ field: this, create: e })];
  }
  get extension() {
    return this;
  }
}
const Ao = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function kc(t) {
  return (e) => new w6(e, t);
}
const ai = { highest: kc(Ao.highest), high: kc(Ao.high), default: kc(Ao.default), low: kc(Ao.low), lowest: kc(Ao.lowest) };
class w6 {
  constructor(e, n) {
    (this.inner = e), (this.prec = n);
  }
}
class rc {
  of(e) {
    return new mv(this, e);
  }
  reconfigure(e) {
    return rc.reconfigure.of({ compartment: this, extension: e });
  }
  get(e) {
    return e.config.compartments.get(this);
  }
}
class mv {
  constructor(e, n) {
    (this.compartment = e), (this.inner = n);
  }
}
class Np {
  constructor(e, n, r, i, s, o) {
    for (
      this.base = e,
        this.compartments = n,
        this.dynamicSlots = r,
        this.address = i,
        this.staticValues = s,
        this.facets = o,
        this.statusTemplate = [];
      this.statusTemplate.length < r.length;

    )
      this.statusTemplate.push(0);
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, r) {
    let i = [],
      s = Object.create(null),
      o = new Map();
    for (let f of Ire(e, n, o)) f instanceof zt ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let a = Object.create(null),
      l = [],
      c = [];
    for (let f of i) (a[f.id] = c.length << 1), c.push((d) => f.slot(d));
    let u = r == null ? void 0 : r.config.facets;
    for (let f in s) {
      let d = s[f],
        p = d[0].facet,
        m = (u && u[f]) || [];
      if (d.every((O) => O.type == 0))
        if (((a[p.id] = (l.length << 1) | 1), Cw(m, d))) l.push(r.facet(p));
        else {
          let O = p.combine(d.map((v) => v.value));
          l.push(r && p.compare(O, r.facet(p)) ? r.facet(p) : O);
        }
      else {
        for (let O of d)
          O.type == 0 ? ((a[O.id] = (l.length << 1) | 1), l.push(O.value)) : ((a[O.id] = c.length << 1), c.push((v) => O.dynamicSlot(v)));
        (a[p.id] = c.length << 1), c.push((O) => Rre(O, p, d));
      }
    }
    let h = c.map((f) => f(a));
    return new Np(e, o, h, a, l, s);
  }
}
function Ire(t, e, n) {
  let r = [[], [], [], [], []],
    i = new Map();
  function s(o, a) {
    let l = i.get(o);
    if (l != null) {
      if (l <= a) return;
      let c = r[l].indexOf(o);
      c > -1 && r[l].splice(c, 1), o instanceof mv && n.delete(o.compartment);
    }
    if ((i.set(o, a), Array.isArray(o))) for (let c of o) s(c, a);
    else if (o instanceof mv) {
      if (n.has(o.compartment)) throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      n.set(o.compartment, c), s(c, a);
    } else if (o instanceof w6) s(o.inner, o.prec);
    else if (o instanceof zt) r[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof Pd) r[a].push(o), o.facet.extensions && s(o.facet.extensions, Ao.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(
          `Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`
        );
      s(c, a);
    }
  }
  return s(t, Ao.default), r.reduce((o, a) => o.concat(a));
}
function uu(t, e) {
  if (e & 1) return 2;
  let n = e >> 1,
    r = t.status[n];
  if (r == 4) throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2) return r;
  t.status[n] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[n]);
  return (t.status[n] = 2 | i);
}
function Lp(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const S6 = ye.define(),
  gv = ye.define({ combine: (t) => t.some((e) => e), static: !0 }),
  k6 = ye.define({ combine: (t) => (t.length ? t[0] : void 0), static: !0 }),
  C6 = ye.define(),
  _6 = ye.define(),
  E6 = ye.define(),
  T6 = ye.define({ combine: (t) => (t.length ? t[0] : !1) });
class Jr {
  constructor(e, n) {
    (this.type = e), (this.value = n);
  }
  static define() {
    return new Nre();
  }
}
class Nre {
  of(e) {
    return new Jr(this, e);
  }
}
class Lre {
  constructor(e) {
    this.map = e;
  }
  of(e) {
    return new Ae(this, e);
  }
}
class Ae {
  constructor(e, n) {
    (this.type = e), (this.value = n);
  }
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new Ae(this.type, n);
  }
  is(e) {
    return this.type == e;
  }
  static define(e = {}) {
    return new Lre(e.map || ((n) => n));
  }
  static mapEffects(e, n) {
    if (!e.length) return e;
    let r = [];
    for (let i of e) {
      let s = i.map(n);
      s && r.push(s);
    }
    return r;
  }
}
Ae.reconfigure = Ae.define();
Ae.appendConfig = Ae.define();
class Gt {
  constructor(e, n, r, i, s, o) {
    (this.startState = e),
      (this.changes = n),
      (this.selection = r),
      (this.effects = i),
      (this.annotations = s),
      (this.scrollIntoView = o),
      (this._doc = null),
      (this._state = null),
      r && y6(r, n.newLength),
      s.some((a) => a.type == Gt.time) || (this.annotations = s.concat(Gt.time.of(Date.now())));
  }
  static create(e, n, r, i, s, o) {
    return new Gt(e, n, r, i, s, o);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(e) {
    for (let n of this.annotations) if (n.type == e) return n.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(e) {
    let n = this.annotation(Gt.userEvent);
    return !!(n && (n == e || (n.length > e.length && n.slice(0, e.length) == e && n[e.length] == ".")));
  }
}
Gt.time = Jr.define();
Gt.userEvent = Jr.define();
Gt.addToHistory = Jr.define();
Gt.remote = Jr.define();
function Mre(t, e) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < t.length && (i == e.length || e[i] >= t[r])) (s = t[r++]), (o = t[r++]);
    else if (i < e.length) (s = e[i++]), (o = e[i++]);
    else return n;
    !n.length || n[n.length - 1] < s ? n.push(s, o) : n[n.length - 1] < o && (n[n.length - 1] = o);
  }
}
function P6(t, e, n) {
  var r;
  let i, s, o;
  return (
    n
      ? ((i = e.changes), (s = qt.empty(e.changes.length)), (o = t.changes.compose(e.changes)))
      : ((i = e.changes.map(t.changes)), (s = t.changes.mapDesc(e.changes, !0)), (o = t.changes.compose(i))),
    {
      changes: o,
      selection: e.selection ? e.selection.map(s) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
      effects: Ae.mapEffects(t.effects, i).concat(Ae.mapEffects(e.effects, s)),
      annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
      scrollIntoView: t.scrollIntoView || e.scrollIntoView,
    }
  );
}
function Ov(t, e, n) {
  let r = e.selection,
    i = sl(e.annotations);
  return (
    e.userEvent && (i = i.concat(Gt.userEvent.of(e.userEvent))),
    {
      changes: e.changes instanceof qt ? e.changes : qt.of(e.changes || [], n, t.facet(k6)),
      selection: r && (r instanceof X ? r : X.single(r.anchor, r.head)),
      effects: sl(e.effects),
      annotations: i,
      scrollIntoView: !!e.scrollIntoView,
    }
  );
}
function A6(t, e, n) {
  let r = Ov(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (n = !1);
    let o = !!e[s].sequential;
    r = P6(r, Ov(t, e[s], o ? r.changes.newLength : t.doc.length), o);
  }
  let i = Gt.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return Qre(n ? Dre(i) : i);
}
function Dre(t) {
  let e = t.startState,
    n = !0;
  for (let i of e.facet(C6)) {
    let s = i(t);
    if (s === !1) {
      n = !1;
      break;
    }
    Array.isArray(s) && (n = n === !0 ? s : Mre(n, s));
  }
  if (n !== !0) {
    let i, s;
    if (n === !1) (s = t.changes.invertedDesc), (i = qt.empty(e.doc.length));
    else {
      let o = t.changes.filter(n);
      (i = o.changes), (s = o.filtered.mapDesc(o.changes).invertedDesc);
    }
    t = Gt.create(e, i, t.selection && t.selection.map(s), Ae.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let r = e.facet(_6);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s instanceof Gt ? (t = s) : Array.isArray(s) && s.length == 1 && s[0] instanceof Gt ? (t = s[0]) : (t = A6(e, sl(s), !1));
  }
  return t;
}
function Qre(t) {
  let e = t.startState,
    n = e.facet(E6),
    r = t;
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s && Object.keys(s).length && (r = P6(r, Ov(e, s, t.changes.newLength), !0));
  }
  return r == t ? t : Gt.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
}
const Fre = [];
function sl(t) {
  return t == null ? Fre : Array.isArray(t) ? t : [t];
}
var Nt = (function (t) {
  return (t[(t.Word = 0)] = "Word"), (t[(t.Space = 1)] = "Space"), (t[(t.Other = 2)] = "Other"), t;
})(Nt || (Nt = {}));
const Vre = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let vv;
try {
  vv = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {}
function Bre(t) {
  if (vv) return vv.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || (n > "" && (n.toUpperCase() != n.toLowerCase() || Vre.test(n)))) return !0;
  }
  return !1;
}
function jre(t) {
  return (e) => {
    if (!/\S/.test(e)) return Nt.Space;
    if (Bre(e)) return Nt.Word;
    for (let n = 0; n < t.length; n++) if (e.indexOf(t[n]) > -1) return Nt.Word;
    return Nt.Other;
  };
}
class Qe {
  constructor(e, n, r, i, s, o) {
    (this.config = e),
      (this.doc = n),
      (this.selection = r),
      (this.values = i),
      (this.status = e.statusTemplate.slice()),
      (this.computeSlot = s),
      o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++) uu(this, a << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (n) throw new RangeError("Field is not present in this state");
      return;
    }
    return uu(this, r), Lp(this, r);
  }
  update(...e) {
    return A6(this, e, !0);
  }
  applyTransaction(e) {
    let n = this.config,
      { base: r, compartments: i } = n;
    for (let a of e.effects)
      a.is(rc.reconfigure)
        ? (n && ((i = new Map()), n.compartments.forEach((l, c) => i.set(c, l)), (n = null)), i.set(a.value.compartment, a.value.extension))
        : a.is(Ae.reconfigure)
        ? ((n = null), (r = a.value))
        : a.is(Ae.appendConfig) && ((n = null), (r = sl(r).concat(a.value)));
    let s;
    n
      ? (s = e.startState.values.slice())
      : ((n = Np.resolve(r, i, this)),
        (s = new Qe(
          n,
          this.doc,
          this.selection,
          n.dynamicSlots.map(() => null),
          (l, c) => c.reconfigure(l, this),
          null
        ).values));
    let o = e.startState.facet(gv) ? e.newSelection : e.newSelection.asSingle();
    new Qe(n, e.newDoc, o, s, (a, l) => l.update(a, e), e);
  }
  replaceSelection(e) {
    return (
      typeof e == "string" && (e = this.toText(e)),
      this.changeByRange((n) => ({ changes: { from: n.from, to: n.to, insert: e }, range: X.cursor(n.from + e.length) }))
    );
  }
  changeByRange(e) {
    let n = this.selection,
      r = e(n.ranges[0]),
      i = this.changes(r.changes),
      s = [r.range],
      o = sl(r.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let l = e(n.ranges[a]),
        c = this.changes(l.changes),
        u = c.map(i);
      for (let f = 0; f < a; f++) s[f] = s[f].map(u);
      let h = i.mapDesc(c, !0);
      s.push(l.range.map(h)), (i = i.compose(u)), (o = Ae.mapEffects(o, u).concat(Ae.mapEffects(sl(l.effects), h)));
    }
    return { changes: i, selection: X.create(s, n.mainIndex), effects: o };
  }
  changes(e = []) {
    return e instanceof qt ? e : qt.of(e, this.doc.length, this.facet(Qe.lineSeparator));
  }
  toText(e) {
    return ot.of(e.split(this.facet(Qe.lineSeparator) || hv));
  }
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (uu(this, n), Lp(this, n));
  }
  toJSON(e) {
    let n = { doc: this.sliceDoc(), selection: this.selection.toJSON() };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof zt && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return n;
  }
  static fromJSON(e, n = {}, r) {
    if (!e || typeof e.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s],
            a = e[s];
          i.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return Qe.create({ doc: e.doc, selection: X.fromJSON(e.selection), extensions: n.extensions ? i.concat([n.extensions]) : i });
  }
  static create(e = {}) {
    let n = Np.resolve(e.extensions || [], new Map()),
      r = e.doc instanceof ot ? e.doc : ot.of((e.doc || "").split(n.staticFacet(Qe.lineSeparator) || hv)),
      i = e.selection ? (e.selection instanceof X ? e.selection : X.single(e.selection.anchor, e.selection.head)) : X.single(0);
    return (
      y6(i, r.length),
      n.staticFacet(gv) || (i = i.asSingle()),
      new Qe(
        n,
        r,
        i,
        n.dynamicSlots.map(() => null),
        (s, o) => o.create(s),
        null
      )
    );
  }
  get tabSize() {
    return this.facet(Qe.tabSize);
  }
  get lineBreak() {
    return (
      this.facet(Qe.lineSeparator) ||
      `
`
    );
  }
  get readOnly() {
    return this.facet(T6);
  }
  phrase(e, ...n) {
    for (let r of this.facet(Qe.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return (
      n.length &&
        (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
          if (i == "$") return "$";
          let s = +(i || 1);
          return !s || s > n.length ? r : n[s - 1];
        })),
      e
    );
  }
  languageDataAt(e, n, r = -1) {
    let i = [];
    for (let s of this.facet(S6)) for (let o of s(this, n, r)) Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  charCategorizer(e) {
    return jre(this.languageDataAt("wordChars", e).join(""));
  }
  wordAt(e) {
    let { text: n, from: r, length: i } = this.doc.lineAt(e),
      s = this.charCategorizer(e),
      o = e - r,
      a = e - r;
    for (; o > 0; ) {
      let l = xn(n, o, !1);
      if (s(n.slice(l, o)) != Nt.Word) break;
      o = l;
    }
    for (; a < i; ) {
      let l = xn(n, a);
      if (s(n.slice(a, l)) != Nt.Word) break;
      a = l;
    }
    return o == a ? null : X.range(o + r, a + r);
  }
}
Qe.allowMultipleSelections = gv;
Qe.tabSize = ye.define({ combine: (t) => (t.length ? t[0] : 4) });
Qe.lineSeparator = k6;
Qe.readOnly = T6;
Qe.phrases = ye.define({
  compare(t, e) {
    let n = Object.keys(t),
      r = Object.keys(e);
    return n.length == r.length && n.every((i) => t[i] == e[i]);
  },
});
Qe.languageData = S6;
Qe.changeFilter = C6;
Qe.transactionFilter = _6;
Qe.transactionExtender = E6;
rc.reconfigure = Ae.define();
function Vi(t, e, n = {}) {
  let r = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let o = i[s],
        a = r[s];
      if (a === void 0) r[s] = o;
      else if (!(a === o || o === void 0))
        if (Object.hasOwnProperty.call(n, s)) r[s] = n[s](a, o);
        else throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e) r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class Go {
  eq(e) {
    return this == e;
  }
  range(e, n = e) {
    return xv.create(e, n, this);
  }
}
Go.prototype.startSide = Go.prototype.endSide = 0;
Go.prototype.point = !1;
Go.prototype.mapMode = On.TrackDel;
let xv = class $6 {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.value = r);
  }
  static create(e, n, r) {
    return new $6(e, n, r);
  }
};
function bv(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
let Zre = class R6 {
  constructor(e, n, r, i) {
    (this.from = e), (this.to = n), (this.value = r), (this.maxPoint = i);
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(e, n, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, a = s.length; ; ) {
      if (o == a) return o;
      let l = (o + a) >> 1,
        c = s[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;
      if (l == o) return c >= 0 ? o : a;
      c >= 0 ? (a = l) : (o = l + 1);
    }
  }
  between(e, n, r, i) {
    for (let s = this.findIndex(n, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1) return !1;
  }
  map(e, n) {
    let r = [],
      i = [],
      s = [],
      o = -1,
      a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l],
        u = this.from[l] + e,
        h = this.to[l] + e,
        f,
        d;
      if (u == h) {
        let p = n.mapPos(u, c.startSide, c.mapMode);
        if (p == null || ((f = d = p), c.startSide != c.endSide && ((d = n.mapPos(u, c.endSide)), d < f))) continue;
      } else if (((f = n.mapPos(u, c.startSide)), (d = n.mapPos(h, c.endSide)), f > d || (f == d && c.startSide > 0 && c.endSide <= 0)))
        continue;
      (d - f || c.endSide - c.startSide) < 0 ||
        (o < 0 && (o = f), c.point && (a = Math.max(a, d - f)), r.push(c), i.push(f - o), s.push(d - o));
    }
    return { mapped: r.length ? new R6(i, s, r, a) : null, pos: o };
  }
};
class Xe {
  constructor(e, n, r, i) {
    (this.chunkPos = e), (this.chunk = n), (this.nextLayer = r), (this.maxPoint = i);
  }
  static create(e, n, r, i) {
    return new Xe(e, n, r, i);
  }
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty) return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk) e += n.value.length;
    return e;
  }
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  update(e) {
    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e,
      o = e.filter;
    if (n.length == 0 && !o) return this;
    if ((r && (n = n.slice().sort(bv)), this.isEmpty)) return n.length ? Xe.of(n) : this;
    let a = new I6(this, null, -1).goto(0),
      l = 0,
      c = [],
      u = new Or();
    for (; a.value || l < n.length; )
      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
        let h = n[l++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else
        a.rangeIndex == 1 &&
        a.chunkIndex < this.chunk.length &&
        (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) &&
        (!o || i > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) &&
        u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex])
          ? a.nextChunk()
          : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) &&
              (u.addInner(a.from, a.to, a.value) || c.push(xv.create(a.from, a.to, a.value))),
            a.next());
    return u.finishInner(
      this.nextLayer.isEmpty && !c.length ? Xe.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s })
    );
  }
  map(e) {
    if (e.empty || this.isEmpty) return this;
    let n = [],
      r = [],
      i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o],
        l = this.chunk[o],
        c = e.touchesRange(a, a + l.length);
      if (c === !1) (i = Math.max(i, l.maxPoint)), n.push(l), r.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: h } = l.map(a, e);
        u && ((i = Math.max(i, u.maxPoint)), n.push(u), r.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return n.length == 0 ? s : new Xe(r, n, s || Xe.empty, i);
  }
  between(e, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i],
          o = this.chunk[i];
        if (n >= s && e <= s + o.length && o.between(s, e - s, n - s, r) === !1) return;
      }
      this.nextLayer.between(e, n, r);
    }
  }
  iter(e = 0) {
    return Vu.from([this]).goto(e);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(e, n = 0) {
    return Vu.from(e).goto(n);
  }
  static compare(e, n, r, i, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || (!h.isEmpty && h.maxPoint >= s)),
      a = n.filter((h) => h.maxPoint > 0 || (!h.isEmpty && h.maxPoint >= s)),
      l = L_(o, a, r),
      c = new Cc(o, l, s),
      u = new Cc(a, l, s);
    r.iterGaps((h, f, d) => M_(c, h, u, f, d, i)), r.empty && r.length == 0 && M_(c, 0, u, 0, 0, i);
  }
  static eq(e, n, r = 0, i) {
    i == null && (i = 1e9 - 1);
    let s = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0),
      o = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length) return !1;
    if (!s.length) return !0;
    let a = L_(s, o),
      l = new Cc(s, a, 0).goto(r),
      c = new Cc(o, a, 0).goto(r);
    for (;;) {
      if (l.to != c.to || !yv(l.active, c.active) || (l.point && (!c.point || !l.point.eq(c.point)))) return !1;
      if (l.to > i) return !0;
      l.next(), c.next();
    }
  }
  static spans(e, n, r, i, s = -1) {
    let o = new Cc(e, null, s).goto(n),
      a = n,
      l = o.openStart;
    for (;;) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to),
          h = o.pointFrom < n ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);
        i.point(a, c, o.point, u, h, o.pointRank), (l = Math.min(o.openEnd(c), u.length));
      } else c > a && (i.span(a, c, o.active, l), (l = o.openEnd(c)));
      if (o.to > r) return l + (o.point && o.to > r ? 1 : 0);
      (a = o.to), o.next();
    }
  }
  static of(e, n = !1) {
    let r = new Or();
    for (let i of e instanceof xv ? [e] : n ? zre(e) : e) r.add(i.from, i.to, i.value);
    return r.finish();
  }
  static join(e) {
    if (!e.length) return Xe.empty;
    let n = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != Xe.empty; i = i.nextLayer) n = new Xe(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
    return n;
  }
}
Xe.empty = new Xe([], [], null, -1);
function zre(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let r = t[n];
      if (bv(e, r) > 0) return t.slice().sort(bv);
      e = r;
    }
  return t;
}
Xe.empty.nextLayer = Xe.empty;
class Or {
  finishChunk(e) {
    this.chunks.push(new Zre(this.from, this.to, this.value, this.maxPoint)),
      this.chunkPos.push(this.chunkStart),
      (this.chunkStart = -1),
      (this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)),
      (this.maxPoint = -1),
      e && ((this.from = []), (this.to = []), (this.value = []));
  }
  constructor() {
    (this.chunks = []),
      (this.chunkPos = []),
      (this.chunkStart = -1),
      (this.last = null),
      (this.lastFrom = -1e9),
      (this.lastTo = -1e9),
      (this.from = []),
      (this.to = []),
      (this.value = []),
      (this.maxPoint = -1),
      (this.setMaxPoint = -1),
      (this.nextLayer = null);
  }
  add(e, n, r) {
    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new Or())).add(e, n, r);
  }
  addInner(e, n, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0
      ? !1
      : (this.from.length == 250 && this.finishChunk(!0),
        this.chunkStart < 0 && (this.chunkStart = e),
        this.from.push(e - this.chunkStart),
        this.to.push(n - this.chunkStart),
        (this.last = r),
        (this.lastFrom = e),
        (this.lastTo = n),
        this.value.push(r),
        r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)),
        !0);
  }
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0) return !1;
    this.from.length && this.finishChunk(!0),
      (this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint)),
      this.chunks.push(n),
      this.chunkPos.push(e);
    let r = n.value.length - 1;
    return (this.last = n.value[r]), (this.lastFrom = n.from[r] + e), (this.lastTo = n.to[r] + e), !0;
  }
  finish() {
    return this.finishInner(Xe.empty);
  }
  finishInner(e) {
    if ((this.from.length && this.finishChunk(!1), this.chunks.length == 0)) return e;
    let n = Xe.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return (this.from = null), n;
  }
}
function L_(t, e, n) {
  let r = new Map();
  for (let s of t) for (let o = 0; o < s.chunk.length; o++) s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = r.get(s.chunk[o]);
      a != null && (n ? n.mapPos(a) : a) == s.chunkPos[o] && !(n != null && n.touchesRange(a, a + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class I6 {
  constructor(e, n, r, i = 0) {
    (this.layer = e), (this.skip = n), (this.minPoint = r), (this.rank = i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return (this.chunkIndex = this.rangeIndex = 0), this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!((this.skip && this.skip.has(i)) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint)) break;
      this.chunkIndex++, (r = !1);
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (;;)
      if (this.chunkIndex == this.layer.chunk.length) {
        (this.from = this.to = 1e9), (this.value = null);
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex],
          n = this.layer.chunk[this.chunkIndex],
          r = e + n.from[this.rangeIndex];
        if (
          ((this.from = r),
          (this.to = e + n.to[this.rangeIndex]),
          (this.value = n.value[this.rangeIndex]),
          this.setRangeIndex(this.rangeIndex + 1),
          this.minPoint < 0 || (this.value.point && this.to - this.from >= this.minPoint))
        )
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if ((this.chunkIndex++, this.skip))
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); ) this.chunkIndex++;
      this.rangeIndex = 0;
    } else this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, (this.rangeIndex = 0), this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Vu {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++) for (let o = e[s]; !o.isEmpty; o = o.nextLayer) o.maxPoint >= r && i.push(new I6(o, n, r, s));
    return i.length == 1 ? i[0] : new Vu(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let r of this.heap) r.goto(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--) Q0(this.heap, r);
    return this.next(), this;
  }
  forward(e, n) {
    for (let r of this.heap) r.forward(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--) Q0(this.heap, r);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0) (this.from = this.to = 1e9), (this.value = null), (this.rank = -1);
    else {
      let e = this.heap[0];
      (this.from = e.from), (this.to = e.to), (this.value = e.value), (this.rank = e.rank), e.value && e.next(), Q0(this.heap, 0);
    }
  }
}
function Q0(t, e) {
  for (let n = t[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= t.length) break;
    let i = t[r];
    if ((r + 1 < t.length && i.compare(t[r + 1]) >= 0 && ((i = t[r + 1]), r++), n.compare(i) < 0)) break;
    (t[r] = n), (t[e] = i), (e = r);
  }
}
class Cc {
  constructor(e, n, r) {
    (this.minPoint = r),
      (this.active = []),
      (this.activeTo = []),
      (this.activeRank = []),
      (this.minActive = -1),
      (this.point = null),
      (this.pointFrom = 0),
      (this.pointRank = 0),
      (this.to = -1e9),
      (this.endSide = 0),
      (this.openStart = -1),
      (this.cursor = Vu.from(e, n, r));
  }
  goto(e, n = -1e9) {
    return (
      this.cursor.goto(e, n),
      (this.active.length = this.activeTo.length = this.activeRank.length = 0),
      (this.minActive = -1),
      (this.to = e),
      (this.endSide = n),
      (this.openStart = -1),
      this.next(),
      this
    );
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    If(this.active, e), If(this.activeTo, e), If(this.activeRank, e), (this.minActive = D_(this.active, this.activeTo));
  }
  addActive(e) {
    let n = 0,
      { value: r, to: i, rank: s } = this.cursor;
    for (; n < this.activeRank.length && (s - this.activeRank[n] || i - this.activeTo[n]) > 0; ) n++;
    Nf(this.active, n, r),
      Nf(this.activeTo, n, i),
      Nf(this.activeRank, n, s),
      e && Nf(e, n, this.cursor.from),
      (this.minActive = D_(this.active, this.activeTo));
  }
  next() {
    let e = this.to,
      n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (;;) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          (this.to = this.activeTo[i]), (this.endSide = this.active[i].endSide);
          break;
        }
        this.removeActive(i), r && If(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          (this.to = this.cursor.from), (this.endSide = this.cursor.startSide);
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point) this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to) this.cursor.next();
          else {
            (this.point = s),
              (this.pointFrom = this.cursor.from),
              (this.pointRank = this.cursor.rank),
              (this.to = this.cursor.to),
              (this.endSide = s.endSide),
              this.cursor.next(),
              this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--) this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length) return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || (this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide)) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--) n++;
    return n;
  }
}
function M_(t, e, n, r, i, s) {
  t.goto(e), n.goto(r);
  let o = r + i,
    a = r,
    l = r - e;
  for (;;) {
    let c = t.to + l - n.to || t.endSide - n.endSide,
      u = c < 0 ? t.to + l : n.to,
      h = Math.min(u, o);
    if (
      (t.point || n.point
        ? (t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && yv(t.activeForPoint(t.to), n.activeForPoint(n.to))) ||
          s.comparePoint(a, h, t.point, n.point)
        : h > a && !yv(t.active, n.active) && s.compareRange(a, h, t.active, n.active),
      u > o)
    )
      break;
    (a = u), c <= 0 && t.next(), c >= 0 && n.next();
  }
}
function yv(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) if (t[n] != e[n] && !t[n].eq(e[n])) return !1;
  return !0;
}
function If(t, e) {
  for (let n = e, r = t.length - 1; n < r; n++) t[n] = t[n + 1];
  t.pop();
}
function Nf(t, e, n) {
  for (let r = t.length - 1; r >= e; r--) t[r + 1] = t[r];
  t[e] = n;
}
function D_(t, e) {
  let n = -1,
    r = 1e9;
  for (let i = 0; i < e.length; i++) (e[i] - r || t[i].endSide - t[n].endSide) < 0 && ((n = i), (r = e[i]));
  return n;
}
function Kr(t, e, n = t.length) {
  let r = 0;
  for (let i = 0; i < n; ) t.charCodeAt(i) == 9 ? ((r += e - (r % e)), i++) : (r++, (i = xn(t, i)));
  return r;
}
function wv(t, e, n, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e) return i;
    if (i == t.length) break;
    (s += t.charCodeAt(i) == 9 ? n - (s % n) : 1), (i = xn(t, i));
  }
  return r === !0 ? -1 : t.length;
}
const Sv = "ͼ",
  Q_ = typeof Symbol > "u" ? "__" + Sv : Symbol.for(Sv),
  kv = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"),
  F_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class ds {
  constructor(e, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, c) {
      let u = [],
        h = /^@(\w+)\b/.exec(o[0]),
        f = h && h[1] == "keyframes";
      if (h && a == null) return l.push(o[0] + ";");
      for (let d in a) {
        let p = a[d];
        if (/&/.test(d))
          s(
            d
              .split(/,\s*/)
              .map((m) => o.map((O) => m.replace(/&/, O)))
              .reduce((m, O) => m.concat(O)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!h) throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(i(d), p, u, f);
        } else p != null && u.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || f) && l.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let e = F_[Q_] || 1;
    return (F_[Q_] = e + 1), Sv + e.toString(36);
  }
  static mount(e, n, r) {
    let i = e[kv],
      s = r && r.nonce;
    i ? s && i.setNonce(s) : (i = new Wre(e, s)), i.mount(Array.isArray(n) ? n : [n], e);
  }
}
let V_ = new Map();
class Wre {
  constructor(e, n) {
    let r = e.ownerDocument || e,
      i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = V_.get(r);
      if (s) return (e[kv] = s);
      (this.sheet = new i.CSSStyleSheet()), V_.set(r, this);
    } else (this.styleTag = r.createElement("style")), n && this.styleTag.setAttribute("nonce", n);
    (this.modules = []), (e[kv] = this);
  }
  mount(e, n) {
    let r = this.sheet,
      i = 0,
      s = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o],
        l = this.modules.indexOf(a);
      if ((l < s && l > -1 && (this.modules.splice(l, 1), s--, (l = -1)), l == -1)) {
        if ((this.modules.splice(s++, 0, a), r)) for (let c = 0; c < a.rules.length; c++) r.insertRule(a.rules[c], i++);
      } else {
        for (; s < l; ) i += this.modules[s++].rules.length;
        (i += a.rules.length), s++;
      }
    }
    if (r) n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let o = "";
      for (let l = 0; l < this.modules.length; l++)
        o +=
          this.modules[l].getRules() +
          `
`;
      this.styleTag.textContent = o;
      let a = n.head || n;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var io = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
  },
  Bu = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
  },
  Ure = typeof navigator < "u" && /Mac/.test(navigator.platform),
  Xre = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var gn = 0; gn < 10; gn++) io[48 + gn] = io[96 + gn] = String(gn);
for (var gn = 1; gn <= 24; gn++) io[gn + 111] = "F" + gn;
for (var gn = 65; gn <= 90; gn++) (io[gn] = String.fromCharCode(gn + 32)), (Bu[gn] = String.fromCharCode(gn));
for (var F0 in io) Bu.hasOwnProperty(F0) || (Bu[F0] = io[F0]);
function Hre(t) {
  var e =
      (Ure && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
      (Xre && t.shiftKey && t.key && t.key.length == 1) ||
      t.key == "Unidentified",
    n = (!e && t.key) || (t.shiftKey ? Bu : io)[t.keyCode] || t.key || "Unidentified";
  return (
    n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
  );
}
function ju(t) {
  let e;
  return t.nodeType == 11 ? (e = t.getSelection ? t : t.ownerDocument) : (e = t), e.getSelection();
}
function Cv(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function qre(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
  return e;
}
function Ad(t, e) {
  if (!e.anchorNode) return !1;
  try {
    return Cv(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Zu(t) {
  return t.nodeType == 3 ? Ko(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function hu(t, e, n, r) {
  return n ? B_(t, e, n, r, -1) || B_(t, e, n, r, 1) : !1;
}
function Jo(t) {
  for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
}
function Mp(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function B_(t, e, n, r, i) {
  for (;;) {
    if (t == n && e == r) return !0;
    if (e == (i < 0 ? 0 : ps(t))) {
      if (t.nodeName == "DIV") return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1) return !1;
      (e = Jo(t) + (i < 0 ? 0 : 1)), (t = s);
    } else if (t.nodeType == 1) {
      if (((t = t.childNodes[e + (i < 0 ? -1 : 0)]), t.nodeType == 1 && t.contentEditable == "false")) return !1;
      e = i < 0 ? ps(t) : 0;
    } else return !1;
  }
}
function ps(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function _w(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function Yre(t) {
  let e = t.visualViewport;
  return e ? { left: 0, right: e.width, top: 0, bottom: e.height } : { left: 0, right: t.innerWidth, top: 0, bottom: t.innerHeight };
}
function N6(t, e) {
  let n = e.width / t.offsetWidth,
    r = e.height / t.offsetHeight;
  return (
    ((n > 0.995 && n < 1.005) || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1),
    ((r > 0.995 && r < 1.005) || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1),
    { scaleX: n, scaleY: r }
  );
}
function Gre(t, e, n, r, i, s, o, a) {
  let l = t.ownerDocument,
    c = l.defaultView || window;
  for (let u = t, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let f,
        d = u == l.body,
        p = 1,
        m = 1;
      if (d) f = Yre(c);
      else {
        if (
          (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0),
          u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth)
        ) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let g = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = N6(u, g)),
          (f = { left: g.left, right: g.left + u.clientWidth * p, top: g.top, bottom: g.top + u.clientHeight * m });
      }
      let O = 0,
        v = 0;
      if (i == "nearest")
        e.top < f.top
          ? ((v = -(f.top - e.top + o)), n > 0 && e.bottom > f.bottom + v && (v = e.bottom - f.bottom + v + o))
          : e.bottom > f.bottom && ((v = e.bottom - f.bottom + o), n < 0 && e.top - v < f.top && (v = -(f.top + v - e.top + o)));
      else {
        let g = e.bottom - e.top,
          x = f.bottom - f.top;
        v =
          (i == "center" && g <= x ? e.top + g / 2 - x / 2 : i == "start" || (i == "center" && n < 0) ? e.top - o : e.bottom - x + o) -
          f.top;
      }
      if (
        (r == "nearest"
          ? e.left < f.left
            ? ((O = -(f.left - e.left + s)), n > 0 && e.right > f.right + O && (O = e.right - f.right + O + s))
            : e.right > f.right && ((O = e.right - f.right + s), n < 0 && e.left < f.left + O && (O = -(f.left + O - e.left + s)))
          : (O =
              (r == "center"
                ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2
                : (r == "start") == a
                ? e.left - s
                : e.right - (f.right - f.left) + s) - f.left),
        O || v)
      )
        if (d) c.scrollBy(O, v);
        else {
          let g = 0,
            x = 0;
          if (v) {
            let y = u.scrollTop;
            (u.scrollTop += v / m), (x = (u.scrollTop - y) * m);
          }
          if (O) {
            let y = u.scrollLeft;
            (u.scrollLeft += O / p), (g = (u.scrollLeft - y) * p);
          }
          (e = { left: e.left - g, top: e.top - x, right: e.right - g, bottom: e.bottom - x }),
            g && Math.abs(g - O) < 1 && (r = "nearest"),
            x && Math.abs(x - v) < 1 && (i = "nearest");
        }
      if (d) break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11) u = u.host;
    else break;
}
function Jre(t) {
  let e = t.ownerDocument;
  for (let n = t.parentNode; n && n != e.body; )
    if (n.nodeType == 1) {
      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth) return n;
      n = n.assignedSlot || n.parentNode;
    } else if (n.nodeType == 11) n = n.host;
    else break;
  return null;
}
class Kre {
  constructor() {
    (this.anchorNode = null), (this.anchorOffset = 0), (this.focusNode = null), (this.focusOffset = 0);
  }
  eq(e) {
    return (
      this.anchorNode == e.anchorNode &&
      this.anchorOffset == e.anchorOffset &&
      this.focusNode == e.focusNode &&
      this.focusOffset == e.focusOffset
    );
  }
  setRange(e) {
    let { anchorNode: n, focusNode: r } = e;
    this.set(n, Math.min(e.anchorOffset, n ? ps(n) : 0), r, Math.min(e.focusOffset, r ? ps(r) : 0));
  }
  set(e, n, r, i) {
    (this.anchorNode = e), (this.anchorOffset = n), (this.focusNode = r), (this.focusOffset = i);
  }
}
let Ca = null;
function L6(t) {
  if (t.setActive) return t.setActive();
  if (Ca) return t.focus(Ca);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode);
  if (
    (t.focus(
      Ca == null
        ? {
            get preventScroll() {
              return (Ca = { preventScroll: !0 }), !0;
            },
          }
        : void 0
    ),
    !Ca)
  ) {
    Ca = !1;
    for (let n = 0; n < e.length; ) {
      let r = e[n++],
        i = e[n++],
        s = e[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let j_;
function Ko(t, e, n = e) {
  let r = j_ || (j_ = document.createRange());
  return r.setEnd(t, n), r.setStart(t, e), r;
}
function ol(t, e, n, r) {
  let i = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let s = new KeyboardEvent("keydown", i);
  (s.synthetic = !0), t.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", i);
  return (o.synthetic = !0), t.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function eie(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || (t.nodeType == 11 && t.host))) return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function M6(t) {
  for (; t.attributes.length; ) t.removeAttributeNode(t.attributes[0]);
}
function tie(t, e) {
  let n = e.focusNode,
    r = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != r) return !1;
  for (r = Math.min(r, ps(n)); ; )
    if (r) {
      if (n.nodeType != 1) return !1;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : ((n = i), (r = ps(n)));
    } else {
      if (n == t) return !0;
      (r = Jo(n)), (n = n.parentNode);
    }
}
function D6(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function Q6(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r > 0) return { node: n, offset: r };
    if (n.nodeType == 1 && r > 0) {
      if (n.contentEditable == "false") return null;
      (n = n.childNodes[r - 1]), (r = ps(n));
    } else if (n.parentNode && !Mp(n)) (r = Jo(n)), (n = n.parentNode);
    else return null;
  }
}
function F6(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r < n.nodeValue.length) return { node: n, offset: r };
    if (n.nodeType == 1 && r < n.childNodes.length) {
      if (n.contentEditable == "false") return null;
      (n = n.childNodes[r]), (r = 0);
    } else if (n.parentNode && !Mp(n)) (r = Jo(n) + 1), (n = n.parentNode);
    else return null;
  }
}
class Cn {
  constructor(e, n, r = !0) {
    (this.node = e), (this.offset = n), (this.precise = r);
  }
  static before(e, n) {
    return new Cn(e.parentNode, Jo(e), n);
  }
  static after(e, n) {
    return new Cn(e.parentNode, Jo(e) + 1, n);
  }
}
const Ew = [];
class xt {
  constructor() {
    (this.parent = null), (this.dom = null), (this.flags = 2);
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == e) return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let r = this.dom,
        i = null,
        s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let a = xt.get(s);
            (!a || (!a.parent && a.canReuseDOM(o))) && o.reuseDOM(s);
          }
          o.sync(e, n), (o.flags &= -8);
        }
        if (
          ((s = i ? i.nextSibling : r.firstChild), n && !n.written && n.node == r && s != o.dom && (n.written = !0), o.dom.parentNode == r)
        )
          for (; s && s != o.dom; ) s = Z_(s);
        else r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && n && n.node == r && (n.written = !0); s; ) s = Z_(s);
    } else if (this.flags & 1) for (let r of this.children) r.flags & 7 && (r.sync(e, n), (r.flags &= -8));
  }
  reuseDOM(e) {}
  localPosFromDOM(e, n) {
    let r;
    if (e == this.dom) r = this.dom.childNodes[n];
    else {
      let i = ps(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (;;) {
        let s = e.parentNode;
        if (s == this.dom) break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? (i = -1) : (i = 1)), (e = s);
      }
      i < 0 ? (r = e) : (r = e.nextSibling);
    }
    if (r == this.dom.firstChild) return 0;
    for (; r && !xt.get(r); ) r = r.nextSibling;
    if (!r) return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r) return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, n, r = 0) {
    let i = -1,
      s = -1,
      o = -1,
      a = -1;
    for (let l = 0, c = r, u = r; l < this.children.length; l++) {
      let h = this.children[l],
        f = c + h.length;
      if (c < e && f > n) return h.domBoundsAround(e, n, c);
      if ((f >= e && i == -1 && ((i = l), (s = c)), c > n && h.dom.parentNode == this.dom)) {
        (o = l), (a = u);
        break;
      }
      (u = f), (c = f + h.breakAfter);
    }
    return {
      from: s,
      to: a < 0 ? r + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null,
    };
  }
  markDirty(e = !1) {
    (this.flags |= 2), this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if ((e && (n.flags |= 2), n.flags & 1)) return;
      (n.flags |= 1), (e = !1);
    }
  }
  setParent(e) {
    this.parent != e && ((this.parent = e), this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), (this.dom = e), (e.cmView = this));
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n) return e;
      e = n;
    }
  }
  replaceChildren(e, n, r = Ew) {
    this.markDirty();
    for (let i = e; i < n; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, n - e, ...r);
    for (let i = 0; i < r.length; i++) r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new V6(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return (
      e +
      (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") +
      (this.breakAfter ? "#" : "")
    );
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children) e.parent == this && e.destroy();
    this.parent = null;
  }
}
xt.prototype.breakAfter = 0;
function Z_(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class V6 {
  constructor(e, n, r) {
    (this.children = e), (this.pos = n), (this.i = r), (this.off = 0);
  }
  findPos(e, n = 1) {
    for (;;) {
      if (e > this.pos || (e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)))
        return (this.off = e - this.pos), this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function B6(t, e, n, r, i, s, o, a, l) {
  let { children: c } = t,
    u = c.length ? c[e] : null,
    h = s.length ? s[s.length - 1] : null,
    f = h ? h.breakAfter : o;
  if (!(e == r && u && !o && !f && s.length < 2 && u.merge(n, i, s.length ? h : null, n == 0, a, l))) {
    if (r < c.length) {
      let d = c[r];
      d && (i < d.length || (d.breakAfter && h != null && h.breakAfter))
        ? (e == r && ((d = d.split(i)), (i = 0)),
          !f && h && d.merge(0, i, h, !0, 0, l)
            ? (s[s.length - 1] = d)
            : ((i || (d.children.length && !d.children[0].length)) && d.merge(0, i, null, !1, 0, l), s.push(d)))
        : d != null && d.breakAfter && (h ? (h.breakAfter = 1) : (o = 1)),
        r++;
    }
    for (
      u &&
      ((u.breakAfter = o),
      n > 0 &&
        (!o && s.length && u.merge(n, u.length, s[0], !1, a, 0)
          ? (u.breakAfter = s.shift().breakAfter)
          : (n < u.length || (u.children.length && u.children[u.children.length - 1].length == 0)) && u.merge(n, u.length, null, !1, a, 0),
        e++));
      e < r && s.length;

    )
      if (c[r - 1].become(s[s.length - 1])) r--, s.pop(), (l = s.length ? 0 : a);
      else if (c[e].become(s[0])) e++, s.shift(), (a = s.length ? 0 : l);
      else break;
    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, a, l) && e--,
      (e < r || s.length) && t.replaceChildren(e, r, s);
  }
}
function j6(t, e, n, r, i, s) {
  let o = t.childCursor(),
    { i: a, off: l } = o.findPos(n, 1),
    { i: c, off: u } = o.findPos(e, -1),
    h = e - n;
  for (let f of r) h += f.length;
  (t.length += h), B6(t, c, u, a, l, r, 0, i, s);
}
let qn = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" },
  _v = typeof document < "u" ? document : { documentElement: { style: {} } };
const Ev = /Edge\/(\d+)/.exec(qn.userAgent),
  Z6 = /MSIE \d/.test(qn.userAgent),
  Tv = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(qn.userAgent),
  wg = !!(Z6 || Tv || Ev),
  z_ = !wg && /gecko\/(\d+)/i.test(qn.userAgent),
  V0 = !wg && /Chrome\/(\d+)/.exec(qn.userAgent),
  W_ = "webkitFontSmoothing" in _v.documentElement.style,
  z6 = !wg && /Apple Computer/.test(qn.vendor),
  U_ = z6 && (/Mobile\/\w+/.test(qn.userAgent) || qn.maxTouchPoints > 2);
var be = {
  mac: U_ || /Mac/.test(qn.platform),
  windows: /Win/.test(qn.platform),
  linux: /Linux|X11/.test(qn.platform),
  ie: wg,
  ie_version: Z6 ? _v.documentMode || 6 : Tv ? +Tv[1] : Ev ? +Ev[1] : 0,
  gecko: z_,
  gecko_version: z_ ? +(/Firefox\/(\d+)/.exec(qn.userAgent) || [0, 0])[1] : 0,
  chrome: !!V0,
  chrome_version: V0 ? +V0[1] : 0,
  ios: U_,
  android: /Android\b/.test(qn.userAgent),
  webkit: W_,
  safari: z6,
  webkit_version: W_ ? +(/\bAppleWebKit\/(\d+)/.exec(qn.userAgent) || [0, 0])[1] : 0,
  tabSize: _v.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size",
};
const nie = 256;
class ei extends xt {
  constructor(e) {
    super(), (this.text = e);
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(),
      this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), (this.dom.nodeValue = this.text));
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, r) {
    return this.flags & 8 || (r && (!(r instanceof ei) || this.length - (n - e) + r.length > nie || r.flags & 8))
      ? !1
      : ((this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n)), this.markDirty(), !0);
  }
  split(e) {
    let n = new ei(this.text.slice(e));
    return (this.text = this.text.slice(0, e)), this.markDirty(), (n.flags |= this.flags & 8), n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Cn(this.dom, e);
  }
  domBoundsAround(e, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return rie(this.dom, e, n);
  }
}
class ms extends xt {
  constructor(e, n = [], r = 0) {
    super(), (this.mark = e), (this.children = n), (this.length = r);
    for (let i of n) i.setParent(this);
  }
  setAttrs(e) {
    if ((M6(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs))
      for (let n in this.mark.attrs) e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
      super.sync(e, n);
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof ms && r.mark.eq(this.mark)) || (e && s <= 0) || (n < this.length && o <= 0))
      ? !1
      : (j6(this, e, n, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [],
      r = 0,
      i = -1,
      s = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > e && n.push(r < e ? a.split(e - r) : a), i < 0 && r >= e && (i = s), (r = l), s++;
    }
    let o = this.length - e;
    return (this.length = e), i > -1 && ((this.children.length = i), this.markDirty()), new ms(this.mark, n, o);
  }
  domAtPos(e) {
    return W6(this, e);
  }
  coordsAt(e, n) {
    return X6(this, e, n);
  }
}
function rie(t, e, n) {
  let r = t.nodeValue.length;
  e > r && (e = r);
  let i = e,
    s = e,
    o = 0;
  (e == 0 && n < 0) || (e == r && n >= 0)
    ? be.chrome || be.gecko || (e ? (i--, (o = 1)) : s < r && (s++, (o = -1)))
    : n < 0
    ? i--
    : s < r && s++;
  let a = Ko(t, i, s).getClientRects();
  if (!a.length) return null;
  let l = a[(o ? o < 0 : n >= 0) ? 0 : a.length - 1];
  return be.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? _w(l, o < 0) : l || null;
}
class Vs extends xt {
  static create(e, n, r) {
    return new Vs(e, n, r);
  }
  constructor(e, n, r) {
    super(), (this.widget = e), (this.length = n), (this.side = r), (this.prevWidget = null);
  }
  split(e) {
    let n = Vs.create(this.widget, this.length - e, this.side);
    return (this.length -= e), n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof Vs) || !this.widget.compare(r.widget) || (e > 0 && s <= 0) || (n < this.length && o <= 0))
      ? !1
      : ((this.length = e + (r ? r.length : 0) + (this.length - n)), !0);
  }
  become(e) {
    return e instanceof Vs && e.side == this.side && this.widget.constructor == e.widget.constructor
      ? (this.widget.compare(e.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0) return ot.empty;
    let e = this;
    for (; e.parent; ) e = e.parent;
    let { view: n } = e,
      r = n && n.state.doc,
      i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : ot.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Cn.before(this.dom) : Cn.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    if (r) return r;
    let i = this.dom.getClientRects(),
      s = null;
    if (!i.length) return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? i.length - 1 : 0; (s = i[a]), !(e > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom); a += o ? -1 : 1);
    return _w(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class kl extends xt {
  constructor(e) {
    super(), (this.side = e);
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof kl && e.side == this.side;
  }
  split() {
    return new kl(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      (e.className = "cm-widgetBuffer"), e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Cn.before(this.dom) : Cn.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return ot.empty;
  }
  get isHidden() {
    return !0;
  }
}
ei.prototype.children = Vs.prototype.children = kl.prototype.children = Ew;
function W6(t, e) {
  let n = t.dom,
    { children: r } = t,
    i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i],
      a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == n) return o.domAtPos(e - s);
      if (e <= s) break;
      s = a;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == n) return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == n) return o.domAtPos(0);
  }
  return new Cn(n, 0);
}
function U6(t, e, n) {
  let r,
    { children: i } = t;
  n > 0 && e instanceof ms && i.length && (r = i[i.length - 1]) instanceof ms && r.mark.eq(e.mark)
    ? U6(r, e.children[0], n - 1)
    : (i.push(e), e.setParent(t)),
    (t.length += e.length);
}
function X6(t, e, n) {
  let r = null,
    i = -1,
    s = null,
    o = -1;
  function a(c, u) {
    for (let h = 0, f = 0; h < c.children.length && f <= u; h++) {
      let d = c.children[h],
        p = f + d.length;
      p >= u &&
        (d.children.length
          ? a(d, u - f)
          : (!s || (s.isHidden && n > 0)) && (p > u || (f == p && d.getSide() > 0))
          ? ((s = d), (o = u - f))
          : (f < u || (f == p && d.getSide() < 0 && !d.isHidden)) && ((r = d), (i = u - f))),
        (f = p);
    }
  }
  a(t, e);
  let l = (n < 0 ? r : s) || r || s;
  return l ? l.coordsAt(Math.max(0, l == r ? i : o), n) : iie(t);
}
function iie(t) {
  let e = t.dom.lastChild;
  if (!e) return t.dom.getBoundingClientRect();
  let n = Zu(e);
  return n[n.length - 1] || null;
}
function Pv(t, e) {
  for (let n in t)
    n == "class" && e.class ? (e.class += " " + t.class) : n == "style" && e.style ? (e.style += ";" + t.style) : (e[n] = t[n]);
  return e;
}
const X_ = Object.create(null);
function Dp(t, e, n) {
  if (t == e) return !0;
  t || (t = X_), e || (e = X_);
  let r = Object.keys(t),
    i = Object.keys(e);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0)) return !1;
  for (let s of r) if (s != n && (i.indexOf(s) == -1 || t[s] !== e[s])) return !1;
  return !0;
}
function Av(t, e, n) {
  let r = !1;
  if (e) for (let i in e) (n && i in n) || ((r = !0), i == "style" ? (t.style.cssText = "") : t.removeAttribute(i));
  if (n) for (let i in n) (e && e[i] == n[i]) || ((r = !0), i == "style" ? (t.style.cssText = n[i]) : t.setAttribute(i, n[i]));
  return r;
}
function sie(t) {
  let e = Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let r = t.attributes[n];
    e[r.name] = r.value;
  }
  return e;
}
class Xt extends xt {
  constructor() {
    super(...arguments), (this.children = []), (this.length = 0), (this.prevAttrs = void 0), (this.attrs = null), (this.breakAfter = 0);
  }
  merge(e, n, r, i, s, o) {
    if (r) {
      if (!(r instanceof Xt)) return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), j6(this, e, n, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let n = new Xt();
    if (((n.breakAfter = this.breakAfter), this.length == 0)) return n;
    let { i: r, off: i } = this.childPos(e);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++) n.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; ) this.children[--r].destroy();
    return (this.children.length = r), this.markDirty(), (this.length = e), n;
  }
  transferDOM(e) {
    this.dom &&
      (this.markDirty(),
      e.setDOM(this.dom),
      (e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs),
      (this.prevAttrs = void 0),
      (this.dom = null));
  }
  setDeco(e) {
    Dp(this.attrs, e) || (this.dom && ((this.prevAttrs = this.attrs), this.markDirty()), (this.attrs = e));
  }
  append(e, n) {
    U6(this, e, n);
  }
  addLineDeco(e) {
    let n = e.spec.attributes,
      r = e.spec.class;
    n && (this.attrs = Pv(n, this.attrs || {})), r && (this.attrs = Pv({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return W6(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, n) {
    var r;
    this.dom
      ? this.flags & 4 && (M6(this.dom), (this.dom.className = "cm-line"), (this.prevAttrs = this.attrs ? null : void 0))
      : (this.setDOM(document.createElement("div")), (this.dom.className = "cm-line"), (this.prevAttrs = this.attrs ? null : void 0)),
      this.prevAttrs !== void 0 && (Av(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), (this.prevAttrs = void 0)),
      super.sync(e, n);
    let i = this.dom.lastChild;
    for (; i && xt.get(i) instanceof ms; ) i = i.lastChild;
    if (
      !i ||
      !this.length ||
      (i.nodeName != "BR" &&
        ((r = xt.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 &&
        (!be.ios || !this.children.some((s) => s instanceof ei)))
    ) {
      let s = document.createElement("BR");
      (s.cmIgnore = !0), this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null;
    let e = 0,
      n;
    for (let r of this.children) {
      if (!(r instanceof ei) || /[^ -~]/.test(r.text)) return null;
      let i = Zu(r.dom);
      if (i.length != 1) return null;
      (e += i[0].width), (n = i[0].height);
    }
    return e ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: e / this.length, textHeight: n } : null;
  }
  coordsAt(e, n) {
    let r = X6(this, e, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState,
        s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return (
      e instanceof Xt && this.children.length == 0 && e.children.length == 0 && Dp(this.attrs, e.attrs) && this.breakAfter == e.breakAfter
    );
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r],
        o = i + s.length;
      if (o >= n) {
        if (s instanceof Xt) return s;
        if (o > n) break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class rs extends xt {
  constructor(e, n, r) {
    super(), (this.widget = e), (this.length = n), (this.deco = r), (this.breakAfter = 0), (this.prevWidget = null);
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof rs) || !this.widget.compare(r.widget) || (e > 0 && s <= 0) || (n < this.length && o <= 0))
      ? !1
      : ((this.length = e + (r ? r.length : 0) + (this.length - n)), !0);
  }
  domAtPos(e) {
    return e == 0 ? Cn.before(this.dom) : Cn.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let r = new rs(this.widget, n, this.deco);
    return (r.breakAfter = this.breakAfter), r;
  }
  get children() {
    return Ew;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ot.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof rs && e.widget.constructor == this.widget.constructor
      ? (e.widget.compare(this.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        (this.deco = e.deco),
        (this.breakAfter = e.breakAfter),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    return this.widget.coordsAt(this.dom, e, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : e < 0 ? n < 0 : r > 0;
  }
}
class li {
  eq(e) {
    return !1;
  }
  updateDOM(e, n) {
    return !1;
  }
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(e) {
    return !0;
  }
  coordsAt(e, n, r) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  get editable() {
    return !1;
  }
  destroy(e) {}
}
var Fn = (function (t) {
  return (
    (t[(t.Text = 0)] = "Text"),
    (t[(t.WidgetBefore = 1)] = "WidgetBefore"),
    (t[(t.WidgetAfter = 2)] = "WidgetAfter"),
    (t[(t.WidgetRange = 3)] = "WidgetRange"),
    t
  );
})(Fn || (Fn = {}));
class ge extends Go {
  constructor(e, n, r, i) {
    super(), (this.startSide = e), (this.endSide = n), (this.widget = r), (this.spec = i);
  }
  get heightRelevant() {
    return !1;
  }
  static mark(e) {
    return new tf(e);
  }
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)),
      r = !!e.block;
    return (n += r && !e.inlineOrder ? (n > 0 ? 3e8 : -4e8) : n > 0 ? 1e8 : -1e8), new so(e, n, n, r, e.widget || null, !1);
  }
  static replace(e) {
    let n = !!e.block,
      r,
      i;
    if (e.isBlockGap) (r = -5e8), (i = 4e8);
    else {
      let { start: s, end: o } = H6(e, n);
      (r = (s ? (n ? -3e8 : -1) : 5e8) - 1), (i = (o ? (n ? 2e8 : 1) : -6e8) + 1);
    }
    return new so(e, r, i, n, e.widget || null, !0);
  }
  static line(e) {
    return new nf(e);
  }
  static set(e, n = !1) {
    return Xe.of(e, n);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ge.none = Xe.empty;
class tf extends ge {
  constructor(e) {
    let { start: n, end: r } = H6(e);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e),
      (this.tagName = e.tagName || "span"),
      (this.class = e.class || ""),
      (this.attrs = e.attributes || null);
  }
  eq(e) {
    var n, r;
    return (
      this == e ||
      (e instanceof tf &&
        this.tagName == e.tagName &&
        (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) ==
          (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) &&
        Dp(this.attrs, e.attrs, "class"))
    );
  }
  range(e, n = e) {
    if (e >= n) throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
tf.prototype.point = !1;
class nf extends ge {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof nf && this.spec.class == e.spec.class && Dp(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e) throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
nf.prototype.mapMode = On.TrackBefore;
nf.prototype.point = !0;
class so extends ge {
  constructor(e, n, r, i, s, o) {
    super(n, r, s, e), (this.block = i), (this.isReplace = o), (this.mapMode = i ? (n <= 0 ? On.TrackBefore : On.TrackAfter) : On.TrackDel);
  }
  get type() {
    return this.startSide != this.endSide ? Fn.WidgetRange : this.startSide <= 0 ? Fn.WidgetBefore : Fn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || (!!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0));
  }
  eq(e) {
    return (
      e instanceof so && oie(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide
    );
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || (e == n && this.startSide > 0 && this.endSide <= 0)))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e) throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
so.prototype.point = !0;
function H6(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = t;
  return n == null && (n = t.inclusive), r == null && (r = t.inclusive), { start: n ?? e, end: r ?? e };
}
function oie(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function $v(t, e, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= t ? (n[i] = Math.max(n[i], e)) : n.push(t, e);
}
class fu {
  constructor(e, n, r, i) {
    (this.doc = e),
      (this.pos = n),
      (this.end = r),
      (this.disallowBlockEffectsFor = i),
      (this.content = []),
      (this.curLine = null),
      (this.breakAtStart = 0),
      (this.pendingBuffer = 0),
      (this.bufferMarks = []),
      (this.atCursorPos = !0),
      (this.openStart = -1),
      (this.openEnd = -1),
      (this.text = ""),
      (this.textOff = 0),
      (this.cursor = e.iter()),
      (this.skip = n);
  }
  posCovered() {
    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || (e instanceof rs && e.deco.endSide < 0));
  }
  getLine() {
    return this.curLine || (this.content.push((this.curLine = new Xt())), (this.atCursorPos = !0)), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Lf(new kl(-1), e), e.length), (this.pendingBuffer = 0));
  }
  addBlockWidget(e) {
    this.flushBuffer(), (this.curLine = null), this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : (this.pendingBuffer = 0),
      !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof rs) && this.getLine();
  }
  buildText(e, n, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (((this.skip = 0), a)) throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(),
            this.content.length ? (this.content[this.content.length - 1].breakAfter = 1) : (this.breakAtStart = 1),
            this.flushBuffer(),
            (this.curLine = null),
            (this.atCursorPos = !0),
            e--;
          continue;
        } else (this.text = s), (this.textOff = 0);
      }
      let i = Math.min(this.text.length - this.textOff, e, 512);
      this.flushBuffer(n.slice(n.length - r)),
        this.getLine().append(Lf(new ei(this.text.slice(this.textOff, this.textOff + i)), n), r),
        (this.atCursorPos = !0),
        (this.textOff += i),
        (e -= i),
        (r = 0);
    }
  }
  span(e, n, r, i) {
    this.buildText(n - e, r, i), (this.pos = n), this.openStart < 0 && (this.openStart = i);
  }
  point(e, n, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof so) {
      if (r.block) throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - e;
    if (r instanceof so)
      if (r.block) r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new rs(r.widget || Cl.block, a, r));
      else {
        let l = Vs.create(r.widget || Cl.inline, a, a ? 0 : r.startSide),
          c = this.atCursorPos && !l.isEditable && s <= i.length && (e < n || r.startSide > 0),
          u = !l.isEditable && (e < n || s > i.length || r.startSide <= 0),
          h = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0),
          this.flushBuffer(i),
          c && (h.append(Lf(new kl(1), i), s), (s = i.length + Math.max(0, s - i.length))),
          h.append(Lf(l, i), s),
          (this.atCursorPos = u),
          (this.pendingBuffer = u ? (e < n || s > i.length ? 1 : 2) : 0),
          this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a &&
      (this.textOff + a <= this.text.length
        ? (this.textOff += a)
        : ((this.skip += a - (this.text.length - this.textOff)), (this.text = ""), (this.textOff = 0)),
      (this.pos = n)),
      this.openStart < 0 && (this.openStart = s);
  }
  static build(e, n, r, i, s) {
    let o = new fu(e, n, r, s);
    return (o.openEnd = Xe.spans(i, n, r, o)), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Lf(t, e) {
  for (let n of e) t = new ms(n, [t], t.length);
  return t;
}
class Cl extends li {
  constructor(e) {
    super(), (this.tag = e);
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
Cl.inline = new Cl("span");
Cl.block = new Cl("div");
var Pt = (function (t) {
  return (t[(t.LTR = 0)] = "LTR"), (t[(t.RTL = 1)] = "RTL"), t;
})(Pt || (Pt = {}));
const ea = Pt.LTR,
  Tw = Pt.RTL;
function q6(t) {
  let e = [];
  for (let n = 0; n < t.length; n++) e.push(1 << +t[n]);
  return e;
}
const aie = q6(
    "88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"
  ),
  lie = q6(
    "4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"
  ),
  Rv = Object.create(null),
  fi = [];
for (let t of ["()", "[]", "{}"]) {
  let e = t.charCodeAt(0),
    n = t.charCodeAt(1);
  (Rv[e] = n), (Rv[n] = -e);
}
function Y6(t) {
  return t <= 247
    ? aie[t]
    : 1424 <= t && t <= 1524
    ? 2
    : 1536 <= t && t <= 1785
    ? lie[t - 1536]
    : 1774 <= t && t <= 2220
    ? 4
    : 8192 <= t && t <= 8204
    ? 256
    : 64336 <= t && t <= 65023
    ? 4
    : 1;
}
const cie = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Bs {
  get dir() {
    return this.level % 2 ? Tw : ea;
  }
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.level = r);
  }
  side(e, n) {
    return (this.dir == n) == e ? this.to : this.from;
  }
  forward(e, n) {
    return e == (this.dir == n);
  }
  static find(e, n, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= n && a.to >= n) {
        if (a.level == r) return o;
        (s < 0 || (i != 0 ? (i < 0 ? a.from < n : a.to > n) : e[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0) throw new RangeError("Index out of range");
    return s;
  }
}
function G6(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) {
    let r = t[n],
      i = e[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !G6(r.inner, i.inner)) return !1;
  }
  return !0;
}
const gt = [];
function uie(t, e, n, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e,
      a = s < r.length ? r[s].from : n,
      l = s ? 256 : i;
    for (let c = o, u = l, h = l; c < a; c++) {
      let f = Y6(t.charCodeAt(c));
      f == 512 ? (f = u) : f == 8 && h == 4 && (f = 16), (gt[c] = f == 4 ? 2 : f), f & 7 && (h = f), (u = f);
    }
    for (let c = o, u = l, h = l; c < a; c++) {
      let f = gt[c];
      if (f == 128) c < a - 1 && u == gt[c + 1] && u & 24 ? (f = gt[c] = u) : (gt[c] = 256);
      else if (f == 64) {
        let d = c + 1;
        for (; d < a && gt[d] == 64; ) d++;
        let p = (c && u == 8) || (d < n && gt[d] == 8) ? (h == 1 ? 1 : 8) : 256;
        for (let m = c; m < d; m++) gt[m] = p;
        c = d - 1;
      } else f == 8 && h == 1 && (gt[c] = 1);
      (u = f), f & 7 && (h = f);
    }
  }
}
function hie(t, e, n, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e,
      u = o < r.length ? r[o].from : n;
    for (let h = c, f, d, p; h < u; h++)
      if ((d = Rv[(f = t.charCodeAt(h))]))
        if (d < 0) {
          for (let m = a - 3; m >= 0; m -= 3)
            if (fi[m + 1] == -d) {
              let O = fi[m + 2],
                v = O & 2 ? i : O & 4 ? (O & 1 ? s : i) : 0;
              v && (gt[h] = gt[fi[m]] = v), (a = m);
              break;
            }
        } else {
          if (fi.length == 189) break;
          (fi[a++] = h), (fi[a++] = f), (fi[a++] = l);
        }
      else if ((p = gt[h]) == 2 || p == 1) {
        let m = p == i;
        l = m ? 0 : 1;
        for (let O = a - 3; O >= 0; O -= 3) {
          let v = fi[O + 2];
          if (v & 2) break;
          if (m) fi[O + 2] |= 2;
          else {
            if (v & 4) break;
            fi[O + 2] |= 4;
          }
        }
      }
  }
}
function fie(t, e, n, r) {
  for (let i = 0, s = r; i <= n.length; i++) {
    let o = i ? n[i - 1].to : t,
      a = i < n.length ? n[i].from : e;
    for (let l = o; l < a; ) {
      let c = gt[l];
      if (c == 256) {
        let u = l + 1;
        for (;;)
          if (u == a) {
            if (i == n.length) break;
            (u = n[i++].to), (a = i < n.length ? n[i].from : e);
          } else if (gt[u] == 256) u++;
          else break;
        let h = s == 1,
          f = (u < e ? gt[u] : r) == 1,
          d = h == f ? (h ? 1 : 2) : r;
        for (let p = u, m = i, O = m ? n[m - 1].to : t; p > l; ) p == O && ((p = n[--m].from), (O = m ? n[m - 1].to : t)), (gt[--p] = d);
        l = u;
      } else (s = c), l++;
    }
  }
}
function Iv(t, e, n, r, i, s, o) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let l = e, c = 0; l < n; ) {
      let u = !0,
        h = !1;
      if (c == s.length || l < s[c].from) {
        let m = gt[l];
        m != a && ((u = !1), (h = m == 16));
      }
      let f = !u && a == 1 ? [] : null,
        d = u ? r : r + 1,
        p = l;
      e: for (;;)
        if (c < s.length && p == s[c].from) {
          if (h) break e;
          let m = s[c];
          if (!u)
            for (let O = m.to, v = c + 1; ; ) {
              if (O == n) break e;
              if (v < s.length && s[v].from == O) O = s[v++].to;
              else {
                if (gt[O] == a) break e;
                break;
              }
            }
          if ((c++, f)) f.push(m);
          else {
            m.from > l && o.push(new Bs(l, m.from, d));
            let O = (m.direction == ea) != !(d % 2);
            Nv(t, O ? r + 1 : r, i, m.inner, m.from, m.to, o), (l = m.to);
          }
          p = m.to;
        } else {
          if (p == n || (u ? gt[p] != a : gt[p] == a)) break;
          p++;
        }
      f ? Iv(t, l, p, r + 1, i, f, o) : l < p && o.push(new Bs(l, p, d)), (l = p);
    }
  else
    for (let l = n, c = s.length; l > e; ) {
      let u = !0,
        h = !1;
      if (!c || l > s[c - 1].to) {
        let m = gt[l - 1];
        m != a && ((u = !1), (h = m == 16));
      }
      let f = !u && a == 1 ? [] : null,
        d = u ? r : r + 1,
        p = l;
      e: for (;;)
        if (c && p == s[c - 1].to) {
          if (h) break e;
          let m = s[--c];
          if (!u)
            for (let O = m.from, v = c; ; ) {
              if (O == e) break e;
              if (v && s[v - 1].to == O) O = s[--v].from;
              else {
                if (gt[O - 1] == a) break e;
                break;
              }
            }
          if (f) f.push(m);
          else {
            m.to < l && o.push(new Bs(m.to, l, d));
            let O = (m.direction == ea) != !(d % 2);
            Nv(t, O ? r + 1 : r, i, m.inner, m.from, m.to, o), (l = m.from);
          }
          p = m.from;
        } else {
          if (p == e || (u ? gt[p - 1] != a : gt[p - 1] == a)) break;
          p--;
        }
      f ? Iv(t, p, l, r + 1, i, f, o) : p < l && o.push(new Bs(p, l, d)), (l = p);
    }
}
function Nv(t, e, n, r, i, s, o) {
  let a = e % 2 ? 2 : 1;
  uie(t, i, s, r, a), hie(t, i, s, r, a), fie(i, s, r, a), Iv(t, i, s, e, n, r, o);
}
function die(t, e, n) {
  if (!t) return [new Bs(0, 0, e == Tw ? 1 : 0)];
  if (e == ea && !n.length && !cie.test(t)) return J6(t.length);
  if (n.length) for (; t.length > gt.length; ) gt[gt.length] = 256;
  let r = [],
    i = e == ea ? 0 : 1;
  return Nv(t, i, i, n, 0, t.length, r), r;
}
function J6(t) {
  return [new Bs(0, t, 0)];
}
let K6 = "";
function pie(t, e, n, r, i) {
  var s;
  let o = r.head - t.from,
    a = Bs.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc),
    l = e[a],
    c = l.side(i, n);
  if (o == c) {
    let f = (a += i ? 1 : -1);
    if (f < 0 || f >= e.length) return null;
    (l = e[(a = f)]), (o = l.side(!i, n)), (c = l.side(i, n));
  }
  let u = xn(t.text, o, l.forward(i, n));
  (u < l.from || u > l.to) && (u = c), (K6 = t.text.slice(Math.min(o, u), Math.max(o, u)));
  let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < l.level
    ? X.cursor(h.side(!i, n) + t.from, h.forward(i, n) ? 1 : -1, h.level)
    : X.cursor(u + t.from, l.forward(i, n) ? -1 : 1, l.level);
}
function mie(t, e, n) {
  for (let r = e; r < n; r++) {
    let i = Y6(t.charCodeAt(r));
    if (i == 1) return ea;
    if (i == 2 || i == 4) return Tw;
  }
  return ea;
}
const e4 = ye.define(),
  t4 = ye.define(),
  n4 = ye.define(),
  r4 = ye.define(),
  Lv = ye.define(),
  i4 = ye.define(),
  s4 = ye.define(),
  o4 = ye.define({ combine: (t) => t.some((e) => e) }),
  a4 = ye.define({ combine: (t) => t.some((e) => e) }),
  l4 = ye.define();
class al {
  constructor(e, n = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    (this.range = e), (this.y = n), (this.x = r), (this.yMargin = i), (this.xMargin = s), (this.isSnapshot = o);
  }
  map(e) {
    return e.empty ? this : new al(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length
      ? this
      : new al(X.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Mf = Ae.define({ map: (t, e) => t.map(e) }),
  c4 = Ae.define();
function Kn(t, e, n) {
  let r = t.facet(r4);
  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
const Rs = ye.define({ combine: (t) => (t.length ? t[0] : !0) });
let gie = 0;
const Bc = ye.define();
class Dt {
  constructor(e, n, r, i, s) {
    (this.id = e), (this.create = n), (this.domEventHandlers = r), (this.domEventObservers = i), (this.extension = s(this));
  }
  static define(e, n) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = n || {};
    return new Dt(gie++, e, r, i, (a) => {
      let l = [Bc.of(a)];
      return (
        o &&
          l.push(
            zu.of((c) => {
              let u = c.plugin(a);
              return u ? o(u) : ge.none;
            })
          ),
        s && l.push(s(a)),
        l
      );
    });
  }
  static fromClass(e, n) {
    return Dt.define((r) => new e(r), n);
  }
}
class B0 {
  constructor(e) {
    (this.spec = e), (this.mustUpdate = null), (this.value = null);
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (((this.mustUpdate = null), this.value.update))
          try {
            this.value.update(n);
          } catch (r) {
            if ((Kn(n.state, r, "CodeMirror plugin crashed"), this.value.destroy))
              try {
                this.value.destroy();
              } catch {}
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        Kn(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Kn(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const u4 = ye.define(),
  Pw = ye.define(),
  zu = ye.define(),
  h4 = ye.define(),
  Aw = ye.define(),
  f4 = ye.define();
function H_(t, e) {
  let n = t.state.facet(f4);
  if (!n.length) return n;
  let r = n.map((s) => (s instanceof Function ? s(t) : s)),
    i = [];
  return (
    Xe.spans(r, e.from, e.to, {
      point() {},
      span(s, o, a, l) {
        let c = s - e.from,
          u = o - e.from,
          h = i;
        for (let f = a.length - 1; f >= 0; f--, l--) {
          let d = a[f].spec.bidiIsolate,
            p;
          if ((d == null && (d = mie(e.text, c, u)), l > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == d))
            (p.to = u), (h = p.inner);
          else {
            let m = { from: c, to: u, direction: d, inner: [] };
            h.push(m), (h = m.inner);
          }
        }
      },
    }),
    i
  );
}
const d4 = ye.define();
function p4(t) {
  let e = 0,
    n = 0,
    r = 0,
    i = 0;
  for (let s of t.state.facet(d4)) {
    let o = s(t);
    o &&
      (o.left != null && (e = Math.max(e, o.left)),
      o.right != null && (n = Math.max(n, o.right)),
      o.top != null && (r = Math.max(r, o.top)),
      o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: n, top: r, bottom: i };
}
const jc = ye.define();
class Nr {
  constructor(e, n, r, i) {
    (this.fromA = e), (this.toA = n), (this.fromB = r), (this.toB = i);
  }
  join(e) {
    return new Nr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length,
      r = this;
    for (; n > 0; n--) {
      let i = e[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA) break;
        (r = r.join(i)), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, r), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0) return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i],
        c = o - a,
        u = l ? l.fromB : 1e9;
      for (; s < n.length && n[s] < u; ) {
        let h = n[s],
          f = n[s + 1],
          d = Math.max(a, h),
          p = Math.min(u, f);
        if ((d <= p && new Nr(d + c, p + c, d, p).addToSet(r), f > u)) break;
        s += 2;
      }
      if (!l) return r;
      new Nr(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), (o = l.toA), (a = l.toB);
    }
  }
}
class Qp {
  constructor(e, n, r) {
    (this.view = e),
      (this.state = n),
      (this.transactions = r),
      (this.flags = 0),
      (this.startState = e.state),
      (this.changes = qt.empty(this.startState.doc.length));
    for (let s of r) this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, a, l) => i.push(new Nr(s, o, a, l))), (this.changedRanges = i);
  }
  static create(e, n, r) {
    return new Qp(e, n, r);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class q_ extends xt {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(),
      (this.view = e),
      (this.decorations = []),
      (this.dynamicDecorationMap = [!1]),
      (this.domChanged = null),
      (this.hasComposition = null),
      (this.markedForComposition = new Set()),
      (this.editContextFormatting = ge.none),
      (this.lastCompositionAfterCursor = !1),
      (this.minWidth = 0),
      (this.minWidthFrom = 0),
      (this.minWidthTo = 0),
      (this.impreciseAnchor = null),
      (this.impreciseHead = null),
      (this.forceSelection = !1),
      (this.lastUpdate = Date.now()),
      this.setDOM(e.contentDOM),
      (this.children = [new Xt()]),
      this.children[0].setParent(this),
      this.updateDeco(),
      this.updateInner([new Nr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  update(e) {
    var n;
    let r = e.changedRanges;
    this.minWidth > 0 &&
      r.length &&
      (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo)
        ? ((this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1)), (this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)))
        : (this.minWidth = this.minWidthFrom = this.minWidthTo = 0)),
      this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 &&
      !this.view.observer.editContext &&
      (!((n = this.domChanged) === null || n === void 0) && n.newSel
        ? (i = this.domChanged.newSel.head)
        : !Sie(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? vie(this.view, e.changes, i) : null;
    if (((this.domChanged = null), this.hasComposition)) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new Nr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    (this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null),
      (be.ie || be.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations,
      a = this.updateDeco(),
      l = yie(o, a, e.changes);
    return (
      (r = Nr.extendWithRanges(r, l)),
      !(this.flags & 7) && r.length == 0
        ? !1
        : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0)
    );
  }
  updateInner(e, n, r) {
    (this.view.viewState.mustMeasureContent = !0), this.updateChildren(e, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      (this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px"),
        (this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "");
      let o = be.chrome || be.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o),
        (this.flags &= -8),
        o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0),
        (this.dom.style.height = "");
    }),
      this.markedForComposition.forEach((o) => (o.flags &= -9));
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children) o instanceof rs && o.widget instanceof Y_ && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, n, r) {
    let i = r ? r.range.addToSet(e.slice()) : e,
      s = this.childCursor(n);
    for (let o = i.length - 1; ; o--) {
      let a = o >= 0 ? i[o] : null;
      if (!a) break;
      let { fromA: l, toA: c, fromB: u, toB: h } = a,
        f,
        d,
        p,
        m;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let y = fu.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap),
          S = fu.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        (d = y.breakAtStart), (p = y.openStart), (m = S.openEnd);
        let k = this.compositionView(r);
        S.breakAtStart
          ? (k.breakAfter = 1)
          : S.content.length &&
            k.merge(k.length, k.length, S.content[0], !1, S.openStart, 0) &&
            ((k.breakAfter = S.content[0].breakAfter), S.content.shift()),
          y.content.length && k.merge(0, 0, y.content[y.content.length - 1], !0, 0, y.openEnd) && y.content.pop(),
          (f = y.content.concat(k).concat(S.content));
      } else
        ({
          content: f,
          breakAtStart: d,
          openStart: p,
          openEnd: m,
        } = fu.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: O, off: v } = s.findPos(c, 1),
        { i: g, off: x } = s.findPos(l, -1);
      B6(this, g, x, O, v, f, d, p, m);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions) for (let r of n.effects) r.is(c4) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let n = new ei(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of e.marks) n = new ms(i, [n], n.length);
    let r = new Xt();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(e) {
    let n = (s, o) => {
        (o.flags |= 8 | (o.children.some((l) => l.flags & 7) ? 1 : 0)), this.markedForComposition.add(o);
        let a = xt.get(s);
        a && a != o && (a.dom = null), o.setDOM(s);
      },
      r = this.childPos(e.range.fromB, 1),
      i = this.children[r.i];
    n(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      (r = i.childPos(r.off, 1)), (i = i.children[r.i]), n(s >= 0 ? e.marks[s].node : e.text, i);
  }
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement,
      i = r == this.dom,
      s = !i && Ad(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || s)) return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main,
      l = this.moveToLine(this.domAtPos(a.anchor)),
      c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (be.gecko && a.empty && !this.hasComposition && Oie(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), (l = c = new Cn(h, 0)), (o = !0);
    }
    let u = this.view.observer.selectionRange;
    (o ||
      !u.focusNode ||
      ((!hu(l.node, l.offset, u.anchorNode, u.anchorOffset) || !hu(c.node, c.offset, u.focusNode, u.focusOffset)) &&
        !this.suppressWidgetCursorChange(u, a))) &&
      (this.view.observer.ignore(() => {
        be.android &&
          be.chrome &&
          this.dom.contains(u.focusNode) &&
          wie(u.focusNode, this.dom) &&
          (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
        let h = ju(this.view.root);
        if (h)
          if (a.empty) {
            if (be.gecko) {
              let f = xie(l.node, l.offset);
              if (f && f != 3) {
                let d = (f == 1 ? Q6 : F6)(l.node, l.offset);
                d && (l = new Cn(d.node, d.offset));
              }
            }
            h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
          } else if (h.extend) {
            h.collapse(l.node, l.offset);
            try {
              h.extend(c.node, c.offset);
            } catch {}
          } else {
            let f = document.createRange();
            a.anchor > a.head && ([l, c] = [c, l]),
              f.setEnd(c.node, c.offset),
              f.setStart(l.node, l.offset),
              h.removeAllRanges(),
              h.addRange(f);
          }
        s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
      }),
      this.view.observer.setSelectionRange(l, c)),
      (this.impreciseAnchor = l.precise ? null : new Cn(u.anchorNode, u.anchorOffset)),
      (this.impreciseHead = c.precise ? null : new Cn(u.focusNode, u.focusOffset));
  }
  suppressWidgetCursorChange(e, n) {
    return (
      this.hasComposition &&
      n.empty &&
      hu(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) &&
      this.posFromDOM(e.focusNode, e.focusOffset) == n.head
    );
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: e } = this,
      n = e.state.selection.main,
      r = ju(e.root),
      { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify) return;
    let o = Xt.find(this, n.head);
    if (!o) return;
    let a = o.posAtStart;
    if (n.head == a || n.head == a + o.length) return;
    let l = this.coordsAt(n.head, -1),
      c = this.coordsAt(n.head, 1);
    if (!l || !c || l.bottom > c.top) return;
    let u = this.domAtPos(n.head + n.assoc);
    r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != n.from && r.collapse(i, s);
  }
  moveToLine(e) {
    let n = this.dom,
      r;
    if (e.node != n) return e;
    for (let i = e.offset; !r && i < n.childNodes.length; i++) {
      let s = xt.get(n.childNodes[i]);
      s instanceof Xt && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = xt.get(n.childNodes[i]);
      s instanceof Xt && (r = s.domAtPos(s.length));
    }
    return r ? new Cn(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let r = xt.get(n);
      if (r && r.rootView == this) return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let r = this.nearest(e);
    if (!r) throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, n) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: r } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof Xt) break;
      n++, (r = 0);
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(e, n) {
    let r = null,
      i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o],
        l = s - a.breakAfter,
        c = l - a.length;
      if (l < e) break;
      if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || (a instanceof Xt && !(r instanceof Xt && n >= 0))))
        (r = a), (i = c);
      else if (r && c == e && l == e && a instanceof rs && Math.abs(n) < 2) {
        if (a.deco.startSide < 0) break;
        o && (r = null);
      }
      s = c;
    }
    return r ? r.coordsAt(e - i, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: r } = this.childPos(e, 1),
      i = this.children[n];
    if (!(i instanceof Xt)) return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(r, 1);
      for (; ; a++) {
        if (a == i.children.length) return null;
        if ((i = i.children[a]).length) break;
      }
      r = l;
    }
    if (!(i instanceof ei)) return null;
    let s = xn(i.text, r);
    if (s == r) return null;
    let o = Ko(i.dom, r, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || (l.top < l.bottom && l.left < l.right)) return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [],
      { from: r, to: i } = e,
      s = this.view.contentDOM.clientWidth,
      o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
      a = -1,
      l = this.view.textDirection == Pt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u],
        f = c + h.length;
      if (f > i) break;
      if (c >= r) {
        let d = h.dom.getBoundingClientRect();
        if ((n.push(d.height), o)) {
          let p = h.dom.lastChild,
            m = p ? Zu(p) : [];
          if (m.length) {
            let O = m[m.length - 1],
              v = l ? O.right - d.left : d.right - O.left;
            v > a && ((a = v), (this.minWidth = s), (this.minWidthFrom = c), (this.minWidthTo = f));
          }
        }
      }
      c = f + h.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? Pt.RTL : Pt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Xt) {
        let o = s.measureTextSize();
        if (o) return o;
      }
    let e = document.createElement("div"),
      n,
      r,
      i;
    return (
      (e.className = "cm-line"),
      (e.style.width = "99999px"),
      (e.style.position = "absolute"),
      (e.textContent = "abc def ghi jkl mno pqr stu"),
      this.view.observer.ignore(() => {
        this.dom.appendChild(e);
        let s = Zu(e.firstChild)[0];
        (n = e.getBoundingClientRect().height), (r = s ? s.width / 27 : 7), (i = s ? s.height : n), e.remove();
      }),
      { lineHeight: n, charWidth: r, textHeight: i }
    );
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new V6(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [],
      n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == n.viewports.length ? null : n.viewports[i],
        o = s ? s.from - 1 : this.length;
      if (o > r) {
        let a = (n.lineBlockAt(o).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        e.push(ge.replace({ widget: new Y_(a), block: !0, inclusive: !0, isBlockGap: !0 }).range(r, o));
      }
      if (!s) break;
      r = s.to + 1;
    }
    return ge.set(e);
  }
  updateDeco() {
    let e = 1,
      n = this.view.state.facet(zu).map((s) => ((this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s)),
      r = !1,
      i = this.view.state.facet(h4).map((s, o) => {
        let a = typeof s == "function";
        return a && (r = !0), a ? s(this.view) : s;
      });
    for (
      i.length && ((this.dynamicDecorationMap[e++] = r), n.push(Xe.join(i))),
        this.decorations = [this.editContextFormatting, ...n, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];
      e < this.decorations.length;

    )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      (this.view.scrollDOM.scrollTop = c.top - e.yMargin), (this.view.scrollDOM.scrollLeft = e.xMargin);
      return;
    }
    for (let c of this.view.state.facet(l4))
      try {
        if (c(this.view, e.range, e)) return !0;
      } catch (u) {
        Kn(this.view.state, u, "scroll handler");
      }
    let { range: n } = e,
      r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1),
      i;
    if (!r) return;
    !n.empty &&
      (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) &&
      (r = {
        left: Math.min(r.left, i.left),
        top: Math.min(r.top, i.top),
        right: Math.max(r.right, i.right),
        bottom: Math.max(r.bottom, i.bottom),
      });
    let s = p4(this.view),
      o = { left: r.left - s.left, top: r.top - s.top, right: r.right + s.right, bottom: r.bottom + s.bottom },
      { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    Gre(
      this.view.scrollDOM,
      o,
      n.head < n.anchor ? -1 : 1,
      e.x,
      e.y,
      Math.max(Math.min(e.xMargin, a), -a),
      Math.max(Math.min(e.yMargin, l), -l),
      this.view.textDirection == Pt.LTR
    );
  }
}
function Oie(t) {
  return (
    t.node.nodeType == 1 &&
    t.node.firstChild &&
    (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") &&
    (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false")
  );
}
class Y_ extends li {
  constructor(e) {
    super(), (this.height = e);
  }
  toDOM() {
    let e = document.createElement("div");
    return (e.className = "cm-gap"), this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return (e.style.height = this.height + "px"), !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function m4(t, e) {
  let n = t.observer.selectionRange;
  if (!n.focusNode) return null;
  let r = Q6(n.focusNode, n.focusOffset),
    i = F6(n.focusNode, n.focusOffset),
    s = r || i;
  if (i && r && i.node != r.node) {
    let a = xt.get(i.node);
    if (!a || (a instanceof ei && a.text != i.node.nodeValue)) s = i;
    else if (t.docView.lastCompositionAfterCursor) {
      let l = xt.get(r.node);
      !l || (l instanceof ei && l.text != r.node.nodeValue) || (s = i);
    }
  }
  if (((t.docView.lastCompositionAfterCursor = s != r), !s)) return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function vie(t, e, n) {
  let r = m4(t, n);
  if (!r) return null;
  let { node: i, from: s, to: o } = r,
    a = i.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a) return null;
  let l = e.invertedDesc,
    c = new Nr(l.mapPos(s), l.mapPos(o), s, o),
    u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = xt.get(h);
    if (f instanceof ms) u.push({ node: h, deco: f.mark });
    else {
      if (f instanceof Xt || (h.nodeName == "DIV" && h.parentNode == t.contentDOM)) return { range: c, text: i, marks: u, line: h };
      if (h != t.contentDOM) u.push({ node: h, deco: new tf({ inclusive: !0, attributes: sie(h), tagName: h.tagName.toLowerCase() }) });
      else return null;
    }
  }
}
function xie(t, e) {
  return t.nodeType != 1
    ? 0
    : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) |
        (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let bie = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    $v(e, n, this.changes);
  }
  comparePoint(e, n) {
    $v(e, n, this.changes);
  }
};
function yie(t, e, n) {
  let r = new bie();
  return Xe.compare(t, e, n, r), r.changes;
}
function wie(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode) if (n.nodeType == 1 && n.contentEditable == "false") return !0;
  return !1;
}
function Sie(t, e) {
  let n = !1;
  return (
    e &&
      t.iterChangedRanges((r, i) => {
        r < e.to && i > e.from && (n = !0);
      }),
    n
  );
}
function kie(t, e, n = 1) {
  let r = t.charCategorizer(e),
    i = t.doc.lineAt(e),
    s = e - i.from;
  if (i.length == 0) return X.cursor(e);
  s == 0 ? (n = 1) : s == i.length && (n = -1);
  let o = s,
    a = s;
  n < 0 ? (o = xn(i.text, s, !1)) : (a = xn(i.text, s));
  let l = r(i.text.slice(o, a));
  for (; o > 0; ) {
    let c = xn(i.text, o, !1);
    if (r(i.text.slice(c, o)) != l) break;
    o = c;
  }
  for (; a < i.length; ) {
    let c = xn(i.text, a);
    if (r(i.text.slice(a, c)) != l) break;
    a = c;
  }
  return X.range(o + i.from, a + i.from);
}
function Cie(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function _ie(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function j0(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function G_(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function J_(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function Mv(t, e, n) {
  let r,
    i,
    s,
    o,
    a = !1,
    l,
    c,
    u,
    h;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let m = Zu(p);
    for (let O = 0; O < m.length; O++) {
      let v = m[O];
      i && j0(i, v) && (v = G_(J_(v, i.bottom), i.top));
      let g = Cie(e, v),
        x = _ie(n, v);
      if (g == 0 && x == 0) return p.nodeType == 3 ? K_(p, e, n) : Mv(p, e, n);
      if (!r || o > x || (o == x && s > g)) {
        (r = p), (i = v), (s = g), (o = x);
        let y = x ? (n < v.top ? -1 : 1) : g ? (e < v.left ? -1 : 1) : 0;
        a = !y || (y > 0 ? O < m.length - 1 : O > 0);
      }
      g == 0
        ? n > v.bottom && (!u || u.bottom < v.bottom)
          ? ((l = p), (u = v))
          : n < v.top && (!h || h.top > v.top) && ((c = p), (h = v))
        : u && j0(u, v)
        ? (u = J_(u, v.bottom))
        : h && j0(h, v) && (h = G_(h, v.top));
    }
  }
  if ((u && u.bottom >= n ? ((r = l), (i = u)) : h && h.top <= n && ((r = c), (i = h)), !r)) return { node: t, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3) return K_(r, f, n);
  if (a && r.contentEditable != "false") return Mv(r, f, n);
  let d = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: d };
}
function K_(t, e, n) {
  let r = t.nodeValue.length,
    i = -1,
    s = 1e9,
    o = 0;
  for (let a = 0; a < r; a++) {
    let l = Ko(t, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom) continue;
      o || (o = e - u.left);
      let h = (u.top > n ? u.top - n : n - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let f = e >= (u.left + u.right) / 2,
          d = f;
        if (((be.chrome || be.gecko) && Ko(t, a).getBoundingClientRect().left == u.right && (d = !f), h <= 0))
          return { node: t, offset: a + (d ? 1 : 0) };
        (i = a + (d ? 1 : 0)), (s = h);
      }
    }
  }
  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };
}
function g4(t, e, n, r = -1) {
  var i, s;
  let o = t.contentDOM.getBoundingClientRect(),
    a = o.top + t.viewState.paddingTop,
    l,
    { docHeight: c } = t.viewState,
    { x: u, y: h } = e,
    f = h - a;
  if (f < 0) return 0;
  if (f > c) return t.state.doc.length;
  for (let y = t.viewState.heightOracle.textHeight / 2, S = !1; (l = t.elementAtHeight(f)), l.type != Fn.Text; )
    for (; (f = r > 0 ? l.bottom + y : l.top - y), !(f >= 0 && f <= c); ) {
      if (S) return n ? null : 0;
      (S = !0), (r = -r);
    }
  h = a + f;
  let d = l.from;
  if (d < t.viewport.from) return t.viewport.from == 0 ? 0 : n ? null : e5(t, o, l, u, h);
  if (d > t.viewport.to) return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : e5(t, o, l, u, h);
  let p = t.dom.ownerDocument,
    m = t.root.elementFromPoint ? t.root : p,
    O = m.elementFromPoint(u, h);
  O && !t.contentDOM.contains(O) && (O = null),
    O ||
      ((u = Math.max(o.left + 1, Math.min(o.right - 1, u))), (O = m.elementFromPoint(u, h)), O && !t.contentDOM.contains(O) && (O = null));
  let v,
    g = -1;
  if (O && ((i = t.docView.nearest(O)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let y = p.caretPositionFromPoint(u, h);
      y && ({ offsetNode: v, offset: g } = y);
    } else if (p.caretRangeFromPoint) {
      let y = p.caretRangeFromPoint(u, h);
      y &&
        (({ startContainer: v, startOffset: g } = y),
        (!t.contentDOM.contains(v) || (be.safari && Eie(v, g, u)) || (be.chrome && Tie(v, g, u))) && (v = void 0));
    }
  }
  if (!v || !t.docView.dom.contains(v)) {
    let y = Xt.find(t.docView, d);
    if (!y) return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: v, offset: g } = Mv(y.dom, u, h));
  }
  let x = t.docView.nearest(v);
  if (!x) return null;
  if (x.isWidget && ((s = x.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let y = x.dom.getBoundingClientRect();
    return e.y < y.top || (e.y <= y.bottom && e.x <= (y.left + y.right) / 2) ? x.posAtStart : x.posAtEnd;
  } else return x.localPosFromDOM(v, g) + x.posAtStart;
}
function e5(t, e, n, r, i) {
  let s = Math.round((r - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight,
      l = Math.floor((i - n.top - (t.defaultLineHeight - a) * 0.5) / a);
    s += l * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(n.from, n.to);
  return n.from + wv(o, s, t.state.tabSize);
}
function Eie(t, e, n) {
  let r;
  if (t.nodeType != 3 || e != (r = t.nodeValue.length)) return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling) if (i.nodeType != 1 || i.nodeName != "BR") return !1;
  return Ko(t, r - 1, r).getBoundingClientRect().left > n;
}
function Tie(t, e, n) {
  if (e != 0) return !1;
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i) return !1;
    if (s.classList.contains("cm-line")) break;
    i = s;
  }
  let r = t.nodeType == 1 ? t.getBoundingClientRect() : Ko(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function Dv(t, e) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let r of n.type) if (r.to > e || (r.to == e && (r.to == n.to || r.type == Fn.Text))) return r;
  }
  return n;
}
function Pie(t, e, n, r) {
  let i = Dv(t, e.head),
    s =
      !r || i.type != Fn.Text || !(t.lineWrapping || i.widgetLineBreaks)
        ? null
        : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(),
      a = t.textDirectionAt(i.from),
      l = t.posAtCoords({ x: n == (a == Pt.LTR) ? o.right - 1 : o.left + 1, y: (s.top + s.bottom) / 2 });
    if (l != null) return X.cursor(l, n ? -1 : 1);
  }
  return X.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function t5(t, e, n, r) {
  let i = t.state.doc.lineAt(e.head),
    s = t.bidiSpans(i),
    o = t.textDirectionAt(i.from);
  for (let a = e, l = null; ; ) {
    let c = pie(i, s, o, a, n),
      u = K6;
    if (!c) {
      if (i.number == (n ? t.state.doc.lines : 1)) return a;
      (u = `
`),
        (i = t.state.doc.line(i.number + (n ? 1 : -1))),
        (s = t.bidiSpans(i)),
        (c = t.visualLineSide(i, !n));
    }
    if (l) {
      if (!l(u)) return a;
    } else {
      if (!r) return c;
      l = r(u);
    }
    a = c;
  }
}
function Aie(t, e, n) {
  let r = t.state.charCategorizer(e),
    i = r(n);
  return (s) => {
    let o = r(s);
    return i == Nt.Space && (i = o), i == o;
  };
}
function $ie(t, e, n, r) {
  let i = e.head,
    s = n ? 1 : -1;
  if (i == (n ? t.state.doc.length : 0)) return X.cursor(i, e.assoc);
  let o = e.goalColumn,
    a,
    l = t.contentDOM.getBoundingClientRect(),
    c = t.coordsAtPos(i, e.assoc || -1),
    u = t.documentTop;
  if (c) o == null && (o = c.left - l.left), (a = s < 0 ? c.top : c.bottom);
  else {
    let d = t.viewState.lineBlockAt(i);
    o == null && (o = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - d.from))), (a = (s < 0 ? d.top : d.bottom) + u);
  }
  let h = l.left + o,
    f = r ?? t.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = a + (f + d) * s,
      m = g4(t, { x: h, y: p }, !1, s);
    if (p < l.top || p > l.bottom || (s < 0 ? m < i : m > i)) {
      let O = t.docView.coordsForChar(m),
        v = !O || p < O.top ? -1 : 1;
      return X.cursor(m, v, void 0, o);
    }
  }
}
function $d(t, e, n) {
  for (;;) {
    let r = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = r || n || (e - s < o - e ? -1 : 1);
          (e = l < 0 ? s : o), (r = l);
        }
      });
    if (!r) return e;
  }
}
function Z0(t, e, n) {
  let r = $d(
    t.state.facet(Aw).map((i) => i(t)),
    n.from,
    e.head > n.from ? -1 : 1
  );
  return r == n.from ? n : X.cursor(r, r < n.from ? 1 : -1);
}
class Rie {
  setSelectionOrigin(e) {
    (this.lastSelectionOrigin = e), (this.lastSelectionTime = Date.now());
  }
  constructor(e) {
    (this.view = e),
      (this.lastKeyCode = 0),
      (this.lastKeyTime = 0),
      (this.lastTouchTime = 0),
      (this.lastFocusTime = 0),
      (this.lastScrollTop = 0),
      (this.lastScrollLeft = 0),
      (this.pendingIOSKey = void 0),
      (this.tabFocusMode = -1),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastContextMenu = 0),
      (this.scrollHandlers = []),
      (this.handlers = Object.create(null)),
      (this.composing = -1),
      (this.compositionFirstChange = null),
      (this.compositionEndedAt = 0),
      (this.compositionPendingKey = !1),
      (this.compositionPendingChange = !1),
      (this.mouseSelection = null),
      (this.draggedContent = null),
      (this.handleEvent = this.handleEvent.bind(this)),
      (this.notifiedFocused = e.hasFocus),
      be.safari && e.contentDOM.addEventListener("input", () => null),
      be.gecko && Hie(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !Vie(this.view, e) || this.ignoreDuringComposition(e) || (e.type == "keydown" && this.keydown(e)) || this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers) i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented) break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = Iie(e),
      r = this.handlers,
      i = this.view.contentDOM;
    for (let s in n)
      if (s != "scroll") {
        let o = !n[s].handlers.length,
          a = r[s];
        a && o != !a.handlers.length && (i.removeEventListener(s, this.handleEvent), (a = null)),
          a || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r) s != "scroll" && !n[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (
      ((this.lastKeyCode = e.keyCode),
      (this.lastKeyTime = Date.now()),
      e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
    )
      return !0;
    if (
      (this.tabFocusMode > 0 && e.keyCode != 27 && v4.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1),
      be.android && be.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
    )
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return be.ios &&
      !e.synthetic &&
      !e.altKey &&
      !e.metaKey &&
      (((n = O4.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey) || (Nie.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey))
      ? ((this.pendingIOSKey = n || e), setTimeout(() => this.flushIOSKey(), 250), !0)
      : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || (n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()))
      ? !1
      : ((this.pendingIOSKey = void 0), ol(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type)
      ? this.composing > 0
        ? !0
        : be.safari && !be.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100
        ? ((this.compositionPendingKey = !1), !0)
        : !1
      : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), (this.mouseSelection = e);
  }
  update(e) {
    this.view.observer.update(e),
      this.mouseSelection && this.mouseSelection.update(e),
      this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)),
      e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function n5(t, e) {
  return (n, r) => {
    try {
      return e.call(t, r, n);
    } catch (i) {
      Kn(n.state, i);
    }
  };
}
function Iie(t) {
  let e = Object.create(null);
  function n(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of t) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s];
        o && n(s).handlers.push(n5(r.value, o));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s];
        o && n(s).observers.push(n5(r.value, o));
      }
  }
  for (let r in ti) n(r).handlers.push(ti[r]);
  for (let r in Mr) n(r).observers.push(Mr[r]);
  return e;
}
const O4 = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" },
  ],
  Nie = "dthko",
  v4 = [16, 17, 18, 20, 91, 92, 224, 225],
  Df = 6;
function Qf(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function Lie(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class Mie {
  constructor(e, n, r, i) {
    (this.view = e),
      (this.startEvent = n),
      (this.style = r),
      (this.mustSelect = i),
      (this.scrollSpeed = { x: 0, y: 0 }),
      (this.scrolling = -1),
      (this.lastEvent = n),
      (this.scrollParent = Jre(e.contentDOM)),
      (this.atoms = e.state.facet(Aw).map((o) => o(e)));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", (this.move = this.move.bind(this))),
      s.addEventListener("mouseup", (this.up = this.up.bind(this))),
      (this.extend = n.shiftKey),
      (this.multiple = e.state.facet(Qe.allowMultipleSelections) && Die(e, n)),
      (this.dragging = Fie(e, n) && w4(n) == 1 ? null : !1);
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var n;
    if (e.buttons == 0) return this.destroy();
    if (this.dragging || (this.dragging == null && Lie(this.startEvent, e) < 10)) return;
    this.select((this.lastEvent = e));
    let r = 0,
      i = 0,
      s = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || {
        left: 0,
        top: 0,
        right: this.view.win.innerWidth,
        bottom: this.view.win.innerHeight,
      },
      o = p4(this.view);
    e.clientX - o.left <= s.left + Df
      ? (r = -Qf(s.left - e.clientX))
      : e.clientX + o.right >= s.right - Df && (r = Qf(e.clientX - s.right)),
      e.clientY - o.top <= s.top + Df
        ? (i = -Qf(s.top - e.clientY))
        : e.clientY + o.bottom >= s.bottom - Df && (i = Qf(e.clientY - s.bottom)),
      this.setScrollSpeed(r, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move),
      e.removeEventListener("mouseup", this.up),
      (this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null);
  }
  setScrollSpeed(e, n) {
    (this.scrollSpeed = { x: e, y: n }),
      e || n
        ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50))
        : this.scrolling > -1 && (clearInterval(this.scrolling), (this.scrolling = -1));
  }
  scroll() {
    this.scrollParent
      ? ((this.scrollParent.scrollLeft += this.scrollSpeed.x), (this.scrollParent.scrollTop += this.scrollSpeed.y))
      : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
      this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r],
        s = null;
      if (i.empty) {
        let o = $d(this.atoms, i.from, 0);
        o != i.from && (s = X.cursor(o, -1));
      } else {
        let o = $d(this.atoms, i.from, -1),
          a = $d(this.atoms, i.to, 1);
        (o != i.from || a != i.to) && (s = X.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a));
      }
      s && (n || (n = e.ranges.slice()), (n[r] = s));
    }
    return n ? X.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this,
      r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) &&
      this.view.dispatch({ selection: r, userEvent: "select.pointer" }),
      (this.mustSelect = !1);
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type"))
      ? this.destroy()
      : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function Die(t, e) {
  let n = t.state.facet(e4);
  return n.length ? n[0](e) : be.mac ? e.metaKey : e.ctrlKey;
}
function Qie(t, e) {
  let n = t.state.facet(t4);
  return n.length ? n[0](e) : be.mac ? !e.altKey : !e.ctrlKey;
}
function Fie(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty) return !1;
  let r = ju(t.root);
  if (!r || r.rangeCount == 0) return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY) return !0;
  }
  return !1;
}
function Vie(t, e) {
  if (!e.bubbles) return !0;
  if (e.defaultPrevented) return !1;
  for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || ((r = xt.get(n)) && r.ignoreEvent(e))) return !1;
  return !0;
}
const ti = Object.create(null),
  Mr = Object.create(null),
  x4 = (be.ie && be.ie_version < 15) || (be.ios && be.webkit_version < 604);
function Bie(t) {
  let e = t.dom.parentNode;
  if (!e) return;
  let n = e.appendChild(document.createElement("textarea"));
  (n.style.cssText = "position: fixed; left: -10000px; top: 10px"),
    n.focus(),
    setTimeout(() => {
      t.focus(), n.remove(), b4(t, n.value);
    }, 50);
}
function b4(t, e) {
  let { state: n } = t,
    r,
    i = 1,
    s = n.toText(e),
    o = s.lines == n.selection.ranges.length;
  if (Qv != null && n.selection.ranges.every((l) => l.empty) && Qv == s.toString()) {
    let l = -1;
    r = n.changeByRange((c) => {
      let u = n.doc.lineAt(c.from);
      if (u.from == l) return { range: c };
      l = u.from;
      let h = n.toText((o ? s.line(i++).text : e) + n.lineBreak);
      return { changes: { from: u.from, insert: h }, range: X.cursor(c.from + h.length) };
    });
  } else
    o
      ? (r = n.changeByRange((l) => {
          let c = s.line(i++);
          return { changes: { from: l.from, to: l.to, insert: c.text }, range: X.cursor(l.from + c.length) };
        }))
      : (r = n.replaceSelection(s));
  t.dispatch(r, { userEvent: "input.paste", scrollIntoView: !0 });
}
Mr.scroll = (t) => {
  (t.inputState.lastScrollTop = t.scrollDOM.scrollTop), (t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft);
};
ti.keydown = (t, e) => (
  t.inputState.setSelectionOrigin("select"),
  e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3),
  !1
);
Mr.touchstart = (t, e) => {
  (t.inputState.lastTouchTime = Date.now()), t.inputState.setSelectionOrigin("select.pointer");
};
Mr.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
ti.mousedown = (t, e) => {
  if ((t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)) return !1;
  let n = null;
  for (let r of t.state.facet(n4)) if (((n = r(t, e)), n)) break;
  if ((!n && e.button == 0 && (n = zie(t, e)), n)) {
    let r = !t.hasFocus;
    t.inputState.startMouseSelection(new Mie(t, e, n, r)),
      r &&
        t.observer.ignore(() => {
          L6(t.contentDOM);
          let s = t.root.activeElement;
          s && !s.contains(t.contentDOM) && s.blur();
        });
    let i = t.inputState.mouseSelection;
    if (i) return i.start(e), i.dragging === !1;
  }
  return !1;
};
function r5(t, e, n, r) {
  if (r == 1) return X.cursor(e, n);
  if (r == 2) return kie(t.state, e, n);
  {
    let i = Xt.find(t.docView, e),
      s = t.state.doc.lineAt(i ? i.posAtEnd : e),
      o = i ? i.posAtStart : s.from,
      a = i ? i.posAtEnd : s.to;
    return a < t.state.doc.length && a == s.to && a++, X.range(o, a);
  }
}
let y4 = (t, e) => t >= e.top && t <= e.bottom,
  i5 = (t, e, n) => y4(e, n) && t >= n.left && t <= n.right;
function jie(t, e, n, r) {
  let i = Xt.find(t.docView, e);
  if (!i) return 1;
  let s = e - i.posAtStart;
  if (s == 0) return 1;
  if (s == i.length) return -1;
  let o = i.coordsAt(s, -1);
  if (o && i5(n, r, o)) return -1;
  let a = i.coordsAt(s, 1);
  return a && i5(n, r, a) ? 1 : o && y4(r, o) ? -1 : 1;
}
function s5(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: jie(t, n, e.clientX, e.clientY) };
}
const Zie = be.ie && be.ie_version <= 11;
let o5 = null,
  a5 = 0,
  l5 = 0;
function w4(t) {
  if (!Zie) return t.detail;
  let e = o5,
    n = l5;
  return (
    (o5 = t),
    (l5 = Date.now()),
    (a5 = !e || (n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2) ? (a5 + 1) % 3 : 1)
  );
}
function zie(t, e) {
  let n = s5(t, e),
    r = w4(e),
    i = t.state.selection;
  return {
    update(s) {
      s.docChanged && ((n.pos = s.changes.mapPos(n.pos)), (i = i.map(s.changes)));
    },
    get(s, o, a) {
      let l = s5(t, s),
        c,
        u = r5(t, l.pos, l.bias, r);
      if (n.pos != l.pos && !o) {
        let h = r5(t, n.pos, n.bias, r),
          f = Math.min(h.from, u.from),
          d = Math.max(h.to, u.to);
        u = f < u.from ? X.range(f, d) : X.range(d, f);
      }
      return o
        ? i.replaceRange(i.main.extend(u.from, u.to))
        : a && r == 1 && i.ranges.length > 1 && (c = Wie(i, l.pos))
        ? c
        : a
        ? i.addRange(u)
        : X.create([u]);
    },
  };
}
function Wie(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: r, to: i } = t.ranges[n];
    if (r <= e && i >= e)
      return X.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
ti.dragstart = (t, e) => {
  let {
    selection: { main: n },
  } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart,
        o = s + i.length;
      (s >= n.to || o <= n.from) && (n = X.range(s, o));
    }
  }
  let { inputState: r } = t;
  return (
    r.mouseSelection && (r.mouseSelection.dragging = !0),
    (r.draggedContent = n),
    e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(n.from, n.to)), (e.dataTransfer.effectAllowed = "copyMove")),
    !1
  );
};
ti.dragend = (t) => ((t.inputState.draggedContent = null), !1);
function c5(t, e, n, r) {
  if (!n) return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    { draggedContent: s } = t.inputState,
    o = r && s && Qie(t, e) ? { from: s.from, to: s.to } : null,
    a = { from: i, insert: n },
    l = t.state.changes(o ? [o, a] : a);
  t.focus(),
    t.dispatch({ changes: l, selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) }, userEvent: o ? "move.drop" : "input.drop" }),
    (t.inputState.draggedContent = null);
}
ti.drop = (t, e) => {
  if (!e.dataTransfer) return !1;
  if (t.state.readOnly) return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length),
      i = 0,
      s = () => {
        ++i == n.length && c5(t, e, r.filter((o) => o != null).join(t.state.lineBreak), !1);
      };
    for (let o = 0; o < n.length; o++) {
      let a = new FileReader();
      (a.onerror = s),
        (a.onload = () => {
          /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result), s();
        }),
        a.readAsText(n[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r) return c5(t, e, r, !0), !0;
  }
  return !1;
};
ti.paste = (t, e) => {
  if (t.state.readOnly) return !0;
  t.observer.flush();
  let n = x4 ? null : e.clipboardData;
  return n ? (b4(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (Bie(t), !1);
};
function Uie(t, e) {
  let n = t.dom.parentNode;
  if (!n) return;
  let r = n.appendChild(document.createElement("textarea"));
  (r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
    (r.value = e),
    r.focus(),
    (r.selectionEnd = e.length),
    (r.selectionStart = 0),
    setTimeout(() => {
      r.remove(), t.focus();
    }, 50);
}
function Xie(t) {
  let e = [],
    n = [],
    r = !1;
  for (let i of t.selection.ranges) i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > i && (e.push(o.text), n.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), (i = o.number);
    }
    r = !0;
  }
  return { text: e.join(t.lineBreak), ranges: n, linewise: r };
}
let Qv = null;
ti.copy = ti.cut = (t, e) => {
  let { text: n, ranges: r, linewise: i } = Xie(t.state);
  if (!n && !i) return !1;
  (Qv = i ? n : null), e.type == "cut" && !t.state.readOnly && t.dispatch({ changes: r, scrollIntoView: !0, userEvent: "delete.cut" });
  let s = x4 ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", n), !0) : (Uie(t, n), !1);
};
const S4 = Jr.define();
function k4(t, e) {
  let n = [];
  for (let r of t.facet(s4)) {
    let i = r(t, e);
    i && n.push(i);
  }
  return n ? t.update({ effects: n, annotations: S4.of(!0) }) : null;
}
function C4(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = k4(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
Mr.focus = (t) => {
  (t.inputState.lastFocusTime = Date.now()),
    !t.scrollDOM.scrollTop &&
      (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) &&
      ((t.scrollDOM.scrollTop = t.inputState.lastScrollTop), (t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft)),
    C4(t);
};
Mr.blur = (t) => {
  t.observer.clearSelectionRange(), C4(t);
};
Mr.compositionstart = Mr.compositionupdate = (t) => {
  t.observer.editContext ||
    (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0),
    t.inputState.composing < 0 && (t.inputState.composing = 0));
};
Mr.compositionend = (t) => {
  t.observer.editContext ||
    ((t.inputState.composing = -1),
    (t.inputState.compositionEndedAt = Date.now()),
    (t.inputState.compositionPendingKey = !0),
    (t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0),
    (t.inputState.compositionFirstChange = null),
    be.chrome && be.android
      ? t.observer.flushSoon()
      : t.inputState.compositionPendingChange
      ? Promise.resolve().then(() => t.observer.flush())
      : setTimeout(() => {
          t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
        }, 50));
};
Mr.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
ti.beforeinput = (t, e) => {
  var n;
  let r;
  if (
    be.chrome &&
    be.android &&
    (r = O4.find((i) => i.inputType == e.inputType)) &&
    (t.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")
  ) {
    let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 &&
        t.hasFocus &&
        (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return (
    be.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(),
    be.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => Mr.compositionend(t, e), 20),
    !1
  );
};
const u5 = new Set();
function Hie(t) {
  u5.has(t) || (u5.add(t), t.addEventListener("copy", () => {}), t.addEventListener("cut", () => {}));
}
const h5 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class qie {
  constructor(e) {
    (this.lineWrapping = e),
      (this.doc = ot.empty),
      (this.heightSamples = {}),
      (this.lineHeight = 14),
      (this.charWidth = 7),
      (this.textHeight = 14),
      (this.lineLength = 30),
      (this.heightChanged = !1);
  }
  heightForGap(e, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping
      ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight
      : this.lineHeight;
  }
  setDoc(e) {
    return (this.doc = e), this;
  }
  mustRefreshForWrapping(e) {
    return h5.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || ((n = !0), (this.heightSamples[Math.floor(i * 10)] = !0));
    }
    return n;
  }
  refresh(e, n, r, i, s, o) {
    let a = h5.indexOf(e) > -1,
      l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (((this.lineWrapping = a), (this.lineHeight = n), (this.charWidth = r), (this.textHeight = i), (this.lineLength = s), l)) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : (this.heightSamples[Math.floor(u * 10)] = !0);
      }
    }
    return l;
  }
}
class Yie {
  constructor(e, n) {
    (this.from = e), (this.heights = n), (this.index = 0);
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class yi {
  constructor(e, n, r, i, s) {
    (this.from = e), (this.length = n), (this.top = r), (this.height = i), (this._content = s);
  }
  get type() {
    return typeof this._content == "number" ? Fn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof so ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new yi(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var _t = (function (t) {
  return (t[(t.ByPos = 0)] = "ByPos"), (t[(t.ByHeight = 1)] = "ByHeight"), (t[(t.ByPosNoHeight = 2)] = "ByPosNoHeight"), t;
})(_t || (_t = {}));
const Rd = 0.001;
class Vn {
  constructor(e, n, r = 2) {
    (this.length = e), (this.height = n), (this.flags = r);
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | (this.flags & -3);
  }
  setHeight(e, n) {
    this.height != n && (Math.abs(this.height - n) > Rd && (e.heightChanged = !0), (this.height = n));
  }
  replace(e, n, r) {
    return Vn.of(r);
  }
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, r, i) {
    let s = this,
      o = r.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: h } = i[a],
        f = s.lineAt(l, _t.ByPosNoHeight, r.setDoc(n), 0, 0),
        d = f.to >= c ? f : s.lineAt(c, _t.ByPosNoHeight, r, 0, 0);
      for (h += d.to - c, c = d.to; a > 0 && f.from <= i[a - 1].toA; )
        (l = i[a - 1].fromA), (u = i[a - 1].fromB), a--, l < f.from && (f = s.lineAt(l, _t.ByPosNoHeight, r, 0, 0));
      (u += f.from - l), (l = f.from);
      let p = $w.build(r.setDoc(o), e, u, h);
      s = s.replace(l, c, p);
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new ur(0, 0);
  }
  static of(e) {
    if (e.length == 1) return e[0];
    let n = 0,
      r = e.length,
      i = 0,
      s = 0;
    for (;;)
      if (n == r)
        if (i > s * 2) {
          let a = e[n - 1];
          a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), (r += 1 + a.break), (i -= a.size);
        } else if (s > i * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), (r += 2 + a.break), (s -= a.size);
        } else break;
      else if (i < s) {
        let a = e[n++];
        a && (i += a.size);
      } else {
        let a = e[--r];
        a && (s += a.size);
      }
    let o = 0;
    return e[n - 1] == null ? ((o = 1), n--) : e[n] == null && ((o = 1), r++), new Gie(Vn.of(e.slice(0, n)), o, Vn.of(e.slice(r)));
  }
}
Vn.prototype.size = 1;
class _4 extends Vn {
  constructor(e, n, r) {
    super(e, n), (this.deco = r);
  }
  blockAt(e, n, r, i) {
    return new yi(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, n, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, n, r, i, s, o) {
    e <= s + this.length && n >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(e, i.heights[i.index++]), (this.outdated = !1), this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class ur extends _4 {
  constructor(e, n) {
    super(e, n, null), (this.collapsed = 0), (this.widgetHeight = 0), (this.breaks = 0);
  }
  blockAt(e, n, r, i) {
    return new yi(i, this.length, r, this.height, this.breaks);
  }
  replace(e, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof ur || (i instanceof dn && i.flags & 4)) && Math.abs(this.length - i.length) < 10
      ? (i instanceof dn ? (i = new ur(i.length, this.height)) : (i.height = this.height), this.outdated || (i.outdated = !1), i)
      : Vn.of(r);
  }
  updateHeight(e, n = 0, r = !1, i) {
    return (
      i && i.from <= n && i.more
        ? this.setHeight(e, i.heights[i.index++])
        : (r || this.outdated) &&
          this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight),
      (this.outdated = !1),
      this
    );
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class dn extends Vn {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let r = e.doc.lineAt(n).number,
      i = e.doc.lineAt(n + this.length).number,
      s = i - r + 1,
      o,
      a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      (o = l / s), this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: a };
  }
  blockAt(e, n, r, i) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let c = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)),
        u = n.doc.lineAt(c),
        h = a + u.length * l,
        f = Math.max(r, e - h / 2);
      return new yi(u.from, u.length, f, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / a))),
        { from: u, length: h } = n.doc.line(s + c);
      return new yi(u, h, r + a * c, a, 0);
    }
  }
  lineAt(e, n, r, i, s) {
    if (n == _t.ByHeight) return this.blockAt(e, r, i, s);
    if (n == _t.ByPosNoHeight) {
      let { from: d, to: p } = r.doc.lineAt(e);
      return new yi(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, s),
      c = r.doc.lineAt(e),
      u = a + c.length * l,
      h = c.number - o,
      f = i + a * h + l * (c.from - s - h);
    return new yi(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, n, r, i, s, o) {
    (e = Math.max(e, s)), (n = Math.min(n, s + this.length));
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, s);
    for (let u = e, h = i; u <= n; ) {
      let f = r.doc.lineAt(u);
      if (u == e) {
        let p = f.number - a;
        h += l * p + c * (e - s - p);
      }
      let d = l + c * f.length;
      o(new yi(f.from, f.length, h, d, 0)), (h += d), (u = f.to + 1);
    }
  }
  replace(e, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof dn ? (r[r.length - 1] = new dn(s.length + i)) : r.push(null, new dn(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof dn ? (r[0] = new dn(e + s.length)) : r.unshift(new dn(e - 1), null);
    }
    return Vn.of(r);
  }
  decomposeLeft(e, n) {
    n.push(new dn(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new dn(this.length - e - 1));
  }
  updateHeight(e, n = 0, r = !1, i) {
    let s = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let o = [],
        a = Math.max(n, i.from),
        l = -1;
      for (i.from > n && o.push(new dn(i.from - n - 1).updateHeight(e, n)); a <= s && i.more; ) {
        let u = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let h = i.heights[i.index++];
        l == -1 ? (l = h) : Math.abs(h - l) >= Rd && (l = -2);
        let f = new ur(u, h);
        (f.outdated = !1), o.push(f), (a += u + 1);
      }
      a <= s && o.push(null, new dn(s - a).updateHeight(e, a));
      let c = Vn.of(o);
      return (
        (l < 0 || Math.abs(c.height - this.height) >= Rd || Math.abs(l - this.heightMetrics(e, n).perLine) >= Rd) && (e.heightChanged = !0),
        c
      );
    } else (r || this.outdated) && (this.setHeight(e, e.heightForGap(n, n + this.length)), (this.outdated = !1));
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Gie extends Vn {
  constructor(e, n, r) {
    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)),
      (this.left = e),
      (this.right = r),
      (this.size = e.size + r.size);
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, s, i + this.left.length + this.break);
  }
  lineAt(e, n, r, i, s) {
    let o = i + this.left.height,
      a = s + this.left.length + this.break,
      l = n == _t.ByHeight ? e < o : e < a,
      c = l ? this.left.lineAt(e, n, r, i, s) : this.right.lineAt(e, n, r, o, a);
    if (this.break || (l ? c.to < a : c.from > a)) return c;
    let u = n == _t.ByPosNoHeight ? _t.ByPosNoHeight : _t.ByPos;
    return l ? c.join(this.right.lineAt(a, u, r, o, a)) : this.left.lineAt(a, u, r, i, s).join(c);
  }
  forEachLine(e, n, r, i, s, o) {
    let a = i + this.left.height,
      l = s + this.left.length + this.break;
    if (this.break) e < l && this.left.forEachLine(e, n, r, i, s, o), n >= l && this.right.forEachLine(e, n, r, a, l, o);
    else {
      let c = this.lineAt(l, _t.ByPos, r, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o),
        c.to >= e && c.from <= n && o(c),
        n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, o);
    }
  }
  replace(e, n, r) {
    let i = this.left.length + this.break;
    if (n < i) return this.balanced(this.left.replace(e, n, r), this.right);
    if (e > this.left.length) return this.balanced(this.left, this.right.replace(e - i, n - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let a of r) s.push(a);
    if ((e > 0 && f5(s, o - 1), n < this.length)) {
      let a = s.length;
      this.decomposeRight(n, s), f5(s, a);
    }
    return Vn.of(s);
  }
  decomposeLeft(e, n) {
    let r = this.left.length;
    if (e <= r) return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
  }
  decomposeRight(e, n) {
    let r = this.left.length,
      i = r + this.break;
    if (e >= i) return this.right.decomposeRight(e - i, n);
    e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size
      ? Vn.of(this.break ? [e, null, n] : [e, n])
      : ((this.left = e),
        (this.right = n),
        (this.height = e.height + n.height),
        (this.outdated = e.outdated || n.outdated),
        (this.size = e.size + n.size),
        (this.length = e.length + this.break + n.length),
        this);
  }
  updateHeight(e, n = 0, r = !1, i) {
    let { left: s, right: o } = this,
      a = n + s.length + this.break,
      l = null;
    return (
      i && i.from <= n + s.length && i.more ? (l = s = s.updateHeight(e, n, r, i)) : s.updateHeight(e, n, r),
      i && i.from <= a + o.length && i.more ? (l = o = o.updateHeight(e, a, r, i)) : o.updateHeight(e, a, r),
      l ? this.balanced(s, o) : ((this.height = this.left.height + this.right.height), (this.outdated = !1), this)
    );
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function f5(t, e) {
  let n, r;
  t[e] == null && (n = t[e - 1]) instanceof dn && (r = t[e + 1]) instanceof dn && t.splice(e - 1, 3, new dn(n.length + 1 + r.length));
}
const Jie = 5;
class $w {
  constructor(e, n) {
    (this.pos = e),
      (this.oracle = n),
      (this.nodes = []),
      (this.lineStart = -1),
      (this.lineEnd = -1),
      (this.covering = null),
      (this.writtenTo = e);
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd),
        i = this.nodes[this.nodes.length - 1];
      i instanceof ur ? (i.length += r - this.pos) : (r > this.pos || !this.isCovered) && this.nodes.push(new ur(r - this.pos, -1)),
        (this.writtenTo = r),
        n > r && (this.nodes.push(null), this.writtenTo++, (this.lineStart = -1));
    }
    this.pos = n;
  }
  point(e, n, r) {
    if (e < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0,
        s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = n - e;
      r.block ? this.addBlock(new _4(o, i, r)) : (o || s || i >= Jie) && this.addLineDeco(i, s, o);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    (this.lineStart = e),
      (this.lineEnd = n),
      this.writtenTo < e &&
        ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
        this.nodes.push(null)),
      this.pos > e && this.nodes.push(new ur(this.pos - e, -1)),
      (this.writtenTo = this.pos);
  }
  blankContent(e, n) {
    let r = new dn(n - e);
    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof ur) return e;
    let n = new ur(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(),
      this.nodes.push(e),
      (this.writtenTo = this.pos = this.pos + e.length),
      n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, r) {
    let i = this.ensureLine();
    (i.length += r),
      (i.collapsed += r),
      (i.widgetHeight = Math.max(i.widgetHeight, e)),
      (i.breaks += n),
      (this.writtenTo = this.pos = this.pos + r);
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof ur) && !this.isCovered
      ? this.nodes.push(new ur(0, -1))
      : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes) i instanceof ur && i.updateHeight(this.oracle, r), (r += i ? i.length : 1);
    return this.nodes;
  }
  static build(e, n, r, i) {
    let s = new $w(r, e);
    return Xe.spans(n, r, i, s, 0), s.finish(r);
  }
}
function Kie(t, e, n) {
  let r = new ese();
  return Xe.compare(t, e, n, r, 0), r.changes;
}
class ese {
  constructor() {
    this.changes = [];
  }
  compareRange() {}
  comparePoint(e, n, r, i) {
    (e < n || (r && r.heightRelevant) || (i && i.heightRelevant)) && $v(e, n, this.changes, 5);
  }
}
function tse(t, e) {
  let n = t.getBoundingClientRect(),
    r = t.ownerDocument,
    i = r.defaultView || window,
    s = Math.max(0, n.left),
    o = Math.min(i.innerWidth, n.right),
    a = Math.max(0, n.top),
    l = Math.min(i.innerHeight, n.bottom);
  for (let c = t.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c,
        h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let f = u.getBoundingClientRect();
        (s = Math.max(s, f.left)),
          (o = Math.min(o, f.right)),
          (a = Math.max(a, f.top)),
          (l = c == t.parentNode ? f.bottom : Math.min(l, f.bottom));
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11) c = c.host;
    else break;
  return { left: s - n.left, right: Math.max(s, o) - n.left, top: a - (n.top + e), bottom: Math.max(a, l) - (n.top + e) };
}
function nse(t, e) {
  let n = t.getBoundingClientRect();
  return { left: 0, right: n.right - n.left, top: e, bottom: n.bottom - (n.top + e) };
}
class z0 {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.size = r);
  }
  static same(e, n) {
    if (e.length != n.length) return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r],
        s = n[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size) return !1;
    }
    return !0;
  }
  draw(e, n) {
    return ge.replace({ widget: new rse(this.size * (n ? e.scaleY : e.scaleX), n) }).range(this.from, this.to);
  }
}
class rse extends li {
  constructor(e, n) {
    super(), (this.size = e), (this.vertical = n);
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return (
      this.vertical
        ? (e.style.height = this.size + "px")
        : ((e.style.width = this.size + "px"), (e.style.height = "2px"), (e.style.display = "inline-block")),
      e
    );
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class d5 {
  constructor(e) {
    (this.state = e),
      (this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }),
      (this.inView = !0),
      (this.paddingTop = 0),
      (this.paddingBottom = 0),
      (this.contentDOMWidth = 0),
      (this.contentDOMHeight = 0),
      (this.editorHeight = 0),
      (this.editorWidth = 0),
      (this.scrollTop = 0),
      (this.scrolledToBottom = !1),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.scrollAnchorPos = 0),
      (this.scrollAnchorHeight = -1),
      (this.scaler = p5),
      (this.scrollTarget = null),
      (this.printing = !1),
      (this.mustMeasureContent = !0),
      (this.defaultTextDirection = Pt.LTR),
      (this.visibleRanges = []),
      (this.mustEnforceCursorAssoc = !1);
    let n = e.facet(Pw).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    (this.heightOracle = new qie(n)),
      (this.stateDeco = e.facet(zu).filter((r) => typeof r != "function")),
      (this.heightMap = Vn.empty().applyChanges(this.stateDeco, ot.empty, this.heightOracle.setDoc(e.doc), [
        new Nr(0, 0, 0, e.doc.length),
      ]));
    for (let r = 0; r < 2 && ((this.viewport = this.getViewport(0, null)), !!this.updateForViewport()); r++);
    this.updateViewportLines(),
      (this.lineGaps = this.ensureLineGaps([])),
      (this.lineGapDeco = ge.set(this.lineGaps.map((r) => r.draw(this, !1)))),
      this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport],
      { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new Ff(s, o));
      }
    }
    return (this.viewports = e.sort((r, i) => r.from - i.from)), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return (
      (this.scaler = this.heightMap.height <= 7e6 ? p5 : new Rw(this.heightOracle, this.heightMap, this.viewports)),
      e.eq(this.scaler) ? 0 : 2
    );
  }
  updateViewportLines() {
    (this.viewportLines = []),
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
        this.viewportLines.push(Zc(e, this.scaler));
      });
  }
  update(e, n = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(zu).filter((u) => typeof u != "function");
    let i = e.changedRanges,
      s = Nr.extendWithRanges(i, Kie(r, this.stateDeco, e ? e.changes : qt.empty(this.state.doc.length))),
      o = this.heightMap.height,
      a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    (this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s)),
      this.heightMap.height != o && (e.flags |= 2),
      a
        ? ((this.scrollAnchorPos = e.changes.mapPos(a.from, -1)), (this.scrollAnchorHeight = a.top))
        : ((this.scrollAnchorPos = -1), (this.scrollAnchorHeight = this.heightMap.height));
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    ((n && (n.range.head < l.from || n.range.head > l.to)) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    (this.viewport = l),
      (e.flags |= this.updateForViewport()),
      (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))),
      (e.flags |= this.computeVisibleRanges()),
      n && (this.scrollTarget = n),
      !this.mustEnforceCursorAssoc &&
        e.selectionSet &&
        e.view.lineWrapping &&
        e.state.selection.main.empty &&
        e.state.selection.main.assoc &&
        !e.state.facet(a4) &&
        (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM,
      r = window.getComputedStyle(n),
      i = this.heightOracle,
      s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? Pt.RTL : Pt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s),
      a = n.getBoundingClientRect(),
      l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    (this.contentDOMHeight = a.height), (this.mustMeasureContent = !1);
    let c = 0,
      u = 0;
    if (a.width && a.height) {
      let { scaleX: y, scaleY: S } = N6(n, a);
      ((y > 0.005 && Math.abs(this.scaleX - y) > 0.005) || (S > 0.005 && Math.abs(this.scaleY - S) > 0.005)) &&
        ((this.scaleX = y), (this.scaleY = S), (c |= 8), (o = l = !0));
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY,
      f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && ((this.paddingTop = h), (this.paddingBottom = f), (c |= 10)),
      this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), (this.editorWidth = e.scrollDOM.clientWidth), (c |= 8));
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && ((this.scrollAnchorHeight = -1), (this.scrollTop = d)), (this.scrolledToBottom = D6(e.scrollDOM));
    let p = (this.printing ? nse : tse)(n, this.paddingTop),
      m = p.top - this.pixelViewport.top,
      O = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if ((v != this.inView && ((this.inView = v), v && (l = !0)), !this.inView && !this.scrollTarget)) return 0;
    let g = a.width;
    if (
      ((this.contentDOMWidth != g || this.editorHeight != e.scrollDOM.clientHeight) &&
        ((this.contentDOMWidth = a.width), (this.editorHeight = e.scrollDOM.clientHeight), (c |= 8)),
      l)
    ) {
      let y = e.docView.measureVisibleLineHeights(this.viewport);
      if ((i.mustRefreshForHeights(y) && (o = !0), o || (i.lineWrapping && Math.abs(g - this.contentDOMWidth) > i.charWidth))) {
        let { lineHeight: S, charWidth: k, textHeight: b } = e.docView.measureTextSize();
        (o = S > 0 && i.refresh(s, S, k, b, g / k, y)), o && ((e.docView.minWidth = 0), (c |= 8));
      }
      m > 0 && O > 0 ? (u = Math.max(m, O)) : m < 0 && O < 0 && (u = Math.min(m, O)), (i.heightChanged = !1);
      for (let S of this.viewports) {
        let k = S.from == this.viewport.from ? y : e.docView.measureVisibleLineHeights(S);
        this.heightMap = (
          o ? Vn.empty().applyChanges(this.stateDeco, ot.empty, this.heightOracle, [new Nr(0, 0, 0, e.state.doc.length)]) : this.heightMap
        ).updateHeight(i, 0, o, new Yie(S.from, k));
      }
      i.heightChanged && (c |= 2);
    }
    let x =
      !this.viewportIsAppropriate(this.viewport, u) ||
      (this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to));
    return (
      x && (c & 2 && (c |= this.updateScaler()), (this.viewport = this.getViewport(u, this.scrollTarget)), (c |= this.updateForViewport())),
      (c & 2 || x) && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)),
      (c |= this.computeVisibleRanges()),
      this.mustEnforceCursorAssoc && ((this.mustEnforceCursorAssoc = !1), e.docView.enforceCursorAssoc()),
      c
    );
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)),
      i = this.heightMap,
      s = this.heightOracle,
      { visibleTop: o, visibleBottom: a } = this,
      l = new Ff(i.lineAt(o - r * 1e3, _t.ByHeight, s, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, _t.ByHeight, s, 0, 0).to);
    if (n) {
      let { head: c } = n.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top),
          h = i.lineAt(c, _t.ByPos, s, 0, 0),
          f;
        n.y == "center"
          ? (f = (h.top + h.bottom) / 2 - u / 2)
          : n.y == "start" || (n.y == "nearest" && c < l.from)
          ? (f = h.top)
          : (f = h.bottom - u),
          (l = new Ff(i.lineAt(f - 1e3 / 2, _t.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, _t.ByHeight, s, 0, 0).to));
      }
    }
    return l;
  }
  mapViewport(e, n) {
    let r = n.mapPos(e.from, -1),
      i = n.mapPos(e.to, 1);
    return new Ff(
      this.heightMap.lineAt(r, _t.ByPos, this.heightOracle, 0, 0).from,
      this.heightMap.lineAt(i, _t.ByPos, this.heightOracle, 0, 0).to
    );
  }
  viewportIsAppropriate({ from: e, to: n }, r = 0) {
    if (!this.inView) return !0;
    let { top: i } = this.heightMap.lineAt(e, _t.ByPos, this.heightOracle, 0, 0),
      { bottom: s } = this.heightMap.lineAt(n, _t.ByPos, this.heightOracle, 0, 0),
      { visibleTop: o, visibleBottom: a } = this;
    return (
      (e == 0 || i <= o - Math.max(10, Math.min(-r, 250))) &&
      (n == this.state.doc.length || s >= a + Math.max(10, Math.min(r, 250))) &&
      i > o - 2 * 1e3 &&
      s < a + 2 * 1e3
    );
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty) return e;
    let r = [];
    for (let i of e) n.touchesRange(i.from, i.to) || r.push(new z0(n.mapPos(i.from), n.mapPos(i.to), i.size));
    return r;
  }
  ensureLineGaps(e, n) {
    let r = this.heightOracle.lineWrapping,
      i = r ? 1e4 : 2e3,
      s = i >> 1,
      o = i << 1;
    if (this.defaultTextDirection != Pt.LTR && !r) return [];
    let a = [],
      l = (u, h, f, d) => {
        if (h - u < s) return;
        let p = this.state.selection.main,
          m = [p.from];
        p.empty || m.push(p.to);
        for (let v of m)
          if (v > u && v < h) {
            l(u, v - 10, f, d), l(v + 10, h, f, d);
            return;
          }
        let O = sse(
          e,
          (v) =>
            v.from >= f.from && v.to <= f.to && Math.abs(v.from - u) < s && Math.abs(v.to - h) < s && !m.some((g) => v.from < g && v.to > g)
        );
        if (!O) {
          if (h < f.to && n && r && n.visibleRanges.some((v) => v.from <= h && v.to >= h)) {
            let v = n.moveToLineBoundary(X.cursor(h), !1, !0).head;
            v > u && (h = v);
          }
          O = new z0(u, h, this.gapSize(f, u, h, d));
        }
        a.push(O);
      },
      c = (u) => {
        if (u.length < o || u.type != Fn.Text) return;
        let h = ise(u.from, u.to, this.stateDeco);
        if (h.total < o) return;
        let f = this.scrollTarget ? this.scrollTarget.range.head : null,
          d,
          p;
        if (r) {
          let m = (i / this.heightOracle.lineLength) * this.heightOracle.lineHeight,
            O,
            v;
          if (f != null) {
            let g = Bf(h, f),
              x = ((this.visibleBottom - this.visibleTop) / 2 + m) / u.height;
            (O = g - x), (v = g + x);
          } else (O = (this.visibleTop - u.top - m) / u.height), (v = (this.visibleBottom - u.top + m) / u.height);
          (d = Vf(h, O)), (p = Vf(h, v));
        } else {
          let m = h.total * this.heightOracle.charWidth,
            O = i * this.heightOracle.charWidth,
            v,
            g;
          if (f != null) {
            let x = Bf(h, f),
              y = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + O) / m;
            (v = x - y), (g = x + y);
          } else (v = (this.pixelViewport.left - O) / m), (g = (this.pixelViewport.right + O) / m);
          (d = Vf(h, v)), (p = Vf(h, g));
        }
        d > u.from && l(u.from, d, u, h), p < u.to && l(p, u.to, u, h);
      };
    for (let u of this.viewportLines) Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return a;
  }
  gapSize(e, n, r, i) {
    let s = Bf(i, r) - Bf(i, n);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    z0.same(e, this.lineGaps) ||
      ((this.lineGaps = e), (this.lineGapDeco = ge.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping)))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let n = [];
    Xe.spans(
      e,
      this.viewport.from,
      this.viewport.to,
      {
        span(i, s) {
          n.push({ from: i, to: s });
        },
        point() {},
      },
      20
    );
    let r = n.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != n[s].from || i.to != n[s].to);
    return (this.visibleRanges = n), r ? 4 : 0;
  }
  lineBlockAt(e) {
    return (
      (e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e)) ||
      Zc(this.heightMap.lineAt(e, _t.ByPos, this.heightOracle, 0, 0), this.scaler)
    );
  }
  lineBlockAtHeight(e) {
    return (
      (e >= this.viewportLines[0].top &&
        e <= this.viewportLines[this.viewportLines.length - 1].bottom &&
        this.viewportLines.find((n) => n.top <= e && n.bottom >= e)) ||
      Zc(this.heightMap.lineAt(this.scaler.fromDOM(e), _t.ByHeight, this.heightOracle, 0, 0), this.scaler)
    );
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Zc(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
let Ff = class {
  constructor(e, n) {
    (this.from = e), (this.to = n);
  }
};
function ise(t, e, n) {
  let r = [],
    i = t,
    s = 0;
  return (
    Xe.spans(
      n,
      t,
      e,
      {
        span() {},
        point(o, a) {
          o > i && (r.push({ from: i, to: o }), (s += o - i)), (i = a);
        },
      },
      20
    ),
    i < e && (r.push({ from: i, to: e }), (s += e - i)),
    { total: s, ranges: r }
  );
}
function Vf({ total: t, ranges: e }, n) {
  if (n <= 0) return e[0].from;
  if (n >= 1) return e[e.length - 1].to;
  let r = Math.floor(t * n);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i],
      a = o - s;
    if (r <= a) return s + r;
    r -= a;
  }
}
function Bf(t, e) {
  let n = 0;
  for (let { from: r, to: i } of t.ranges) {
    if (e <= i) {
      n += e - r;
      break;
    }
    n += i - r;
  }
  return n / t.total;
}
function sse(t, e) {
  for (let n of t) if (e(n)) return n;
}
const p5 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  },
};
class Rw {
  constructor(e, n, r) {
    let i = 0,
      s = 0,
      o = 0;
    (this.viewports = r.map(({ from: a, to: l }) => {
      let c = n.lineAt(a, _t.ByPos, e, 0, 0).top,
        u = n.lineAt(l, _t.ByPos, e, 0, 0).bottom;
      return (i += u - c), { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    })),
      (this.scale = (7e6 - i) / (n.height - i));
    for (let a of this.viewports)
      (a.domTop = o + (a.top - s) * this.scale), (o = a.domBottom = a.domTop + (a.bottom - a.top)), (s = a.bottom);
  }
  toDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.top) return i + (e - r) * this.scale;
      if (e <= s.bottom) return s.domTop + (e - s.top);
      (r = s.bottom), (i = s.domBottom);
    }
  }
  fromDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.domTop) return r + (e - i) / this.scale;
      if (e <= s.domBottom) return s.top + (e - s.domTop);
      (r = s.bottom), (i = s.domBottom);
    }
  }
  eq(e) {
    return e instanceof Rw
      ? this.scale == e.scale &&
          this.viewports.length == e.viewports.length &&
          this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to)
      : !1;
  }
}
function Zc(t, e) {
  if (e.scale == 1) return t;
  let n = e.toDOM(t.top),
    r = e.toDOM(t.bottom);
  return new yi(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => Zc(i, e)) : t._content);
}
const jf = ye.define({ combine: (t) => t.join(" ") }),
  Fv = ye.define({ combine: (t) => t.indexOf(!0) > -1 }),
  Vv = ds.newName(),
  E4 = ds.newName(),
  T4 = ds.newName(),
  P4 = { "&light": "." + E4, "&dark": "." + T4 };
function Bv(t, e, n) {
  return new ds(e, {
    finish(r) {
      return /&/.test(r)
        ? r.replace(/&\w*/, (i) => {
            if (i == "&") return t;
            if (!n || !n[i]) throw new RangeError(`Unsupported selector: ${i}`);
            return n[i];
          })
        : t + " " + r;
    },
  });
}
const ose = Bv(
    "." + Vv,
    {
      "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": { outline: "1px dotted #212121" },
        display: "flex !important",
        flexDirection: "column",
      },
      ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
      },
      ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" },
      },
      ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        overflowWrap: "anywhere",
        flexShrink: 1,
      },
      "&light .cm-content": { caretColor: "black" },
      "&dark .cm-content": { caretColor: "white" },
      ".cm-line": { display: "block", padding: "0 2px 0 6px" },
      ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } },
      "&light .cm-selectionBackground": { background: "#d9d9d9" },
      "&dark .cm-selectionBackground": { background: "#222" },
      "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" },
      "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" },
      ".cm-cursorLayer": { pointerEvents: "none" },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" },
      "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" },
      ".cm-cursor": { display: "none" },
      "&dark .cm-cursor": { borderLeftColor: "#444" },
      ".cm-dropCursor": { position: "absolute" },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" },
      ".cm-iso": { unicodeBidi: "isolate" },
      ".cm-announced": { position: "fixed", top: "-10000px" },
      "@media print": { ".cm-announced": { display: "none" } },
      "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
      "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
      "&light .cm-specialChar": { color: "red" },
      "&dark .cm-specialChar": { color: "#f78" },
      ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 },
      "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" },
      "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" },
      ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden",
      },
      ".cm-gutterElement": { boxSizing: "border-box" },
      ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" },
      "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" },
      "&dark .cm-activeLineGutter": { backgroundColor: "#222227" },
      ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 },
      "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" },
      "&light .cm-panels-top": { borderBottom: "1px solid #ddd" },
      "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" },
      "&dark .cm-panels": { backgroundColor: "#333338", color: "white" },
      ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" },
      ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" },
      ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" },
      ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" },
      ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat",
      },
      ".cm-trailingSpace": { backgroundColor: "#ff332255" },
      ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" },
      "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" },
      },
      "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": { backgroundImage: "linear-gradient(#111, #333)" },
      },
      ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" },
      "&light .cm-textfield": { backgroundColor: "white" },
      "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" },
    },
    P4
  ),
  zc = "￿";
class ase {
  constructor(e, n) {
    (this.points = e), (this.text = ""), (this.lineSeparator = n.facet(Qe.lineSeparator));
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += zc;
  }
  readRange(e, n) {
    if (!e) return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == n) break;
      let a = xt.get(i),
        l = xt.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Mp(i)) || (Mp(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s)) &&
        this.lineBreak(),
        (i = o);
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let r of this.points) r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1,
        o = 1,
        a;
      if (
        (this.lineSeparator
          ? ((s = n.indexOf(this.lineSeparator, r)), (o = this.lineSeparator.length))
          : (a = i.exec(n)) && ((s = a.index), (o = a[0].length)),
        this.append(n.slice(r, s < 0 ? n.length : s)),
        s < 0)
      )
        break;
      if ((this.lineBreak(), o > 1)) for (let l of this.points) l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore) return;
    let n = xt.get(e),
      r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; ) i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3
        ? this.readTextNode(e)
        : e.nodeName == "BR"
        ? e.nextSibling && this.lineBreak()
        : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let r of this.points) r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (lse(e, r.node, r.offset) ? n : 0));
  }
}
function lse(t, e, n) {
  for (;;) {
    if (!e || n < ps(e)) return !1;
    if (e == t) return !0;
    (n = Jo(e) + 1), (e = e.parentNode);
  }
}
class m5 {
  constructor(e, n) {
    (this.node = e), (this.offset = n), (this.pos = -1);
  }
}
class cse {
  constructor(e, n, r, i) {
    (this.typeOver = i), (this.bounds = null), (this.text = ""), (this.domChanged = n > -1);
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && n > -1) this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
      let a = s || o ? [] : fse(e),
        l = new ase(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), (this.text = l.text), (this.newSel = dse(a, this.bounds.from));
    } else {
      let a = e.observer.selectionRange,
        l =
          (s && s.node == a.focusNode && s.offset == a.focusOffset) || !Cv(e.contentDOM, a.focusNode)
            ? e.state.selection.main.head
            : e.docView.posFromDOM(a.focusNode, a.focusOffset),
        c =
          (o && o.node == a.anchorNode && o.offset == a.anchorOffset) || !Cv(e.contentDOM, a.anchorNode)
            ? e.state.selection.main.anchor
            : e.docView.posFromDOM(a.anchorNode, a.anchorOffset),
        u = e.viewport;
      if ((be.ios || be.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(l, c),
          f = Math.max(l, c),
          d = u.from - h,
          p = u.to - f;
        (d == 0 || d == 1 || h == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && ((l = 0), (c = e.state.doc.length));
      }
      this.newSel = X.single(c, l);
    }
  }
}
function A4(t, e) {
  let n,
    { newSel: r } = e,
    i = t.state.selection.main,
    s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds,
      l = i.from,
      c = null;
    (s === 8 || (be.android && e.text.length < a - o)) && ((l = i.to), (c = "end"));
    let u = hse(t.state.doc.sliceString(o, a, zc), e.text, l - o, c);
    u &&
      (be.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == zc + zc && u.toB--,
      (n = { from: o + u.from, to: o + u.toA, insert: ot.of(e.text.slice(u.from, u.toB).split(zc)) }));
  } else r && ((!t.hasFocus && t.state.facet(Rs)) || r.main.eq(i)) && (r = null);
  if (!n && !r) return !1;
  if (
    (!n && e.typeOver && !i.empty && r && r.main.empty
      ? (n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) })
      : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4
      ? (n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to)) })
      : (be.mac || be.android) &&
        n &&
        n.from == n.to &&
        n.from == i.head - 1 &&
        /^\. ?$/.test(n.insert.toString()) &&
        t.contentDOM.getAttribute("autocorrect") == "off"
      ? (r && n.insert.length == 2 && (r = X.single(r.main.anchor - 1, r.main.head - 1)),
        (n = { from: i.from, to: i.to, insert: ot.of([" "]) }))
      : be.chrome &&
        n &&
        n.from == n.to &&
        n.from == i.head &&
        n.insert.toString() ==
          `
 ` &&
        t.lineWrapping &&
        (r && (r = X.single(r.main.anchor - 1, r.main.head - 1)), (n = { from: i.from, to: i.to, insert: ot.of([" "]) })),
    n)
  )
    return $4(t, n, r, s);
  if (r && !r.main.eq(i)) {
    let o = !1,
      a = "select";
    return (
      t.inputState.lastSelectionTime > Date.now() - 50 &&
        (t.inputState.lastSelectionOrigin == "select" && (o = !0), (a = t.inputState.lastSelectionOrigin)),
      t.dispatch({ selection: r, scrollIntoView: o, userEvent: a }),
      !0
    );
  } else return !1;
}
function $4(t, e, n, r = -1) {
  if (be.ios && t.inputState.flushIOSKey(e)) return !0;
  let i = t.state.selection.main;
  if (
    be.android &&
    ((e.to == i.to &&
      (e.from == i.from || (e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ")) &&
      e.insert.length == 1 &&
      e.insert.lines == 2 &&
      ol(t.contentDOM, "Enter", 13)) ||
      (((e.from == i.from - 1 && e.to == i.to && e.insert.length == 0) || (r == 8 && e.insert.length < e.to - e.from && e.to > i.head)) &&
        ol(t.contentDOM, "Backspace", 8)) ||
      (e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && ol(t.contentDOM, "Delete", 46)))
  )
    return !0;
  let s = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let o,
    a = () => o || (o = use(t, e, n));
  return t.state.facet(i4).some((l) => l(t, e.from, e.to, s, a)) || t.dispatch(a()), !0;
}
function use(t, e, n) {
  let r,
    i = t.state,
    s = i.selection.main;
  if (
    e.from >= s.from &&
    e.to <= s.to &&
    e.to - e.from >= (s.to - s.from) / 3 &&
    (!n || (n.main.empty && n.main.from == e.from + e.insert.length)) &&
    t.inputState.composing < 0
  ) {
    let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : "",
      l = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));
  } else {
    let a = i.changes(e),
      l = n && n.main.to <= a.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to),
        u,
        h = n && m4(t, n.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - p };
      } else u = t.state.doc.lineAt(s.head);
      let f = s.to - e.to,
        d = s.to - s.from;
      r = i.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to) return { changes: a, range: l || p.map(a) };
        let m = p.to - f,
          O = m - c.length;
        if (p.to - p.from != d || t.state.sliceDoc(O, m) != c || (p.to >= u.from && p.from <= u.to)) return { range: p };
        let v = i.changes({ from: O, to: m, insert: e.insert }),
          g = p.to - s.to;
        return { changes: v, range: l ? X.range(Math.max(0, l.anchor + g), Math.max(0, l.head + g)) : p.map(v) };
      });
    } else r = { changes: a, selection: l && i.selection.replaceRange(l) };
  }
  let o = "input.type";
  return (
    (t.composing || (t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50)) &&
      ((t.inputState.compositionPendingChange = !1),
      (o += ".compose"),
      t.inputState.compositionFirstChange && ((o += ".start"), (t.inputState.compositionFirstChange = !1))),
    i.update(r, { userEvent: o, scrollIntoView: !0 })
  );
}
function hse(t, e, n, r) {
  let i = Math.min(t.length, e.length),
    s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); ) s++;
  if (s == i && t.length == e.length) return null;
  let o = t.length,
    a = e.length;
  for (; o > 0 && a > 0 && t.charCodeAt(o - 1) == e.charCodeAt(a - 1); ) o--, a--;
  if (r == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    n -= o + l - s;
  }
  if (o < s && t.length < e.length) {
    let l = n <= s && n >= o ? s - n : 0;
    (s -= l), (a = s + (a - o)), (o = s);
  } else if (a < s) {
    let l = n <= s && n >= a ? s - n : 0;
    (s -= l), (o = s + (o - a)), (a = s);
  }
  return { from: s, toA: o, toB: a };
}
function fse(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM) return e;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return n && (e.push(new m5(n, r)), (i != n || s != r) && e.push(new m5(i, s))), e;
}
function dse(t, e) {
  if (t.length == 0) return null;
  let n = t[0].pos,
    r = t.length == 2 ? t[1].pos : n;
  return n > -1 && r > -1 ? X.single(n + e, r + e) : null;
}
const pse = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 },
  W0 = be.ie && be.ie_version <= 11;
class mse {
  constructor(e) {
    (this.view = e),
      (this.active = !1),
      (this.editContext = null),
      (this.selectionRange = new Kre()),
      (this.selectionChanged = !1),
      (this.delayedFlush = -1),
      (this.resizeTimeout = -1),
      (this.queue = []),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1),
      (this.lastChange = 0),
      (this.scrollTargets = []),
      (this.intersection = null),
      (this.resizeScroll = null),
      (this.intersecting = !1),
      (this.gapIntersection = null),
      (this.gaps = []),
      (this.printQuery = null),
      (this.parentCheck = -1),
      (this.dom = e.contentDOM),
      (this.observer = new MutationObserver((n) => {
        for (let r of n) this.queue.push(r);
        ((be.ie && be.ie_version <= 11) || (be.ios && e.composing)) &&
        n.some(
          (r) =>
            (r.type == "childList" && r.removedNodes.length) || (r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length)
        )
          ? this.flushSoon()
          : this.flush();
      })),
      window.EditContext &&
        e.constructor.EDIT_CONTEXT !== !1 &&
        !(be.chrome && be.chrome_version < 126) &&
        ((this.editContext = new Ose(e)), e.state.facet(Rs) && (e.contentDOM.editContext = this.editContext.editContext)),
      W0 &&
        (this.onCharData = (n) => {
          this.queue.push({ target: n.target, type: "characterData", oldValue: n.prevValue }), this.flushSoon();
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this)),
      (this.onResize = this.onResize.bind(this)),
      (this.onPrint = this.onPrint.bind(this)),
      (this.onScroll = this.onScroll.bind(this)),
      window.matchMedia && (this.printQuery = window.matchMedia("print")),
      typeof ResizeObserver == "function" &&
        ((this.resizeScroll = new ResizeObserver(() => {
          var n;
          ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
        })),
        this.resizeScroll.observe(e.scrollDOM)),
      this.addWindowListeners((this.win = e.win)),
      this.start(),
      typeof IntersectionObserver == "function" &&
        ((this.intersection = new IntersectionObserver(
          (n) => {
            this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)),
              n.length > 0 &&
                n[n.length - 1].intersectionRatio > 0 != this.intersecting &&
                ((this.intersecting = !this.intersecting),
                this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
          },
          { threshold: [0, 0.001] }
        )),
        this.intersection.observe(this.dom),
        (this.gapIntersection = new IntersectionObserver((n) => {
          n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
        }, {}))),
      this.listenForScroll(),
      this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 &&
      (this.resizeTimeout = setTimeout(() => {
        (this.resizeTimeout = -1), this.view.requestMeasure();
      }, 50));
  }
  onPrint(e) {
    (e.type == "change" && !e.matches) ||
      ((this.view.viewState.printing = !0),
      this.view.measure(),
      setTimeout(() => {
        (this.view.viewState.printing = !1), this.view.requestMeasure();
      }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
      this.gapIntersection.disconnect();
      for (let n of e) this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: r } = this,
      i = this.selectionRange;
    if (r.state.facet(Rs) ? r.root.activeElement != this.dom : !Ad(r.dom, i)) return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    ((be.ie && be.ie_version <= 11) || (be.android && be.chrome)) &&
    !r.state.selection.main.empty &&
    i.focusNode &&
    hu(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset)
      ? this.flushSoon()
      : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this,
      n = ju(e.root);
    if (!n) return !1;
    let r = (be.safari && e.root.nodeType == 11 && qre(this.dom.ownerDocument) == this.dom && gse(this.view, n)) || n;
    if (!r || this.selectionRange.eq(r)) return !1;
    let i = Ad(this.dom, r);
    return i &&
      !this.selectionChanged &&
      e.inputState.lastFocusTime > Date.now() - 200 &&
      e.inputState.lastTouchTime < Date.now() - 300 &&
      tie(this.dom, r)
      ? ((this.view.inputState.lastFocusTime = 0), e.docView.updateSelection(), !1)
      : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), (this.selectionChanged = !1);
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0,
      n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)),
          n && n.push(r),
          (r = r.assignedSlot || r.parentNode);
      else if (r.nodeType == 11) r = r.host;
      else break;
    if ((e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n)) {
      for (let r of this.scrollTargets) r.removeEventListener("scroll", this.onScroll);
      for (let r of (this.scrollTargets = n)) r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active) return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active ||
      (this.observer.observe(this.dom, pse),
      W0 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
      (this.active = !0));
  }
  stop() {
    this.active &&
      ((this.active = !1), this.observer.disconnect(), W0 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), (this.queue.length = 0), (this.selectionChanged = !1);
  }
  delayAndroidKey(e, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s &&
          (this.clearDelayedAndroidKey(),
          (this.view.inputState.lastKeyCode = s.keyCode),
          (this.view.inputState.lastKeyTime = Date.now()),
          !this.flush() && s.force && ol(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") &&
      (this.delayedAndroidKey = {
        key: e,
        keyCode: n,
        force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force),
      });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), (this.delayedAndroidKey = null), (this.flushingAndroidKey = -1);
  }
  flushSoon() {
    this.delayedFlush < 0 &&
      (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        (this.delayedFlush = -1), this.flush();
      }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), (this.delayedFlush = -1)), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords()) this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1,
      r = -1,
      i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), n == -1 ? ({ from: n, to: r } = o) : ((n = Math.min(o.from, n)), (r = Math.max(o.to, r))));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: n, typeOver: r } = this.processRecords(),
      i = this.selectionChanged && Ad(this.dom, this.selectionRange);
    if (e < 0 && !i) return null;
    e > -1 && (this.lastChange = Date.now()), (this.view.inputState.lastFocusTime = 0), (this.selectionChanged = !1);
    let s = new cse(this.view, e, n, r);
    return (this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }), s;
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n) return this.view.requestMeasure(), !1;
    let r = this.view.state,
      i = A4(this.view, n);
    return (
      this.view.state == r && (n.domChanged || (n.newSel && !n.newSel.main.eq(this.view.state.selection.main))) && this.view.update([]), i
    );
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e)) return null;
    if ((n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList")) {
      let r = g5(n, e.previousSibling || e.target.previousSibling, -1),
        i = g5(n, e.nextSibling || e.target.nextSibling, 1);
      return { from: r ? n.posAfter(r) : n.posAtStart, to: i ? n.posBefore(i) : n.posAtEnd, typeOver: !1 };
    } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), (this.win = e), this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize),
      this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : e.addEventListener("beforeprint", this.onPrint),
      e.addEventListener("scroll", this.onScroll),
      e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll),
      e.removeEventListener("resize", this.onResize),
      this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : e.removeEventListener("beforeprint", this.onPrint),
      e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext &&
      (this.editContext.update(e),
      e.startState.facet(Rs) != e.state.facet(Rs) &&
        (e.view.contentDOM.editContext = e.state.facet(Rs) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, r;
    this.stop(),
      (e = this.intersection) === null || e === void 0 || e.disconnect(),
      (n = this.gapIntersection) === null || n === void 0 || n.disconnect(),
      (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets) i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win),
      clearTimeout(this.parentCheck),
      clearTimeout(this.resizeTimeout),
      this.win.cancelAnimationFrame(this.delayedFlush),
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function g5(t, e, n) {
  for (; e; ) {
    let r = xt.get(e);
    if (r && r.parent == t) return r;
    let i = e.parentNode;
    e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function O5(t, e) {
  let n = e.startContainer,
    r = e.startOffset,
    i = e.endContainer,
    s = e.endOffset,
    o = t.docView.domAtPos(t.state.selection.main.anchor);
  return hu(o.node, o.offset, i, s) && ([n, r, i, s] = [i, s, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s };
}
function gse(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i) return O5(t, i);
  }
  let n = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), (n = i.getTargetRanges()[0]);
  }
  return (
    t.contentDOM.addEventListener("beforeinput", r, !0),
    t.dom.ownerDocument.execCommand("indent"),
    t.contentDOM.removeEventListener("beforeinput", r, !0),
    n ? O5(t, n) : null
  );
}
class Ose {
  constructor(e) {
    (this.from = 0), (this.to = 0), (this.pendingContextChange = null), this.resetRange(e.state);
    let n = (this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head),
    }));
    n.addEventListener("textupdate", (r) => {
      let { anchor: i } = e.state.selection.main,
        s = {
          from: this.toEditorPos(r.updateRangeStart),
          to: this.toEditorPos(r.updateRangeEnd),
          insert: ot.of(
            r.text.split(`
`)
          ),
        };
      s.from == this.from && i < this.from ? (s.from = i) : s.to == this.to && i > this.to && (s.to = i),
        !(s.from == s.to && !s.insert.length) &&
          ((this.pendingContextChange = s),
          $4(e, s, X.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd))),
          this.pendingContextChange && this.revertPending(e.state));
    }),
      n.addEventListener("characterboundsupdate", (r) => {
        let i = [],
          s = null;
        for (let o = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); o < a; o++) {
          let l = e.coordsForChar(o);
          (s = (l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top)) || s || new DOMRect()), i.push(s);
        }
        n.updateCharacterBounds(r.rangeStart, i);
      }),
      n.addEventListener("textformatupdate", (r) => {
        let i = [];
        for (let s of r.getTextFormats()) {
          let o = s.underlineStyle,
            a = s.underlineThickness;
          if (o != "None" && a != "None") {
            let l = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
            i.push(ge.mark({ attributes: { style: l } }).range(this.toEditorPos(s.rangeStart), this.toEditorPos(s.rangeEnd)));
          }
        }
        e.dispatch({ effects: c4.of(ge.set(i)) });
      }),
      n.addEventListener("compositionstart", () => {
        e.inputState.composing < 0 && ((e.inputState.composing = 0), (e.inputState.compositionFirstChange = !0));
      }),
      n.addEventListener("compositionend", () => {
        (e.inputState.composing = -1), (e.inputState.compositionFirstChange = null);
      }),
      (this.measureReq = {
        read: (r) => {
          this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
          let i = ju(r.root);
          i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
        },
      });
  }
  applyEdits(e) {
    let n = 0,
      r = !1,
      i = this.pendingContextChange;
    return (
      e.changes.iterChanges((s, o, a, l, c) => {
        if (r) return;
        let u = c.length - (o - s);
        if (i && o >= i.to)
          if (i.from == s && i.to == o && i.insert.eq(c)) {
            (i = this.pendingContextChange = null), (n += u), (this.to += u);
            return;
          } else (i = null), this.revertPending(e.state);
        if (((s += n), (o += n), o <= this.from)) (this.from += u), (this.to += u);
        else if (s < this.to) {
          if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
            r = !0;
            return;
          }
          this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), (this.to += u);
        }
        n += u;
      }),
      i && !r && this.revertPending(e.state),
      !r
    );
  }
  update(e) {
    !this.applyEdits(e) || !this.rangeIsValid(e.state)
      ? ((this.pendingContextChange = null),
        this.resetRange(e.state),
        this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)),
        this.setSelection(e.state))
      : (e.docChanged || e.selectionSet) && this.setSelection(e.state),
      (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    (this.from = Math.max(0, n - 1e4)), (this.to = Math.min(e.doc.length, n + 1e4));
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    (this.pendingContextChange = null),
      this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.to + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection,
      r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))),
      i = this.toContextPos(n.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !((this.from > 0 && n - this.from < 500) || (this.to < e.doc.length && this.to - n < 500) || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e) {
    return e + this.from;
  }
  toContextPos(e) {
    return e - this.from;
  }
}
class re {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(e = {}) {
    (this.plugins = []),
      (this.pluginMap = new Map()),
      (this.editorAttrs = {}),
      (this.contentAttrs = {}),
      (this.bidiCache = []),
      (this.destroyed = !1),
      (this.updateState = 2),
      (this.measureScheduled = -1),
      (this.measureRequests = []),
      (this.contentDOM = document.createElement("div")),
      (this.scrollDOM = document.createElement("div")),
      (this.scrollDOM.tabIndex = -1),
      (this.scrollDOM.className = "cm-scroller"),
      this.scrollDOM.appendChild(this.contentDOM),
      (this.announceDOM = document.createElement("div")),
      (this.announceDOM.className = "cm-announced"),
      this.announceDOM.setAttribute("aria-live", "polite"),
      (this.dom = document.createElement("div")),
      this.dom.appendChild(this.announceDOM),
      this.dom.appendChild(this.scrollDOM),
      e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    (this.dispatchTransactions = e.dispatchTransactions || (n && ((r) => r.forEach((i) => n(i, this)))) || ((r) => this.update(r))),
      (this.dispatch = this.dispatch.bind(this)),
      (this._root = e.root || eie(e.parent) || document),
      (this.viewState = new d5(e.state || Qe.create(e))),
      e.scrollTo && e.scrollTo.is(Mf) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)),
      (this.plugins = this.state.facet(Bc).map((r) => new B0(r)));
    for (let r of this.plugins) r.update(this);
    (this.observer = new mse(this)),
      (this.inputState = new Rie(this)),
      this.inputState.ensureHandlers(this.plugins),
      (this.docView = new q_(this)),
      this.mountStyles(),
      this.updateAttrs(),
      (this.updateState = 0),
      this.requestMeasure();
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof Gt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  update(e) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1,
      r = !1,
      i,
      s = this.state;
    for (let f of e) {
      if (f.startState != s) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus,
      a = 0,
      l = null;
    e.some((f) => f.annotation(S4))
      ? ((this.inputState.notifiedFocused = o), (a = 1))
      : o != this.inputState.notifiedFocused && ((this.inputState.notifiedFocused = o), (l = k4(s, o)), l || (a = 1));
    let c = this.observer.delayedAndroidKey,
      u = null;
    if (
      (c
        ? (this.observer.clearDelayedAndroidKey(),
          (u = this.observer.readChange()),
          ((u && !this.state.doc.eq(s.doc)) || !this.state.selection.eq(s.selection)) && (u = null))
        : this.observer.clear(),
      s.facet(Qe.phrases) != this.state.facet(Qe.phrases))
    )
      return this.setState(s);
    (i = Qp.create(this, s, e)), (i.flags |= a);
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if ((h && (h = h.map(f.changes)), f.scrollIntoView)) {
          let { main: d } = f.state.selection;
          h = new al(d.empty ? d : X.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects) d.is(Mf) && (h = d.value.clip(this.state));
      }
      this.viewState.update(i, h),
        (this.bidiCache = Fp.update(this.bidiCache, i.changes)),
        i.empty || (this.updatePlugins(i), this.inputState.update(i)),
        (n = this.docView.update(i)),
        this.state.facet(jc) != this.styleModules && this.mountStyles(),
        (r = this.updateAttrs()),
        this.showAnnouncements(e),
        this.docView.updateSelection(
          n,
          e.some((f) => f.isUserEvent("select.pointer"))
        );
    } finally {
      this.updateState = 0;
    }
    if (
      (i.startState.facet(jf) != i.state.facet(jf) && (this.viewState.mustMeasureContent = !0),
      (n || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(),
      n && this.docViewUpdate(),
      !i.empty)
    )
      for (let f of this.state.facet(Lv))
        try {
          f(i);
        } catch (d) {
          Kn(this.state, d, "update listener");
        }
    (l || u) &&
      Promise.resolve().then(() => {
        l && this.state == l.startState && this.dispatch(l), u && !A4(this, u) && c.force && ol(this.contentDOM, c.key, c.keyCode);
      });
  }
  setState(e) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins) r.destroy(this);
      (this.viewState = new d5(e)), (this.plugins = e.facet(Bc).map((r) => new B0(r))), this.pluginMap.clear();
      for (let r of this.plugins) r.update(this);
      this.docView.destroy(),
        (this.docView = new q_(this)),
        this.inputState.ensureHandlers(this.plugins),
        this.mountStyles(),
        this.updateAttrs(),
        (this.bidiCache = []);
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(Bc),
      r = e.state.facet(Bc);
    if (n != r) {
      let i = [];
      for (let s of r) {
        let o = n.indexOf(s);
        if (o < 0) i.push(new B0(s));
        else {
          let a = this.plugins[o];
          (a.mustUpdate = e), i.push(a);
        }
      }
      for (let s of this.plugins) s.mustUpdate != e && s.destroy(this);
      (this.plugins = i), this.pluginMap.clear();
    } else for (let i of this.plugins) i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (r) {
          Kn(this.state, r, "doc view update listener");
        }
    }
  }
  measure(e = !0) {
    if (this.destroyed) return;
    if ((this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey)) {
      (this.measureScheduled = -1), this.requestMeasure();
      return;
    }
    (this.measureScheduled = 0), e && this.observer.forceFlush();
    let n = null,
      r = this.scrollDOM,
      i = r.scrollTop * this.scaleY,
      { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), (this.viewState.scrollAnchorHeight = -1);
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (D6(r)) (s = -1), (o = this.viewState.heightMap.height);
          else {
            let d = this.viewState.scrollAnchorAt(i);
            (s = d.from), (o = d.top);
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((d) => {
            try {
              return d.read(this);
            } catch (p) {
              return Kn(this.state, p), v5;
            }
          }),
          h = Qp.create(this, this.state, []),
          f = !1;
        (h.flags |= l),
          n ? (n.flags |= l) : (n = h),
          (this.updateState = 2),
          h.empty ||
            (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), (f = this.docView.update(h)), f && this.docViewUpdate());
        for (let d = 0; d < c.length; d++)
          if (u[d] != v5)
            try {
              let p = c[d];
              p.write && p.write(u[d], this);
            } catch (p) {
              Kn(this.state, p);
            }
        if ((f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0)) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), (this.viewState.scrollTarget = null), (o = -1);
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                (i = i + p), (r.scrollTop = i / this.scaleY), (o = -1);
                continue;
              }
            }
          break;
        }
      }
    } finally {
      (this.updateState = 0), (this.measureScheduled = -1);
    }
    if (n && !n.empty) for (let a of this.state.facet(Lv)) a(n);
  }
  get themeClasses() {
    return Vv + " " + (this.state.facet(Fv) ? T4 : E4) + " " + this.state.facet(jf);
  }
  updateAttrs() {
    let e = x5(this, u4, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }),
      n = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: this.state.facet(Rs) ? "true" : "false",
        class: "cm-content",
        style: `${be.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true",
      };
    this.state.readOnly && (n["aria-readonly"] = "true"), x5(this, Pw, n);
    let r = this.observer.ignore(() => {
      let i = Av(this.contentDOM, this.contentAttrs, n),
        s = Av(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return (this.editorAttrs = e), (this.contentAttrs = n), r;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(re.announce)) {
          n && (this.announceDOM.textContent = ""), (n = !1);
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(jc);
    let e = this.state.facet(re.cspNonce);
    ds.mount(this.root, this.styleModules.concat(ose).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(e) {
    if ((this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e)) {
      if (this.measureRequests.indexOf(e) > -1) return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (
      (n === void 0 || (n && n.spec != e)) && this.pluginMap.set(e, (n = this.plugins.find((r) => r.spec == e) || null)),
      n && n.update(this).value
    );
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(e, n, r) {
    return Z0(this, e, t5(this, e, n, r));
  }
  moveByGroup(e, n) {
    return Z0(
      this,
      e,
      t5(this, e, n, (r) => Aie(this, e.head, r))
    );
  }
  visualLineSide(e, n) {
    let r = this.bidiSpans(e),
      i = this.textDirectionAt(e.from),
      s = r[n ? r.length - 1 : 0];
    return X.cursor(s.side(n, i) + e.from, s.forward(!n, i) ? 1 : -1);
  }
  moveToLineBoundary(e, n, r = !0) {
    return Pie(this, e, n, r);
  }
  moveVertically(e, n, r) {
    return Z0(this, e, $ie(this, e, n, r));
  }
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), g4(this, e, n);
  }
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, n);
    if (!r || r.left == r.right) return r;
    let i = this.state.doc.lineAt(e),
      s = this.bidiSpans(i),
      o = s[Bs.find(s, e - i.from, -1, n)];
    return _w(r, (o.dir == Pt.LTR) == n > 0);
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(e) {
    return !this.state.facet(o4) || e < this.viewport.from || e > this.viewport.to
      ? this.textDirection
      : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(e) {
    if (e.length > vse) return J6(e.length);
    let n = this.textDirectionAt(e.from),
      r;
    for (let s of this.bidiCache) if (s.from == e.from && s.dir == n && (s.fresh || G6(s.isolates, (r = H_(this, e))))) return s.order;
    r || (r = H_(this, e));
    let i = die(e.text, n, r);
    return this.bidiCache.push(new Fp(e.from, e.to, n, r, !0, i)), i;
  }
  get hasFocus() {
    var e;
    return (
      (this.dom.ownerDocument.hasFocus() ||
        (be.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4)) &&
      this.root.activeElement == this.contentDOM
    );
  }
  focus() {
    this.observer.ignore(() => {
      L6(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(e) {
    this._root != e &&
      ((this._root = e), this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins) e.destroy(this);
    (this.plugins = []),
      this.inputState.destroy(),
      this.docView.destroy(),
      this.dom.remove(),
      this.observer.destroy(),
      this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
      (this.destroyed = !0);
  }
  static scrollIntoView(e, n = {}) {
    return Mf.of(new al(typeof e == "number" ? X.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM,
      r = this.viewState.scrollAnchorAt(e);
    return Mf.of(new al(X.cursor(r.from), "start", "start", r.top - e, n, !0));
  }
  setTabFocusMode(e) {
    e == null
      ? (this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1)
      : typeof e == "boolean"
      ? (this.inputState.tabFocusMode = e ? 0 : -1)
      : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  static domEventHandlers(e) {
    return Dt.define(() => ({}), { eventHandlers: e });
  }
  static domEventObservers(e) {
    return Dt.define(() => ({}), { eventObservers: e });
  }
  static theme(e, n) {
    let r = ds.newName(),
      i = [jf.of(r), jc.of(Bv(`.${r}`, e))];
    return n && n.dark && i.push(Fv.of(!0)), i;
  }
  static baseTheme(e) {
    return ai.lowest(jc.of(Bv("." + Vv, e, P4)));
  }
  static findFromDOM(e) {
    var n;
    let r = e.querySelector(".cm-content"),
      i = (r && xt.get(r)) || xt.get(e);
    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
re.styleModule = jc;
re.inputHandler = i4;
re.scrollHandler = l4;
re.focusChangeEffect = s4;
re.perLineTextDirection = o4;
re.exceptionSink = r4;
re.updateListener = Lv;
re.editable = Rs;
re.mouseSelectionStyle = n4;
re.dragMovesSelection = t4;
re.clickAddsSelectionRange = e4;
re.decorations = zu;
re.outerDecorations = h4;
re.atomicRanges = Aw;
re.bidiIsolatedRanges = f4;
re.scrollMargins = d4;
re.darkTheme = Fv;
re.cspNonce = ye.define({ combine: (t) => (t.length ? t[0] : "") });
re.contentAttributes = Pw;
re.editorAttributes = u4;
re.lineWrapping = re.contentAttributes.of({ class: "cm-lineWrapping" });
re.announce = Ae.define();
const vse = 4096,
  v5 = {};
class Fp {
  constructor(e, n, r, i, s, o) {
    (this.from = e), (this.to = n), (this.dir = r), (this.isolates = i), (this.fresh = s), (this.order = o);
  }
  static update(e, n) {
    if (n.empty && !e.some((s) => s.fresh)) return e;
    let r = [],
      i = e.length ? e[e.length - 1].dir : Pt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i &&
        !n.touchesRange(o.from, o.to) &&
        r.push(new Fp(n.mapPos(o.from, 1), n.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function x5(t, e, n) {
  for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i],
      o = typeof s == "function" ? s(t) : s;
    o && Pv(o, n);
  }
  return n;
}
const xse = be.mac ? "mac" : be.windows ? "win" : be.linux ? "linux" : "key";
function bse(t, e) {
  const n = t.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, a;
  for (let l = 0; l < n.length - 1; ++l) {
    const c = n[l];
    if (/^(cmd|meta|m)$/i.test(c)) a = !0;
    else if (/^a(lt)?$/i.test(c)) i = !0;
    else if (/^(c|ctrl|control)$/i.test(c)) s = !0;
    else if (/^s(hift)?$/i.test(c)) o = !0;
    else if (/^mod$/i.test(c)) e == "mac" ? (a = !0) : (s = !0);
    else throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), a && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function Zf(t, e, n) {
  return (
    e.altKey && (t = "Alt-" + t),
    e.ctrlKey && (t = "Ctrl-" + t),
    e.metaKey && (t = "Meta-" + t),
    n !== !1 && e.shiftKey && (t = "Shift-" + t),
    t
  );
}
const yse = ai.default(
    re.domEventHandlers({
      keydown(t, e) {
        return I4(R4(e.state), t, e, "editor");
      },
    })
  ),
  ta = ye.define({ enables: yse }),
  b5 = new WeakMap();
function R4(t) {
  let e = t.facet(ta),
    n = b5.get(e);
  return n || b5.set(e, (n = kse(e.reduce((r, i) => r.concat(i), [])))), n;
}
function wse(t, e, n) {
  return I4(R4(t.state), e, t, n);
}
let Is = null;
const Sse = 4e3;
function kse(t, e = xse) {
  let n = Object.create(null),
    r = Object.create(null),
    i = (o, a) => {
      let l = r[o];
      if (l == null) r[o] = a;
      else if (l != a) throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
    },
    s = (o, a, l, c, u) => {
      var h, f;
      let d = n[o] || (n[o] = Object.create(null)),
        p = a.split(/ (?!$)/).map((v) => bse(v, e));
      for (let v = 1; v < p.length; v++) {
        let g = p.slice(0, v).join(" ");
        i(g, !0),
          d[g] ||
            (d[g] = {
              preventDefault: !0,
              stopPropagation: !1,
              run: [
                (x) => {
                  let y = (Is = { view: x, prefix: g, scope: o });
                  return (
                    setTimeout(() => {
                      Is == y && (Is = null);
                    }, Sse),
                    !0
                  );
                },
              ],
            });
      }
      let m = p.join(" ");
      i(m, !1);
      let O =
        d[m] ||
        (d[m] = {
          preventDefault: !1,
          stopPropagation: !1,
          run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || [],
        });
      l && O.run.push(l), c && (O.preventDefault = !0), u && (O.stopPropagation = !0);
    };
  for (let o of t) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let u = n[c] || (n[c] = Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = o;
        for (let f in u) u[f].run.push((d) => h(d, jv));
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return n;
}
let jv = null;
function I4(t, e, n, r) {
  jv = e;
  let i = Hre(e),
    s = mn(i, 0),
    o = Pr(s) == i.length && i != " ",
    a = "",
    l = !1,
    c = !1,
    u = !1;
  Is && Is.view == n && Is.scope == r && ((a = Is.prefix + " "), v4.indexOf(e.keyCode) < 0 && ((c = !0), (Is = null)));
  let h = new Set(),
    f = (O) => {
      if (O) {
        for (let v of O.run) if (!h.has(v) && (h.add(v), v(n))) return O.stopPropagation && (u = !0), !0;
        O.preventDefault && (O.stopPropagation && (u = !0), (c = !0));
      }
      return !1;
    },
    d = t[r],
    p,
    m;
  return (
    d &&
      (f(d[a + Zf(i, e, !o)])
        ? (l = !0)
        : o && (e.altKey || e.metaKey || e.ctrlKey) && !(be.windows && e.ctrlKey && e.altKey) && (p = io[e.keyCode]) && p != i
        ? (f(d[a + Zf(p, e, !0)]) || (e.shiftKey && (m = Bu[e.keyCode]) != i && m != p && f(d[a + Zf(m, e, !1)]))) && (l = !0)
        : o && e.shiftKey && f(d[a + Zf(i, e, !0)]) && (l = !0),
      !l && f(d._any) && (l = !0)),
    c && (l = !0),
    l && u && e.stopPropagation(),
    (jv = null),
    l
  );
}
class rf {
  constructor(e, n, r, i, s) {
    (this.className = e), (this.left = n), (this.top = r), (this.width = i), (this.height = s);
  }
  draw() {
    let e = document.createElement("div");
    return (e.className = this.className), this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    (e.style.left = this.left + "px"),
      (e.style.top = this.top + "px"),
      this.width != null && (e.style.width = this.width + "px"),
      (e.style.height = this.height + "px");
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  static forRange(e, n, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i) return [];
      let s = N4(e);
      return [new rf(n, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else return Cse(e, n, r);
  }
}
function N4(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return {
    left: (t.textDirection == Pt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX,
    top: e.top - t.scrollDOM.scrollTop * t.scaleY,
  };
}
function y5(t, e, n, r) {
  let i = t.coordsAtPos(e, n * 2);
  if (!i) return r;
  let s = t.dom.getBoundingClientRect(),
    o = (i.top + i.bottom) / 2,
    a = t.posAtCoords({ x: s.left + 1, y: o }),
    l = t.posAtCoords({ x: s.right - 1, y: o });
  return a == null || l == null ? r : { from: Math.max(r.from, Math.min(a, l)), to: Math.min(r.to, Math.max(a, l)) };
}
function Cse(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to) return [];
  let r = Math.max(n.from, t.viewport.from),
    i = Math.min(n.to, t.viewport.to),
    s = t.textDirection == Pt.LTR,
    o = t.contentDOM,
    a = o.getBoundingClientRect(),
    l = N4(t),
    c = o.querySelector(".cm-line"),
    u = c && window.getComputedStyle(c),
    h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0),
    f = a.right - (u ? parseInt(u.paddingRight) : 0),
    d = Dv(t, r),
    p = Dv(t, i),
    m = d.type == Fn.Text ? d : null,
    O = p.type == Fn.Text ? p : null;
  if (
    (m && (t.lineWrapping || d.widgetLineBreaks) && (m = y5(t, r, 1, m)),
    O && (t.lineWrapping || p.widgetLineBreaks) && (O = y5(t, i, -1, O)),
    m && O && m.from == O.from && m.to == O.to)
  )
    return g(x(n.from, n.to, m));
  {
    let S = m ? x(n.from, null, m) : y(d, !1),
      k = O ? x(null, n.to, O) : y(p, !0),
      b = [];
    return (
      (m || d).to < (O || p).from - (m && O ? 1 : 0) || (d.widgetLineBreaks > 1 && S.bottom + t.defaultLineHeight / 2 < k.top)
        ? b.push(v(h, S.bottom, f, k.top))
        : S.bottom < k.top && t.elementAtHeight((S.bottom + k.top) / 2).type == Fn.Text && (S.bottom = k.top = (S.bottom + k.top) / 2),
      g(S).concat(b).concat(g(k))
    );
  }
  function v(S, k, b, _) {
    return new rf(e, S - l.left, k - l.top - 0.01, b - S, _ - k + 0.01);
  }
  function g({ top: S, bottom: k, horizontal: b }) {
    let _ = [];
    for (let T = 0; T < b.length; T += 2) _.push(v(b[T], S, b[T + 1], k));
    return _;
  }
  function x(S, k, b) {
    let _ = 1e9,
      T = -1e9,
      P = [];
    function M(Q, N, G, H, te) {
      let le = t.coordsAtPos(Q, Q == b.to ? -2 : 2),
        $ = t.coordsAtPos(G, G == b.from ? 2 : -2);
      !le ||
        !$ ||
        ((_ = Math.min(le.top, $.top, _)),
        (T = Math.max(le.bottom, $.bottom, T)),
        te == Pt.LTR ? P.push(s && N ? h : le.left, s && H ? f : $.right) : P.push(!s && H ? h : $.left, !s && N ? f : le.right));
    }
    let D = S ?? b.from,
      V = k ?? b.to;
    for (let Q of t.visibleRanges)
      if (Q.to > D && Q.from < V)
        for (let N = Math.max(Q.from, D), G = Math.min(Q.to, V); ; ) {
          let H = t.state.doc.lineAt(N);
          for (let te of t.bidiSpans(H)) {
            let le = te.from + H.from,
              $ = te.to + H.from;
            if (le >= G) break;
            $ > N && M(Math.max(le, N), S == null && le <= D, Math.min($, G), k == null && $ >= V, te.dir);
          }
          if (((N = H.to + 1), N >= G)) break;
        }
    return P.length == 0 && M(D, S == null, V, k == null, t.textDirection), { top: _, bottom: T, horizontal: P };
  }
  function y(S, k) {
    let b = a.top + (k ? S.top : S.bottom);
    return { top: b, bottom: b, horizontal: [] };
  }
}
function _se(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class Ese {
  constructor(e, n) {
    (this.view = e),
      (this.layer = n),
      (this.drawn = []),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }),
      (this.dom = e.scrollDOM.appendChild(document.createElement("div"))),
      this.dom.classList.add("cm-layer"),
      n.above && this.dom.classList.add("cm-layer-above"),
      n.class && this.dom.classList.add(n.class),
      this.scale(),
      this.dom.setAttribute("aria-hidden", "true"),
      this.setOrder(e.state),
      e.requestMeasure(this.measureReq),
      n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Id) != e.state.facet(Id) && this.setOrder(e.state),
      (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0,
      r = e.facet(Id);
    for (; n < r.length && r[n] != this.layer; ) n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) &&
      ((this.scaleX = e), (this.scaleY = n), (this.dom.style.transform = `scale(${1 / e}, ${1 / n})`));
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, r) => !_se(n, this.drawn[r]))) {
      let n = this.dom.firstChild,
        r = 0;
      for (let i of e)
        i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r])
          ? ((n = n.nextSibling), r++)
          : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), (n = i);
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Id = ye.define();
function L4(t) {
  return [Dt.define((e) => new Ese(e, t)), Id.of(t)];
}
const M4 = !be.ios,
  Wu = ye.define({
    combine(t) {
      return Vi(
        t,
        { cursorBlinkRate: 1200, drawRangeCursor: !0 },
        { cursorBlinkRate: (e, n) => Math.min(e, n), drawRangeCursor: (e, n) => e || n }
      );
    },
  });
function Tse(t = {}) {
  return [Wu.of(t), Pse, Ase, $se, a4.of(!0)];
}
function D4(t) {
  return t.startState.facet(Wu) != t.state.facet(Wu);
}
const Pse = L4({
  above: !0,
  markers(t) {
    let { state: e } = t,
      n = e.facet(Wu),
      r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty ? !s || M4 : n.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary",
          a = i.empty ? i : X.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of rf.forRange(t, o, a)) r.push(l);
      }
    }
    return r;
  },
  update(t, e) {
    t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = D4(t);
    return n && w5(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    w5(e.state, t);
  },
  class: "cm-cursorLayer",
});
function w5(t, e) {
  e.style.animationDuration = t.facet(Wu).cursorBlinkRate + "ms";
}
const Ase = L4({
    above: !1,
    markers(t) {
      return t.state.selection.ranges
        .map((e) => (e.empty ? [] : rf.forRange(t, "cm-selectionBackground", e)))
        .reduce((e, n) => e.concat(n));
    },
    update(t, e) {
      return t.docChanged || t.selectionSet || t.viewportChanged || D4(t);
    },
    class: "cm-selectionLayer",
  }),
  Zv = {
    ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } },
    ".cm-content": {
      "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } },
    },
  };
M4 && (Zv[".cm-line"].caretColor = Zv[".cm-content"].caretColor = "transparent !important");
const $se = ai.highest(re.theme(Zv)),
  Q4 = Ae.define({
    map(t, e) {
      return t == null ? null : e.mapPos(t);
    },
  }),
  Wc = zt.define({
    create() {
      return null;
    },
    update(t, e) {
      return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => (r.is(Q4) ? r.value : n), t);
    },
  }),
  Rse = Dt.fromClass(
    class {
      constructor(t) {
        (this.view = t), (this.cursor = null), (this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) });
      }
      update(t) {
        var e;
        let n = t.state.field(Wc);
        n == null
          ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), (this.cursor = null))
          : (this.cursor ||
              ((this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"))), (this.cursor.className = "cm-dropCursor")),
            (t.startState.field(Wc) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
      }
      readPos() {
        let { view: t } = this,
          e = t.state.field(Wc),
          n = e != null && t.coordsAtPos(e);
        if (!n) return null;
        let r = t.scrollDOM.getBoundingClientRect();
        return {
          left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
          top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
          height: n.bottom - n.top,
        };
      }
      drawCursor(t) {
        if (this.cursor) {
          let { scaleX: e, scaleY: n } = this.view;
          t
            ? ((this.cursor.style.left = t.left / e + "px"),
              (this.cursor.style.top = t.top / n + "px"),
              (this.cursor.style.height = t.height / n + "px"))
            : (this.cursor.style.left = "-100000px");
        }
      }
      destroy() {
        this.cursor && this.cursor.remove();
      }
      setDropPos(t) {
        this.view.state.field(Wc) != t && this.view.dispatch({ effects: Q4.of(t) });
      }
    },
    {
      eventObservers: {
        dragover(t) {
          this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
        },
        dragleave(t) {
          (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
        },
        dragend() {
          this.setDropPos(null);
        },
        drop() {
          this.setDropPos(null);
        },
      },
    }
  );
function Ise() {
  return [Wc, Rse];
}
function S5(t, e, n, r, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(n, r), o = n, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak) for (; (a = e.exec(s.value)); ) i(o + a.index, a);
}
function Nse(t, e) {
  let n = t.visibleRanges;
  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to) return n;
  let r = [];
  for (let { from: i, to: s } of n)
    (i = Math.max(t.state.doc.lineAt(i).from, i - e)),
      (s = Math.min(t.state.doc.lineAt(s).to, s + e)),
      r.length && r[r.length - 1].to >= i ? (r[r.length - 1].to = s) : r.push({ from: i, to: s });
  return r;
}
class Lse {
  constructor(e) {
    const { regexp: n, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!n.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (((this.regexp = n), i)) this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
    else if (typeof r == "function")
      this.addMatch = (a, l, c, u) => {
        let h = r(a, l, c);
        h && u(c, c + a[0].length, h);
      };
    else if (r) this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r);
    else throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    (this.boundary = s), (this.maxLength = o);
  }
  createDeco(e) {
    let n = new Or(),
      r = n.add.bind(n);
    for (let { from: i, to: s } of Nse(e, this.maxLength)) S5(e.state.doc, this.regexp, i, s, (o, a) => this.addMatch(a, e, o, r));
    return n.finish();
  }
  updateDeco(e, n) {
    let r = 1e9,
      i = -1;
    return (
      e.docChanged &&
        e.changes.iterChanges((s, o, a, l) => {
          l > e.view.viewport.from && a < e.view.viewport.to && ((r = Math.min(a, r)), (i = Math.max(l, i)));
        }),
      e.viewportChanged || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n
    );
  }
  updateRange(e, n, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r),
        a = Math.min(s.to, i);
      if (a > o) {
        let l = e.state.doc.lineAt(o),
          c = l.to < a ? e.state.doc.lineAt(a) : l,
          u = Math.max(s.from, l.from),
          h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              h = a;
              break;
            }
        }
        let f = [],
          d,
          p = (m, O, v) => f.push(v.range(m, O));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (d = this.regexp.exec(l.text)) && d.index < h - l.from; )
            this.addMatch(d, e, d.index + l.from, p);
        else S5(e.state.doc, this.regexp, u, h, (m, O) => this.addMatch(O, e, m, p));
        n = n.update({ filterFrom: u, filterTo: h, filter: (m, O) => m < u || O > h, add: f });
      }
    }
    return n;
  }
}
const zv = /x/.unicode != null ? "gu" : "g",
  Mse = new RegExp(
    `[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`,
    zv
  ),
  Dse = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement",
  };
let U0 = null;
function Qse() {
  var t;
  if (U0 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    U0 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return U0 || !1;
}
const Nd = ye.define({
  combine(t) {
    let e = Vi(t, { render: null, specialChars: Mse, addSpecialChars: null });
    return (
      (e.replaceTabs = !Qse()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, zv)),
      e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, zv)),
      e
    );
  },
});
function F4(t = {}) {
  return [Nd.of(t), Fse()];
}
let k5 = null;
function Fse() {
  return (
    k5 ||
    (k5 = Dt.fromClass(
      class {
        constructor(t) {
          (this.view = t),
            (this.decorations = ge.none),
            (this.decorationCache = Object.create(null)),
            (this.decorator = this.makeDecorator(t.state.facet(Nd))),
            (this.decorations = this.decorator.createDeco(t));
        }
        makeDecorator(t) {
          return new Lse({
            regexp: t.specialChars,
            decoration: (e, n, r) => {
              let { doc: i } = n.state,
                s = mn(e[0], 0);
              if (s == 9) {
                let o = i.lineAt(r),
                  a = n.state.tabSize,
                  l = Kr(o.text, a, r - o.from);
                return ge.replace({ widget: new Zse(((a - (l % a)) * this.view.defaultCharacterWidth) / this.view.scaleX) });
              }
              return this.decorationCache[s] || (this.decorationCache[s] = ge.replace({ widget: new jse(t, s) }));
            },
            boundary: t.replaceTabs ? void 0 : /[^]/,
          });
        }
        update(t) {
          let e = t.state.facet(Nd);
          t.startState.facet(Nd) != e
            ? ((this.decorator = this.makeDecorator(e)), (this.decorations = this.decorator.createDeco(t.view)))
            : (this.decorations = this.decorator.updateDeco(t, this.decorations));
        }
      },
      { decorations: (t) => t.decorations }
    ))
  );
}
const Vse = "•";
function Bse(t) {
  return t >= 32 ? Vse : t == 10 ? "␤" : String.fromCharCode(9216 + t);
}
class jse extends li {
  constructor(e, n) {
    super(), (this.options = e), (this.code = n);
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = Bse(this.code),
      r = e.state.phrase("Control character") + " " + (Dse[this.code] || "0x" + this.code.toString(16)),
      i = this.options.render && this.options.render(this.code, r, n);
    if (i) return i;
    let s = document.createElement("span");
    return (s.textContent = n), (s.title = r), s.setAttribute("aria-label", r), (s.className = "cm-specialChar"), s;
  }
  ignoreEvent() {
    return !1;
  }
}
class Zse extends li {
  constructor(e) {
    super(), (this.width = e);
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return (e.textContent = "	"), (e.className = "cm-tab"), (e.style.width = this.width + "px"), e;
  }
  ignoreEvent() {
    return !1;
  }
}
function V4() {
  return Wse;
}
const zse = ge.line({ class: "cm-activeLine" }),
  Wse = Dt.fromClass(
    class {
      constructor(t) {
        this.decorations = this.getDeco(t);
      }
      update(t) {
        (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
      }
      getDeco(t) {
        let e = -1,
          n = [];
        for (let r of t.state.selection.ranges) {
          let i = t.lineBlockAt(r.head);
          i.from > e && (n.push(zse.range(i.from)), (e = i.from));
        }
        return ge.set(n);
      }
    },
    { decorations: (t) => t.decorations }
  ),
  Wv = 2e3;
function Use(t, e, n) {
  let r = Math.min(e.line, n.line),
    i = Math.max(e.line, n.line),
    s = [];
  if (e.off > Wv || n.off > Wv || e.col < 0 || n.col < 0) {
    let o = Math.min(e.off, n.off),
      a = Math.max(e.off, n.off);
    for (let l = r; l <= i; l++) {
      let c = t.doc.line(l);
      c.length <= a && s.push(X.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, n.col),
      a = Math.max(e.col, n.col);
    for (let l = r; l <= i; l++) {
      let c = t.doc.line(l),
        u = wv(c.text, o, t.tabSize, !0);
      if (u < 0) s.push(X.cursor(c.to));
      else {
        let h = wv(c.text, a, t.tabSize);
        s.push(X.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function Xse(t, e) {
  let n = t.coordsAtPos(t.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
}
function C5(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    r = t.state.doc.lineAt(n),
    i = n - r.from,
    s = i > Wv ? -1 : i == r.length ? Xse(t, e.clientX) : Kr(r.text, t.state.tabSize, n - r.from);
  return { line: r.number, col: s, off: i };
}
function Hse(t, e) {
  let n = C5(t, e),
    r = t.state.selection;
  return n
    ? {
        update(i) {
          if (i.docChanged) {
            let s = i.changes.mapPos(i.startState.doc.line(n.line).from),
              o = i.state.doc.lineAt(s);
            (n = { line: o.number, col: n.col, off: Math.min(n.off, o.length) }), (r = r.map(i.changes));
          }
        },
        get(i, s, o) {
          let a = C5(t, i);
          if (!a) return r;
          let l = Use(t.state, n, a);
          return l.length ? (o ? X.create(l.concat(r.ranges)) : X.create(l)) : r;
        },
      }
    : null;
}
function qse(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((n) => n.altKey && n.button == 0);
  return re.mouseSelectionStyle.of((n, r) => (e(r) ? Hse(n, r) : null));
}
const Yse = {
    Alt: [18, (t) => !!t.altKey],
    Control: [17, (t) => !!t.ctrlKey],
    Shift: [16, (t) => !!t.shiftKey],
    Meta: [91, (t) => !!t.metaKey],
  },
  Gse = { style: "cursor: crosshair" };
function Jse(t = {}) {
  let [e, n] = Yse[t.key || "Alt"],
    r = Dt.fromClass(
      class {
        constructor(i) {
          (this.view = i), (this.isDown = !1);
        }
        set(i) {
          this.isDown != i && ((this.isDown = i), this.view.update([]));
        }
      },
      {
        eventObservers: {
          keydown(i) {
            this.set(i.keyCode == e || n(i));
          },
          keyup(i) {
            (i.keyCode == e || !n(i)) && this.set(!1);
          },
          mousemove(i) {
            this.set(n(i));
          },
        },
      }
    );
  return [
    r,
    re.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? Gse : null;
    }),
  ];
}
const _c = "-10000px";
class B4 {
  constructor(e, n, r, i) {
    (this.facet = n),
      (this.createTooltipView = r),
      (this.removeTooltipView = i),
      (this.input = e.state.facet(n)),
      (this.tooltips = this.input.filter((o) => o));
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => (s = r(o, s)));
  }
  update(e, n) {
    var r;
    let i = e.state.facet(this.facet),
      s = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews) l.update && l.update(e);
      return !1;
    }
    let o = [],
      a = n ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let c = s[l],
        u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == c.create && (u = h);
        }
        if (u < 0) (o[l] = this.createTooltipView(c, l ? o[l - 1] : null)), a && (a[l] = !!c.above);
        else {
          let h = (o[l] = this.tooltipViews[u]);
          a && (a[l] = n[u]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews) o.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return (
      n && (a.forEach((l, c) => (n[c] = l)), (n.length = a.length)), (this.input = i), (this.tooltips = s), (this.tooltipViews = o), !0
    );
  }
}
function Kse(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const X0 = ye.define({
    combine: (t) => {
      var e, n, r;
      return {
        position: be.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
        parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
        tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || Kse,
      };
    },
  }),
  _5 = new WeakMap(),
  Iw = Dt.fromClass(
    class {
      constructor(t) {
        (this.view = t),
          (this.above = []),
          (this.inView = !0),
          (this.madeAbsolute = !1),
          (this.lastTransaction = 0),
          (this.measureTimeout = -1);
        let e = t.state.facet(X0);
        (this.position = e.position),
          (this.parent = e.parent),
          (this.classes = t.themeClasses),
          this.createContainer(),
          (this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }),
          (this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null),
          (this.manager = new B4(
            t,
            Nw,
            (n, r) => this.createTooltip(n, r),
            (n) => {
              this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
            }
          )),
          (this.above = this.manager.tooltips.map((n) => !!n.above)),
          (this.intersectionObserver =
            typeof IntersectionObserver == "function"
              ? new IntersectionObserver(
                  (n) => {
                    Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
                  },
                  { threshold: [1] }
                )
              : null),
          this.observeIntersection(),
          t.win.addEventListener("resize", (this.measureSoon = this.measureSoon.bind(this))),
          this.maybeMeasure();
      }
      createContainer() {
        this.parent
          ? ((this.container = document.createElement("div")),
            (this.container.style.position = "relative"),
            (this.container.className = this.view.themeClasses),
            this.parent.appendChild(this.container))
          : (this.container = this.view.dom);
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          for (let t of this.manager.tooltipViews) this.intersectionObserver.observe(t.dom);
        }
      }
      measureSoon() {
        this.measureTimeout < 0 &&
          (this.measureTimeout = setTimeout(() => {
            (this.measureTimeout = -1), this.maybeMeasure();
          }, 50));
      }
      update(t) {
        t.transactions.length && (this.lastTransaction = Date.now());
        let e = this.manager.update(t, this.above);
        e && this.observeIntersection();
        let n = e || t.geometryChanged,
          r = t.state.facet(X0);
        if (r.position != this.position && !this.madeAbsolute) {
          this.position = r.position;
          for (let i of this.manager.tooltipViews) i.dom.style.position = this.position;
          n = !0;
        }
        if (r.parent != this.parent) {
          this.parent && this.container.remove(), (this.parent = r.parent), this.createContainer();
          for (let i of this.manager.tooltipViews) this.container.appendChild(i.dom);
          n = !0;
        } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
        n && this.maybeMeasure();
      }
      createTooltip(t, e) {
        let n = t.create(this.view),
          r = e ? e.dom : null;
        if ((n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow"))) {
          let i = document.createElement("div");
          (i.className = "cm-tooltip-arrow"), n.dom.appendChild(i);
        }
        return (
          (n.dom.style.position = this.position),
          (n.dom.style.top = _c),
          (n.dom.style.left = "0px"),
          this.container.insertBefore(n.dom, r),
          n.mount && n.mount(this.view),
          this.resizeObserver && this.resizeObserver.observe(n.dom),
          n
        );
      }
      destroy() {
        var t, e, n;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let r of this.manager.tooltipViews) r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
        this.parent && this.container.remove(),
          (e = this.resizeObserver) === null || e === void 0 || e.disconnect(),
          (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(),
          clearTimeout(this.measureTimeout);
      }
      readMeasure() {
        let t = this.view.dom.getBoundingClientRect(),
          e = 1,
          n = 1,
          r = !1;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
          let { dom: i } = this.manager.tooltipViews[0];
          if (be.gecko) r = i.offsetParent != this.container.ownerDocument.body;
          else if (i.style.top == _c && i.style.left == "0px") {
            let s = i.getBoundingClientRect();
            r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
          }
        }
        if (r || this.position == "absolute")
          if (this.parent) {
            let i = this.parent.getBoundingClientRect();
            i.width && i.height && ((e = i.width / this.parent.offsetWidth), (n = i.height / this.parent.offsetHeight));
          } else ({ scaleX: e, scaleY: n } = this.view.viewState);
        return {
          editor: t,
          parent: this.parent ? this.container.getBoundingClientRect() : t,
          pos: this.manager.tooltips.map((i, s) => {
            let o = this.manager.tooltipViews[s];
            return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
          }),
          size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
          space: this.view.state.facet(X0).tooltipSpace(this.view),
          scaleX: e,
          scaleY: n,
          makeAbsolute: r,
        };
      }
      writeMeasure(t) {
        var e;
        if (t.makeAbsolute) {
          (this.madeAbsolute = !0), (this.position = "absolute");
          for (let a of this.manager.tooltipViews) a.dom.style.position = "absolute";
        }
        let { editor: n, space: r, scaleX: i, scaleY: s } = t,
          o = [];
        for (let a = 0; a < this.manager.tooltips.length; a++) {
          let l = this.manager.tooltips[a],
            c = this.manager.tooltipViews[a],
            { dom: u } = c,
            h = t.pos[a],
            f = t.size[a];
          if (
            !h ||
            h.bottom <= Math.max(n.top, r.top) ||
            h.top >= Math.min(n.bottom, r.bottom) ||
            h.right < Math.max(n.left, r.left) - 0.1 ||
            h.left > Math.min(n.right, r.right) + 0.1
          ) {
            u.style.top = _c;
            continue;
          }
          let d = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null,
            p = d ? 7 : 0,
            m = f.right - f.left,
            O = (e = _5.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top,
            v = c.offset || toe,
            g = this.view.textDirection == Pt.LTR,
            x =
              f.width > r.right - r.left
                ? g
                  ? r.left
                  : r.right - f.width
                : g
                ? Math.min(h.left - (d ? 14 : 0) + v.x, r.right - m)
                : Math.max(r.left, h.left - m + (d ? 14 : 0) - v.x),
            y = this.above[a];
          !l.strictSide &&
            (y ? h.top - (f.bottom - f.top) - v.y < r.top : h.bottom + (f.bottom - f.top) + v.y > r.bottom) &&
            y == r.bottom - h.bottom > h.top - r.top &&
            (y = this.above[a] = !y);
          let S = (y ? h.top - r.top : r.bottom - h.bottom) - p;
          if (S < O && c.resize !== !1) {
            if (S < this.view.defaultLineHeight) {
              u.style.top = _c;
              continue;
            }
            _5.set(c, O), (u.style.height = (O = S) / s + "px");
          } else u.style.height && (u.style.height = "");
          let k = y ? h.top - O - p - v.y : h.bottom + p + v.y,
            b = x + m;
          if (c.overlap !== !0)
            for (let _ of o) _.left < b && _.right > x && _.top < k + O && _.bottom > k && (k = y ? _.top - O - 2 - p : _.bottom + p + 2);
          if (
            (this.position == "absolute"
              ? ((u.style.top = (k - t.parent.top) / s + "px"), (u.style.left = (x - t.parent.left) / i + "px"))
              : ((u.style.top = k / s + "px"), (u.style.left = x / i + "px")),
            d)
          ) {
            let _ = h.left + (g ? v.x : -v.x) - (x + 14 - 7);
            d.style.left = _ / i + "px";
          }
          c.overlap !== !0 && o.push({ left: x, top: k, right: b, bottom: k + O }),
            u.classList.toggle("cm-tooltip-above", y),
            u.classList.toggle("cm-tooltip-below", !y),
            c.positioned && c.positioned(t.space);
        }
      }
      maybeMeasure() {
        if (
          this.manager.tooltips.length &&
          (this.view.inView && this.view.requestMeasure(this.measureReq),
          this.inView != this.view.inView && ((this.inView = this.view.inView), !this.inView))
        )
          for (let t of this.manager.tooltipViews) t.dom.style.top = _c;
      }
    },
    {
      eventObservers: {
        scroll() {
          this.maybeMeasure();
        },
      },
    }
  ),
  eoe = re.baseTheme({
    ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" },
    "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" },
    "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" },
    "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" },
    ".cm-tooltip-arrow": {
      height: "7px",
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: "7px solid transparent",
        borderRight: "7px solid transparent",
      },
      ".cm-tooltip-above &": {
        bottom: "-7px",
        "&:before": { borderTop: "7px solid #bbb" },
        "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" },
      },
      ".cm-tooltip-below &": {
        top: "-7px",
        "&:before": { borderBottom: "7px solid #bbb" },
        "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" },
      },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" },
      "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" },
    },
  }),
  toe = { x: 0, y: 0 },
  Nw = ye.define({ enables: [Iw, eoe] }),
  Vp = ye.define({ combine: (t) => t.reduce((e, n) => e.concat(n), []) });
class Sg {
  static create(e) {
    return new Sg(e);
  }
  constructor(e) {
    (this.view = e),
      (this.mounted = !1),
      (this.dom = document.createElement("div")),
      this.dom.classList.add("cm-tooltip-hover"),
      (this.manager = new B4(
        e,
        Vp,
        (n, r) => this.createHostedView(n, r),
        (n) => n.dom.remove()
      ));
  }
  createHostedView(e, n) {
    let r = e.create(this.view);
    return (
      r.dom.classList.add("cm-tooltip-section"),
      this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild),
      this.mounted && r.mount && r.mount(this.view),
      r
    );
  }
  mount(e) {
    for (let n of this.manager.tooltipViews) n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews) n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews) (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (n === void 0) n = i;
        else if (n !== i) return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const noe = Nw.compute([Vp], (t) => {
  let e = t.facet(Vp);
  return e.length === 0
    ? null
    : {
        pos: Math.min(...e.map((n) => n.pos)),
        end: Math.max(
          ...e.map((n) => {
            var r;
            return (r = n.end) !== null && r !== void 0 ? r : n.pos;
          })
        ),
        create: Sg.create,
        above: e[0].above,
        arrow: e.some((n) => n.arrow),
      };
});
class roe {
  constructor(e, n, r, i, s) {
    (this.view = e),
      (this.source = n),
      (this.field = r),
      (this.setHover = i),
      (this.hoverTime = s),
      (this.hoverTimeout = -1),
      (this.restartTimeout = -1),
      (this.pending = null),
      (this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }),
      (this.checkHover = this.checkHover.bind(this)),
      e.dom.addEventListener("mouseleave", (this.mouseleave = this.mouseleave.bind(this))),
      e.dom.addEventListener("mousemove", (this.mousemove = this.mousemove.bind(this)));
  }
  update() {
    this.pending &&
      ((this.pending = null), clearTimeout(this.restartTimeout), (this.restartTimeout = setTimeout(() => this.startHover(), 20)));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (((this.hoverTimeout = -1), this.active.length)) return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e)) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this,
      r = e.docView.nearest(n.target);
    if (!r) return;
    let i,
      s = 1;
    if (r instanceof Vs) i = r.posAtStart;
    else {
      if (((i = e.posAtCoords(n)), i == null)) return;
      let a = e.coordsAtPos(i);
      if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth) return;
      let l = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i),
        c = l && l.dir == Pt.RTL ? -1 : 1;
      s = n.x < a.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o != null && o.then) {
      let a = (this.pending = { pos: i });
      o.then(
        (l) => {
          this.pending == a &&
            ((this.pending = null),
            l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
        },
        (l) => Kn(e.state, l, "hover tooltip")
      );
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(Iw),
      n = e ? e.manager.tooltips.findIndex((r) => r.create == Sg.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, r;
    (this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }),
      this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if ((i.length && s && !ioe(s.dom, e)) || this.pending) {
      let { pos: o } = i[0] || this.pending,
        a = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !soe(this.view, o, a, e.clientX, e.clientY)) &&
        (this.view.dispatch({ effects: this.setHover.of([]) }), (this.pending = null));
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), (this.hoverTimeout = -1);
    let { active: n } = this;
    if (n.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (r) => {
      e.removeEventListener("mouseleave", n),
        this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout),
      this.view.dom.removeEventListener("mouseleave", this.mouseleave),
      this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const zf = 4;
function ioe(t, e) {
  let n = t.getBoundingClientRect();
  return e.clientX >= n.left - zf && e.clientX <= n.right + zf && e.clientY >= n.top - zf && e.clientY <= n.bottom + zf;
}
function soe(t, e, n, r, i, s) {
  let o = t.scrollDOM.getBoundingClientRect(),
    a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, a) < i) return !1;
  let l = t.posAtCoords({ x: r, y: i }, !1);
  return l >= e && l <= n;
}
function ooe(t, e = {}) {
  let n = Ae.define(),
    r = zt.define({
      create() {
        return [];
      },
      update(i, s) {
        if (
          i.length &&
          (e.hideOnChange && (s.docChanged || s.selection) ? (i = []) : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged)
        ) {
          let o = [];
          for (let a of i) {
            let l = s.changes.mapPos(a.pos, -1, On.TrackDel);
            if (l != null) {
              let c = Object.assign(Object.create(null), a);
              (c.pos = l), c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
            }
          }
          i = o;
        }
        for (let o of s.effects) o.is(n) && (i = o.value), o.is(aoe) && (i = []);
        return i;
      },
      provide: (i) => Vp.from(i),
    });
  return [r, Dt.define((i) => new roe(i, t, r, n, e.hoverTime || 300)), noe];
}
function j4(t, e) {
  let n = t.plugin(Iw);
  if (!n) return null;
  let r = n.manager.tooltips.indexOf(e);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const aoe = Ae.define(),
  E5 = ye.define({
    combine(t) {
      let e, n;
      for (let r of t) (e = e || r.topContainer), (n = n || r.bottomContainer);
      return { topContainer: e, bottomContainer: n };
    },
  });
function Uu(t, e) {
  let n = t.plugin(Z4),
    r = n ? n.specs.indexOf(e) : -1;
  return r > -1 ? n.panels[r] : null;
}
const Z4 = Dt.fromClass(
  class {
    constructor(t) {
      (this.input = t.state.facet(Xu)), (this.specs = this.input.filter((n) => n)), (this.panels = this.specs.map((n) => n(t)));
      let e = t.state.facet(E5);
      (this.top = new Wf(t, !0, e.topContainer)),
        (this.bottom = new Wf(t, !1, e.bottomContainer)),
        this.top.sync(this.panels.filter((n) => n.top)),
        this.bottom.sync(this.panels.filter((n) => !n.top));
      for (let n of this.panels) n.dom.classList.add("cm-panel"), n.mount && n.mount();
    }
    update(t) {
      let e = t.state.facet(E5);
      this.top.container != e.topContainer && (this.top.sync([]), (this.top = new Wf(t.view, !0, e.topContainer))),
        this.bottom.container != e.bottomContainer && (this.bottom.sync([]), (this.bottom = new Wf(t.view, !1, e.bottomContainer))),
        this.top.syncClasses(),
        this.bottom.syncClasses();
      let n = t.state.facet(Xu);
      if (n != this.input) {
        let r = n.filter((l) => l),
          i = [],
          s = [],
          o = [],
          a = [];
        for (let l of r) {
          let c = this.specs.indexOf(l),
            u;
          c < 0 ? ((u = l(t.view)), a.push(u)) : ((u = this.panels[c]), u.update && u.update(t)), i.push(u), (u.top ? s : o).push(u);
        }
        (this.specs = r), (this.panels = i), this.top.sync(s), this.bottom.sync(o);
        for (let l of a) l.dom.classList.add("cm-panel"), l.mount && l.mount();
      } else for (let r of this.panels) r.update && r.update(t);
    }
    destroy() {
      this.top.sync([]), this.bottom.sync([]);
    }
  },
  {
    provide: (t) =>
      re.scrollMargins.of((e) => {
        let n = e.plugin(t);
        return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
      }),
  }
);
class Wf {
  constructor(e, n, r) {
    (this.view = e), (this.top = n), (this.container = r), (this.dom = void 0), (this.classes = ""), (this.panels = []), this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels) n.destroy && e.indexOf(n) < 0 && n.destroy();
    (this.panels = e), this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), (this.dom = void 0));
      return;
    }
    if (!this.dom) {
      (this.dom = document.createElement("div")),
        (this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom"),
        (this.dom.style[this.top ? "top" : "bottom"] = "0");
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; ) e = T5(e);
        e = e.nextSibling;
      } else this.dom.insertBefore(n.dom, e);
    for (; e; ) e = T5(e);
  }
  scrollMargin() {
    return !this.dom || this.container
      ? 0
      : Math.max(
          0,
          this.top
            ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
            : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top
        );
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" ")) e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" ")) e && this.container.classList.add(e);
    }
  }
}
function T5(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const Xu = ye.define({ enables: Z4 });
class Li extends Go {
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  eq(e) {
    return !1;
  }
  destroy(e) {}
}
Li.prototype.elementClass = "";
Li.prototype.toDOM = void 0;
Li.prototype.mapMode = On.TrackBefore;
Li.prototype.startSide = Li.prototype.endSide = -1;
Li.prototype.point = !0;
const Ld = ye.define(),
  loe = {
    class: "",
    renderEmptyElements: !1,
    elementStyle: "",
    markers: () => Xe.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {},
  },
  du = ye.define();
function z4(t) {
  return [W4(), du.of(Object.assign(Object.assign({}, loe), t))];
}
const Uv = ye.define({ combine: (t) => t.some((e) => e) });
function W4(t) {
  let e = [coe];
  return t && t.fixed === !1 && e.push(Uv.of(!0)), e;
}
const coe = Dt.fromClass(
  class {
    constructor(t) {
      (this.view = t),
        (this.prevViewport = t.viewport),
        (this.dom = document.createElement("div")),
        (this.dom.className = "cm-gutters"),
        this.dom.setAttribute("aria-hidden", "true"),
        (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
        (this.gutters = t.state.facet(du).map((e) => new A5(t, e)));
      for (let e of this.gutters) this.dom.appendChild(e.dom);
      (this.fixed = !t.state.facet(Uv)),
        this.fixed && (this.dom.style.position = "sticky"),
        this.syncGutters(!1),
        t.scrollDOM.insertBefore(this.dom, t.contentDOM);
    }
    update(t) {
      if (this.updateGutters(t)) {
        let e = this.prevViewport,
          n = t.view.viewport,
          r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
        this.syncGutters(r < (n.to - n.from) * 0.8);
      }
      t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
        this.view.state.facet(Uv) != !this.fixed && ((this.fixed = !this.fixed), (this.dom.style.position = this.fixed ? "sticky" : "")),
        (this.prevViewport = t.view.viewport);
    }
    syncGutters(t) {
      let e = this.dom.nextSibling;
      t && this.dom.remove();
      let n = Xe.iter(this.view.state.facet(Ld), this.view.viewport.from),
        r = [],
        i = this.gutters.map((s) => new uoe(s, this.view.viewport, -this.view.documentPadding.top));
      for (let s of this.view.viewportLineBlocks)
        if ((r.length && (r = []), Array.isArray(s.type))) {
          let o = !0;
          for (let a of s.type)
            if (a.type == Fn.Text && o) {
              Xv(n, r, a.from);
              for (let l of i) l.line(this.view, a, r);
              o = !1;
            } else if (a.widget) for (let l of i) l.widget(this.view, a);
        } else if (s.type == Fn.Text) {
          Xv(n, r, s.from);
          for (let o of i) o.line(this.view, s, r);
        } else if (s.widget) for (let o of i) o.widget(this.view, s);
      for (let s of i) s.finish();
      t && this.view.scrollDOM.insertBefore(this.dom, e);
    }
    updateGutters(t) {
      let e = t.startState.facet(du),
        n = t.state.facet(du),
        r =
          t.docChanged ||
          t.heightChanged ||
          t.viewportChanged ||
          !Xe.eq(t.startState.facet(Ld), t.state.facet(Ld), t.view.viewport.from, t.view.viewport.to);
      if (e == n) for (let i of this.gutters) i.update(t) && (r = !0);
      else {
        r = !0;
        let i = [];
        for (let s of n) {
          let o = e.indexOf(s);
          o < 0 ? i.push(new A5(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));
        }
        for (let s of this.gutters) s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
        for (let s of i) this.dom.appendChild(s.dom);
        this.gutters = i;
      }
      return r;
    }
    destroy() {
      for (let t of this.gutters) t.destroy();
      this.dom.remove();
    }
  },
  {
    provide: (t) =>
      re.scrollMargins.of((e) => {
        let n = e.plugin(t);
        return !n || n.gutters.length == 0 || !n.fixed
          ? null
          : e.textDirection == Pt.LTR
          ? { left: n.dom.offsetWidth * e.scaleX }
          : { right: n.dom.offsetWidth * e.scaleX };
      }),
  }
);
function P5(t) {
  return Array.isArray(t) ? t : [t];
}
function Xv(t, e, n) {
  for (; t.value && t.from <= n; ) t.from == n && e.push(t.value), t.next();
}
class uoe {
  constructor(e, n, r) {
    (this.gutter = e), (this.height = r), (this.i = 0), (this.cursor = Xe.iter(e.markers, n.from));
  }
  addElement(e, n, r) {
    let { gutter: i } = this,
      s = (n.top - this.height) / e.scaleY,
      o = n.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new U4(e, o, s, r);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else i.elements[this.i].update(e, o, s, r);
    (this.height = n.bottom), this.i++;
  }
  line(e, n, r) {
    let i = [];
    Xv(this.cursor, i, n.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, n, i);
    s && i.unshift(s);
    let o = this.gutter;
    (i.length == 0 && !o.config.renderEmptyElements) || this.addElement(e, n, i);
  }
  widget(e, n) {
    let r = this.gutter.config.widgetMarker(e, n.widget, n);
    r && this.addElement(e, n, [r]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class A5 {
  constructor(e, n) {
    (this.view = e),
      (this.config = n),
      (this.elements = []),
      (this.spacer = null),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""));
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target,
          o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; ) s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else o = i.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        n.domEventHandlers[r](e, a, i) && i.preventDefault();
      });
    (this.markers = P5(n.markers(e))),
      n.initialSpacer &&
        ((this.spacer = new U4(e, 0, 0, [n.initialSpacer(e)])),
        this.dom.appendChild(this.spacer.dom),
        (this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none"));
  }
  update(e) {
    let n = this.markers;
    if (((this.markers = P5(this.config.markers(e.view))), this.spacer && this.config.updateSpacer)) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !Xe.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements) e.destroy();
  }
}
class U4 {
  constructor(e, n, r, i) {
    (this.height = -1),
      (this.above = 0),
      (this.markers = []),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-gutterElement"),
      this.update(e, n, r, i);
  }
  update(e, n, r, i) {
    this.height != n && ((this.height = n), (this.dom.style.height = n + "px")),
      this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""),
      hoe(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, n) {
    let r = "cm-gutterElement",
      i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o,
        l = s < n.length ? n[s++] : null,
        c = !1;
      if (l) {
        let u = l.elementClass;
        u && (r += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            (a = h), (c = !0);
            break;
          }
      } else a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), (i = h);
        }
      }
      if (!l) break;
      l.toDOM && (c ? (i = i.nextSibling) : this.dom.insertBefore(l.toDOM(e), i)), c && o++;
    }
    (this.dom.className = r), (this.markers = n);
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function hoe(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) if (!t[n].compare(e[n])) return !1;
  return !0;
}
const foe = ye.define(),
  za = ye.define({
    combine(t) {
      return Vi(
        t,
        { formatNumber: String, domEventHandlers: {} },
        {
          domEventHandlers(e, n) {
            let r = Object.assign({}, e);
            for (let i in n) {
              let s = r[i],
                o = n[i];
              r[i] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;
            }
            return r;
          },
        }
      );
    },
  });
class H0 extends Li {
  constructor(e) {
    super(), (this.number = e);
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function q0(t, e) {
  return t.state.facet(za).formatNumber(e, t.state);
}
const doe = du.compute([za], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(foe);
  },
  lineMarker(e, n, r) {
    return r.some((i) => i.toDOM) ? null : new H0(q0(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(za) != e.state.facet(za),
  initialSpacer(e) {
    return new H0(q0(e, $5(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let r = q0(n.view, $5(n.view.state.doc.lines));
    return r == e.number ? e : new H0(r);
  },
  domEventHandlers: t.facet(za).domEventHandlers,
}));
function kg(t = {}) {
  return [za.of(t), W4(), doe];
}
function $5(t) {
  let e = 9;
  for (; e < t; ) e = e * 10 + 9;
  return e;
}
const poe = new (class extends Li {
    constructor() {
      super(...arguments), (this.elementClass = "cm-activeLineGutter");
    }
  })(),
  moe = Ld.compute(["selection"], (t) => {
    let e = [],
      n = -1;
    for (let r of t.selection.ranges) {
      let i = t.doc.lineAt(r.head).from;
      i > n && ((n = i), e.push(poe.range(i)));
    }
    return Xe.of(e);
  });
function goe() {
  return moe;
}
const X4 = 1024;
let Ooe = 0,
  Ar = class {
    constructor(e, n) {
      (this.from = e), (this.to = n);
    }
  };
class Ie {
  constructor(e = {}) {
    (this.id = Ooe++),
      (this.perNode = !!e.perNode),
      (this.deserialize =
        e.deserialize ||
        (() => {
          throw new Error("This node type doesn't define a deserialize function");
        }));
  }
  add(e) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types");
    return (
      typeof e != "function" && (e = Kt.match(e)),
      (n) => {
        let r = e(n);
        return r === void 0 ? null : [this, r];
      }
    );
  }
}
Ie.closedBy = new Ie({ deserialize: (t) => t.split(" ") });
Ie.openedBy = new Ie({ deserialize: (t) => t.split(" ") });
Ie.group = new Ie({ deserialize: (t) => t.split(" ") });
Ie.isolate = new Ie({
  deserialize: (t) => {
    if (t && t != "rtl" && t != "ltr" && t != "auto") throw new RangeError("Invalid value for isolate: " + t);
    return t || "auto";
  },
});
Ie.contextHash = new Ie({ perNode: !0 });
Ie.lookAhead = new Ie({ perNode: !0 });
Ie.mounted = new Ie({ perNode: !0 });
class Hu {
  constructor(e, n, r) {
    (this.tree = e), (this.overlay = n), (this.parser = r);
  }
  static get(e) {
    return e && e.props && e.props[Ie.mounted.id];
  }
}
const voe = Object.create(null);
class Kt {
  constructor(e, n, r, i = 0) {
    (this.name = e), (this.props = n), (this.id = r), (this.flags = i);
  }
  static define(e) {
    let n = e.props && e.props.length ? Object.create(null) : voe,
      r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0),
      i = new Kt(e.name || "", n, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if ((Array.isArray(s) || (s = s(i)), s)) {
          if (s[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
          n[s[0].id] = s[1];
        }
    }
    return i;
  }
  prop(e) {
    return this.props[e.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(e) {
    if (typeof e == "string") {
      if (this.name == e) return !0;
      let n = this.prop(Ie.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  static match(e) {
    let n = Object.create(null);
    for (let r in e) for (let i of r.split(" ")) n[i] = e[r];
    return (r) => {
      for (let i = r.prop(Ie.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = n[s < 0 ? r.name : i[s]];
        if (o) return o;
      }
    };
  }
}
Kt.none = new Kt("", Object.create(null), 0, 8);
class ic {
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...e) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), (i[o[0].id] = o[1]));
      }
      n.push(i ? new Kt(r.name, i, r.id, r.flags) : r);
    }
    return new ic(n);
  }
}
const Uf = new WeakMap(),
  R5 = new WeakMap();
var kt;
(function (t) {
  (t[(t.ExcludeBuffers = 1)] = "ExcludeBuffers"),
    (t[(t.IncludeAnonymous = 2)] = "IncludeAnonymous"),
    (t[(t.IgnoreMounts = 4)] = "IgnoreMounts"),
    (t[(t.IgnoreOverlays = 8)] = "IgnoreOverlays");
})(kt || (kt = {}));
class ze {
  constructor(e, n, r, i, s) {
    if (((this.type = e), (this.children = n), (this.positions = r), (this.length = i), (this.props = null), s && s.length)) {
      this.props = Object.create(null);
      for (let [o, a] of s) this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  toString() {
    let e = Hu.get(this);
    if (e && !e.overlay) return e.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), (n += i));
    }
    return this.type.name
      ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
          (n.length ? "(" + n + ")" : "")
      : n;
  }
  cursor(e = 0) {
    return new Bp(this.topNode, e);
  }
  cursorAt(e, n = 0, r = 0) {
    let i = Uf.get(this) || this.topNode,
      s = new Bp(i);
    return s.moveTo(e, n), Uf.set(this, s._tree), s;
  }
  get topNode() {
    return new En(this, 0, 0, null);
  }
  resolve(e, n = 0) {
    let r = qu(Uf.get(this) || this.topNode, e, n, !1);
    return Uf.set(this, r), r;
  }
  resolveInner(e, n = 0) {
    let r = qu(R5.get(this) || this.topNode, e, n, !0);
    return R5.set(this, r), r;
  }
  resolveStack(e, n = 0) {
    return yoe(this, e, n);
  }
  iterate(e) {
    let { enter: n, leave: r, from: i = 0, to: s = this.length } = e,
      o = e.mode || 0,
      a = (o & kt.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | kt.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= s && l.to >= i && ((!a && l.type.isAnonymous) || n(l) !== !1)) {
        if (l.firstChild()) continue;
        c = !0;
      }
      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent()) return;
        c = !0;
      }
    }
  }
  prop(e) {
    return e.perNode ? (this.props ? this.props[e.id] : void 0) : this.type.prop(e);
  }
  get propValues() {
    let e = [];
    if (this.props) for (let n in this.props) e.push([+n, this.props[n]]);
    return e;
  }
  balance(e = {}) {
    return this.children.length <= 8
      ? this
      : Dw(
          Kt.none,
          this.children,
          this.positions,
          0,
          this.children.length,
          0,
          this.length,
          (n, r, i) => new ze(this.type, n, r, i, this.propValues),
          e.makeTree || ((n, r, i) => new ze(Kt.none, n, r, i))
        );
  }
  static build(e) {
    return woe(e);
  }
}
ze.empty = new ze(Kt.none, [], [], 0);
class Lw {
  constructor(e, n) {
    (this.buffer = e), (this.index = n);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Lw(this.buffer, this.index);
  }
}
class oo {
  constructor(e, n, r) {
    (this.buffer = e), (this.length = n), (this.set = r);
  }
  get type() {
    return Kt.none;
  }
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; ) e.push(this.childString(n)), (n = this.buffer[n + 3]);
    return e.join(",");
  }
  childString(e) {
    let n = this.buffer[e],
      r = this.buffer[e + 3],
      i = this.set.types[n],
      s = i.name;
    if ((/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), (e += 4), r == e)) return s;
    let o = [];
    for (; e < r; ) o.push(this.childString(e)), (e = this.buffer[e + 3]);
    return s + "(" + o.join(",") + ")";
  }
  findChild(e, n, r, i, s) {
    let { buffer: o } = this,
      a = -1;
    for (let l = e; l != n && !(H4(s, i, o[l + 1], o[l + 2]) && ((a = l), r > 0)); l = o[l + 3]);
    return a;
  }
  slice(e, n, r) {
    let i = this.buffer,
      s = new Uint16Array(n - e),
      o = 0;
    for (let a = e, l = 0; a < n; ) {
      (s[l++] = i[a++]), (s[l++] = i[a++] - r);
      let c = (s[l++] = i[a++] - r);
      (s[l++] = i[a++] - e), (o = Math.max(o, c));
    }
    return new oo(s, o, this.set);
  }
}
function H4(t, e, n, r) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return r >= e && n < e;
    case 0:
      return n < e && r > e;
    case 1:
      return n <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function qu(t, e, n, r) {
  for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let o = !r && t instanceof En && t.index < 0 ? null : t.parent;
    if (!o) return t;
    t = o;
  }
  let s = r ? 0 : kt.IgnoreOverlays;
  if (r)
    for (let o = t, a = o.parent; a; o = a, a = o.parent)
      o instanceof En && o.index < 0 && ((i = a.enter(e, n, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = a);
  for (;;) {
    let o = t.enter(e, n, s);
    if (!o) return t;
    t = o;
  }
}
class q4 {
  cursor(e = 0) {
    return new Bp(this, e);
  }
  getChild(e, n = null, r = null) {
    let i = I5(this, e, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, n = null, r = null) {
    return I5(this, e, n, r);
  }
  resolve(e, n = 0) {
    return qu(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return qu(this, e, n, !0);
  }
  matchContext(e) {
    return Hv(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e),
      r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to) break;
      i.type.isError && i.from == i.to ? ((r = n), (n = i.prevSibling)) : (n = i);
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class En extends q4 {
  constructor(e, n, r, i) {
    super(), (this._tree = e), (this.from = n), (this.index = r), (this._parent = i);
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
        let u = a[e],
          h = l[e] + o.from;
        if (H4(i, r, h, h + u.length)) {
          if (u instanceof oo) {
            if (s & kt.ExcludeBuffers) continue;
            let f = u.findChild(0, u.buffer.length, n, r - h, i);
            if (f > -1) return new Ci(new xoe(o, u, e, h), null, f);
          } else if (s & kt.IncludeAnonymous || !u.type.isAnonymous || Mw(u)) {
            let f;
            if (!(s & kt.IgnoreMounts) && (f = Hu.get(u)) && !f.overlay) return new En(f.tree, h, e, o);
            let d = new En(u, h, e, o);
            return s & kt.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (
        s & kt.IncludeAnonymous ||
        !o.type.isAnonymous ||
        (o.index >= 0 ? (e = o.index + n) : (e = n < 0 ? -1 : o._parent._tree.children.length), (o = o._parent), !o)
      )
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(e) {
    return this.nextChild(0, 1, e, 2);
  }
  childBefore(e) {
    return this.nextChild(this._tree.children.length - 1, -1, e, -2);
  }
  enter(e, n, r = 0) {
    let i;
    if (!(r & kt.IgnoreOverlays) && (i = Hu.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: a } of i.overlay)
        if ((n > 0 ? o <= s : o < s) && (n < 0 ? a >= s : a > s)) return new En(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; ) e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function I5(t, e, n, r) {
  let i = t.cursor(),
    s = [];
  if (!i.firstChild()) return s;
  if (n != null) {
    for (let o = !1; !o; ) if (((o = i.type.is(n)), !i.nextSibling())) return s;
  }
  for (;;) {
    if (r != null && i.type.is(r)) return s;
    if ((i.type.is(e) && s.push(i.node), !i.nextSibling())) return r == null ? s : [];
  }
}
function Hv(t, e, n = e.length - 1) {
  for (let r = t.parent; n >= 0; r = r.parent) {
    if (!r) return !1;
    if (!r.type.isAnonymous) {
      if (e[n] && e[n] != r.name) return !1;
      n--;
    }
  }
  return !0;
}
class xoe {
  constructor(e, n, r, i) {
    (this.parent = e), (this.buffer = n), (this.index = r), (this.start = i);
  }
}
class Ci extends q4 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, r) {
    super(), (this.context = e), (this._parent = n), (this.index = r), (this.type = e.buffer.set.types[e.buffer.buffer[r]]);
  }
  child(e, n, r) {
    let { buffer: i } = this.context,
      s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
    return s < 0 ? null : new Ci(this.context, this, s);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(e) {
    return this.child(1, e, 2);
  }
  childBefore(e) {
    return this.child(-1, e, -2);
  }
  enter(e, n, r = 0) {
    if (r & kt.ExcludeBuffers) return null;
    let { buffer: i } = this.context,
      s = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return s < 0 ? null : new Ci(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
  }
  get nextSibling() {
    let { buffer: e } = this.context,
      n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length)
      ? new Ci(this.context, this._parent, n)
      : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context,
      n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Ci(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [],
      n = [],
      { buffer: r } = this.context,
      i = this.index + 4,
      s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), n.push(0);
    }
    return new ze(this.type, e, n, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function Y4(t) {
  if (!t.length) return null;
  let e = 0,
    n = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > n.from || o.to < n.to) && ((n = o), (e = s));
  }
  let r = n instanceof En && n.index < 0 ? null : n.parent,
    i = t.slice();
  return r ? (i[e] = r) : i.splice(e, 1), new boe(i, n);
}
class boe {
  constructor(e, n) {
    (this.heads = e), (this.node = n);
  }
  get next() {
    return Y4(this.heads);
  }
}
function yoe(t, e, n) {
  let r = t.resolveInner(e, n),
    i = null;
  for (let s = r instanceof En ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, n)), (s = o);
    } else {
      let o = Hu.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new En(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(qu(a, e, n, !1));
      }
    }
  return i ? Y4(i) : r;
}
class Bp {
  get name() {
    return this.type.name;
  }
  constructor(e, n = 0) {
    if (((this.mode = n), (this.buffer = null), (this.stack = []), (this.index = 0), (this.bufferNode = null), e instanceof En))
      this.yieldNode(e);
    else {
      (this._tree = e.context.parent), (this.buffer = e.context);
      for (let r = e._parent; r; r = r._parent) this.stack.unshift(r.index);
      (this.bufferNode = e), this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? ((this._tree = e), (this.type = e.type), (this.from = e.from), (this.to = e.to), !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return (this.type = n || i.set.types[i.buffer[e]]), (this.from = r + i.buffer[e + 1]), (this.to = r + i.buffer[e + 2]), !0;
  }
  yield(e) {
    return e
      ? e instanceof En
        ? ((this.buffer = null), this.yieldNode(e))
        : ((this.buffer = e.context), this.yieldBuf(e.index, e.type))
      : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(e, n, r) {
    if (!this.buffer) return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
    let { buffer: i } = this.buffer,
      s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(e) {
    return this.enterChild(1, e, 2);
  }
  childBefore(e) {
    return this.enterChild(-1, e, -2);
  }
  enter(e, n, r = this.mode) {
    return this.buffer ? (r & kt.ExcludeBuffers ? !1 : this.enterChild(1, e, n)) : this.yield(this._tree.enter(e, n, r));
  }
  parent() {
    if (!this.buffer) return this.yieldNode(this.mode & kt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let e = this.mode & kt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return (this.buffer = null), this.yieldNode(e);
  }
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent
        ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode))
        : !1;
    let { buffer: n } = this.buffer,
      r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i) return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3])) return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n,
      r,
      { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length) return !1;
      } else for (let s = 0; s < this.index; s++) if (i.buffer.buffer[s + 3] < this.index) return !1;
      ({ index: n, parent: r } = i);
    } else ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let s = n + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let a = r._tree.children[s];
          if (this.mode & kt.IncludeAnonymous || a instanceof oo || !a.type.isAnonymous || Mw(a)) return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(e, 0, 4)) return !0;
    for (;;) {
      if (this.sibling(e)) return !0;
      if (this.atLastNode(e) || !this.parent()) return !1;
    }
  }
  next(e = !0) {
    return this.move(1, e);
  }
  prev(e = !0) {
    return this.move(-1, e);
  }
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); );
    for (; this.enterChild(1, e, n); );
    return this;
  }
  get node() {
    if (!this.buffer) return this._tree;
    let e = this.bufferNode,
      n = null,
      r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index) return o;
            (n = o), (r = s + 1);
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = r; i < this.stack.length; i++) n = new Ci(this.buffer, n, this.stack[i]);
    return (this.bufferNode = new Ci(this.buffer, n, this.index));
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(e, n) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && n && n(this), (i = this.type.isAnonymous), !this.nextSibling(); ) {
        if (!r) return;
        this.parent(), r--, (i = !0);
      }
    }
  }
  matchContext(e) {
    if (!this.buffer) return Hv(this.node, e);
    let { buffer: n } = this.buffer,
      { types: r } = n.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0) return Hv(this.node, e, i);
      let o = r[n.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name) return !1;
        i--;
      }
    }
    return !0;
  }
}
function Mw(t) {
  return t.children.some((e) => e instanceof oo || !e.type.isAnonymous || Mw(e));
}
function woe(t) {
  var e;
  let { buffer: n, nodeSet: r, maxBufferLength: i = X4, reused: s = [], minRepeatType: o = r.types.length } = t,
    a = Array.isArray(n) ? new Lw(n, n.length) : n,
    l = r.types,
    c = 0,
    u = 0;
  function h(S, k, b, _, T, P) {
    let { id: M, start: D, end: V, size: Q } = a,
      N = u;
    for (; Q < 0; )
      if ((a.next(), Q == -1)) {
        let $ = s[M];
        b.push($), _.push(D - S);
        return;
      } else if (Q == -3) {
        c = M;
        return;
      } else if (Q == -4) {
        u = M;
        return;
      } else throw new RangeError(`Unrecognized record size: ${Q}`);
    let G = l[M],
      H,
      te,
      le = D - S;
    if (V - D <= i && (te = O(a.pos - k, T))) {
      let $ = new Uint16Array(te.size - te.skip),
        B = a.pos - te.size,
        ie = $.length;
      for (; a.pos > B; ) ie = v(te.start, $, ie);
      (H = new oo($, V - te.start, r)), (le = te.start - S);
    } else {
      let $ = a.pos - Q;
      a.next();
      let B = [],
        ie = [],
        L = M >= o ? M : -1,
        pe = 0,
        Ce = V;
      for (; a.pos > $; )
        L >= 0 && a.id == L && a.size >= 0
          ? (a.end <= Ce - i && (p(B, ie, D, pe, a.end, Ce, L, N), (pe = B.length), (Ce = a.end)), a.next())
          : P > 2500
          ? f(D, $, B, ie)
          : h(D, $, B, ie, L, P + 1);
      if ((L >= 0 && pe > 0 && pe < B.length && p(B, ie, D, pe, D, Ce, L, N), B.reverse(), ie.reverse(), L > -1 && pe > 0)) {
        let me = d(G);
        H = Dw(G, B, ie, 0, B.length, 0, V - D, me, me);
      } else H = m(G, B, ie, V - D, N - V);
    }
    b.push(H), _.push(le);
  }
  function f(S, k, b, _) {
    let T = [],
      P = 0,
      M = -1;
    for (; a.pos > k; ) {
      let { id: D, start: V, end: Q, size: N } = a;
      if (N > 4) a.next();
      else {
        if (M > -1 && V < M) break;
        M < 0 && (M = Q - i), T.push(D, V, Q), P++, a.next();
      }
    }
    if (P) {
      let D = new Uint16Array(P * 4),
        V = T[T.length - 2];
      for (let Q = T.length - 3, N = 0; Q >= 0; Q -= 3) (D[N++] = T[Q]), (D[N++] = T[Q + 1] - V), (D[N++] = T[Q + 2] - V), (D[N++] = N);
      b.push(new oo(D, T[2] - V, r)), _.push(V - S);
    }
  }
  function d(S) {
    return (k, b, _) => {
      let T = 0,
        P = k.length - 1,
        M,
        D;
      if (P >= 0 && (M = k[P]) instanceof ze) {
        if (!P && M.type == S && M.length == _) return M;
        (D = M.prop(Ie.lookAhead)) && (T = b[P] + M.length + D);
      }
      return m(S, k, b, _, T);
    };
  }
  function p(S, k, b, _, T, P, M, D) {
    let V = [],
      Q = [];
    for (; S.length > _; ) V.push(S.pop()), Q.push(k.pop() + b - T);
    S.push(m(r.types[M], V, Q, P - T, D - P)), k.push(T - b);
  }
  function m(S, k, b, _, T = 0, P) {
    if (c) {
      let M = [Ie.contextHash, c];
      P = P ? [M].concat(P) : [M];
    }
    if (T > 25) {
      let M = [Ie.lookAhead, T];
      P = P ? [M].concat(P) : [M];
    }
    return new ze(S, k, b, _, P);
  }
  function O(S, k) {
    let b = a.fork(),
      _ = 0,
      T = 0,
      P = 0,
      M = b.end - i,
      D = { size: 0, start: 0, skip: 0 };
    e: for (let V = b.pos - S; b.pos > V; ) {
      let Q = b.size;
      if (b.id == k && Q >= 0) {
        (D.size = _), (D.start = T), (D.skip = P), (P += 4), (_ += 4), b.next();
        continue;
      }
      let N = b.pos - Q;
      if (Q < 0 || N < V || b.start < M) break;
      let G = b.id >= o ? 4 : 0,
        H = b.start;
      for (b.next(); b.pos > N; ) {
        if (b.size < 0)
          if (b.size == -3) G += 4;
          else break e;
        else b.id >= o && (G += 4);
        b.next();
      }
      (T = H), (_ += Q), (P += G);
    }
    return (k < 0 || _ == S) && ((D.size = _), (D.start = T), (D.skip = P)), D.size > 4 ? D : void 0;
  }
  function v(S, k, b) {
    let { id: _, start: T, end: P, size: M } = a;
    if ((a.next(), M >= 0 && _ < o)) {
      let D = b;
      if (M > 4) {
        let V = a.pos - (M - 4);
        for (; a.pos > V; ) b = v(S, k, b);
      }
      (k[--b] = D), (k[--b] = P - S), (k[--b] = T - S), (k[--b] = _);
    } else M == -3 ? (c = _) : M == -4 && (u = _);
    return b;
  }
  let g = [],
    x = [];
  for (; a.pos > 0; ) h(t.start || 0, t.bufferStart || 0, g, x, -1, 0);
  let y = (e = t.length) !== null && e !== void 0 ? e : g.length ? x[0] + g[0].length : 0;
  return new ze(l[t.topID], g.reverse(), x.reverse(), y);
}
const N5 = new WeakMap();
function Md(t, e) {
  if (!t.isAnonymous || e instanceof oo || e.type != t) return 1;
  let n = N5.get(e);
  if (n == null) {
    n = 1;
    for (let r of e.children) {
      if (r.type != t || !(r instanceof ze)) {
        n = 1;
        break;
      }
      n += Md(t, r);
    }
    N5.set(e, n);
  }
  return n;
}
function Dw(t, e, n, r, i, s, o, a, l) {
  let c = 0;
  for (let p = r; p < i; p++) c += Md(t, e[p]);
  let u = Math.ceil((c * 1.5) / 8),
    h = [],
    f = [];
  function d(p, m, O, v, g) {
    for (let x = O; x < v; ) {
      let y = x,
        S = m[x],
        k = Md(t, p[x]);
      for (x++; x < v; x++) {
        let b = Md(t, p[x]);
        if (k + b >= u) break;
        k += b;
      }
      if (x == y + 1) {
        if (k > u) {
          let b = p[y];
          d(b.children, b.positions, 0, b.children.length, m[y] + g);
          continue;
        }
        h.push(p[y]);
      } else {
        let b = m[x - 1] + p[x - 1].length - S;
        h.push(Dw(t, p, m, y, x, S, b, null, l));
      }
      f.push(S + g - s);
    }
  }
  return d(e, n, r, i, 0), (a || l)(h, f, o);
}
class G4 {
  constructor() {
    this.map = new WeakMap();
  }
  setBuffer(e, n, r) {
    let i = this.map.get(e);
    i || this.map.set(e, (i = new Map())), i.set(n, r);
  }
  getBuffer(e, n) {
    let r = this.map.get(e);
    return r && r.get(n);
  }
  set(e, n) {
    e instanceof Ci ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof En && this.map.set(e.tree, n);
  }
  get(e) {
    return e instanceof Ci ? this.getBuffer(e.context.buffer, e.index) : e instanceof En ? this.map.get(e.tree) : void 0;
  }
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class is {
  constructor(e, n, r, i, s = !1, o = !1) {
    (this.from = e), (this.to = n), (this.tree = r), (this.offset = i), (this.open = (s ? 1 : 0) | (o ? 2 : 0));
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(e, n = [], r = !1) {
    let i = [new is(0, e.length, e, 0, !1, r)];
    for (let s of n) s.to > e.length && i.push(s);
    return i;
  }
  static applyChanges(e, n, r = 128) {
    if (!n.length) return e;
    let i = [],
      s = 1,
      o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < n.length ? n[a] : null,
        h = u ? u.fromA : 1e9;
      if (h - l >= r)
        for (; o && o.from < h; ) {
          let f = o;
          if (l >= f.from || h <= f.to || c) {
            let d = Math.max(f.from, l) - c,
              p = Math.min(f.to, h) - c;
            f = d >= p ? null : new is(d, p, f.tree, f.offset + c, a > 0, !!u);
          }
          if ((f && i.push(f), o.to > h)) break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u) break;
      (l = u.toA), (c = u.toA - u.toB);
    }
    return i;
  }
}
class Cg {
  startParse(e, n, r) {
    return (
      typeof e == "string" && (e = new Soe(e)),
      (r = r ? (r.length ? r.map((i) => new Ar(i.from, i.to)) : [new Ar(0, 0)]) : [new Ar(0, e.length)]),
      this.createParse(e, n || [], r)
    );
  }
  parse(e, n, r) {
    let i = this.startParse(e, n, r);
    for (;;) {
      let s = i.advance();
      if (s) return s;
    }
  }
}
class Soe {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
function J4(t) {
  return (e, n, r, i) => new Coe(e, t, n, r, i);
}
class L5 {
  constructor(e, n, r, i, s) {
    (this.parser = e), (this.parse = n), (this.overlay = r), (this.target = i), (this.from = s);
  }
}
function M5(t) {
  if (!t.length || t.some((e) => e.from >= e.to)) throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class koe {
  constructor(e, n, r, i, s, o, a) {
    (this.parser = e),
      (this.predicate = n),
      (this.mounts = r),
      (this.index = i),
      (this.start = s),
      (this.target = o),
      (this.prev = a),
      (this.depth = 0),
      (this.ranges = []);
  }
}
const qv = new Ie({ perNode: !0 });
class Coe {
  constructor(e, n, r, i, s) {
    (this.nest = n),
      (this.input = r),
      (this.fragments = i),
      (this.ranges = s),
      (this.inner = []),
      (this.innerDone = 0),
      (this.baseTree = null),
      (this.stoppedAt = null),
      (this.baseParse = e);
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r) return null;
      if (((this.baseParse = null), (this.baseTree = r), this.startInner(), this.stoppedAt != null))
        for (let i of this.inner) i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return (
        this.stoppedAt != null && (r = new ze(r.type, r.children, r.positions, r.length, r.propValues.concat([[qv, this.stoppedAt]]))), r
      );
    }
    let e = this.inner[this.innerDone],
      n = e.parse.advance();
    if (n) {
      this.innerDone++;
      let r = Object.assign(Object.create(null), e.target.props);
      (r[Ie.mounted.id] = new Hu(n, e.overlay, e.parser)), (e.target.props = r);
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse) return 0;
    let e = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++) this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (((this.stoppedAt = e), this.baseParse)) this.baseParse.stopAt(e);
    else for (let n = this.innerDone; n < this.inner.length; n++) this.inner[n].parse.stopAt(e);
  }
  startInner() {
    let e = new Toe(this.fragments),
      n = null,
      r = null,
      i = new Bp(new En(this.baseTree, this.ranges[0].from, 0, null), kt.IncludeAnonymous | kt.IgnoreMounts);
    e: for (let s, o; ; ) {
      let a = !0,
        l;
      if (this.stoppedAt != null && i.from >= this.stoppedAt) a = !1;
      else if (e.hasNode(i)) {
        if (n) {
          let c = n.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos,
                f = u.to + c.pos;
              h >= i.from && f <= i.to && !n.ranges.some((d) => d.from < f && d.to > h) && n.ranges.push({ from: h, to: f });
            }
        }
        a = !1;
      } else if (r && (o = _oe(r.ranges, i.from, i.to))) a = o != 2;
      else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
        i.tree || Eoe(i);
        let c = e.findMounts(i.from, s.parser);
        if (typeof s.overlay == "function") n = new koe(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, n);
        else {
          let u = F5(this.ranges, s.overlay || (i.from < i.to ? [new Ar(i.from, i.to)] : []));
          u.length && M5(u),
            (u.length || !s.overlay) &&
              this.inner.push(
                new L5(
                  s.parser,
                  u.length ? s.parser.startParse(this.input, V5(c, u), u) : s.parser.startParse(""),
                  s.overlay ? s.overlay.map((h) => new Ar(h.from - i.from, h.to - i.from)) : null,
                  i.tree,
                  u.length ? u[0].from : i.from
                )
              ),
            s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : (a = !1);
        }
      } else n && (l = n.predicate(i)) && (l === !0 && (l = new Ar(i.from, i.to)), l.from < l.to && n.ranges.push(l));
      if (a && i.firstChild()) n && n.depth++, r && r.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent()) break e;
          if (n && !--n.depth) {
            let c = F5(this.ranges, n.ranges);
            c.length &&
              (M5(c),
              this.inner.splice(
                n.index,
                0,
                new L5(
                  n.parser,
                  n.parser.startParse(this.input, V5(n.mounts, c), c),
                  n.ranges.map((u) => new Ar(u.from - n.start, u.to - n.start)),
                  n.target,
                  c[0].from
                )
              )),
              (n = n.prev);
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function _oe(t, e, n) {
  for (let r of t) {
    if (r.from >= n) break;
    if (r.to > e) return r.from <= e && r.to >= n ? 2 : 1;
  }
  return 0;
}
function D5(t, e, n, r, i, s) {
  if (e < n) {
    let o = t.buffer[e + 1];
    r.push(t.slice(e, n, o)), i.push(o - s);
  }
}
function Eoe(t) {
  let { node: e } = t,
    n = [],
    r = e.context.buffer;
  do n.push(t.index), t.parent();
  while (!t.tree);
  let i = t.tree,
    s = i.children.indexOf(r),
    o = i.children[s],
    a = o.buffer,
    l = [s];
  function c(u, h, f, d, p, m) {
    let O = n[m],
      v = [],
      g = [];
    D5(o, u, O, v, g, d);
    let x = a[O + 1],
      y = a[O + 2];
    l.push(v.length);
    let S = m ? c(O + 4, a[O + 3], o.set.types[a[O]], x, y - x, m - 1) : e.toTree();
    return v.push(S), g.push(x - d), D5(o, a[O + 3], h, v, g, d), new ze(f, v, g, p);
  }
  i.children[s] = c(0, a.length, Kt.none, 0, o.length, n.length - 1);
  for (let u of l) {
    let h = t.tree.children[u],
      f = t.tree.positions[u];
    t.yield(new En(h, f + t.from, u, t._tree));
  }
}
class Q5 {
  constructor(e, n) {
    (this.offset = n), (this.done = !1), (this.cursor = e.cursor(kt.IncludeAnonymous | kt.IgnoreMounts));
  }
  moveTo(e) {
    let { cursor: n } = this,
      r = e - this.offset;
    for (; !this.done && n.from < r; )
      (n.to >= e && n.enter(r, 1, kt.IgnoreOverlays | kt.ExcludeBuffers)) || n.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if ((this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree))
      for (let n = this.cursor.tree; ; ) {
        if (n == e.tree) return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof ze) n = n.children[0];
        else break;
      }
    return !1;
  }
}
let Toe = class {
  constructor(e) {
    var n;
    if (((this.fragments = e), (this.curTo = 0), (this.fragI = 0), e.length)) {
      let r = (this.curFrag = e[0]);
      (this.curTo = (n = r.tree.prop(qv)) !== null && n !== void 0 ? n : r.to), (this.inner = new Q5(r.tree, -r.offset));
    } else this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; ) this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if ((this.fragI++, this.fragI == this.fragments.length)) this.curFrag = this.inner = null;
    else {
      let n = (this.curFrag = this.fragments[this.fragI]);
      (this.curTo = (e = n.tree.prop(qv)) !== null && e !== void 0 ? e : n.to), (this.inner = new Q5(n.tree, -n.offset));
    }
  }
  findMounts(e, n) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(Ie.mounted);
        if (o && o.parser == n)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= s.to) break;
            l.tree == this.curFrag.tree && i.push({ frag: l, pos: s.from - l.offset, mount: o });
          }
      }
    }
    return i;
  }
};
function F5(t, e) {
  let n = null,
    r = e;
  for (let i = 1, s = 0; i < t.length; i++) {
    let o = t[i - 1].to,
      a = t[i].from;
    for (; s < r.length; s++) {
      let l = r[s];
      if (l.from >= a) break;
      l.to <= o ||
        (n || (r = n = e.slice()),
        l.from < o
          ? ((n[s] = new Ar(l.from, o)), l.to > a && n.splice(s + 1, 0, new Ar(a, l.to)))
          : l.to > a
          ? (n[s--] = new Ar(a, l.to))
          : n.splice(s--, 1));
    }
  }
  return r;
}
function Poe(t, e, n, r) {
  let i = 0,
    s = 0,
    o = !1,
    a = !1,
    l = -1e9,
    c = [];
  for (;;) {
    let u = i == t.length ? 1e9 : o ? t[i].to : t[i].from,
      h = s == e.length ? 1e9 : a ? e[s].to : e[s].from;
    if (o != a) {
      let f = Math.max(l, n),
        d = Math.min(u, h, r);
      f < d && c.push(new Ar(f, d));
    }
    if (((l = Math.min(u, h)), l == 1e9)) break;
    u == l && (o ? ((o = !1), i++) : (o = !0)), h == l && (a ? ((a = !1), s++) : (a = !0));
  }
  return c;
}
function V5(t, e) {
  let n = [];
  for (let { pos: r, mount: i, frag: s } of t) {
    let o = r + (i.overlay ? i.overlay[0].from : 0),
      a = o + i.tree.length,
      l = Math.max(s.from, o),
      c = Math.min(s.to, a);
    if (i.overlay) {
      let u = i.overlay.map((f) => new Ar(f.from + r, f.to + r)),
        h = Poe(e, u, l, c);
      for (let f = 0, d = l; ; f++) {
        let p = f == h.length,
          m = p ? c : h[f].from;
        if ((m > d && n.push(new is(d, m, i.tree, -o, s.from >= d || s.openStart, s.to <= m || s.openEnd)), p)) break;
        d = h[f].to;
      }
    } else n.push(new is(l, c, i.tree, -o, s.from >= o || s.openStart, s.to <= a || s.openEnd));
  }
  return n;
}
let Aoe = 0;
class Ur {
  constructor(e, n, r) {
    (this.set = e), (this.base = n), (this.modified = r), (this.id = Aoe++);
  }
  static define(e) {
    if (e != null && e.base) throw new Error("Can not derive from a modified tag");
    let n = new Ur([], null, []);
    if ((n.set.push(n), e)) for (let r of e.set) n.set.push(r);
    return n;
  }
  static defineModifier() {
    let e = new jp();
    return (n) =>
      n.modified.indexOf(e) > -1
        ? n
        : jp.get(
            n.base || n,
            n.modified.concat(e).sort((r, i) => r.id - i.id)
          );
  }
}
let $oe = 0;
class jp {
  constructor() {
    (this.instances = []), (this.id = $oe++);
  }
  static get(e, n) {
    if (!n.length) return e;
    let r = n[0].instances.find((a) => a.base == e && Roe(n, a.modified));
    if (r) return r;
    let i = [],
      s = new Ur(i, e, n);
    for (let a of n) a.instances.push(s);
    let o = Ioe(n);
    for (let a of e.set) if (!a.modified.length) for (let l of o) i.push(jp.get(a, l));
    return s;
  }
}
function Roe(t, e) {
  return t.length == e.length && t.every((n, r) => n == e[r]);
}
function Ioe(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++) for (let r = 0, i = e.length; r < i; r++) e.push(e[r].concat(t[n]));
  return e.sort((n, r) => r.length - n.length);
}
function sc(t) {
  let e = Object.create(null);
  for (let n in t) {
    let r = t[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let s = [],
          o = 2,
          a = i;
        for (let h = 0; ; ) {
          if (a == "..." && h > 0 && h + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!f) throw new RangeError("Invalid path: " + i);
          if ((s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), (h += f[0].length), h == i.length)) break;
          let d = i[h++];
          if (h == i.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/") throw new RangeError("Invalid path: " + i);
          a = i.slice(h);
        }
        let l = s.length - 1,
          c = s[l];
        if (!c) throw new RangeError("Invalid path: " + i);
        let u = new Zp(r, o, l > 0 ? s.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return K4.add(e);
}
const K4 = new Ie();
class Zp {
  constructor(e, n, r, i) {
    (this.tags = e), (this.mode = n), (this.context = r), (this.next = i);
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? ((this.next = e), this) : ((e.next = this.sort(e.next)), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Zp.empty = new Zp([], 2, null);
function e8(t, e) {
  let n = Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag)) n[s.tag.id] = s.class;
    else for (let o of s.tag) n[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let a of s)
        for (let l of a.set) {
          let c = n[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r,
  };
}
function Noe(t, e) {
  let n = null;
  for (let r of t) {
    let i = r.style(e);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function t8(t, e, n, r = 0, i = t.length) {
  let s = new Loe(r, Array.isArray(e) ? e : [e], n);
  s.highlightRange(t.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class Loe {
  constructor(e, n, r) {
    (this.at = e), (this.highlighters = n), (this.span = r), (this.class = "");
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), (this.class = n));
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, r, i, s) {
    let { type: o, from: a, to: l } = e;
    if (a >= r || l <= n) return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = i,
      u = Moe(e) || Zp.empty,
      h = Noe(s, u.tags);
    if ((h && (c && (c += " "), (c += h), u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(n, a), c), u.opaque)) return;
    let f = e.tree && e.tree.prop(Ie.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + a, 1),
        p = this.highlighters.filter((O) => !O.scope || O.scope(f.tree.type)),
        m = e.firstChild();
      for (let O = 0, v = a; ; O++) {
        let g = O < f.overlay.length ? f.overlay[O] : null,
          x = g ? g.from + a : l,
          y = Math.max(n, v),
          S = Math.min(r, x);
        if (y < S && m)
          for (
            ;
            e.from < S && (this.highlightRange(e, y, S, i, s), this.startSpan(Math.min(S, e.to), c), !(e.to >= x || !e.nextSibling()));

          );
        if (!g || x > r) break;
        (v = g.to + a),
          v > n && (this.highlightRange(d.cursor(), Math.max(n, g.from + a), Math.min(r, v), "", p), this.startSpan(Math.min(r, v), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= r) break;
          this.highlightRange(e, n, r, i, s), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function Moe(t) {
  let e = t.type.prop(K4);
  for (; e && e.context && !t.matchContext(e.context); ) e = e.next;
  return e || null;
}
const he = Ur.define,
  Xf = he(),
  As = he(),
  B5 = he(As),
  j5 = he(As),
  $s = he(),
  Hf = he($s),
  Y0 = he($s),
  mi = he(),
  Eo = he(mi),
  di = he(),
  pi = he(),
  Yv = he(),
  Ec = he(Yv),
  qf = he(),
  R = {
    comment: Xf,
    lineComment: he(Xf),
    blockComment: he(Xf),
    docComment: he(Xf),
    name: As,
    variableName: he(As),
    typeName: B5,
    tagName: he(B5),
    propertyName: j5,
    attributeName: he(j5),
    className: he(As),
    labelName: he(As),
    namespace: he(As),
    macroName: he(As),
    literal: $s,
    string: Hf,
    docString: he(Hf),
    character: he(Hf),
    attributeValue: he(Hf),
    number: Y0,
    integer: he(Y0),
    float: he(Y0),
    bool: he($s),
    regexp: he($s),
    escape: he($s),
    color: he($s),
    url: he($s),
    keyword: di,
    self: he(di),
    null: he(di),
    atom: he(di),
    unit: he(di),
    modifier: he(di),
    operatorKeyword: he(di),
    controlKeyword: he(di),
    definitionKeyword: he(di),
    moduleKeyword: he(di),
    operator: pi,
    derefOperator: he(pi),
    arithmeticOperator: he(pi),
    logicOperator: he(pi),
    bitwiseOperator: he(pi),
    compareOperator: he(pi),
    updateOperator: he(pi),
    definitionOperator: he(pi),
    typeOperator: he(pi),
    controlOperator: he(pi),
    punctuation: Yv,
    separator: he(Yv),
    bracket: Ec,
    angleBracket: he(Ec),
    squareBracket: he(Ec),
    paren: he(Ec),
    brace: he(Ec),
    content: mi,
    heading: Eo,
    heading1: he(Eo),
    heading2: he(Eo),
    heading3: he(Eo),
    heading4: he(Eo),
    heading5: he(Eo),
    heading6: he(Eo),
    contentSeparator: he(mi),
    list: he(mi),
    quote: he(mi),
    emphasis: he(mi),
    strong: he(mi),
    link: he(mi),
    monospace: he(mi),
    strikethrough: he(mi),
    inserted: he(),
    deleted: he(),
    changed: he(),
    invalid: he(),
    meta: qf,
    documentMeta: he(qf),
    annotation: he(qf),
    processingInstruction: he(qf),
    definition: Ur.defineModifier(),
    constant: Ur.defineModifier(),
    function: Ur.defineModifier(),
    standard: Ur.defineModifier(),
    local: Ur.defineModifier(),
    special: Ur.defineModifier(),
  };
e8([
  { tag: R.link, class: "tok-link" },
  { tag: R.heading, class: "tok-heading" },
  { tag: R.emphasis, class: "tok-emphasis" },
  { tag: R.strong, class: "tok-strong" },
  { tag: R.keyword, class: "tok-keyword" },
  { tag: R.atom, class: "tok-atom" },
  { tag: R.bool, class: "tok-bool" },
  { tag: R.url, class: "tok-url" },
  { tag: R.labelName, class: "tok-labelName" },
  { tag: R.inserted, class: "tok-inserted" },
  { tag: R.deleted, class: "tok-deleted" },
  { tag: R.literal, class: "tok-literal" },
  { tag: R.string, class: "tok-string" },
  { tag: R.number, class: "tok-number" },
  { tag: [R.regexp, R.escape, R.special(R.string)], class: "tok-string2" },
  { tag: R.variableName, class: "tok-variableName" },
  { tag: R.local(R.variableName), class: "tok-variableName tok-local" },
  { tag: R.definition(R.variableName), class: "tok-variableName tok-definition" },
  { tag: R.special(R.variableName), class: "tok-variableName2" },
  { tag: R.definition(R.propertyName), class: "tok-propertyName tok-definition" },
  { tag: R.typeName, class: "tok-typeName" },
  { tag: R.namespace, class: "tok-namespace" },
  { tag: R.className, class: "tok-className" },
  { tag: R.macroName, class: "tok-macroName" },
  { tag: R.propertyName, class: "tok-propertyName" },
  { tag: R.operator, class: "tok-operator" },
  { tag: R.comment, class: "tok-comment" },
  { tag: R.meta, class: "tok-meta" },
  { tag: R.invalid, class: "tok-invalid" },
  { tag: R.punctuation, class: "tok-punctuation" },
]);
var G0;
const js = new Ie();
function _g(t) {
  return ye.define({ combine: t ? (e) => e.concat(t) : void 0 });
}
const Qw = new Ie();
class mr {
  constructor(e, n, r = [], i = "") {
    (this.data = e),
      (this.name = i),
      Qe.prototype.hasOwnProperty("tree") ||
        Object.defineProperty(Qe.prototype, "tree", {
          get() {
            return pt(this);
          },
        }),
      (this.parser = n),
      (this.extension = [
        ao.of(this),
        Qe.languageData.of((s, o, a) => {
          let l = Z5(s, o, a),
            c = l.type.prop(js);
          if (!c) return [];
          let u = s.facet(c),
            h = l.type.prop(Qw);
          if (h) {
            let f = l.resolve(o - l.from, a);
            for (let d of h)
              if (d.test(f, s)) {
                let p = s.facet(d.facet);
                return d.type == "replace" ? p : p.concat(u);
              }
          }
          return u;
        }),
      ].concat(r));
  }
  isActiveAt(e, n, r = -1) {
    return Z5(e, n, r).type.prop(js) == this.data;
  }
  findRegions(e) {
    let n = e.facet(ao);
    if ((n == null ? void 0 : n.data) == this.data) return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting) return [];
    let r = [],
      i = (s, o) => {
        if (s.prop(js) == this.data) {
          r.push({ from: o, to: o + s.length });
          return;
        }
        let a = s.prop(Ie.mounted);
        if (a) {
          if (a.tree.prop(js) == this.data) {
            if (a.overlay) for (let l of a.overlay) r.push({ from: l.from + o, to: l.to + o });
            else r.push({ from: o, to: o + s.length });
            return;
          } else if (a.overlay) {
            let l = r.length;
            if ((i(a.tree, a.overlay[0].from + o), r.length > l)) return;
          }
        }
        for (let l = 0; l < s.children.length; l++) {
          let c = s.children[l];
          c instanceof ze && i(c, s.positions[l] + o);
        }
      };
    return i(pt(e), 0), r;
  }
  get allowsNesting() {
    return !0;
  }
}
mr.setState = Ae.define();
function Z5(t, e, n) {
  let r = t.facet(ao),
    i = pt(t).topNode;
  if (!r || r.allowsNesting) for (let s = i; s; s = s.enter(e, n, kt.ExcludeBuffers)) s.type.isTop && (i = s);
  return i;
}
class _l extends mr {
  constructor(e, n, r) {
    super(e, n, [], r), (this.parser = n);
  }
  static define(e) {
    let n = _g(e.languageData);
    return new _l(n, e.parser.configure({ props: [js.add((r) => (r.isTop ? n : void 0))] }), e.name);
  }
  configure(e, n) {
    return new _l(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function pt(t) {
  let e = t.field(mr.state, !1);
  return e ? e.tree : ze.empty;
}
class Doe {
  constructor(e) {
    (this.doc = e), (this.cursorPos = 0), (this.string = ""), (this.cursor = e.iter());
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return (
      (this.string = this.cursor.next(e - this.cursorPos).value),
      (this.cursorPos = e + this.string.length),
      this.cursorPos - this.string.length
    );
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let r = this.cursorPos - this.string.length;
    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
  }
}
let Tc = null;
class na {
  constructor(e, n, r = [], i, s, o, a, l) {
    (this.parser = e),
      (this.state = n),
      (this.fragments = r),
      (this.tree = i),
      (this.treeLen = s),
      (this.viewport = o),
      (this.skipped = a),
      (this.scheduleOn = l),
      (this.parse = null),
      (this.tempSkipped = []);
  }
  static create(e, n, r) {
    return new na(e, n, [], ze.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new Doe(this.state.doc), this.fragments);
  }
  work(e, n) {
    return (
      n != null && n >= this.state.doc.length && (n = void 0),
      this.tree != ze.empty && this.isDone(n ?? this.state.doc.length)
        ? (this.takeTree(), !0)
        : this.withContext(() => {
            var r;
            if (typeof e == "number") {
              let i = Date.now() + e;
              e = () => Date.now() > i;
            }
            for (
              this.parse || (this.parse = this.startParse()),
                n != null &&
                  (this.parse.stoppedAt == null || this.parse.stoppedAt > n) &&
                  n < this.state.doc.length &&
                  this.parse.stopAt(n);
              ;

            ) {
              let i = this.parse.advance();
              if (i)
                if (
                  ((this.fragments = this.withoutTempSkipped(is.addTree(i, this.fragments, this.parse.stoppedAt != null))),
                  (this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length),
                  (this.tree = i),
                  (this.parse = null),
                  this.treeLen < (n ?? this.state.doc.length))
                )
                  this.parse = this.startParse();
                else return !0;
              if (e()) return !1;
            }
          })
    );
  }
  takeTree() {
    let e, n;
    this.parse &&
      (e = this.parse.parsedPos) >= this.treeLen &&
      ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e),
      this.withContext(() => {
        for (; !(n = this.parse.advance()); );
      }),
      (this.treeLen = e),
      (this.tree = n),
      (this.fragments = this.withoutTempSkipped(is.addTree(this.tree, this.fragments, !0))),
      (this.parse = null));
  }
  withContext(e) {
    let n = Tc;
    Tc = this;
    try {
      return e();
    } finally {
      Tc = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; (n = this.tempSkipped.pop()); ) e = z5(e, n.from, n.to);
    return e;
  }
  changes(e, n) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: a } = this;
    if ((this.takeTree(), !e.empty)) {
      let l = [];
      if (
        (e.iterChangedRanges((c, u, h, f) => l.push({ fromA: c, toA: u, fromB: h, toB: f })),
        (r = is.applyChanges(r, l)),
        (i = ze.empty),
        (s = 0),
        (o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }),
        this.skipped.length)
      ) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1),
            h = e.mapPos(c.to, -1);
          u < h && a.push({ from: u, to: h });
        }
      }
    }
    return new na(this.parser, n, r, i, s, o, a, this.scheduleOn);
  }
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to) return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && ((this.fragments = z5(this.fragments, i, s)), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), (this.parse = null));
  }
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  static getSkippingParser(e) {
    return new (class extends Cg {
      createParse(n, r, i) {
        let s = i[0].from,
          o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = Tc;
            if (l) {
              for (let c of i) l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return (this.parsedPos = o), new ze(Kt.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {},
        };
      }
    })();
  }
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  static get() {
    return Tc;
  }
}
function z5(t, e, n) {
  return is.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class El {
  constructor(e) {
    (this.context = e), (this.tree = e.tree);
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree) return this;
    let n = this.context.changes(e.changes, e.state),
      r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new El(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length),
      r = na.create(e.facet(ao).parser, e, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new El(r);
  }
}
mr.state = zt.define({
  create: El.init,
  update(t, e) {
    for (let n of e.effects) if (n.is(mr.setState)) return n.value;
    return e.startState.facet(ao) != e.state.facet(ao) ? El.init(e.state) : t.apply(e);
  },
});
let n8 = (t) => {
  let e = setTimeout(() => t(), 500);
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" &&
  (n8 = (t) => {
    let e = -1,
      n = setTimeout(() => {
        e = requestIdleCallback(t, { timeout: 500 - 100 });
      }, 100);
    return () => (e < 0 ? clearTimeout(n) : cancelIdleCallback(e));
  });
const J0 =
    typeof navigator < "u" && !((G0 = navigator.scheduling) === null || G0 === void 0) && G0.isInputPending
      ? () => navigator.scheduling.isInputPending()
      : null,
  Qoe = Dt.fromClass(
    class {
      constructor(e) {
        (this.view = e),
          (this.working = null),
          (this.workScheduled = 0),
          (this.chunkEnd = -1),
          (this.chunkBudget = -1),
          (this.work = this.work.bind(this)),
          this.scheduleWork();
      }
      update(e) {
        let n = this.view.state.field(mr.state).context;
        (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(),
          (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()),
          this.checkAsyncSchedule(n);
      }
      scheduleWork() {
        if (this.working) return;
        let { state: e } = this.view,
          n = e.field(mr.state);
        (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = n8(this.work));
      }
      work(e) {
        this.working = null;
        let n = Date.now();
        if (
          (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && ((this.chunkEnd = n + 3e4), (this.chunkBudget = 3e3)),
          this.chunkBudget <= 0)
        )
          return;
        let {
            state: r,
            viewport: { to: i },
          } = this.view,
          s = r.field(mr.state);
        if (s.tree == s.context.tree && s.context.isDone(i + 1e5)) return;
        let o = Date.now() + Math.min(this.chunkBudget, 100, e && !J0 ? Math.max(25, e.timeRemaining() - 5) : 1e9),
          a = s.context.treeLen < i && r.doc.length > i + 1e3,
          l = s.context.work(() => (J0 && J0()) || Date.now() > o, i + (a ? 0 : 1e5));
        (this.chunkBudget -= Date.now() - n),
          (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: mr.setState.of(new El(s.context)) })),
          this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(),
          this.checkAsyncSchedule(s.context);
      }
      checkAsyncSchedule(e) {
        e.scheduleOn &&
          (this.workScheduled++,
          e.scheduleOn
            .then(() => this.scheduleWork())
            .catch((n) => Kn(this.view.state, n))
            .then(() => this.workScheduled--),
          (e.scheduleOn = null));
      }
      destroy() {
        this.working && this.working();
      }
      isWorking() {
        return !!(this.working || this.workScheduled > 0);
      }
    },
    {
      eventHandlers: {
        focus() {
          this.scheduleWork();
        },
      },
    }
  ),
  ao = ye.define({
    combine(t) {
      return t.length ? t[0] : null;
    },
    enables: (t) => [
      mr.state,
      Qoe,
      re.contentAttributes.compute([t], (e) => {
        let n = e.facet(t);
        return n && n.name ? { "data-language": n.name } : {};
      }),
    ],
  });
class Tl {
  constructor(e, n = []) {
    (this.language = e), (this.support = n), (this.extension = [e, n]);
  }
}
class j {
  constructor(e, n, r, i, s, o = void 0) {
    (this.name = e),
      (this.alias = n),
      (this.extensions = r),
      (this.filename = i),
      (this.loadFunc = s),
      (this.support = o),
      (this.loading = null);
  }
  load() {
    return (
      this.loading ||
      (this.loading = this.loadFunc().then(
        (e) => (this.support = e),
        (e) => {
          throw ((this.loading = null), e);
        }
      ))
    );
  }
  static of(e) {
    let { load: n, support: r } = e;
    if (!n) {
      if (!r) throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      n = () => Promise.resolve(r);
    }
    return new j(
      e.name,
      (e.alias || []).concat(e.name).map((i) => i.toLowerCase()),
      e.extensions || [],
      e.filename,
      n,
      r
    );
  }
  static matchFilename(e, n) {
    for (let i of e) if (i.filename && i.filename.test(n)) return i;
    let r = /\.([^.]+)$/.exec(n);
    if (r) {
      for (let i of e) if (i.extensions.indexOf(r[1]) > -1) return i;
    }
    return null;
  }
  static matchLanguageName(e, n, r = !0) {
    n = n.toLowerCase();
    for (let i of e) if (i.alias.some((s) => s == n)) return i;
    if (r)
      for (let i of e)
        for (let s of i.alias) {
          let o = n.indexOf(s);
          if (o > -1 && (s.length > 2 || (!/\w/.test(n[o - 1]) && !/\w/.test(n[o + s.length])))) return i;
        }
    return null;
  }
}
const r8 = ye.define(),
  sf = ye.define({
    combine: (t) => {
      if (!t.length) return "  ";
      let e = t[0];
      if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0])) throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
      return e;
    },
  });
function ra(t) {
  let e = t.facet(sf);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function Yu(t, e) {
  let n = "",
    r = t.tabSize,
    i = t.facet(sf)[0];
  if (i == "	") {
    for (; e >= r; ) (n += "	"), (e -= r);
    i = " ";
  }
  for (let s = 0; s < e; s++) n += i;
  return n;
}
function Fw(t, e) {
  t instanceof Qe && (t = new Eg(t));
  for (let r of t.state.facet(r8)) {
    let i = r(t, e);
    if (i !== void 0) return i;
  }
  let n = pt(t.state);
  return n.length >= e ? Foe(t, n, e) : null;
}
class Eg {
  constructor(e, n = {}) {
    (this.state = e), (this.options = n), (this.unit = ra(e));
  }
  lineAt(e, n = 1) {
    let r = this.state.doc.lineAt(e),
      { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to
      ? s && i == e
        ? { text: "", from: e }
        : (n < 0 ? i < e : i <= e)
        ? { text: r.text.slice(i - r.from), from: i }
        : { text: r.text.slice(0, i - r.from), from: r.from }
      : r;
  }
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak) return "";
    let { text: r, from: i } = this.lineAt(e, n);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  column(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n),
      s = this.countColumn(r, e - i),
      o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  countColumn(e, n = e.length) {
    return Kr(e, this.state.tabSize, n);
  }
  lineIndent(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n),
      s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1) return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const of = new Ie();
function Foe(t, e, n) {
  let r = e.resolveStack(n),
    i = r.node.enterUnfinishedNodesBefore(n);
  if (i != r.node) {
    let s = [];
    for (let o = i; o != r.node; o = o.parent) s.push(o);
    for (let o = s.length - 1; o >= 0; o--) r = { node: s[o], next: r };
  }
  return i8(r, t, n);
}
function i8(t, e, n) {
  for (let r = t; r; r = r.next) {
    let i = Boe(r.node);
    if (i) return i(Vw.create(e, n, r));
  }
  return 0;
}
function Voe(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function Boe(t) {
  let e = t.type.prop(of);
  if (e) return e;
  let n = t.firstChild,
    r;
  if (n && (r = n.type.prop(Ie.closedBy))) {
    let i = t.lastChild,
      s = i && r.indexOf(i.name) > -1;
    return (o) => s8(o, !0, 1, void 0, s && !Voe(o) ? i.from : void 0);
  }
  return t.parent == null ? joe : null;
}
function joe() {
  return 0;
}
class Vw extends Eg {
  constructor(e, n, r) {
    super(e.state, e.options), (this.base = e), (this.pos = n), (this.context = r);
  }
  get node() {
    return this.context.node;
  }
  static create(e, n, r) {
    return new Vw(e, n, r);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (;;) {
      let r = e.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; ) r = r.parent;
      if (Zoe(r, e)) break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  continue() {
    return i8(this.context.next, this.base, this.pos);
  }
}
function Zoe(t, e) {
  for (let n = e; n; n = n.parent) if (t == n) return !0;
  return !1;
}
function zoe(t) {
  let e = t.node,
    n = e.childAfter(e.from),
    r = e.lastChild;
  if (!n) return null;
  let i = t.options.simulateBreak,
    s = t.state.doc.lineAt(n.from),
    o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let a = n.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r) return null;
    if (!l.type.isSkipped) return l.from < o ? n : null;
    a = l.to;
  }
}
function Woe({ closing: t, align: e = !0, units: n = 1 }) {
  return (r) => s8(r, e, n, t);
}
function s8(t, e, n, r, i) {
  let s = t.textAfter,
    o = s.match(/^\s*/)[0].length,
    a = (r && s.slice(o, o + r.length) == r) || i == t.pos + o,
    l = e ? zoe(t) : null;
  return l ? (a ? t.column(l.from) : t.column(l.to)) : t.baseIndent + (a ? 0 : t.unit * n);
}
const Uoe = (t) => t.baseIndent;
function Dd({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let r = t && t.test(n.textAfter);
    return n.baseIndent + (r ? 0 : e * n.unit);
  };
}
const Xoe = 200;
function Hoe() {
  return Qe.transactionFilter.of((t) => {
    if (!t.docChanged || (!t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))) return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length) return t;
    let n = t.newDoc,
      { head: r } = t.newSelection.main,
      i = n.lineAt(r);
    if (r > i.from + Xoe) return t;
    let s = n.sliceString(i.from, r);
    if (!e.some((c) => c.test(s))) return t;
    let { state: o } = t,
      a = -1,
      l = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == a) continue;
      a = u.from;
      let h = Fw(o, u.from);
      if (h == null) continue;
      let f = /^\s*/.exec(u.text)[0],
        d = Yu(o, h);
      f != d && l.push({ from: u.from, to: u.from + f.length, insert: d });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const o8 = ye.define(),
  oc = new Ie();
function a8(t) {
  let e = t.firstChild,
    n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
function qoe(t, e, n) {
  let r = pt(t);
  if (r.length < n) return null;
  let i = r.resolveStack(n, 1),
    s = null;
  for (let o = i; o; o = o.next) {
    let a = o.node;
    if (a.to <= n || a.from > n) continue;
    if (s && a.from < e) break;
    let l = a.type.prop(oc);
    if (l && (a.to < r.length - 50 || r.length == t.doc.length || !Yoe(a))) {
      let c = l(a, t);
      c && c.from <= n && c.from >= e && c.to > n && (s = c);
    }
  }
  return s;
}
function Yoe(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function zp(t, e, n) {
  for (let r of t.facet(o8)) {
    let i = r(t, e, n);
    if (i) return i;
  }
  return qoe(t, e, n);
}
function l8(t, e) {
  let n = e.mapPos(t.from, 1),
    r = e.mapPos(t.to, -1);
  return n >= r ? void 0 : { from: n, to: r };
}
const Tg = Ae.define({ map: l8 }),
  af = Ae.define({ map: l8 });
function c8(t) {
  let e = [];
  for (let { head: n } of t.state.selection.ranges) e.some((r) => r.from <= n && r.to >= n) || e.push(t.lineBlockAt(n));
  return e;
}
const ia = zt.define({
  create() {
    return ge.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      if (n.is(Tg) && !Goe(t, n.value.from, n.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(Bw),
          i = r ? ge.replace({ widget: new iae(r(e.state, n.value)) }) : W5;
        t = t.update({ add: [i.range(n.value.from, n.value.to)] });
      } else
        n.is(af) &&
          (t = t.update({ filter: (r, i) => n.value.from != r || n.value.to != i, filterFrom: n.value.from, filterTo: n.value.to }));
    if (e.selection) {
      let n = !1,
        { head: r } = e.selection.main;
      t.between(r, r, (i, s) => {
        i < r && s > r && (n = !0);
      }),
        n && (t = t.update({ filterFrom: r, filterTo: r, filter: (i, s) => s <= r || i >= r }));
    }
    return t;
  },
  provide: (t) => re.decorations.from(t),
  toJSON(t, e) {
    let n = [];
    return (
      t.between(0, e.doc.length, (r, i) => {
        n.push(r, i);
      }),
      n
    );
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2) throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t.length; ) {
      let r = t[n++],
        i = t[n++];
      if (typeof r != "number" || typeof i != "number") throw new RangeError("Invalid JSON for fold state");
      e.push(W5.range(r, i));
    }
    return ge.set(e, !0);
  },
});
function Wp(t, e, n) {
  var r;
  let i = null;
  return (
    (r = t.field(ia, !1)) === null ||
      r === void 0 ||
      r.between(e, n, (s, o) => {
        (!i || i.from > s) && (i = { from: s, to: o });
      }),
    i
  );
}
function Goe(t, e, n) {
  let r = !1;
  return (
    t.between(e, e, (i, s) => {
      i == e && s == n && (r = !0);
    }),
    r
  );
}
function u8(t, e) {
  return t.field(ia, !1) ? e : e.concat(Ae.appendConfig.of(f8()));
}
const Joe = (t) => {
    for (let e of c8(t)) {
      let n = zp(t.state, e.from, e.to);
      if (n) return t.dispatch({ effects: u8(t.state, [Tg.of(n), h8(t, n)]) }), !0;
    }
    return !1;
  },
  Koe = (t) => {
    if (!t.state.field(ia, !1)) return !1;
    let e = [];
    for (let n of c8(t)) {
      let r = Wp(t.state, n.from, n.to);
      r && e.push(af.of(r), h8(t, r, !1));
    }
    return e.length && t.dispatch({ effects: e }), e.length > 0;
  };
function h8(t, e, n = !0) {
  let r = t.state.doc.lineAt(e.from).number,
    i = t.state.doc.lineAt(e.to).number;
  return re.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${i}.`);
}
const eae = (t) => {
    let { state: e } = t,
      n = [];
    for (let r = 0; r < e.doc.length; ) {
      let i = t.lineBlockAt(r),
        s = zp(e, i.from, i.to);
      s && n.push(Tg.of(s)), (r = (s ? t.lineBlockAt(s.to) : i).to + 1);
    }
    return n.length && t.dispatch({ effects: u8(t.state, n) }), !!n.length;
  },
  tae = (t) => {
    let e = t.state.field(ia, !1);
    if (!e || !e.size) return !1;
    let n = [];
    return (
      e.between(0, t.state.doc.length, (r, i) => {
        n.push(af.of({ from: r, to: i }));
      }),
      t.dispatch({ effects: n }),
      !0
    );
  },
  nae = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Joe },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Koe },
    { key: "Ctrl-Alt-[", run: eae },
    { key: "Ctrl-Alt-]", run: tae },
  ],
  rae = { placeholderDOM: null, preparePlaceholder: null, placeholderText: "…" },
  Bw = ye.define({
    combine(t) {
      return Vi(t, rae);
    },
  });
function f8(t) {
  let e = [ia, aae];
  return t && e.push(Bw.of(t)), e;
}
function d8(t, e) {
  let { state: n } = t,
    r = n.facet(Bw),
    i = (o) => {
      let a = t.lineBlockAt(t.posAtDOM(o.target)),
        l = Wp(t.state, a.from, a.to);
      l && t.dispatch({ effects: af.of(l) }), o.preventDefault();
    };
  if (r.placeholderDOM) return r.placeholderDOM(t, i, e);
  let s = document.createElement("span");
  return (
    (s.textContent = r.placeholderText),
    s.setAttribute("aria-label", n.phrase("folded code")),
    (s.title = n.phrase("unfold")),
    (s.className = "cm-foldPlaceholder"),
    (s.onclick = i),
    s
  );
}
const W5 = ge.replace({
  widget: new (class extends li {
    toDOM(t) {
      return d8(t, null);
    }
  })(),
});
class iae extends li {
  constructor(e) {
    super(), (this.value = e);
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return d8(e, this.value);
  }
}
const sae = { openText: "⌄", closedText: "›", markerDOM: null, domEventHandlers: {}, foldingChanged: () => !1 };
class K0 extends Li {
  constructor(e, n) {
    super(), (this.config = e), (this.open = n);
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return (
      (n.textContent = this.open ? this.config.openText : this.config.closedText),
      (n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line")),
      n
    );
  }
}
function oae(t = {}) {
  let e = Object.assign(Object.assign({}, sae), t),
    n = new K0(e, !0),
    r = new K0(e, !1),
    i = Dt.fromClass(
      class {
        constructor(o) {
          (this.from = o.viewport.from), (this.markers = this.buildMarkers(o));
        }
        update(o) {
          (o.docChanged ||
            o.viewportChanged ||
            o.startState.facet(ao) != o.state.facet(ao) ||
            o.startState.field(ia, !1) != o.state.field(ia, !1) ||
            pt(o.startState) != pt(o.state) ||
            e.foldingChanged(o)) &&
            (this.markers = this.buildMarkers(o.view));
        }
        buildMarkers(o) {
          let a = new Or();
          for (let l of o.viewportLineBlocks) {
            let c = Wp(o.state, l.from, l.to) ? r : zp(o.state, l.from, l.to) ? n : null;
            c && a.add(l.from, l.from, c);
          }
          return a.finish();
        }
      }
    ),
    { domEventHandlers: s } = e;
  return [
    i,
    z4({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || Xe.empty;
      },
      initialSpacer() {
        return new K0(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), {
        click: (o, a, l) => {
          if (s.click && s.click(o, a, l)) return !0;
          let c = Wp(o.state, a.from, a.to);
          if (c) return o.dispatch({ effects: af.of(c) }), !0;
          let u = zp(o.state, a.from, a.to);
          return u ? (o.dispatch({ effects: Tg.of(u) }), !0) : !1;
        },
      }),
    }),
    f8(),
  ];
}
const aae = re.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer",
  },
  ".cm-foldGutter span": { padding: "0 1px", cursor: "pointer" },
});
class ac {
  constructor(e, n) {
    this.specs = e;
    let r;
    function i(a) {
      let l = ds.newName();
      return ((r || (r = Object.create(null)))["." + l] = a), l;
    }
    const s = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0,
      o = n.scope;
    (this.scope = o instanceof mr ? (a) => a.prop(js) == o.data : o ? (a) => a == o : void 0),
      (this.style = e8(
        e.map((a) => ({ tag: a.tag, class: a.class || i(Object.assign({}, a, { tag: null })) })),
        { all: s }
      ).style),
      (this.module = r ? new ds(r) : null),
      (this.themeType = n.themeType);
  }
  static define(e, n) {
    return new ac(e, n || {});
  }
}
const Gv = ye.define(),
  p8 = ye.define({
    combine(t) {
      return t.length ? [t[0]] : null;
    },
  });
function e1(t) {
  let e = t.facet(Gv);
  return e.length ? e : t.facet(p8);
}
function jw(t, e) {
  let n = [cae],
    r;
  return (
    t instanceof ac && (t.module && n.push(re.styleModule.of(t.module)), (r = t.themeType)),
    e != null && e.fallback
      ? n.push(p8.of(t))
      : r
      ? n.push(Gv.computeN([re.darkTheme], (i) => (i.facet(re.darkTheme) == (r == "dark") ? [t] : [])))
      : n.push(Gv.of(t)),
    n
  );
}
class lae {
  constructor(e) {
    (this.markCache = Object.create(null)),
      (this.tree = pt(e.state)),
      (this.decorations = this.buildDeco(e, e1(e.state))),
      (this.decoratedTo = e.viewport.to);
  }
  update(e) {
    let n = pt(e.state),
      r = e1(e.state),
      i = r != e1(e.startState),
      { viewport: s } = e.view,
      o = e.changes.mapPos(this.decoratedTo, 1);
    n.length < s.to && !i && n.type == this.tree.type && o >= s.to
      ? ((this.decorations = this.decorations.map(e.changes)), (this.decoratedTo = o))
      : (n != this.tree || e.viewportChanged || i) &&
        ((this.tree = n), (this.decorations = this.buildDeco(e.view, r)), (this.decoratedTo = s.to));
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length) return ge.none;
    let r = new Or();
    for (let { from: i, to: s } of e.visibleRanges)
      t8(
        this.tree,
        n,
        (o, a, l) => {
          r.add(o, a, this.markCache[l] || (this.markCache[l] = ge.mark({ class: l })));
        },
        i,
        s
      );
    return r.finish();
  }
}
const cae = ai.high(Dt.fromClass(lae, { decorations: (t) => t.decorations })),
  uae = ac.define([
    { tag: R.meta, color: "#404740" },
    { tag: R.link, textDecoration: "underline" },
    { tag: R.heading, textDecoration: "underline", fontWeight: "bold" },
    { tag: R.emphasis, fontStyle: "italic" },
    { tag: R.strong, fontWeight: "bold" },
    { tag: R.strikethrough, textDecoration: "line-through" },
    { tag: R.keyword, color: "#708" },
    { tag: [R.atom, R.bool, R.url, R.contentSeparator, R.labelName], color: "#219" },
    { tag: [R.literal, R.inserted], color: "#164" },
    { tag: [R.string, R.deleted], color: "#a11" },
    { tag: [R.regexp, R.escape, R.special(R.string)], color: "#e40" },
    { tag: R.definition(R.variableName), color: "#00f" },
    { tag: R.local(R.variableName), color: "#30a" },
    { tag: [R.typeName, R.namespace], color: "#085" },
    { tag: R.className, color: "#167" },
    { tag: [R.special(R.variableName), R.macroName], color: "#256" },
    { tag: R.definition(R.propertyName), color: "#00c" },
    { tag: R.comment, color: "#940" },
    { tag: R.invalid, color: "#f00" },
  ]),
  hae = re.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" },
  }),
  m8 = 1e4,
  g8 = "()[]{}",
  O8 = ye.define({
    combine(t) {
      return Vi(t, { afterCursor: !0, brackets: g8, maxScanDistance: m8, renderMatch: pae });
    },
  }),
  fae = ge.mark({ class: "cm-matchingBracket" }),
  dae = ge.mark({ class: "cm-nonmatchingBracket" });
function pae(t) {
  let e = [],
    n = t.matched ? fae : dae;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const mae = zt.define({
    create() {
      return ge.none;
    },
    update(t, e) {
      if (!e.docChanged && !e.selection) return t;
      let n = [],
        r = e.state.facet(O8);
      for (let i of e.state.selection.ranges) {
        if (!i.empty) continue;
        let s =
          _i(e.state, i.head, -1, r) ||
          (i.head > 0 && _i(e.state, i.head - 1, 1, r)) ||
          (r.afterCursor && (_i(e.state, i.head, 1, r) || (i.head < e.state.doc.length && _i(e.state, i.head + 1, -1, r))));
        s && (n = n.concat(r.renderMatch(s, e.state)));
      }
      return ge.set(n, !0);
    },
    provide: (t) => re.decorations.from(t),
  }),
  gae = [mae, hae];
function v8(t = {}) {
  return [O8.of(t), gae];
}
const x8 = new Ie();
function Jv(t, e, n) {
  let r = t.prop(e < 0 ? Ie.openedBy : Ie.closedBy);
  if (r) return r;
  if (t.name.length == 1) {
    let i = n.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0)) return [n[i + e]];
  }
  return null;
}
function Kv(t) {
  let e = t.type.prop(x8);
  return e ? e(t.node) : t;
}
function _i(t, e, n, r = {}) {
  let i = r.maxScanDistance || m8,
    s = r.brackets || g8,
    o = pt(t),
    a = o.resolveInner(e, n);
  for (let l = a; l; l = l.parent) {
    let c = Jv(l.type, n, s);
    if (c && l.from < l.to) {
      let u = Kv(l);
      if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to)) return Oae(t, e, n, l, u, c, s);
    }
  }
  return vae(t, e, n, o, a.type, i, s);
}
function Oae(t, e, n, r, i, s, o) {
  let a = r.parent,
    l = { from: i.from, to: i.to },
    c = 0,
    u = a == null ? void 0 : a.cursor();
  if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (n < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = Kv(u);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (Jv(u.type, n, o)) c++;
        else if (Jv(u.type, -n, o)) {
          if (c == 0) {
            let h = Kv(u);
            return { start: l, end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0, matched: !1 };
          }
          c--;
        }
      }
    while (n < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function vae(t, e, n, r, i, s, o) {
  let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1),
    l = o.indexOf(a);
  if (l < 0 || (l % 2 == 0) != n > 0) return null;
  let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e },
    u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0),
    h = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let d = u.value;
    n < 0 && (f += d.length);
    let p = e + f * n;
    for (let m = n > 0 ? 0 : d.length - 1, O = n > 0 ? d.length : -1; m != O; m += n) {
      let v = o.indexOf(d[m]);
      if (!(v < 0 || r.resolveInner(p + m, 1).type != i))
        if ((v % 2 == 0) == n > 0) h++;
        else {
          if (h == 1) return { start: c, end: { from: p + m, to: p + m + 1 }, matched: v >> 1 == l >> 1 };
          h--;
        }
    }
    n > 0 && (f += d.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function U5(t, e, n, r = 0, i = 0) {
  e == null && ((e = t.search(/[^\s\u00a0]/)), e == -1 && (e = t.length));
  let s = i;
  for (let o = r; o < e; o++) t.charCodeAt(o) == 9 ? (s += n - (s % n)) : s++;
  return s;
}
class b8 {
  constructor(e, n, r, i) {
    (this.string = e),
      (this.tabSize = n),
      (this.indentUnit = r),
      (this.overrideIndent = i),
      (this.pos = 0),
      (this.start = 0),
      (this.lastColumnPos = 0),
      (this.lastColumnValue = 0);
  }
  eol() {
    return this.pos >= this.string.length;
  }
  sol() {
    return this.pos == 0;
  }
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  next() {
    if (this.pos < this.string.length) return this.string.charAt(this.pos++);
  }
  eat(e) {
    let n = this.string.charAt(this.pos),
      r;
    if ((typeof e == "string" ? (r = n == e) : (r = n && (e instanceof RegExp ? e.test(n) : e(n))), r)) return ++this.pos, n;
  }
  eatWhile(e) {
    let n = this.pos;
    for (; this.eat(e); );
    return this.pos > n;
  }
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); ) ++this.pos;
    return this.pos > e;
  }
  skipToEnd() {
    this.pos = this.string.length;
  }
  skipTo(e) {
    let n = this.string.indexOf(e, this.pos);
    if (n > -1) return (this.pos = n), !0;
  }
  backUp(e) {
    this.pos -= e;
  }
  column() {
    return (
      this.lastColumnPos < this.start &&
        ((this.lastColumnValue = U5(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)),
        (this.lastColumnPos = this.start)),
      this.lastColumnValue
    );
  }
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : U5(this.string, null, this.tabSize);
  }
  match(e, n, r) {
    if (typeof e == "string") {
      let i = (o) => (r ? o.toLowerCase() : o),
        s = this.string.substr(this.pos, e.length);
      return i(s) == i(e) ? (n !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let i = this.string.slice(this.pos).match(e);
      return i && i.index > 0 ? null : (i && n !== !1 && (this.pos += i[0].length), i);
    }
  }
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function xae(t) {
  return {
    name: t.name || "",
    token: t.token,
    blankLine: t.blankLine || (() => {}),
    startState: t.startState || (() => !0),
    copyState: t.copyState || bae,
    indent: t.indent || (() => null),
    languageData: t.languageData || {},
    tokenTable: t.tokenTable || Ww,
  };
}
function bae(t) {
  if (typeof t != "object") return t;
  let e = {};
  for (let n in t) {
    let r = t[n];
    e[n] = r instanceof Array ? r.slice() : r;
  }
  return e;
}
const X5 = new WeakMap();
class Zw extends mr {
  constructor(e) {
    let n = _g(e.languageData),
      r = xae(e),
      i,
      s = new (class extends Cg {
        createParse(o, a, l) {
          return new wae(i, o, a, l);
        }
      })();
    super(n, s, [r8.of((o, a) => this.getIndent(o, a))], e.name),
      (this.topNode = Cae(n)),
      (i = this),
      (this.streamParser = r),
      (this.stateAfter = new Ie({ perNode: !0 })),
      (this.tokenTable = e.tokenTable ? new k8(r.tokenTable) : kae);
  }
  static define(e) {
    return new Zw(e);
  }
  getIndent(e, n) {
    let r = pt(e.state),
      i = r.resolve(n);
    for (; i && i.type != this.topNode; ) i = i.parent;
    if (!i) return null;
    let s,
      { overrideIndentation: o } = e.options;
    o && ((s = X5.get(e.state)), s != null && s < n - 1e4 && (s = void 0));
    let a = zw(this, r, 0, i.from, s ?? n),
      l,
      c;
    if ((a ? ((c = a.state), (l = a.pos + 1)) : ((c = this.streamParser.startState(e.unit)), (l = 0)), n - l > 1e4)) return null;
    for (; l < n; ) {
      let h = e.state.doc.lineAt(l),
        f = Math.min(n, h.to);
      if (h.length) {
        let d = o ? o(h.from) : -1,
          p = new b8(h.text, e.state.tabSize, e.unit, d < 0 ? void 0 : d);
        for (; p.pos < f - h.from; ) w8(this.streamParser.token, p, c);
      } else this.streamParser.blankLine(c, e.unit);
      if (f == n) break;
      l = h.to + 1;
    }
    let u = e.lineAt(n);
    return o && s == null && X5.set(e.state, u.from), this.streamParser.indent(c, /^\s*(.*)/.exec(u.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function zw(t, e, n, r, i) {
  let s = n >= r && n + e.length <= i && e.prop(t.stateAfter);
  if (s) return { state: t.streamParser.copyState(s), pos: n + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let a = e.children[o],
      l = n + e.positions[o],
      c = a instanceof ze && l < i && zw(t, a, l, r, i);
    if (c) return c;
  }
  return null;
}
function y8(t, e, n, r, i) {
  if (i && n <= 0 && r >= e.length) return e;
  !i && e.type == t.topNode && (i = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s],
      a = e.children[s],
      l;
    if (o < r && a instanceof ze) {
      if (!(l = y8(t, a, n - o, r - o, i))) break;
      return i ? new ze(e.type, e.children.slice(0, s).concat(l), e.positions.slice(0, s + 1), o + l.length) : l;
    }
  }
  return null;
}
function yae(t, e, n, r) {
  for (let i of e) {
    let s = i.from + (i.openStart ? 25 : 0),
      o = i.to - (i.openEnd ? 25 : 0),
      a = s <= n && o > n && zw(t, i.tree, 0 - i.offset, n, o),
      l;
    if (a && (l = y8(t, i.tree, n + i.offset, a.pos + i.offset, !1))) return { state: a.state, tree: l };
  }
  return { state: t.streamParser.startState(r ? ra(r) : 4), tree: ze.empty };
}
let wae = class {
  constructor(e, n, r, i) {
    (this.lang = e),
      (this.input = n),
      (this.fragments = r),
      (this.ranges = i),
      (this.stoppedAt = null),
      (this.chunks = []),
      (this.chunkPos = []),
      (this.chunk = []),
      (this.chunkReused = void 0),
      (this.rangeIndex = 0),
      (this.to = i[i.length - 1].to);
    let s = na.get(),
      o = i[0].from,
      { state: a, tree: l } = yae(e, r, o, s == null ? void 0 : s.state);
    (this.state = a), (this.parsedPos = this.chunkStart = o + l.length);
    for (let c = 0; c < l.children.length; c++) this.chunks.push(l.children[c]), this.chunkPos.push(l.positions[c]);
    s &&
      this.parsedPos < s.viewport.from - 1e5 &&
      ((this.state = this.lang.streamParser.startState(ra(s.state))),
      s.skipUntilInView(this.parsedPos, s.viewport.from),
      (this.parsedPos = s.viewport.from)),
      this.moveRangeIndex();
  }
  advance() {
    let e = na.get(),
      n = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt),
      r = Math.min(n, this.chunkStart + 2048);
    for (e && (r = Math.min(r, e.viewport.to)); this.parsedPos < r; ) this.parseLine(e);
    return (
      this.chunkStart < this.parsedPos && this.finishChunk(),
      this.parsedPos >= n
        ? this.finish()
        : e && this.parsedPos >= e.viewport.to
        ? (e.skipUntilInView(this.parsedPos, n), this.finish())
        : null
    );
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let n = this.input.chunk(e);
    if (this.input.lineChunks)
      n ==
        `
` && (n = "");
    else {
      let r = n.indexOf(`
`);
      r > -1 && (n = n.slice(0, r));
    }
    return e + n.length <= this.to ? n : n.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos,
      n = this.lineAfter(e),
      r = e + n.length;
    for (let i = this.rangeIndex; ; ) {
      let s = this.ranges[i].to;
      if (s >= r || ((n = n.slice(0, s - (r - n.length))), i++, i == this.ranges.length)) break;
      let o = this.ranges[i].from,
        a = this.lineAfter(o);
      (n += a), (r = o + a.length);
    }
    return { line: n, end: r };
  }
  skipGapsTo(e, n, r) {
    for (;;) {
      let i = this.ranges[this.rangeIndex].to,
        s = e + n;
      if (r > 0 ? i > s : i >= s) break;
      let o = this.ranges[++this.rangeIndex].from;
      n += o - i;
    }
    return n;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; ) this.rangeIndex++;
  }
  emitToken(e, n, r, i, s) {
    if (this.ranges.length > 1) {
      (s = this.skipGapsTo(n, s, 1)), (n += s);
      let o = this.chunk.length;
      (s = this.skipGapsTo(r, s, -1)), (r += s), (i += this.chunk.length - o);
    }
    return this.chunk.push(e, n, r, i), s;
  }
  parseLine(e) {
    let { line: n, end: r } = this.nextLine(),
      i = 0,
      { streamParser: s } = this.lang,
      o = new b8(n, e ? e.state.tabSize : 4, e ? ra(e.state) : 2);
    if (o.eol()) s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let a = w8(s.token, o, this.state);
        if (
          (a && (i = this.emitToken(this.lang.tokenTable.resolve(a), this.parsedPos + o.start, this.parsedPos + o.pos, 4, i)),
          o.start > 1e4)
        )
          break;
      }
    (this.parsedPos = r), this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = ze.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: Sae,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused,
    });
    (e = new ze(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]])),
      this.chunks.push(e),
      this.chunkPos.push(this.chunkStart - this.ranges[0].from),
      (this.chunk = []),
      (this.chunkReused = void 0),
      (this.chunkStart = this.parsedPos);
  }
  finish() {
    return new ze(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
};
function w8(t, e, n) {
  e.start = e.pos;
  for (let r = 0; r < 10; r++) {
    let i = t(e, n);
    if (e.pos > e.start) return i;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const Ww = Object.create(null),
  Gu = [Kt.none],
  Sae = new ic(Gu),
  H5 = [],
  q5 = Object.create(null),
  S8 = Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"],
])
  S8[t] = C8(Ww, e);
class k8 {
  constructor(e) {
    (this.extra = e), (this.table = Object.assign(Object.create(null), S8));
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = C8(this.extra, e)) : 0;
  }
}
const kae = new k8(Ww);
function t1(t, e) {
  H5.indexOf(t) > -1 || (H5.push(t), console.warn(e));
}
function C8(t, e) {
  let n = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = t[c] || R[c];
      u
        ? typeof u == "function"
          ? l.length
            ? (l = l.map(u))
            : t1(c, `Modifier ${c} used at start of tag`)
          : l.length
          ? t1(c, `Tag ${c} used as modifier`)
          : (l = Array.isArray(u) ? u : [u])
        : t1(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l) n.push(c);
  }
  if (!n.length) return 0;
  let r = e.replace(/ /g, "_"),
    i = r + " " + n.map((a) => a.id),
    s = q5[i];
  if (s) return s.id;
  let o = (q5[i] = Kt.define({ id: Gu.length, name: r, props: [sc({ [r]: n })] }));
  return Gu.push(o), o.id;
}
function Cae(t) {
  let e = Kt.define({ id: Gu.length, name: "Document", props: [js.add(() => t)], top: !0 });
  return Gu.push(e), e;
}
Pt.RTL, Pt.LTR;
class Uw {
  constructor(e, n, r, i) {
    (this.state = e), (this.pos = n), (this.explicit = r), (this.view = i), (this.abortListeners = []);
  }
  tokenBefore(e) {
    let n = pt(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; ) n = n.parent;
    return n ? { from: n.from, to: this.pos, text: this.state.sliceDoc(n.from, this.pos), type: n.type } : null;
  }
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos),
      r = Math.max(n.from, this.pos - 250),
      i = n.text.slice(r - n.from, this.pos - n.from),
      s = i.search(E8(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(e, n) {
    e == "abort" && this.abortListeners && this.abortListeners.push(n);
  }
}
function Y5(t) {
  let e = Object.keys(t).join(""),
    n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function _ae(t) {
  let e = Object.create(null),
    n = Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++) n[i[s]] = !0;
  }
  let r = Y5(e) + Y5(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function _8(t) {
  let e = t.map((i) => (typeof i == "string" ? { label: i } : i)),
    [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : _ae(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: n } : null;
  };
}
function Eae(t, e) {
  return (n) => {
    for (let r = pt(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
      if (t.indexOf(r.name) > -1) return null;
      if (r.type.isTop) break;
    }
    return e(n);
  };
}
class G5 {
  constructor(e, n, r, i) {
    (this.completion = e), (this.source = n), (this.match = r), (this.score = i);
  }
}
function Hs(t) {
  return t.selection.main.from;
}
function E8(t, e) {
  var n;
  let { source: r } = t,
    i = e && r[0] != "^",
    s = r[r.length - 1] != "$";
  return !i && !s
    ? t
    : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const Xw = Jr.define();
function Tae(t, e, n, r) {
  let { main: i } = t.selection,
    s = n - i.from,
    o = r - i.from;
  return Object.assign(
    Object.assign(
      {},
      t.changeByRange((a) =>
        a != i && n != r && t.sliceDoc(a.from + s, a.from + o) != t.sliceDoc(n, r)
          ? { range: a }
          : { changes: { from: a.from + s, to: r == i.from ? a.to : a.from + o, insert: e }, range: X.cursor(a.from + s + e.length) }
      )
    ),
    { scrollIntoView: !0, userEvent: "input.complete" }
  );
}
const J5 = new WeakMap();
function Pae(t) {
  if (!Array.isArray(t)) return t;
  let e = J5.get(t);
  return e || J5.set(t, (e = _8(t))), e;
}
const Up = Ae.define(),
  Ju = Ae.define();
class Aae {
  constructor(e) {
    (this.pattern = e),
      (this.chars = []),
      (this.folded = []),
      (this.any = []),
      (this.precise = []),
      (this.byWord = []),
      (this.score = 0),
      (this.matched = []);
    for (let n = 0; n < e.length; ) {
      let r = mn(e, n),
        i = Pr(r);
      this.chars.push(r);
      let s = e.slice(n, n + i),
        o = s.toUpperCase();
      this.folded.push(mn(o == s ? s.toLowerCase() : o, 0)), (n += i);
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return (this.score = e), (this.matched = n), this;
  }
  match(e) {
    if (this.pattern.length == 0) return this.ret(-100, []);
    if (e.length < this.pattern.length) return null;
    let { chars: n, folded: r, any: i, precise: s, byWord: o } = this;
    if (n.length == 1) {
      let g = mn(e, 0),
        x = Pr(g),
        y = x == e.length ? 0 : -100;
      if (g != n[0])
        if (g == r[0]) y += -200;
        else return null;
      return this.ret(y, [0, x]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0) return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = n.length,
      c = 0;
    if (a < 0) {
      for (let g = 0, x = Math.min(e.length, 200); g < x && c < l; ) {
        let y = mn(e, g);
        (y == n[c] || y == r[c]) && (i[c++] = g), (g += Pr(y));
      }
      if (c < l) return null;
    }
    let u = 0,
      h = 0,
      f = !1,
      d = 0,
      p = -1,
      m = -1,
      O = /[a-z]/.test(e),
      v = !0;
    for (let g = 0, x = Math.min(e.length, 200), y = 0; g < x && h < l; ) {
      let S = mn(e, g);
      a < 0 && (u < l && S == n[u] && (s[u++] = g), d < l && (S == n[d] || S == r[d] ? (d == 0 && (p = g), (m = g + 1), d++) : (d = 0)));
      let k,
        b =
          S < 255
            ? (S >= 48 && S <= 57) || (S >= 97 && S <= 122)
              ? 2
              : S >= 65 && S <= 90
              ? 1
              : 0
            : (k = Sw(S)) != k.toLowerCase()
            ? 1
            : k != k.toUpperCase()
            ? 2
            : 0;
      (!g || (b == 1 && O) || (y == 0 && b != 0)) && (n[h] == S || (r[h] == S && (f = !0)) ? (o[h++] = g) : o.length && (v = !1)),
        (y = b),
        (g += Pr(S));
    }
    return h == l && o[0] == 0 && v
      ? this.result(-100 + (f ? -200 : 0), o, e)
      : d == l && p == 0
      ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m])
      : a > -1
      ? this.ret(-700 - e.length, [a, a + this.pattern.length])
      : d == l
      ? this.ret(-200 + -700 - e.length, [p, m])
      : h == l
      ? this.result(-100 + (f ? -200 : 0) + -700 + (v ? 0 : -1100), o, e)
      : n.length == 2
      ? null
      : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, n, r) {
    let i = [],
      s = 0;
    for (let o of n) {
      let a = o + (this.astral ? Pr(mn(r, o)) : 1);
      s && i[s - 1] == o ? (i[s - 1] = a) : ((i[s++] = o), (i[s++] = a));
    }
    return this.ret(e - r.length, i);
  }
}
class $ae {
  constructor(e) {
    (this.pattern = e), (this.matched = []), (this.score = 0), (this.folded = e.toLowerCase());
  }
  match(e) {
    if (e.length < this.pattern.length) return null;
    let n = e.slice(0, this.pattern.length),
      r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : ((this.matched = [0, n.length]), (this.score = r + (e.length == this.pattern.length ? 0 : -100)), this);
  }
}
const vn = ye.define({
  combine(t) {
    return Vi(
      t,
      {
        activateOnTyping: !0,
        activateOnCompletion: () => !1,
        activateOnTypingDelay: 100,
        selectOnOpen: !0,
        override: null,
        closeOnBlur: !0,
        maxRenderedOptions: 100,
        defaultKeymap: !0,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: !1,
        icons: !0,
        addToOptions: [],
        positionInfo: Rae,
        filterStrict: !1,
        compareCompletions: (e, n) => e.label.localeCompare(n.label),
        interactionDelay: 75,
        updateSyncTime: 100,
      },
      {
        defaultKeymap: (e, n) => e && n,
        closeOnBlur: (e, n) => e && n,
        icons: (e, n) => e && n,
        tooltipClass: (e, n) => (r) => K5(e(r), n(r)),
        optionClass: (e, n) => (r) => K5(e(r), n(r)),
        addToOptions: (e, n) => e.concat(n),
        filterStrict: (e, n) => e || n,
      }
    );
  },
});
function K5(t, e) {
  return t ? (e ? t + " " + e : t) : e;
}
function Rae(t, e, n, r, i, s) {
  let o = t.textDirection == Pt.RTL,
    a = o,
    l = !1,
    c = "top",
    u,
    h,
    f = e.left - i.left,
    d = i.right - e.right,
    p = r.right - r.left,
    m = r.bottom - r.top;
  if ((a && f < Math.min(p, d) ? (a = !1) : !a && d < Math.min(p, f) && (a = !0), p <= (a ? f : d)))
    (u = Math.max(i.top, Math.min(n.top, i.bottom - m)) - e.top), (h = Math.min(400, a ? f : d));
  else {
    (l = !0), (h = Math.min(400, (o ? e.right : i.right - e.left) - 30));
    let g = i.bottom - e.bottom;
    g >= m || g > e.top ? (u = n.bottom - e.top) : ((c = "bottom"), (u = e.bottom - n.top));
  }
  let O = (e.bottom - e.top) / s.offsetHeight,
    v = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / O}px; max-width: ${h / v}px`,
    class: "cm-completionInfo-" + (l ? (o ? "left-narrow" : "right-narrow") : a ? "left" : "right"),
  };
}
function Iae(t) {
  let e = t.addToOptions.slice();
  return (
    t.icons &&
      e.push({
        render(n) {
          let r = document.createElement("div");
          return (
            r.classList.add("cm-completionIcon"),
            n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)),
            r.setAttribute("aria-hidden", "true"),
            r
          );
        },
        position: 20,
      }),
    e.push(
      {
        render(n, r, i, s) {
          let o = document.createElement("span");
          o.className = "cm-completionLabel";
          let a = n.displayLabel || n.label,
            l = 0;
          for (let c = 0; c < s.length; ) {
            let u = s[c++],
              h = s[c++];
            u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
            let f = o.appendChild(document.createElement("span"));
            f.appendChild(document.createTextNode(a.slice(u, h))), (f.className = "cm-completionMatchedText"), (l = h);
          }
          return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
        },
        position: 50,
      },
      {
        render(n) {
          if (!n.detail) return null;
          let r = document.createElement("span");
          return (r.className = "cm-completionDetail"), (r.textContent = n.detail), r;
        },
        position: 80,
      }
    ),
    e.sort((n, r) => n.position - r.position).map((n) => n.render)
  );
}
function n1(t, e, n) {
  if (t <= n) return { from: 0, to: t };
  if ((e < 0 && (e = 0), e <= t >> 1)) {
    let i = Math.floor(e / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((t - e) / n);
  return { from: t - (r + 1) * n, to: t - r * n };
}
class Nae {
  constructor(e, n, r) {
    (this.view = e),
      (this.stateField = n),
      (this.applyCompletion = r),
      (this.info = null),
      (this.infoDestroy = null),
      (this.placeInfoReq = { read: () => this.measureInfo(), write: (l) => this.placeInfo(l), key: this }),
      (this.space = null),
      (this.currentClass = "");
    let i = e.state.field(n),
      { options: s, selected: o } = i.open,
      a = e.state.facet(vn);
    (this.optionContent = Iae(a)),
      (this.optionClass = a.optionClass),
      (this.tooltipClass = a.tooltipClass),
      (this.range = n1(s.length, o, a.maxRenderedOptions)),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-tooltip-autocomplete"),
      this.updateTooltipClass(e.state),
      this.dom.addEventListener("mousedown", (l) => {
        let { options: c } = e.state.field(n).open;
        for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
          if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
            this.applyCompletion(e, c[+h[1]]), l.preventDefault();
            return;
          }
      }),
      this.dom.addEventListener("focusout", (l) => {
        let c = e.state.field(this.stateField, !1);
        c && c.tooltip && e.state.facet(vn).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: Ju.of(null) });
      }),
      this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(),
      (this.list = this.dom.appendChild(this.createListBox(e, n, this.range))),
      this.list.addEventListener("scroll", () => {
        this.info && this.view.requestMeasure(this.placeInfoReq);
      });
  }
  update(e) {
    var n;
    let r = e.state.field(this.stateField),
      i = e.startState.field(this.stateField);
    if ((this.updateTooltipClass(e.state), r != i)) {
      let { options: s, selected: o, disabled: a } = r.open;
      (!i.open || i.open.options != s) && ((this.range = n1(s.length, o, e.state.facet(vn).maxRenderedOptions)), this.showOptions(s, r.id)),
        this.updateSel(),
        a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) &&
          this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" ")) r && this.dom.classList.remove(r);
      for (let r of n.split(" ")) r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(e) {
    (this.space = e), this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField),
      n = e.open;
    if (
      (((n.selected > -1 && n.selected < this.range.from) || n.selected >= this.range.to) &&
        ((this.range = n1(n.options.length, n.selected, this.view.state.facet(vn).maxRenderedOptions)), this.showOptions(n.options, e.id)),
      this.updateSelectedOption(n.selected))
    ) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected],
        { info: i } = r;
      if (!i) return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s) return;
      "then" in s
        ? s
            .then((o) => {
              o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
            })
            .catch((o) => Kn(this.view.state, o, "completion info"))
        : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let r = (this.info = document.createElement("div"));
    if (((r.className = "cm-tooltip cm-completionInfo"), e.nodeType != null)) r.appendChild(e), (this.infoDestroy = null);
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), (this.infoDestroy = s || null);
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id
        ? i--
        : i == e
        ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), (n = r))
        : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && Mae(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info) return null;
    let n = this.dom.getBoundingClientRect(),
      r = this.info.getBoundingClientRect(),
      i = e.getBoundingClientRect(),
      s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return i.top > Math.min(s.bottom, n.bottom) - 10 || i.bottom < Math.max(s.top, n.top) + 10
      ? null
      : this.view.state.facet(vn).positionInfo(this.view, n, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info &&
      (e
        ? (e.style && (this.info.style.cssText = e.style), (this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")))
        : (this.info.style.cssText = "top: -1e6px"));
  }
  createListBox(e, n, r) {
    const i = document.createElement("ul");
    (i.id = n),
      i.setAttribute("role", "listbox"),
      i.setAttribute("aria-expanded", "true"),
      i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: a, match: l } = e[o],
        { section: c } = a;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > r.from || r.from == 0))
          if (((s = f), typeof c != "string" && c.header)) i.appendChild(c.header(c));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      (u.id = n + "-" + o), u.setAttribute("role", "option");
      let h = this.optionClass(a);
      h && (u.className = h);
      for (let f of this.optionContent) {
        let d = f(a, this.view.state, this.view, l);
        d && u.appendChild(d);
      }
    }
    return (
      r.from && i.classList.add("cm-completionListIncompleteTop"),
      r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"),
      i
    );
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), (this.info = null));
  }
  destroy() {
    this.destroyInfo();
  }
}
function Lae(t, e) {
  return (n) => new Nae(n, t, e);
}
function Mae(t, e) {
  let n = t.getBoundingClientRect(),
    r = e.getBoundingClientRect(),
    i = n.height / t.offsetHeight;
  r.top < n.top ? (t.scrollTop -= (n.top - r.top) / i) : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
}
function eE(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function Dae(t, e) {
  let n = [],
    r = null,
    i = (c) => {
      n.push(c);
      let { section: u } = c.completion;
      if (u) {
        r || (r = []);
        let h = typeof u == "string" ? u : u.name;
        r.some((f) => f.name == h) || r.push(typeof u == "string" ? { name: h } : u);
      }
    },
    s = e.facet(vn);
  for (let c of t)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === !1) for (let h of c.result.options) i(new G5(h, c.source, u ? u(h) : [], 1e9 - n.length));
      else {
        let h = e.sliceDoc(c.from, c.to),
          f,
          d = s.filterStrict ? new $ae(h) : new Aae(h);
        for (let p of c.result.options)
          if ((f = d.match(p.label))) {
            let m = p.displayLabel ? (u ? u(p, f.matched) : []) : f.matched;
            i(new G5(p, c.source, m, f.score + (p.boost || 0)));
          }
      }
    }
  if (r) {
    let c = Object.create(null),
      u = 0,
      h = (f, d) => {
        var p, m;
        return (
          ((p = f.rank) !== null && p !== void 0 ? p : 1e9) - ((m = d.rank) !== null && m !== void 0 ? m : 1e9) ||
          (f.name < d.name ? -1 : 1)
        );
      };
    for (let f of r.sort(h)) (u -= 1e5), (c[f.name] = u);
    for (let f of n) {
      let { section: d } = f.completion;
      d && (f.score += c[typeof d == "string" ? d : d.name]);
    }
  }
  let o = [],
    a = null,
    l = s.compareCompletions;
  for (let c of n.sort((u, h) => h.score - u.score || l(u.completion, h.completion))) {
    let u = c.completion;
    !a ||
    a.label != u.label ||
    a.detail != u.detail ||
    (a.type != null && u.type != null && a.type != u.type) ||
    a.apply != u.apply ||
    a.boost != u.boost
      ? o.push(c)
      : eE(c.completion) > eE(a) && (o[o.length - 1] = c),
      (a = c.completion);
  }
  return o;
}
class Wa {
  constructor(e, n, r, i, s, o) {
    (this.options = e), (this.attrs = n), (this.tooltip = r), (this.timestamp = i), (this.selected = s), (this.disabled = o);
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length
      ? this
      : new Wa(this.options, tE(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, r, i, s) {
    let o = Dae(e, n);
    if (!o.length) return i && e.some((l) => l.state == 1) ? new Wa(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let a = n.facet(vn).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let l = i.options[i.selected].completion;
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == l) {
          a = c;
          break;
        }
    }
    return new Wa(
      o,
      tE(r, a),
      { pos: e.reduce((l, c) => (c.hasResult() ? Math.min(l, c.from) : l), 1e8), create: Zae, above: s.aboveCursor },
      i ? i.timestamp : Date.now(),
      a,
      !1
    );
  }
  map(e) {
    return new Wa(
      this.options,
      this.attrs,
      Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }),
      this.timestamp,
      this.selected,
      this.disabled
    );
  }
}
class Xp {
  constructor(e, n, r) {
    (this.active = e), (this.id = n), (this.open = r);
  }
  static start() {
    return new Xp(Bae, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e,
      r = n.facet(vn),
      s = (r.override || n.languageDataAt("autocomplete", Hs(n)).map(Pae)).map((a) =>
        (this.active.find((c) => c.source == a) || new dr(a, this.active.some((c) => c.state != 0) ? 1 : 0)).update(e, r)
      );
    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)),
      e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !Qae(s, this.active)
        ? (o = Wa.build(s, n, this.id, o, r))
        : o && o.disabled && !s.some((a) => a.state == 1) && (o = null),
      !o && s.every((a) => a.state != 1) && s.some((a) => a.hasResult()) && (s = s.map((a) => (a.hasResult() ? new dr(a.source, 0) : a)));
    for (let a of e.effects) a.is(A8) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new Xp(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? Fae : Vae;
  }
}
function Qae(t, e) {
  if (t == e) return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < t.length && !t[n].hasResult; ) n++;
    for (; r < e.length && !e[r].hasResult; ) r++;
    let i = n == t.length,
      s = r == e.length;
    if (i || s) return i == s;
    if (t[n++].result != e[r++].result) return !1;
  }
}
const Fae = { "aria-autocomplete": "list" },
  Vae = {};
function tE(t, e) {
  let n = { "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-controls": t };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const Bae = [];
function T8(t, e) {
  if (t.isUserEvent("input.complete")) {
    let r = t.annotation(Xw);
    if (r && e.activateOnCompletion(r)) return 12;
  }
  let n = t.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class dr {
  constructor(e, n, r = -1) {
    (this.source = e), (this.state = n), (this.explicitPos = r);
  }
  hasResult() {
    return !1;
  }
  update(e, n) {
    let r = T8(e, n),
      i = this;
    (r & 8 || (r & 16 && this.touches(e))) && (i = new dr(i.source, 0)),
      r & 4 && i.state == 0 && (i = new dr(this.source, 1)),
      (i = i.updateFor(e, r));
    for (let s of e.effects)
      if (s.is(Up)) i = new dr(i.source, 1, s.value ? Hs(e.state) : -1);
      else if (s.is(Ju)) i = new dr(i.source, 0);
      else if (s.is(P8)) for (let o of s.value) o.source == i.source && (i = o);
    return i;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new dr(this.source, this.state, e.mapPos(this.explicitPos));
  }
  touches(e) {
    return e.changes.touchesRange(Hs(e.state));
  }
}
class ll extends dr {
  constructor(e, n, r, i, s) {
    super(e, 2, n), (this.result = r), (this.from = i), (this.to = s);
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var r;
    if (!(n & 3)) return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let s = e.changes.mapPos(this.from),
      o = e.changes.mapPos(this.to, 1),
      a = Hs(e.state);
    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || !i || (n & 2 && Hs(e.startState) == this.from))
      return new dr(this.source, n & 4 ? 1 : 0);
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
    return jae(i.validFor, e.state, s, o)
      ? new ll(this.source, l, i, s, o)
      : i.update && (i = i.update(i, s, o, new Uw(e.state, a, l >= 0)))
      ? new ll(this.source, l, i, i.from, (r = i.to) !== null && r !== void 0 ? r : Hs(e.state))
      : new dr(this.source, 1, l);
  }
  map(e) {
    return e.empty
      ? this
      : (this.result.map ? this.result.map(this.result, e) : this.result)
      ? new ll(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1))
      : new dr(this.source, 0);
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function jae(t, e, n, r) {
  if (!t) return !1;
  let i = e.sliceDoc(n, r);
  return typeof t == "function" ? t(i, n, r, e) : E8(t, !0).test(i);
}
const P8 = Ae.define({
    map(t, e) {
      return t.map((n) => n.map(e));
    },
  }),
  A8 = Ae.define(),
  Yn = zt.define({
    create() {
      return Xp.start();
    },
    update(t, e) {
      return t.update(e);
    },
    provide: (t) => [Nw.from(t, (e) => e.tooltip), re.contentAttributes.from(t, (e) => e.attrs)],
  });
function Hw(t, e) {
  const n = e.completion.apply || e.completion.label;
  let r = t.state.field(Yn).active.find((i) => i.source == e.source);
  return r instanceof ll
    ? (typeof n == "string"
        ? t.dispatch(Object.assign(Object.assign({}, Tae(t.state, n, r.from, r.to)), { annotations: Xw.of(e.completion) }))
        : n(t, e.completion, r.from, r.to),
      !0)
    : !1;
}
const Zae = Lae(Yn, Hw);
function Yf(t, e = "option") {
  return (n) => {
    let r = n.state.field(Yn, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(vn).interactionDelay) return !1;
    let i = 1,
      s;
    e == "page" &&
      (s = j4(n, r.open.tooltip)) &&
      (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options,
      a = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
    return a < 0 ? (a = e == "page" ? 0 : o - 1) : a >= o && (a = e == "page" ? o - 1 : 0), n.dispatch({ effects: A8.of(a) }), !0;
  };
}
const zae = (t) => {
    let e = t.state.field(Yn, !1);
    return t.state.readOnly ||
      !e ||
      !e.open ||
      e.open.selected < 0 ||
      e.open.disabled ||
      Date.now() - e.open.timestamp < t.state.facet(vn).interactionDelay
      ? !1
      : Hw(t, e.open.options[e.open.selected]);
  },
  Wae = (t) => (t.state.field(Yn, !1) ? (t.dispatch({ effects: Up.of(!0) }), !0) : !1),
  Uae = (t) => {
    let e = t.state.field(Yn, !1);
    return !e || !e.active.some((n) => n.state != 0) ? !1 : (t.dispatch({ effects: Ju.of(null) }), !0);
  };
class Xae {
  constructor(e, n) {
    (this.active = e), (this.context = n), (this.time = Date.now()), (this.updates = []), (this.done = void 0);
  }
}
const Hae = 50,
  qae = 1e3,
  Yae = Dt.fromClass(
    class {
      constructor(t) {
        (this.view = t),
          (this.debounceUpdate = -1),
          (this.running = []),
          (this.debounceAccept = -1),
          (this.pendingStart = !1),
          (this.composing = 0);
        for (let e of t.state.field(Yn).active) e.state == 1 && this.startQuery(e);
      }
      update(t) {
        let e = t.state.field(Yn),
          n = t.state.facet(vn);
        if (!t.selectionSet && !t.docChanged && t.startState.field(Yn) == e) return;
        let r = t.transactions.some((s) => {
          let o = T8(s, n);
          return o & 8 || ((s.selection || s.docChanged) && !(o & 3));
        });
        for (let s = 0; s < this.running.length; s++) {
          let o = this.running[s];
          if (r || (o.updates.length + t.transactions.length > Hae && Date.now() - o.time > qae)) {
            for (let a of o.context.abortListeners)
              try {
                a();
              } catch (l) {
                Kn(this.view.state, l);
              }
            (o.context.abortListeners = null), this.running.splice(s--, 1);
          } else o.updates.push(...t.transactions);
        }
        this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
          t.transactions.some((s) => s.effects.some((o) => o.is(Up))) && (this.pendingStart = !0);
        let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
        if (
          ((this.debounceUpdate = e.active.some((s) => s.state == 1 && !this.running.some((o) => o.active.source == s.source))
            ? setTimeout(() => this.startUpdate(), i)
            : -1),
          this.composing != 0)
        )
          for (let s of t.transactions)
            s.isUserEvent("input.type") ? (this.composing = 2) : this.composing == 2 && s.selection && (this.composing = 3);
      }
      startUpdate() {
        (this.debounceUpdate = -1), (this.pendingStart = !1);
        let { state: t } = this.view,
          e = t.field(Yn);
        for (let n of e.active) n.state == 1 && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
      }
      startQuery(t) {
        let { state: e } = this.view,
          n = Hs(e),
          r = new Uw(e, n, t.explicitPos == n, this.view),
          i = new Xae(t, r);
        this.running.push(i),
          Promise.resolve(t.source(r)).then(
            (s) => {
              i.context.aborted || ((i.done = s || null), this.scheduleAccept());
            },
            (s) => {
              this.view.dispatch({ effects: Ju.of(null) }), Kn(this.view.state, s);
            }
          );
      }
      scheduleAccept() {
        this.running.every((t) => t.done !== void 0)
          ? this.accept()
          : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(vn).updateSyncTime));
      }
      accept() {
        var t;
        this.debounceAccept > -1 && clearTimeout(this.debounceAccept), (this.debounceAccept = -1);
        let e = [],
          n = this.view.state.facet(vn);
        for (let r = 0; r < this.running.length; r++) {
          let i = this.running[r];
          if (i.done === void 0) continue;
          if ((this.running.splice(r--, 1), i.done)) {
            let o = new ll(
              i.active.source,
              i.active.explicitPos,
              i.done,
              i.done.from,
              (t = i.done.to) !== null && t !== void 0 ? t : Hs(i.updates.length ? i.updates[0].startState : this.view.state)
            );
            for (let a of i.updates) o = o.update(a, n);
            if (o.hasResult()) {
              e.push(o);
              continue;
            }
          }
          let s = this.view.state.field(Yn).active.find((o) => o.source == i.active.source);
          if (s && s.state == 1)
            if (i.done == null) {
              let o = new dr(i.active.source, 0);
              for (let a of i.updates) o = o.update(a, n);
              o.state != 1 && e.push(o);
            } else this.startQuery(s);
        }
        e.length && this.view.dispatch({ effects: P8.of(e) });
      }
    },
    {
      eventHandlers: {
        blur(t) {
          let e = this.view.state.field(Yn, !1);
          if (e && e.tooltip && this.view.state.facet(vn).closeOnBlur) {
            let n = e.open && j4(this.view, e.open.tooltip);
            (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Ju.of(null) }), 10);
          }
        },
        compositionstart() {
          this.composing = 1;
        },
        compositionend() {
          this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Up.of(!1) }), 20), (this.composing = 0);
        },
      },
    }
  ),
  Gae = typeof navigator == "object" && /Win/.test(navigator.platform),
  Jae = ai.highest(
    re.domEventHandlers({
      keydown(t, e) {
        let n = e.state.field(Yn, !1);
        if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || (t.ctrlKey && !(Gae && t.altKey)) || t.metaKey)
          return !1;
        let r = n.open.options[n.open.selected],
          i = n.active.find((o) => o.source == r.source),
          s = r.completion.commitCharacters || i.result.commitCharacters;
        return s && s.indexOf(t.key) > -1 && Hw(e, r), !1;
      },
    })
  ),
  $8 = re.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": { padding: "1px 3px", lineHeight: 1.2 },
        "& > li": { overflowX: "hidden", textOverflow: "ellipsis", cursor: "pointer" },
        "& > completion-section": { display: "list-item", borderBottom: "1px solid silver", paddingLeft: "0.5em", opacity: 0.7 },
      },
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#17c", color: "white" },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#347", color: "white" },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"···"',
      opacity: 0.5,
      display: "block",
      textAlign: "center",
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: "400px",
      boxSizing: "border-box",
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888",
    },
    ".cm-completionMatchedText": { textDecoration: "underline" },
    ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box",
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "'ƒ'" } },
    ".cm-completionIcon-class": { "&:after": { content: "'○'" } },
    ".cm-completionIcon-interface": { "&:after": { content: "'◌'" } },
    ".cm-completionIcon-variable": { "&:after": { content: "'𝑥'" } },
    ".cm-completionIcon-constant": { "&:after": { content: "'𝐶'" } },
    ".cm-completionIcon-type": { "&:after": { content: "'𝑡'" } },
    ".cm-completionIcon-enum": { "&:after": { content: "'∪'" } },
    ".cm-completionIcon-property": { "&:after": { content: "'□'" } },
    ".cm-completionIcon-keyword": { "&:after": { content: "'🔑︎'" } },
    ".cm-completionIcon-namespace": { "&:after": { content: "'▢'" } },
    ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } },
  });
class Kae {
  constructor(e, n, r, i) {
    (this.field = e), (this.line = n), (this.from = r), (this.to = i);
  }
}
class qw {
  constructor(e, n, r) {
    (this.field = e), (this.from = n), (this.to = r);
  }
  map(e) {
    let n = e.mapPos(this.from, -1, On.TrackDel),
      r = e.mapPos(this.to, 1, On.TrackDel);
    return n == null || r == null ? null : new qw(this.field, n, r);
  }
}
class Yw {
  constructor(e, n) {
    (this.lines = e), (this.fieldPositions = n);
  }
  instantiate(e, n) {
    let r = [],
      i = [n],
      s = e.doc.lineAt(n),
      o = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let c = o,
          u = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < u; h++) c += e.facet(sf);
        i.push(n + c.length - u), (l = c + l.slice(u));
      }
      r.push(l), (n += l.length + 1);
    }
    let a = this.fieldPositions.map((l) => new qw(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(e) {
    let n = [],
      r = [],
      i = [],
      s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; (s = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o)); ) {
        let a = s[1] ? +s[1] : null,
          l = s[2] || s[3] || "",
          c = -1,
          u = l.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < n.length; h++) (a != null ? n[h].seq == a : u && n[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < n.length && (a == null || (n[h].seq != null && n[h].seq < a)); ) h++;
          n.splice(h, 0, { seq: a, name: u }), (c = h);
          for (let f of i) f.field >= c && f.field++;
        }
        i.push(new Kae(c, r.length, s.index, s.index + u.length)), (o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length));
      }
      (o = o.replace(/\\([{}])/g, (a, l, c) => {
        for (let u of i) u.line == r.length && u.from > c && (u.from--, u.to--);
        return l;
      })),
        r.push(o);
    }
    return new Yw(r, i);
  }
}
let ele = ge.widget({
    widget: new (class extends li {
      toDOM() {
        let t = document.createElement("span");
        return (t.className = "cm-snippetFieldPosition"), t;
      }
      ignoreEvent() {
        return !1;
      }
    })(),
  }),
  tle = ge.mark({ class: "cm-snippetField" });
class lc {
  constructor(e, n) {
    (this.ranges = e), (this.active = n), (this.deco = ge.set(e.map((r) => (r.from == r.to ? ele : tle).range(r.from, r.to))));
  }
  map(e) {
    let n = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i) return null;
      n.push(i);
    }
    return new lc(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));
  }
}
const lf = Ae.define({
    map(t, e) {
      return t && t.map(e);
    },
  }),
  nle = Ae.define(),
  Ku = zt.define({
    create() {
      return null;
    },
    update(t, e) {
      for (let n of e.effects) {
        if (n.is(lf)) return n.value;
        if (n.is(nle) && t) return new lc(t.ranges, n.value);
      }
      return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
    },
    provide: (t) => re.decorations.from(t, (e) => (e ? e.deco : ge.none)),
  });
function Gw(t, e) {
  return X.create(t.filter((n) => n.field == e).map((n) => X.range(n.from, n.to)));
}
function rle(t) {
  let e = Yw.parse(t);
  return (n, r, i, s) => {
    let { text: o, ranges: a } = e.instantiate(n.state, i),
      l = {
        changes: { from: i, to: s, insert: ot.of(o) },
        scrollIntoView: !0,
        annotations: r ? [Xw.of(r), Gt.userEvent.of("input.complete")] : void 0,
      };
    if ((a.length && (l.selection = Gw(a, 0)), a.some((c) => c.field > 0))) {
      let c = new lc(a, 0),
        u = (l.effects = [lf.of(c)]);
      n.state.field(Ku, !1) === void 0 && u.push(Ae.appendConfig.of([Ku, lle, cle, $8]));
    }
    n.dispatch(n.state.update(l));
  };
}
function R8(t) {
  return ({ state: e, dispatch: n }) => {
    let r = e.field(Ku, !1);
    if (!r || (t < 0 && r.active == 0)) return !1;
    let i = r.active + t,
      s = t > 0 && !r.ranges.some((o) => o.field == i + t);
    return n(e.update({ selection: Gw(r.ranges, i), effects: lf.of(s ? null : new lc(r.ranges, i)), scrollIntoView: !0 })), !0;
  };
}
const ile = ({ state: t, dispatch: e }) => (t.field(Ku, !1) ? (e(t.update({ effects: lf.of(null) })), !0) : !1),
  sle = R8(1),
  ole = R8(-1),
  ale = [
    { key: "Tab", run: sle, shift: ole },
    { key: "Escape", run: ile },
  ],
  nE = ye.define({
    combine(t) {
      return t.length ? t[0] : ale;
    },
  }),
  lle = ai.highest(ta.compute([nE], (t) => t.facet(nE)));
function Hn(t, e) {
  return Object.assign(Object.assign({}, e), { apply: rle(t) });
}
const cle = re.domEventHandlers({
    mousedown(t, e) {
      let n = e.state.field(Ku, !1),
        r;
      if (!n || (r = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null) return !1;
      let i = n.ranges.find((s) => s.from <= r && s.to >= r);
      return !i || i.field == n.active
        ? !1
        : (e.dispatch({
            selection: Gw(n.ranges, i.field),
            effects: lf.of(n.ranges.some((s) => s.field > i.field) ? new lc(n.ranges, i.field) : null),
            scrollIntoView: !0,
          }),
          !0);
    },
  }),
  eh = { brackets: ["(", "[", "{", "'", '"'], before: ")]}:;>", stringPrefixes: [] },
  Io = Ae.define({
    map(t, e) {
      let n = e.mapPos(t, -1, On.TrackAfter);
      return n ?? void 0;
    },
  }),
  Jw = new (class extends Go {})();
Jw.startSide = 1;
Jw.endSide = -1;
const I8 = zt.define({
  create() {
    return Xe.empty;
  },
  update(t, e) {
    if (((t = t.map(e.changes)), e.selection)) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of e.effects) n.is(Io) && (t = t.update({ add: [Jw.range(n.value, n.value + 1)] }));
    return t;
  },
});
function N8() {
  return [hle, I8];
}
const r1 = "()[]{}<>";
function L8(t) {
  for (let e = 0; e < r1.length; e += 2) if (r1.charCodeAt(e) == t) return r1.charAt(e + 1);
  return Sw(t < 128 ? t : t + 1);
}
function M8(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || eh;
}
const ule = typeof navigator == "object" && /Android\b/.test(navigator.userAgent),
  hle = re.inputHandler.of((t, e, n, r) => {
    if ((ule ? t.composing : t.compositionStarted) || t.state.readOnly) return !1;
    let i = t.state.selection.main;
    if (r.length > 2 || (r.length == 2 && Pr(mn(r, 0)) == 1) || e != i.from || n != i.to) return !1;
    let s = dle(t.state, r);
    return s ? (t.dispatch(s), !0) : !1;
  }),
  fle = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let r = M8(t, t.selection.main.head).brackets || eh.brackets,
      i = null,
      s = t.changeByRange((o) => {
        if (o.empty) {
          let a = ple(t.doc, o.head);
          for (let l of r)
            if (l == a && Pg(t.doc, o.head) == L8(mn(l, 0)))
              return { changes: { from: o.head - l.length, to: o.head + l.length }, range: X.cursor(o.head - l.length) };
        }
        return { range: (i = o) };
      });
    return i || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
  },
  D8 = [{ key: "Backspace", run: fle }];
function dle(t, e) {
  let n = M8(t, t.selection.main.head),
    r = n.brackets || eh.brackets;
  for (let i of r) {
    let s = L8(mn(i, 0));
    if (e == i) return s == i ? Ole(t, i, r.indexOf(i + i + i) > -1, n) : mle(t, i, s, n.before || eh.before);
    if (e == s && Q8(t, t.selection.main.from)) return gle(t, i, s);
  }
  return null;
}
function Q8(t, e) {
  let n = !1;
  return (
    t.field(I8).between(0, t.doc.length, (r) => {
      r == e && (n = !0);
    }),
    n
  );
}
function Pg(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, Pr(mn(n, 0)));
}
function ple(t, e) {
  let n = t.sliceString(e - 2, e);
  return Pr(mn(n, 0)) == n.length ? n : n.slice(1);
}
function mle(t, e, n, r) {
  let i = null,
    s = t.changeByRange((o) => {
      if (!o.empty)
        return {
          changes: [
            { insert: e, from: o.from },
            { insert: n, from: o.to },
          ],
          effects: Io.of(o.to + e.length),
          range: X.range(o.anchor + e.length, o.head + e.length),
        };
      let a = Pg(t.doc, o.head);
      return !a || /\s/.test(a) || r.indexOf(a) > -1
        ? { changes: { insert: e + n, from: o.head }, effects: Io.of(o.head + e.length), range: X.cursor(o.head + e.length) }
        : { range: (i = o) };
    });
  return i ? null : t.update(s, { scrollIntoView: !0, userEvent: "input.type" });
}
function gle(t, e, n) {
  let r = null,
    i = t.changeByRange((s) =>
      s.empty && Pg(t.doc, s.head) == n
        ? { changes: { from: s.head, to: s.head + n.length, insert: n }, range: X.cursor(s.head + n.length) }
        : (r = { range: s })
    );
  return r ? null : t.update(i, { scrollIntoView: !0, userEvent: "input.type" });
}
function Ole(t, e, n, r) {
  let i = r.stringPrefixes || eh.stringPrefixes,
    s = null,
    o = t.changeByRange((a) => {
      if (!a.empty)
        return {
          changes: [
            { insert: e, from: a.from },
            { insert: e, from: a.to },
          ],
          effects: Io.of(a.to + e.length),
          range: X.range(a.anchor + e.length, a.head + e.length),
        };
      let l = a.head,
        c = Pg(t.doc, l),
        u;
      if (c == e) {
        if (rE(t, l)) return { changes: { insert: e + e, from: l }, effects: Io.of(l + e.length), range: X.cursor(l + e.length) };
        if (Q8(t, l)) {
          let f = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
          return { changes: { from: l, to: l + f.length, insert: f }, range: X.cursor(l + f.length) };
        }
      } else {
        if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = iE(t, l - 2 * e.length, i)) > -1 && rE(t, u))
          return { changes: { insert: e + e + e + e, from: l }, effects: Io.of(l + e.length), range: X.cursor(l + e.length) };
        if (t.charCategorizer(l)(c) != Nt.Word && iE(t, l, i) > -1 && !vle(t, l, e, i))
          return { changes: { insert: e + e, from: l }, effects: Io.of(l + e.length), range: X.cursor(l + e.length) };
      }
      return { range: (s = a) };
    });
  return s ? null : t.update(o, { scrollIntoView: !0, userEvent: "input.type" });
}
function rE(t, e) {
  let n = pt(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function vle(t, e, n, r) {
  let i = pt(t).resolveInner(e, -1),
    s = r.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + s)),
      l = a.indexOf(n);
    if (!l || (l > -1 && r.indexOf(a.slice(0, l)) > -1)) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {
        if (t.sliceDoc(u.to - n.length, u.to) == n) return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c) break;
    i = c;
  }
  return !1;
}
function iE(t, e, n) {
  let r = t.charCategorizer(e);
  if (r(t.sliceDoc(e - 1, e)) != Nt.Word) return e;
  for (let i of n) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && r(t.sliceDoc(s - 1, s)) != Nt.Word) return s;
  }
  return -1;
}
function xle(t = {}) {
  return [Jae, Yn, vn.of(t), Yae, ble, $8];
}
const F8 = [
    { key: "Ctrl-Space", run: Wae },
    { key: "Escape", run: Uae },
    { key: "ArrowDown", run: Yf(!0) },
    { key: "ArrowUp", run: Yf(!1) },
    { key: "PageDown", run: Yf(!0, "page") },
    { key: "PageUp", run: Yf(!1, "page") },
    { key: "Enter", run: zae },
  ],
  ble = ai.highest(ta.computeN([vn], (t) => (t.facet(vn).defaultKeymap ? [F8] : []))),
  yle = (t) => {
    let { state: e } = t,
      n = e.doc.lineAt(e.selection.main.from),
      r = eS(t.state, n.from);
    return r.line ? wle(t) : r.block ? kle(t) : !1;
  };
function Kw(t, e) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly) return !1;
    let i = t(e, n);
    return i ? (r(n.update(i)), !0) : !1;
  };
}
const wle = Kw(Ele, 0),
  Sle = Kw(V8, 0),
  kle = Kw((t, e) => V8(t, e, _le(e)), 0);
function eS(t, e) {
  let n = t.languageDataAt("commentTokens", e);
  return n.length ? n[0] : {};
}
const Pc = 50;
function Cle(t, { open: e, close: n }, r, i) {
  let s = t.sliceDoc(r - Pc, r),
    o = t.sliceDoc(i, i + Pc),
    a = /\s*$/.exec(s)[0].length,
    l = /^\s*/.exec(o)[0].length,
    c = s.length - a;
  if (s.slice(c - e.length, c) == e && o.slice(l, l + n.length) == n)
    return { open: { pos: r - a, margin: a && 1 }, close: { pos: i + l, margin: l && 1 } };
  let u, h;
  i - r <= 2 * Pc ? (u = h = t.sliceDoc(r, i)) : ((u = t.sliceDoc(r, r + Pc)), (h = t.sliceDoc(i - Pc, i)));
  let f = /^\s*/.exec(u)[0].length,
    d = /\s*$/.exec(h)[0].length,
    p = h.length - d - n.length;
  return u.slice(f, f + e.length) == e && h.slice(p, p + n.length) == n
    ? {
        open: { pos: r + f + e.length, margin: /\s/.test(u.charAt(f + e.length)) ? 1 : 0 },
        close: { pos: i - d - n.length, margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0 },
      }
    : null;
}
function _le(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let r = t.doc.lineAt(n.from),
      i = n.to <= r.to ? r : t.doc.lineAt(n.to),
      s = e.length - 1;
    s >= 0 && e[s].to > r.from ? (e[s].to = i.to) : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function V8(t, e, n = e.selection.ranges) {
  let r = n.map((s) => eS(e, s.from).block);
  if (!r.every((s) => s)) return null;
  let i = n.map((s, o) => Cle(e, r[o], s.from, s.to));
  if (t != 2 && !i.every((s) => s))
    return {
      changes: e.changes(
        n.map((s, o) =>
          i[o]
            ? []
            : [
                { from: s.from, insert: r[o].open + " " },
                { from: s.to, insert: " " + r[o].close },
              ]
        )
      ),
    };
  if (t != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, a; o < i.length; o++)
      if ((a = i[o])) {
        let l = r[o],
          { open: c, close: u } = a;
        s.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function Ele(t, e, n = e.selection.ranges) {
  let r = [],
    i = -1;
  for (let { from: s, to: o } of n) {
    let a = r.length,
      l = 1e9,
      c = eS(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (s == o || o > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length,
            d = f == h.length,
            p = h.text.slice(f, f + c.length) == c ? f : -1;
          f < h.text.length && f < l && (l = f), r.push({ line: h, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        u = h.to + 1;
      }
      if (l < 1e9) for (let u = a; u < r.length; u++) r[u].indent < r[u].line.text.length && (r[u].indent = l);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (t != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: c, empty: u, single: h } of r) (h || !u) && s.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: a, token: l } of r)
      if (a >= 0) {
        let c = o.from + a,
          u = c + l.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const ex = Jr.define(),
  Tle = Jr.define(),
  Ple = ye.define(),
  B8 = ye.define({
    combine(t) {
      return Vi(
        t,
        { minDepth: 100, newGroupDelay: 500, joinToEvent: (e, n) => n },
        { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i) }
      );
    },
  }),
  j8 = zt.define({
    create() {
      return Ei.empty;
    },
    update(t, e) {
      let n = e.state.facet(B8),
        r = e.annotation(ex);
      if (r) {
        let l = er.fromTransaction(e, r.selection),
          c = r.side,
          u = c == 0 ? t.undone : t.done;
        return (
          l ? (u = Hp(u, u.length, n.minDepth, l)) : (u = U8(u, e.startState.selection)), new Ei(c == 0 ? r.rest : u, c == 0 ? u : r.rest)
        );
      }
      let i = e.annotation(Tle);
      if (((i == "full" || i == "before") && (t = t.isolate()), e.annotation(Gt.addToHistory) === !1))
        return e.changes.empty ? t : t.addMapping(e.changes.desc);
      let s = er.fromTransaction(e),
        o = e.annotation(Gt.time),
        a = e.annotation(Gt.userEvent);
      return (
        s ? (t = t.addChanges(s, o, a, n, e)) : e.selection && (t = t.addSelection(e.startState.selection, o, a, n.newGroupDelay)),
        (i == "full" || i == "after") && (t = t.isolate()),
        t
      );
    },
    toJSON(t) {
      return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
    },
    fromJSON(t) {
      return new Ei(t.done.map(er.fromJSON), t.undone.map(er.fromJSON));
    },
  });
function Z8(t = {}) {
  return [
    j8,
    B8.of(t),
    re.domEventHandlers({
      beforeinput(e, n) {
        let r = e.inputType == "historyUndo" ? z8 : e.inputType == "historyRedo" ? tx : null;
        return r ? (e.preventDefault(), r(n)) : !1;
      },
    }),
  ];
}
function Ag(t, e) {
  return function ({ state: n, dispatch: r }) {
    if (!e && n.readOnly) return !1;
    let i = n.field(j8, !1);
    if (!i) return !1;
    let s = i.pop(t, n, e);
    return s ? (r(s), !0) : !1;
  };
}
const z8 = Ag(0, !1),
  tx = Ag(1, !1),
  Ale = Ag(0, !0),
  $le = Ag(1, !0);
class er {
  constructor(e, n, r, i, s) {
    (this.changes = e), (this.effects = n), (this.mapped = r), (this.startSelection = i), (this.selectionsAfter = s);
  }
  setSelAfter(e) {
    return new er(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON()),
    };
  }
  static fromJSON(e) {
    return new er(
      e.changes && qt.fromJSON(e.changes),
      [],
      e.mapped && Pi.fromJSON(e.mapped),
      e.startSelection && X.fromJSON(e.startSelection),
      e.selectionsAfter.map(X.fromJSON)
    );
  }
  static fromTransaction(e, n) {
    let r = $r;
    for (let i of e.startState.facet(Ple)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new er(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, $r);
  }
  static selection(e) {
    return new er(void 0, $r, void 0, void 0, e);
  }
}
function Hp(t, e, n, r) {
  let i = e + 1 > n + 20 ? e - n - 1 : 0,
    s = t.slice(i, e);
  return s.push(r), s;
}
function Rle(t, e) {
  let n = [],
    r = !1;
  return (
    t.iterChangedRanges((i, s) => n.push(i, s)),
    e.iterChangedRanges((i, s, o, a) => {
      for (let l = 0; l < n.length; ) {
        let c = n[l++],
          u = n[l++];
        a >= c && o <= u && (r = !0);
      }
    }),
    r
  );
}
function Ile(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
}
function W8(t, e) {
  return t.length ? (e.length ? t.concat(e) : t) : e;
}
const $r = [],
  Nle = 200;
function U8(t, e) {
  if (t.length) {
    let n = t[t.length - 1],
      r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - Nle));
    return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), Hp(t, t.length - 1, 1e9, n.setSelAfter(r)));
  } else return [er.selection([e])];
}
function Lle(t) {
  let e = t[t.length - 1],
    n = t.slice();
  return (n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1))), n;
}
function i1(t, e) {
  if (!t.length) return t;
  let n = t.length,
    r = $r;
  for (; n; ) {
    let i = Mle(t[n - 1], e, r);
    if ((i.changes && !i.changes.empty) || i.effects.length) {
      let s = t.slice(0, n);
      return (s[n - 1] = i), s;
    } else (e = i.mapped), n--, (r = i.selectionsAfter);
  }
  return r.length ? [er.selection(r)] : $r;
}
function Mle(t, e, n) {
  let r = W8(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : $r, n);
  if (!t.changes) return er.selection(r);
  let i = t.changes.map(e),
    s = e.mapDesc(t.changes, !0),
    o = t.mapped ? t.mapped.composeDesc(s) : s;
  return new er(i, Ae.mapEffects(t.effects, e), o, t.startSelection.map(s), r);
}
const Dle = /^(input\.type|delete)($|\.)/;
class Ei {
  constructor(e, n, r = 0, i = void 0) {
    (this.done = e), (this.undone = n), (this.prevTime = r), (this.prevUserEvent = i);
  }
  isolate() {
    return this.prevTime ? new Ei(this.done, this.undone) : this;
  }
  addChanges(e, n, r, i, s) {
    let o = this.done,
      a = o[o.length - 1];
    return (
      a &&
      a.changes &&
      !a.changes.empty &&
      e.changes &&
      (!r || Dle.test(r)) &&
      ((!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(s, Rle(a.changes, e.changes))) ||
        r == "input.type.compose")
        ? (o = Hp(
            o,
            o.length - 1,
            i.minDepth,
            new er(e.changes.compose(a.changes), W8(e.effects, a.effects), a.mapped, a.startSelection, $r)
          ))
        : (o = Hp(o, o.length, i.minDepth, e)),
      new Ei(o, $r, n, r)
    );
  }
  addSelection(e, n, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : $r;
    return s.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && Ile(s[s.length - 1], e)
      ? this
      : new Ei(U8(this.done, e), this.undone, n, r);
  }
  addMapping(e) {
    return new Ei(i1(this.done, e), i1(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0) return null;
    let s = i[i.length - 1],
      o = s.selectionsAfter[0] || n.selection;
    if (r && s.selectionsAfter.length)
      return n.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: ex.of({ side: e, rest: Lle(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0,
      });
    if (s.changes) {
      let a = i.length == 1 ? $r : i.slice(0, i.length - 1);
      return (
        s.mapped && (a = i1(a, s.mapped)),
        n.update({
          changes: s.changes,
          selection: s.startSelection,
          effects: s.effects,
          annotations: ex.of({ side: e, rest: a, selection: o }),
          filter: !1,
          userEvent: e == 0 ? "undo" : "redo",
          scrollIntoView: !0,
        })
      );
    } else return null;
  }
}
Ei.empty = new Ei($r, $r);
const X8 = [
  { key: "Mod-z", run: z8, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: tx, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: tx, preventDefault: !0 },
  { key: "Mod-u", run: Ale, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: $le, preventDefault: !0 },
];
function cc(t, e) {
  return X.create(t.ranges.map(e), t.mainIndex);
}
function Bi(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ci({ state: t, dispatch: e }, n) {
  let r = cc(t.selection, n);
  return r.eq(t.selection, !0) ? !1 : (e(Bi(t, r)), !0);
}
function $g(t, e) {
  return X.cursor(e ? t.to : t.from);
}
function H8(t, e) {
  return ci(t, (n) => (n.empty ? t.moveByChar(n, e) : $g(n, e)));
}
function $n(t) {
  return t.textDirectionAt(t.state.selection.main.head) == Pt.LTR;
}
const q8 = (t) => H8(t, !$n(t)),
  Y8 = (t) => H8(t, $n(t));
function G8(t, e) {
  return ci(t, (n) => (n.empty ? t.moveByGroup(n, e) : $g(n, e)));
}
const Qle = (t) => G8(t, !$n(t)),
  Fle = (t) => G8(t, $n(t));
function Vle(t, e, n) {
  if (e.type.prop(n)) return !0;
  let r = e.to - e.from;
  return (r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to)))) || e.firstChild;
}
function Rg(t, e, n) {
  let r = pt(t).resolveInner(e.head),
    i = n ? Ie.closedBy : Ie.openedBy;
  for (let l = e.head; ; ) {
    let c = n ? r.childAfter(l) : r.childBefore(l);
    if (!c) break;
    Vle(t, c, i) ? (r = c) : (l = n ? c.to : c.from);
  }
  let s = r.type.prop(i),
    o,
    a;
  return (
    s && (o = n ? _i(t, r.from, 1) : _i(t, r.to, -1)) && o.matched ? (a = n ? o.end.to : o.end.from) : (a = n ? r.to : r.from),
    X.cursor(a, n ? -1 : 1)
  );
}
const Ble = (t) => ci(t, (e) => Rg(t.state, e, !$n(t))),
  jle = (t) => ci(t, (e) => Rg(t.state, e, $n(t)));
function J8(t, e) {
  return ci(t, (n) => {
    if (!n.empty) return $g(n, e);
    let r = t.moveVertically(n, e);
    return r.head != n.head ? r : t.moveToLineBoundary(n, e);
  });
}
const K8 = (t) => J8(t, !1),
  eR = (t) => J8(t, !0);
function tR(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2,
    n = 0,
    r = 0,
    i;
  if (e) {
    for (let s of t.state.facet(re.scrollMargins)) {
      let o = s(t);
      o != null && o.top && (n = Math.max(o == null ? void 0 : o.top, n)),
        o != null && o.bottom && (r = Math.max(o == null ? void 0 : o.bottom, r));
    }
    i = t.scrollDOM.clientHeight - n - r;
  } else i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return { marginTop: n, marginBottom: r, selfScroll: e, height: Math.max(t.defaultLineHeight, i - 5) };
}
function nR(t, e) {
  let n = tR(t),
    { state: r } = t,
    i = cc(r.selection, (o) => (o.empty ? t.moveVertically(o, e, n.height) : $g(o, e)));
  if (i.eq(r.selection)) return !1;
  let s;
  if (n.selfScroll) {
    let o = t.coordsAtPos(r.selection.main.head),
      a = t.scrollDOM.getBoundingClientRect(),
      l = a.top + n.marginTop,
      c = a.bottom - n.marginBottom;
    o && o.top > l && o.bottom < c && (s = re.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - l }));
  }
  return t.dispatch(Bi(r, i), { effects: s }), !0;
}
const sE = (t) => nR(t, !1),
  nx = (t) => nR(t, !0);
function vo(t, e, n) {
  let r = t.lineBlockAt(e.head),
    i = t.moveToLineBoundary(e, n);
  if ((i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, !1)), !n && i.head == r.from && r.length)) {
    let s = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = X.cursor(r.from + s));
  }
  return i;
}
const Zle = (t) => ci(t, (e) => vo(t, e, !0)),
  zle = (t) => ci(t, (e) => vo(t, e, !1)),
  Wle = (t) => ci(t, (e) => vo(t, e, !$n(t))),
  Ule = (t) => ci(t, (e) => vo(t, e, $n(t))),
  Xle = (t) => ci(t, (e) => X.cursor(t.lineBlockAt(e.head).from, 1)),
  Hle = (t) => ci(t, (e) => X.cursor(t.lineBlockAt(e.head).to, -1));
function qle(t, e, n) {
  let r = !1,
    i = cc(t.selection, (s) => {
      let o =
        _i(t, s.head, -1) || _i(t, s.head, 1) || (s.head > 0 && _i(t, s.head - 1, 1)) || (s.head < t.doc.length && _i(t, s.head + 1, -1));
      if (!o || !o.end) return s;
      r = !0;
      let a = o.start.from == s.head ? o.end.to : o.end.from;
      return n ? X.range(s.anchor, a) : X.cursor(a);
    });
  return r ? (e(Bi(t, i)), !0) : !1;
}
const Yle = ({ state: t, dispatch: e }) => qle(t, e, !1);
function Qr(t, e) {
  let n = cc(t.state.selection, (r) => {
    let i = e(r);
    return X.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(Bi(t.state, n)), !0);
}
function rR(t, e) {
  return Qr(t, (n) => t.moveByChar(n, e));
}
const iR = (t) => rR(t, !$n(t)),
  sR = (t) => rR(t, $n(t));
function oR(t, e) {
  return Qr(t, (n) => t.moveByGroup(n, e));
}
const Gle = (t) => oR(t, !$n(t)),
  Jle = (t) => oR(t, $n(t)),
  Kle = (t) => Qr(t, (e) => Rg(t.state, e, !$n(t))),
  ece = (t) => Qr(t, (e) => Rg(t.state, e, $n(t)));
function aR(t, e) {
  return Qr(t, (n) => t.moveVertically(n, e));
}
const lR = (t) => aR(t, !1),
  cR = (t) => aR(t, !0);
function uR(t, e) {
  return Qr(t, (n) => t.moveVertically(n, e, tR(t).height));
}
const oE = (t) => uR(t, !1),
  aE = (t) => uR(t, !0),
  tce = (t) => Qr(t, (e) => vo(t, e, !0)),
  nce = (t) => Qr(t, (e) => vo(t, e, !1)),
  rce = (t) => Qr(t, (e) => vo(t, e, !$n(t))),
  ice = (t) => Qr(t, (e) => vo(t, e, $n(t))),
  sce = (t) => Qr(t, (e) => X.cursor(t.lineBlockAt(e.head).from)),
  oce = (t) => Qr(t, (e) => X.cursor(t.lineBlockAt(e.head).to)),
  lE = ({ state: t, dispatch: e }) => (e(Bi(t, { anchor: 0 })), !0),
  cE = ({ state: t, dispatch: e }) => (e(Bi(t, { anchor: t.doc.length })), !0),
  uE = ({ state: t, dispatch: e }) => (e(Bi(t, { anchor: t.selection.main.anchor, head: 0 })), !0),
  hE = ({ state: t, dispatch: e }) => (e(Bi(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0),
  ace = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0),
  lce = ({ state: t, dispatch: e }) => {
    let n = Ig(t).map(({ from: r, to: i }) => X.range(r, Math.min(i + 1, t.doc.length)));
    return e(t.update({ selection: X.create(n), userEvent: "select" })), !0;
  },
  cce = ({ state: t, dispatch: e }) => {
    let n = cc(t.selection, (r) => {
      var i;
      let s = pt(t).resolveStack(r.from, 1);
      for (let o = s; o; o = o.next) {
        let { node: a } = o;
        if (
          ((a.from < r.from && a.to >= r.to) || (a.to > r.to && a.from <= r.from)) &&
          !((i = a.parent) === null || i === void 0) &&
          i.parent
        )
          return X.range(a.to, a.from);
      }
      return r;
    });
    return e(Bi(t, n)), !0;
  },
  uce = ({ state: t, dispatch: e }) => {
    let n = t.selection,
      r = null;
    return (
      n.ranges.length > 1 ? (r = X.create([n.main])) : n.main.empty || (r = X.create([X.cursor(n.main.head)])), r ? (e(Bi(t, r)), !0) : !1
    );
  };
function cf(t, e) {
  if (t.state.readOnly) return !1;
  let n = "delete.selection",
    { state: r } = t,
    i = r.changeByRange((s) => {
      let { from: o, to: a } = s;
      if (o == a) {
        let l = e(s);
        l < o ? ((n = "delete.backward"), (l = Gf(t, l, !1))) : l > o && ((n = "delete.forward"), (l = Gf(t, l, !0))),
          (o = Math.min(o, l)),
          (a = Math.max(a, l));
      } else (o = Gf(t, o, !1)), (a = Gf(t, a, !0));
      return o == a ? { range: s } : { changes: { from: o, to: a }, range: X.cursor(o, o < s.head ? -1 : 1) };
    });
  return i.changes.empty
    ? !1
    : (t.dispatch(
        r.update(i, {
          scrollIntoView: !0,
          userEvent: n,
          effects: n == "delete.selection" ? re.announce.of(r.phrase("Selection deleted")) : void 0,
        })
      ),
      !0);
}
function Gf(t, e, n) {
  if (t instanceof re)
    for (let r of t.state.facet(re.atomicRanges).map((i) => i(t)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = n ? s : i);
      });
  return e;
}
const hR = (t, e, n) =>
    cf(t, (r) => {
      let i = r.from,
        { state: s } = t,
        o = s.doc.lineAt(i),
        a,
        l;
      if (n && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test((a = o.text.slice(0, i - o.from)))) {
        if (a[a.length - 1] == "	") return i - 1;
        let c = Kr(a, s.tabSize),
          u = c % ra(s) || ra(s);
        for (let h = 0; h < u && a[a.length - 1 - h] == " "; h++) i--;
        l = i;
      } else
        (l = xn(o.text, i - o.from, e, e) + o.from),
          l == i && o.number != (e ? s.doc.lines : 1)
            ? (l += e ? 1 : -1)
            : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, i - o.from)) && (l = xn(o.text, l - o.from, !1, !1) + o.from);
      return l;
    }),
  rx = (t) => hR(t, !1, !0),
  fR = (t) => hR(t, !0, !1),
  dR = (t, e) =>
    cf(t, (n) => {
      let r = n.head,
        { state: i } = t,
        s = i.doc.lineAt(r),
        o = i.charCategorizer(r);
      for (let a = null; ; ) {
        if (r == (e ? s.to : s.from)) {
          r == n.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
          break;
        }
        let l = xn(s.text, r - s.from, e) + s.from,
          c = s.text.slice(Math.min(r, l) - s.from, Math.max(r, l) - s.from),
          u = o(c);
        if (a != null && u != a) break;
        (c != " " || r != n.head) && (a = u), (r = l);
      }
      return r;
    }),
  tS = (t) => dR(t, !1),
  hce = (t) => dR(t, !0),
  fce = (t) =>
    cf(t, (e) => {
      let n = t.lineBlockAt(e.head).to;
      return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
    }),
  dce = (t) =>
    cf(t, (e) => {
      let n = t.moveToLineBoundary(e, !1).head;
      return e.head > n ? n : Math.max(0, e.head - 1);
    }),
  pce = (t) =>
    cf(t, (e) => {
      let n = t.moveToLineBoundary(e, !0).head;
      return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
    }),
  mce = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let n = t.changeByRange((r) => ({ changes: { from: r.from, to: r.to, insert: ot.of(["", ""]) }, range: X.cursor(r.from) }));
    return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  },
  gce = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let n = t.changeByRange((r) => {
      if (!r.empty || r.from == 0 || r.from == t.doc.length) return { range: r };
      let i = r.from,
        s = t.doc.lineAt(i),
        o = i == s.from ? i - 1 : xn(s.text, i - s.from, !1) + s.from,
        a = i == s.to ? i + 1 : xn(s.text, i - s.from, !0) + s.from;
      return { changes: { from: o, to: a, insert: t.doc.slice(i, a).append(t.doc.slice(o, i)) }, range: X.cursor(a) };
    });
    return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
  };
function Ig(t) {
  let e = [],
    n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.from),
      s = t.doc.lineAt(r.to);
    if ((!r.empty && r.to == s.from && (s = t.doc.lineAt(r.to - 1)), n >= i.number)) {
      let o = e[e.length - 1];
      (o.to = s.to), o.ranges.push(r);
    } else e.push({ from: i.from, to: s.to, ranges: [r] });
    n = s.number + 1;
  }
  return e;
}
function pR(t, e, n) {
  if (t.readOnly) return !1;
  let r = [],
    i = [];
  for (let s of Ig(t)) {
    if (n ? s.to == t.doc.length : s.from == 0) continue;
    let o = t.doc.lineAt(n ? s.to + 1 : s.from - 1),
      a = o.length + 1;
    if (n) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + t.lineBreak });
      for (let l of s.ranges) i.push(X.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: t.lineBreak + o.text });
      for (let l of s.ranges) i.push(X.range(l.anchor - a, l.head - a));
    }
  }
  return r.length
    ? (e(t.update({ changes: r, scrollIntoView: !0, selection: X.create(i, t.selection.mainIndex), userEvent: "move.line" })), !0)
    : !1;
}
const Oce = ({ state: t, dispatch: e }) => pR(t, e, !1),
  vce = ({ state: t, dispatch: e }) => pR(t, e, !0);
function mR(t, e, n) {
  if (t.readOnly) return !1;
  let r = [];
  for (let i of Ig(t))
    n
      ? r.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak })
      : r.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const xce = ({ state: t, dispatch: e }) => mR(t, e, !1),
  bce = ({ state: t, dispatch: e }) => mR(t, e, !0),
  yce = (t) => {
    if (t.state.readOnly) return !1;
    let { state: e } = t,
      n = e.changes(Ig(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))),
      r = cc(e.selection, (i) => {
        let s;
        if (t.lineWrapping) {
          let o = t.lineBlockAt(i.head),
            a = t.coordsAtPos(i.head, i.assoc || 1);
          a && (s = o.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
        }
        return t.moveVertically(i, !0, s);
      }).map(n);
    return t.dispatch({ changes: n, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
  };
function wce(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1))) return { from: e, to: e };
  let n = pt(t).resolveInner(e),
    r = n.childBefore(e),
    i = n.childAfter(e),
    s;
  return r &&
    i &&
    r.to <= e &&
    i.from >= e &&
    (s = r.type.prop(Ie.closedBy)) &&
    s.indexOf(i.name) > -1 &&
    t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from &&
    !/\S/.test(t.sliceDoc(r.to, i.from))
    ? { from: r.to, to: i.from }
    : null;
}
const Sce = gR(!1),
  kce = gR(!0);
function gR(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly) return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i,
        a = e.doc.lineAt(s),
        l = !t && s == o && wce(e, s);
      t && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new Eg(e, { simulateBreak: s, simulateDoubleBreak: !!l }),
        u = Fw(c, s);
      for (u == null && (u = Kr(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); ) o++;
      l ? ({ from: s, to: o } = l) : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let h = ["", Yu(e, u)];
      return (
        l && h.push(Yu(e, c.lineIndent(a.from, -1))),
        { changes: { from: s, to: o, insert: ot.of(h) }, range: X.cursor(s + 1 + h[1].length) }
      );
    });
    return n(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function nS(t, e) {
  let n = -1;
  return t.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let a = t.doc.lineAt(o);
      a.number > n && (r.empty || r.to > a.from) && (e(a, i, r), (n = a.number)), (o = a.to + 1);
    }
    let s = t.changes(i);
    return { changes: i, range: X.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1)) };
  });
}
const Cce = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let n = Object.create(null),
      r = new Eg(t, {
        overrideIndentation: (s) => {
          let o = n[s];
          return o ?? -1;
        },
      }),
      i = nS(t, (s, o, a) => {
        let l = Fw(r, s.from);
        if (l == null) return;
        /\S/.test(s.text) || (l = 0);
        let c = /^\s*/.exec(s.text)[0],
          u = Yu(t, l);
        (c != u || a.from < s.from + c.length) && ((n[s.from] = l), o.push({ from: s.from, to: s.from + c.length, insert: u }));
      });
    return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
  },
  OR = ({ state: t, dispatch: e }) =>
    t.readOnly
      ? !1
      : (e(
          t.update(
            nS(t, (n, r) => {
              r.push({ from: n.from, insert: t.facet(sf) });
            }),
            { userEvent: "input.indent" }
          )
        ),
        !0),
  vR = ({ state: t, dispatch: e }) =>
    t.readOnly
      ? !1
      : (e(
          t.update(
            nS(t, (n, r) => {
              let i = /^\s*/.exec(n.text)[0];
              if (!i) return;
              let s = Kr(i, t.tabSize),
                o = 0,
                a = Yu(t, Math.max(0, s - ra(t)));
              for (; o < i.length && o < a.length && i.charCodeAt(o) == a.charCodeAt(o); ) o++;
              r.push({ from: n.from + o, to: n.from + i.length, insert: a.slice(o) });
            }),
            { userEvent: "delete.dedent" }
          )
        ),
        !0),
  _ce = (t) => (t.setTabFocusMode(), !0),
  Ece = [
    { key: "Ctrl-b", run: q8, shift: iR, preventDefault: !0 },
    { key: "Ctrl-f", run: Y8, shift: sR },
    { key: "Ctrl-p", run: K8, shift: lR },
    { key: "Ctrl-n", run: eR, shift: cR },
    { key: "Ctrl-a", run: Xle, shift: sce },
    { key: "Ctrl-e", run: Hle, shift: oce },
    { key: "Ctrl-d", run: fR },
    { key: "Ctrl-h", run: rx },
    { key: "Ctrl-k", run: fce },
    { key: "Ctrl-Alt-h", run: tS },
    { key: "Ctrl-o", run: mce },
    { key: "Ctrl-t", run: gce },
    { key: "Ctrl-v", run: nx },
  ],
  Tce = [
    { key: "ArrowLeft", run: q8, shift: iR, preventDefault: !0 },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: Qle, shift: Gle, preventDefault: !0 },
    { mac: "Cmd-ArrowLeft", run: Wle, shift: rce, preventDefault: !0 },
    { key: "ArrowRight", run: Y8, shift: sR, preventDefault: !0 },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: Fle, shift: Jle, preventDefault: !0 },
    { mac: "Cmd-ArrowRight", run: Ule, shift: ice, preventDefault: !0 },
    { key: "ArrowUp", run: K8, shift: lR, preventDefault: !0 },
    { mac: "Cmd-ArrowUp", run: lE, shift: uE },
    { mac: "Ctrl-ArrowUp", run: sE, shift: oE },
    { key: "ArrowDown", run: eR, shift: cR, preventDefault: !0 },
    { mac: "Cmd-ArrowDown", run: cE, shift: hE },
    { mac: "Ctrl-ArrowDown", run: nx, shift: aE },
    { key: "PageUp", run: sE, shift: oE },
    { key: "PageDown", run: nx, shift: aE },
    { key: "Home", run: zle, shift: nce, preventDefault: !0 },
    { key: "Mod-Home", run: lE, shift: uE },
    { key: "End", run: Zle, shift: tce, preventDefault: !0 },
    { key: "Mod-End", run: cE, shift: hE },
    { key: "Enter", run: Sce },
    { key: "Mod-a", run: ace },
    { key: "Backspace", run: rx, shift: rx },
    { key: "Delete", run: fR },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: tS },
    { key: "Mod-Delete", mac: "Alt-Delete", run: hce },
    { mac: "Mod-Backspace", run: dce },
    { mac: "Mod-Delete", run: pce },
  ].concat(Ece.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))),
  xR = [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: Ble, shift: Kle },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: jle, shift: ece },
    { key: "Alt-ArrowUp", run: Oce },
    { key: "Shift-Alt-ArrowUp", run: xce },
    { key: "Alt-ArrowDown", run: vce },
    { key: "Shift-Alt-ArrowDown", run: bce },
    { key: "Escape", run: uce },
    { key: "Mod-Enter", run: kce },
    { key: "Alt-l", mac: "Ctrl-l", run: lce },
    { key: "Mod-i", run: cce, preventDefault: !0 },
    { key: "Mod-[", run: vR },
    { key: "Mod-]", run: OR },
    { key: "Mod-Alt-\\", run: Cce },
    { key: "Shift-Mod-k", run: yce },
    { key: "Shift-Mod-\\", run: Yle },
    { key: "Mod-/", run: yle },
    { key: "Alt-A", run: Sle },
    { key: "Ctrl-m", mac: "Shift-Alt-m", run: _ce },
  ].concat(Tce);
(function () {
  if (typeof window != "object") return;
  if (
    "IntersectionObserver" in window &&
    "IntersectionObserverEntry" in window &&
    "intersectionRatio" in window.IntersectionObserverEntry.prototype
  ) {
    "isIntersecting" in window.IntersectionObserverEntry.prototype ||
      Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get: function () {
          return this.intersectionRatio > 0;
        },
      });
    return;
  }
  var t = window.document,
    e = [],
    n = null,
    r = null;
  function i(g) {
    (this.time = g.time),
      (this.target = g.target),
      (this.rootBounds = d(g.rootBounds)),
      (this.boundingClientRect = d(g.boundingClientRect)),
      (this.intersectionRect = d(g.intersectionRect || f())),
      (this.isIntersecting = !!g.intersectionRect);
    var x = this.boundingClientRect,
      y = x.width * x.height,
      S = this.intersectionRect,
      k = S.width * S.height;
    y ? (this.intersectionRatio = Number((k / y).toFixed(4))) : (this.intersectionRatio = this.isIntersecting ? 1 : 0);
  }
  function s(g, x) {
    var y = x || {};
    if (typeof g != "function") throw new Error("callback must be a function");
    if (y.root && y.root.nodeType != 1) throw new Error("root must be an Element");
    (this._checkForIntersections = a(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT)),
      (this._callback = g),
      (this._observationTargets = []),
      (this._queuedEntries = []),
      (this._rootMarginValues = this._parseRootMargin(y.rootMargin)),
      (this.thresholds = this._initThresholds(y.threshold)),
      (this.root = y.root || null),
      (this.rootMargin = this._rootMarginValues
        .map(function (S) {
          return S.value + S.unit;
        })
        .join(" ")),
      (this._monitoringDocuments = []),
      (this._monitoringUnsubscribes = []);
  }
  (s.prototype.THROTTLE_TIMEOUT = 100),
    (s.prototype.POLL_INTERVAL = null),
    (s.prototype.USE_MUTATION_OBSERVER = !0),
    (s._setupCrossOriginUpdater = function () {
      return (
        n ||
          (n = function (g, x) {
            !g || !x ? (r = f()) : (r = p(g, x)),
              e.forEach(function (y) {
                y._checkForIntersections();
              });
          }),
        n
      );
    }),
    (s._resetCrossOriginUpdater = function () {
      (n = null), (r = null);
    }),
    (s.prototype.observe = function (g) {
      var x = this._observationTargets.some(function (y) {
        return y.element == g;
      });
      if (!x) {
        if (!(g && g.nodeType == 1)) throw new Error("target must be an Element");
        this._registerInstance(),
          this._observationTargets.push({ element: g, entry: null }),
          this._monitorIntersections(g.ownerDocument),
          this._checkForIntersections();
      }
    }),
    (s.prototype.unobserve = function (g) {
      (this._observationTargets = this._observationTargets.filter(function (x) {
        return x.element != g;
      })),
        this._unmonitorIntersections(g.ownerDocument),
        this._observationTargets.length == 0 && this._unregisterInstance();
    }),
    (s.prototype.disconnect = function () {
      (this._observationTargets = []), this._unmonitorAllIntersections(), this._unregisterInstance();
    }),
    (s.prototype.takeRecords = function () {
      var g = this._queuedEntries.slice();
      return (this._queuedEntries = []), g;
    }),
    (s.prototype._initThresholds = function (g) {
      var x = g || [0];
      return (
        Array.isArray(x) || (x = [x]),
        x.sort().filter(function (y, S, k) {
          if (typeof y != "number" || isNaN(y) || y < 0 || y > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
          return y !== k[S - 1];
        })
      );
    }),
    (s.prototype._parseRootMargin = function (g) {
      var x = g || "0px",
        y = x.split(/\s+/).map(function (S) {
          var k = /^(-?\d*\.?\d+)(px|%)$/.exec(S);
          if (!k) throw new Error("rootMargin must be specified in pixels or percent");
          return { value: parseFloat(k[1]), unit: k[2] };
        });
      return (y[1] = y[1] || y[0]), (y[2] = y[2] || y[0]), (y[3] = y[3] || y[1]), y;
    }),
    (s.prototype._monitorIntersections = function (g) {
      var x = g.defaultView;
      if (x && this._monitoringDocuments.indexOf(g) == -1) {
        var y = this._checkForIntersections,
          S = null,
          k = null;
        if (
          (this.POLL_INTERVAL
            ? (S = x.setInterval(y, this.POLL_INTERVAL))
            : (l(x, "resize", y, !0),
              l(g, "scroll", y, !0),
              this.USE_MUTATION_OBSERVER &&
                "MutationObserver" in x &&
                ((k = new x.MutationObserver(y)), k.observe(g, { attributes: !0, childList: !0, characterData: !0, subtree: !0 }))),
          this._monitoringDocuments.push(g),
          this._monitoringUnsubscribes.push(function () {
            var _ = g.defaultView;
            _ && (S && _.clearInterval(S), c(_, "resize", y, !0)), c(g, "scroll", y, !0), k && k.disconnect();
          }),
          g != ((this.root && this.root.ownerDocument) || t))
        ) {
          var b = v(g);
          b && this._monitorIntersections(b.ownerDocument);
        }
      }
    }),
    (s.prototype._unmonitorIntersections = function (g) {
      var x = this._monitoringDocuments.indexOf(g);
      if (x != -1) {
        var y = (this.root && this.root.ownerDocument) || t,
          S = this._observationTargets.some(function (_) {
            var T = _.element.ownerDocument;
            if (T == g) return !0;
            for (; T && T != y; ) {
              var P = v(T);
              if (((T = P && P.ownerDocument), T == g)) return !0;
            }
            return !1;
          });
        if (!S) {
          var k = this._monitoringUnsubscribes[x];
          if ((this._monitoringDocuments.splice(x, 1), this._monitoringUnsubscribes.splice(x, 1), k(), g != y)) {
            var b = v(g);
            b && this._unmonitorIntersections(b.ownerDocument);
          }
        }
      }
    }),
    (s.prototype._unmonitorAllIntersections = function () {
      var g = this._monitoringUnsubscribes.slice(0);
      (this._monitoringDocuments.length = 0), (this._monitoringUnsubscribes.length = 0);
      for (var x = 0; x < g.length; x++) g[x]();
    }),
    (s.prototype._checkForIntersections = function () {
      if (!(!this.root && n && !r)) {
        var g = this._rootIsInDom(),
          x = g ? this._getRootRect() : f();
        this._observationTargets.forEach(function (y) {
          var S = y.element,
            k = h(S),
            b = this._rootContainsTarget(S),
            _ = y.entry,
            T = g && b && this._computeTargetAndRootIntersection(S, k, x),
            P = (y.entry = new i({
              time: o(),
              target: S,
              boundingClientRect: k,
              rootBounds: n && !this.root ? null : x,
              intersectionRect: T,
            }));
          _
            ? g && b
              ? this._hasCrossedThreshold(_, P) && this._queuedEntries.push(P)
              : _ && _.isIntersecting && this._queuedEntries.push(P)
            : this._queuedEntries.push(P);
        }, this),
          this._queuedEntries.length && this._callback(this.takeRecords(), this);
      }
    }),
    (s.prototype._computeTargetAndRootIntersection = function (g, x, y) {
      if (window.getComputedStyle(g).display != "none") {
        for (var S = x, k = O(g), b = !1; !b && k; ) {
          var _ = null,
            T = k.nodeType == 1 ? window.getComputedStyle(k) : {};
          if (T.display == "none") return null;
          if (k == this.root || k.nodeType == 9)
            if (((b = !0), k == this.root || k == t))
              n && !this.root ? (!r || (r.width == 0 && r.height == 0) ? ((k = null), (_ = null), (S = null)) : (_ = r)) : (_ = y);
            else {
              var P = O(k),
                M = P && h(P),
                D = P && this._computeTargetAndRootIntersection(P, M, y);
              M && D ? ((k = P), (_ = p(M, D))) : ((k = null), (S = null));
            }
          else {
            var V = k.ownerDocument;
            k != V.body && k != V.documentElement && T.overflow != "visible" && (_ = h(k));
          }
          if ((_ && (S = u(_, S)), !S)) break;
          k = k && O(k);
        }
        return S;
      }
    }),
    (s.prototype._getRootRect = function () {
      var g;
      if (this.root) g = h(this.root);
      else {
        var x = t.documentElement,
          y = t.body;
        g = {
          top: 0,
          left: 0,
          right: x.clientWidth || y.clientWidth,
          width: x.clientWidth || y.clientWidth,
          bottom: x.clientHeight || y.clientHeight,
          height: x.clientHeight || y.clientHeight,
        };
      }
      return this._expandRectByRootMargin(g);
    }),
    (s.prototype._expandRectByRootMargin = function (g) {
      var x = this._rootMarginValues.map(function (S, k) {
          return S.unit == "px" ? S.value : (S.value * (k % 2 ? g.width : g.height)) / 100;
        }),
        y = { top: g.top - x[0], right: g.right + x[1], bottom: g.bottom + x[2], left: g.left - x[3] };
      return (y.width = y.right - y.left), (y.height = y.bottom - y.top), y;
    }),
    (s.prototype._hasCrossedThreshold = function (g, x) {
      var y = g && g.isIntersecting ? g.intersectionRatio || 0 : -1,
        S = x.isIntersecting ? x.intersectionRatio || 0 : -1;
      if (y !== S)
        for (var k = 0; k < this.thresholds.length; k++) {
          var b = this.thresholds[k];
          if (b == y || b == S || b < y != b < S) return !0;
        }
    }),
    (s.prototype._rootIsInDom = function () {
      return !this.root || m(t, this.root);
    }),
    (s.prototype._rootContainsTarget = function (g) {
      return m(this.root || t, g) && (!this.root || this.root.ownerDocument == g.ownerDocument);
    }),
    (s.prototype._registerInstance = function () {
      e.indexOf(this) < 0 && e.push(this);
    }),
    (s.prototype._unregisterInstance = function () {
      var g = e.indexOf(this);
      g != -1 && e.splice(g, 1);
    });
  function o() {
    return window.performance && performance.now && performance.now();
  }
  function a(g, x) {
    var y = null;
    return function () {
      y ||
        (y = setTimeout(function () {
          g(), (y = null);
        }, x));
    };
  }
  function l(g, x, y, S) {
    typeof g.addEventListener == "function"
      ? g.addEventListener(x, y, S || !1)
      : typeof g.attachEvent == "function" && g.attachEvent("on" + x, y);
  }
  function c(g, x, y, S) {
    typeof g.removeEventListener == "function"
      ? g.removeEventListener(x, y, S || !1)
      : typeof g.detatchEvent == "function" && g.detatchEvent("on" + x, y);
  }
  function u(g, x) {
    var y = Math.max(g.top, x.top),
      S = Math.min(g.bottom, x.bottom),
      k = Math.max(g.left, x.left),
      b = Math.min(g.right, x.right),
      _ = b - k,
      T = S - y;
    return (_ >= 0 && T >= 0 && { top: y, bottom: S, left: k, right: b, width: _, height: T }) || null;
  }
  function h(g) {
    var x;
    try {
      x = g.getBoundingClientRect();
    } catch {}
    return x
      ? ((x.width && x.height) ||
          (x = { top: x.top, right: x.right, bottom: x.bottom, left: x.left, width: x.right - x.left, height: x.bottom - x.top }),
        x)
      : f();
  }
  function f() {
    return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
  }
  function d(g) {
    return !g || "x" in g
      ? g
      : { top: g.top, y: g.top, bottom: g.bottom, left: g.left, x: g.left, right: g.right, width: g.width, height: g.height };
  }
  function p(g, x) {
    var y = x.top - g.top,
      S = x.left - g.left;
    return { top: y, left: S, height: x.height, width: x.width, bottom: y + x.height, right: S + x.width };
  }
  function m(g, x) {
    for (var y = x; y; ) {
      if (y == g) return !0;
      y = O(y);
    }
    return !1;
  }
  function O(g) {
    var x = g.parentNode;
    return g.nodeType == 9 && g != t
      ? v(g)
      : x && x.nodeType == 11 && x.host
      ? x.host
      : x && x.assignedSlot
      ? x.assignedSlot.parentNode
      : x;
  }
  function v(g) {
    try {
      return (g.defaultView && g.defaultView.frameElement) || null;
    } catch {
      return null;
    }
  }
  (window.IntersectionObserver = s), (window.IntersectionObserverEntry = i);
})();
const Pce = C[typeof document < "u" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"],
  Ace = Pce;
function $ce(t, e = {}) {
  const {
      root: n = null,
      pollInterval: r = null,
      useMutationObserver: i = !1,
      rootMargin: s = "0px 0px 0px 0px",
      threshold: o = 0,
      initialIsIntersecting: a = !1,
    } = e,
    [l, c] = w.useState(() => ({
      boundingClientRect: null,
      intersectionRatio: 0,
      intersectionRect: null,
      isIntersecting: a,
      rootBounds: null,
      target: null,
      time: 0,
    })),
    [u, h] = w.useState(() => dE({ root: n, pollInterval: r, useMutationObserver: i, rootMargin: s, threshold: o }));
  return (
    w.useEffect(() => {
      const f = dE({ root: n, pollInterval: r, useMutationObserver: i, rootMargin: s, threshold: o });
      h(f);
    }, [n, s, r, i, JSON.stringify(o)]),
    Ace(() => {
      const f = t && "current" in t ? t.current : t;
      if (!u || !f) return;
      let d = !1;
      u.observer.observe(f);
      const p = (m) => {
        if (!d)
          for (let O = 0; O < m.length; O++) {
            const v = m[O];
            v.target === f && c(v);
          }
      };
      return (
        u.subscribe(p),
        () => {
          (d = !0), u.observer.unobserve(f), u.unsubscribe(p);
        }
      );
    }, [t, u]),
    l
  );
}
function Rce({ root: t = null, pollInterval: e = null, useMutationObserver: n = !1, rootMargin: r = "0px 0px 0px 0px", threshold: i = 0 }) {
  const s = new Set();
  if (typeof IntersectionObserver > "u") return null;
  const o = new IntersectionObserver(
    (a) => {
      for (const l of s) l(a, o);
    },
    { root: t, rootMargin: r, threshold: i }
  );
  return (
    (o.POLL_INTERVAL = e),
    (o.USE_MUTATION_OBSERVER = n),
    {
      observer: o,
      getListeners() {
        return s;
      },
      subscribe: (a) => s.add(a),
      unsubscribe: (a) => s.delete(a),
    }
  );
}
const fE = new Map();
function dE(t) {
  const { root: e, ...n } = t,
    r = JSON.stringify(n);
  let i = fE.get(e);
  return i || ((i = {}), fE.set(e, i)), i[r] ? i[r] : (i[r] = Rce(t));
}
class qp {
  constructor(e, n, r, i, s, o, a, l, c, u = 0, h) {
    (this.p = e),
      (this.stack = n),
      (this.state = r),
      (this.reducePos = i),
      (this.pos = s),
      (this.score = o),
      (this.buffer = a),
      (this.bufferBase = l),
      (this.curContext = c),
      (this.lookAhead = u),
      (this.parent = h);
  }
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(e, n, r = 0) {
    let i = e.parser.context;
    return new qp(e, [], n, r, r, 0, [], 0, i ? new pE(i, i.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), (this.state = e);
  }
  reduce(e) {
    var n;
    let r = e >> 19,
      i = e & 65535,
      { parser: s } = this.p;
    this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
    let o = s.dynamicPrecedence(i);
    if ((o && (this.score += o), r == 0)) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos),
        i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0),
        this.reduceContext(i, this.reducePos);
      return;
    }
    let a = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0),
      l = a ? this.stack[a - 2] : this.p.ranges[0].from,
      c = this.reducePos - l;
    c >= 2e3 &&
      !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) &&
      (l == this.p.lastBigReductionStart
        ? (this.p.bigReductionCount++, (this.p.lastBigReductionSize = c))
        : this.p.lastBigReductionSize < c &&
          ((this.p.bigReductionCount = 1), (this.p.lastBigReductionStart = l), (this.p.lastBigReductionSize = c)));
    let u = a ? this.stack[a - 1] : 0,
      h = this.bufferBase + this.buffer.length - u;
    if (i < s.minRepeatTerm || e & 131072) {
      let f = s.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(i, l, f, h + 4, !0);
    }
    if (e & 262144) this.state = this.stack[a];
    else {
      let f = this.stack[a - 3];
      this.state = s.getGoto(f, i, !0);
    }
    for (; this.stack.length > a; ) this.stack.pop();
    this.reduceContext(i, l);
  }
  storeNode(e, n, r, i = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this,
        a = this.buffer.length;
      if (
        (a == 0 && o.parent && ((a = o.bufferBase - o.parent.bufferBase), (o = o.parent)),
        a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1)
      ) {
        if (n == r) return;
        if (o.buffer[a - 2] >= n) {
          o.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!s || this.pos == r) this.buffer.push(e, n, r, i);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > r; )
          (this.buffer[o] = this.buffer[o - 4]),
            (this.buffer[o + 1] = this.buffer[o - 3]),
            (this.buffer[o + 2] = this.buffer[o - 2]),
            (this.buffer[o + 3] = this.buffer[o - 1]),
            (o -= 4),
            i > 4 && (i -= 4);
      (this.buffer[o] = e), (this.buffer[o + 1] = n), (this.buffer[o + 2] = r), (this.buffer[o + 3] = i);
    }
  }
  shift(e, n, r, i) {
    if (e & 131072) this.pushState(e & 65535, this.pos);
    else if (e & 262144) (this.pos = i), this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
    else {
      let s = e,
        { parser: o } = this.p;
      (i > this.pos || n <= o.maxNode) && ((this.pos = i), o.stateFlag(s, 1) || (this.reducePos = i)),
        this.pushState(s, r),
        this.shiftContext(n, r),
        n <= o.maxNode && this.buffer.push(n, r, i, 4);
    }
  }
  apply(e, n, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, r, i);
  }
  useNode(e, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let i = this.pos;
    (this.reducePos = this.pos = i + e.length),
      this.pushState(n, i),
      this.buffer.push(r, i, this.reducePos, -1),
      this.curContext &&
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  split() {
    let e = this,
      n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; ) n -= 4;
    let r = e.buffer.slice(n),
      i = e.bufferBase + n;
    for (; e && i == e.bufferBase; ) e = e.parent;
    return new qp(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);
  }
  recoverByDelete(e, n) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), (this.pos = this.reducePos = n), (this.score -= 190);
  }
  canShift(e) {
    for (let n = new Ice(this); ; ) {
      let r = this.p.parser.stateSlot(n.state, 4) || this.p.parser.hasAction(n.state, e);
      if (r == 0) return !1;
      if (!(r & 65536)) return !0;
      n.reduce(r);
    }
  }
  recoverByInsert(e) {
    if (this.stack.length >= 300) return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let s = 0, o; s < n.length; s += 2) (o = n[s + 1]) != this.state && this.p.parser.hasAction(o, e) && i.push(n[s], o);
      if (this.stack.length < 120)
        for (let s = 0; i.length < 8 && s < n.length; s += 2) {
          let o = n[s + 1];
          i.some((a, l) => l & 1 && a == o) || i.push(n[s], o);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let s = n[i + 1];
      if (s == this.state) continue;
      let o = this.split();
      o.pushState(s, this.pos),
        o.storeNode(0, o.pos, o.pos, 4, !0),
        o.shiftContext(n[i], this.pos),
        (o.reducePos = this.pos),
        (o.score -= 200),
        r.push(o);
    }
    return r;
  }
  forceReduce() {
    let { parser: e } = this.p,
      n = e.stateSlot(this.state, 5);
    if (!(n & 65536)) return !1;
    if (!e.validAction(this.state, n)) {
      let r = n >> 19,
        i = n & 65535,
        s = this.stack.length - r * 3;
      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null) return !1;
        n = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), (this.score -= 100);
    }
    return (this.reducePos = this.pos), this.reduce(n), !0;
  }
  findForcedReduction() {
    let { parser: e } = this.p,
      n = [],
      r = (i, s) => {
        if (!n.includes(i))
          return (
            n.push(i),
            e.allActions(i, (o) => {
              if (!(o & 393216))
                if (o & 65536) {
                  let a = (o >> 19) - s;
                  if (a > 1) {
                    let l = o & 65535,
                      c = this.stack.length - a * 3;
                    if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0) return (a << 19) | 65536 | l;
                  }
                } else {
                  let a = r(o, s + 1);
                  if (a != null) return a;
                }
            })
          );
      };
    return r(this.state, 0);
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3) return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(this.state, 1)] == 65535 && !e.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), (this.state = this.stack[0]), (this.stack.length = 0);
  }
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length) return !1;
    for (let n = 0; n < this.stack.length; n += 3) if (this.stack[n] != e.stack[n]) return !1;
    return !0;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new pE(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), (this.curContext = n);
    }
  }
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), (this.lookAhead = e));
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class pE {
  constructor(e, n) {
    (this.tracker = e), (this.context = n), (this.hash = e.strict ? e.hash(n) : 0);
  }
}
class Ice {
  constructor(e) {
    (this.start = e), (this.state = e.state), (this.stack = e.stack), (this.base = this.stack.length);
  }
  reduce(e) {
    let n = e & 65535,
      r = e >> 19;
    r == 0
      ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), (this.base += 3))
      : (this.base -= (r - 1) * 3);
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class Yp {
  constructor(e, n, r) {
    (this.stack = e), (this.pos = n), (this.index = r), (this.buffer = e.buffer), this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new Yp(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && ((this.index = this.stack.bufferBase - e.bufferBase), (this.stack = e), (this.buffer = e.buffer));
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    (this.index -= 4), (this.pos -= 4), this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Yp(this.stack, this.pos, this.index);
  }
}
function Uc(t, e = Uint16Array) {
  if (typeof t != "string") return t;
  let n = null;
  for (let r = 0, i = 0; r < t.length; ) {
    let s = 0;
    for (;;) {
      let o = t.charCodeAt(r++),
        a = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if ((l >= 46 && ((l -= 46), (a = !0)), (s += l), a)) break;
      s *= 46;
    }
    n ? (n[i++] = s) : (n = new e(s));
  }
  return n;
}
class Qd {
  constructor() {
    (this.start = -1), (this.value = -1), (this.end = -1), (this.extended = -1), (this.lookAhead = 0), (this.mask = 0), (this.context = 0);
  }
}
const mE = new Qd();
class Nce {
  constructor(e, n) {
    (this.input = e),
      (this.ranges = n),
      (this.chunk = ""),
      (this.chunkOff = 0),
      (this.chunk2 = ""),
      (this.chunk2Pos = 0),
      (this.next = -1),
      (this.token = mE),
      (this.rangeIndex = 0),
      (this.pos = this.chunkPos = n[0].from),
      (this.range = n[0]),
      (this.end = n[n.length - 1].to),
      this.readNext();
  }
  resolveOffset(e, n) {
    let r = this.range,
      i = this.rangeIndex,
      s = this.pos + e;
    for (; s < r.from; ) {
      if (!i) return null;
      let o = this.ranges[--i];
      (s -= r.from - o.to), (r = o);
    }
    for (; n < 0 ? s > r.to : s >= r.to; ) {
      if (i == this.ranges.length - 1) return null;
      let o = this.ranges[++i];
      (s += o.from - r.to), (r = o);
    }
    return s;
  }
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to) return e;
    for (let n of this.ranges) if (n.to > e) return Math.max(e, n.from);
    return this.end;
  }
  peek(e) {
    let n = this.chunkOff + e,
      r,
      i;
    if (n >= 0 && n < this.chunk.length) (r = this.pos + e), (i = this.chunk.charCodeAt(n));
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null) return -1;
      if (((r = s), r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)) i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let o = this.rangeIndex,
          a = this.range;
        for (; a.to <= r; ) a = this.ranges[++o];
        (this.chunk2 = this.input.chunk((this.chunk2Pos = r))),
          r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)),
          (i = this.chunk2.charCodeAt(0));
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  acceptToken(e, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start) throw new RangeError("Token end out of bounds");
    (this.token.value = e), (this.token.end = r);
  }
  acceptTokenTo(e, n) {
    (this.token.value = e), (this.token.end = n);
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      (this.chunk = this.chunk2),
        (this.chunkPos = this.chunk2Pos),
        (this.chunk2 = e),
        (this.chunk2Pos = n),
        (this.chunkOff = this.pos - this.chunkPos);
    } else {
      (this.chunk2 = this.chunk), (this.chunk2Pos = this.chunkPos);
      let e = this.input.chunk(this.pos),
        n = this.pos + e.length;
      (this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e), (this.chunkPos = this.pos), (this.chunkOff = 0);
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length)
      ? (this.next = -1)
      : (this.next = this.chunk.charCodeAt(this.chunkOff));
  }
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
      (e -= this.range.to - this.pos), (this.range = this.ranges[++this.rangeIndex]), (this.pos = this.range.from);
    }
    return (this.pos += e), this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return (
      (this.pos = this.chunkPos = this.end),
      (this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]),
      (this.chunk = ""),
      (this.next = -1)
    );
  }
  reset(e, n) {
    if ((n ? ((this.token = n), (n.start = e), (n.lookAhead = e + 1), (n.value = n.extended = -1)) : (this.token = mE), this.pos != e)) {
      if (((this.pos = e), e == this.end)) return this.setDone(), this;
      for (; e < this.range.from; ) this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; ) this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length
        ? (this.chunkOff = e - this.chunkPos)
        : ((this.chunk = ""), (this.chunkOff = 0)),
        this.readNext();
    }
    return this;
  }
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length) return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to) return this.input.read(e, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n) break;
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, n)));
    }
    return r;
  }
}
class cl {
  constructor(e, n) {
    (this.data = e), (this.id = n);
  }
  token(e, n) {
    let { parser: r } = n.p;
    bR(this.data, e, n, this.id, r.data, r.tokenPrecTable);
  }
}
cl.prototype.contextual = cl.prototype.fallback = cl.prototype.extend = !1;
class Gp {
  constructor(e, n, r) {
    (this.precTable = n), (this.elseToken = r), (this.data = typeof e == "string" ? Uc(e) : e);
  }
  token(e, n) {
    let r = e.pos,
      i = 0;
    for (;;) {
      let s = e.next < 0,
        o = e.resolveOffset(1, 1);
      if ((bR(this.data, e, n, 0, this.data, this.precTable), e.token.value > -1)) break;
      if (this.elseToken == null) return;
      if ((s || i++, o == null)) break;
      e.reset(o, e.token);
    }
    i && (e.reset(r, e.token), e.acceptToken(this.elseToken, i));
  }
}
Gp.prototype.contextual = cl.prototype.fallback = cl.prototype.extend = !1;
class ui {
  constructor(e, n = {}) {
    (this.token = e), (this.contextual = !!n.contextual), (this.fallback = !!n.fallback), (this.extend = !!n.extend);
  }
}
function bR(t, e, n, r, i, s) {
  let o = 0,
    a = 1 << r,
    { dialect: l } = n.p.parser;
  e: for (; a & t[o]; ) {
    let c = t[o + 1];
    for (let d = o + 3; d < c; d += 2)
      if ((t[d + 1] & a) > 0) {
        let p = t[d];
        if (l.allows(p) && (e.token.value == -1 || e.token.value == p || Lce(p, e.token.value, i, s))) {
          e.acceptToken(p);
          break;
        }
      }
    let u = e.next,
      h = 0,
      f = t[o + 2];
    if (e.next < 0 && f > h && t[c + f * 3 - 3] == 65535) {
      o = t[c + f * 3 - 1];
      continue e;
    }
    for (; h < f; ) {
      let d = (h + f) >> 1,
        p = c + d + (d << 1),
        m = t[p],
        O = t[p + 1] || 65536;
      if (u < m) f = d;
      else if (u >= O) h = d + 1;
      else {
        (o = t[p + 2]), e.advance();
        continue e;
      }
    }
    break;
  }
}
function gE(t, e, n) {
  for (let r = e, i; (i = t[r]) != 65535; r++) if (i == n) return r - e;
  return -1;
}
function Lce(t, e, n, r) {
  let i = gE(n, r, e);
  return i < 0 || gE(n, r, t) < i;
}
const ar = typeof process < "u" && process.env && /\bparse\b/.test({}.LOG);
let s1 = null;
function OE(t, e, n) {
  let r = t.cursor(kt.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(n < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (;;) {
        if ((n < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(r.to - 1, e - 25)) : Math.min(t.length, Math.max(r.from + 1, e + 25));
        if (n < 0 ? r.prevSibling() : r.nextSibling()) break;
        if (!r.parent()) return n < 0 ? 0 : t.length;
      }
}
let Mce = class {
  constructor(e, n) {
    (this.fragments = e),
      (this.nodeSet = n),
      (this.i = 0),
      (this.fragment = null),
      (this.safeFrom = -1),
      (this.safeTo = -1),
      (this.trees = []),
      (this.start = []),
      (this.index = []),
      this.nextFragment();
  }
  nextFragment() {
    let e = (this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]);
    if (e) {
      for (
        this.safeFrom = e.openStart ? OE(e.tree, e.from + e.offset, 1) - e.offset : e.from,
          this.safeTo = e.openEnd ? OE(e.tree, e.to + e.offset, -1) - e.offset : e.to;
        this.trees.length;

      )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), (this.nextStart = this.safeFrom);
    } else this.nextStart = 1e9;
  }
  nodeAt(e) {
    if (e < this.nextStart) return null;
    for (; this.fragment && this.safeTo <= e; ) this.nextFragment();
    if (!this.fragment) return null;
    for (;;) {
      let n = this.trees.length - 1;
      if (n < 0) return this.nextFragment(), null;
      let r = this.trees[n],
        i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = r.children[i],
        o = this.start[n] + r.positions[i];
      if (o > e) return (this.nextStart = o), null;
      if (s instanceof ze) {
        if (o == e) {
          if (o < this.safeFrom) return null;
          let a = o + s.length;
          if (a <= this.safeTo) {
            let l = s.prop(Ie.lookAhead);
            if (!l || a + l < this.fragment.to) return s;
          }
        }
        this.index[n]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else this.index[n]++, (this.nextStart = o + s.length);
    }
  }
};
class Dce {
  constructor(e, n) {
    (this.stream = n), (this.tokens = []), (this.mainToken = null), (this.actions = []), (this.tokens = e.tokenizers.map((r) => new Qd()));
  }
  getActions(e) {
    let n = 0,
      r = null,
      { parser: i } = e.p,
      { tokenizers: s } = i,
      o = i.stateSlot(e.state, 3),
      a = e.curContext ? e.curContext.hash : 0,
      l = 0;
    for (let c = 0; c < s.length; c++) {
      if (!((1 << c) & o)) continue;
      let u = s[c],
        h = this.tokens[c];
      if (
        !(r && !u.fallback) &&
        ((u.contextual || h.start != e.pos || h.mask != o || h.context != a) &&
          (this.updateCachedToken(h, u, e), (h.mask = o), (h.context = a)),
        h.lookAhead > h.end + 25 && (l = Math.max(h.lookAhead, l)),
        h.value != 0)
      ) {
        let f = n;
        if (
          (h.extended > -1 && (n = this.addActions(e, h.extended, h.end, n)),
          (n = this.addActions(e, h.value, h.end, n)),
          !u.extend && ((r = h), n > f))
        )
          break;
      }
    }
    for (; this.actions.length > n; ) this.actions.pop();
    return (
      l && e.setLookAhead(l),
      !r &&
        e.pos == this.stream.end &&
        ((r = new Qd()), (r.value = e.p.parser.eofTerm), (r.start = r.end = e.pos), (n = this.addActions(e, r.value, r.end, n))),
      (this.mainToken = r),
      this.actions
    );
  }
  getMainToken(e) {
    if (this.mainToken) return this.mainToken;
    let n = new Qd(),
      { pos: r, p: i } = e;
    return (n.start = r), (n.end = Math.min(r + 1, i.stream.end)), (n.value = r == i.stream.end ? i.parser.eofTerm : 0), n;
  }
  updateCachedToken(e, n, r) {
    let i = this.stream.clipPos(r.pos);
    if ((n.token(this.stream.reset(i, e), r), e.value > -1)) {
      let { parser: s } = r.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let a = s.specializers[o](this.stream.read(e.start, e.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? (e.extended = a >> 1) : (e.value = a >> 1);
            break;
          }
        }
    } else (e.value = 0), (e.end = this.stream.clipPos(i + 1));
  }
  putAction(e, n, r, i) {
    for (let s = 0; s < i; s += 3) if (this.actions[s] == e) return i;
    return (this.actions[i++] = e), (this.actions[i++] = n), (this.actions[i++] = r), i;
  }
  addActions(e, n, r, i) {
    let { state: s } = e,
      { parser: o } = e.p,
      { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(s, l ? 2 : 1); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1) c = Yi(a, c + 2);
          else {
            i == 0 && a[c + 1] == 2 && (i = this.putAction(Yi(a, c + 2), n, r, i));
            break;
          }
        a[c] == n && (i = this.putAction(Yi(a, c + 1), n, r, i));
      }
    return i;
  }
}
class Qce {
  constructor(e, n, r, i) {
    (this.parser = e),
      (this.input = n),
      (this.ranges = i),
      (this.recovering = 0),
      (this.nextStackID = 9812),
      (this.minStackPos = 0),
      (this.reused = []),
      (this.stoppedAt = null),
      (this.lastBigReductionStart = -1),
      (this.lastBigReductionSize = 0),
      (this.bigReductionCount = 0),
      (this.stream = new Nce(n, i)),
      (this.tokens = new Dce(e, this.stream)),
      (this.topTerm = e.top[1]);
    let { from: s } = i[0];
    (this.stacks = [qp.start(this, e.top[0], s)]),
      (this.fragments = r.length && this.stream.end - s > e.bufferLength * 4 ? new Mce(r, e.nodeSet) : null);
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let e = this.stacks,
      n = this.minStackPos,
      r = (this.stacks = []),
      i,
      s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; );
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      for (;;) {
        if (((this.tokens.mainToken = null), a.pos > n)) r.push(a);
        else {
          if (this.advanceStack(a, r, e)) continue;
          {
            i || ((i = []), (s = [])), i.push(a);
            let l = this.tokens.getMainToken(a);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let o = i && Vce(i);
      if (o) return ar && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw (
          (ar &&
            i &&
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")),
          new SyntaxError("No parse at " + n))
        );
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let o = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, r);
      if (o) return ar && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > o) for (r.sort((a, l) => l.score - a.score); r.length > o; ) r.pop();
      r.some((a) => a.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      e: for (let o = 0; o < r.length - 1; o++) {
        let a = r[o];
        for (let l = o + 1; l < r.length; l++) {
          let c = r[l];
          if (a.sameState(c) || (a.buffer.length > 500 && c.buffer.length > 500))
            if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0) r.splice(l--, 1);
            else {
              r.splice(o--, 1);
              continue e;
            }
        }
      }
      r.length > 12 && r.splice(12, r.length - 12);
    }
    this.minStackPos = r[0].pos;
    for (let o = 1; o < r.length; o++) r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  advanceStack(e, n, r) {
    let i = e.pos,
      { parser: s } = this,
      o = ar ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt) return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict,
        u = c ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(i); h; ) {
        let f = this.parser.nodeSet.types[h.type.id] == h.type ? s.getGoto(e.state, h.type.id) : -1;
        if (f > -1 && h.length && (!c || (h.prop(Ie.contextHash) || 0) == u))
          return e.useNode(h, f), ar && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(h.type.id)})`), !0;
        if (!(h instanceof ze) || h.children.length == 0 || h.positions[0] > 0) break;
        let d = h.children[0];
        if (d instanceof ze && h.positions[0] == 0) h = d;
        else break;
      }
    }
    let a = s.stateSlot(e.state, 4);
    if (a > 0) return e.reduce(a), ar && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(a & 65535)})`), !0;
    if (e.stack.length >= 8400) for (; e.stack.length > 6e3 && e.forceReduce(); );
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let u = l[c++],
        h = l[c++],
        f = l[c++],
        d = c == l.length || !r,
        p = d ? e : e.split(),
        m = this.tokens.mainToken;
      if (
        (p.apply(u, h, m ? m.start : p.pos, f),
        ar &&
          console.log(
            o +
              this.stackID(p) +
              ` (via ${u & 65536 ? `reduce of ${s.getName(u & 65535)}` : "shift"} for ${s.getName(h)} @ ${i}${p == e ? "" : ", split"})`
          ),
        d)
      )
        return !0;
      p.pos > i ? n.push(p) : r.push(p);
    }
    return !1;
  }
  advanceFully(e, n) {
    let r = e.pos;
    for (;;) {
      if (!this.advanceStack(e, null, null)) return !1;
      if (e.pos > r) return vE(e, n), !0;
    }
  }
  runRecovery(e, n, r) {
    let i = null,
      s = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o],
        l = n[o << 1],
        c = n[(o << 1) + 1],
        u = ar ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (s || ((s = !0), a.restart(), ar && console.log(u + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let h = a.split(),
        f = u;
      for (
        let d = 0;
        h.forceReduce() && d < 10 && (ar && console.log(f + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, r));
        d++
      )
        ar && (f = this.stackID(h) + " -> ");
      for (let d of a.recoverByInsert(l)) ar && console.log(u + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, r);
      this.stream.end > a.pos
        ? (c == a.pos && (c++, (l = 0)),
          a.recoverByDelete(l, c),
          ar && console.log(u + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`),
          vE(a, r))
        : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  stackToTree(e) {
    return (
      e.close(),
      ze.build({
        buffer: Yp.create(e),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: e.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm,
      })
    );
  }
  stackID(e) {
    let n = (s1 || (s1 = new WeakMap())).get(e);
    return n || s1.set(e, (n = String.fromCodePoint(this.nextStackID++))), n + e;
  }
}
function vE(t, e) {
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    if (r.pos == t.pos && r.sameState(t)) {
      e[n].score < t.score && (e[n] = t);
      return;
    }
  }
  e.push(t);
}
class Fce {
  constructor(e, n, r) {
    (this.source = e), (this.flags = n), (this.disabled = r);
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const o1 = (t) => t;
class yR {
  constructor(e) {
    (this.start = e.start),
      (this.shift = e.shift || o1),
      (this.reduce = e.reduce || o1),
      (this.reuse = e.reuse || o1),
      (this.hash = e.hash || (() => 0)),
      (this.strict = e.strict !== !1);
  }
}
class Pl extends Cg {
  constructor(e) {
    if ((super(), (this.wrappers = []), e.version != 14))
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let a = 0; a < e.repeatNodeCount; a++) n.push("");
    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]),
      i = [];
    for (let a = 0; a < n.length; a++) i.push([]);
    function s(a, l, c) {
      i[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = Ie[l]);
        for (let c = 1; c < a.length; ) {
          let u = a[c++];
          if (u >= 0) s(u, l, a[c++]);
          else {
            let h = a[c + -u];
            for (let f = -u; f > 0; f--) s(a[c++], l, h);
            c++;
          }
        }
      }
    (this.nodeSet = new ic(
      n.map((a, l) =>
        Kt.define({
          name: l >= this.minRepeatTerm ? void 0 : a,
          id: l,
          props: i[l],
          top: r.indexOf(l) > -1,
          error: l == 0,
          skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1,
        })
      )
    )),
      e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)),
      (this.strict = !1),
      (this.bufferLength = X4);
    let o = Uc(e.tokenData);
    (this.context = e.context),
      (this.specializerSpecs = e.specialized || []),
      (this.specialized = new Uint16Array(this.specializerSpecs.length));
    for (let a = 0; a < this.specializerSpecs.length; a++) this.specialized[a] = this.specializerSpecs[a].term;
    (this.specializers = this.specializerSpecs.map(xE)),
      (this.states = Uc(e.states, Uint32Array)),
      (this.data = Uc(e.stateData)),
      (this.goto = Uc(e.goto)),
      (this.maxTerm = e.maxTerm),
      (this.tokenizers = e.tokenizers.map((a) => (typeof a == "number" ? new cl(o, a) : a))),
      (this.topRules = e.topRules),
      (this.dialects = e.dialects || {}),
      (this.dynamicPrecedences = e.dynamicPrecedences || null),
      (this.tokenPrecTable = e.tokenPrec),
      (this.termNames = e.termNames || null),
      (this.maxNode = this.nodeSet.types.length - 1),
      (this.dialect = this.parseDialect()),
      (this.top = this.topRules[Object.keys(this.topRules)[0]]);
  }
  createParse(e, n, r) {
    let i = new Qce(this, e, n, r);
    for (let s of this.wrappers) i = s(i, e, n, r);
    return i;
  }
  getGoto(e, n, r = !1) {
    let i = this.goto;
    if (n >= i[0]) return -1;
    for (let s = i[n + 1]; ; ) {
      let o = i[s++],
        a = o & 1,
        l = i[s++];
      if (a && r) return l;
      for (let c = s + (o >> 1); s < c; s++) if (i[s] == e) return l;
      if (a) return -1;
    }
  }
  hasAction(e, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(e, i ? 2 : 1), o; ; s += 3) {
        if ((o = r[s]) == 65535)
          if (r[s + 1] == 1) o = r[(s = Yi(r, s + 2))];
          else {
            if (r[s + 1] == 2) return Yi(r, s + 2);
            break;
          }
        if (o == n || o == 0) return Yi(r, s + 1);
      }
    return 0;
  }
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  stateFlag(e, n) {
    return (this.stateSlot(e, 0) & n) > 0;
  }
  validAction(e, n) {
    return !!this.allActions(e, (r) => (r == n ? !0 : null));
  }
  allActions(e, n) {
    let r = this.stateSlot(e, 4),
      i = r ? n(r) : void 0;
    for (let s = this.stateSlot(e, 1); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1) s = Yi(this.data, s + 2);
        else break;
      i = n(Yi(this.data, s + 1));
    }
    return i;
  }
  nextStates(e) {
    let n = [];
    for (let r = this.stateSlot(e, 1); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1) r = Yi(this.data, r + 2);
        else break;
      if (!(this.data[r + 2] & 1)) {
        let i = this.data[r + 1];
        n.some((s, o) => o & 1 && s == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  configure(e) {
    let n = Object.assign(Object.create(Pl.prototype), this);
    if ((e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top)) {
      let r = this.topRules[e.top];
      if (!r) throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = r;
    }
    return (
      e.tokenizers &&
        (n.tokenizers = this.tokenizers.map((r) => {
          let i = e.tokenizers.find((s) => s.from == r);
          return i ? i.to : r;
        })),
      e.specializers &&
        ((n.specializers = this.specializers.slice()),
        (n.specializerSpecs = this.specializerSpecs.map((r, i) => {
          let s = e.specializers.find((a) => a.from == r.external);
          if (!s) return r;
          let o = Object.assign(Object.assign({}, r), { external: s.to });
          return (n.specializers[i] = xE(o)), o;
        }))),
      e.contextTracker && (n.context = e.contextTracker),
      e.dialect && (n.dialect = this.parseDialect(e.dialect)),
      e.strict != null && (n.strict = e.strict),
      e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)),
      e.bufferLength != null && (n.bufferLength = e.bufferLength),
      n
    );
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(e) {
    return this.termNames ? this.termNames[e] : String((e <= this.maxNode && this.nodeSet.types[e].name) || e);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  parseDialect(e) {
    let n = Object.keys(this.dialects),
      r = n.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = n.indexOf(s);
        o >= 0 && (r[o] = !0);
      }
    let i = null;
    for (let s = 0; s < n.length; s++)
      if (!r[s]) for (let o = this.dialects[n[s]], a; (a = this.data[o++]) != 65535; ) (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new Fce(e, r, i);
  }
  static deserialize(e) {
    return new Pl(e);
  }
}
function Yi(t, e) {
  return t[e] | (t[e + 1] << 16);
}
function Vce(t) {
  let e = null;
  for (let n of t) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || (r != null && n.pos > r)) && n.p.parser.stateFlag(n.state, 2) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function xE(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (n, r) => (t.external(n, r) << 1) | e;
  }
  return t.get;
}
const Bce = 99,
  bE = 1,
  jce = 100,
  Zce = 101,
  yE = 2,
  wR = [
    9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288,
  ],
  zce = 58,
  Wce = 40,
  SR = 95,
  Uce = 91,
  Fd = 45,
  Xce = 46,
  Hce = 35,
  qce = 37,
  Yce = 38,
  Gce = 92,
  Jce = 10;
function th(t) {
  return (t >= 65 && t <= 90) || (t >= 97 && t <= 122) || t >= 161;
}
function kR(t) {
  return t >= 48 && t <= 57;
}
const Kce = new ui((t, e) => {
    for (let n = !1, r = 0, i = 0; ; i++) {
      let { next: s } = t;
      if (th(s) || s == Fd || s == SR || (n && kR(s))) !n && (s != Fd || i > 0) && (n = !0), r === i && s == Fd && r++, t.advance();
      else if (s == Gce && t.peek(1) != Jce) t.advance(), t.next > -1 && t.advance(), (n = !0);
      else {
        n && t.acceptToken(s == Wce ? jce : r == 2 && e.canShift(yE) ? yE : Zce);
        break;
      }
    }
  }),
  eue = new ui((t) => {
    if (wR.includes(t.peek(-1))) {
      let { next: e } = t;
      (th(e) || e == SR || e == Hce || e == Xce || e == Uce || (e == zce && th(t.peek(1))) || e == Fd || e == Yce) && t.acceptToken(Bce);
    }
  }),
  tue = new ui((t) => {
    if (!wR.includes(t.peek(-1))) {
      let { next: e } = t;
      if ((e == qce && (t.advance(), t.acceptToken(bE)), th(e))) {
        do t.advance();
        while (th(t.next) || kR(t.next));
        t.acceptToken(bE);
      }
    }
  }),
  nue = sc({
    "AtKeyword import charset namespace keyframes media supports": R.definitionKeyword,
    "from to selector": R.keyword,
    NamespaceName: R.namespace,
    KeyframeName: R.labelName,
    KeyframeRangeName: R.operatorKeyword,
    TagName: R.tagName,
    ClassName: R.className,
    PseudoClassName: R.constant(R.className),
    IdName: R.labelName,
    "FeatureName PropertyName": R.propertyName,
    AttributeName: R.attributeName,
    NumberLiteral: R.number,
    KeywordQuery: R.keyword,
    UnaryQueryOp: R.operatorKeyword,
    "CallTag ValueName": R.atom,
    VariableName: R.variableName,
    Callee: R.operatorKeyword,
    Unit: R.unit,
    "UniversalSelector NestingSelector": R.definitionOperator,
    MatchOp: R.compareOperator,
    "ChildOp SiblingOp, LogicOp": R.logicOperator,
    BinOp: R.arithmeticOperator,
    Important: R.modifier,
    Comment: R.blockComment,
    ColorLiteral: R.color,
    "ParenthesizedContent StringLiteral": R.string,
    ":": R.punctuation,
    "PseudoOp #": R.derefOperator,
    "; ,": R.separator,
    "( )": R.paren,
    "[ ]": R.squareBracket,
    "{ }": R.brace,
  }),
  rue = {
    __proto__: null,
    lang: 32,
    "nth-child": 32,
    "nth-last-child": 32,
    "nth-of-type": 32,
    "nth-last-of-type": 32,
    dir: 32,
    "host-context": 32,
    url: 60,
    "url-prefix": 60,
    domain: 60,
    regexp: 60,
    selector: 138,
  },
  iue = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 },
  sue = { __proto__: null, not: 132, only: 132 },
  oue = Pl.deserialize({
    version: 14,
    states:
      ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
    stateData:
      ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
    goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
    nodeNames:
      "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
    maxTerm: 117,
    nodeProps: [
      ["isolate", -2, 3, 24, ""],
      ["openedBy", 17, "(", 32, "[", 50, "{"],
      ["closedBy", 18, ")", 33, "]", 51, "}"],
    ],
    propSources: [nue],
    skippedNodes: [0, 3, 87],
    repeatNodeCount: 11,
    tokenData:
      "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
    tokenizers: [eue, tue, Kce, 1, 2, 3, 4, new Gp("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
    topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
    specialized: [
      { term: 100, get: (t) => rue[t] || -1 },
      { term: 58, get: (t) => iue[t] || -1 },
      { term: 101, get: (t) => sue[t] || -1 },
    ],
    tokenPrec: 1200,
  });
let a1 = null;
function l1() {
  if (!a1 && typeof document == "object" && document.body) {
    let { style: t } = document.body,
      e = [],
      n = new Set();
    for (let r in t)
      r != "cssText" &&
        r != "cssFloat" &&
        typeof t[r] == "string" &&
        (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), n.has(r) || (e.push(r), n.add(r)));
    a1 = e.sort().map((r) => ({ type: "property", label: r }));
  }
  return a1 || [];
}
const wE = [
    "active",
    "after",
    "any-link",
    "autofill",
    "backdrop",
    "before",
    "checked",
    "cue",
    "default",
    "defined",
    "disabled",
    "empty",
    "enabled",
    "file-selector-button",
    "first",
    "first-child",
    "first-letter",
    "first-line",
    "first-of-type",
    "focus",
    "focus-visible",
    "focus-within",
    "fullscreen",
    "has",
    "host",
    "host-context",
    "hover",
    "in-range",
    "indeterminate",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "marker",
    "modal",
    "not",
    "nth-child",
    "nth-last-child",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "part",
    "placeholder",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "selection",
    "slotted",
    "target",
    "target-text",
    "valid",
    "visited",
    "where",
  ].map((t) => ({ type: "class", label: t })),
  SE = [
    "above",
    "absolute",
    "activeborder",
    "additive",
    "activecaption",
    "after-white-space",
    "ahead",
    "alias",
    "all",
    "all-scroll",
    "alphabetic",
    "alternate",
    "always",
    "antialiased",
    "appworkspace",
    "asterisks",
    "attr",
    "auto",
    "auto-flow",
    "avoid",
    "avoid-column",
    "avoid-page",
    "avoid-region",
    "axis-pan",
    "background",
    "backwards",
    "baseline",
    "below",
    "bidi-override",
    "blink",
    "block",
    "block-axis",
    "bold",
    "bolder",
    "border",
    "border-box",
    "both",
    "bottom",
    "break",
    "break-all",
    "break-word",
    "bullets",
    "button",
    "button-bevel",
    "buttonface",
    "buttonhighlight",
    "buttonshadow",
    "buttontext",
    "calc",
    "capitalize",
    "caps-lock-indicator",
    "caption",
    "captiontext",
    "caret",
    "cell",
    "center",
    "checkbox",
    "circle",
    "cjk-decimal",
    "clear",
    "clip",
    "close-quote",
    "col-resize",
    "collapse",
    "color",
    "color-burn",
    "color-dodge",
    "column",
    "column-reverse",
    "compact",
    "condensed",
    "contain",
    "content",
    "contents",
    "content-box",
    "context-menu",
    "continuous",
    "copy",
    "counter",
    "counters",
    "cover",
    "crop",
    "cross",
    "crosshair",
    "currentcolor",
    "cursive",
    "cyclic",
    "darken",
    "dashed",
    "decimal",
    "decimal-leading-zero",
    "default",
    "default-button",
    "dense",
    "destination-atop",
    "destination-in",
    "destination-out",
    "destination-over",
    "difference",
    "disc",
    "discard",
    "disclosure-closed",
    "disclosure-open",
    "document",
    "dot-dash",
    "dot-dot-dash",
    "dotted",
    "double",
    "down",
    "e-resize",
    "ease",
    "ease-in",
    "ease-in-out",
    "ease-out",
    "element",
    "ellipse",
    "ellipsis",
    "embed",
    "end",
    "ethiopic-abegede-gez",
    "ethiopic-halehame-aa-er",
    "ethiopic-halehame-gez",
    "ew-resize",
    "exclusion",
    "expanded",
    "extends",
    "extra-condensed",
    "extra-expanded",
    "fantasy",
    "fast",
    "fill",
    "fill-box",
    "fixed",
    "flat",
    "flex",
    "flex-end",
    "flex-start",
    "footnotes",
    "forwards",
    "from",
    "geometricPrecision",
    "graytext",
    "grid",
    "groove",
    "hand",
    "hard-light",
    "help",
    "hidden",
    "hide",
    "higher",
    "highlight",
    "highlighttext",
    "horizontal",
    "hsl",
    "hsla",
    "hue",
    "icon",
    "ignore",
    "inactiveborder",
    "inactivecaption",
    "inactivecaptiontext",
    "infinite",
    "infobackground",
    "infotext",
    "inherit",
    "initial",
    "inline",
    "inline-axis",
    "inline-block",
    "inline-flex",
    "inline-grid",
    "inline-table",
    "inset",
    "inside",
    "intrinsic",
    "invert",
    "italic",
    "justify",
    "keep-all",
    "landscape",
    "large",
    "larger",
    "left",
    "level",
    "lighter",
    "lighten",
    "line-through",
    "linear",
    "linear-gradient",
    "lines",
    "list-item",
    "listbox",
    "listitem",
    "local",
    "logical",
    "loud",
    "lower",
    "lower-hexadecimal",
    "lower-latin",
    "lower-norwegian",
    "lowercase",
    "ltr",
    "luminosity",
    "manipulation",
    "match",
    "matrix",
    "matrix3d",
    "medium",
    "menu",
    "menutext",
    "message-box",
    "middle",
    "min-intrinsic",
    "mix",
    "monospace",
    "move",
    "multiple",
    "multiple_mask_images",
    "multiply",
    "n-resize",
    "narrower",
    "ne-resize",
    "nesw-resize",
    "no-close-quote",
    "no-drop",
    "no-open-quote",
    "no-repeat",
    "none",
    "normal",
    "not-allowed",
    "nowrap",
    "ns-resize",
    "numbers",
    "numeric",
    "nw-resize",
    "nwse-resize",
    "oblique",
    "opacity",
    "open-quote",
    "optimizeLegibility",
    "optimizeSpeed",
    "outset",
    "outside",
    "outside-shape",
    "overlay",
    "overline",
    "padding",
    "padding-box",
    "painted",
    "page",
    "paused",
    "perspective",
    "pinch-zoom",
    "plus-darker",
    "plus-lighter",
    "pointer",
    "polygon",
    "portrait",
    "pre",
    "pre-line",
    "pre-wrap",
    "preserve-3d",
    "progress",
    "push-button",
    "radial-gradient",
    "radio",
    "read-only",
    "read-write",
    "read-write-plaintext-only",
    "rectangle",
    "region",
    "relative",
    "repeat",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "repeat-x",
    "repeat-y",
    "reset",
    "reverse",
    "rgb",
    "rgba",
    "ridge",
    "right",
    "rotate",
    "rotate3d",
    "rotateX",
    "rotateY",
    "rotateZ",
    "round",
    "row",
    "row-resize",
    "row-reverse",
    "rtl",
    "run-in",
    "running",
    "s-resize",
    "sans-serif",
    "saturation",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
    "scaleZ",
    "screen",
    "scroll",
    "scrollbar",
    "scroll-position",
    "se-resize",
    "self-start",
    "self-end",
    "semi-condensed",
    "semi-expanded",
    "separate",
    "serif",
    "show",
    "single",
    "skew",
    "skewX",
    "skewY",
    "skip-white-space",
    "slide",
    "slider-horizontal",
    "slider-vertical",
    "sliderthumb-horizontal",
    "sliderthumb-vertical",
    "slow",
    "small",
    "small-caps",
    "small-caption",
    "smaller",
    "soft-light",
    "solid",
    "source-atop",
    "source-in",
    "source-out",
    "source-over",
    "space",
    "space-around",
    "space-between",
    "space-evenly",
    "spell-out",
    "square",
    "start",
    "static",
    "status-bar",
    "stretch",
    "stroke",
    "stroke-box",
    "sub",
    "subpixel-antialiased",
    "svg_masks",
    "super",
    "sw-resize",
    "symbolic",
    "symbols",
    "system-ui",
    "table",
    "table-caption",
    "table-cell",
    "table-column",
    "table-column-group",
    "table-footer-group",
    "table-header-group",
    "table-row",
    "table-row-group",
    "text",
    "text-bottom",
    "text-top",
    "textarea",
    "textfield",
    "thick",
    "thin",
    "threeddarkshadow",
    "threedface",
    "threedhighlight",
    "threedlightshadow",
    "threedshadow",
    "to",
    "top",
    "transform",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "translateZ",
    "transparent",
    "ultra-condensed",
    "ultra-expanded",
    "underline",
    "unidirectional-pan",
    "unset",
    "up",
    "upper-latin",
    "uppercase",
    "url",
    "var",
    "vertical",
    "vertical-text",
    "view-box",
    "visible",
    "visibleFill",
    "visiblePainted",
    "visibleStroke",
    "visual",
    "w-resize",
    "wait",
    "wave",
    "wider",
    "window",
    "windowframe",
    "windowtext",
    "words",
    "wrap",
    "wrap-reverse",
    "x-large",
    "x-small",
    "xor",
    "xx-large",
    "xx-small",
  ]
    .map((t) => ({ type: "keyword", label: t }))
    .concat(
      [
        "aliceblue",
        "antiquewhite",
        "aqua",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "black",
        "blanchedalmond",
        "blue",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "fuchsia",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "gray",
        "grey",
        "green",
        "greenyellow",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightsteelblue",
        "lightyellow",
        "lime",
        "limegreen",
        "linen",
        "magenta",
        "maroon",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "navy",
        "oldlace",
        "olive",
        "olivedrab",
        "orange",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "purple",
        "rebeccapurple",
        "red",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "silver",
        "skyblue",
        "slateblue",
        "slategray",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "teal",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "white",
        "whitesmoke",
        "yellow",
        "yellowgreen",
      ].map((t) => ({ type: "constant", label: t }))
    ),
  aue = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "b",
    "bdi",
    "bdo",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "figcaption",
    "figure",
    "footer",
    "form",
    "header",
    "hgroup",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "meter",
    "nav",
    "ol",
    "output",
    "p",
    "pre",
    "ruby",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "tr",
    "u",
    "ul",
  ].map((t) => ({ type: "type", label: t })),
  Ss = /^(\w[\w-]*|-\w[\w-]*|)$/,
  lue = /^-(-[\w-]*)?$/;
function cue(t, e) {
  var n;
  if (((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")) return !1;
  let r = (n = t.parent) === null || n === void 0 ? void 0 : n.firstChild;
  return (r == null ? void 0 : r.name) != "Callee" ? !1 : e.sliceString(r.from, r.to) == "var";
}
const kE = new G4(),
  uue = ["Declaration"];
function hue(t) {
  for (let e = t; ; ) {
    if (e.type.isTop) return e;
    if (!(e = e.parent)) return t;
  }
}
function CR(t, e, n) {
  if (e.to - e.from > 4096) {
    let r = kE.get(e);
    if (r) return r;
    let i = [],
      s = new Set(),
      o = e.cursor(kt.IncludeAnonymous);
    if (o.firstChild())
      do for (let a of CR(t, o.node, n)) s.has(a.label) || (s.add(a.label), i.push(a));
      while (o.nextSibling());
    return kE.set(e, i), i;
  } else {
    let r = [],
      i = new Set();
    return (
      e.cursor().iterate((s) => {
        var o;
        if (n(s) && s.matchContext(uue) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
          let a = t.sliceString(s.from, s.to);
          i.has(a) || (i.add(a), r.push({ label: a, type: "variable" }));
        }
      }),
      r
    );
  }
}
const _R = (t) => (e) => {
    let { state: n, pos: r } = e,
      i = pt(n).resolveInner(r, -1),
      s = i.type.isError && i.from == i.to - 1 && n.doc.sliceString(i.from, i.to) == "-";
    if (i.name == "PropertyName" || ((s || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name)))
      return { from: i.from, options: l1(), validFor: Ss };
    if (i.name == "ValueName") return { from: i.from, options: SE, validFor: Ss };
    if (i.name == "PseudoClassName") return { from: i.from, options: wE, validFor: Ss };
    if (t(i) || ((e.explicit || s) && cue(i, n.doc))) return { from: t(i) || s ? i.from : r, options: CR(n.doc, hue(i), t), validFor: lue };
    if (i.name == "TagName") {
      for (let { parent: l } = i; l; l = l.parent) if (l.name == "Block") return { from: i.from, options: l1(), validFor: Ss };
      return { from: i.from, options: aue, validFor: Ss };
    }
    if (!e.explicit) return null;
    let o = i.resolve(r),
      a = o.childBefore(r);
    return a && a.name == ":" && o.name == "PseudoClassSelector"
      ? { from: r, options: wE, validFor: Ss }
      : (a && a.name == ":" && o.name == "Declaration") || o.name == "ArgList"
      ? { from: r, options: SE, validFor: Ss }
      : o.name == "Block" || o.name == "Styles"
      ? { from: r, options: l1(), validFor: Ss }
      : null;
  },
  ER = _R((t) => t.name == "VariableName"),
  nh = _l.define({
    name: "css",
    parser: oue.configure({ props: [of.add({ Declaration: Dd() }), oc.add({ "Block KeyframeList": a8 })] }),
    languageData: { commentTokens: { block: { open: "/*", close: "*/" } }, indentOnInput: /^\s*\}$/, wordChars: "-" },
  });
function rS() {
  return new Tl(nh, nh.data.of({ autocomplete: ER }));
}
const fue = Object.freeze(
    Object.defineProperty(
      { __proto__: null, css: rS, cssCompletionSource: ER, cssLanguage: nh, defineCSSCompletionSource: _R },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  due = 54,
  pue = 1,
  mue = 55,
  gue = 2,
  Oue = 56,
  vue = 3,
  CE = 4,
  xue = 5,
  Jp = 6,
  TR = 7,
  PR = 8,
  AR = 9,
  $R = 10,
  bue = 11,
  yue = 12,
  wue = 13,
  c1 = 57,
  Sue = 14,
  _E = 58,
  RR = 20,
  kue = 22,
  IR = 23,
  Cue = 24,
  ix = 26,
  NR = 27,
  _ue = 28,
  Eue = 31,
  Tue = 34,
  Pue = 36,
  Aue = 37,
  $ue = 0,
  Rue = 1,
  Iue = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    command: !0,
    embed: !0,
    frame: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
    menuitem: !0,
  },
  Nue = { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 },
  EE = {
    dd: { dd: !0, dt: !0 },
    dt: { dd: !0, dt: !0 },
    li: { li: !0 },
    option: { option: !0, optgroup: !0 },
    optgroup: { optgroup: !0 },
    p: {
      address: !0,
      article: !0,
      aside: !0,
      blockquote: !0,
      dir: !0,
      div: !0,
      dl: !0,
      fieldset: !0,
      footer: !0,
      form: !0,
      h1: !0,
      h2: !0,
      h3: !0,
      h4: !0,
      h5: !0,
      h6: !0,
      header: !0,
      hgroup: !0,
      hr: !0,
      menu: !0,
      nav: !0,
      ol: !0,
      p: !0,
      pre: !0,
      section: !0,
      table: !0,
      ul: !0,
    },
    rp: { rp: !0, rt: !0 },
    rt: { rp: !0, rt: !0 },
    tbody: { tbody: !0, tfoot: !0 },
    td: { td: !0, th: !0 },
    tfoot: { tbody: !0 },
    th: { td: !0, th: !0 },
    thead: { tbody: !0, tfoot: !0 },
    tr: { tr: !0 },
  };
function Lue(t) {
  return t == 45 || t == 46 || t == 58 || (t >= 65 && t <= 90) || t == 95 || (t >= 97 && t <= 122) || t >= 161;
}
function LR(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let TE = null,
  PE = null,
  AE = 0;
function sx(t, e) {
  let n = t.pos + e;
  if (AE == n && PE == t) return TE;
  let r = t.peek(e);
  for (; LR(r); ) r = t.peek(++e);
  let i = "";
  for (; Lue(r); ) (i += String.fromCharCode(r)), (r = t.peek(++e));
  return (PE = t), (AE = n), (TE = i ? i.toLowerCase() : r == Mue || r == Due ? void 0 : null);
}
const MR = 60,
  Kp = 62,
  iS = 47,
  Mue = 63,
  Due = 33,
  Que = 45;
function $E(t, e) {
  (this.name = t), (this.parent = e);
}
const Fue = [Jp, $R, TR, PR, AR],
  Vue = new yR({
    start: null,
    shift(t, e, n, r) {
      return Fue.indexOf(e) > -1 ? new $E(sx(r, 1) || "", t) : t;
    },
    reduce(t, e) {
      return e == RR && t ? t.parent : t;
    },
    reuse(t, e, n, r) {
      let i = e.type.id;
      return i == Jp || i == Pue ? new $E(sx(r, 1) || "", t) : t;
    },
    strict: !1,
  }),
  Bue = new ui(
    (t, e) => {
      if (t.next != MR) {
        t.next < 0 && e.context && t.acceptToken(c1);
        return;
      }
      t.advance();
      let n = t.next == iS;
      n && t.advance();
      let r = sx(t, 0);
      if (r === void 0) return;
      if (!r) return t.acceptToken(n ? Sue : Jp);
      let i = e.context ? e.context.name : null;
      if (n) {
        if (r == i) return t.acceptToken(bue);
        if (i && Nue[i]) return t.acceptToken(c1, -2);
        if (e.dialectEnabled($ue)) return t.acceptToken(yue);
        for (let s = e.context; s; s = s.parent) if (s.name == r) return;
        t.acceptToken(wue);
      } else {
        if (r == "script") return t.acceptToken(TR);
        if (r == "style") return t.acceptToken(PR);
        if (r == "textarea") return t.acceptToken(AR);
        if (Iue.hasOwnProperty(r)) return t.acceptToken($R);
        i && EE[i] && EE[i][r] ? t.acceptToken(c1, -1) : t.acceptToken(Jp);
      }
    },
    { contextual: !0 }
  ),
  jue = new ui((t) => {
    for (let e = 0, n = 0; ; n++) {
      if (t.next < 0) {
        n && t.acceptToken(_E);
        break;
      }
      if (t.next == Que) e++;
      else if (t.next == Kp && e >= 2) {
        n >= 3 && t.acceptToken(_E, -2);
        break;
      } else e = 0;
      t.advance();
    }
  });
function Zue(t) {
  for (; t; t = t.parent) if (t.name == "svg" || t.name == "math") return !0;
  return !1;
}
const zue = new ui((t, e) => {
  if (t.next == iS && t.peek(1) == Kp) {
    let n = e.dialectEnabled(Rue) || Zue(e.context);
    t.acceptToken(n ? xue : CE, 2);
  } else t.next == Kp && t.acceptToken(CE, 1);
});
function sS(t, e, n) {
  let r = 2 + t.length;
  return new ui((i) => {
    for (let s = 0, o = 0, a = 0; ; a++) {
      if (i.next < 0) {
        a && i.acceptToken(e);
        break;
      }
      if ((s == 0 && i.next == MR) || (s == 1 && i.next == iS) || (s >= 2 && s < r && i.next == t.charCodeAt(s - 2))) s++, o++;
      else if ((s == 2 || s == r) && LR(i.next)) o++;
      else if (s == r && i.next == Kp) {
        a > o ? i.acceptToken(e, -o) : i.acceptToken(n, -(o - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && a) {
        i.acceptToken(e, 1);
        break;
      } else s = o = 0;
      i.advance();
    }
  });
}
const Wue = sS("script", due, pue),
  Uue = sS("style", mue, gue),
  Xue = sS("textarea", Oue, vue),
  Hue = sc({
    "Text RawText": R.content,
    "StartTag StartCloseTag SelfClosingEndTag EndTag": R.angleBracket,
    TagName: R.tagName,
    "MismatchedCloseTag/TagName": [R.tagName, R.invalid],
    AttributeName: R.attributeName,
    "AttributeValue UnquotedAttributeValue": R.attributeValue,
    Is: R.definitionOperator,
    "EntityReference CharacterReference": R.character,
    Comment: R.blockComment,
    ProcessingInst: R.processingInstruction,
    DoctypeDecl: R.documentMeta,
  }),
  que = Pl.deserialize({
    version: 14,
    states:
      ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
    stateData:
      ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
    goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
    nodeNames:
      "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
    maxTerm: 67,
    context: Vue,
    nodeProps: [
      ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
      ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
      ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
      ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""],
    ],
    propSources: [Hue],
    skippedNodes: [0],
    repeatNodeCount: 9,
    tokenData:
      "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
    tokenizers: [Wue, Uue, Xue, zue, Bue, jue, 0, 1, 2, 3, 4, 5],
    topRules: { Document: [0, 15] },
    dialects: { noMatch: 0, selfClosing: 509 },
    tokenPrec: 511,
  });
function DR(t, e) {
  let n = Object.create(null);
  for (let r of t.getChildren(IR)) {
    let i = r.getChild(Cue),
      s = r.getChild(ix) || r.getChild(NR);
    i && (n[e.read(i.from, i.to)] = s ? (s.type.id == ix ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to)) : "");
  }
  return n;
}
function RE(t, e) {
  let n = t.getChild(kue);
  return n ? e.read(n.from, n.to) : " ";
}
function u1(t, e, n) {
  let r;
  for (let i of n) if (!i.attrs || i.attrs(r || (r = DR(t.node.parent.firstChild, e)))) return { parser: i.parser };
  return null;
}
function QR(t = [], e = []) {
  let n = [],
    r = [],
    i = [],
    s = [];
  for (let a of t) (a.tag == "script" ? n : a.tag == "style" ? r : a.tag == "textarea" ? i : s).push(a);
  let o = e.length ? Object.create(null) : null;
  for (let a of e) (o[a.name] || (o[a.name] = [])).push(a);
  return J4((a, l) => {
    let c = a.type.id;
    if (c == _ue) return u1(a, l, n);
    if (c == Eue) return u1(a, l, r);
    if (c == Tue) return u1(a, l, i);
    if (c == RR && s.length) {
      let u = a.node,
        h = u.firstChild,
        f = h && RE(h, l),
        d;
      if (f) {
        for (let p of s)
          if (p.tag == f && (!p.attrs || p.attrs(d || (d = DR(h, l))))) {
            let m = u.lastChild,
              O = m.type.id == Aue ? m.from : u.to;
            if (O > h.to) return { parser: p.parser, overlay: [{ from: h.to, to: O }] };
          }
      }
    }
    if (o && c == IR) {
      let u = a.node,
        h;
      if ((h = u.firstChild)) {
        let f = o[l.read(h.from, h.to)];
        if (f)
          for (let d of f) {
            if (d.tagName && d.tagName != RE(u.parent, l)) continue;
            let p = u.lastChild;
            if (p.type.id == ix) {
              let m = p.from + 1,
                O = p.lastChild,
                v = p.to - (O && O.isError ? 0 : 1);
              if (v > m) return { parser: d.parser, overlay: [{ from: m, to: v }] };
            } else if (p.type.id == NR) return { parser: d.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const Yue = 312,
  IE = 1,
  Gue = 2,
  Jue = 3,
  Kue = 4,
  ehe = 313,
  the = 315,
  nhe = 316,
  rhe = 5,
  ihe = 6,
  she = 0,
  ox = [
    9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288,
  ],
  FR = 125,
  ohe = 59,
  ax = 47,
  ahe = 42,
  lhe = 43,
  che = 45,
  uhe = 60,
  hhe = 44,
  fhe = 63,
  dhe = 46,
  phe = new yR({
    start: !1,
    shift(t, e) {
      return e == rhe || e == ihe || e == the ? t : e == nhe;
    },
    strict: !1,
  }),
  mhe = new ui(
    (t, e) => {
      let { next: n } = t;
      (n == FR || n == -1 || e.context) && t.acceptToken(ehe);
    },
    { contextual: !0, fallback: !0 }
  ),
  ghe = new ui(
    (t, e) => {
      let { next: n } = t,
        r;
      ox.indexOf(n) > -1 ||
        (n == ax && ((r = t.peek(1)) == ax || r == ahe)) ||
        (n != FR && n != ohe && n != -1 && !e.context && t.acceptToken(Yue));
    },
    { contextual: !0 }
  ),
  Ohe = new ui(
    (t, e) => {
      let { next: n } = t;
      if (n == lhe || n == che) {
        if ((t.advance(), n == t.next)) {
          t.advance();
          let r = !e.context && e.canShift(IE);
          t.acceptToken(r ? IE : Gue);
        }
      } else n == fhe && t.peek(1) == dhe && (t.advance(), t.advance(), (t.next < 48 || t.next > 57) && t.acceptToken(Jue));
    },
    { contextual: !0 }
  );
function h1(t, e) {
  return (t >= 65 && t <= 90) || (t >= 97 && t <= 122) || t == 95 || t >= 192 || (!e && t >= 48 && t <= 57);
}
const vhe = new ui((t, e) => {
    if (t.next != uhe || !e.dialectEnabled(she) || (t.advance(), t.next == ax)) return;
    let n = 0;
    for (; ox.indexOf(t.next) > -1; ) t.advance(), n++;
    if (h1(t.next, !0)) {
      for (t.advance(), n++; h1(t.next, !1); ) t.advance(), n++;
      for (; ox.indexOf(t.next) > -1; ) t.advance(), n++;
      if (t.next == hhe) return;
      for (let r = 0; ; r++) {
        if (r == 7) {
          if (!h1(t.next, !0)) return;
          break;
        }
        if (t.next != "extends".charCodeAt(r)) break;
        t.advance(), n++;
      }
    }
    t.acceptToken(Kue, -n);
  }),
  xhe = sc({
    "get set async static": R.modifier,
    "for while do if else switch try catch finally return throw break continue default case": R.controlKeyword,
    "in of await yield void typeof delete instanceof": R.operatorKeyword,
    "let var const using function class extends": R.definitionKeyword,
    "import export from": R.moduleKeyword,
    "with debugger as new": R.keyword,
    TemplateString: R.special(R.string),
    super: R.atom,
    BooleanLiteral: R.bool,
    this: R.self,
    null: R.null,
    Star: R.modifier,
    VariableName: R.variableName,
    "CallExpression/VariableName TaggedTemplateExpression/VariableName": R.function(R.variableName),
    VariableDefinition: R.definition(R.variableName),
    Label: R.labelName,
    PropertyName: R.propertyName,
    PrivatePropertyName: R.special(R.propertyName),
    "CallExpression/MemberExpression/PropertyName": R.function(R.propertyName),
    "FunctionDeclaration/VariableDefinition": R.function(R.definition(R.variableName)),
    "ClassDeclaration/VariableDefinition": R.definition(R.className),
    PropertyDefinition: R.definition(R.propertyName),
    PrivatePropertyDefinition: R.definition(R.special(R.propertyName)),
    UpdateOp: R.updateOperator,
    "LineComment Hashbang": R.lineComment,
    BlockComment: R.blockComment,
    Number: R.number,
    String: R.string,
    Escape: R.escape,
    ArithOp: R.arithmeticOperator,
    LogicOp: R.logicOperator,
    BitOp: R.bitwiseOperator,
    CompareOp: R.compareOperator,
    RegExp: R.regexp,
    Equals: R.definitionOperator,
    Arrow: R.function(R.punctuation),
    ": Spread": R.punctuation,
    "( )": R.paren,
    "[ ]": R.squareBracket,
    "{ }": R.brace,
    "InterpolationStart InterpolationEnd": R.special(R.brace),
    ".": R.derefOperator,
    ", ;": R.separator,
    "@": R.meta,
    TypeName: R.typeName,
    TypeDefinition: R.definition(R.typeName),
    "type enum interface implements namespace module declare": R.definitionKeyword,
    "abstract global Privacy readonly override": R.modifier,
    "is keyof unique infer": R.operatorKeyword,
    JSXAttributeValue: R.attributeValue,
    JSXText: R.content,
    "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": R.angleBracket,
    "JSXIdentifier JSXNameSpacedName": R.tagName,
    "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": R.attributeName,
    "JSXBuiltin/JSXIdentifier": R.standard(R.tagName),
  }),
  bhe = {
    __proto__: null,
    export: 20,
    as: 25,
    from: 33,
    default: 36,
    async: 41,
    function: 42,
    extends: 54,
    this: 58,
    true: 66,
    false: 66,
    null: 78,
    void: 82,
    typeof: 86,
    super: 102,
    new: 136,
    delete: 148,
    yield: 157,
    await: 161,
    class: 166,
    public: 229,
    private: 229,
    protected: 229,
    readonly: 231,
    instanceof: 250,
    satisfies: 253,
    in: 254,
    const: 256,
    import: 290,
    keyof: 345,
    unique: 349,
    infer: 355,
    is: 391,
    abstract: 411,
    implements: 413,
    type: 415,
    let: 418,
    var: 420,
    using: 423,
    interface: 429,
    enum: 433,
    namespace: 439,
    module: 441,
    declare: 445,
    global: 449,
    for: 468,
    of: 477,
    while: 480,
    with: 484,
    do: 488,
    if: 492,
    else: 494,
    switch: 498,
    case: 504,
    try: 510,
    catch: 514,
    finally: 518,
    return: 522,
    throw: 526,
    break: 530,
    continue: 534,
    debugger: 538,
  },
  yhe = {
    __proto__: null,
    async: 123,
    get: 125,
    set: 127,
    declare: 189,
    public: 191,
    private: 191,
    protected: 191,
    static: 193,
    abstract: 195,
    override: 197,
    readonly: 203,
    accessor: 205,
    new: 395,
  },
  whe = { __proto__: null, "<": 187 },
  She = Pl.deserialize({
    version: 14,
    states:
      "$@QO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#CiO+RO!bO'#CjO+aO#tO'#CjO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DwO0fQ^O'#EPOOQ?Mr'#EX'#EXO1PQWO'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQWO'#GpO1dQWO'#ElO1iQWO'#ElO3hQ?NdO'#JmO6[Q?NdO'#JnO6uQWO'#F[O6zQ&jO'#FsOOQ?Mr'#Fe'#FeO7VO,YO'#FeO7eQ7[O'#FzO9RQWO'#FyOOQ?Mr'#Jn'#JnOOQ?Mp'#Jm'#JmO9WQWO'#GtOOQU'#KZ'#KZO9cQWO'#IUO9hQ?MxO'#IVOOQU'#JZ'#JZOOQU'#IZ'#IZQ`Q^OOO`Q^OOO9pQMnO'#DsO9wQ^O'#D{O:OQ^O'#D}O9^QWO'#GpO:VQ7[O'#CoO:eQWO'#EkO:pQWO'#EvO:uQ7[O'#FdO;dQWO'#GpOOQO'#K['#K[O;iQWO'#K[O;wQWO'#GxO;wQWO'#GyO;wQWO'#G{O9^QWO'#HOO<nQWO'#HRO>VQWO'#CeO>gQWO'#H_O>oQWO'#HeO>oQWO'#HgO`Q^O'#HiO>oQWO'#HkO>oQWO'#HnO>tQWO'#HtO>yQ?MyO'#HzO%[Q^O'#H|O?UQ?MyO'#IOO?aQ?MyO'#IQO9hQ?MxO'#ISO?lQ?NdO'#CiO@nQ`O'#DiQOQWOOO%[Q^O'#D}OAUQWO'#EQO:VQ7[O'#EkOAaQWO'#EkOAlQpO'#FdOOQU'#Cg'#CgOOQ?Mp'#Dn'#DnOOQ?Mp'#Jq'#JqO%[Q^O'#JqOOQO'#Jt'#JtOOQO'#Id'#IdOBlQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Jx'#JxOChQ?NQO'#EdOCrQ`O'#ETOOQO'#Js'#JsODWQ`O'#JtOEeQ`O'#ETOCrQ`O'#EdPErO#@ItO'#CbPOOO)CDx)CDxOOOO'#I['#I[OE}O!bO,59UOOQ?Mr,59U,59UOOOO'#I]'#I]OF]O#tO,59UO%[Q^O'#D`OOOO'#I_'#I_OFkO!0LbO,59xOOQ?Mr,59x,59xOFyQ^O'#I`OG^QWO'#JoOI]QrO'#JoO+}Q^O'#JoOIdQWO,5:OOIzQWO'#EmOJXQWO'#KOOJdQWO'#J}OJdQWO'#J}OJlQWO,5;ZOJqQWO'#J|OOQ?Mv,5:Z,5:ZOJxQ^O,5:ZOLvQ?NdO,5:cOMgQWO,5:kONQQ?MxO'#J{ONXQWO'#JzO9WQWO'#JzONmQWO'#JzONuQWO,5;YONzQWO'#JzO!#PQrO'#JnOOQ?Mr'#Ci'#CiO%[Q^O'#EPO!#oQrO,5:pOOQQ'#Ju'#JuOOQO-E<f-E<fO9^QWO,5=[O!$VQWO,5=[O!$[Q^O,5;WO!&_Q7[O'#EhO!'xQWO,5;WO!'}Q^O'#DvO!(XQ`O,5;aO!(aQ`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!(oQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yOOQ?Mr,5;{,5;{O%[Q^O'#IlO!*rQ?MxO,5<gO%[Q^O,5;bO!&_Q7[O,5;bO!+aQ7[O,5;bO!-RQ7[O'#EZO%[Q^O,5;vOOQ?Mr,5;z,5;zO!-YQ&jO'#FiO!.VQ&jO'#KSO!-qQ&jO'#KSO!.^Q&jO'#KSOOQO'#KS'#KSO!.rQ&jO,5<ROOOS,5<_,5<_O!/TQ^O'#FuOOOS'#Ik'#IkO7VO,YO,5<PO!/[Q&jO'#FwOOQ?Mr,5<P,5<PO!/{Q!LQO'#CvOOQ?Mr'#Cz'#CzO!0`O!0LbO'#DOO!0|Q7[O,5<dO!1TQWO,5<fO!2pQ$ISO'#GVO!2}QWO'#GWO!3SQWO'#GWO!4rQ$ISO'#G[O!5nQ`O'#G`OOQO'#Gk'#GkO!+hQ7[O'#GjOOQO'#Gm'#GmO!+hQ7[O'#GlO!6aQ!LQO'#JgOOQ?Mr'#Jg'#JgO!6kQWO'#JfO!6yQWO'#JeO!7RQWO'#CuOOQ?Mr'#Cx'#CxO!7ZQWO'#CzOOQ?Mr'#DS'#DSOOQ?Mr'#DU'#DUO1SQWO'#DWO!+hQ7[O'#F}O!+hQ7[O'#GPO!7`QWO'#GRO!7eQWO'#GSO!3SQWO'#GYO!+hQ7[O'#G_O!7jQWO'#EnO!8XQWO,5<eOOQ?Mp'#Cr'#CrO!8aQWO'#EoO!9ZQ`O'#EpOOQ?Mp'#J|'#J|O!9bQ?MxO'#K]O9hQ?MxO,5=`O`Q^O,5>pOOQU'#Jc'#JcOOQU,5>q,5>qOOQU-E<X-E<XO!;aQ?NdO,5:_O!9UQ`O,5:]O!=zQ?NdO,5:gO%[Q^O,5:gO!@bQ?NdO,5:iOOQO,5@v,5@vO!ARQ7[O,5=[O!AaQ?MxO'#JdO9RQWO'#JdO!ArQ?MxO,59ZO!A}Q`O,59ZO!BVQ7[O,59ZO:VQ7[O,59ZO!BbQWO,5;WO!BjQWO'#H^O!COQWO'#K`O%[Q^O,5;|O!9UQ`O,5<OO!CWQWO,5=wO!C]QWO,5=wO!CbQWO,5=wO9hQ?MxO,5=wO;wQWO,5=gOOQO'#Cv'#CvO!CpQ`O,5=dO!CxQ7[O,5=eO!DTQWO,5=gO!DYQpO,5=jO!DbQWO'#K[O>tQWO'#HTO9^QWO'#HVO!DgQWO'#HVO:VQ7[O'#HXO!DlQWO'#HXOOQU,5=m,5=mO!DqQWO'#HYO!ESQWO'#CoO!EXQWO,59PO!EcQWO,59PO!GhQ^O,59POOQU,59P,59PO!GxQ?MxO,59PO%[Q^O,59PO!JTQ^O'#HaOOQU'#Hb'#HbOOQU'#Hc'#HcO`Q^O,5=yO!JkQWO,5=yO`Q^O,5>PO`Q^O,5>RO!JpQWO,5>TO`Q^O,5>VO!JuQWO,5>YO!JzQ^O,5>`OOQU,5>f,5>fO%[Q^O,5>fO9hQ?MxO,5>hOOQU,5>j,5>jO# UQWO,5>jOOQU,5>l,5>lO# UQWO,5>lOOQU,5>n,5>nO# rQ`O'#D[O%[Q^O'#JqO# |Q`O'#JqO#!kQ`O'#DjO#!|Q`O'#DjO#%_Q^O'#DjO#%fQWO'#JpO#%nQWO,5:TO#%sQWO'#EqO#&RQWO'#KPO#&ZQWO,5;[O#&`Q`O'#DjO#&mQ`O'#ESOOQ?Mr,5:l,5:lO%[Q^O,5:lO#&tQWO,5:lO>tQWO,5;VO!A}Q`O,5;VO!BVQ7[O,5;VO:VQ7[O,5;VO#&|QWO,5@]O#'RQ(CYO,5:pOOQO-E<b-E<bO#(XQ?NQO,5;OOCrQ`O,5:oO#(cQ`O,5:oOCrQ`O,5;OO!ArQ?MxO,5:oOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#(pQ?MxO,5;OO#({Q?MxO,5;OO!A}Q`O,5:oOOQO,5;U,5;UO#)ZQ?MxO,5;OPOOO'#IY'#IYP#)oO#@ItO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ?Mr1G.p1G.pOOOO-E<Z-E<ZO#)zQpO,59zOOOO-E<]-E<]OOQ?Mr1G/d1G/dO#*PQrO,5>zO+}Q^O,5>zOOQO,5?Q,5?QO#*ZQ^O'#I`OOQO-E<^-E<^O#*hQWO,5@ZO#*pQrO,5@ZO#*wQWO,5@iOOQ?Mr1G/j1G/jO%[Q^O,5@jO#+PQWO'#IfOOQO-E<d-E<dO#*wQWO,5@iOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0V1G0VO%[Q^O,5@gO#+eQ?MxO,5@gO#+vQ?MxO,5@gO#+}QWO,5@fO9WQWO,5@fO#,VQWO,5@fO#,eQWO'#IiO#+}QWO,5@fOOQ?Mp1G0t1G0tO!(XQ`O,5:rO!(dQ`O,5:rOOQQ,5:t,5:tO#-VQYO,5:tO#-_Q7[O1G2vO9^QWO1G2vOOQ?Mr1G0r1G0rO#-mQ?NdO1G0rO#.rQ?NbO,5;SOOQ?Mr'#GU'#GUO#/`Q?NdO'#JgO!$[Q^O1G0rO#1hQrO'#JrO%[Q^O'#JrO#1rQWO,5:bOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#1wQWO1G0{O#4]Q?NdO1G0|O#4dQ?NdO1G0|O#6zQ?NdO1G0|O#7RQ?NdO1G0|O#9iQ?NdO1G0|O#<PQ?NdO1G0|O#<WQ?NdO1G0|O#<_Q?NdO1G0|O#>uQ?NdO1G0|O#>|Q?NdO1G0|O#AZQ07bO'#CiO#CUQ07bO1G1_O#C]Q07bO'#JnO#CpQ?NdO,5?WOOQ?Mp-E<j-E<jO#E}Q?NdO1G0|O#FzQ?NdO1G0|OOQ?Mr1G0|1G0|O#GzQ7[O'#JwO#HUQWO,5:uO#HZQ?NdO1G1bO#H}Q&jO,5<VO#IVQ&jO,5<WO#I_Q&jO'#FnO#IvQWO'#FmOOQO'#KT'#KTOOQO'#Ij'#IjO#I{Q&jO1G1mOOQ?Mr1G1m1G1mOOOS1G1x1G1xO#J^Q07bO'#JmO#JhQWO,5<aO!(oQ^O,5<aOOOS-E<i-E<iOOQ?Mr1G1k1G1kO#JmQ`O'#KSOOQ?Mr,5<c,5<cO#JuQ`O,5<cO!&_Q7[O'#DQOOOO'#I^'#I^O#JzO!0LbO,59jOOQ?Mr,59j,59jO%[Q^O1G2OO!7eQWO'#InO#KVQ7[O,5<xOOQ?Mr,5<u,5<uO!+hQ7[O'#IqO#KuQ7[O,5=UO!+hQ7[O'#IsO#LhQ7[O,5=WO!&_Q7[O,5=YOOQO1G2Q1G2QO#LrQpO'#CrO#MVQ$ISO'#EoO#NUQ`O'#G`O#NrQpO,5<qO#NyQWO'#KWO9WQWO'#KWO$ XQWO,5<sO!+hQ7[O,5<rO$ ^QWO'#GXO$ oQWO,5<rO$ tQpO'#GUO$!RQpO'#KXO$!]QWO'#KXO!&_Q7[O'#KXO$!bQWO,5<vO$!gQ`O'#GaO!5iQ`O'#GaO$!xQWO'#GcO$!}QWO'#GeO!3SQWO'#GhO$#SQ?MxO'#IpO$#_Q`O,5<zOOQ?Mv,5<z,5<zO$#fQ`O'#GaO$#tQ`O'#GbO$#|Q`O'#GbO$$RQ7[O,5=UO$$cQ7[O,5=WOOQ?Mr,5=Z,5=ZO!+hQ7[O,5@QO!+hQ7[O,5@QO$$sQWO'#IuO$%OQWO,5@PO$%WQWO,59aOOQ?Mr,59f,59fO$%zQ!LSO,59rOOQ?Mr'#Jk'#JkO$&mQ7[O,5<iO$'`Q7[O,5<kO@fQWO,5<mOOQ?Mr,5<n,5<nO$'jQWO,5<tO$'oQ7[O,5<yO$(PQWO'#JzO!$[Q^O1G2PO$(UQWO1G2PO9WQWO'#J}O9WQWO'#EqO%[Q^O'#EqO9WQWO'#IwO$(ZQ?MxO,5@wOOQU1G2z1G2zOOQU1G4[1G4[OOQ?Mr1G/y1G/yOOQ?Mr1G/w1G/wO$*]Q?NdO1G0ROOQU1G2v1G2vO!&_Q7[O1G2vO%[Q^O1G2vO#-bQWO1G2vO$,aQ7[O'#EhOOQ?Mp,5@O,5@OO$,kQ?MxO,5@OOOQU1G.u1G.uO!ArQ?MxO1G.uO!A}Q`O1G.uO!BVQ7[O1G.uO$,|QWO1G0rO$-RQWO'#CiO$-^QWO'#KaO$-fQWO,5=xO$-kQWO'#KaO$-pQWO'#KaO$.OQWO'#I}O$.^QWO,5@zO$.fQrO1G1hOOQ?Mr1G1j1G1jO9^QWO1G3cO@fQWO1G3cO$.mQWO1G3cO$.rQWO1G3cOOQU1G3c1G3cO!DTQWO1G3RO!&_Q7[O1G3OO$.wQWO1G3OOOQU1G3P1G3PO!&_Q7[O1G3PO$.|QWO1G3PO$/UQ`O'#G}OOQU1G3R1G3RO!5iQ`O'#IyO!DYQpO1G3UOOQU1G3U1G3UOOQU,5=o,5=oO$/^Q7[O,5=qO9^QWO,5=qO$!}QWO,5=sO9RQWO,5=sO!A}Q`O,5=sO!BVQ7[O,5=sO:VQ7[O,5=sO$/lQWO'#K_O$/wQWO,5=tOOQU1G.k1G.kO$/|Q?MxO1G.kO@fQWO1G.kO$0XQWO1G.kO9hQ?MxO1G.kO$2aQrO,5@|O$2nQWO,5@|O9WQWO,5@|O$2yQ^O,5={O$3QQWO,5={OOQU1G3e1G3eO`Q^O1G3eOOQU1G3k1G3kOOQU1G3m1G3mO>oQWO1G3oO$3VQ^O1G3qO$7ZQ^O'#HpOOQU1G3t1G3tO$7hQWO'#HvO>tQWO'#HxOOQU1G3z1G3zO$7pQ^O1G3zO9hQ?MxO1G4QOOQU1G4S1G4SOOQ?Mp'#G]'#G]O9hQ?MxO1G4UO9hQ?MxO1G4WO$;wQWO,5@]O!(oQ^O,5;]O9WQWO,5;]O>tQWO,5:UO!(oQ^O,5:UO!A}Q`O,5:UO$;|Q07bO,5:UOOQO,5;],5;]O$<WQ`O'#IaO$<nQWO,5@[OOQ?Mr1G/o1G/oO$<vQ`O'#IgO$=QQWO,5@kOOQ?Mp1G0v1G0vO#!|Q`O,5:UOOQO'#Ic'#IcO$=YQ`O,5:nOOQ?Mv,5:n,5:nO#&wQWO1G0WOOQ?Mr1G0W1G0WO%[Q^O1G0WOOQ?Mr1G0q1G0qO>tQWO1G0qO!A}Q`O1G0qO!BVQ7[O1G0qOOQ?Mp1G5w1G5wO!ArQ?MxO1G0ZOOQO1G0j1G0jO%[Q^O1G0jO$=aQ?MxO1G0jO$=lQ?MxO1G0jO!A}Q`O1G0ZOCrQ`O1G0ZO$=zQ?MxO1G0jOOQO1G0Z1G0ZO$>`Q?NdO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$>jQpO,5<gO$>rQrO1G4fOOQO1G4l1G4lO%[Q^O,5>zO$>|QWO1G5uO$?UQWO1G6TO$?^QrO1G6UO9WQWO,5?QO$?hQ?NdO1G6RO%[Q^O1G6RO$?xQ?MxO1G6RO$@ZQWO1G6QO$@ZQWO1G6QO9WQWO1G6QO$@cQWO,5?TO9WQWO,5?TOOQO,5?T,5?TO$@wQWO,5?TO$(PQWO,5?TOOQO-E<g-E<gOOQQ1G0^1G0^OOQQ1G0`1G0`O#-YQWO1G0`OOQU7+(b7+(bO!&_Q7[O7+(bO%[Q^O7+(bO$AVQWO7+(bO$AbQ7[O7+(bO$ApQ?NdO,5=UO$CxQ?NdO,5=WO$FQQ?NdO,5=UO$H`Q?NdO,5=WO$JnQ?NdO,59rO$LsQ?NdO,5<iO$N{Q?NdO,5<kO%#TQ?NdO,5<yOOQ?Mr7+&^7+&^O%%cQ?NdO7+&^O%&VQ^O'#IbO%&dQWO,5@^O%&lQrO,5@^OOQ?Mr1G/|1G/|O%&vQWO7+&gOOQ?Mr7+&g7+&gO%&{Q07bO,5:cO%[Q^O7+&yO%'VQ07bO,5:_O%'dQ07bO,5:gO%'nQ07bO,5:iO%'xQ7[O'#IeO%(SQWO,5@cOOQ?Mr1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%([QtO,5<YO!(oQ^O,5<XOOQO-E<h-E<hOOQ?Mr7+'X7+'XOOOS7+'d7+'dOOOS1G1{1G1{O%(gQWO1G1{OOQ?Mr1G1}1G1}O%(lQpO,59lOOOO-E<[-E<[OOQ?Mr1G/U1G/UO%(sQ?NdO7+'jOOQ?Mr,5?Y,5?YO%)gQpO,5?YOOQ?Mr1G2d1G2dP!&_Q7[O'#InPOQ?Mr-E<l-E<lO%*VQ7[O,5?]OOQ?Mr-E<o-E<oO%*xQ7[O,5?_OOQ?Mr-E<q-E<qO%+SQpO1G2tO%+ZQpO'#CrO%+qQ7[O'#J}O%+xQ^O'#EqOOQ?Mr1G2]1G2]O%,SQWO'#ImO%,hQWO,5@rO%,hQWO,5@rO%,pQWO,5@rO%,{QWO,5@rOOQO1G2_1G2_O%-ZQ7[O1G2^O!+hQ7[O1G2^O%-kQ$ISO'#IoO%-xQWO,5@sO!&_Q7[O,5@sO%.QQpO,5@sOOQ?Mr1G2b1G2bOOQ?Mp,5<{,5<{OOQ?Mp,5<|,5<|O$(PQWO,5<|OCcQWO,5<|O!A}Q`O,5<{OOQO'#Gd'#GdO%.[QWO,5<}OOQ?Mp,5=P,5=PO$(PQWO,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ?Mv1G2f1G2fO!5iQ`O,5<{O%.dQWO,5<|O$!xQWO,5<}O%.oQ`O,5<|O!+hQ7[O'#IqO%/`Q7[O1G2pO!+hQ7[O'#IsO%0RQ7[O1G2rO%0]Q7[O1G5lO%0gQ7[O1G5lOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9UQ`O,59tO%[Q^O,59tOOQ?Mr,5<h,5<hO%0tQWO1G2XO!+hQ7[O1G2`O%0yQ?NdO7+'kOOQ?Mr7+'k7+'kO!$[Q^O7+'kO%1mQWO,5;]OOQ?Mp,5?c,5?cOOQ?Mp-E<u-E<uO%1rQpO'#KYO#&wQWO7+(bO4UQrO7+(bO$AYQWO7+(bO%1|Q?NbO'#CiO%2aQ?NbO,5=QO%3RQWO,5=QOOQ?Mp1G5j1G5jOOQU7+$a7+$aO!ArQ?MxO7+$aO!A}Q`O7+$aO!$[Q^O7+&^O%3WQWO'#I|O%3oQWO,5@{OOQO1G3d1G3dO9^QWO,5@{O%3oQWO,5@{O%3wQWO,5@{OOQO,5?i,5?iOOQO-E<{-E<{OOQ?Mr7+'S7+'SO%3|QWO7+(}O9hQ?MxO7+(}O9^QWO7+(}O@fQWO7+(}OOQU7+(m7+(mO%4RQ?NbO7+(jO!&_Q7[O7+(jO%4]QpO7+(kOOQU7+(k7+(kO!&_Q7[O7+(kO%4dQWO'#K^O%4oQWO,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQU7+(p7+(pO%6RQ`O'#HWOOQU1G3]1G3]O!&_Q7[O1G3]O%[Q^O1G3]O%6YQWO1G3]O%6eQ7[O1G3]O9hQ?MxO1G3_O$!}QWO1G3_O9RQWO1G3_O!A}Q`O1G3_O!BVQ7[O1G3_O%6sQWO'#I{O%7XQWO,5@yO%7aQ`O,5@yOOQ?Mp1G3`1G3`OOQU7+$V7+$VO@fQWO7+$VO9hQ?MxO7+$VO%7lQWO7+$VO%[Q^O1G6hO%[Q^O1G6iO%7qQ?MxO1G6hO%7{Q^O1G3gO%8SQWO1G3gO%8XQ^O1G3gOOQU7+)P7+)PO9hQ?MxO7+)ZO`Q^O7+)]OOQU'#Kd'#KdOOQU'#JO'#JOO%8`Q^O,5>[OOQU,5>[,5>[O%[Q^O'#HqO%8mQWO'#HsOOQU,5>b,5>bO9WQWO,5>bOOQU,5>d,5>dOOQU7+)f7+)fOOQU7+)l7+)lOOQU7+)p7+)pOOQU7+)r7+)rO%8rQ`O1G5wO%9WQ07bO1G0wO%9bQWO1G0wOOQO1G/p1G/pO%9mQ07bO1G/pO>tQWO1G/pO!(oQ^O'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!A}Q`O1G/pOOQO-E<a-E<aOOQ?Mv1G0Y1G0YOOQ?Mr7+%r7+%rO#&wQWO7+%rOOQ?Mr7+&]7+&]O>tQWO7+&]O!A}Q`O7+&]OOQO7+%u7+%uO$>`Q?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%9wQ?MxO7+&UO!ArQ?MxO7+%uO!A}Q`O7+%uO%:SQ?MxO7+&UO%:bQ?NdO7++mO%[Q^O7++mO%:rQWO7++lO%:rQWO7++lOOQO1G4o1G4oO9WQWO1G4oO%:zQWO1G4oOOQQ7+%z7+%zO#&wQWO<<K|O4UQrO<<K|O%;YQWO<<K|OOQU<<K|<<K|O!&_Q7[O<<K|O%[Q^O<<K|O%;bQWO<<K|O%;mQ?NdO,5?]O%=uQ?NdO,5?_O%?}Q?NdO1G2^O%B]Q?NdO1G2pO%DeQ?NdO1G2rO%FmQrO,5>|O%[Q^O,5>|OOQO-E<`-E<`O%FwQWO1G5xOOQ?Mr<<JR<<JRO%GPQ07bO1G0rO%IWQ07bO1G0|O%I_Q07bO1G0|O%K`Q07bO1G0|O%KgQ07bO1G0|O%MhQ07bO1G0|O& iQ07bO1G0|O& pQ07bO1G0|O& wQ07bO1G0|O&#xQ07bO1G0|O&$PQ07bO1G0|O&$WQ?NdO<<JeO&&OQ07bO1G0|O&&{Q07bO1G0|O&'{Q07bO'#JgO&*OQ07bO1G1bO&*]Q07bO1G0RO&*gQ7[O,5?POOQO-E<c-E<cO!(oQ^O'#FpOOQO'#KU'#KUOOQO1G1t1G1tO&*qQWO1G1sO&*vQ07bO,5?WOOOS7+'g7+'gOOOO1G/W1G/WOOQ?Mr1G4t1G4tO!+hQ7[O7+(`O&-WQrO'#CiO&-bQWO,5?XO9WQWO,5?XOOQO-E<k-E<kO&-pQWO1G6^O&-pQWO1G6^O&-xQWO1G6^O&.TQ7[O7+'xO&.eQpO,5?ZO&.oQWO,5?ZO!&_Q7[O,5?ZOOQO-E<m-E<mO&.tQpO1G6_O&/OQWO1G6_OOQ?Mp1G2h1G2hO$(PQWO1G2hOOQ?Mp1G2g1G2gO&/WQWO1G2iO!&_Q7[O1G2iOOQ?Mp1G2n1G2nO!A}Q`O1G2gOCcQWO1G2hO&/]QWO1G2iO&/eQWO1G2hO$!xQWO1G2iO&0XQ7[O,5?]OOQ?Mr-E<p-E<pO&0zQ7[O,5?_OOQ?Mr-E<r-E<rO!+hQ7[O7++WOOQ?Mr1G/`1G/`O&1UQWO1G/`OOQ?Mr7+'s7+'sO&1ZQ7[O7+'zO&1kQ?NdO<<KVOOQ?Mr<<KV<<KVO&2_QWO1G0wO!&_Q7[O'#IvO&2dQWO,5@tO&4fQrO<<K|O!&_Q7[O1G2lOOQU<<G{<<G{O!ArQ?MxO<<G{O&4mQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?h,5?hO&5aQWO,5?hO&5fQWO,5?hOOQO-E<z-E<zO&5tQWO1G6gO&5tQWO1G6gO9^QWO1G6gO@fQWO<<LiOOQU<<Li<<LiO&5|QWO<<LiO9hQ?MxO<<LiOOQU<<LU<<LUO%4RQ?NbO<<LUOOQU<<LV<<LVO%4]QpO<<LVO&6RQ`O'#IxO&6^QWO,5@xO!(oQ^O,5@xOOQU1G3T1G3TO%+xQ^O'#JqOOQO'#Iz'#IzO9hQ?MxO'#IzO&6fQ`O,5=rOOQU,5=r,5=rO&6mQ`O'#EdO&7RQ`O'#GcO&7WQWO7+(wO&7]QWO7+(wOOQU7+(w7+(wO!&_Q7[O7+(wO%[Q^O7+(wO&7eQWO7+(wOOQU7+(y7+(yO9hQ?MxO7+(yO$!}QWO7+(yO9RQWO7+(yO!A}Q`O7+(yO&7pQWO,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&7{QWO1G6eO9hQ?MxO<<GqOOQU<<Gq<<GqO@fQWO<<GqO&8TQWO7+,SO&8YQWO7+,TO%[Q^O7+,SO%[Q^O7+,TOOQU7+)R7+)RO&8_QWO7+)RO&8dQ^O7+)RO&8kQWO7+)ROOQU<<Lu<<LuOOQU<<Lw<<LwOOQU-E<|-E<|OOQU1G3v1G3vO&8pQWO,5>]OOQU,5>_,5>_O&8uQWO1G3|O9WQWO7+&cO!(oQ^O7+&cOOQO7+%[7+%[O&8zQ07bO1G6UO>tQWO7+%[OOQ?Mr<<I^<<I^OOQ?Mr<<Iw<<IwO>tQWO<<IwOOQO<<Ip<<IpO$>`Q?NdO<<IpO%[Q^O<<IpOOQO<<Ia<<IaO!ArQ?MxO<<IaO&9UQ?MxO<<IpO&9aQ?NdO<= XO&9qQWO<= WOOQO7+*Z7+*ZO9WQWO7+*ZOOQUANAhANAhO&9yQrOANAhO!&_Q7[OANAhO#&wQWOANAhO4UQrOANAhO&:QQWOANAhO%[Q^OANAhO&:YQ?NdO7+'xO&<hQ?NdO,5?]O&>pQ?NdO,5?_O&@xQ?NdO7+'zO&CWQrO1G4hO&CbQ07bO7+&^O&EcQ07bO,5=UO&GgQ07bO,5=WO&GwQ07bO,5=UO&HXQ07bO,5=WO&HiQ07bO,59rO&JlQ07bO,5<iO&LlQ07bO,5<kO&N}Q07bO,5<yO'!pQ07bO7+'jO'!}Q07bO7+'kO'#[QWO,5<[OOQO7+'_7+'_O'#aQ7[O<<KzOOQO1G4s1G4sO'#hQWO1G4sO'#sQWO1G4sO'$RQWO7++xO'$RQWO7++xO!&_Q7[O1G4uO'$ZQpO1G4uO'$eQWO7++yOOQ?Mp7+(S7+(SO'$mQWO7+(TO'$xQpO7+(TOOQ?Mp7+(R7+(RO$(PQWO7+(SO'%PQWO7+(TO!&_Q7[O7+(TOCcQWO7+(SO'%UQWO7+(TO'%^Q7[O<<NrOOQ?Mr7+$z7+$zO'%hQpO,5?bOOQO-E<t-E<tO'%rQ?NbO7+(WOOQUAN=gAN=gO9^QWO1G5SOOQO1G5S1G5SO'&SQWO1G5SO'&XQWO7+,RO'&XQWO7+,RO9hQ?MxOANBTO@fQWOANBTOOQUANBTANBTOOQUANApANApOOQUANAqANAqO'&aQWO,5?dOOQO-E<v-E<vO'&lQ07bO1G6dOOQO,5?f,5?fOOQO-E<x-E<xOOQU1G3^1G3^O%+xQ^O,5<}O'&vQWO,5<}OOQU<<Lc<<LcO!&_Q7[O<<LcO&7WQWO<<LcO'&{QWO<<LcO%[Q^O<<LcOOQU<<Le<<LeO9hQ?MxO<<LeO$!}QWO<<LeO9RQWO<<LeO''TQ`O1G5RO''`QWO7+,POOQUAN=]AN=]O9hQ?MxOAN=]OOQU<= n<= nOOQU<= o<= oO''hQWO<= nO''mQWO<= oOOQU<<Lm<<LmO''rQWO<<LmO''wQ^O<<LmOOQU1G3w1G3wO>tQWO7+)hO'(OQWO<<I}O'(ZQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$>`Q?NdOAN?[OOQOAN>{AN>{O%[Q^OAN?[OOQO<<Mu<<MuOOQUG27SG27SO!&_Q7[OG27SO#&wQWOG27SO'(eQrOG27SO4UQrOG27SO'(lQWOG27SO'(tQ07bO<<JeO')RQ07bO1G2^O'*tQ07bO,5?]O',tQ07bO,5?_O'.tQ07bO1G2pO'0tQ07bO1G2rO'2tQ07bO<<KVO'3RQ07bO<<IxOOQO1G1v1G1vO!+hQ7[OANAfOOQO7+*_7+*_O'3`QWO7+*_O'3kQWO<= dO'3sQpO7+*aOOQ?Mp<<Ko<<KoO$(PQWO<<KoOCcQWO<<KoO'3}QWO<<KoOOQ?Mp<<Kn<<KnO'4YQpO<<KoO$(PQWO<<KnO'4aQWO<<KoO!&_Q7[O<<KoOOQO7+*n7+*nO9^QWO7+*nO'4fQWO<= mOOQUG27oG27oO9hQ?MxOG27oO!(oQ^O1G5OO'4nQWO7+,OO&7WQWOANA}OOQUANA}ANA}O!&_Q7[OANA}O'4vQWOANA}OOQUANBPANBPO9hQ?MxOANBPO$!}QWOANBPOOQO'#H['#H[OOQO7+*m7+*mOOQUG22wG22wOOQUANEYANEYOOQUANEZANEZOOQUANBXANBXO'5OQWOANBXOOQU<<MS<<MSO!(oQ^OAN?iOOQOG24vG24vO$>`Q?NdOG24vO#&wQWOLD,nOOQULD,nLD,nO!&_Q7[OLD,nO'5TQrOLD,nO'5[Q07bO7+'xO'6}Q07bO,5?]O'8}Q07bO,5?_O':}Q07bO7+'zO'<pQ7[OG27QOOQO<<My<<MyOOQ?MpANAZANAZO$(PQWOANAZOCcQWOANAZO'=QQWOANAZOOQ?MpANAYANAYO'=]QpOANAZOOQO<<NY<<NYOOQULD-ZLD-ZO'=dQ07bO7+*jOOQUG27iG27iO&7WQWOG27iO!&_Q7[OG27iOOQUG27kG27kO9hQ?MxOG27kOOQUG27sG27sO'=nQ07bOG25TOOQOLD*bLD*bOOQU!$(!Y!$(!YO#&wQWO!$(!YO!&_Q7[O!$(!YO'=xQ?NdOG27QOOQ?MpG26uG26uO$(PQWOG26uOCcQWOG26uO'@WQWOG26uOOQULD-TLD-TO&7WQWOLD-TOOQULD-VLD-VOOQU!)9Et!)9EtO#&wQWO!)9EtOOQ?MpLD,aLD,aO$(PQWOLD,aOCcQWOLD,aOOQU!$(!o!$(!oOOQU!.K;`!.K;`O'@cQ07bOG27QOOQ?Mp!$( {!$( {O$(PQWO!$( {OOQ?Mp!)9Eg!)9EgO!(oQ^O'#DwO1PQWO'#EUO'BUQrO'#JmO'B]QMnO'#DsO'BdQ^O'#D{O'BkQrO'#CiO'ERQrO'#CiO!(oQ^O'#D}O'EcQ^O,5;WO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O'#IlO'GfQWO,5<gO!(oQ^O,5;bO'GnQ7[O,5;bO'IXQ7[O,5;bO!(oQ^O,5;vO!&_Q7[O'#GjO'GnQ7[O'#GjO!&_Q7[O'#GlO'GnQ7[O'#GlO1SQWO'#DWO1SQWO'#DWO!&_Q7[O'#F}O'GnQ7[O'#F}O!&_Q7[O'#GPO'GnQ7[O'#GPO!&_Q7[O'#G_O'GnQ7[O'#G_O!(oQ^O,5:gO'I`Q`O'#D[O!(oQ^O,5@jO'EcQ^O1G0rO'IjQ07bO'#CiO!(oQ^O1G2OO!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO'ItQpO'#CrO!&_Q7[O,5<rO'GnQ7[O,5<rO'EcQ^O1G2PO!(oQ^O7+&yO!&_Q7[O1G2^O'GnQ7[O1G2^O!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO!&_Q7[O1G2`O'GnQ7[O1G2`O'EcQ^O7+'kO'EcQ^O7+&^O!&_Q7[OANAfO'GnQ7[OANAfO'JXQWO'#ElO'J^QWO'#ElO'JfQWO'#F[O'JkQWO'#EvO'JpQWO'#KOO'J{QWO'#J|O'KWQWO,5;WO'K]Q7[O,5<dO'KdQWO'#GWO'KiQWO'#GWO'KnQWO,5<eO'KvQWO,5;WO'LOQ07bO1G1_O'LVQWO,5<rO'L[QWO,5<rO'LaQWO,5<tO'LfQWO,5<tO'LkQWO1G2PO'LpQWO1G0rO'LuQ7[O<<KzO'L|Q7[O<<KzO7eQ7[O'#FzO9RQWO'#FyOAaQWO'#EkO!(oQ^O,5;sO!3SQWO'#GWO!3SQWO'#GWO!3SQWO'#GYO!3SQWO'#GYO!+hQ7[O7+(`O!+hQ7[O7+(`O%+SQpO1G2tO%+SQpO1G2tO!&_Q7[O,5=YO!&_Q7[O,5=Y",
    stateData:
      "'NQ~O'wOS'xOSTOS'yRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(OSO(QTO(TUO([VO(j[O(yiO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O'y!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'u]X([]X(m]X(t]X(u]X~O!d%PX~P(qO_!}O(Q#PO(R!}O(S#PO~O_#QO(S#PO(T#PO(U#QO~Ou#SO!R#TO(]#TO(^#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O;UO(QTO(TUO([VO(j[O(yiO~O!X#ZO!Y#WO!V(cP!V(qP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(QTO(TUO([VO(j[O(yiO~Om#mO!X#iO!y]O#f#lO#g#iO(O;VO!h(nP~P.iO!i#oO(O#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa(aX'u(aX's(aX!h(aX!V(aX![(aX%f(aX!d(aX~P1qO#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX![(bX%f(bX~Oa(bX'u(bX's(bX!V(bX!h(bXs(bX!d(bX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O$sO(QTO(TUO([$uO(t$}O(u%POg(XP~O!i%cO~O!P%fO![%gO(O%eO~O!d%kO~Oa%lO'u%lO~O}%pO~P%[O(P!lO~P%[O%k%tO~P%[Oh%VO!i%cO(O%eO(P!lO~Oe%{O!i%cO(O%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(O%eO(P!lO(QTO(TUO`)SP~O!u#sO~O%p&VO!P)OX![)OX(O)OX~O(O&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(P!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'u%lO~Oa%lO't&{O'u%lO~Oa%lO't&}O'u%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(P!lO(QTO(TUO~Op'RO!P'QO!X'UO(`'PO!Z(dP!Z(sP~P@YOk'_O![']O(O%eO~Oe'dO!i%cO(O%eO~O}&QO!i&PO~Op!nO!P!oO!y;QO#Q!pO#R!pO#T!pO#U!pO(P!lO(QTO(TUO(`!mO(j!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'u%lO(m'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(QTO(TUO(`!mO(j!sO~O![XOp(hX!P(hX!_(hX!`(hX!a(hX!y(hX#Q(hX#R(hX#S(hX#T(hX#U(hX#X(hX#Y(hX(P(hX(Q(hX(T(hX(`(hX(j(hX~O!`'iO!a'iO(P!lO~PCrO'z'uO'{'uO'|'wO~O_!}O(Q'yO(R!}O(S'yO~O_#QO(S'yO(T'yO(U#QO~Ou#SO!R#TO(]#TO(^'}O~O!X(PO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(RO!V(cX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(RO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~O!V(cX~PGfO!V(WO~O!V(pX!Y(pX!d(pX!h(pX(m(pX~O#](pX#h#aX!Z(pX~PIiO#](XO!V(rX!Y(rX~O!Y(YO!V(qX~O!V(]O~O#]$eO~PIiO!Z(^O~P`OR#zO}#yO!P#{O!i#xO([VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(m!ka(t!ka(u!ka~Oa!ka'u!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKPO!h(_O~O!d#vO#](`O(m'mO!Y(oXa(oX'u(oX~O!h(oX~PMlO!P%fO![%gO!y]O#f(eO#g(dO(O%eO~O!Y(fO!h(nX~O!h(hO~O!P%fO![%gO#g(dO(O%eO~OP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O!d#vO!h(bX~P! YOR(jO}(iO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(O!xa~P!#ZO!u(nO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#h(tO~O!X(vO!h(fP~P%[O(`(xO(j[O~O!P(zO!i#xO(`(xO(j[O~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y$_Oa$oa'u$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)`O~P!&_Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~Og(kP~P!+hO})eO!d)dO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)dO![(vX$Y(vX$[(vX$^(vX$e(vX~O})eO~P!-qO})eO![(vX$Y(vX$[(vX$^(vX$e(vX~O![)gO$Y)kO$[)fO$^)fO$e)lO~O!X)oO~P!(oO$[$hO$^$gO$e)sO~Ok$xX}$xX!P$xX#P$xX(t$xX(u$xX~OgjXg$xXkjX!YjX#]jX~P!/gOu)uO(])vO(^)xO~Ok*RO})zO!P){O(t$}O(u%PO~Og)yO~P!0kOg*SO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P*UO![*VO!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~O!X*YO(O*TO!h(zP~P!1YO#h*[O~O!i*]O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O*_O(QTO(TUO([$uO(t$}O(u%PO~O!X*bO!V({P~P!3XOo*nO!P*fO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO(`!mO~O!Z*kO~P!4|O#P$dOk(ZX}(ZX!P(ZX(t(ZX(u(ZX!Y(ZX#](ZX~Og(ZX#}(ZX~P!5uOk*sO#]*rOg(YX!Y(YX~O!Y*tOg(XX~O(O&WOg(XP~Op*wO~O!i*|O~O(O(rO~Om+QO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(O%eO!h(nP~O!d#vO#h+RO~O!P%fO!X+TO!Y(YO![%gO(O%eO!V(qP~Op'XO!P+VO!X+UO(QTO(TUO(`(xO~O!Z(sP~P!8uO!Y+WOa)PX'u)PX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa!ga!Y!ga'u!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9mOR#zO}#yO!P#{O!i#xO([VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(m!oa(t!oa(u!oa~Oa!oa'u!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<TOR#zO}#yO!P#{O!i#xO([VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(m!qa(t!qa(u!qa~Oa!qa'u!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>kOh%VOk+aO![']O%f+`O~O!d+cOa(WX![(WX'u(WX!Y(WX~Oa%lO![XO'u%lO~Oh%VO!i%cO~Oh%VO!i%cO(O%eO~O!d#vO#h(tO~Ob+nO%g+oO(O+kO(QTO(TUO!Z)TP~O!Y+pO`)SX~O[+tO~O`+uO~O![%}O(O%eO(P!lO`)SP~Oh%VO#]+zO~Oh%VOk+}O![$|O~O![,PO~O},RO![XO~O%k%tO~O!u,WO~Oe,]O~Ob,^O(O#nO(QTO(TUO!Z)RP~Oe%{O~O%g!QO(O&WO~P=RO[,cO`,bO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(QTO(TUO([VO(j[O(yiO~O![!eO!r!gO$V!kO(O!dO~P!EkO`,bOa%lO'u%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa,hO!rwO#t!OO%i!OO%j!OO%k!OO~P!HTO!i&lO~O&Y,nO~O![,pO~O&k,rO&m,sOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(O&ha(Q&ha(T&ha([&ha(j&ha(y&ha!Z&ha&a&hab&ha&f&ha~O(O,xO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# ZO!d,}O#],|Oh(eX!Y#eX!Y(eX!Z#eX!Z(eX!d(eX!i(eX~Oh%VO!d-PO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(QTO(TUO(`!mO~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(QTO(TUO([VO(j[O(y<xO~O(O;zO~P##_O!Y-TO!Z(dX~O!Z-VO~O!d,}O#],|O!Y#eX!Z#eX~O!Y-WO!Z(sX~O!Z-YO~O!`-ZO!a-ZO(P!lO~P#!|O!Z-^O~P'_Ok-aO![']O~O!V-fO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(P!xa(Q!xa(T!xa(`!xa(j!xa~P!#ZO!m-kO#]-iO~PCSO!`-mO!a-mO(P!lO~PCrOa%lO#]-iO'u%lO~Oa%lO!d#vO#]-iO'u%lO~Oa%lO!d#vO!m-kO#]-iO'u%lO(m'mO~O'z'uO'{'uO'|-rO~Os-sO~O!V'Sa!Y'Sa~P!9mO!X-wO!V'SX!Y'SX~P%[O!Y(RO!V(ca~O!V(ca~PGfO!Y(YO!V(qa~O!P%fO!X-{O![%gO(O%eO!V'YX!Y'YX~O#]-}O!Y(oa!h(oaa(oa'u(oa~O!d#vO~P#+eO!Y(fO!h(na~O!P%fO![%gO#g.RO(O%eO~Om.WO!P%fO!X.TO![%gO!y]O#f.VO#g.TO(O%eO!Y']X!h']X~OR.[O!i#xO~Oh%VOk._O![']O%f.^O~Oa#`i!Y#`i'u#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9mOk=UO})zO!P){O(t$}O(u%PO~O#h#[aa#[a#]#[a'u#[a!Y#[a!h#[a![#[a!V#[a~P#.aO#h(ZXP(ZXR(ZX[(ZXa(ZXo(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX'u(ZX([(ZX(m(ZX!h(ZX!V(ZX's(ZXs(ZX![(ZX%f(ZX!d(ZX~P!5uO!Y.lO!h(fX~P!9mO!h.oO~O!V.qO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#1|O#k$OO~P#1|OP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#4kO#o$QO~P#4kOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO([VOa#ji!Y#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO([VO(u#}Oa#ji!Y#ji#y#ji#z#ji'u#ji(m#ji(t#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#9pO#w#ji~P#9pO#u$SO~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO([VO(t#|O(u#}Oa#ji!Y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<fO#y$WO~P#<fOP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X!Y]X!Z]X~O#}]X~P#?TOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O#y;bO#z;cO([VO(m$YO(t#|O(u#}O~O#}.sO~P#AbO#P$dO#];iO$P;iO#}(bX!Z(bX~P! YOa'`a!Y'`a'u'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9mO[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO(t#ji(u#ji~P#DdOk=UO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P#DdO!Y.wOg(kX~P!0kOg.yO~Oa$Oi!Y$Oi'u$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9mO$[.zO$^.zO~O$[.{O$^.{O~O!d)dO#].|O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X.}O~O![)gO$Y/PO$[)fO$^)fO$e/QO~O!Y;dO!Z(aX~P#AbO!Z/RO~O!d)dO$e(vX~O$e/TO~Ou)uO(])vO(^/WO~O!V/[O~P!&_O(t$}Ok%^a}%^a!P%^a(u%^a!Y%^a#]%^a~Og%^a#}%^a~P#K^O(u%POk%`a}%`a!P%`a(t%`a!Y%`a#]%`a~Og%`a#}%`a~P#LPO!YfX!dfX!hfX!h$xX(mfX~P!/gO!X/eO!Y(YO(O/dO!V(qP!V({P~P!1YOo*nO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO~Op'XO!P/fO!X+UO!Z*kO(QTO(TUO(`;wO!Z(sP~P#MjO!h/gO~P#.aO!Y/hO!d#vO(m'mO!h(zX~O!h/mO~O!P%fO!X*YO![%gO(O%eO!h(zP~O#h/oO~O!V$xX!Y$xX!d%PX~P!/gO!Y/pO!V({X~P#.aO!d/rO~O!V/tO~Oh%VOo/xO!d#vO!i%cO(m'mO~O(O/zO~O!d+cO~Oa%lO!Y0OO'u%lO~O!Z0QO~P!4|O!`0RO!a0RO(P!lO(`!mO~O!P0TO(`!mO~O#X0UO~Og%^a!Y%^a#]%^a#}%^a~P!0kOg%`a!Y%`a#]%`a#}%`a~P!0kO(O&WOg'iX!Y'iX~O!Y*tOg(Xa~Og0_O~OR0`O}0`O!P0aO#P$dOkza(tza(uza!Yza#]za~Ogza#}za~P$%]O})zO!P){Ok$qa(t$qa(u$qa!Y$qa#]$qa~Og$qa#}$qa~P$&UO})zO!P){Ok$sa(t$sa(u$sa!Y$sa#]$sa~Og$sa#}$sa~P$&wO#h0dO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0kO!d#vO~O#h0gO~O!Y+WOa)Pa'u)Pa~OR#zO}#yO!P#{O!i#xO([VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(m!oi(t!oi(u!oi~Oa!oi'u!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$(fOh%VOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~Om0pO(O0oO~P$*|O!d+cOa(Wa![(Wa'u(Wa!Y(Wa~O#h0vO~O[]X!YfX!ZfX~O!Y0wO!Z)TX~O!Z0yO~O[0zO~Ob0|O(O+kO(QTO(TUO~O![%}O(O%eO`'qX!Y'qX~O!Y+pO`)Sa~O!h1PO~P!9mO[1SO~O`1TO~O#]1WO~Ok1ZO![$|O~O(`(xO!Z)QP~Oh%VOk1dO![1aO%f1cO~O[1nO!Y1lO!Z)RX~O!Z1oO~O`1qOa%lO'u%lO~O(O#nO(QTO(TUO~O#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O#s1tO&W1uOa(bX~P$0dO#]$eO#s1tO&W1uO~Oa1wO~P%[Oa1yO~O&a1|OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(O&_i(Q&_i(T&_i([&_i(j&_i(y&_i!Z&_ib&_i&f&_i~Ob2SO!Z2QO&f2RO~P`O![XO!i2UO~O&m,sOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(O&hi(Q&hi(T&hi([&hi(j&hi(y&hi!Z&hi&a&hib&hi&f&hi~O!V2[O~O!Y!^a!Z!^a~P#AbOp!nO!P!oO!X2bO(`!mO!Y'TX!Z'TX~P@YO!Y-TO!Z(da~O!Y'ZX!Z'ZX~P!8uO!Y-WO!Z(sa~O!Z2iO~P'_Oa%lO#]2rO'u%lO~Oa%lO!d#vO#]2rO'u%lO~Oa%lO!d#vO!m2vO#]2rO'u%lO(m'mO~Oa%lO'u%lO~P!9mO!Y$_Os$oa~O!V'Si!Y'Si~P!9mO!Y(RO!V(ci~O!Y(YO!V(qi~O!V(ri!Y(ri~P!9mO!Y(oi!h(oia(oi'u(oi~P!9mO#]2xO!Y(oi!h(oia(oi'u(oi~O!Y(fO!h(ni~O!P%fO![%gO!y]O#f2}O#g2|O(O%eO~O!P%fO![%gO#g2|O(O%eO~Ok3UO![']O%f3TO~Oh%VOk3UO![']O%f3TO~O#h%^aP%^aR%^a[%^aa%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K^O#h%`aP%`aR%`a[%`aa%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LPO#h%^aP%^aR%^a[%^aa%^ao%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.aO#h%`aP%`aR%`a[%`aa%`ao%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.aO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'uza([za(mza!hza!Vza'szasza![za%fza!dza~P$%]O#h$qaP$qaR$qa[$qaa$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'u$qa([$qa(m$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$&UO#h$saP$saR$sa[$saa$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'u$sa([$sa(m$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$&wO#h%RaP%RaR%Ra[%Raa%Rao%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'u%Ra([%Ra(m%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.aOa#`q!Y#`q'u#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9mO!X3^O!Y'UX!h'UX~P%[O!Y.lO!h(fa~O!Y.lO!h(fa~P!9mO!V3aO~O#}!ka!Z!ka~PKPO#}!ga!Y!ga!Z!ga~P#AbO#}!oa!Z!oa~P!<TO#}!qa!Z!qa~P!>kOg'XX!Y'XX~P!+hO!Y.wOg(ka~OSfO![3uO$c3vO~O!Z3zO~Os3{O~P#.aOa$lq!Y$lq'u$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9mO!V3|O~P#.aO})zO!P){O(u%POk'ea(t'ea!Y'ea#]'ea~Og'ea#}'ea~P%)nO})zO!P){Ok'ga(t'ga(u'ga!Y'ga#]'ga~Og'ga#}'ga~P%*aO(m$YO~P#.aO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/gO(O<QO~P!1YOmkO(O4OO~P.iO!P%fO!X4QO![%gO(O%eO!Y'aX!h'aX~O!Y/hO!h(za~O!Y/hO!d#vO!h(za~O!Y/hO!d#vO(m'mO!h(za~Og$zi!Y$zi#]$zi#}$zi~P!0kO!X4YO!V'cX!Y'cX~P!3XO!Y/pO!V({a~O!Y/pO!V({a~P#.aO!d#vO#s4bO~Oo4eO!d#vO(m'mO~O!P4hO(`!mO~O(t$}Ok%^i}%^i!P%^i(u%^i!Y%^i#]%^i~Og%^i#}%^i~P%.wO(u%POk%`i}%`i!P%`i(t%`i!Y%`i#]%`i~Og%`i#}%`i~P%/jOg(Yi!Y(Yi~P!0kO#]4mOg(Yi!Y(Yi~P!0kO!h4pO~Oa$mq!Y$mq'u$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9mO!V4tO~O!Y4uO![(|X~P#.aOa$xX![$xX%Z]X'u$xX!Y$xX~P!/gO%Z4xOalXklX}lX!PlX![lX'ulX(tlX(ulX!YlX~O%Z4xO~Ob5OO%g5PO(O+kO(QTO(TUO!Y'pX!Z'pX~O!Y0wO!Z)Ta~O[5TO~O`5UO~Oa%lO'u%lO~P#.aO![$|O~P#.aO!Y5^O#]5`O!Z)QX~O!Z5aO~Oo5hOp!nO!P5bO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5gO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O!Z5fO~P%4tOk5mO![1aO%f5lO~Oh%VOk5mO![1aO%f5lO~Ob5tO(O#nO(QTO(TUO!Y'oX!Z'oX~O!Y1lO!Z)Ra~O(QTO(TUO(`5vO~O`5zO~O#s5}O&W6OO~PMlO!h6PO~P%[Oa6RO~Oa6RO~P%[Ob2SO!Z6WO&f2RO~P`O!d6YO~O!d6[Oh(ei!Y(ei!Z(ei!d(ei!i(ei~O!Y#ei!Z#ei~P#AbO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AbOa%lO#]6fO'u%lO~Oa%lO!d#vO#]6fO'u%lO~O!Y(oq!h(oqa(oq'u(oq~P!9mO!Y(fO!h(nq~O!P%fO![%gO#g6mO(O%eO~O![']O%f6pO~Ok6tO![']O%f6pO~O#h'eaP'eaR'ea['eaa'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'u'ea(['ea(m'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%)nO#h'gaP'gaR'ga['gaa'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'u'ga(['ga(m'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%*aO#h$ziP$ziR$zi[$zia$zio$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'u$zi([$zi(m$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.aO#h%^iP%^iR%^i[%^ia%^io%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'u%^i([%^i(m%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%.wO#h%`iP%`iR%`i[%`ia%`io%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'u%`i([%`i(m%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%/jO!Y'Ua!h'Ua~P!9mO!Y.lO!h(fi~O#}#`i!Y#`i!Z#`i~P#AbOP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#k#ji~P%G^O#k;YO~P%G^OP$[OR#zOo;fO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#o#ji~P%IfO#o;[O~P%IfOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O([VO#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#u#ji~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O([VO(u#}O#y#ji#z#ji#}#ji(m#ji(t#ji!Y#ji!Z#ji~O#w;`O~P%MoO#w#ji~P%MoO#u;^O~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O([VO(t#|O(u#}O#z#ji#}#ji(m#ji!Y#ji!Z#ji~O#y#ji~P&!OO#y;bO~P&!OOa#{y!Y#{y'u#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9mO[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO(t#ji(u#ji~P&$zOk=VO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P&$zO#P$dOP(ZXR(ZX[(ZXk(ZXo(ZX}(ZX!P(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX#}(ZX([(ZX(m(ZX(t(ZX(u(ZX!Y(ZX!Z(ZX~O#}$Oi!Y$Oi!Z$Oi~P#AbO#}!oi!Z!oi~P$(fOg'Xa!Y'Xa~P!0kO!Z7WO~O!Y'`a!Z'`a~P#AbOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!d%WX#s%WX~P&+QO!d#vO(m'mO!Y'aa!h'aa~O!Y/hO!h(zi~O!Y/hO!d#vO!h(zi~Og$zq!Y$zq#]$zq#}$zq~P!0kO!V'ca!Y'ca~P#.aO!d7_O~O!Y/pO!V({i~P#.aO!Y/pO!V({i~O!V7cO~O!d#vO#s7hO~Oo7iO!d#vO(m'mO~O})zO!P){O(u%POk'fa(t'fa!Y'fa#]'fa~Og'fa#}'fa~P&/pO})zO!P){Ok'ha(t'ha(u'ha!Y'ha#]'ha~Og'ha#}'ha~P&0cO!V7lO~Og$|q!Y$|q#]$|q#}$|q~P!0kOa$my!Y$my'u$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9mO!d6[O~O!Y4uO![(|a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa([$Sa(m$Sa(t$Sa(u$Sa~O%f6pO~P&2lOa#`y!Y#`y'u#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9mO[7qO~Ob7sO(O+kO(QTO(TUO~O!Y0wO!Z)Ti~O`7wO~O(`(xO!Y'lX!Z'lX~O!Y5^O!Z)Qa~O!Z8QO~P%4tOp!nO!P8RO(QTO(TUO(`!mO(j!sO~O#X8SO~O![1aO~O![1aO%f8UO~Ok8XO![1aO%f8UO~O[8^O!Y'oa!Z'oa~O!Y1lO!Z)Ri~O!h8bO~O!h8cO~O!h8fO~O!h8fO~P%[Oa8hO~O!d8iO~O!h8jO~O!Y(ri!Z(ri~P#AbOa%lO#]8rO'u%lO~O!Y(oy!h(oya(oy'u(oy~P!9mO!Y(fO!h(ny~O%f8uO~P&2lO![']O%f8uO~O#h$zqP$zqR$zq[$zqa$zqo$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'u$zq([$zq(m$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.aO#h'faP'faR'fa['faa'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'u'fa(['fa(m'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&/pO#h'haP'haR'ha['haa'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'u'ha(['ha(m'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&0cO#h$|qP$|qR$|q[$|qa$|qo$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'u$|q([$|q(m$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.aO!Y'Ui!h'Ui~P!9mO#}#`q!Y#`q!Z#`q~P#AbO(t$}OP%^aR%^a[%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a([%^a(m%^a!Y%^a!Z%^a~Ok%^a}%^a!P%^a(u%^a~P&CoO(u%POP%`aR%`a[%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a([%`a(m%`a!Y%`a!Z%`a~Ok%`a}%`a!P%`a(t%`a~P&EsOk=VO})zO!P){O(u%PO~P&CoOk=VO})zO!P){O(t$}O~P&EsOR0`O}0`O!P0aO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za([za(mza(tza(uza!Yza!Zza~O})zO!P){OP$qaR$qa[$qak$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa([$qa(m$qa(t$qa(u$qa!Y$qa!Z$qa~O})zO!P){OP$saR$sa[$sak$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa([$sa(m$sa(t$sa(u$sa!Y$sa!Z$sa~Ok=VO})zO!P){O(t$}O(u%PO~OP%RaR%Ra[%Rao%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra([%Ra(m%Ra!Y%Ra!Z%Ra~P&NlO#}$lq!Y$lq!Z$lq~P#AbO#}$mq!Y$mq!Z$mq~P#AbO!Z9SO~O#}9TO~P!0kO!d#vO!Y'ai!h'ai~O!d#vO(m'mO!Y'ai!h'ai~O!Y/hO!h(zq~O!V'ci!Y'ci~P#.aO!Y/pO!V({q~Oo9[O!d#vO(m'mO~O!V9]O~P#.aO!V9]O~O!d#vO#s9bO~Og(Yy!Y(Yy~P!0kO!Y'ja!['ja~P#.aOa%Yq![%Yq'u%Yq!Y%Yq~P#.aO[9dO~O!Y0wO!Z)Tq~O#]9hO!Y'la!Z'la~O!Y5^O!Z)Qi~P#AbO!P4hO~O![1aO%f9lO~O(QTO(TUO(`9qO~O!Y1lO!Z)Rq~O!h9tO~O!h9uO~O!h9vO~O!h9vO~P%[O#]9yO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AbO%f:OO~P&2lO![']O%f:OO~O#}#{y!Y#{y!Z#{y~P#AbOP$ziR$zi[$zio$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi([$zi(m$zi!Y$zi!Z$zi~P&NlO})zO!P){O(u%POP'eaR'ea['eak'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(['ea(m'ea(t'ea!Y'ea!Z'ea~O})zO!P){OP'gaR'ga['gak'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(['ga(m'ga(t'ga(u'ga!Y'ga!Z'ga~O(t$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i([%^i(m%^i(u%^i!Y%^i!Z%^i~O(u%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i([%`i(m%`i(t%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AbO#}#`y!Y#`y!Z#`y~P#AbO!d#vO!Y'aq!h'aq~O!Y/hO!h(zy~O!V'cq!Y'cq~P#.aOo:YO!d#vO(m'mO~O!V:ZO~P#.aO!V:ZO~O!Y0wO!Z)Ty~O!Y5^O!Z)Qq~O![1aO%f:cO~O!h:fO~O%f:kO~P&2lOP$zqR$zq[$zqo$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq([$zq(m$zq!Y$zq!Z$zq~P&NlO})zO!P){O(u%POP'faR'fa['fak'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(['fa(m'fa(t'fa!Y'fa!Z'fa~O})zO!P){OP'haR'ha['hak'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(['ha(m'ha(t'ha(u'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q([$|q(m$|q!Y$|q!Z$|q~P&NlOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0kOo:oO!d#vO(m'mO~O!V:pO~P#.aO!Y'lq!Z'lq~P#AbO!Y#e!Z!Z#e!Z~P#AbO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'u%b!Z([%b!Z(m%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.aOo:xO!d#vO(m'mO~OP%b!ZR%b!Z[%b!Zo%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z([%b!Z(m%b!Z!Y%b!Z!Z%b!Z~P&NlOs(aX~P1qO}%pO~P!(oO(P!lO~P!(oO!VfX!YfX#]fX~P&+QOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!dfX!h]X!hfX(mfX~P'BxOP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![XO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y;dO!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;oO!P${O![$|O!f=PO!i$xO#g;uO$V%_O$r;qO$t;sO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#t)`O~P'GnOo!bX(m!bX~P# ZO!Z]X!ZfX~P'BxO!VfX!V$xX!YfX!Y$xX#]fX~P!/gO#h;XO~O!d#vO#h;XO~O#];iO~O#s;]O~O#];xO!Y(rX!Z(rX~O#];iO!Y(pX!Z(pX~O#h;yO~Og;{O~P!0kO#h<RO~O#h<SO~O!d#vO#h<TO~O!d#vO#h;yO~O#}<UO~P#AbO#h<VO~O#h<WO~O#h<]O~O#h<^O~O#h<_O~O#h<`O~O#}<aO~P!0kO#}<bO~P!0kO#P#Q#R#T#U#X#f#g#r(y$r$t$w%Z%e%f%g%n%p%s%t%v%x~'yT#l!U'w(P#mp#k#no}'x$['x(O$^(`~",
    goto: "$4Q)XPPPPPP)YPP)]P)nP+O/PPPPP5xPP6`PP<V?mP@QP@QPPP@QPBRP@QP@QP@QPBVPB[PByPGrPPPGvPPPPGvJxPPPKOKzPGvPGvPPNYGvPPPGvPGvP!!aGvP!%v!&{!'UP!'x!'|!'x!+YPPPPPPP!+y!&{PP!,Z!-gP!0jGvGv!0o!3z!8b!8b!<`PPP!<hGvPPPPPPPPPPP!?vP!ATPPGv!BfPGvPGvGvGvGvGvPGv!CxP!GRP!JWP!J[!Jf!Jj!JjP!GOP!Jn!JnP!MsP!MwGvGv!M}##RBV@QP@QP@Q@QP#$_@Q@Q#&j@Q#)Z@Q#+`@Q@Q#,O#.]#.]#.b#.k#.]#.wP#.]P@Q#/a@Q#3S@Q@Q5xPPP#6{PPP#7f#7fP#7fP#7|#7fPP#8SP#7yP#7y#8g#7y#9R#9X5u)]#9[)]P#9c#9c#9cP)]P)]P)]P)]PP)]P#9i#9lP#9l)]P#9pP#9sP)]P)]P)]P)]P)]P)])]PP#9y#:P#:[#:b#:h#:n#:t#;S#;Y#;d#;j#;t#;z#<[#<b#=S#=f#=l#=r#>Q#>g#@V#@e#@l#BR#Ba#C|#D[#Db#Dh#Dn#Dx#EO#EU#E`#Er#ExPPPPPPPPPP#FOPPPPPPP#Fs#Iz#KZ#Kb#KjPPP$!sP$!|$%t$,^$,a$,d$-P$-S$-Z$-cP$-i$-lP$.Y$.^$/U$0d$0i$1PPP$1U$1[$1`P$1c$1g$1k$2a$2x$3a$3e$3h$3k$3q$3t$3x$3|R!|RoqOXst!Z#d%k&o&q&r&t,k,p1|2PY!vQ']-]1a5eQ%rvQ%zyQ&R|Q&g!VS'T!e-TQ'c!iS'i!r!yU*e$|*V*jQ+i%{Q+v&TQ,[&aQ-Z'[Q-e'dQ-m'jQ0R*lQ1k,]R;v;T%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8rS#q];Q!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U*y%[;n;oQ+n%}Q,^&dQ,e&lQ0m+aQ0q+cQ0|+oQ1s,cQ3Q._Q5O0wQ5t1lQ6r3UQ7s5PR8x6t'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{t!nQ!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5g$|$ti#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ&U|Q'R!eU'X%g*V-WQ+n%}Q,^&dQ0c*|Q0|+oQ1R+uQ1r,bQ1s,cQ5O0wQ5X1TQ5t1lQ5w1nQ5x1qQ7s5PQ7v5UQ8a5zQ9g7wR9r8^rnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR,`&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<z<{[#]WZ#W#Z'U(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+h%z%{Q+l%}Q,V&_Q,Z&aS-d'c'dQ.a(nQ0u+iQ0{+oQ0}+pQ1Q+tQ1f,WS1j,[,]Q2n-eQ4}0wQ5R0zQ5W1SQ5s1kQ7r5PQ7u5TQ9c7qR:^9d!O$zi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R!S%wy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dQ+b%uQ+{&XQ,O&YQ,Y&aQ.`(mQ1e,VU1i,Z,[,]Q3V.aQ5n1fS5r1j1kQ8]5s#^<|#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo<};g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bW%Ti%V*t<xS&X!Q&fQ&Y!RQ&Z!SR+y&V$}%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VT)v$u)wV*y%[;n;oW'X!e%g*V-WS(y#y#zQ+]%pQ+s&QS.Y(i(jQ1[,PQ4n0`R7{5^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{$i$^c#Y#e%o%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.t.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q'V!eR2c-Tv!nQ!e!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5gU*d$|*V*jS/y*e*lQ0S*mQ1^,RQ4d0RR4g0UnqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&v!^Q's!xS(o#u;XQ+f%xQ,T&[Q,U&^Q-b'aQ-o'lS.j(t;yS0f+R<TQ0s+gQ1`,SQ2T,rQ2V,sQ2_-OQ2l-cQ2o-gS4s0g<_Q4y0tS4|0v<`Q6^2aQ6b2mQ6g2tQ7p4zQ8m6`Q8n6cQ8q6hR9x8j$d$]c#Y#e%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oS(k#p'fQ({#zS+[%o.tS.Z(j(lR3O.['OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S#q];QQ&q!XQ&r!YQ&t![Q&u!]R1{,nQ'^!hQ+_%uQ-`'`S.](m+bQ2j-_W3S.`.a0l0nQ6a2kW6n3P3R3V4wU8t6o6q6sU9}8v8w8yS:i9|:PQ:t:jR:z:uU!wQ']-]T5c1a5e!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,k,p.S1|2P]!pQ!r']-]1a5eT#q];Q%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS(y#y#zS.Y(i(j!s<f$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U$fd)Z,eS(l#p'fU*q%R(s3pU0b*x.f7PQ4w0mQ6o3QQ8w6rR:P8xm!tQ!r!v!y!z']'i'j'k-]-m1a5e5gQ'q!uS(b#g1vS-k'h'tQ/k*XQ/w*dQ2v-nQ4U/lS4_/x0SQ7Z4PS7f4e4gQ9V7[Q9Z7cQ9`7iS:X9[9]S:n:Y:ZS:w:o:pR:}:xQ#wbQ'p!uS(a#g1vS(c#m+QQ+S%dQ+d%vQ+j%|U-j'h'q'tQ.O(bQ/j*XQ/v*dQ/|*gQ0r+eQ1g,XS2s-k-nQ2{.WS4T/k/lS4^/w0SQ4a/{Q4c/}Q5p1hQ6i2vQ7Y4PQ7^4US7b4_4gQ7g4fQ8Z5qS9U7Z7[Q9Y7cQ9^7fQ9a7jQ9o8[Q:V9VS:W9Z9]Q:[9`Q:e9pS:m:X:ZS:v:n:pQ:|:wQ;O:}Q<i<dQ<t<mR<u<nV!wQ']-]%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS#wz!j!r<c$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<i<z%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dS%|z!jQ+e%wQ,X&aW1h,Y,Z,[,]U5q1i1j1kS8[5r5sQ9p8]!r<d$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q<m<yR<n<z%OeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rY#bWZ#W#Z(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ,f&l!p<e$Z$n)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<h'UU'Y!e%g*VR2e-W%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8r!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q,e&lQ0m+aQ3Q._Q6r3UR8x6t!b$Tc#Y%o(O(U(p(u)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!P;_)Y)m-R.t2]2`3b3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!f$Vc#Y%o(O(U(p(u)S)T)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!T;a)Y)m-R.t2]2`3b3h3i3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!^$Zc#Y%o(O(U(p(u)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;RQ3}/cz<{)Y)m-R.t2]2`3b3q3y6_6z7T7U7}8l8z9Q9R:`:g<oQ=Q=SR=R=T'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S$oh$pR3v.|'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$kf$qQ$ifS)f$l)jR)r$qT$jf$qT)h$l)j'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$oh$pQ$rhR)q$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8r!s<y$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{#elOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_(z)o+V+a,h,k,p-a._.}/f0a1d1t1u1w1y1|2P2R3U3u5b5m5}6O6R6t8R8X8h!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=VQ*}%`Q/Y)zo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!O$yi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=RQ*^$zU*g$|*V*jQ+O%aQ/}*h#^<k#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn<l;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bQ<p<|Q<q<}Q<r=OR<s=P!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bnoOXst!Z#d%k&o&q&r&t,k,p1|2PS*a${*UQ,y&{Q,z&}R4X/p$|%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ+|&YQ1Y,OQ5[1XR7z5]V*i$|*V*jU*i$|*V*jT5d1a5eU/{*f/f5bS4f0T8RR7j4hQ+d%vQ/|*gQ0r+eQ1g,XQ5p1hQ8Z5qQ9o8[R:e9p!O%Oi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rr)}$v)a*O*p+P/n0Z0[3s4V4q7X7k:U<j<v<wS0V*o0W#^;j#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;k;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!`;|(q)_*W*`.b.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=T`;}3o6{7O7S8{:Q:T:{S<X.d3ZT<Y6}9O!O%Qi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rv*P$v)a*Q*o+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<wS0X*p0Y#^;l#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;m;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!d<O(q)_*W*`.c.d.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=Td<P3o6|6}7S8{8|:Q:R:T:{S<Z.e3[T<[7O9PrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ&c!UR,h&lrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR&c!UQ,Q&ZR1U+ysnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ1b,VS5k1e1fU8T5i5j5nS9k8V8WS:a9j9mQ:q:bR:y:rQ&j!VR,a&fR5w1nS&O|&TR0}+pQ&o!WR,k&pR,q&uT1},p2PR,u&vQ,t&vR2W,uQ'v!{R-q'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)w$uR/V)wQ#UVR'|#UQ#XWU(S#X(T-xQ(T#YR-x(UQ-U'VR2d-UQ.m(uS3_.m3`R3`.nQ-]']R2h-]Y!rQ']-]1a5eR'g!rQ.x)aR3t.xU#_W%f*UU(Z#_([-yQ([#`R-y(VQ-X'YR2f-Xt`OXst!V!Z#d%k&f&h&o&q&r&t,k,p1|2PS#hZ%cU#r`#h.SR.S(fQ(g#jQ.P(cW.X(g.P2y6kQ2y.QR6k2zQ)j$lR/O)jQ$phR)p$pQ$`cU)]$`-t;eQ-t;RR;e)mQ/i*XW4R/i4S7]9WU4S/j/k/lS7]4T4UR9W7^$Z)|$v(q)_)a*W*`*o*p*z*{+P.d.e.g.h.i/U/Z/_/a/c/n/s0Z0[0k1V1X3W3X3Y3o3s4V4W4[4i4k4q5Z5]6u6v6w6x6}7O7Q7R7S7X7`7d7k7m7o8{8|8}9X9_:Q:R:S:T:U:]:l:{<j<v<w=S=TQ/q*`U4Z/q4]7aQ4]/sR7a4[S*j$|*VR0P*jr*O$v)a*o*p+P/n0Z0[3s4V4q7X7k:U<j<v<w!`.b(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=TU/`*O.b6{a6{3o6}7O7S8{:Q:T:{Q0W*oQ3Z.dU4j0W3Z9OR9O6}v*Q$v)a*o*p+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<w!d.c(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=TU/b*Q.c6|e6|3o6}7O7S8{8|:Q:R:T:{Q0Y*pQ3[.eU4l0Y3[9PR9P7OQ*u%UR0^*uQ4v0kR7n4vQ+X%iR0j+XQ5_1[S7|5_9iR9i7}Q,S&[R1_,SQ5e1aR8P5eQ1m,^S5u1m8_R8_5wQ0x+lW5Q0x5S7t9eQ5S0{Q7t5RR9e7uQ+q&OR1O+qQ2P,pR6V2PYrOXst#dQ&s!ZQ+Z%kQ,j&oQ,l&qQ,m&rQ,o&tQ1z,kS1},p2PR6U1|Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Y%jQ+f%xQ+x&UQ,`&jQ,w&yW-h'h'p'q'tQ-o'lQ0O*iQ0s+gS1p,a,dQ2X,vQ2Y,yQ2Z,zQ2o-gW2q-j-k-n-pQ4y0tQ5V1RQ5Y1VQ5o1gQ5y1rQ6T1{U6d2p2s2vQ6g2tQ7p4zQ7x5XQ7y5ZQ8O5dQ8Y5pQ8`5xS8o6e6iQ8q6hQ9f7vQ9n8ZQ9s8aQ9z8pQ:_9gQ:d9oQ:h9{R:s:eQ%xyQ'a!iQ'l!uU+g%y%z%{Q-O'SU-c'b'c'dS-g'h'rQ/u*dS0t+h+iQ2a-QS2m-d-eQ2t-lQ4`/yQ4z0uQ6`2gQ6c2nQ6h2uR7e4dS$wi<xR*v%VU%Ui%V<xR0]*tQ$viS(q#v+cS)_$b$cQ)a$dQ*W$xS*`${*UQ*o%OQ*p%QQ*z%]Q*{%^Q+P%bQ.d;jQ.e;lQ.g;pQ.h;rQ.i;tQ/U)uS/Z){/]Q/_)}Q/a*PQ/c*RQ/n*[S/s*b/eQ0Z*rQ0[*sh0k+`.^1c3T5l6p8U8u9l:O:c:kQ1V+zQ1X+}Q3W;|Q3X<OQ3Y<RS3o;g;hQ3s.wQ4V/oQ4W/pQ4[/rQ4i0VQ4k0XQ4q0dQ5Z1WQ5]1ZQ6u<VQ6v<XQ6w<ZQ6x<]Q6};kQ7O;mQ7Q;qQ7R;sQ7S;uQ7X3}Q7`4YQ7d4bQ7k4mQ7m4uQ7o4xQ8{<SQ8|;}Q8}<PQ9X7_Q9_7hQ:Q<WQ:R<YQ:S<[Q:T<^Q:U9TQ:]9bQ:l<aQ:{<bQ<j<xQ<v=QQ<w=RQ=S=UR=T=VQ*x%[Q.f;nR7P;onpOXst!Z#d%k&o&q&r&t,k,p1|2PQ!fPS#fZ#oQ&y!`U'e!o5b8RQ'{#SQ(|#{Q)n$nS,d&h&kQ,i&lQ,v&xQ,{'QQ-_'_Q.p(zQ/S)oS0h+V/fQ0n+aQ1x,hQ2k-aQ3R._Q3x.}Q4o0aQ5j1dQ5{1tQ5|1uQ6Q1wQ6S1yQ6X2RQ6s3UQ7V3uQ8W5mQ8d5}Q8e6OQ8g6RQ8y6tQ9m8XR9w8h#YcOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_(z+V+a,h,k,p-a._/f0a1d1t1u1w1y1|2P2R3U5b5m5}6O6R6t8R8X8hQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)Y$ZQ)[$_Q)^$aQ)c$eW)m$n)o.}3uQ+^%rQ+r&PS-R'U2bQ-p'oS-u(P-wQ-z(XQ-|(`Q.k(tQ.n(vQ.r;PQ.t;SQ.u;TQ.v;WQ/X)yQ0e+RQ2],|Q2`-PQ2p-iQ2w-}Q3].lQ3b;XQ3c;YQ3d;ZQ3e;[Q3f;]Q3g;^Q3h;_Q3i;`Q3j;aQ3k;bQ3l;cQ3m.sQ3n;fQ3q;iQ3r;vQ3y;dQ4r0gQ4{0vQ6_;xQ6e2rQ6j2xQ6y3^Q6z;yQ7T;{Q7U<TQ7}5`Q8l6]Q8p6fQ8z<UQ9Q<_Q9R<`Q9{8rQ:`9hQ:g9yQ;R#SR<o<{R#[WR'W!el!tQ!r!v!y!z']'i'j'k-]-m1a5e5gS'S!e-TS-Q'T'[R2g-ZR(w#xQ!fQT-[']-]]!qQ!r']-]1a5eQ#p]R'f;QR)b$dY!uQ']-]1a5eQ'h!rS'r!v!yS't!z5gS-l'i'jQ-n'kR2u-mT#kZ%cS#jZ%cS%im,gU(c#h#i#lS.Q(d(eQ.U(fQ0i+WQ2z.RU2{.S.T.VS6l2|2}R8s6md#^W#W#Z%f(P(Y*U+T-{/er#gZm#h#i#l%c(d(e(f+W.R.S.T.V2|2}6mS*X$x*]Q/l*YQ1v,gQ2^,}Q4P/hQ6Z2UQ7[4QQ8k6[T<g'U+UV#aW%f*UU#`W%f*US(Q#W(YU(V#Z+T/eS-S'U+UT-v(P-{V'Z!e%g*VQ$lfR)t$qT)i$l)jR3w.|T*Z$x*]T*c${*UQ0l+`Q3P.^Q5i1cQ6q3TQ8V5lQ8v6pQ9j8UQ9|8uQ:b9lQ:j:OQ:r:cR:u:knqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&i!VR,`&ftmOXst!U!V!Z#d%k&f&o&q&r&t,k,p1|2PR,g&lT%jm,gR1],PR,_&dQ&S|R+w&TR+m%}T&m!W&pT&n!W&pT2O,p2P",
    nodeNames:
      "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
    maxTerm: 376,
    context: phe,
    nodeProps: [
      ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
      [
        "group",
        -26,
        9,
        17,
        19,
        65,
        204,
        208,
        212,
        213,
        215,
        218,
        221,
        231,
        233,
        239,
        241,
        243,
        245,
        248,
        254,
        260,
        262,
        264,
        266,
        268,
        270,
        271,
        "Statement",
        -34,
        13,
        14,
        29,
        32,
        33,
        39,
        48,
        51,
        52,
        54,
        59,
        67,
        69,
        73,
        77,
        79,
        81,
        82,
        107,
        108,
        117,
        118,
        135,
        138,
        140,
        141,
        142,
        143,
        144,
        146,
        147,
        166,
        167,
        169,
        "Expression",
        -23,
        28,
        30,
        34,
        38,
        40,
        42,
        171,
        173,
        175,
        176,
        178,
        179,
        180,
        182,
        183,
        184,
        186,
        187,
        188,
        198,
        200,
        202,
        203,
        "Type",
        -3,
        85,
        100,
        106,
        "ClassItem",
      ],
      ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
      ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"],
    ],
    propSources: [xhe],
    skippedNodes: [0, 5, 6, 274],
    repeatNodeCount: 37,
    tokenData:
      "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Rp(U!b'w0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(S#S$h&j'x0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Rp(U!b'x0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(Q':f$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(U!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Rp(U!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Rp(U!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(U!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(U!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(RpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(RpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Rp(U!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(j%1l(Rp(U!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Rp(U!b$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Rp(U!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Rp(U!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(u+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(T';W$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(RpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Rp(U!b(P%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Rp(U!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Rp(U!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Rp(U!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Rp(U!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(U!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(U!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(U!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(U!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(U!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(U!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Rp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Rp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Rp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Rp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(RpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(RpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Rp(U!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Rp(U!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Rp(U!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Rp(U!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Rp(U!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Rp(U!b'y0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Rp(U!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(U!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(U!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(RpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(RpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Rp(U!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Rp(U!b(y7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(m(Ct$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Rp(U!b([+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Rp(U!b(O,2j$^#t(`$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Rp(U!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(t+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z(Kd$?V_!Z(Cds`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Rp(U!b'w0/l$[#t(O,2j(`$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Rp(U!b'x0/l$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
    tokenizers: [
      ghe,
      Ohe,
      vhe,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      mhe,
      new Gp(
        "$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(^~~",
        141,
        335
      ),
      new Gp("j~RQYZXz{^~^O'{~~aP!P!Qd~iO'|~~", 25, 318),
    ],
    topRules: { Script: [0, 7], SingleExpression: [1, 272], SingleClassItem: [2, 273] },
    dialects: { jsx: 0, ts: 14725 },
    dynamicPrecedences: { 77: 1, 79: 1, 91: 1, 167: 1, 196: 1 },
    specialized: [
      { term: 322, get: (t) => bhe[t] || -1 },
      { term: 338, get: (t) => yhe[t] || -1 },
      { term: 92, get: (t) => whe[t] || -1 },
    ],
    tokenPrec: 14749,
  }),
  oS = [
    Hn("function ${name}(${params}) {\n	${}\n}", { label: "function", detail: "definition", type: "keyword" }),
    Hn("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", { label: "for", detail: "loop", type: "keyword" }),
    Hn("for (let ${name} of ${collection}) {\n	${}\n}", { label: "for", detail: "of loop", type: "keyword" }),
    Hn("do {\n	${}\n} while (${})", { label: "do", detail: "loop", type: "keyword" }),
    Hn("while (${}) {\n	${}\n}", { label: "while", detail: "loop", type: "keyword" }),
    Hn(
      `try {
	\${}
} catch (\${error}) {
	\${}
}`,
      { label: "try", detail: "/ catch block", type: "keyword" }
    ),
    Hn("if (${}) {\n	${}\n}", { label: "if", detail: "block", type: "keyword" }),
    Hn(
      `if (\${}) {
	\${}
} else {
	\${}
}`,
      { label: "if", detail: "/ else block", type: "keyword" }
    ),
    Hn(
      `class \${name} {
	constructor(\${params}) {
		\${}
	}
}`,
      { label: "class", detail: "definition", type: "keyword" }
    ),
    Hn('import {${names}} from "${module}"\n${}', { label: "import", detail: "named", type: "keyword" }),
    Hn('import ${name} from "${module}"\n${}', { label: "import", detail: "default", type: "keyword" }),
  ],
  VR = oS.concat([
    Hn("interface ${name} {\n	${}\n}", { label: "interface", detail: "definition", type: "keyword" }),
    Hn("type ${name} = ${type}", { label: "type", detail: "definition", type: "keyword" }),
    Hn("enum ${name} {\n	${}\n}", { label: "enum", detail: "definition", type: "keyword" }),
  ]),
  NE = new G4(),
  BR = new Set(["Script", "Block", "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration", "ForStatement"]);
function Ac(t) {
  return (e, n) => {
    let r = e.node.getChild("VariableDefinition");
    return r && n(r, t), !0;
  };
}
const khe = ["FunctionDeclaration"],
  Che = {
    FunctionDeclaration: Ac("function"),
    ClassDeclaration: Ac("class"),
    ClassExpression: () => !0,
    EnumDeclaration: Ac("constant"),
    TypeAliasDeclaration: Ac("type"),
    NamespaceDeclaration: Ac("namespace"),
    VariableDefinition(t, e) {
      t.matchContext(khe) || e(t, "variable");
    },
    TypeDefinition(t, e) {
      e(t, "type");
    },
    __proto__: null,
  };
function jR(t, e) {
  let n = NE.get(e);
  if (n) return n;
  let r = [],
    i = !0;
  function s(o, a) {
    let l = t.sliceString(o.from, o.to);
    r.push({ label: l, type: a });
  }
  return (
    e.cursor(kt.IncludeAnonymous).iterate((o) => {
      if (i) i = !1;
      else if (o.name) {
        let a = Che[o.name];
        if ((a && a(o, s)) || BR.has(o.name)) return !1;
      } else if (o.to - o.from > 8192) {
        for (let a of jR(t, o.node)) r.push(a);
        return !1;
      }
    }),
    NE.set(e, r),
    r
  );
}
const em = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,
  aS = [
    "TemplateString",
    "String",
    "RegExp",
    "LineComment",
    "BlockComment",
    "VariableDefinition",
    "TypeDefinition",
    "Label",
    "PropertyDefinition",
    "PropertyName",
    "PrivatePropertyDefinition",
    "PrivatePropertyName",
    ".",
    "?.",
  ];
function ZR(t) {
  let e = pt(t.state).resolveInner(t.pos, -1);
  if (aS.indexOf(e.name) > -1) return null;
  let n = e.name == "VariableName" || (e.to - e.from < 20 && em.test(t.state.sliceDoc(e.from, e.to)));
  if (!n && !t.explicit) return null;
  let r = [];
  for (let i = e; i; i = i.parent) BR.has(i.name) && (r = r.concat(jR(t.state.doc, i)));
  return { options: r, from: n ? e.from : t.pos, validFor: em };
}
function f1(t, e, n) {
  var r;
  let i = [];
  for (;;) {
    let s = e.firstChild,
      o;
    if ((s == null ? void 0 : s.name) == "VariableName") return i.push(t(s)), { path: i.reverse(), name: n };
    if (
      (s == null ? void 0 : s.name) == "MemberExpression" &&
      ((r = o = s.lastChild) === null || r === void 0 ? void 0 : r.name) == "PropertyName"
    )
      i.push(t(o)), (e = s);
    else return null;
  }
}
function zR(t) {
  let e = (r) => t.state.doc.sliceString(r.from, r.to),
    n = pt(t.state).resolveInner(t.pos, -1);
  return n.name == "PropertyName"
    ? f1(e, n.parent, e(n))
    : (n.name == "." || n.name == "?.") && n.parent.name == "MemberExpression"
    ? f1(e, n.parent, "")
    : aS.indexOf(n.name) > -1
    ? null
    : n.name == "VariableName" || (n.to - n.from < 20 && em.test(e(n)))
    ? { path: [], name: e(n) }
    : n.name == "MemberExpression"
    ? f1(e, n, "")
    : t.explicit
    ? { path: [], name: "" }
    : null;
}
function _he(t, e) {
  let n = [],
    r = new Set();
  for (let i = 0; ; i++) {
    for (let o of (Object.getOwnPropertyNames || Object.keys)(t)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(o) || r.has(o)) continue;
      r.add(o);
      let a;
      try {
        a = t[o];
      } catch {
        continue;
      }
      n.push({
        label: o,
        type: typeof a == "function" ? (/^[A-Z]/.test(o) ? "class" : e ? "function" : "method") : e ? "variable" : "property",
        boost: -i,
      });
    }
    let s = Object.getPrototypeOf(t);
    if (!s) return n;
    t = s;
  }
}
function Ehe(t) {
  let e = new Map();
  return (n) => {
    let r = zR(n);
    if (!r) return null;
    let i = t;
    for (let o of r.path) if (((i = i[o]), !i)) return null;
    let s = e.get(i);
    return s || e.set(i, (s = _he(i, !r.path.length))), { from: n.pos - r.name.length, options: s, validFor: em };
  };
}
const Lr = _l.define({
    name: "javascript",
    parser: She.configure({
      props: [
        of.add({
          IfStatement: Dd({ except: /^\s*({|else\b)/ }),
          TryStatement: Dd({ except: /^\s*({|catch\b|finally\b)/ }),
          LabeledStatement: Uoe,
          SwitchBody: (t) => {
            let e = t.textAfter,
              n = /^\s*\}/.test(e),
              r = /^\s*(case|default)\b/.test(e);
            return t.baseIndent + (n ? 0 : r ? 1 : 2) * t.unit;
          },
          Block: Woe({ closing: "}" }),
          ArrowFunction: (t) => t.baseIndent + t.unit,
          "TemplateString BlockComment": () => null,
          "Statement Property": Dd({ except: /^{/ }),
          JSXElement(t) {
            let e = /^\s*<\//.test(t.textAfter);
            return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
          },
          JSXEscape(t) {
            let e = /\s*\}/.test(t.textAfter);
            return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
          },
          "JSXOpenTag JSXSelfClosingTag"(t) {
            return t.column(t.node.from) + t.unit;
          },
        }),
        oc.add({
          "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": a8,
          BlockComment(t) {
            return { from: t.from + 2, to: t.to - 2 };
          },
        }),
      ],
    }),
    languageData: {
      closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
      wordChars: "$",
    },
  }),
  WR = { test: (t) => /^JSX/.test(t.name), facet: _g({ commentTokens: { block: { open: "{/*", close: "*/}" } } }) },
  lS = Lr.configure({ dialect: "ts" }, "typescript"),
  cS = Lr.configure({ dialect: "jsx", props: [Qw.add((t) => (t.isTop ? [WR] : void 0))] }),
  uS = Lr.configure({ dialect: "jsx ts", props: [Qw.add((t) => (t.isTop ? [WR] : void 0))] }, "typescript");
let UR = (t) => ({ label: t, type: "keyword" });
const XR =
    "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield"
      .split(" ")
      .map(UR),
  The = XR.concat(["declare", "implements", "private", "protected", "public"].map(UR));
function tm(t = {}) {
  let e = t.jsx ? (t.typescript ? uS : cS) : t.typescript ? lS : Lr,
    n = t.typescript ? VR.concat(The) : oS.concat(XR);
  return new Tl(e, [Lr.data.of({ autocomplete: Eae(aS, _8(n)) }), Lr.data.of({ autocomplete: ZR }), t.jsx ? HR : []]);
}
function Phe(t) {
  for (;;) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag") return t;
    if (t.name == "JSXEscape" || !t.parent) return null;
    t = t.parent;
  }
}
function LE(t, e, n = t.length) {
  for (let r = e == null ? void 0 : e.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return t.sliceString(r.from, Math.min(r.to, n));
  return "";
}
const Ahe = typeof navigator == "object" && /Android\b/.test(navigator.userAgent),
  HR = re.inputHandler.of((t, e, n, r, i) => {
    if (
      (Ahe ? t.composing : t.compositionStarted) ||
      t.state.readOnly ||
      e != n ||
      (r != ">" && r != "/") ||
      !Lr.isActiveAt(t.state, e, -1)
    )
      return !1;
    let s = i(),
      { state: o } = s,
      a = o.changeByRange((l) => {
        var c;
        let { head: u } = l,
          h = pt(o).resolveInner(u - 1, -1),
          f;
        if (
          (h.name == "JSXStartTag" && (h = h.parent), !(o.doc.sliceString(u - 1, u) != r || (h.name == "JSXAttributeValue" && h.to > u)))
        ) {
          if (r == ">" && h.name == "JSXFragmentTag") return { range: l, changes: { from: u, insert: "</>" } };
          if (r == "/" && h.name == "JSXStartCloseTag") {
            let d = h.parent,
              p = d.parent;
            if (
              p &&
              d.from == u - 2 &&
              ((f = LE(o.doc, p.firstChild, u)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")
            ) {
              let m = `${f}>`;
              return { range: X.cursor(u + m.length, -1), changes: { from: u, insert: m } };
            }
          } else if (r == ">") {
            let d = Phe(h);
            if (d && d.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(u, u + 2)) && (f = LE(o.doc, d, u)))
              return { range: l, changes: { from: u, insert: `</${f}>` } };
          }
        }
        return { range: l };
      });
    return a.changes.empty ? !1 : (t.dispatch([s, o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })]), !0);
  });
function $he(t, e) {
  return (
    e ||
      ((e = {
        parserOptions: { ecmaVersion: 2019, sourceType: "module" },
        env: { browser: !0, node: !0, es6: !0, es2015: !0, es2017: !0, es2020: !0 },
        rules: {},
      }),
      t.getRules().forEach((n, r) => {
        n.meta.docs.recommended && (e.rules[r] = 2);
      })),
    (n) => {
      let { state: r } = n,
        i = [];
      for (let { from: s, to: o } of Lr.findRegions(r)) {
        let a = r.doc.lineAt(s),
          l = { line: a.number - 1, col: s - a.from, pos: s };
        for (let c of t.verify(r.sliceDoc(s, o), e)) i.push(Rhe(c, r.doc, l));
      }
      return i;
    }
  );
}
function ME(t, e, n, r) {
  return n.line(t + r.line).from + e + (t == 1 ? r.col - 1 : -1);
}
function Rhe(t, e, n) {
  let r = ME(t.line, t.column, e, n),
    i = {
      from: r,
      to: t.endLine != null && t.endColumn != 1 ? ME(t.endLine, t.endColumn, e, n) : r,
      message: t.message,
      source: t.ruleId ? "eslint:" + t.ruleId : "eslint",
      severity: t.severity == 1 ? "warning" : "error",
    };
  if (t.fix) {
    let { range: s, text: o } = t.fix,
      a = s[0] + n.pos - r,
      l = s[1] + n.pos - r;
    i.actions = [
      {
        name: "fix",
        apply(c, u) {
          c.dispatch({ changes: { from: u + a, to: u + l, insert: o }, scrollIntoView: !0 });
        },
      },
    ];
  }
  return i;
}
const Jf = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        autoCloseTags: HR,
        completionPath: zR,
        esLint: $he,
        javascript: tm,
        javascriptLanguage: Lr,
        jsxLanguage: cS,
        localCompletionSource: ZR,
        scopeCompletionSource: Ehe,
        snippets: oS,
        tsxLanguage: uS,
        typescriptLanguage: lS,
        typescriptSnippets: VR,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  $c = ["_blank", "_self", "_top", "_parent"],
  d1 = ["ascii", "utf-8", "utf-16", "latin1", "latin1"],
  p1 = ["get", "post", "put", "delete"],
  m1 = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
  lr = ["true", "false"],
  _e = {},
  Ihe = {
    a: { attrs: { href: null, ping: null, type: null, media: null, target: $c, hreflang: null } },
    abbr: _e,
    address: _e,
    area: {
      attrs: {
        alt: null,
        coords: null,
        href: null,
        target: null,
        ping: null,
        media: null,
        hreflang: null,
        type: null,
        shape: ["default", "rect", "circle", "poly"],
      },
    },
    article: _e,
    aside: _e,
    audio: {
      attrs: {
        src: null,
        mediagroup: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["none", "metadata", "auto"],
        autoplay: ["autoplay"],
        loop: ["loop"],
        controls: ["controls"],
      },
    },
    b: _e,
    base: { attrs: { href: null, target: $c } },
    bdi: _e,
    bdo: _e,
    blockquote: { attrs: { cite: null } },
    body: _e,
    br: _e,
    button: {
      attrs: {
        form: null,
        formaction: null,
        name: null,
        value: null,
        autofocus: ["autofocus"],
        disabled: ["autofocus"],
        formenctype: m1,
        formmethod: p1,
        formnovalidate: ["novalidate"],
        formtarget: $c,
        type: ["submit", "reset", "button"],
      },
    },
    canvas: { attrs: { width: null, height: null } },
    caption: _e,
    center: _e,
    cite: _e,
    code: _e,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
      attrs: {
        type: ["command", "checkbox", "radio"],
        label: null,
        icon: null,
        radiogroup: null,
        command: null,
        title: null,
        disabled: ["disabled"],
        checked: ["checked"],
      },
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: _e,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: _e,
    div: _e,
    dl: _e,
    dt: _e,
    em: _e,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: _e,
    figure: _e,
    footer: _e,
    form: {
      attrs: {
        action: null,
        name: null,
        "accept-charset": d1,
        autocomplete: ["on", "off"],
        enctype: m1,
        method: p1,
        novalidate: ["novalidate"],
        target: $c,
      },
    },
    h1: _e,
    h2: _e,
    h3: _e,
    h4: _e,
    h5: _e,
    h6: _e,
    head: { children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"] },
    header: _e,
    hgroup: _e,
    hr: _e,
    html: { attrs: { manifest: null } },
    i: _e,
    iframe: {
      attrs: {
        src: null,
        srcdoc: null,
        name: null,
        width: null,
        height: null,
        sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
        seamless: ["seamless"],
      },
    },
    img: {
      attrs: { alt: null, src: null, ismap: null, usemap: null, width: null, height: null, crossorigin: ["anonymous", "use-credentials"] },
    },
    input: {
      attrs: {
        alt: null,
        dirname: null,
        form: null,
        formaction: null,
        height: null,
        list: null,
        max: null,
        maxlength: null,
        min: null,
        name: null,
        pattern: null,
        placeholder: null,
        size: null,
        src: null,
        step: null,
        value: null,
        width: null,
        accept: ["audio/*", "video/*", "image/*"],
        autocomplete: ["on", "off"],
        autofocus: ["autofocus"],
        checked: ["checked"],
        disabled: ["disabled"],
        formenctype: m1,
        formmethod: p1,
        formnovalidate: ["novalidate"],
        formtarget: $c,
        multiple: ["multiple"],
        readonly: ["readonly"],
        required: ["required"],
        type: [
          "hidden",
          "text",
          "search",
          "tel",
          "url",
          "email",
          "password",
          "datetime",
          "date",
          "month",
          "week",
          "time",
          "datetime-local",
          "number",
          "range",
          "color",
          "checkbox",
          "radio",
          "file",
          "submit",
          "image",
          "reset",
          "button",
        ],
      },
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: _e,
    keygen: { attrs: { challenge: null, form: null, name: null, autofocus: ["autofocus"], disabled: ["disabled"], keytype: ["RSA"] } },
    label: { attrs: { for: null, form: null } },
    legend: _e,
    li: { attrs: { value: null } },
    link: { attrs: { href: null, type: null, hreflang: null, media: null, sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"] } },
    map: { attrs: { name: null } },
    mark: _e,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
      attrs: {
        content: null,
        charset: d1,
        name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
        "http-equiv": ["content-language", "content-type", "default-style", "refresh"],
      },
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: _e,
    noscript: _e,
    object: {
      attrs: { data: null, type: null, name: null, usemap: null, form: null, width: null, height: null, typemustmatch: ["typemustmatch"] },
    },
    ol: {
      attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
      children: ["li", "script", "template", "ul", "ol"],
    },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: _e,
    param: { attrs: { name: null, value: null } },
    pre: _e,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: _e,
    rt: _e,
    ruby: _e,
    samp: _e,
    script: { attrs: { type: ["text/javascript"], src: null, async: ["async"], defer: ["defer"], charset: d1 } },
    section: _e,
    select: { attrs: { form: null, name: null, size: null, autofocus: ["autofocus"], disabled: ["disabled"], multiple: ["multiple"] } },
    slot: { attrs: { name: null } },
    small: _e,
    source: { attrs: { src: null, type: null, media: null } },
    span: _e,
    strong: _e,
    style: { attrs: { type: ["text/css"], media: null, scoped: null } },
    sub: _e,
    summary: _e,
    sup: _e,
    table: _e,
    tbody: _e,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: _e,
    textarea: {
      attrs: {
        dirname: null,
        form: null,
        maxlength: null,
        name: null,
        placeholder: null,
        rows: null,
        cols: null,
        autofocus: ["autofocus"],
        disabled: ["disabled"],
        readonly: ["readonly"],
        required: ["required"],
        wrap: ["soft", "hard"],
      },
    },
    tfoot: _e,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: _e,
    time: { attrs: { datetime: null } },
    title: _e,
    tr: _e,
    track: {
      attrs: {
        src: null,
        label: null,
        default: null,
        kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
        srclang: null,
      },
    },
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: _e,
    video: {
      attrs: {
        src: null,
        poster: null,
        width: null,
        height: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["auto", "metadata", "none"],
        autoplay: ["autoplay"],
        mediagroup: ["movie"],
        muted: ["muted"],
        controls: ["controls"],
      },
    },
    wbr: _e,
  },
  qR = {
    accesskey: null,
    class: null,
    contenteditable: lr,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: lr,
    autocorrect: lr,
    autocapitalize: lr,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    rel: [
      "stylesheet",
      "alternate",
      "author",
      "bookmark",
      "help",
      "license",
      "next",
      "nofollow",
      "noreferrer",
      "prefetch",
      "prev",
      "search",
      "tag",
    ],
    role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(
      " "
    ),
    "aria-activedescendant": null,
    "aria-atomic": lr,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": lr,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": lr,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": lr,
    "aria-hidden": lr,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": lr,
    "aria-multiselectable": lr,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": lr,
    "aria-relevant": null,
    "aria-required": lr,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null,
  },
  YR =
    "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload"
      .split(" ")
      .map((t) => "on" + t);
for (let t of YR) qR[t] = null;
class rh {
  constructor(e, n) {
    (this.tags = Object.assign(Object.assign({}, Ihe), e)),
      (this.globalAttrs = Object.assign(Object.assign({}, qR), n)),
      (this.allTags = Object.keys(this.tags)),
      (this.globalAttrNames = Object.keys(this.globalAttrs));
  }
}
rh.default = new rh();
function Al(t, e, n = t.length) {
  if (!e) return "";
  let r = e.firstChild,
    i = r && r.getChild("TagName");
  return i ? t.sliceString(i.from, Math.min(i.to, n)) : "";
}
function $l(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e) e = !1;
      else return t;
  return null;
}
function GR(t, e, n) {
  let r = n.tags[Al(t, $l(e))];
  return (r == null ? void 0 : r.children) || n.allTags;
}
function hS(t, e) {
  let n = [];
  for (let r = $l(e); r && !r.type.isTop; r = $l(r.parent)) {
    let i = Al(t, r);
    if (i && r.lastChild.name == "CloseTag") break;
    i && n.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= r.firstChild.to) && n.push(i);
  }
  return n;
}
const JR = /^[:\-\.\w\u00b7-\uffff]*$/;
function DE(t, e, n, r, i) {
  let s = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">",
    o = $l(n, !0);
  return {
    from: r,
    to: i,
    options: GR(t.doc, o, e)
      .map((a) => ({ label: a, type: "type" }))
      .concat(hS(t.doc, n).map((a, l) => ({ label: "/" + a, apply: "/" + a + s, type: "type", boost: 99 - l }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/,
  };
}
function QE(t, e, n, r) {
  let i = /\s*>/.test(t.sliceDoc(r, r + 5)) ? "" : ">";
  return { from: n, to: r, options: hS(t.doc, e).map((s, o) => ({ label: s, apply: s + i, type: "type", boost: 99 - o })), validFor: JR };
}
function Nhe(t, e, n, r) {
  let i = [],
    s = 0;
  for (let o of GR(t.doc, n, e)) i.push({ label: "<" + o, type: "type" });
  for (let o of hS(t.doc, n)) i.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
  return { from: r, to: r, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function Lhe(t, e, n, r, i) {
  let s = $l(n),
    o = s ? e.tags[Al(t.doc, s)] : null,
    a = o && o.attrs ? Object.keys(o.attrs) : [],
    l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return { from: r, to: i, options: l.map((c) => ({ label: c, type: "property" })), validFor: JR };
}
function Mhe(t, e, n, r, i) {
  var s;
  let o = (s = n.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"),
    a = [],
    l;
  if (o) {
    let c = t.sliceDoc(o.from, o.to),
      u = e.globalAttrs[c];
    if (!u) {
      let h = $l(n),
        f = h ? e.tags[Al(t.doc, h)] : null;
      u = (f == null ? void 0 : f.attrs) && f.attrs[c];
    }
    if (u) {
      let h = t.sliceDoc(r, i).toLowerCase(),
        f = '"',
        d = '"';
      /^['"]/.test(h)
        ? ((l = h[0] == '"' ? /^[^"]*$/ : /^[^']*$/), (f = ""), (d = t.sliceDoc(i, i + 1) == h[0] ? "" : h[0]), (h = h.slice(1)), r++)
        : (l = /^[^\s<>='"]*$/);
      for (let p of u) a.push({ label: p, apply: f + p + d, type: "constant" });
    }
  }
  return { from: r, to: i, options: a, validFor: l };
}
function KR(t, e) {
  let { state: n, pos: r } = e,
    i = pt(n).resolveInner(r, -1),
    s = i.resolve(r);
  for (let o = r, a; s == i && (a = i.childBefore(o)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to) break;
    (s = i = a), (o = l.from);
  }
  return i.name == "TagName"
    ? i.parent && /CloseTag$/.test(i.parent.name)
      ? QE(n, i, i.from, r)
      : DE(n, t, i, i.from, r)
    : i.name == "StartTag"
    ? DE(n, t, i, r, r)
    : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag"
    ? QE(n, i, r, r)
    : i.name == "OpenTag" || i.name == "SelfClosingTag" || i.name == "AttributeName"
    ? Lhe(n, t, i, i.name == "AttributeName" ? i.from : r, r)
    : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue"
    ? Mhe(n, t, i, i.name == "Is" ? r : i.from, r)
    : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document")
    ? Nhe(n, t, i, r)
    : null;
}
function eI(t) {
  return KR(rh.default, t);
}
function tI(t) {
  let { extraTags: e, extraGlobalAttributes: n } = t,
    r = n || e ? new rh(e, n) : rh.default;
  return (i) => KR(r, i);
}
const Dhe = Lr.parser.configure({ top: "SingleExpression" }),
  nI = [
    { tag: "script", attrs: (t) => t.type == "text/typescript" || t.lang == "ts", parser: lS.parser },
    { tag: "script", attrs: (t) => t.type == "text/babel" || t.type == "text/jsx", parser: cS.parser },
    { tag: "script", attrs: (t) => t.type == "text/typescript-jsx", parser: uS.parser },
    {
      tag: "script",
      attrs(t) {
        return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
      },
      parser: Dhe,
    },
    {
      tag: "script",
      attrs(t) {
        return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
      },
      parser: Lr.parser,
    },
    {
      tag: "style",
      attrs(t) {
        return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
      },
      parser: nh.parser,
    },
  ],
  rI = [{ name: "style", parser: nh.parser.configure({ top: "Styles" }) }].concat(YR.map((t) => ({ name: t, parser: Lr.parser }))),
  fS = _l.define({
    name: "html",
    parser: que.configure({
      props: [
        of.add({
          Element(t) {
            let e = /^(\s*)(<\/)?/.exec(t.textAfter);
            return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
          },
          "OpenTag CloseTag SelfClosingTag"(t) {
            return t.column(t.node.from) + t.unit;
          },
          Document(t) {
            if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to) return t.continue();
            let e = null,
              n;
            for (let r = t.node; ; ) {
              let i = r.lastChild;
              if (!i || i.name != "Element" || i.to != r.to) break;
              e = r = i;
            }
            return e && !((n = e.lastChild) && (n.name == "CloseTag" || n.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
          },
        }),
        oc.add({
          Element(t) {
            let e = t.firstChild,
              n = t.lastChild;
            return !e || e.name != "OpenTag" ? null : { from: e.to, to: n.name == "CloseTag" ? n.from : t.to };
          },
        }),
        x8.add({ "OpenTag CloseTag": (t) => t.getChild("TagName") }),
      ],
    }),
    languageData: { commentTokens: { block: { open: "<!--", close: "-->" } }, indentOnInput: /^\s*<\/\w+\W$/, wordChars: "-._" },
  }),
  pu = fS.configure({ wrap: QR(nI, rI) });
function dS(t = {}) {
  let e = "",
    n;
  t.matchClosingTags === !1 && (e = "noMatch"),
    t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"),
    ((t.nestedLanguages && t.nestedLanguages.length) || (t.nestedAttributes && t.nestedAttributes.length)) &&
      (n = QR((t.nestedLanguages || []).concat(nI), (t.nestedAttributes || []).concat(rI)));
  let r = n ? fS.configure({ wrap: n, dialect: e }) : e ? pu.configure({ dialect: e }) : pu;
  return new Tl(r, [pu.data.of({ autocomplete: tI(t) }), t.autoCloseTags !== !1 ? iI : [], tm().support, rS().support]);
}
const FE = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")),
  iI = re.inputHandler.of((t, e, n, r, i) => {
    if (t.composing || t.state.readOnly || e != n || (r != ">" && r != "/") || !pu.isActiveAt(t.state, e, -1)) return !1;
    let s = i(),
      { state: o } = s,
      a = o.changeByRange((l) => {
        var c, u, h;
        let f = o.doc.sliceString(l.from - 1, l.to) == r,
          { head: d } = l,
          p = pt(o).resolveInner(d, -1),
          m;
        if (f && r == ">" && p.name == "EndTag") {
          let O = p.parent;
          if (
            ((u = (c = O.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || u === void 0 ? void 0 : u.name) !=
              "CloseTag" &&
            (m = Al(o.doc, O.parent, d)) &&
            !FE.has(m)
          ) {
            let v = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0),
              g = `</${m}>`;
            return { range: l, changes: { from: d, to: v, insert: g } };
          }
        } else if (f && r == "/" && p.name == "IncompleteCloseTag") {
          let O = p.parent;
          if (
            p.from == d - 2 &&
            ((h = O.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" &&
            (m = Al(o.doc, O, d)) &&
            !FE.has(m)
          ) {
            let v = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0),
              g = `${m}>`;
            return { range: X.cursor(d + g.length, -1), changes: { from: d, to: v, insert: g } };
          }
        }
        return { range: l };
      });
    return a.changes.empty ? !1 : (t.dispatch([s, o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })]), !0);
  }),
  Qhe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        autoCloseTags: iI,
        html: dS,
        htmlCompletionSource: eI,
        htmlCompletionSourceWith: tI,
        htmlLanguage: pu,
        htmlPlain: fS,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
var VE = (function () {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      (i.enumerable = i.enumerable || !1), (i.configurable = !0), "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  return function (e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
})();
function Fhe(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
var ks = [
    [
      { color: "0, 0, 0", class: "ansi-black" },
      { color: "187, 0, 0", class: "ansi-red" },
      { color: "0, 187, 0", class: "ansi-green" },
      { color: "187, 187, 0", class: "ansi-yellow" },
      { color: "0, 0, 187", class: "ansi-blue" },
      { color: "187, 0, 187", class: "ansi-magenta" },
      { color: "0, 187, 187", class: "ansi-cyan" },
      { color: "255,255,255", class: "ansi-white" },
    ],
    [
      { color: "85, 85, 85", class: "ansi-bright-black" },
      { color: "255, 85, 85", class: "ansi-bright-red" },
      { color: "0, 255, 0", class: "ansi-bright-green" },
      { color: "255, 255, 85", class: "ansi-bright-yellow" },
      { color: "85, 85, 255", class: "ansi-bright-blue" },
      { color: "255, 85, 255", class: "ansi-bright-magenta" },
      { color: "85, 255, 255", class: "ansi-bright-cyan" },
      { color: "255, 255, 255", class: "ansi-bright-white" },
    ],
  ],
  Vhe = (function () {
    VE(t, null, [
      {
        key: "escapeForHtml",
        value: function (n) {
          return new t().escapeForHtml(n);
        },
      },
      {
        key: "linkify",
        value: function (n) {
          return new t().linkify(n);
        },
      },
      {
        key: "ansiToHtml",
        value: function (n, r) {
          return new t().ansiToHtml(n, r);
        },
      },
      {
        key: "ansiToJson",
        value: function (n, r) {
          return new t().ansiToJson(n, r);
        },
      },
      {
        key: "ansiToText",
        value: function (n) {
          return new t().ansiToText(n);
        },
      },
    ]);
    function t() {
      Fhe(this, t), (this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null), (this.bright = 0), (this.decorations = []);
    }
    return (
      VE(t, [
        {
          key: "setupPalette",
          value: function () {
            this.PALETTE_COLORS = [];
            for (var n = 0; n < 2; ++n) for (var r = 0; r < 8; ++r) this.PALETTE_COLORS.push(ks[n][r].color);
            for (
              var i = [0, 95, 135, 175, 215, 255],
                s = function (f, d, p) {
                  return i[f] + ", " + i[d] + ", " + i[p];
                },
                o = 0;
              o < 6;
              ++o
            )
              for (var a = 0; a < 6; ++a) for (var l = 0; l < 6; ++l) this.PALETTE_COLORS.push(s(o, a, l));
            for (var c = 8, u = 0; u < 24; ++u, c += 10) this.PALETTE_COLORS.push(s(c, c, c));
          },
        },
        {
          key: "escapeForHtml",
          value: function (n) {
            return n.replace(/[&<>\"]/gm, function (r) {
              return r == "&" ? "&amp;" : r == '"' ? "&quot;" : r == "<" ? "&lt;" : r == ">" ? "&gt;" : "";
            });
          },
        },
        {
          key: "linkify",
          value: function (n) {
            return n.replace(/(https?:\/\/[^\s]+)/gm, function (r) {
              return '<a href="' + r + '">' + r + "</a>";
            });
          },
        },
        {
          key: "ansiToHtml",
          value: function (n, r) {
            return this.process(n, r, !0);
          },
        },
        {
          key: "ansiToJson",
          value: function (n, r) {
            return (r = r || {}), (r.json = !0), (r.clearLine = !1), this.process(n, r, !0);
          },
        },
        {
          key: "ansiToText",
          value: function (n) {
            return this.process(n, {}, !1);
          },
        },
        {
          key: "process",
          value: function (n, r, i) {
            var s = this,
              o = this,
              a = n.split(/\033\[/),
              l = a.shift();
            r == null && (r = {}), (r.clearLine = /\r/.test(n));
            var c = a.map(function (h) {
              return s.processChunk(h, r, i);
            });
            if (r && r.json) {
              var u = o.processChunkJson("");
              return (
                (u.content = l),
                (u.clearLine = r.clearLine),
                c.unshift(u),
                r.remove_empty &&
                  (c = c.filter(function (h) {
                    return !h.isEmpty();
                  })),
                c
              );
            } else c.unshift(l);
            return c.join("");
          },
        },
        {
          key: "processChunkJson",
          value: function (n, r, i) {
            r = typeof r > "u" ? {} : r;
            var s = (r.use_classes = typeof r.use_classes < "u" && r.use_classes),
              o = (r.key = s ? "class" : "color"),
              a = {
                content: n,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                isInverted: !1,
                clearLine: r.clearLine,
                decoration: null,
                decorations: [],
                was_processed: !1,
                isEmpty: function () {
                  return !a.content;
                },
              },
              l = n.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
            if (!l) return a;
            a.content = l[4];
            var c = l[2].split(";");
            if (l[1] !== "" || l[3] !== "m" || !i) return a;
            for (var u = this; c.length > 0; ) {
              var h = c.shift(),
                f = parseInt(h);
              if (isNaN(f) || f === 0) (u.fg = u.bg = null), (u.decorations = []);
              else if (f === 1) u.decorations.push("bold");
              else if (f === 2) u.decorations.push("dim");
              else if (f === 3) u.decorations.push("italic");
              else if (f === 4) u.decorations.push("underline");
              else if (f === 5) u.decorations.push("blink");
              else if (f === 7) u.decorations.push("reverse");
              else if (f === 8) u.decorations.push("hidden");
              else if (f === 9) u.decorations.push("strikethrough");
              else if (f === 21) u.removeDecoration("bold");
              else if (f === 22) u.removeDecoration("bold"), u.removeDecoration("dim");
              else if (f === 23) u.removeDecoration("italic");
              else if (f === 24) u.removeDecoration("underline");
              else if (f === 25) u.removeDecoration("blink");
              else if (f === 27) u.removeDecoration("reverse");
              else if (f === 28) u.removeDecoration("hidden");
              else if (f === 29) u.removeDecoration("strikethrough");
              else if (f === 39) u.fg = null;
              else if (f === 49) u.bg = null;
              else if (f >= 30 && f < 38) u.fg = ks[0][f % 10][o];
              else if (f >= 90 && f < 98) u.fg = ks[1][f % 10][o];
              else if (f >= 40 && f < 48) u.bg = ks[0][f % 10][o];
              else if (f >= 100 && f < 108) u.bg = ks[1][f % 10][o];
              else if (f === 38 || f === 48) {
                var d = f === 38;
                if (c.length >= 1) {
                  var p = c.shift();
                  if (p === "5" && c.length >= 1) {
                    var m = parseInt(c.shift());
                    if (m >= 0 && m <= 255)
                      if (!s)
                        this.PALETTE_COLORS || u.setupPalette(), d ? (u.fg = this.PALETTE_COLORS[m]) : (u.bg = this.PALETTE_COLORS[m]);
                      else {
                        var O = m >= 16 ? "ansi-palette-" + m : ks[m > 7 ? 1 : 0][m % 8].class;
                        d ? (u.fg = O) : (u.bg = O);
                      }
                  } else if (p === "2" && c.length >= 3) {
                    var v = parseInt(c.shift()),
                      g = parseInt(c.shift()),
                      x = parseInt(c.shift());
                    if (v >= 0 && v <= 255 && g >= 0 && g <= 255 && x >= 0 && x <= 255) {
                      var y = v + ", " + g + ", " + x;
                      s
                        ? d
                          ? ((u.fg = "ansi-truecolor"), (u.fg_truecolor = y))
                          : ((u.bg = "ansi-truecolor"), (u.bg_truecolor = y))
                        : d
                        ? (u.fg = y)
                        : (u.bg = y);
                    }
                  }
                }
              }
            }
            return (
              (u.fg === null && u.bg === null && u.decorations.length === 0) ||
                ((a.fg = u.fg),
                (a.bg = u.bg),
                (a.fg_truecolor = u.fg_truecolor),
                (a.bg_truecolor = u.bg_truecolor),
                (a.decorations = u.decorations),
                (a.decoration = u.decorations.slice(-1).pop() || null),
                (a.was_processed = !0)),
              a
            );
          },
        },
        {
          key: "processChunk",
          value: function (n, r, i) {
            var s = this;
            r = r || {};
            var o = this.processChunkJson(n, r, i),
              a = r.use_classes;
            if (
              ((o.decorations = o.decorations.filter(function (d) {
                if (d === "reverse") {
                  o.fg || (o.fg = ks[0][7][a ? "class" : "color"]), o.bg || (o.bg = ks[0][0][a ? "class" : "color"]);
                  var p = o.fg;
                  (o.fg = o.bg), (o.bg = p);
                  var m = o.fg_truecolor;
                  return (o.fg_truecolor = o.bg_truecolor), (o.bg_truecolor = m), (o.isInverted = !0), !1;
                }
                return !0;
              })),
              r.json)
            )
              return o;
            if (o.isEmpty()) return "";
            if (!o.was_processed) return o.content;
            var l = [],
              c = [],
              u = [],
              h = {},
              f = function (p) {
                var m = [],
                  O = void 0;
                for (O in p) p.hasOwnProperty(O) && m.push("data-" + O + '="' + s.escapeForHtml(p[O]) + '"');
                return m.length > 0 ? " " + m.join(" ") : "";
              };
            return (
              o.isInverted && (h["ansi-is-inverted"] = "true"),
              o.fg &&
                (a
                  ? (l.push(o.fg + "-fg"), o.fg_truecolor !== null && ((h["ansi-truecolor-fg"] = o.fg_truecolor), (o.fg_truecolor = null)))
                  : l.push("color:rgb(" + o.fg + ")")),
              o.bg &&
                (a
                  ? (l.push(o.bg + "-bg"), o.bg_truecolor !== null && ((h["ansi-truecolor-bg"] = o.bg_truecolor), (o.bg_truecolor = null)))
                  : l.push("background-color:rgb(" + o.bg + ")")),
              o.decorations.forEach(function (d) {
                if (a) {
                  c.push("ansi-" + d);
                  return;
                }
                d === "bold"
                  ? c.push("font-weight:bold")
                  : d === "dim"
                  ? c.push("opacity:0.5")
                  : d === "italic"
                  ? c.push("font-style:italic")
                  : d === "hidden"
                  ? c.push("visibility:hidden")
                  : d === "strikethrough"
                  ? u.push("line-through")
                  : u.push(d);
              }),
              u.length && c.push("text-decoration:" + u.join(" ")),
              a
                ? '<span class="' + l.concat(c).join(" ") + '"' + f(h) + ">" + o.content + "</span>"
                : '<span style="' + l.concat(c).join(";") + '"' + f(h) + ">" + o.content + "</span>"
            );
          },
        },
        {
          key: "removeDecoration",
          value: function (n) {
            var r = this.decorations.indexOf(n);
            r >= 0 && this.decorations.splice(r, 1);
          },
        },
      ]),
      t
    );
  })(),
  Bhe = Vhe;
const jhe = Ql(Bhe);
var pS = { exports: {} };
function mS(t) {
  if (!t) return "";
  if (!/\r/.test(t)) return t;
  for (
    t = t.replace(
      /\r+\n/gm,
      `
`
    );
    /\r./.test(t);

  )
    t = t.replace(/^([^\r\n]*)\r+([^\r\n]+)/gm, function (e, n, r) {
      return r + n.slice(r.length);
    });
  return t;
}
function Zhe(t) {
  for (var e = 0, n = 0; n < t.length; n++) t[e].length <= t[n].length && (e = n);
  return e;
}
function BE(t) {
  if (!/\r/.test(t)) return t;
  for (var e = t.split("\r"), n = []; e.length > 0; ) {
    var r = Zhe(e);
    n.push(e[r]), (e = e.slice(r + 1));
  }
  return n.join("\r");
}
function zhe(t) {
  if (!t) return "";
  if (!/\r/.test(t)) return t;
  if (!/\n/.test(t)) return BE(t);
  t = t.replace(
    /\r+\n/gm,
    `
`
  );
  var e = t.lastIndexOf(`
`);
  return (
    mS(t.slice(0, e)) +
    `
` +
    BE(t.slice(e + 1))
  );
}
pS.exports = mS;
var Whe = (pS.exports.escapeCarriageReturn = mS);
pS.exports.escapeCarriageReturnSafe = zhe;
var gS = { exports: {} };
gS.exports;
(function (t) {
  var e = (function () {
    var n = String.fromCharCode,
      r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
      s = {};
    function o(l, c) {
      if (!s[l]) {
        s[l] = {};
        for (var u = 0; u < l.length; u++) s[l][l.charAt(u)] = u;
      }
      return s[l][c];
    }
    var a = {
      compressToBase64: function (l) {
        if (l == null) return "";
        var c = a._compress(l, 6, function (u) {
          return r.charAt(u);
        });
        switch (c.length % 4) {
          default:
          case 0:
            return c;
          case 1:
            return c + "===";
          case 2:
            return c + "==";
          case 3:
            return c + "=";
        }
      },
      decompressFromBase64: function (l) {
        return l == null
          ? ""
          : l == ""
          ? null
          : a._decompress(l.length, 32, function (c) {
              return o(r, l.charAt(c));
            });
      },
      compressToUTF16: function (l) {
        return l == null
          ? ""
          : a._compress(l, 15, function (c) {
              return n(c + 32);
            }) + " ";
      },
      decompressFromUTF16: function (l) {
        return l == null
          ? ""
          : l == ""
          ? null
          : a._decompress(l.length, 16384, function (c) {
              return l.charCodeAt(c) - 32;
            });
      },
      compressToUint8Array: function (l) {
        for (var c = a.compress(l), u = new Uint8Array(c.length * 2), h = 0, f = c.length; h < f; h++) {
          var d = c.charCodeAt(h);
          (u[h * 2] = d >>> 8), (u[h * 2 + 1] = d % 256);
        }
        return u;
      },
      decompressFromUint8Array: function (l) {
        if (l == null) return a.decompress(l);
        for (var c = new Array(l.length / 2), u = 0, h = c.length; u < h; u++) c[u] = l[u * 2] * 256 + l[u * 2 + 1];
        var f = [];
        return (
          c.forEach(function (d) {
            f.push(n(d));
          }),
          a.decompress(f.join(""))
        );
      },
      compressToEncodedURIComponent: function (l) {
        return l == null
          ? ""
          : a._compress(l, 6, function (c) {
              return i.charAt(c);
            });
      },
      decompressFromEncodedURIComponent: function (l) {
        return l == null
          ? ""
          : l == ""
          ? null
          : ((l = l.replace(/ /g, "+")),
            a._decompress(l.length, 32, function (c) {
              return o(i, l.charAt(c));
            }));
      },
      compress: function (l) {
        return a._compress(l, 16, function (c) {
          return n(c);
        });
      },
      _compress: function (l, c, u) {
        if (l == null) return "";
        var h,
          f,
          d = {},
          p = {},
          m = "",
          O = "",
          v = "",
          g = 2,
          x = 3,
          y = 2,
          S = [],
          k = 0,
          b = 0,
          _;
        for (_ = 0; _ < l.length; _ += 1)
          if (
            ((m = l.charAt(_)),
            Object.prototype.hasOwnProperty.call(d, m) || ((d[m] = x++), (p[m] = !0)),
            (O = v + m),
            Object.prototype.hasOwnProperty.call(d, O))
          )
            v = O;
          else {
            if (Object.prototype.hasOwnProperty.call(p, v)) {
              if (v.charCodeAt(0) < 256) {
                for (h = 0; h < y; h++) (k = k << 1), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++;
                for (f = v.charCodeAt(0), h = 0; h < 8; h++)
                  (k = (k << 1) | (f & 1)), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = f >> 1);
              } else {
                for (f = 1, h = 0; h < y; h++) (k = (k << 1) | f), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = 0);
                for (f = v.charCodeAt(0), h = 0; h < 16; h++)
                  (k = (k << 1) | (f & 1)), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = f >> 1);
              }
              g--, g == 0 && ((g = Math.pow(2, y)), y++), delete p[v];
            } else
              for (f = d[v], h = 0; h < y; h++) (k = (k << 1) | (f & 1)), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = f >> 1);
            g--, g == 0 && ((g = Math.pow(2, y)), y++), (d[O] = x++), (v = String(m));
          }
        if (v !== "") {
          if (Object.prototype.hasOwnProperty.call(p, v)) {
            if (v.charCodeAt(0) < 256) {
              for (h = 0; h < y; h++) (k = k << 1), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++;
              for (f = v.charCodeAt(0), h = 0; h < 8; h++)
                (k = (k << 1) | (f & 1)), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = f >> 1);
            } else {
              for (f = 1, h = 0; h < y; h++) (k = (k << 1) | f), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = 0);
              for (f = v.charCodeAt(0), h = 0; h < 16; h++)
                (k = (k << 1) | (f & 1)), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = f >> 1);
            }
            g--, g == 0 && ((g = Math.pow(2, y)), y++), delete p[v];
          } else
            for (f = d[v], h = 0; h < y; h++) (k = (k << 1) | (f & 1)), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = f >> 1);
          g--, g == 0 && ((g = Math.pow(2, y)), y++);
        }
        for (f = 2, h = 0; h < y; h++) (k = (k << 1) | (f & 1)), b == c - 1 ? ((b = 0), S.push(u(k)), (k = 0)) : b++, (f = f >> 1);
        for (;;)
          if (((k = k << 1), b == c - 1)) {
            S.push(u(k));
            break;
          } else b++;
        return S.join("");
      },
      decompress: function (l) {
        return l == null
          ? ""
          : l == ""
          ? null
          : a._decompress(l.length, 32768, function (c) {
              return l.charCodeAt(c);
            });
      },
      _decompress: function (l, c, u) {
        var h = [],
          f = 4,
          d = 4,
          p = 3,
          m = "",
          O = [],
          v,
          g,
          x,
          y,
          S,
          k,
          b,
          _ = { val: u(0), position: c, index: 1 };
        for (v = 0; v < 3; v += 1) h[v] = v;
        for (x = 0, S = Math.pow(2, 2), k = 1; k != S; )
          (y = _.val & _.position),
            (_.position >>= 1),
            _.position == 0 && ((_.position = c), (_.val = u(_.index++))),
            (x |= (y > 0 ? 1 : 0) * k),
            (k <<= 1);
        switch (x) {
          case 0:
            for (x = 0, S = Math.pow(2, 8), k = 1; k != S; )
              (y = _.val & _.position),
                (_.position >>= 1),
                _.position == 0 && ((_.position = c), (_.val = u(_.index++))),
                (x |= (y > 0 ? 1 : 0) * k),
                (k <<= 1);
            b = n(x);
            break;
          case 1:
            for (x = 0, S = Math.pow(2, 16), k = 1; k != S; )
              (y = _.val & _.position),
                (_.position >>= 1),
                _.position == 0 && ((_.position = c), (_.val = u(_.index++))),
                (x |= (y > 0 ? 1 : 0) * k),
                (k <<= 1);
            b = n(x);
            break;
          case 2:
            return "";
        }
        for (h[3] = b, g = b, O.push(b); ; ) {
          if (_.index > l) return "";
          for (x = 0, S = Math.pow(2, p), k = 1; k != S; )
            (y = _.val & _.position),
              (_.position >>= 1),
              _.position == 0 && ((_.position = c), (_.val = u(_.index++))),
              (x |= (y > 0 ? 1 : 0) * k),
              (k <<= 1);
          switch ((b = x)) {
            case 0:
              for (x = 0, S = Math.pow(2, 8), k = 1; k != S; )
                (y = _.val & _.position),
                  (_.position >>= 1),
                  _.position == 0 && ((_.position = c), (_.val = u(_.index++))),
                  (x |= (y > 0 ? 1 : 0) * k),
                  (k <<= 1);
              (h[d++] = n(x)), (b = d - 1), f--;
              break;
            case 1:
              for (x = 0, S = Math.pow(2, 16), k = 1; k != S; )
                (y = _.val & _.position),
                  (_.position >>= 1),
                  _.position == 0 && ((_.position = c), (_.val = u(_.index++))),
                  (x |= (y > 0 ? 1 : 0) * k),
                  (k <<= 1);
              (h[d++] = n(x)), (b = d - 1), f--;
              break;
            case 2:
              return O.join("");
          }
          if ((f == 0 && ((f = Math.pow(2, p)), p++), h[b])) m = h[b];
          else if (b === d) m = g + g.charAt(0);
          else return null;
          O.push(m), (h[d++] = g + m.charAt(0)), f--, (g = m), f == 0 && ((f = Math.pow(2, p)), p++);
        }
      },
    };
    return a;
  })();
  t != null
    ? (t.exports = e)
    : typeof angular < "u" &&
      angular != null &&
      angular.module("LZString", []).factory("LZString", function () {
        return e;
      });
})(gS);
var Uhe = gS.exports;
const Xhe = Ql(Uhe);
var Z = function () {
  return (
    (Z =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    Z.apply(this, arguments)
  );
};
function Jt(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function Xc(t, e, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (h) {
        o(h);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (h) {
        o(h);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(t, e || [])).next());
  });
}
function Hc(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    o;
  return (
    (o = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function a(c) {
    return function (u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (
          ((r = 1),
          i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done)
        )
          return s;
        switch (((i = 0), s && (c = [c[0] & 2, s.value]), c[0])) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return n.label++, { value: c[1], done: !1 };
          case 5:
            n.label++, (i = c[1]), (c = [0]);
            continue;
          case 7:
            (c = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (((s = n.trys), !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2))) {
              n = 0;
              continue;
            }
            if (c[0] === 3 && (!s || (c[1] > s[0] && c[1] < s[3]))) {
              n.label = c[1];
              break;
            }
            if (c[0] === 6 && n.label < s[1]) {
              (n.label = s[1]), (s = c);
              break;
            }
            if (s && n.label < s[2]) {
              (n.label = s[2]), n.ops.push(c);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        c = e.call(t, n);
      } catch (u) {
        (c = [6, u]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function wn(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++) (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]));
  return t.concat(s || Array.prototype.slice.call(e));
}
var hi = function (t) {
    return E.jsx(
      "svg",
      Z({ fill: "currentColor", height: "16", viewBox: "0 0 16 16", width: "16", xmlns: "http://www.w3.org/2000/svg" }, t)
    );
  },
  Hhe = function () {
    return E.jsxs(hi, {
      viewBox: "0 0 48 48",
      children: [
        E.jsx("title", { children: "Sign in" }),
        E.jsx("path", {
          d: "M9 42q-1.2 0-2.1-.9Q6 40.2 6 39V9q0-1.2.9-2.1Q7.8 6 9 6h14.55v3H9v30h14.55v3Zm24.3-9.25-2.15-2.15 5.1-5.1h-17.5v-3h17.4l-5.1-5.1 2.15-2.15 8.8 8.8Z",
        }),
      ],
    });
  },
  qhe = function () {
    return E.jsxs(hi, {
      viewBox: "0 0 48 48",
      children: [
        E.jsx("title", { children: "Sign out" }),
        E.jsx("path", {
          d: "M9 42q-1.2 0-2.1-.9Q6 40.2 6 39V9q0-1.2.9-2.1Q7.8 6 9 6h14.55v3H9v30h14.55v3Zm24.3-9.25-2.15-2.15 5.1-5.1h-17.5v-3h17.4l-5.1-5.1 2.15-2.15 8.8 8.8Z",
        }),
      ],
    });
  },
  Ng = function () {
    return E.jsxs(hi, {
      fill: "none",
      stroke: "currentColor",
      children: [
        E.jsx("title", { children: "Restart script" }),
        E.jsx("path", { d: "M8 2C4.68629 2 2 4.68629 2 8C2 10.0946 3.07333 11.9385 4.7 13.0118", strokeLinecap: "round" }),
        E.jsx("path", { d: "M14.0005 7.9998C14.0005 5.82095 12.8391 3.91335 11.1016 2.8623", strokeLinecap: "round" }),
        E.jsx("path", { d: "M14.0003 2.3335H11.167C10.8908 2.3335 10.667 2.55735 10.667 2.8335V5.66683", strokeLinecap: "round" }),
        E.jsx("path", {
          d: "M1.99967 13.6665L4.83301 13.6665C5.10915 13.6665 5.33301 13.4426 5.33301 13.1665L5.33301 10.3332",
          strokeLinecap: "round",
        }),
        E.jsx("path", { d: "M10 10L12 12L10 14", strokeLinecap: "round", strokeLinejoin: "round" }),
        E.jsx("path", { d: "M14.667 14L12.667 14", strokeLinecap: "round", strokeLinejoin: "round" }),
      ],
    });
  },
  Yhe = function () {
    return E.jsxs(hi, {
      children: [
        E.jsx("title", { children: "Run sandbox" }),
        E.jsx("path", {
          d: "M11.0792 8.1078C11.2793 8.25007 11.27 8.55012 11.0616 8.67981L6.02535 11.8135C5.79638 11.956 5.5 11.7913 5.5 11.5216L5.5 8.40703L5.5 4.80661C5.5 4.52735 5.81537 4.36463 6.04296 4.52647L11.0792 8.1078Z",
        }),
      ],
    });
  },
  Ghe = function () {
    return E.jsxs(hi, {
      children: [
        E.jsx("title", { children: "Click to go back" }),
        E.jsx("path", {
          d: "M9.64645 12.3536C9.84171 12.5488 10.1583 12.5488 10.3536 12.3536C10.5488 12.1583 10.5488 11.8417 10.3536 11.6464L9.64645 12.3536ZM10.3536 4.35355C10.5488 4.15829 10.5488 3.84171 10.3536 3.64644C10.1583 3.45118 9.84171 3.45118 9.64645 3.64644L10.3536 4.35355ZM6.07072 7.92929L5.71716 7.57573L6.07072 7.92929ZM10.3536 11.6464L6.42427 7.71716L5.71716 8.42426L9.64645 12.3536L10.3536 11.6464ZM6.42427 8.28284L10.3536 4.35355L9.64645 3.64644L5.71716 7.57573L6.42427 8.28284ZM6.42427 7.71716C6.58048 7.87337 6.58048 8.12663 6.42427 8.28284L5.71716 7.57573C5.48285 7.81005 5.48285 8.18995 5.71716 8.42426L6.42427 7.71716Z",
        }),
      ],
    });
  },
  Jhe = function () {
    return E.jsxs(hi, {
      children: [
        E.jsx("title", { children: "Click to go forward" }),
        E.jsx("path", {
          d: "M6.35355 3.64645C6.15829 3.45118 5.84171 3.45118 5.64645 3.64645C5.45118 3.84171 5.45118 4.15829 5.64645 4.35355L6.35355 3.64645ZM5.64645 11.6464C5.45118 11.8417 5.45118 12.1583 5.64645 12.3536C5.84171 12.5488 6.15829 12.5488 6.35355 12.3536L5.64645 11.6464ZM9.92929 8.07071L10.2828 8.42426L9.92929 8.07071ZM5.64645 4.35355L9.57574 8.28284L10.2828 7.57574L6.35355 3.64645L5.64645 4.35355ZM9.57574 7.71716L5.64645 11.6464L6.35355 12.3536L10.2828 8.42426L9.57574 7.71716ZM9.57574 8.28284C9.41952 8.12663 9.41953 7.87337 9.57574 7.71716L10.2828 8.42426C10.5172 8.18995 10.5172 7.81005 10.2828 7.57574L9.57574 8.28284Z",
        }),
      ],
    });
  },
  sI = function () {
    return E.jsxs(hi, {
      children: [
        E.jsx("title", { children: "Refresh preview" }),
        E.jsx("path", {
          clipRule: "evenodd",
          d: "M3.83325 7.99992C3.83325 5.69867 5.69853 3.83325 7.99934 3.83325C9.81246 3.83325 11.3563 4.99195 11.9285 6.61097C11.9396 6.6425 11.9536 6.67221 11.97 6.69992H8.80005C8.52391 6.69992 8.30005 6.92378 8.30005 7.19992C8.30005 7.47606 8.52391 7.69992 8.80005 7.69992H12.5667C12.8981 7.69992 13.1667 7.43129 13.1667 7.09992V3.33325C13.1667 3.05711 12.9429 2.83325 12.6667 2.83325C12.3906 2.83325 12.1667 3.05711 12.1667 3.33325V4.94608C11.2268 3.66522 9.7106 2.83325 7.99934 2.83325C5.14613 2.83325 2.83325 5.14651 2.83325 7.99992C2.83325 10.8533 5.14613 13.1666 7.99934 13.1666C9.91218 13.1666 11.5815 12.1266 12.474 10.5836C12.6123 10.3446 12.5306 10.0387 12.2915 9.90044C12.0525 9.76218 11.7466 9.84387 11.6084 10.0829C10.8873 11.3296 9.54072 12.1666 7.99934 12.1666C5.69853 12.1666 3.83325 10.3012 3.83325 7.99992Z",
          fillRule: "evenodd",
        }),
      ],
    });
  },
  Khe = function () {
    return E.jsxs(hi, {
      fill: "none",
      stroke: "currentColor",
      children: [
        E.jsx("title", { children: "Clean" }),
        E.jsx("circle", { cx: "7.99998", cy: "8.00004", r: "4.66667", strokeLinecap: "round" }),
        E.jsx("path", { d: "M4.66669 4.66663L11.3334 11.3333" }),
      ],
    });
  },
  efe = function () {
    return E.jsxs(hi, {
      fill: "none",
      stroke: "currentColor",
      children: [
        E.jsx("title", { children: "Open on CodeSandbox" }),
        E.jsx("path", {
          d: "M6.66665 3.33337H4.33331C3.78103 3.33337 3.33331 3.78109 3.33331 4.33337V11.6667C3.33331 12.219 3.78103 12.6667 4.33331 12.6667H11.6666C12.2189 12.6667 12.6666 12.219 12.6666 11.6667V9.33337",
          strokeLinecap: "round",
        }),
        E.jsx("path", { d: "M10 3.33337H12.5667C12.6219 3.33337 12.6667 3.37815 12.6667 3.43337V6.00004", strokeLinecap: "round" }),
        E.jsx("path", { d: "M7.33331 8.66668L12.5333 3.46667", strokeLinecap: "round" }),
      ],
    });
  },
  tfe = function () {
    return E.jsxs(hi, {
      stroke: "currentColor",
      children: [
        E.jsx("title", { children: "Close file" }),
        E.jsx("path", { d: "M12 4L4 12", strokeLinecap: "round" }),
        E.jsx("path", { d: "M4 4L12 12", strokeLinecap: "round" }),
      ],
    });
  },
  nfe = function () {
    return E.jsxs(hi, {
      children: [
        E.jsx("title", { children: "Open browser console" }),
        E.jsx("path", {
          d: "M5.65871 3.62037C5.44905 3.44066 5.1334 3.46494 4.95368 3.6746C4.77397 3.88427 4.79825 4.19992 5.00792 4.37963L5.65871 3.62037ZM5.00792 11.6204C4.79825 11.8001 4.77397 12.1157 4.95368 12.3254C5.1334 12.5351 5.44905 12.5593 5.65871 12.3796L5.00792 11.6204ZM9.9114 7.92407L10.2368 7.54445L9.9114 7.92407ZM5.00792 4.37963L9.586 8.3037L10.2368 7.54445L5.65871 3.62037L5.00792 4.37963ZM9.586 7.6963L5.00792 11.6204L5.65871 12.3796L10.2368 8.45555L9.586 7.6963ZM9.586 8.3037C9.39976 8.14407 9.39976 7.85594 9.586 7.6963L10.2368 8.45555C10.5162 8.2161 10.5162 7.7839 10.2368 7.54445L9.586 8.3037Z",
        }),
        E.jsx("path", {
          d: "M10 11.5C9.72386 11.5 9.5 11.7239 9.5 12C9.5 12.2761 9.72386 12.5 10 12.5V11.5ZM14.6667 12.5C14.9428 12.5 15.1667 12.2761 15.1667 12C15.1667 11.7239 14.9428 11.5 14.6667 11.5V12.5ZM10 12.5H14.6667V11.5H10V12.5Z",
        }),
      ],
    });
  },
  g1,
  ul = {
    colors: {
      surface1: "#ffffff",
      surface2: "#EFEFEF",
      surface3: "#F3F3F3",
      disabled: "#C5C5C5",
      base: "#323232",
      clickable: "#808080",
      hover: "#4D4D4D",
      accent: "#3973E0",
      error: "#EA3323",
      errorSurface: "#FCF1F0",
      warning: "#6A4516",
      warningSurface: "#FEF2C0",
    },
    syntax: {
      plain: "#151515",
      comment: { color: "#999", fontStyle: "italic" },
      keyword: "#7C5AE3",
      tag: "#0971F1",
      punctuation: "#3B3B3B",
      definition: "#85A600",
      property: "#3B3B3B",
      static: "#3B3B3B",
      string: "#2E6BD0",
    },
    font: {
      body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      mono: '"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',
      size: "13px",
      lineHeight: "20px",
    },
  },
  lx = {
    colors: {
      surface1: "#151515",
      surface2: "#252525",
      surface3: "#2F2F2F",
      disabled: "#4D4D4D",
      base: "#808080",
      clickable: "#999999",
      hover: "#C5C5C5",
      accent: "#E5E5E5",
      error: "#FFB4A6",
      errorSurface: "#690000",
      warning: "#E7C400",
      warningSurface: "#3A3000",
    },
    syntax: {
      plain: "#FFFFFF",
      comment: { color: "#757575", fontStyle: "italic" },
      keyword: "#77B7D7",
      tag: "#DFAB5C",
      punctuation: "#ffffff",
      definition: "#86D9CA",
      property: "#77B7D7",
      static: "#C64640",
      string: "#977CDC",
    },
    font: {
      body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      mono: '"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',
      size: "13px",
      lineHeight: "20px",
    },
  },
  rfe = {
    light: ul,
    dark: lx,
    auto:
      typeof window < "u" &&
      !((g1 = window == null ? void 0 : window.matchMedia) === null || g1 === void 0) &&
      g1.call(window, "(prefers-color-scheme: dark)").matches
        ? lx
        : ul,
  },
  nm = function (t) {
    var e = t.lastIndexOf("/");
    return t.slice(e + 1);
  },
  ife = function (t, e) {
    var n = (t[0] === "/" ? t.slice(1) : t).split("/"),
      r = [];
    if (n.length === 1) r.unshift(n[0]);
    else
      for (var i = 0; i < e.length; i++)
        for (var s = e[i].split("/"), o = 1; o <= n.length; o++) {
          var a = n[n.length - o],
            l = s[s.length - o];
          if ((r.length < o && r.unshift(a), a !== l)) break;
        }
    return r.length < n.length && r.unshift(".."), r.join("/");
  },
  jE = function (t) {
    var e = 0,
      n = 0,
      r = 0;
    if (t.startsWith("#")) {
      if (t.length < 7) return !0;
      (e = parseInt(t.substr(1, 2), 16)), (n = parseInt(t.substr(3, 2), 16)), (r = parseInt(t.substr(5, 2), 16));
    } else {
      var i = t.replace("rgb(", "").replace("rgba(", "").replace(")", "").split(",");
      if (i.length < 3) return !0;
      (e = parseInt(i[0], 10)), (n = parseInt(i[1], 10)), (r = parseInt(i[2], 10));
    }
    var s = (e * 299 + n * 587 + r * 114) / 1e3;
    return s < 128;
  },
  sfe = 0,
  rm = function () {
    var t = +(Date.now().toString(10).substr(0, 4) + sfe++);
    return t.toString(16);
  },
  ih,
  ut = "sp",
  ofe = ((ih = ure({ prefix: ut })), ih.createTheme),
  fe = ih.css;
ih.getCssText;
var oI = ih.keyframes,
  afe = {
    space: new Array(11).fill(" ").reduce(function (t, e, n) {
      var r;
      return Z(Z({}, t), ((r = {}), (r[n + 1] = "".concat((n + 1) * 4, "px")), r));
    }, {}),
    border: { radius: "4px" },
    layout: { height: "300px", headerHeight: "40px" },
    transitions: { default: "150ms ease" },
    zIndices: { base: "1", overlay: "2", top: "3" },
  },
  lfe = function (t) {
    var e = Object.entries(t.syntax),
      n = e.reduce(function (r, i) {
        var s,
          o = i[0],
          a = i[1],
          l = ((s = {}), (s["color-".concat(o)] = a), s);
        return (
          typeof a == "object" &&
            (l = Object.entries(a).reduce(function (c, u) {
              var h,
                f = u[0],
                d = u[1];
              return Z(Z({}, c), ((h = {}), (h["".concat(f, "-").concat(o)] = d), h));
            }, {})),
          Z(Z({}, r), l)
        );
      }, {});
    return Z(Z({}, afe), { colors: t.colors, font: t.font, syntax: n });
  },
  cfe = function (t) {
    var e, n, r, i, s;
    t === void 0 && (t = "light");
    var o = "default";
    if (typeof t == "string") {
      var a = rfe[t];
      if (!a) throw new Error("[sandpack-react]: invalid theme '".concat(t, "' provided."));
      return { theme: a, id: t, mode: jE(a.colors.surface1) ? "dark" : "light" };
    }
    var l = jE(
        (n = (e = t == null ? void 0 : t.colors) === null || e === void 0 ? void 0 : e.surface1) !== null && n !== void 0
          ? n
          : ul.colors.surface1
      )
        ? "dark"
        : "light",
      c = l === "dark" ? lx : ul,
      u = Z(Z({}, c.colors), (r = t == null ? void 0 : t.colors) !== null && r !== void 0 ? r : {}),
      h = Z(Z({}, c.syntax), (i = t == null ? void 0 : t.syntax) !== null && i !== void 0 ? i : {}),
      f = Z(Z({}, c.font), (s = t == null ? void 0 : t.font) !== null && s !== void 0 ? s : {}),
      d = { colors: u, syntax: h, font: f },
      p = t ? ufe(JSON.stringify(d)) : o;
    return { theme: d, id: "sp-".concat(p), mode: l };
  },
  ufe = function (t) {
    for (var e = 0, n = 0; n < t.length; e &= e) e = 31 * e + t.charCodeAt(n++);
    return Math.abs(e);
  },
  ZE = function () {
    return "";
  };
ZE.toString = ZE;
var aI = w.createContext({}),
  hfe = function (t) {
    var e = t.children,
      n = t.classes;
    return E.jsx(aI.Provider, { value: n || {}, children: e });
  },
  un = function () {
    var t = w.useContext(aI);
    return function (n, r) {
      r === void 0 && (r = []);
      var i = "".concat(ut, "-").concat(n);
      return ffe.apply(void 0, wn(wn([], r, !1), [i, t[i]], !1));
    };
  },
  ffe = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return t.filter(Boolean).join(" ");
  },
  dfe = fe({
    all: "initial",
    fontSize: "$font$size",
    fontFamily: "$font$body",
    display: "block",
    boxSizing: "border-box",
    textRendering: "optimizeLegibility",
    WebkitTapHighlightColor: "transparent",
    WebkitFontSmoothing: "subpixel-antialiased",
    variants: { variant: { dark: { colorScheme: "dark" }, light: { colorScheme: "light" } } },
    "@media screen and (min-resolution: 2dppx)": { WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale" },
    "*": { boxSizing: "border-box" },
    ".sp-wrapper:focus": { outline: "0" },
  }),
  OS = w.createContext({ theme: ul, id: "light", mode: "light" }),
  pfe = function (t) {
    var e = t.theme,
      n = t.children,
      r = t.className,
      i = Jt(t, ["theme", "children", "className"]),
      s = w.useState(e),
      o = s[0],
      a = s[1],
      l = cfe(o),
      c = l.theme,
      u = l.id,
      h = l.mode,
      f = un(),
      d = w.useMemo(
        function () {
          return ofe(u, lfe(c));
        },
        [c, u]
      );
    return (
      w.useEffect(
        function () {
          if (e !== "auto") {
            a(e);
            return;
          }
          var p = function (m) {
            var O = m.matches;
            a(O ? "dark" : "light");
          };
          return (
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", p),
            function () {
              window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", p);
            }
          );
        },
        [e]
      ),
      E.jsx(OS.Provider, {
        value: { theme: c, id: u, mode: h },
        children: E.jsx("div", Z({ className: f("wrapper", [d, dfe({ variant: h }), r]) }, i, { children: n })),
      })
    );
  };
OS.Consumer;
var Wt = {
    "/styles.css": {
      code: `body {
  font-family: sans-serif;
  -webkit-font-smoothing: auto;
  -moz-font-smoothing: auto;
  -moz-osx-font-smoothing: grayscale;
  font-smoothing: auto;
  text-rendering: optimizeLegibility;
  font-smooth: always;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}

h1 {
  font-size: 1.5rem;
}`,
    },
  },
  mfe = {
    files: {
      "/src/styles.css": Wt["/styles.css"],
      "/src/pages/index.astro": {
        code: `---
import "../styles.css";
const data = "world";
---

<h1>Hello {data}</h1>

<style>
  h1 {
    font-size: 1.5rem;
  }
</style>`,
      },
      ".env": { code: 'ASTRO_TELEMETRY_DISABLED="1"' },
      "/package.json": {
        code: JSON.stringify({
          dependencies: { astro: "^1.6.12", "esbuild-wasm": "^0.15.16" },
          scripts: { dev: "astro dev", start: "astro dev", build: "astro build", preview: "astro preview", astro: "astro" },
        }),
      },
    },
    main: "/src/pages/index.astro",
    environment: "node",
  },
  gfe = {
    files: Z(Z({}, Wt), {
      "/pages/_app.js": {
        code: `import '../styles.css'

export default function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}`,
      },
      "/pages/index.js": {
        code: `export default function Home({ data }) {
  return (
    <div>
      <h1>Hello {data}</h1>
    </div>
  );
}
  
export function getServerSideProps() {
  return {
    props: { data: "world" },
  }
}
`,
      },
      "/next.config.js": {
        code: `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
}

module.exports = nextConfig
`,
      },
      "/package.json": {
        code: JSON.stringify({
          name: "my-app",
          version: "0.1.0",
          private: !0,
          scripts: { dev: "NEXT_TELEMETRY_DISABLED=1 next dev", build: "next build", start: "next start", lint: "next lint" },
          dependencies: { next: "12.1.6", react: "18.2.0", "react-dom": "18.2.0", "@next/swc-wasm-nodejs": "12.1.6" },
        }),
      },
    }),
    main: "/pages/index.js",
    environment: "node",
  },
  Ofe = {
    files: {
      "/index.js": {
        code: `const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/html');
  res.end('Hello world');
});

server.listen(port, hostname, () => {
  console.log(\`Server running at http://\${hostname}:\${port}/\`);
});`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, scripts: { start: "node index.js" }, main: "index.js" }) },
    },
    main: "/index.js",
    environment: "node",
  },
  vfe = {
    files: Z(Z({}, Wt), {
      "/index.js": {
        code: `import "./styles.css";

document.getElementById("app").innerHTML = \`
<h1>Hello world</h1>
\`;
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/index.js"><\/script>
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          devDependencies: { vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
    }),
    main: "/index.js",
    environment: "node",
  },
  xfe = {
    files: Z(Z({}, Wt), {
      "/App.jsx": {
        code: `export default function App() {
  const data = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.jsx": {
        code: `import { render } from "preact";
import "./styles.css";

import App from "./App";

const root = document.getElementById("root");
render(<App />, root);
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.jsx"><\/script>
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          dependencies: { preact: "^10.16.0" },
          devDependencies: { "@preact/preset-vite": "^2.5.0", vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
      "/vite.config.js": {
        code: `import { defineConfig } from "vite";
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()],
});
`,
      },
    }),
    main: "/App.jsx",
    environment: "node",
  },
  bfe = {
    files: Z(Z({}, Wt), {
      "/App.tsx": {
        code: `export default function App() {
  const data: string = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.tsx": {
        code: `import { render } from "preact";
import "./styles.css";

import App from "./App";

const root = document.getElementById("root") as HTMLElement;
render(<App />, root);
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"><\/script>
  </body>
</html>
`,
      },
      "/tsconfig.json": {
        code: JSON.stringify(
          {
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              lib: ["DOM", "DOM.Iterable", "ESNext"],
              allowJs: !1,
              skipLibCheck: !0,
              esModuleInterop: !1,
              allowSyntheticDefaultImports: !0,
              strict: !0,
              forceConsistentCasingInFileNames: !0,
              module: "ESNext",
              moduleResolution: "Node",
              resolveJsonModule: !0,
              isolatedModules: !0,
              noEmit: !0,
              jsx: "react-jsx",
              jsxImportSource: "preact",
            },
            include: ["src"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "/tsconfig.node.json": {
        code: JSON.stringify(
          {
            compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node", allowSyntheticDefaultImports: !0 },
            include: ["vite.config.ts"],
          },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            scripts: { dev: "vite", build: "tsc && vite build", preview: "vite preview" },
            dependencies: { preact: "^10.16.0" },
            devDependencies: { "@preact/preset-vite": "^2.5.0", typescript: "^4.9.5", vite: "4.1.4", "esbuild-wasm": "^0.17.12" },
          },
          null,
          2
        ),
      },
      "/vite-env.d.ts": { code: '/// <reference types="vite/client" />' },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()],
})
`,
      },
    }),
    main: "/App.tsx",
    environment: "node",
  },
  yfe = {
    files: Z(Z({}, Wt), {
      "/App.jsx": {
        code: `export default function App() {
  const data = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.jsx": {
        code: `import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.jsx"><\/script>
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          dependencies: { react: "^18.2.0", "react-dom": "^18.2.0" },
          devDependencies: { "@vitejs/plugin-react": "3.1.0", vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
      "/vite.config.js": {
        code: `import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
});
`,
      },
    }),
    main: "/App.jsx",
    environment: "node",
  },
  wfe = {
    files: Z(Z({}, Wt), {
      "/App.tsx": {
        code: `export default function App() {
  const data: string = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.tsx": {
        code: `import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";
import React from "react";

const root = createRoot(document.getElementById("root") as HTMLElement);
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"><\/script>
  </body>
</html>
`,
      },
      "/tsconfig.json": {
        code: JSON.stringify(
          {
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              lib: ["DOM", "DOM.Iterable", "ESNext"],
              allowJs: !1,
              skipLibCheck: !0,
              esModuleInterop: !1,
              allowSyntheticDefaultImports: !0,
              strict: !0,
              forceConsistentCasingInFileNames: !0,
              module: "ESNext",
              moduleResolution: "Node",
              resolveJsonModule: !0,
              isolatedModules: !0,
              noEmit: !0,
              jsx: "react-jsx",
            },
            include: ["src"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "/tsconfig.node.json": {
        code: JSON.stringify(
          {
            compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node", allowSyntheticDefaultImports: !0 },
            include: ["vite.config.ts"],
          },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            scripts: { dev: "vite", build: "tsc && vite build", preview: "vite preview" },
            dependencies: { react: "^18.2.0", "react-dom": "^18.2.0" },
            devDependencies: {
              "@types/react": "^18.0.28",
              "@types/react-dom": "^18.0.11",
              "@vitejs/plugin-react": "^3.1.0",
              typescript: "^4.9.5",
              vite: "4.1.4",
              "esbuild-wasm": "^0.17.12",
            },
          },
          null,
          2
        ),
      },
      "/vite-env.d.ts": { code: '/// <reference types="vite/client" />' },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})
`,
      },
    }),
    main: "/App.tsx",
    environment: "node",
  },
  Sfe = {
    files: {
      "/src/styles.css": Wt["/styles.css"],
      "/src/App.svelte": {
        code: `<script>
const data = "world";
<\/script>

<h1>Hello {data}</h1>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.js": {
        code: `import App from './App.svelte'
import "./styles.css"

const app = new App({
  target: document.getElementById('app'),
})

export default app`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"><\/script>
  </body>
</html>
`,
      },
      "/vite.config.js": {
        code: `import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte()],
})`,
      },
      "/package.json": {
        code: JSON.stringify({
          type: "module",
          scripts: { dev: "vite" },
          devDependencies: { "@sveltejs/vite-plugin-svelte": "^2.0.2", svelte: "^3.55.1", vite: "4.0.4", "esbuild-wasm": "^0.17.12" },
        }),
      },
    },
    main: "/src/App.svelte",
    environment: "node",
  },
  kfe = {
    files: {
      "/src/styles.css": Wt["/styles.css"],
      "/src/App.svelte": {
        code: `<script lang="ts">
const data: string = "world";
<\/script>

<h1>Hello {data}</h1>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.ts": {
        code: `import App from './App.svelte'
import "./styles.css"

const app = new App({
  target: document.getElementById('app'),
})

export default app`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"><\/script>
  </body>
</html>
`,
      },
      "/vite-env.d.ts": {
        code: `/// <reference types="svelte" />
/// <reference types="vite/client" />`,
      },
      "svelte.config.js": {
        code: `import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
}
`,
      },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte()],
})`,
      },
      "tsconfig.json": {
        code: JSON.stringify(
          {
            extends: "@tsconfig/svelte/tsconfig.json",
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              module: "ESNext",
              resolveJsonModule: !0,
              allowJs: !0,
              checkJs: !0,
              isolatedModules: !0,
            },
            include: ["src/**/*.d.ts", "src/**/*.ts", "src/**/*.js", "src/**/*.svelte"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "tsconfig.node.json": {
        code: JSON.stringify(
          { compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node" }, include: ["vite.config.ts"] },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            type: "module",
            scripts: { dev: "vite" },
            devDependencies: {
              "@sveltejs/vite-plugin-svelte": "^2.0.2",
              "@tsconfig/svelte": "^3.0.0",
              svelte: "^3.55.1",
              "svelte-check": "^2.10.3",
              tslib: "^2.5.0",
              vite: "4.1.4",
              "esbuild-wasm": "^0.17.12",
            },
          },
          null,
          2
        ),
      },
    },
    main: "/src/App.svelte",
    environment: "node",
  },
  Cfe = {
    files: {
      "/src/styles.css": Wt["/styles.css"],
      "/src/App.vue": {
        code: `<script setup>
import { ref } from "vue";

const data = ref("world");
<\/script>

<template>
  <h1>Hello {{ data }}</h1>
</template>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.js": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css"
            
createApp(App).mount('#app')            
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"><\/script>
  </body>
</html>
`,
      },
      "/vite.config.js": {
        code: `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()]
})
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          dependencies: { vue: "^3.2.45" },
          devDependencies: { "@vitejs/plugin-vue": "3.2.0", vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
    },
    main: "/src/App.vue",
    environment: "node",
  },
  _fe = {
    files: {
      "/src/styles.css": Wt["/styles.css"],
      "/src/App.vue": {
        code: `<script setup lang="ts">
import { ref } from "vue";

const data = ref<string>("world");
<\/script>

<template>
  <h1>Hello {{ data }}</h1>
</template>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.ts": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css"

createApp(App).mount('#app')
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"><\/script>
  </body>
</html>
`,
      },
      "/vite-env.d.ts": { code: '/// <reference types="vite/client" />' },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()]
})
`,
      },
      "tsconfig.json": {
        code: JSON.stringify(
          {
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              module: "ESNext",
              moduleResolution: "Node",
              strict: !0,
              jsx: "preserve",
              resolveJsonModule: !0,
              isolatedModules: !0,
              esModuleInterop: !0,
              lib: ["ESNext", "DOM"],
              skipLibCheck: !0,
              noEmit: !0,
            },
            include: ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "tsconfig.node.json": {
        code: JSON.stringify(
          {
            compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node", allowSyntheticDefaultImports: !0 },
            include: ["vite.config.ts"],
          },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            scripts: { dev: "vite", build: "tsc && vite build", preview: "vite preview" },
            dependencies: { vue: "^3.2.47" },
            devDependencies: {
              "@vitejs/plugin-vue": "^4.0.0",
              vite: "4.1.4",
              "vue-tsc": "^1.2.0",
              typescript: "^4.9.5",
              "esbuild-wasm": "^0.17.12",
            },
          },
          null,
          2
        ),
      },
    },
    main: "/src/App.vue",
    environment: "node",
  },
  Efe = {
    files: {
      "/src/app/app.component.css": Wt["/styles.css"],
      "/src/app/app.component.html": {
        code: `<div>
<h1>{{ helloWorld }}</h1>
</div>     
`,
      },
      "/src/app/app.component.ts": {
        code: `import { Component } from "@angular/core";

@Component({
  selector: "app-root",
  templateUrl: "./app.component.html",
  styleUrls: ["./app.component.css"]
})
export class AppComponent {
  helloWorld = "Hello world";
}           
`,
      },
      "/src/app/app.module.ts": {
        code: `import { BrowserModule } from "@angular/platform-browser";
import { NgModule } from "@angular/core";
      
import { AppComponent } from "./app.component";
      
@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}       
`,
      },
      "/src/index.html": {
        code: `<!doctype html>
<html lang="en">
      
<head>
  <meta charset="utf-8">
  <title>Angular</title>
  <base href="/">
      
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
      
<body>
   <app-root></app-root>
</body>
      
</html>
`,
      },
      "/src/main.ts": {
        code: `import { enableProdMode } from "@angular/core";
import { platformBrowserDynamic } from "@angular/platform-browser-dynamic";
      
import { AppModule } from "./app/app.module";      

platformBrowserDynamic()
  .bootstrapModule(AppModule)
  .catch(err => console.log(err));
      
`,
      },
      "/src/polyfills.ts": {
        code: `import "core-js/proposals/reflect-metadata";   
      import "zone.js/dist/zone";
`,
      },
      "/package.json": {
        code: JSON.stringify({
          dependencies: {
            "@angular/core": "^11.2.0",
            "@angular/platform-browser": "^11.2.0",
            "@angular/platform-browser-dynamic": "^11.2.0",
            "@angular/common": "^11.2.0",
            "@angular/compiler": "^11.2.0",
            "zone.js": "0.11.3",
            "core-js": "3.8.3",
            rxjs: "6.6.3",
          },
          main: "/src/main.ts",
        }),
      },
    },
    main: "/src/app/app.component.ts",
    environment: "angular-cli",
  },
  Tfe = {
    files: Z(Z({}, Wt), {
      "/App.js": {
        code: `export default function App() {
  return <h1>Hello world</h1>
}
`,
      },
      "/index.js": {
        code: `import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);`,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>`,
      },
      "/package.json": {
        code: JSON.stringify({ dependencies: { react: "^18.0.0", "react-dom": "^18.0.0", "react-scripts": "^5.0.0" }, main: "/index.js" }),
      },
    }),
    main: "/App.js",
    environment: "create-react-app",
  },
  Pfe = {
    files: Z(Z({}, Wt), {
      "tsconfig.json": {
        code: `{
  "include": [
    "./**/*"
  ],
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "lib": [ "dom", "es2015" ],
    "jsx": "react-jsx"
  }
}`,
      },
      "/App.tsx": {
        code: `export default function App(): JSX.Element {
  return <h1>Hello world</h1>
}
`,
      },
      "/index.tsx": {
        code: `import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);`,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>`,
      },
      "/package.json": {
        code: JSON.stringify({
          dependencies: { react: "^18.0.0", "react-dom": "^18.0.0", "react-scripts": "^4.0.0" },
          devDependencies: { "@types/react": "^18.0.0", "@types/react-dom": "^18.0.0", typescript: "^4.0.0" },
          main: "/index.tsx",
        }),
      },
    }),
    main: "/App.tsx",
    environment: "create-react-app",
  },
  Afe = {
    files: Z(Z({}, Wt), {
      "/App.tsx": {
        code: `import { Component } from "solid-js";

const App: Component = () => {
  return <h1>Hello world</h1>
};

export default App;`,
      },
      "/index.tsx": {
        code: `import { render } from "solid-js/web";
import App from "./App";

import "./styles.css";

render(() => <App />, document.getElementById("app"));`,
      },
      "/index.html": {
        code: `<html>
<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
</head>
<body>
  <div id="app"></div>
  <script src="src/index.tsx"><\/script>
</body>
</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: { "solid-js": "1.3.15" }, main: "/index.tsx" }) },
    }),
    main: "/App.tsx",
    environment: "solid",
  },
  $fe = {
    files: Z(Z({}, Wt), {
      "/App.svelte": {
        code: `<style>
  h1 {
    font-size: 1.5rem;
  }
</style>

<script>
  let name = 'world';
<\/script>

<main>
  <h1>Hello {name}</h1>
</main>`,
      },
      "/index.js": {
        code: `import App from "./App.svelte";
import "./styles.css";

const app = new App({
  target: document.body
});

export default app;
      `,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="width=device-width" />

    <title>Svelte app</title>

    <link rel="stylesheet" href="public/bundle.css" />
  </head>

  <body>
    <script src="bundle.js"><\/script>
  </body>
</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: { svelte: "^3.0.0" }, main: "/index.js" }) },
    }),
    main: "/App.svelte",
    environment: "svelte",
  },
  Rfe = {
    files: {
      "tsconfig.json": {
        code: `{
  "include": [
    "./**/*"
  ],
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "lib": [ "dom", "es2015" ],
    "jsx": "react-jsx"
  }
}`,
      },
      "/add.ts": { code: "export const add = (a: number, b: number): number => a + b;" },
      "/add.test.ts": {
        code: `import { add } from './add';

describe('add', () => {
  test('Commutative Law of Addition', () => {
    expect(add(1, 2)).toBe(add(2, 1));
  });
});`,
      },
      "package.json": { code: JSON.stringify({ dependencies: {}, devDependencies: { typescript: "^4.0.0" }, main: "/add.ts" }) },
    },
    main: "/add.test.ts",
    environment: "parcel",
    mode: "tests",
  },
  Ife = {
    files: Z(Z({}, Wt), {
      "/index.js": {
        code: `import "./styles.css";

document.getElementById("app").innerHTML = \`
<h1>Hello world</h1>
\`;
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html>

<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
</head>

<body>
  <div id="app"></div>

  <script src="index.js">
  <\/script>
</body>

</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, main: "/index.js" }) },
    }),
    main: "/index.js",
    environment: "parcel",
  },
  Nfe = {
    files: Z(Z({}, Wt), {
      "tsconfig.json": {
        code: `{
  "compilerOptions": {
    "strict": true,
    "module": "commonjs",
    "jsx": "preserve",
    "esModuleInterop": true,
    "sourceMap": true,
    "allowJs": true,
    "lib": [
      "es6",
      "dom"
    ],
    "rootDir": "src",
    "moduleResolution": "node"
  }
}`,
      },
      "/index.ts": {
        code: `import "./styles.css";

document.getElementById("app").innerHTML = \`
<h1>Hello world</h1>
\`;
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html>

<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
</head>

<body>
  <div id="app"></div>

  <script src="index.ts">
  <\/script>
</body>

</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, devDependencies: { typescript: "^4.0.0" }, main: "/index.ts" }) },
    }),
    main: "/index.ts",
    environment: "parcel",
  },
  Lfe = {
    files: {
      "/src/styles.css": Wt["/styles.css"],
      "/src/App.vue": {
        code: `<template>
  <h1>Hello {{ msg }}</h1>
</template>

<script setup>
import { ref } from 'vue';
const msg = ref('world');
<\/script>`,
      },
      "/src/main.js": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css";

createApp(App).mount('#app')
`,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>codesandbox</title>
  </head>
  <body>
    <noscript>
      <strong
        >We're sorry but codesandbox doesn't work properly without JavaScript
        enabled. Please enable it to continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          name: "vue3",
          version: "0.1.0",
          private: !0,
          main: "/src/main.js",
          scripts: { serve: "vue-cli-service serve", build: "vue-cli-service build" },
          dependencies: { "core-js": "^3.26.1", vue: "^3.2.45" },
          devDependencies: { "@vue/cli-plugin-babel": "^5.0.8", "@vue/cli-service": "^5.0.8" },
        }),
      },
    },
    main: "/src/App.vue",
    environment: "vue-cli",
  },
  Mfe = {
    files: {
      "/src/styles.css": Wt["/styles.css"],
      "/src/App.vue": {
        code: `<template>
  <h1>Hello {{ msg }}</h1>
</template>

<script setup lang="ts">
import { ref } from 'vue';
const msg = ref<string>('world');
<\/script>`,
      },
      "/src/main.ts": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css";

createApp(App).mount('#app')
`,
      },
      "/src/shims-vue.d.ts": `/* eslint-disable */
declare module "*.vue" {
  import type { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}`,
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>codesandbox</title>
  </head>
  <body>
    <noscript>
      <strong
        >We're sorry but codesandbox doesn't work properly without JavaScript
        enabled. Please enable it to continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          name: "vue3-ts",
          version: "0.1.0",
          private: !0,
          main: "/src/main.ts",
          scripts: { serve: "vue-cli-service serve", build: "vue-cli-service build" },
          dependencies: { "core-js": "^3.26.1", vue: "^3.2.45" },
          devDependencies: {
            "@vue/cli-plugin-babel": "^5.0.8",
            "@vue/cli-plugin-typescript": "^5.0.8",
            "@vue/cli-service": "^5.0.8",
            typescript: "^4.9.3",
          },
        }),
      },
      "/tsconfig.json": {
        code: JSON.stringify({
          compilerOptions: {
            target: "esnext",
            module: "esnext",
            strict: !0,
            jsx: "preserve",
            moduleResolution: "node",
            experimentalDecorators: !0,
            skipLibCheck: !0,
            esModuleInterop: !0,
            allowSyntheticDefaultImports: !0,
            forceConsistentCasingInFileNames: !0,
            useDefineForClassFields: !0,
            sourceMap: !1,
            baseUrl: ".",
            types: ["webpack-env"],
            paths: { "@/*": ["src/*"] },
            lib: ["esnext", "dom", "dom.iterable", "scripthost"],
          },
          include: ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "tests/**/*.ts", "tests/**/*.tsx"],
          exclude: ["node_modules"],
        }),
      },
    },
    main: "/src/App.vue",
    environment: "vue-cli",
  },
  Dfe = {
    files: Z(Z({}, Wt), {
      "/index.html": {
        code: `<!DOCTYPE html>
<html>

<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="/styles.css" />
</head>

<body>
  <h1>Hello world</h1>
</body>

</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, main: "/index.html" }) },
    }),
    main: "/index.html",
    environment: "static",
  },
  zE = {
    static: Dfe,
    angular: Efe,
    react: Tfe,
    "react-ts": Pfe,
    solid: Afe,
    svelte: $fe,
    "test-ts": Rfe,
    "vanilla-ts": Nfe,
    vanilla: Ife,
    vue: Lfe,
    "vue-ts": Mfe,
    node: Ofe,
    nextjs: gfe,
    vite: vfe,
    "vite-react": yfe,
    "vite-react-ts": wfe,
    "vite-preact": xfe,
    "vite-preact-ts": bfe,
    "vite-vue": Cfe,
    "vite-vue-ts": _fe,
    "vite-svelte": Sfe,
    "vite-svelte-ts": kfe,
    astro: mfe,
  },
  cx = function (t) {
    var e,
      n,
      r,
      i,
      s,
      o,
      a = Yo(t.files),
      l = Qfe({ template: t.template, customSetup: t.customSetup, files: a }),
      c = Yo((n = (e = t.options) === null || e === void 0 ? void 0 : e.visibleFiles) !== null && n !== void 0 ? n : []),
      u =
        !((r = t.options) === null || r === void 0) && r.activeFile
          ? WE((i = t.options) === null || i === void 0 ? void 0 : i.activeFile, l.files)
          : void 0;
    c.length === 0 &&
      a &&
      Object.keys(a).forEach(function (d) {
        var p = a[d];
        if (typeof p == "string") {
          c.push(d);
          return;
        }
        !u && p.active && ((u = d), p.hidden === !0 && c.push(d)), p.hidden || c.push(d);
      }),
      c.length === 0 && (c = [l.main]),
      l.entry && !l.files[l.entry] && (l.entry = WE(l.entry, l.files)),
      !u && l.main && (u = l.main),
      (!u || !l.files[u]) && (u = c[0]),
      c.includes(u) || c.push(u);
    var h = yre(
        l.files,
        (s = l.dependencies) !== null && s !== void 0 ? s : {},
        (o = l.devDependencies) !== null && o !== void 0 ? o : {},
        l.entry
      ),
      f = c.filter(function (d) {
        return h[d];
      });
    return { visibleFiles: f, activeFile: u, files: h, environment: l.environment, shouldUpdatePreview: !0 };
  },
  WE = function (t, e) {
    var n = Yo(e),
      r = Yo(t);
    if (r in n) return r;
    if (!t) return null;
    for (var i = null, s = 0, o = [".js", ".jsx", ".ts", ".tsx"]; !i && s < o.length; ) {
      var a = r.split(".")[0],
        l = "".concat(a).concat(o[s]);
      n[l] !== void 0 && (i = l), s++;
    }
    return i;
  },
  Qfe = function (t) {
    var e = t.files,
      n = t.template,
      r = t.customSetup;
    if (!n) {
      if (!r) {
        var i = zE.vanilla;
        return Z(Z({}, i), { files: Z(Z({}, i.files), Vd(e)) });
      }
      if (!e || Object.keys(e).length === 0) throw new Error("[sandpack-react]: without a template, you must pass at least one file");
      return Z(Z({}, r), { files: Vd(e) });
    }
    var s = zE[n];
    if (!s) throw new Error('[sandpack-react]: invalid template "'.concat(n, '" provided'));
    return !r && !e
      ? s
      : {
          files: Vd(Z(Z({}, s.files), e)),
          dependencies: Z(Z({}, s.dependencies), r == null ? void 0 : r.dependencies),
          devDependencies: Z(Z({}, s.devDependencies), r == null ? void 0 : r.devDependencies),
          entry: Yo(r == null ? void 0 : r.entry),
          main: s.main,
          environment: (r == null ? void 0 : r.environment) || s.environment,
        };
  },
  Vd = function (t) {
    return t
      ? Object.keys(t).reduce(function (e, n) {
          return typeof t[n] == "string" ? (e[n] = { code: t[n] }) : (e[n] = t[n]), e;
        }, {})
      : {};
  },
  Ffe = function (t, e) {
    var n = w.useState({ editorState: "pristine" }),
      r = n[0],
      i = n[1],
      s = cx(t),
      o = lu(s.files, e) ? "pristine" : "dirty";
    return (
      o !== r.editorState &&
        i(function (a) {
          return Z(Z({}, a), { editorState: o });
        }),
      r
    );
  },
  Vfe = 4e4,
  Bfe = function (t, e) {
    var n,
      r,
      i,
      s = t.options,
      o = t.customSetup,
      a = t.teamId,
      l = t.sandboxId;
    s ?? (s = {}), o ?? (o = {});
    var c = (s == null ? void 0 : s.initMode) || "lazy",
      u = w.useState({
        startRoute: s == null ? void 0 : s.startRoute,
        bundlerState: void 0,
        error: null,
        initMode: c,
        reactDevTools: void 0,
        status: !((n = s == null ? void 0 : s.autorun) !== null && n !== void 0) || n ? "initial" : "idle",
      }),
      h = u[0],
      f = u[1],
      d = w.useRef(),
      p = w.useRef(null),
      m = w.useRef(null),
      O = w.useRef({}),
      v = w.useRef({}),
      g = w.useRef(null),
      x = w.useRef({}),
      y = w.useRef(),
      S = w.useRef({ global: {} }),
      k = w.useRef(),
      b = w.useRef(e.environment),
      _ = w.useCallback(
        function ($, B, ie) {
          return Xc(void 0, void 0, void 0, function () {
            var L, pe, Ce, me, Y, q, se;
            return Hc(this, function (ue) {
              switch (ue.label) {
                case 0:
                  return (
                    v.current[B] && v.current[B].destroy(),
                    s ?? (s = {}),
                    o ?? (o = {}),
                    (L = (Y = s == null ? void 0 : s.bundlerTimeOut) !== null && Y !== void 0 ? Y : Vfe),
                    g.current && clearTimeout(g.current),
                    (pe = typeof y.current != "function"),
                    pe &&
                      (g.current = setTimeout(function () {
                        T(),
                          f(function (ve) {
                            return Z(Z({}, ve), { status: "timeout" });
                          });
                      }, L)),
                    [
                      4,
                      Ere(
                        $,
                        { files: e.files, template: e.environment },
                        {
                          externalResources: s.externalResources,
                          bundlerURL: s.bundlerURL,
                          startRoute: (q = ie == null ? void 0 : ie.startRoute) !== null && q !== void 0 ? q : s.startRoute,
                          fileResolver: s.fileResolver,
                          skipEval: (se = s.skipEval) !== null && se !== void 0 ? se : !1,
                          logLevel: s.logLevel,
                          showOpenInCodeSandbox: !1,
                          showErrorScreen: !0,
                          showLoadingScreen: !1,
                          reactDevTools: h.reactDevTools,
                          customNpmRegistries: o == null ? void 0 : o.npmRegistries,
                          teamId: a,
                          sandboxId: l,
                        }
                      ),
                    ]
                  );
                case 1:
                  return (
                    (Ce = ue.sent()),
                    typeof y.current != "function" && (y.current = Ce.listen(Q)),
                    (x.current[B] = x.current[B] || {}),
                    S.current[B] &&
                      (Object.keys(S.current[B]).forEach(function (ve) {
                        var Pe = S.current[B][ve],
                          Fe = Ce.listen(Pe);
                        x.current[B][ve] = Fe;
                      }),
                      (S.current[B] = {})),
                    (me = Object.entries(S.current.global)),
                    me.forEach(function (ve) {
                      var Pe = ve[0],
                        Fe = ve[1],
                        rt = Ce.listen(Fe);
                      x.current[B][Pe] = rt;
                    }),
                    (v.current[B] = Ce),
                    [2]
                  );
              }
            });
          });
        },
        [e.environment, e.files, h.reactDevTools]
      ),
      T = w.useCallback(function () {
        Object.keys(v.current).map(V), typeof y.current == "function" && (y.current(), (y.current = void 0));
      }, []),
      P = w.useCallback(
        function () {
          return Xc(void 0, void 0, void 0, function () {
            return Hc(this, function ($) {
              switch ($.label) {
                case 0:
                  return [
                    4,
                    Promise.all(
                      Object.entries(O.current).map(function (B) {
                        var ie = B[0],
                          L = B[1],
                          pe = L.iframe,
                          Ce = L.clientPropsOverride,
                          me = Ce === void 0 ? {} : Ce;
                        return Xc(void 0, void 0, void 0, function () {
                          return Hc(this, function (Y) {
                            switch (Y.label) {
                              case 0:
                                return [4, _(pe, ie, me)];
                              case 1:
                                return Y.sent(), [2];
                            }
                          });
                        });
                      })
                    ),
                  ];
                case 1:
                  return (
                    $.sent(),
                    f(function (B) {
                      return Z(Z({}, B), { error: null, status: "running" });
                    }),
                    [2]
                  );
              }
            });
          });
        },
        [_]
      );
    d.current = function ($) {
      $.some(function (B) {
        return B.isIntersecting;
      })
        ? P()
        : T();
    };
    var M = w.useCallback(
        function () {
          var $,
            B,
            ie,
            L = ($ = s == null ? void 0 : s.autorun) !== null && $ !== void 0 ? $ : !0;
          if (L) {
            var pe = (B = s == null ? void 0 : s.initModeObserverOptions) !== null && B !== void 0 ? B : { rootMargin: "1000px 0px" };
            p.current && m.current && ((ie = p.current) === null || ie === void 0 || ie.unobserve(m.current)),
              m.current && h.initMode === "lazy"
                ? ((p.current = new IntersectionObserver(function (Ce) {
                    var me, Y;
                    Ce.some(function (q) {
                      return q.isIntersecting;
                    }) &&
                      Ce.some(function (q) {
                        return q.isIntersecting;
                      }) &&
                      m.current &&
                      ((me = d.current) === null || me === void 0 || me.call(d, Ce),
                      (Y = p.current) === null || Y === void 0 || Y.unobserve(m.current));
                  }, pe)),
                  p.current.observe(m.current))
                : m.current && h.initMode === "user-visible"
                ? ((p.current = new IntersectionObserver(function (Ce) {
                    var me;
                    (me = d.current) === null || me === void 0 || me.call(d, Ce);
                  }, pe)),
                  p.current.observe(m.current))
                : P();
          }
        },
        [s == null ? void 0 : s.autorun, s == null ? void 0 : s.initModeObserverOptions, P, h.initMode, T]
      ),
      D = w.useCallback(
        function ($, B, ie) {
          return Xc(void 0, void 0, void 0, function () {
            return Hc(this, function (L) {
              switch (L.label) {
                case 0:
                  return (O.current[B] = { iframe: $, clientPropsOverride: ie }), h.status !== "running" ? [3, 2] : [4, _($, B, ie)];
                case 1:
                  L.sent(), (L.label = 2);
                case 2:
                  return [2];
              }
            });
          });
        },
        [_, h.status]
      ),
      V = function ($) {
        var B,
          ie,
          L = v.current[$];
        L
          ? (L.destroy(),
            (B = L.iframe.contentWindow) === null || B === void 0 || B.location.replace("about:blank"),
            L.iframe.removeAttribute("src"),
            delete v.current[$])
          : delete O.current[$],
          g.current && clearTimeout(g.current);
        var pe = Object.values((ie = x.current[$]) !== null && ie !== void 0 ? ie : {});
        pe.forEach(function (me) {
          var Y = Object.values(me);
          Y.forEach(function (q) {
            return q();
          });
        });
        var Ce = Object.keys(v.current).length > 0 ? "running" : "idle";
        f(function (me) {
          return Z(Z({}, me), { status: Ce });
        });
      },
      Q = function ($) {
        $.type === "start"
          ? f(function (B) {
              return Z(Z({}, B), { error: null });
            })
          : $.type === "state"
          ? f(function (B) {
              return Z(Z({}, B), { bundlerState: $.state });
            })
          : ($.type === "done" && !$.compilatonError) || $.type === "connected"
          ? (g.current && clearTimeout(g.current),
            f(function (B) {
              return Z(Z({}, B), { error: null });
            }))
          : $.type === "action" && $.action === "show-error"
          ? (g.current && clearTimeout(g.current),
            f(function (B) {
              return Z(Z({}, B), { error: wre($) });
            }))
          : $.type === "action" &&
            $.action === "notification" &&
            $.notificationType === "error" &&
            f(function (B) {
              return Z(Z({}, B), { error: { message: $.title } });
            });
      },
      N = function ($) {
        f(function (B) {
          return Z(Z({}, B), { reactDevTools: $ });
        });
      },
      G = (r = s == null ? void 0 : s.recompileMode) !== null && r !== void 0 ? r : "delayed",
      H = (i = s == null ? void 0 : s.recompileDelay) !== null && i !== void 0 ? i : 200,
      te = function ($, B) {
        if (h.status !== "running") {
          console.warn("[sandpack-react]: dispatch cannot be called while in idle mode");
          return;
        }
        B
          ? v.current[B].dispatch($)
          : Object.values(v.current).forEach(function (ie) {
              ie.dispatch($);
            });
      },
      le = function ($, B) {
        if (B)
          if (v.current[B]) {
            var ie = v.current[B].listen($);
            return ie;
          } else {
            var L = rm();
            (S.current[B] = S.current[B] || {}), (x.current[B] = x.current[B] || {}), (S.current[B][L] = $);
            var ie = function () {
              S.current[B][L] ? delete S.current[B][L] : x.current[B][L] && (x.current[B][L](), delete x.current[B][L]);
            };
            return ie;
          }
        else {
          var pe = rm();
          S.current.global[pe] = $;
          var Ce = Object.values(v.current),
            me = Ce.map(function (q) {
              return q.listen($);
            }),
            ie = function () {
              me.forEach(function (q) {
                return q();
              }),
                delete S.current.global[pe],
                Object.values(x.current).forEach(function (q) {
                  var se;
                  (se = q == null ? void 0 : q[pe]) === null || se === void 0 || se.call(q);
                });
            };
          return ie;
        }
      };
    return (
      w.useEffect(
        function () {
          if (!(h.status !== "running" || !e.shouldUpdatePreview)) {
            if (
              (b.current !== e.environment &&
                ((b.current = e.environment),
                Object.entries(v.current).forEach(function (B) {
                  var ie = B[0],
                    L = B[1];
                  D(L.iframe, ie);
                })),
              G === "immediate" &&
                Object.values(v.current).forEach(function (B) {
                  B.status === "done" && B.updateSandbox({ files: e.files, template: e.environment });
                }),
              G === "delayed")
            ) {
              if (typeof window > "u") return;
              window.clearTimeout(k.current),
                (k.current = window.setTimeout(function () {
                  Object.values(v.current).forEach(function (B) {
                    B.status === "done" && B.updateSandbox({ files: e.files, template: e.environment });
                  });
                }, H));
            }
            return function () {
              window.clearTimeout(k.current);
            };
          }
        },
        [e.files, e.environment, e.shouldUpdatePreview, H, G, D, h.status]
      ),
      w.useEffect(
        function () {
          c !== h.initMode &&
            (f(function (B) {
              return Z(Z({}, B), { initMode: c });
            }),
            M());
        },
        [c, M, h.initMode]
      ),
      w.useEffect(function () {
        return function () {
          typeof y.current == "function" && y.current(),
            g.current && clearTimeout(g.current),
            k.current && clearTimeout(k.current),
            p.current && p.current.disconnect();
        };
      }, []),
      [
        h,
        {
          clients: v.current,
          initializeSandpackIframe: M,
          runSandpack: P,
          registerBundler: D,
          unregisterBundler: V,
          registerReactDevTools: N,
          addListener: le,
          dispatchMessage: te,
          lazyAnchorRef: m,
          unsubscribeClientListenersRef: x,
          queuedListenersRef: S,
        },
      ]
    );
  },
  jfe = function (t) {
    var e = cx(t),
      n = w.useState(e),
      r = n[0],
      i = n[1],
      s = w.useRef(!1);
    w.useEffect(
      function () {
        s.current ? i(cx(t)) : (s.current = !0);
      },
      [t.files, t.customSetup, t.template]
    );
    var o = function (l, c, u) {
        u === void 0 && (u = !0),
          i(function (h) {
            var f,
              d = h.files;
            return (
              typeof l == "string" && typeof c == "string"
                ? (d = Z(Z({}, d), ((f = {}), (f[l] = Z(Z({}, d[l]), { code: c })), f)))
                : typeof l == "object" && (d = Z(Z({}, d), Vd(l))),
              Z(Z({}, h), { files: Yo(d), shouldUpdatePreview: u })
            );
          });
      },
      a = {
        openFile: function (l) {
          i(function (c) {
            var u = c.visibleFiles,
              h = Jt(c, ["visibleFiles"]),
              f = u.includes(l) ? u : wn(wn([], u, !0), [l], !1);
            return Z(Z({}, h), { activeFile: l, visibleFiles: f });
          });
        },
        resetFile: function (l) {
          i(function (c) {
            var u;
            return Z(Z({}, c), { files: Z(Z({}, c.files), ((u = {}), (u[l] = e.files[l]), u)) });
          });
        },
        resetAllFiles: function () {
          i(function (l) {
            return Z(Z({}, l), { files: e.files });
          });
        },
        setActiveFile: function (l) {
          r.files[l] &&
            i(function (c) {
              return Z(Z({}, c), { activeFile: l });
            });
        },
        updateCurrentFile: function (l, c) {
          c === void 0 && (c = !0), o(r.activeFile, l, c);
        },
        updateFile: o,
        addFile: o,
        closeFile: function (l) {
          r.visibleFiles.length !== 1 &&
            i(function (c) {
              var u = c.visibleFiles,
                h = c.activeFile,
                f = Jt(c, ["visibleFiles", "activeFile"]),
                d = u.indexOf(l),
                p = u.filter(function (m) {
                  return m !== l;
                });
              return Z(Z({}, f), { activeFile: l === h ? (d === 0 ? u[1] : u[d - 1]) : h, visibleFiles: p });
            });
        },
        deleteFile: function (l, c) {
          c === void 0 && (c = !0),
            i(function (u) {
              var h = u.visibleFiles,
                f = u.files,
                d = u.activeFile,
                p = Jt(u, ["visibleFiles", "files", "activeFile"]),
                m = Z({}, f);
              delete m[l];
              var O = h.filter(function (x) {
                  return x !== l;
                }),
                v = O.length === 0;
              if (v) {
                var g = Object.keys(f)[Object.keys(f).length - 1];
                return Z(Z({}, p), { visibleFiles: [g], activeFile: g, files: m, shouldUpdatePreview: c });
              }
              return Z(Z({}, p), { visibleFiles: O, activeFile: l === d ? O[O.length - 1] : d, files: m, shouldUpdatePreview: c });
            });
        },
      };
    return [Z(Z({}, r), { visibleFilesFromProps: e.visibleFiles }), a];
  },
  vS = w.createContext(null),
  Zfe = function (t) {
    var e,
      n,
      r,
      i = t.children,
      s = t.options,
      o = t.style,
      a = t.className,
      l = t.theme,
      c = jfe(t),
      u = c[0],
      h = c[1],
      f = Bfe(t, u),
      d = f[0],
      p = f[1],
      m = p.dispatchMessage,
      O = p.addListener,
      v = Jt(p, ["dispatchMessage", "addListener"]),
      g = Ffe(t, u.files);
    return (
      w.useEffect(function () {
        v.initializeSandpackIframe();
      }, []),
      E.jsx(vS.Provider, {
        value: Z(Z(Z(Z(Z(Z({}, u), d), g), h), v), {
          autoReload: (n = (e = t.options) === null || e === void 0 ? void 0 : e.autoReload) !== null && n !== void 0 ? n : !0,
          teamId: t == null ? void 0 : t.teamId,
          exportOptions: (r = t == null ? void 0 : t.customSetup) === null || r === void 0 ? void 0 : r.exportOptions,
          listen: O,
          dispatch: m,
        }),
        children: E.jsx(hfe, {
          classes: s == null ? void 0 : s.classes,
          children: E.jsx(pfe, { className: a, style: o, theme: l, children: i }),
        }),
      })
    );
  };
vS.Consumer;
function Bt() {
  var t = w.useContext(vS);
  if (t === null) throw new Error('[sandpack-react]: "useSandpack" must be wrapped by a "SandpackProvider"');
  var e = t.dispatch,
    n = t.listen,
    r = Jt(t, ["dispatch", "listen"]);
  return { sandpack: Z({}, r), dispatch: e, listen: n };
}
var lI = function () {
    var t,
      e,
      n,
      r = Bt().sandpack;
    return {
      code: (t = r.files[r.activeFile]) === null || t === void 0 ? void 0 : t.code,
      readOnly: (n = (e = r.files[r.activeFile]) === null || e === void 0 ? void 0 : e.readOnly) !== null && n !== void 0 ? n : !1,
      updateCode: r.updateCurrentFile,
    };
  },
  Rc,
  Kf,
  O1,
  ss = fe({ svg: { margin: "auto" } }),
  Bn = fe(
    ((Rc = {
      appearance: "none",
      outline: "none",
      display: "flex",
      alignItems: "center",
      fontSize: "inherit",
      fontFamily: "inherit",
      backgroundColor: "transparent",
      transition: "color $default, background $default",
      cursor: "pointer",
      color: "$colors$clickable",
      border: 0,
      textDecoration: "none",
      "&:disabled": { color: "$colors$disabled" },
      "&:hover:not(:disabled,[data-active='true'])": { color: "$colors$hover" },
      '&[data-active="true"]': { color: "$colors$accent" },
      svg: { minWidth: "$space$4", width: "$space$4", height: "$space$4" },
    }),
    (Rc["&.".concat(ss)] = { padding: "$space$1", height: "$space$7", display: "flex" }),
    (Rc["&.".concat(ss, "&:not(:has(span))")] = { width: "$space$7" }),
    (Rc["&.".concat(ss, "&:has(svg + span)")] = { paddingRight: "$space$3", paddingLeft: "$space$2", gap: "$space$1" }),
    Rc)
  ),
  sa = fe({
    backgroundColor: "$colors$surface2",
    borderRadius: "99999px",
    border: "1px solid $colors$surface3",
    '&[data-active="true"]': { color: "$colors$surface1", background: "$colors$accent" },
    "&:hover:not(:disabled,[data-active='true'])": { backgroundColor: "$colors$surface3" },
  }),
  zfe = fe({ padding: 0 }),
  xS = oI({ "0%": { opacity: 0 }, "100%": { opacity: 1 } }),
  mu = fe({
    position: "absolute",
    bottom: "0",
    left: "0",
    right: "0",
    top: "0",
    margin: "0",
    overflow: "auto",
    height: "100%",
    zIndex: "$top",
  }),
  cI = fe(
    ((Kf = {
      whiteSpace: "pre-wrap",
      padding: "$space$10",
      backgroundColor: "$colors$surface1",
      display: "flex",
      gap: "$space$2",
      flexDirection: "column",
    }),
    (Kf[".".concat(Bn)] = { width: "auto", gap: "$space$2", padding: "0 $space$3 0 $space$2", marginTop: "$space$1" }),
    (Kf.variants = { solidBg: { true: { backgroundColor: "$colors$errorSurface" } } }),
    Kf)
  ),
  ux = fe(
    ((O1 = { padding: "$space$10", backgroundColor: "$colors$surface1" }),
    (O1[".".concat(Bn)] = { marginTop: "$space$6", width: "auto", gap: "$space$2", padding: "0 $space$3 0 $space$2" }),
    O1)
  ),
  Ns = fe({
    animation: "".concat(xS, " 150ms ease"),
    color: "$colors$error",
    display: "flex",
    flexDirection: "column",
    gap: "$space$3",
    variants: { errorCode: { true: { fontFamily: "$font$mono" } } },
    a: { color: "inherit" },
    p: { margin: 0 },
  }),
  v1,
  Wfe = fe({ borderBottom: "1px solid $colors$surface2", background: "$colors$surface1" }),
  Ufe = fe({
    padding: "0 $space$2",
    overflow: "auto",
    display: "flex",
    flexWrap: "nowrap",
    alignItems: "stretch",
    minHeight: "40px",
    marginBottom: "-1px",
  }),
  uI = fe({
    padding: "0 $space$1 0 $space$1",
    borderRadius: "$border$radius",
    marginLeft: "$space$1",
    width: "$space$5",
    visibility: "hidden",
    svg: { width: "$space$3", height: "$space$3", display: "block", position: "relative", top: 1 },
  }),
  Xfe = fe(
    ((v1 = { padding: "0 $space$2", height: "$layout$headerHeight", whiteSpace: "nowrap", "&:focus": { outline: "none" } }),
    (v1["&:hover > .".concat(uI)] = { visibility: "unset" }),
    v1)
  ),
  hI = function (t) {
    var e = t.closableTabs,
      n = t.className,
      r = Jt(t, ["closableTabs", "className"]),
      i = Bt().sandpack,
      s = un(),
      o = i.activeFile,
      a = i.visibleFiles,
      l = i.setActiveFile,
      c = function (h) {
        h.stopPropagation();
        var f = h.target.closest("[data-active]"),
          d = f == null ? void 0 : f.getAttribute("title");
        d && i.closeFile(d);
      },
      u = function (h) {
        var f = nm(h),
          d = a.reduce(function (p, m) {
            if (m === h) return p;
            var O = nm(m);
            return O === f && p.push(m), p;
          }, []);
        return d.length === 0 ? f : ife(h, d);
      };
    return E.jsx(
      "div",
      Z({ className: s("tabs", [Wfe, n]), translate: "no" }, r, {
        children: E.jsx("div", {
          "aria-label": "Select active file",
          className: s("tabs-scrollable-container", [Ufe]),
          role: "tablist",
          children: a.map(function (h) {
            return E.jsxs(
              "button",
              {
                "aria-selected": h === o,
                className: s("tab-button", [Bn, Xfe]),
                "data-active": h === o,
                onClick: function () {
                  return l(h);
                },
                role: "tab",
                title: h,
                type: "button",
                children: [
                  u(h),
                  e && a.length > 1 && E.jsx("span", { className: s("close-button", [uI]), onClick: c, children: E.jsx(tfe, {}) }),
                ],
              },
              h
            );
          }),
        }),
      })
    );
  },
  sh = function (t) {
    var e = t.onClick,
      n = t.className,
      r = t.children,
      i = un();
    return E.jsx("button", { className: i("button", [i("icon-standalone"), Bn, ss, sa, n]), onClick: e, type: "button", children: r });
  },
  Hfe = fe({ position: "absolute", bottom: "$space$2", right: "$space$2", paddingRight: "$space$3" }),
  fI = function (t) {
    t.className;
    var e = t.onClick,
      n = Jt(t, ["className", "onClick"]),
      r = Bt().sandpack;
    return E.jsxs(
      sh,
      Z(
        {
          className: Hfe.toString(),
          onClick: function (i) {
            r.runSandpack(), e == null || e(i);
          },
        },
        n,
        { children: [E.jsx(Yhe, {}), E.jsx("span", { children: "Run" })] }
      )
    );
  },
  x1,
  dI = fe(
    ((x1 = { display: "flex", flexDirection: "column", width: "100%", position: "relative", backgroundColor: "$colors$surface1", gap: 1 }),
    (x1["&:has(.".concat(ut, "-stack)")] = { backgroundColor: "$colors$surface2" }),
    x1)
  ),
  Lg = function (t) {
    var e = t.className,
      n = Jt(t, ["className"]),
      r = un();
    return E.jsx("div", Z({ className: r("stack", [dI, e]) }, n));
  },
  qfe = function () {
    var t = w.useContext(OS),
      e = t.theme,
      n = t.id,
      r = t.mode;
    return { theme: e, themeId: n, themeMode: r };
  },
  UE = function (t, e) {
    if (t.length !== e.length) return !1;
    for (var n = !0, r = 0; r < t.length; r++)
      if (t[r] !== e[r]) {
        n = !1;
        break;
      }
    return n;
  },
  hx = function (t, e) {
    var n = e.line,
      r = e.column;
    return t.line(n).from + (r ?? 0) - 1;
  },
  Yfe = function () {
    return re.theme({
      "&": {
        backgroundColor: "var(--".concat(ut, "-colors-surface1)"),
        color: "var(--".concat(ut, "-syntax-color-plain)"),
        height: "100%",
      },
      ".cm-matchingBracket, .cm-nonmatchingBracket, &.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
        color: "inherit",
        backgroundColor: "rgba(128,128,128,.25)",
        backgroundBlendMode: "difference",
      },
      "&.cm-editor.cm-focused": { outline: "none" },
      ".cm-activeLine": { backgroundColor: "var(--".concat(ut, "-colors-surface3)"), borderRadius: "var(--".concat(ut, "-border-radius)") },
      ".cm-errorLine": {
        backgroundColor: "var(--".concat(ut, "-colors-errorSurface)"),
        borderRadius: "var(--".concat(ut, "-border-radius)"),
      },
      ".cm-content": { caretColor: "var(--".concat(ut, "-colors-accent)"), padding: "0 var(--".concat(ut, "-space-4)") },
      ".cm-scroller": { fontFamily: "var(--".concat(ut, "-font-mono)"), lineHeight: "var(--".concat(ut, "-font-lineHeight)") },
      ".cm-gutters": {
        backgroundColor: "var(--".concat(ut, "-colors-surface1)"),
        color: "var(--".concat(ut, "-colors-disabled)"),
        border: "none",
        paddingLeft: "var(--".concat(ut, "-space-1)"),
      },
      ".cm-gutter.cm-lineNumbers": { fontSize: ".6em" },
      ".cm-lineNumbers .cm-gutterElement": {
        lineHeight: "var(--".concat(ut, "-font-lineHeight)"),
        minWidth: "var(--".concat(ut, "-space-5)"),
      },
      ".cm-content .cm-line": { paddingLeft: "var(--".concat(ut, "-space-1)") },
      ".cm-content.cm-readonly .cm-line": { paddingLeft: 0 },
    });
  },
  gi = function (t) {
    return "".concat(ut, "-syntax-").concat(t);
  },
  Gfe = function () {
    var t = ["string", "plain", "comment", "keyword", "definition", "punctuation", "property", "tag", "static"];
    return t.reduce(function (e, n) {
      var r;
      return Z(
        Z({}, e),
        ((r = {}), (r[".".concat(gi(n))] = { color: "$syntax$color$".concat(n), fontStyle: "$syntax$fontStyle$".concat(n) }), r)
      );
    }, {});
  },
  Jfe = function (t) {
    return ac.define([
      { tag: R.link, textDecoration: "underline" },
      { tag: R.emphasis, fontStyle: "italic" },
      { tag: R.strong, fontWeight: "bold" },
      { tag: R.keyword, class: gi("keyword") },
      { tag: [R.atom, R.number, R.bool], class: gi("static") },
      { tag: R.variableName, class: gi("plain") },
      { tag: R.standard(R.tagName), class: gi("tag") },
      { tag: [R.function(R.variableName), R.definition(R.function(R.variableName)), R.tagName], class: gi("definition") },
      { tag: R.propertyName, class: gi("property") },
      { tag: [R.literal, R.inserted], class: gi(t.syntax.string ? "string" : "static") },
      { tag: R.punctuation, class: gi("punctuation") },
      { tag: [R.comment, R.quote], class: gi("comment") },
    ]);
  },
  Kfe = function (t, e, n) {
    if (!t && !e) return "javascript";
    var r = e;
    if (!r && t) {
      var i = t.lastIndexOf(".");
      r = t.slice(i + 1);
    }
    for (var s = 0, o = n; s < o.length; s++) {
      var a = o[s];
      if (r === a.name || a.extensions.includes(r || "")) return a.name;
    }
    switch (r) {
      case "ts":
      case "tsx":
        return "typescript";
      case "html":
      case "svelte":
      case "vue":
      case "astro":
        return "html";
      case "css":
      case "less":
      case "scss":
        return "css";
      case "js":
      case "jsx":
      case "json":
      default:
        return "javascript";
    }
  },
  ede = function (t, e) {
    for (
      var n = { javascript: tm({ jsx: !0, typescript: !1 }), typescript: tm({ jsx: !0, typescript: !0 }), html: dS(), css: rS() },
        r = 0,
        i = e;
      r < i.length;
      r++
    ) {
      var s = i[r];
      if (t === s.name) return s.language;
    }
    return n[t];
  },
  pI = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return w.useCallback(function (n) {
      return t.forEach(function (r) {
        if (r) {
          if (typeof r == "function") return r(n);
          r.current = n;
        }
      });
    }, t);
  };
function tde(t) {
  return Dt.fromClass(
    (function () {
      function e(n) {
        this.decorations = this.getDecoration(n);
      }
      return (
        (e.prototype.update = function (n) {}),
        (e.prototype.getDecoration = function (n) {
          if (!t) return ge.none;
          var r = t.map(function (i) {
            var s,
              o,
              a,
              l = ge.line({ attributes: { class: (s = i.className) !== null && s !== void 0 ? s : "" } }),
              c = ge.mark({
                class: (o = i.className) !== null && o !== void 0 ? o : "",
                attributes: (a = i.elementAttributes) !== null && a !== void 0 ? a : void 0,
              }),
              u = hx(n.state.doc, { line: i.line, column: i.startColumn }) + 1;
            if (i.startColumn && i.endColumn) {
              var h = hx(n.state.doc, { line: i.line, column: i.endColumn }) + 1;
              return c.range(u, h);
            }
            return l.range(u);
          });
          return ge.set(r);
        }),
        e
      );
    })(),
    {
      decorations: function (e) {
        return e.decorations;
      },
    }
  );
}
function nde() {
  return ide;
}
var rde = ge.line({ attributes: { class: "cm-errorLine" } }),
  ide = Dt.fromClass(
    (function () {
      function t() {
        this.decorations = ge.none;
      }
      return (
        (t.prototype.update = function (e) {
          var n = this;
          e.transactions.forEach(function (r) {
            var i = r.annotation("show-error");
            if (i !== void 0) {
              var s = hx(e.view.state.doc, { line: i }) + 1;
              n.decorations = ge.set([rde.range(s)]);
            } else r.annotation("remove-errors") && (n.decorations = ge.none);
          });
        }),
        t
      );
    })(),
    {
      decorations: function (t) {
        return t.decorations;
      },
    }
  ),
  ed,
  b1,
  fx = fe({
    margin: "0",
    display: "block",
    fontFamily: "$font$mono",
    fontSize: "$font$size",
    color: "$syntax$color$plain",
    lineHeight: "$font$lineHeight",
  }),
  XE = fe(Gfe()),
  mI = fe(
    ((ed = { flex: 1, position: "relative", overflow: "auto", background: "$colors$surface1", ".cm-scroller": { padding: "$space$4 0" } }),
    (ed[".".concat(fx)] = { padding: "$space$4 0" }),
    (ed["@media screen and (max-width: 768px)"] = {
      "@supports (-webkit-overflow-scrolling: touch)": { ".cm-content": { fontSize: "16px" } },
    }),
    ed)
  ),
  HE = fe({ margin: "0", outline: "none", height: "100%" }),
  sde = fe(
    ((b1 = {
      fontFamily: "$font$mono",
      fontSize: "0.8em",
      position: "absolute",
      right: "$space$2",
      bottom: "$space$2",
      zIndex: "$top",
      color: "$colors$clickable",
      backgroundColor: "$colors$surface2",
      borderRadius: "99999px",
      padding: "calc($space$1 / 2) $space$2",
    }),
    (b1["& + .".concat(Bn)] = { right: "calc($space$11 * 2)" }),
    b1)
  ),
  ode = function (t) {
    var e = t.langSupport,
      n = t.highlightTheme,
      r = t.code,
      i = r === void 0 ? "" : r,
      s = e.language.parser.parse(i),
      o = 0,
      a = [],
      l = function (c, u) {
        if (c > o) {
          var h = i.slice(o, c);
          a.push(u ? w.createElement("span", { children: h, className: u, key: "".concat(c).concat(o) }) : h), (o = c);
        }
      };
    return (
      t8(s, n, function (c, u, h) {
        l(c, ""), l(u, h);
      }),
      o < i.length &&
        i != null &&
        i.includes(`
`) &&
        a.push(`

`),
      a
    );
  },
  bS = w.forwardRef(function (t, e) {
    var n = t.code,
      r = n === void 0 ? "" : n,
      i = t.filePath,
      s = t.fileType,
      o = t.onCodeUpdate,
      a = t.showLineNumbers,
      l = a === void 0 ? !1 : a,
      c = t.showInlineErrors,
      u = c === void 0 ? !1 : c,
      h = t.wrapContent,
      f = h === void 0 ? !1 : h,
      d = t.editorState,
      p = d === void 0 ? "pristine" : d,
      m = t.readOnly,
      O = m === void 0 ? !1 : m,
      v = t.showReadOnly,
      g = v === void 0 ? !0 : v,
      x = t.decorators,
      y = t.initMode,
      S = y === void 0 ? "lazy" : y,
      k = t.extensions,
      b = k === void 0 ? [] : k,
      _ = t.extensionsKeymap,
      T = _ === void 0 ? [] : _,
      P = t.additionalLanguages,
      M = P === void 0 ? [] : P,
      D = w.useRef(null),
      V = pI(D, e),
      Q = w.useRef(),
      N = qfe(),
      G = N.theme,
      H = N.themeId,
      te = w.useState(r),
      le = te[0],
      $ = te[1],
      B = w.useState(S === "immediate"),
      ie = B[0],
      L = B[1],
      pe = un(),
      Ce = Bt(),
      me = Ce.listen,
      Y = Ce.sandpack.autoReload,
      q = w.useRef([]),
      se = w.useRef([]),
      ue = $ce(D, { rootMargin: "600px 0px", threshold: 0.2 }).isIntersecting;
    w.useImperativeHandle(e, function () {
      return {
        getCodemirror: function () {
          return Q.current;
        },
      };
    }),
      w.useEffect(
        function () {
          var Ge = S === "lazy" || S === "user-visible";
          Ge && ue && L(!0);
        },
        [S, ue]
      );
    var ve = Kfe(i, s, M),
      Pe = ede(ve, M),
      Fe = Jfe(G),
      rt = ode({ langSupport: Pe, highlightTheme: Fe, code: r }),
      Rt = w.useMemo(
        function () {
          return (
            x &&
            x.sort(function (Ge, Ve) {
              return Ge.line - Ve.line;
            })
          );
        },
        [x]
      );
    w.useEffect(
      function () {
        if (!(!D.current || !ie)) {
          var Ge = D.current,
            Ve = Ge.querySelector(".sp-pre-placeholder");
          Ve && Ge.removeChild(Ve);
          var We = new re({
            doc: r,
            extensions: [],
            parent: Ge,
            dispatch: function (De) {
              if ((We.update([De]), De.docChanged)) {
                var Ut = De.newDoc.sliceString(0, De.newDoc.length);
                $(Ut), o == null || o(Ut);
              }
            },
          });
          return (
            We.contentDOM.setAttribute("data-gramm", "false"),
            We.contentDOM.setAttribute("data-lt-active", "false"),
            We.contentDOM.setAttribute("aria-label", i ? "Code Editor for ".concat(nm(i)) : "Code Editor"),
            O ? We.contentDOM.classList.add("cm-readonly") : We.contentDOM.setAttribute("tabIndex", "-1"),
            (Q.current = We),
            function () {
              var De;
              (De = Q.current) === null || De === void 0 || De.destroy();
            }
          );
        }
      },
      [ie]
    ),
      w.useEffect(
        function () {
          if (Q.current) {
            var Ge = [
                {
                  key: "Tab",
                  run: function (We) {
                    var De, Ut;
                    OR(We);
                    var Lt = T.find(function (it) {
                      var hn = it.key;
                      return hn === "Tab";
                    });
                    return (Ut = (De = Lt == null ? void 0 : Lt.run) === null || De === void 0 ? void 0 : De.call(Lt, We)) !== null &&
                      Ut !== void 0
                      ? Ut
                      : !0;
                  },
                },
                {
                  key: "Shift-Tab",
                  run: function (We) {
                    var De, Ut;
                    vR({ state: We.state, dispatch: We.dispatch });
                    var Lt = T.find(function (it) {
                      var hn = it.key;
                      return hn === "Shift-Tab";
                    });
                    return (Ut = (De = Lt == null ? void 0 : Lt.run) === null || De === void 0 ? void 0 : De.call(Lt, We)) !== null &&
                      Ut !== void 0
                      ? Ut
                      : !0;
                  },
                },
                {
                  key: "Escape",
                  run: function () {
                    return O || (D.current && D.current.focus()), !0;
                  },
                },
                { key: "mod-Backspace", run: tS },
              ],
              Ve = wn(
                wn([F4(), Z8(), N8()], b, !0),
                [ta.of(wn(wn(wn(wn(wn([], D8, !0), xR, !0), X8, !0), Ge, !0), T, !0)), Pe, Yfe(), jw(Fe)],
                !1
              );
            O ? (Ve.push(Qe.readOnly.of(!0)), Ve.push(re.editable.of(!1))) : (Ve.push(v8()), Ve.push(V4())),
              Rt && Ve.push(tde(Rt)),
              f && Ve.push(re.lineWrapping),
              l && Ve.push(kg()),
              u && Ve.push(nde()),
              Q.current.dispatch({ effects: Ae.reconfigure.of(Ve) });
          }
        },
        [ie, Rt, l, f, H, O, Y]
      ),
      w.useEffect(
        function () {
          var Ve = Q.current,
            We = !UE(b, q.current) || !UE(T, se.current);
          Ve &&
            We &&
            (Ve.dispatch({ effects: Ae.appendConfig.of(b) }),
            Ve.dispatch({ effects: Ae.appendConfig.of(ta.of(wn([], T, !0))) }),
            (q.current = b),
            (se.current = T));
        },
        [b, T]
      ),
      w.useEffect(function () {
        Q.current && p === "dirty" && window.matchMedia("(min-width: 768px)").matches && Q.current.contentDOM.focus();
      }, []),
      w.useEffect(
        function () {
          if (Q.current && typeof r == "string" && r !== le) {
            var Ge = Q.current,
              Ve = Ge.state.selection.ranges.some(function (De) {
                var Ut = De.to,
                  Lt = De.from;
                return Ut > r.length || Lt > r.length;
              })
                ? X.cursor(r.length)
                : Ge.state.selection,
              We = { from: 0, to: Ge.state.doc.length, insert: r };
            Ge.dispatch({ changes: We, selection: Ve });
          }
        },
        [r]
      ),
      w.useEffect(
        function () {
          if (u) {
            var Ve = me(function (We) {
              var De = Q.current;
              We.type === "success"
                ? De == null || De.dispatch({ annotations: [new Jr("remove-errors", !0)] })
                : We.type === "action" &&
                  We.action === "show-error" &&
                  We.path === i &&
                  We.line &&
                  (De == null || De.dispatch({ annotations: [new Jr("show-error", We.line)] }));
            });
            return function () {
              return Ve();
            };
          }
        },
        [me, u]
      );
    var Qt = function (Ge) {
        Ge.key === "Enter" && Q.current && (Ge.preventDefault(), Q.current.contentDOM.focus());
      },
      Ft = function () {
        var Ge = 4;
        return l && (Ge += 6), O || (Ge += 1), "var(--".concat(ut, "-space-").concat(Ge, ")");
      };
    return O
      ? E.jsxs(E.Fragment, {
          children: [
            E.jsx("pre", {
              ref: V,
              className: pe("cm", [pe(p), pe(ve), HE, XE]),
              translate: "no",
              children: E.jsx("code", { className: pe("pre-placeholder", [fx]), style: { marginLeft: Ft() }, children: rt }),
            }),
            O && g && E.jsx("span", Z({ className: pe("read-only", [sde]) }, {}, { children: "Read-only" })),
          ],
        })
      : E.jsx("div", {
          ref: V,
          "aria-autocomplete": "list",
          "aria-label": i ? "Code Editor for ".concat(nm(i)) : "Code Editor",
          "aria-multiline": "true",
          className: pe("cm", [pe(p), pe(ve), HE, XE]),
          onKeyDown: Qt,
          role: "textbox",
          tabIndex: 0,
          translate: "no",
          suppressHydrationWarning: !0,
          children: E.jsx("pre", { className: pe("pre-placeholder", [fx]), style: { marginLeft: Ft() }, children: rt }),
        });
  }),
  ade = w.forwardRef(function (t, e) {
    var n = t.showTabs,
      r = t.showLineNumbers,
      i = r === void 0 ? !1 : r,
      s = t.showInlineErrors,
      o = s === void 0 ? !1 : s,
      a = t.showRunButton,
      l = a === void 0 ? !0 : a,
      c = t.wrapContent,
      u = c === void 0 ? !1 : c,
      h = t.closableTabs,
      f = h === void 0 ? !1 : h,
      d = t.initMode,
      p = t.extensions,
      m = t.extensionsKeymap,
      O = t.readOnly,
      v = t.showReadOnly,
      g = t.additionalLanguages,
      x = t.className,
      y = Jt(t, [
        "showTabs",
        "showLineNumbers",
        "showInlineErrors",
        "showRunButton",
        "wrapContent",
        "closableTabs",
        "initMode",
        "extensions",
        "extensionsKeymap",
        "readOnly",
        "showReadOnly",
        "additionalLanguages",
        "className",
      ]),
      S = Bt().sandpack,
      k = lI(),
      b = k.code,
      _ = k.updateCode,
      T = k.readOnly,
      P = S.activeFile,
      M = S.status,
      D = S.editorState,
      V = n ?? S.visibleFiles.length > 1,
      Q = un(),
      N = function (G, H) {
        H === void 0 && (H = !0), _(G, H);
      };
    return E.jsxs(
      Lg,
      Z({ className: Q("editor", [x]) }, y, {
        children: [
          V && E.jsx(hI, { closableTabs: f }),
          E.jsxs("div", {
            className: Q("code-editor", [mI]),
            children: [
              E.jsx(
                bS,
                {
                  ref: e,
                  additionalLanguages: g,
                  code: b,
                  editorState: D,
                  extensions: p,
                  extensionsKeymap: m,
                  filePath: P,
                  initMode: d || S.initMode,
                  onCodeUpdate: function (G) {
                    var H;
                    return N(G, (H = S.autoReload) !== null && H !== void 0 ? H : !0);
                  },
                  readOnly: O || T,
                  showInlineErrors: o,
                  showLineNumbers: i,
                  showReadOnly: v,
                  wrapContent: u,
                },
                P
              ),
              l && (!S.autoReload || M === "idle") ? E.jsx(fI, {}) : null,
            ],
          }),
        ],
      })
    );
  });
w.forwardRef(function (t, e) {
  var n = t.showTabs,
    r = t.showLineNumbers,
    i = t.decorators,
    s = t.code,
    o = t.initMode,
    a = t.wrapContent,
    l = t.additionalLanguages,
    c = Jt(t, ["showTabs", "showLineNumbers", "decorators", "code", "initMode", "wrapContent", "additionalLanguages"]),
    u = Bt().sandpack,
    h = lI().code,
    f = un(),
    d = n ?? u.visibleFiles.length > 1;
  return E.jsxs(
    Lg,
    Z({ className: f("editor-viewer") }, c, {
      children: [
        d ? E.jsx(hI, {}) : null,
        E.jsx("div", {
          className: f("code-editor", [mI]),
          children: E.jsx(bS, {
            ref: e,
            additionalLanguages: l,
            code: s ?? h,
            decorators: i,
            filePath: u.activeFile,
            initMode: o || u.initMode,
            showLineNumbers: r,
            showReadOnly: !1,
            wrapContent: a,
            readOnly: !0,
          }),
        }),
        u.status === "idle" ? E.jsx(fI, {}) : null,
      ],
    })
  );
});
var td,
  nd,
  lde = fe(
    ((td = {
      border: "1px solid $colors$surface2",
      display: "flex",
      flexWrap: "wrap",
      alignItems: "stretch",
      borderRadius: "$border$radius",
      overflow: "hidden",
      position: "relative",
      backgroundColor: "$colors$surface2",
      gap: 1,
    }),
    (td["> .".concat(dI)] = {
      flexGrow: 1,
      flexShrink: 1,
      flexBasis: "0",
      height: "$layout$height",
      overflow: "hidden",
      "@media print": { height: "auto", display: "block" },
      "@media screen and (max-width: 768px)":
        ((nd = {}),
        (nd["&:not(.".concat(ut, "-preview, .").concat(ut, "-editor, .").concat(ut, "-preset-column)")] = {
          height: "calc($layout$height / 2)",
        }),
        (nd.minWidth = "100%;"),
        nd),
    }),
    (td["> .".concat(ut, "-file-explorer")] = { flex: 0.2, minWidth: 200, "@media screen and (max-width: 768px)": { flex: 1 } }),
    td)
  ),
  cde = w.forwardRef(function (t, e) {
    var n = t.children,
      r = t.className,
      i = Jt(t, ["children", "className"]),
      s = Bt().sandpack,
      o = un(),
      a = pI(s.lazyAnchorRef, e);
    return E.jsx("div", Z({ ref: a, className: o("layout", [lde, r]) }, i, { children: n }));
  }),
  ude = function () {
    var t,
      e = Bt().sandpack,
      n = e.error;
    return (t = n == null ? void 0 : n.message) !== null && t !== void 0 ? t : null;
  },
  gI = 200,
  hde = function (t, e) {
    var n = Bt(),
      r = n.sandpack,
      i = n.listen,
      s = w.useState("LOADING"),
      o = s[0],
      a = s[1];
    return (
      w.useEffect(
        function () {
          var l = i(function (c) {
            c.type === "start" && c.firstLoad === !0 && a("LOADING"),
              c.type === "done" &&
                a(function (u) {
                  return u === "LOADING" ? "PRE_FADING" : "HIDDEN";
                });
          }, t);
          return function () {
            l();
          };
        },
        [t, r.status === "idle"]
      ),
      w.useEffect(
        function () {
          var l;
          return (
            o === "PRE_FADING" && !e
              ? a("FADING")
              : o === "FADING" &&
                (l = setTimeout(function () {
                  return a("HIDDEN");
                }, gI)),
            function () {
              clearTimeout(l);
            }
          );
        },
        [o, e]
      ),
      r.status === "timeout" ? "TIMEOUT" : r.status !== "running" ? "HIDDEN" : o
    );
  },
  fde = function (t) {
    var e = Bt().dispatch;
    return {
      refresh: function () {
        return e({ type: "refresh" }, t);
      },
      back: function () {
        return e({ type: "urlback" }, t);
      },
      forward: function () {
        return e({ type: "urlforward" }, t);
      },
    };
  },
  OI = function (t) {
    var e = Bt(),
      n = e.sandpack,
      r = e.listen,
      i = e.dispatch,
      s = w.useRef(null),
      o = w.useRef(rm());
    w.useEffect(function () {
      var l = s.current,
        c = o.current;
      return (
        l !== null && n.registerBundler(l, c, t),
        function () {
          return n.unregisterBundler(c);
        }
      );
    }, []);
    var a = function () {
      return n.clients[o.current] || null;
    };
    return {
      sandpack: n,
      getClient: a,
      clientId: o.current,
      iframe: s,
      listen: function (l) {
        return r(l, o.current);
      },
      dispatch: function (l) {
        return i(l, o.current);
      },
    };
  },
  yS = function (t) {
    var e = Bt().dispatch;
    return {
      restart: function () {
        return e({ type: "shell/restart" }, t);
      },
      openPreview: function () {
        return e({ type: "shell/openPreview" }, t);
      },
    };
  },
  dde = function (t, e) {
    var n;
    switch (t.state) {
      case "downloading_manifest":
        return "[1/3] Downloading manifest";
      case "downloaded_module":
        return "[2/3] Downloaded "
          .concat(t.name, " (")
          .concat(e - t.totalPending, "/")
          .concat(e, ")");
      case "starting_command":
        return "[3/3] Starting command";
      case "command_running":
        return '[3/3] Running "'.concat((n = t.command) === null || n === void 0 ? void 0 : n.trim(), '"');
    }
  },
  vI = function (t) {
    var e = w.useState(!1),
      n = e[0],
      r = e[1],
      i = w.useState(),
      s = i[0],
      o = i[1],
      a = w.useState(null),
      l = a[0],
      c = a[1],
      u = t == null ? void 0 : t.timeout,
      h = t == null ? void 0 : t.clientId,
      f = Bt().listen;
    return (
      w.useEffect(
        function () {
          var d,
            p = f(function (m) {
              m.type === "start" && m.firstLoad && r(!1),
                u &&
                  (d = setTimeout(function () {
                    c(null);
                  }, u)),
                m.type === "dependencies"
                  ? c(function () {
                      switch (m.data.state) {
                        case "downloading_manifest":
                          return "[1/3] Downloading manifest";
                        case "downloaded_module":
                          return "[2/3] Downloaded ".concat(m.data.name, " (").concat(m.data.progress, "/").concat(m.data.total, ")");
                        case "starting":
                          return "[3/3] Starting";
                      }
                      return null;
                    })
                  : m.type === "shell/progress" &&
                    !n &&
                    (!s && m.data.state === "downloaded_module" && o(m.data.totalPending), s !== void 0 && c(dde(m.data, s))),
                m.type === "done" && m.compilatonError === !1 && (c(null), r(!0), clearTimeout(d));
            }, h);
          return function () {
            d && clearTimeout(d), p();
          };
        },
        [h, n, s, u]
      ),
      l
    );
  },
  pde = 400 * 2,
  xI = function (t) {
    var e = t.clientId,
      n = t.maxMessageCount,
      r = n === void 0 ? pde : n;
    t.resetOnPreviewRestart;
    var i = w.useState([]),
      s = i[0],
      o = i[1],
      a = Bt().listen;
    return (
      w.useEffect(
        function () {
          var l = a(function (c) {
            c.type === "start"
              ? o([])
              : c.type === "stdout" &&
                c.payload.data &&
                c.payload.data.trim() &&
                o(function (u) {
                  for (var h = wn(wn([], u, !0), [{ data: c.payload.data, id: rm() }], !1); h.length > r; ) h.shift();
                  return h;
                });
          }, e);
          return l;
        },
        [r, e]
      ),
      {
        logs: s,
        reset: function () {
          return o([]);
        },
      }
    );
  },
  mde = function (t) {
    var e = t.replace("[sandpack-client]: ", "");
    if (/process.exit/.test(e)) {
      var n = e.match(/process.exit\((\d+)\)/);
      return n
        ? Number(n[1]) === 0
          ? "Server is not running, would you like to start it again?"
          : "Server has crashed with status code ".concat(n[1], ", would you like to restart the server?")
        : e;
    }
    return e;
  },
  gde = function (t) {
    var e = t.children,
      n = t.className,
      r = Jt(t, ["children", "className"]),
      i = ude(),
      s = yS().restart,
      o = un(),
      a = Bt().sandpack,
      l = a.runSandpack,
      c = a.teamId,
      u = Bt().dispatch;
    if (!i && !e) return null;
    var h = i == null ? void 0 : i.startsWith("[sandpack-client]"),
      f = i == null ? void 0 : i.includes("NPM_REGISTRY_UNAUTHENTICATED_REQUEST"),
      d = function () {
        c && u({ type: "sign-in", teamId: c });
      };
    return f
      ? E.jsxs(
          "div",
          Z({ className: o("overlay", [o("error"), mu, ux, n]) }, t, {
            children: [
              E.jsx("p", {
                className: o("error-message", [Ns]),
                children: E.jsx("strong", { children: "Unable to fetch required dependency." }),
              }),
              E.jsx("div", {
                className: o("error-message", [Ns]),
                children: E.jsxs("p", {
                  children: [
                    "Authentication required. Please sign in to your account (make sure to allow pop-ups to this page) and try again. If the issue persists, contact",
                    " ",
                    E.jsx("a", { href: "mailto:hello@codesandbox.io?subject=Sandpack Timeout Error", children: "support" }),
                    " ",
                    "for further assistance.",
                  ],
                }),
              }),
              E.jsx("div", {
                children: E.jsxs("button", {
                  className: o("button", [Bn, ss, sa]),
                  onClick: d,
                  children: [E.jsx(Hhe, {}), E.jsx("span", { children: "Sign in" })],
                }),
              }),
            ],
          })
        )
      : h && i
      ? E.jsx(
          "div",
          Z({ className: o("overlay", [o("error"), mu, ux, n]) }, r, {
            children: E.jsxs("div", {
              className: o("error-message", [Ns]),
              children: [
                E.jsx("p", { className: o("error-title", [fe({ fontWeight: "bold" })]), children: "Couldn't connect to server" }),
                E.jsx("p", { children: mde(i) }),
                E.jsx("div", {
                  children: E.jsxs("button", {
                    className: o("button", [o("icon-standalone"), Bn, ss, sa]),
                    onClick: function () {
                      s(), l();
                    },
                    title: "Restart script",
                    type: "button",
                    children: [E.jsx(Ng, {}), " ", E.jsx("span", { children: "Restart" })],
                  }),
                }),
              ],
            }),
          })
        )
      : E.jsxs(
          "div",
          Z({ className: o("overlay", [o("error"), mu, cI({ solidBg: !0 }), n]), translate: "no" }, r, {
            children: [
              E.jsx("p", { className: o("error-message", [Ns]), children: E.jsx("strong", { children: "Something went wrong" }) }),
              E.jsx("p", { className: o("error-message", [Ns({ errorCode: !0 })]), children: i || e }),
            ],
          })
        );
  };
function Ode(t, e) {
  return e === void 0 && (e = !1), (t = Whe(wde(t))), jhe.ansiToJson(t, { json: !0, remove_empty: !0, use_classes: e });
}
function vde(t) {
  var e = "";
  return (
    t.bg && (e += "".concat(t.bg, "-bg ")),
    t.fg && (e += "".concat(t.fg, "-fg ")),
    t.decoration && (e += "ansi-".concat(t.decoration, " ")),
    e === "" ? null : ((e = e.substring(0, e.length - 1)), e)
  );
}
function xde(t) {
  var e = {};
  switch ((t.bg && (e.backgroundColor = "rgb(".concat(t.bg, ")")), t.fg && (e.color = "rgb(".concat(t.fg, ")")), t.decoration)) {
    case "bold":
      e.fontWeight = "bold";
      break;
    case "dim":
      e.opacity = "0.5";
      break;
    case "italic":
      e.fontStyle = "italic";
      break;
    case "hidden":
      e.visibility = "hidden";
      break;
    case "strikethrough":
      e.textDecoration = "line-through";
      break;
    case "underline":
      e.textDecoration = "underline";
      break;
    case "blink":
      e.textDecoration = "blink";
      break;
  }
  return e;
}
function bde(t, e, n, r) {
  var i = e ? null : xde(n),
    s = e ? vde(n) : null;
  if (!t) return w.createElement("span", { style: i, key: r, className: s }, n.content);
  for (
    var o = [], a = /(\s|^)(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/g, l = 0, c;
    (c = a.exec(n.content)) !== null;

  ) {
    var u = c[1],
      h = c[2],
      f = c.index + u.length;
    f > l && o.push(n.content.substring(l, f));
    var d = h.startsWith("www.") ? "http://".concat(h) : h;
    o.push(w.createElement("a", { key: l, href: d, target: "_blank" }, "".concat(h))), (l = a.lastIndex);
  }
  return l < n.content.length && o.push(n.content.substring(l)), w.createElement("span", { style: i, key: r, className: s }, o);
}
function yde(t) {
  var e = t.className,
    n = t.useClasses,
    r = t.children,
    i = t.linkify;
  return w.createElement("code", { className: e }, Ode(r ?? "", n ?? !1).map(bde.bind(null, i ?? !1, n ?? !1)));
}
function wde(t) {
  var e = t;
  do (t = e), (e = t.replace(/[^\n]\x08/gm, ""));
  while (e.length < t.length);
  return t;
}
var bI = function (t) {
    var e = t.data,
      n = un();
    return E.jsx(E.Fragment, {
      children: e.map(function (r) {
        var i = r.data,
          s = r.id;
        return E.jsx("div", { className: n("console-item", [Sde]), children: E.jsx(yde, { children: i }) }, s);
      }),
    });
  },
  Sde = fe({
    width: "100%",
    padding: "$space$3 $space$2",
    fontSize: ".85em",
    position: "relative",
    whiteSpace: "pre",
    "&:not(:first-child):after": {
      content: "",
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      height: 1,
      background: "$colors$surface3",
    },
  }),
  kde = function (t) {
    return Xhe.compressToBase64(JSON.stringify(t)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  },
  qE = "https://codesandbox.io/api/v1/sandboxes/define",
  Cde = function (t, e) {
    var n = Object.keys(t).reduce(function (r, i) {
      var s,
        o = i.replace("/", ""),
        a = { content: t[i].code, isBinary: !1 };
      return Z(Z({}, r), ((s = {}), (s[o] = a), s));
    }, {});
    return kde(Z({ files: n }, e ? { template: e } : null));
  },
  _de = function (t) {
    var e = Bt().sandpack;
    return e.exportOptions ? E.jsx(Ede, Z({ state: e }, t)) : E.jsx(Tde, Z({ state: e }, t));
  },
  Ede = function (t) {
    var e = t.children,
      n = t.state,
      r = Jt(t, ["children", "state"]),
      i = function () {
        return Xc(void 0, void 0, void 0, function () {
          var s, o, a, l;
          return Hc(this, function (c) {
            switch (c.label) {
              case 0:
                if (!(!((l = n.exportOptions) === null || l === void 0) && l.apiToken)) throw new Error("Missing `apiToken` property");
                return (
                  (s = Object.keys(n.files).reduce(function (u, h) {
                    var f,
                      d = h.replace("/", "");
                    return Z(Z({}, u), ((f = {}), (f[d] = n.files[h]), f));
                  }, {})),
                  [
                    4,
                    fetch("https://api.codesandbox.io/sandbox", {
                      method: "POST",
                      body: JSON.stringify({ template: n.environment, files: s, privacy: n.exportOptions.privacy === "public" ? 0 : 2 }),
                      headers: {
                        Authorization: "Bearer ".concat(n.exportOptions.apiToken),
                        "Content-Type": "application/json",
                        "X-CSB-API-Version": "2023-07-01",
                      },
                    }),
                  ]
                );
              case 1:
                return (o = c.sent()), [4, o.json()];
              case 2:
                return (
                  (a = c.sent()),
                  window.open(
                    "https://codesandbox.io/p/sandbox/".concat(a.data.alias, "?file=/").concat(n.activeFile, "&utm-source=storybook-addon"),
                    "_blank"
                  ),
                  [2]
                );
            }
          });
        });
      };
    return E.jsx("button", Z({ onClick: i, title: "Export to workspace in CodeSandbox", type: "button" }, r, { children: e }));
  },
  Tde = function (t) {
    var e,
      n,
      r,
      i = t.children,
      s = t.state,
      o = Jt(t, ["children", "state"]),
      a = w.useRef(null),
      l = w.useState(),
      c = l[0],
      u = l[1];
    return (
      w.useEffect(
        function () {
          var f = setTimeout(function () {
            var d = Cde(s.files, s.environment),
              p = new URLSearchParams({
                parameters: d,
                query: new URLSearchParams({ file: s.activeFile, utm_medium: "sandpack" }).toString(),
              });
            u(p);
          }, 600);
          return function () {
            clearTimeout(f);
          };
        },
        [s.activeFile, s.environment, s.files]
      ),
      ((r =
        (n = (e = c == null ? void 0 : c.get) === null || e === void 0 ? void 0 : e.call(c, "parameters")) === null || n === void 0
          ? void 0
          : n.length) !== null && r !== void 0
        ? r
        : 0) > 1500
        ? E.jsxs(
            "button",
            Z(
              {
                onClick: function () {
                  var h;
                  return (h = a.current) === null || h === void 0 ? void 0 : h.submit();
                },
                title: "Open in CodeSandbox",
                type: "button",
              },
              o,
              {
                children: [
                  E.jsxs("form", {
                    ref: a,
                    action: qE,
                    method: "POST",
                    style: { visibility: "hidden" },
                    target: "_blank",
                    children: [
                      E.jsx("input", { name: "environment", type: "hidden", value: s.environment === "node" ? "server" : s.environment }),
                      Array.from(c, function (h) {
                        var f = h[0],
                          d = h[1];
                        return E.jsx("input", { name: f, type: "hidden", value: d }, f);
                      }),
                    ],
                  }),
                  i,
                ],
              }
            )
          )
        : E.jsx(
            "a",
            Z(
              {
                href: ""
                  .concat(qE, "?")
                  .concat(c == null ? void 0 : c.toString(), "&environment=")
                  .concat(s.environment === "node" ? "server" : s.environment),
                rel: "noreferrer noopener",
                target: "_blank",
                title: "Open in CodeSandbox",
              },
              o,
              { children: i }
            )
          )
    );
  },
  yI = function () {
    var t = un();
    return E.jsxs(_de, {
      className: t("button", [t("icon-standalone"), Bn, ss, sa]),
      children: [E.jsx(efe, {}), E.jsx("span", { children: "Open Sandbox" })],
    });
  },
  To,
  dx = fe({ transform: "translate(-4px, 9px) scale(0.13, 0.13)", "*": { position: "absolute", width: "96px", height: "96px" } }),
  Pde = fe(
    ((To = {
      position: "absolute",
      right: "$space$2",
      bottom: "$space$2",
      zIndex: "$top",
      width: "32px",
      height: "32px",
      borderRadius: "$border$radius",
    }),
    (To[".".concat(dx)] = { display: "flex" }),
    (To[".sp-button.".concat(Bn)] = { display: "none" }),
    (To["&:hover .sp-button.".concat(Bn)] = { display: "flex" }),
    (To["&:hover .sp-button.".concat(Bn, " > span")] = { display: "none" }),
    (To["&:hover .".concat(dx)] = { display: "none" }),
    To)
  ),
  Ade = oI({ "0%": { transform: "rotateX(-25.5deg) rotateY(45deg)" }, "100%": { transform: "rotateX(-25.5deg) rotateY(405deg)" } }),
  $de = fe({
    animation: "".concat(Ade, " 1s linear infinite"),
    animationFillMode: "forwards",
    transformStyle: "preserve-3d",
    transform: "rotateX(-25.5deg) rotateY(45deg)",
    "*": { border: "10px solid $colors$clickable", borderRadius: "8px", background: "$colors$surface1" },
    ".top": { transform: "rotateX(90deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".bottom": { transform: "rotateX(-90deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".front": { transform: "rotateY(0deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".back": { transform: "rotateY(-180deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".left": { transform: "rotateY(-90deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".right": { transform: "rotateY(90deg) translateZ(44px)", transformOrigin: "50% 50%" },
  }),
  Rde = function (t) {
    var e = t.className,
      n = t.showOpenInCodeSandbox,
      r = Jt(t, ["className", "showOpenInCodeSandbox"]),
      i = un();
    return E.jsxs(
      "div",
      Z({ className: i("cube-wrapper", [Pde, e]), title: "Open in CodeSandbox" }, r, {
        children: [
          n && E.jsx(yI, {}),
          E.jsx("div", {
            className: i("cube", [dx]),
            children: E.jsxs("div", {
              className: i("sides", [$de]),
              children: [
                E.jsx("div", { className: "top" }),
                E.jsx("div", { className: "right" }),
                E.jsx("div", { className: "bottom" }),
                E.jsx("div", { className: "left" }),
                E.jsx("div", { className: "front" }),
                E.jsx("div", { className: "back" }),
              ],
            }),
          }),
        ],
      })
    );
  },
  Ide = fe({ backgroundColor: "$colors$surface1" }),
  Nde = function (t) {
    var e = t.clientId,
      n = t.loading,
      r = t.className,
      i = t.style,
      s = t.showOpenInCodeSandbox,
      o = Jt(t, ["clientId", "loading", "className", "style", "showOpenInCodeSandbox"]),
      a = un(),
      l = Bt().sandpack,
      c = l.runSandpack,
      u = l.environment,
      h = w.useState(!1),
      f = h[0],
      d = h[1],
      p = hde(e, n),
      m = vI({ clientId: e }),
      O = xI({ clientId: e }).logs;
    if (
      (w.useEffect(
        function () {
          var g;
          return (
            m != null &&
              m.includes("Running") &&
              (g = setTimeout(function () {
                d(!0);
              }, 3e3)),
            function () {
              g && clearTimeout(g);
            }
          );
        },
        [m]
      ),
      p === "HIDDEN")
    )
      return null;
    if (p === "TIMEOUT")
      return E.jsx(
        "div",
        Z({ className: a("overlay", [a("error"), mu, cI, ux, r]) }, o, {
          children: E.jsxs("div", {
            className: a("error-message", [Ns]),
            children: [
              E.jsx("p", { className: a("error-title", [fe({ fontWeight: "bold" })]), children: "Couldn't connect to server" }),
              E.jsx("div", {
                className: a("error-message", [Ns]),
                children: E.jsxs("p", {
                  children: [
                    "This means sandpack cannot connect to the runtime or your network is having some issues. Please check the network tab in your browser and try again. If the problem persists, report it via",
                    " ",
                    E.jsx("a", { href: "mailto:hello@codesandbox.io?subject=Sandpack Timeout Error", children: "email" }),
                    " ",
                    "or submit an issue on",
                    " ",
                    E.jsx("a", {
                      href: "https://github.com/codesandbox/sandpack/issues",
                      rel: "noreferrer noopener",
                      target: "_blank",
                      children: "GitHub.",
                    }),
                  ],
                }),
              }),
              E.jsxs("p", {
                className: a("error-message", [Ns({ errorCode: !0 })]),
                children: ["ENV: ", u, E.jsx("br", {}), "ERROR: TIME_OUT"],
              }),
              E.jsx("div", {
                children: E.jsxs("button", {
                  className: a("button", [a("icon-standalone"), Bn, ss, sa]),
                  onClick: c,
                  title: "Restart script",
                  type: "button",
                  children: [E.jsx(Ng, {}), " ", E.jsx("span", { children: "Try again" })],
                }),
              }),
            ],
          }),
        })
      );
    var v = p === "LOADING" || p === "PRE_FADING";
    return E.jsxs(E.Fragment, {
      children: [
        E.jsxs(
          "div",
          Z(
            {
              className: a("overlay", [a("loading"), mu, Ide, r]),
              style: Z(Z({}, i), { opacity: v ? 1 : 0, transition: "opacity ".concat(gI, "ms ease-out") }),
            },
            o,
            {
              children: [
                f && E.jsx("div", { className: Lde.toString(), children: E.jsx(bI, { data: O }) }),
                E.jsx(Rde, { showOpenInCodeSandbox: s }),
              ],
            }
          )
        ),
        m && E.jsx("div", { className: Mde.toString(), children: E.jsx("p", { children: m }) }),
      ],
    });
  },
  Lde = fe({ position: "absolute", left: 0, right: 0, bottom: "$space$8", overflow: "auto", opacity: 0.5, overflowX: "hidden" }),
  Mde = fe({
    position: "absolute",
    left: "$space$5",
    bottom: "$space$4",
    zIndex: "$top",
    color: "$colors$clickable",
    animation: "".concat(xS, " 150ms ease"),
    fontFamily: "$font$mono",
    fontSize: ".8em",
    width: "75%",
    p: { whiteSpace: "nowrap", margin: 0, textOverflow: "ellipsis", overflow: "hidden" },
  }),
  Dde = function (t) {
    var e = t.clientId,
      n = vI({ timeout: 3e3, clientId: e });
    return n ? E.jsx("div", { className: Qde.toString(), children: E.jsx("p", { children: n }) }) : null;
  },
  Qde = fe({
    position: "absolute",
    left: "$space$5",
    bottom: "$space$4",
    zIndex: "$top",
    color: "$colors$clickable",
    animation: "".concat(xS, " 150ms ease"),
    fontFamily: "$font$mono",
    fontSize: ".8em",
    width: "75%",
    p: { whiteSpace: "nowrap", margin: 0, textOverflow: "ellipsis", overflow: "hidden" },
  });
fe({
  borderRadius: "0",
  width: "100%",
  padding: 0,
  marginBottom: "$space$2",
  span: { textOverflow: "ellipsis", whiteSpace: "nowrap", overflow: "hidden" },
  svg: { marginRight: "$space$1" },
});
fe({ padding: "$space$3", overflow: "auto", height: "100%" });
var Fde = function (t) {
    var e = t.match(/(https?:\/\/.*?)\//);
    return e && e[1] ? [e[1], t.replace(e[1], "")] : [t, "/"];
  },
  Vde = fe({
    display: "flex",
    alignItems: "center",
    height: "$layout$headerHeight",
    borderBottom: "1px solid $colors$surface2",
    padding: "$space$3 $space$2",
    background: "$colors$surface1",
  }),
  Bde = fe({
    backgroundColor: "$colors$surface2",
    color: "$colors$clickable",
    padding: "$space$1 $space$3",
    borderRadius: "99999px",
    border: "1px solid $colors$surface2",
    height: "24px",
    lineHeight: "24px",
    fontSize: "inherit",
    outline: "none",
    flex: 1,
    marginLeft: "$space$4",
    width: "0",
    transition: "background $transitions$default",
    "&:hover": { backgroundColor: "$colors$surface3" },
    "&:focus": { backgroundColor: "$surface1", border: "1px solid $colors$accent", color: "$colors$base" },
  }),
  jde = function (t) {
    var e,
      n = t.clientId,
      r = t.onURLChange,
      i = t.className,
      s = t.startRoute,
      o = Jt(t, ["clientId", "onURLChange", "className", "startRoute"]),
      a = w.useState(""),
      l = a[0],
      c = a[1],
      u = Bt(),
      h = u.sandpack,
      f = u.dispatch,
      d = u.listen,
      p = w.useState((e = s ?? h.startRoute) !== null && e !== void 0 ? e : "/"),
      m = p[0],
      O = p[1],
      v = w.useState(!1),
      g = v[0],
      x = v[1],
      y = w.useState(!1),
      S = y[0],
      k = y[1],
      b = un();
    w.useEffect(function () {
      var Q = d(function (N) {
        if (N.type === "urlchange") {
          var G = N.url,
            H = N.back,
            te = N.forward,
            le = Fde(G),
            $ = le[0],
            B = le[1];
          c($), O(B), x(H), k(te);
        }
      }, n);
      return function () {
        return Q();
      };
    }, []);
    var _ = function (Q) {
        var N = Q.target.value.startsWith("/") ? Q.target.value : "/".concat(Q.target.value);
        O(N);
      },
      T = function (Q) {
        Q.code === "Enter" && (Q.preventDefault(), Q.stopPropagation(), typeof r == "function" && r(l + Q.currentTarget.value));
      },
      P = function () {
        f({ type: "refresh" });
      },
      M = function () {
        f({ type: "urlback" });
      },
      D = function () {
        f({ type: "urlforward" });
      },
      V = b("button", [b("icon"), Bn, zfe, fe({ minWidth: "$space$6", justifyContent: "center" })]);
    return E.jsxs(
      "div",
      Z({ className: b("navigator", [Vde, i]) }, o, {
        children: [
          E.jsx("button", {
            "aria-label": "Go back one page",
            className: V,
            disabled: !g,
            onClick: M,
            type: "button",
            children: E.jsx(Ghe, {}),
          }),
          E.jsx("button", {
            "aria-label": "Go forward one page",
            className: V,
            disabled: !S,
            onClick: D,
            type: "button",
            children: E.jsx(Jhe, {}),
          }),
          E.jsx("button", { "aria-label": "Refresh page", className: V, onClick: P, type: "button", children: E.jsx(sI, {}) }),
          E.jsx("input", {
            "aria-label": "Current Sandpack URL",
            className: b("input", [Bde]),
            name: "Current Sandpack URL",
            onChange: _,
            onKeyDown: T,
            type: "text",
            value: m,
          }),
        ],
      })
    );
  },
  y1,
  Zde = fe(
    ((y1 = { flex: 1, display: "flex", flexDirection: "column", background: "white", overflow: "auto", position: "relative" }),
    (y1[".".concat(ut, "-bridge-frame")] = {
      border: 0,
      position: "absolute",
      left: "$space$2",
      bottom: "$space$2",
      zIndex: "$top",
      height: 12,
      width: "30%",
      mixBlendMode: "multiply",
      pointerEvents: "none",
    }),
    y1)
  ),
  zde = fe({ border: "0", outline: "0", width: "100%", height: "100%", minHeight: "160px", maxHeight: "2000px", flex: 1 }),
  Wde = fe({ display: "flex", position: "absolute", bottom: "$space$2", right: "$space$2", zIndex: "$overlay", gap: "$space$2" }),
  Ude = w.forwardRef(function (t, e) {
    var n = t.showNavigator,
      r = n === void 0 ? !1 : n,
      i = t.showRefreshButton,
      s = i === void 0 ? !0 : i,
      o = t.showOpenInCodeSandbox,
      a = o === void 0 ? !0 : o,
      l = t.showSandpackErrorOverlay,
      c = l === void 0 ? !0 : l;
    t.showOpenNewtab;
    var u = t.showRestartButton,
      h = u === void 0 ? !0 : u,
      f = t.actionsChildren,
      d = f === void 0 ? E.jsx(E.Fragment, {}) : f,
      p = t.children,
      m = t.className,
      O = t.startRoute,
      v = O === void 0 ? "/" : O,
      g = Jt(t, [
        "showNavigator",
        "showRefreshButton",
        "showOpenInCodeSandbox",
        "showSandpackErrorOverlay",
        "showOpenNewtab",
        "showRestartButton",
        "actionsChildren",
        "children",
        "className",
        "startRoute",
      ]),
      x = OI({ startRoute: v }),
      y = x.sandpack,
      S = x.listen,
      k = x.iframe,
      b = x.getClient,
      _ = x.clientId,
      T = x.dispatch,
      P = w.useState(null),
      M = P[0],
      D = P[1],
      V = y.status,
      Q = fde(_).refresh,
      N = yS(_).restart,
      G = un();
    w.useEffect(function () {
      var te = S(function (le) {
        le.type === "resize" && D(le.height);
      });
      return te;
    }, []),
      w.useImperativeHandle(
        e,
        function () {
          return { clientId: _, getClient: b };
        },
        [b, _]
      );
    var H = function (te) {
      k.current && (k.current.src = te);
    };
    return E.jsxs(
      Lg,
      Z({ className: G("preview", [m]) }, g, {
        children: [
          r && E.jsx(jde, { clientId: _, onURLChange: H, startRoute: v }),
          E.jsxs("div", {
            className: G("preview-container", [Zde]),
            children: [
              E.jsx("iframe", { ref: k, className: G("preview-iframe", [zde]), style: { height: M || void 0 }, title: "Sandpack Preview" }),
              E.jsxs("div", {
                className: G("preview-actions", [Wde]),
                children: [
                  d,
                  h && y.environment === "node" && E.jsx(sh, { onClick: N, children: E.jsx(Ng, {}) }),
                  !r && s && V === "running" && E.jsx(sh, { onClick: Q, children: E.jsx(sI, {}) }),
                  y.teamId &&
                    E.jsx("button", {
                      className: G("button", [G("icon-standalone"), Bn, ss, sa]),
                      onClick: function () {
                        return T({ type: "sign-out" });
                      },
                      title: "Sign out",
                      type: "button",
                      children: E.jsx(qhe, {}),
                    }),
                  a && E.jsx(yI, {}),
                ],
              }),
              E.jsx(Nde, { clientId: _, showOpenInCodeSandbox: a }),
              c && E.jsx(gde, {}),
              p,
            ],
          }),
        ],
      })
    );
  }),
  w1;
fe(
  ((w1 = { display: "flex", flexDirection: "column", width: "100%", position: "relative", overflow: "auto", minHeight: "160px", flex: 1 }),
  (w1[".".concat(ut, "-stack")] = { height: "100%" }),
  w1)
);
fe({
  justifyContent: "space-between",
  borderBottom: "1px solid $colors$surface2",
  padding: "0 $space$2",
  fontFamily: "$font$mono",
  height: "$layout$headerHeight",
  minHeight: "$layout$headerHeight",
  overflowX: "auto",
  whiteSpace: "nowrap",
});
fe({ display: "flex", flexDirection: "row", alignItems: "center", gap: "$space$2" });
var Mg = fe({
  variants: {
    status: {
      pass: { color: "var(--test-pass)" },
      fail: { color: "var(--test-fail)" },
      skip: { color: "var(--test-skip)" },
      title: { color: "var(--test-title)" },
    },
  },
});
Mg({ status: "pass" });
Mg({ status: "fail" });
Mg({ status: "skip" });
Mg({ status: "title" });
var wS = fe({
  variants: {
    status: {
      pass: { background: "var(--test-pass)", color: "$colors$surface1" },
      fail: { background: "var(--test-fail)", color: "$colors$surface1" },
      run: { background: "var(--test-run)", color: "$colors$surface1" },
    },
  },
});
wS({ status: "run" });
wS({ status: "pass" });
wS({ status: "fail" });
fe({ marginLeft: "$space$4" });
fe({ marginBottom: "$space$2", color: "$colors$clickable" });
fe({ marginBottom: "$space$2", color: "$colors$hover" });
fe({ marginLeft: "$space$2" });
fe({ marginRight: "$space$2" });
fe({ color: "$colors$hover", marginBottom: "$space$2" });
fe({ marginLeft: "$space$4" });
fe({ color: "$colors$hover", fontSize: "$font$size", padding: "$space$2", whiteSpace: "pre-wrap" });
fe({ display: "flex", flexDirection: "row", alignItems: "center", marginBottom: "$space$2" });
fe({ marginBottom: "$space$2" });
fe({ fontWeight: "bold" });
fe({ borderRadius: "calc($border$radius / 2)" });
fe({ padding: "$space$1 $space$2", fontFamily: "$font$mono", textTransform: "uppercase", marginRight: "$space$2" });
fe({ fontFamily: "$font$mono", cursor: "pointer", display: "inline-block" });
fe({ color: "$colors$clickable", textDecorationStyle: "dotted", textDecorationLine: "underline" });
fe({ color: "$colors$hover", fontWeight: "bold", textDecorationStyle: "dotted", textDecorationLine: "underline" });
fe({ marginBottom: "$space$2" });
fe({ fontWeight: "bold", color: "$colors$hover", whiteSpace: "pre-wrap" });
fe({ fontWeight: "bold", color: "$colors$clickable" });
fe({ display: "flex", position: "absolute", bottom: "$space$2", right: "$space$2", zIndex: "$overlay", "> *": { marginLeft: "$space$2" } });
fe({
  padding: "$space$4",
  height: "100%",
  overflow: "auto",
  display: "flex",
  flexDirection: "column",
  position: "relative",
  fontFamily: "$font$mono",
});
fe({ fontWeight: "bold", color: "$colors$base" });
var Xde = ["SyntaxError: ", "Error in sandbox:"],
  Hde = { id: "random", method: "clear", data: ["Console was cleared"] },
  YE = "@t",
  GE = "#@t",
  JE = "@r",
  KE = 1e4,
  wI = 2,
  px = 400,
  qde = px * 2,
  S1 = (function () {
    var e = eval;
    return e("this");
  })(),
  Yde = typeof ArrayBuffer == "function",
  Gde = typeof Map == "function",
  Jde = typeof Set == "function",
  gu;
(function (t) {
  (t[(t.infinity = 0)] = "infinity"), (t[(t.minusInfinity = 1)] = "minusInfinity"), (t[(t.minusZero = 2)] = "minusZero");
})(gu || (gu = {}));
var eT = {
    Arithmetic: function (t) {
      return t === gu.infinity ? 1 / 0 : t === gu.minusInfinity ? -1 / 0 : t === gu.minusZero ? -0 : t;
    },
    HTMLElement: function (t) {
      var e = document.implementation.createHTMLDocument("sandbox");
      try {
        var n = e.createElement(t.tagName);
        n.innerHTML = t.innerHTML;
        for (var r = 0, i = Object.keys(t.attributes); r < i.length; r++) {
          var s = i[r];
          try {
            n.setAttribute(s, t.attributes[s]);
          } catch {}
        }
        return n;
      } catch {
        return t;
      }
    },
    Function: function (t) {
      var e = function () {};
      return (
        Object.defineProperty(e, "toString", {
          value: function () {
            return "function ".concat(t.name, "() {").concat(t.body, "}");
          },
        }),
        e
      );
    },
    "[[NaN]]": function () {
      return NaN;
    },
    "[[undefined]]": function () {},
    "[[Date]]": function (t) {
      var e = new Date();
      return e.setTime(t), e;
    },
    "[[RegExp]]": function (t) {
      return new RegExp(t.src, t.flags);
    },
    "[[Error]]": function (t) {
      var e = S1[t.name] || Error,
        n = new e(t.message);
      return (n.stack = t.stack), n;
    },
    "[[ArrayBuffer]]": function (t) {
      if (Yde) {
        var e = new ArrayBuffer(t.length),
          n = new Int8Array(e);
        return n.set(t), e;
      }
      return t;
    },
    "[[TypedArray]]": function (t) {
      return typeof S1[t.ctorName] == "function" ? new S1[t.ctorName](t.arr) : t.arr;
    },
    "[[Map]]": function (t) {
      if (Gde) {
        for (var e = new Map(), n = 0; n < t.length; n += 2) e.set(t[n], t[n + 1]);
        return e;
      }
      for (var r = [], i = 0; i < t.length; i += 2) r.push([t[n], t[n + 1]]);
      return r;
    },
    "[[Set]]": function (t) {
      if (Jde) {
        for (var e = new Set(), n = 0; n < t.length; n++) e.add(t[n]);
        return e;
      }
      return t;
    },
  },
  mx = function (t) {
    var e;
    if (typeof t == "string" || typeof t == "number" || t === null) return t;
    if (Array.isArray(t)) return t.map(mx);
    if (typeof t == "object" && YE in t) {
      var n = t[YE],
        r = eT[n];
      return r(t.data);
    } else if (typeof t == "object" && GE in t) {
      var n = t[GE],
        r = eT[n];
      return r(t.data);
    } else if (typeof t == "object" && ((e = t.constructor) === null || e === void 0 ? void 0 : e.name) === "NodeList") {
      var i = {};
      return (
        Object.entries(t).forEach(function (s) {
          var o = s[0],
            a = s[1];
          i[o] = mx(a);
        }),
        i
      );
    }
    return t;
  },
  Kde = function (t, e, n) {
    var r = t.reduce(function (i, s, o) {
      return ""
        .concat(i)
        .concat(o ? ", " : "")
        .concat(oh(s, e, n));
    }, "");
    return "[".concat(r, "]");
  },
  epe = function (t, e, n) {
    var r = t.constructor.name !== "Object" ? "".concat(t.constructor.name, " ") : "";
    if (n > wI) return r;
    var i = Object.entries(t),
      s = Object.entries(t).reduce(function (o, a, l) {
        var c = a[0],
          u = a[1],
          h = l === 0 ? "" : ", ",
          f =
            i.length > 10
              ? `
  `
              : "",
          d = oh(u, e, n);
        return l === px ? o + f + "..." : l > px ? o : o + "".concat(h).concat(f).concat(c, ": ") + d;
      }, "");
    return ""
      .concat(r, "{ ")
      .concat(s)
      .concat(
        i.length > 10
          ? `
`
          : " ",
        "}"
      );
  },
  oh = function (t, e, n) {
    var r;
    n === void 0 && (n = 0);
    try {
      var i = mx(t);
      if (Array.isArray(i)) return Kde(i, e, n + 1);
      switch (typeof i) {
        case "string":
          return '"'.concat(i, '"').slice(0, KE);
        case "number":
        case "function":
        case "symbol":
          return i.toString();
        case "boolean":
          return String(i);
        case "undefined":
          return "undefined";
        case "object":
        default:
          if (i instanceof RegExp || i instanceof Error || i instanceof Date) return i.toString();
          if (i === null) return String(null);
          if (i instanceof HTMLElement) return i.outerHTML.slice(0, KE);
          if (Object.entries(i).length === 0) return "{}";
          if (JE in i) {
            if (n > wI) return "Unable to print information";
            var s = e[i[JE]];
            return oh(s, e, n + 1);
          }
          if (((r = i.constructor) === null || r === void 0 ? void 0 : r.name) === "NodeList") {
            var o = i.length,
              a = new Array(o).fill(null).map(function (l, c) {
                return oh(i[c], e);
              });
            return "NodeList(".concat(i.length, ")[").concat(a, "]");
          }
          return epe(i, e, n + 1);
      }
    } catch {
      return "Unable to print information";
    }
  },
  tpe = function (t) {
    switch (t) {
      case "warn":
        return "warning";
      case "clear":
        return "clear";
      case "error":
        return "error";
      case "log":
      case "info":
      default:
        return "info";
    }
  },
  rd,
  npe = function (t) {
    var e = t.data,
      n = un();
    return E.jsx(E.Fragment, {
      children: e.map(function (r, i, s) {
        var o = r.data,
          a = r.id,
          l = r.method;
        return o && Array.isArray(o)
          ? E.jsx(
              w.Fragment,
              {
                children: o.map(function (c, u) {
                  var h = s.slice(i, s.length);
                  return E.jsx(
                    "div",
                    {
                      className: n("console-item", [rpe({ variant: tpe(l) })]),
                      children: E.jsx(bS, {
                        code: l === "clear" ? c : oh(c, h),
                        fileType: "js",
                        initMode: "user-visible",
                        showReadOnly: !1,
                        readOnly: !0,
                        wrapContent: !0,
                      }),
                    },
                    "".concat(a, "-").concat(u)
                  );
                }),
              },
              a
            )
          : null;
      }),
    });
  },
  rpe = fe(
    ((rd = {
      width: "100%",
      padding: "$space$3 $space$2",
      fontSize: ".8em",
      position: "relative",
      "&:not(:first-child):after": {
        content: "",
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: 1,
        background: "$colors$surface3",
      },
      ".sp-cm": { padding: 0 },
      ".cm-editor": { background: "none" },
      ".cm-content": { padding: 0 },
    }),
    (rd[".".concat(ut, "-pre-placeholder")] = { margin: "0 !important", fontSize: "1em" }),
    (rd.variants = {
      variant: {
        error: {
          color: "$colors$error",
          background: "$colors$errorSurface",
          "&:not(:first-child):after": { background: "$colors$error", opacity: 0.07 },
        },
        warning: {
          color: "$colors$warning",
          background: "$colors$warningSurface",
          "&:not(:first-child):after": { background: "$colors$warning", opacity: 0.07 },
        },
        clear: { fontStyle: "italic" },
        info: {},
      },
    }),
    rd)
  ),
  ipe = fe({
    justifyContent: "space-between",
    borderBottom: "1px solid $colors$surface2",
    padding: "0 $space$2",
    fontFamily: "$font$mono",
    height: "$layout$headerHeight",
    minHeight: "$layout$headerHeight",
    overflowX: "auto",
    whiteSpace: "nowrap",
  }),
  tT = fe({ display: "flex", flexDirection: "row", alignItems: "center", gap: "$space$2" }),
  spe = function (t) {
    var e = t.currentTab,
      n = t.setCurrentTab,
      r = t.node,
      i = un(),
      s = i("console-header-button", [Bn, sa, fe({ padding: "$space$1 $space$3" })]);
    return E.jsxs("div", {
      className: i("console-header", [ipe, tT]),
      children: [
        E.jsxs("p", {
          className: i("console-header-title", [
            fe({
              lineHeight: 1,
              margin: 0,
              color: "$colors$base",
              fontSize: "$font$size",
              display: "flex",
              alignItems: "center",
              gap: "$space$2",
            }),
          ]),
          children: [E.jsx(nfe, {}), E.jsx("span", { children: "Terminal" })],
        }),
        r &&
          E.jsxs("div", {
            className: i("console-header-actions", [tT]),
            children: [
              E.jsx("button", {
                className: s,
                "data-active": e === "server",
                onClick: function () {
                  return n("server");
                },
                type: "button",
                children: "Server",
              }),
              E.jsx("button", {
                className: s,
                "data-active": e === "client",
                onClick: function () {
                  return n("client");
                },
                type: "button",
                children: "Client",
              }),
            ],
          }),
      ],
    });
  },
  ope = function (t) {
    var e = t.clientId,
      n = t.maxMessageCount,
      r = n === void 0 ? qde : n,
      i = t.showSyntaxError,
      s = i === void 0 ? !1 : i,
      o = t.resetOnPreviewRestart,
      a = o === void 0 ? !1 : o,
      l = w.useState([]),
      c = l[0],
      u = l[1],
      h = Bt().listen;
    return (
      w.useEffect(
        function () {
          var f = h(function (d) {
            if (a && d.type === "start") u([]);
            else if (d.type === "console" && d.codesandbox) {
              var p = Array.isArray(d.log) ? d.log : [d.log];
              if (
                p.find(function (O) {
                  var v = O.method;
                  return v === "clear";
                })
              )
                return u([Hde]);
              var m = s
                ? p
                : p.filter(function (O) {
                    var v,
                      g,
                      x,
                      y =
                        (x =
                          (g = (v = O == null ? void 0 : O.data) === null || v === void 0 ? void 0 : v.filter) === null || g === void 0
                            ? void 0
                            : g.call(v, function (S) {
                                if (typeof S != "string") return !0;
                                var k = Xde.filter(function (b) {
                                  return S.startsWith(b);
                                });
                                return k.length === 0;
                              })) !== null && x !== void 0
                          ? x
                          : [];
                    return y.length > 0;
                  });
              if (!m) return;
              u(function (O) {
                for (
                  var v = wn(wn([], O, !0), m, !0).filter(function (g, x, y) {
                    return (
                      x ===
                      y.findIndex(function (S) {
                        return S.id === g.id;
                      })
                    );
                  });
                  v.length > r;

                )
                  v.shift();
                return v;
              });
            }
          }, e);
          return f;
        },
        [s, r, e, a]
      ),
      {
        logs: c,
        reset: function () {
          return u([]);
        },
      }
    );
  };
w.forwardRef(function (t, e) {
  var n,
    r = t.showHeader,
    i = r === void 0 ? !0 : r,
    s = t.showSyntaxError,
    o = s === void 0 ? !1 : s,
    a = t.maxMessageCount,
    l = t.onLogsChange,
    c = t.className;
  t.showSetupProgress;
  var u = t.showResetConsoleButton,
    h = u === void 0 ? !0 : u,
    f = t.showRestartButton,
    d = f === void 0 ? !0 : f,
    p = t.resetOnPreviewRestart,
    m = p === void 0 ? !1 : p,
    O = t.actionsChildren,
    v = O === void 0 ? E.jsx(E.Fragment, {}) : O,
    g = t.standalone,
    x = g === void 0 ? !1 : g,
    y = Jt(t, [
      "showHeader",
      "showSyntaxError",
      "maxMessageCount",
      "onLogsChange",
      "className",
      "showSetupProgress",
      "showResetConsoleButton",
      "showRestartButton",
      "resetOnPreviewRestart",
      "actionsChildren",
      "standalone",
    ]),
    S = Bt().sandpack.environment,
    k = OI(),
    b = k.iframe,
    _ = k.clientId,
    T = yS().restart,
    P = w.useState(S === "node" ? "server" : "client"),
    M = P[0],
    D = P[1],
    V = x ? _ : void 0,
    Q = ope({ maxMessageCount: a, showSyntaxError: o, resetOnPreviewRestart: m, clientId: V }),
    N = Q.logs,
    G = Q.reset,
    H = xI({ maxMessageCount: a, resetOnPreviewRestart: m, clientId: V }),
    te = H.logs,
    le = H.reset,
    $ = w.useRef(null);
  w.useEffect(
    function () {
      l == null || l(N), $.current && ($.current.scrollTop = $.current.scrollHeight);
    },
    [l, N, te, M]
  );
  var B = M === "server",
    ie = S === "node";
  w.useImperativeHandle(e, function () {
    return {
      reset: function () {
        G(), le();
      },
    };
  });
  var L = un();
  return E.jsxs(
    Lg,
    Z(
      {
        className: L("console", [
          fe(
            ((n = { height: "100%", background: "$surface1", iframe: { display: "none" } }),
            (n[".".concat(ut, "-bridge-frame")] = {
              display: "block",
              border: 0,
              position: "absolute",
              left: "$space$2",
              bottom: "$space$2",
              zIndex: "$top",
              height: 12,
              width: "30%",
              mixBlendMode: "multiply",
              pointerEvents: "none",
            }),
            n)
          ),
          c,
        ]),
      },
      y,
      {
        children: [
          i && ie && E.jsx(spe, { currentTab: M, node: ie, setCurrentTab: D }),
          E.jsx("div", {
            ref: $,
            className: L("console-list", [fe({ overflow: "auto", scrollBehavior: "smooth" })]),
            children: B ? E.jsx(bI, { data: te }) : E.jsx(npe, { data: N }),
          }),
          E.jsxs("div", {
            className: L("console-actions", [
              fe({ position: "absolute", bottom: "$space$2", right: "$space$2", display: "flex", gap: "$space$2" }),
            ]),
            children: [
              v,
              d &&
                B &&
                E.jsx(sh, {
                  onClick: function () {
                    T(), G(), le();
                  },
                  children: E.jsx(Ng, {}),
                }),
              h &&
                E.jsx(sh, {
                  onClick: function () {
                    M === "client" ? G() : le();
                  },
                  children: E.jsx(Khe, {}),
                }),
            ],
          }),
          x && E.jsxs(E.Fragment, { children: [E.jsx(Dde, { clientId: V }), E.jsx("iframe", { ref: b })] }),
        ],
      }
    )
  );
});
fe({
  position: "absolute",
  zIndex: "$top",
  variants: {
    direction: {
      vertical: { right: 0, left: 0, height: 10, cursor: "ns-resize" },
      horizontal: { top: 0, bottom: 0, width: 10, cursor: "ew-resize" },
    },
  },
  "@media screen and (max-width: 768px)": { display: "none" },
});
fe({
  position: "relative",
  strong: {
    background: "$colors$clickable",
    color: "$colors$surface1",
    minWidth: 12,
    height: 12,
    padding: "0 2px",
    borderRadius: 12,
    fontSize: 8,
    lineHeight: "12px",
    position: "absolute",
    top: 0,
    right: 0,
    fontWeight: "normal",
  },
});
fe({ width: "100%", overflow: "hidden" });
fe({
  flexDirection: "row-reverse",
  "@media screen and (max-width: 768px)": { flexFlow: "wrap-reverse !important", flexDirection: "initial" },
});
function SI(t, e, n, r) {
  const i = yt(At),
    s = tt(ho),
    o = C.useRef(null),
    { lexicalNode: a } = wl(),
    l = C.useRef(!1),
    c = C.useRef(!1),
    u = C.useCallback(() => {
      s({ editorType: e, rootNode: a });
    }, [e, a, s]),
    h = C.useCallback(
      (f) => {
        var d, p, m, O, v, g;
        if (f.key === "ArrowDown") {
          const x = (p = (d = o.current) == null ? void 0 : d.getCodemirror()) == null ? void 0 : p.state;
          if (x) {
            const y = x.doc.length,
              S = x.selection.ranges[0].to;
            y === S &&
              (l.current
                ? (i == null ||
                    i.update(() => {
                      var k, b;
                      const _ = vt(t);
                      _.getNextSibling()
                        ? ((b = (k = o.current) == null ? void 0 : k.getCodemirror()) == null || b.contentDOM.blur(), _.selectNext())
                        : _.insertAfter(at());
                    }),
                  (l.current = !1))
                : (l.current = !0));
          }
        } else if (f.key === "ArrowUp") {
          const x = (O = (m = o.current) == null ? void 0 : m.getCodemirror()) == null ? void 0 : O.state;
          x &&
            x.selection.ranges[0].from === 0 &&
            (c.current
              ? (i == null ||
                  i.update(() => {
                    var S, k;
                    const b = vt(t);
                    b.getPreviousSibling() &&
                      ((k = (S = o.current) == null ? void 0 : S.getCodemirror()) == null || k.contentDOM.blur(), b.selectPrevious());
                  }),
                (c.current = !1))
              : (c.current = !0));
        } else if (f.key === "Enter") f.stopPropagation();
        else if (f.key === "Backspace" || f.key === "Delete") {
          const x = (g = (v = o.current) == null ? void 0 : v.getCodemirror()) == null ? void 0 : g.state;
          (x == null ? void 0 : x.doc.length) === 0 &&
            (i == null ||
              i.update(() => {
                vt(t).remove();
              }));
        }
      },
      [i, t]
    );
  return (
    C.useEffect(() => {
      const f = o.current;
      return (
        setTimeout(() => {
          var d, p;
          (d = f == null ? void 0 : f.getCodemirror()) == null || d.contentDOM.addEventListener("focus", u),
            (p = f == null ? void 0 : f.getCodemirror()) == null || p.contentDOM.addEventListener("keydown", h);
        }, 300),
        () => {
          var d, p;
          (d = f == null ? void 0 : f.getCodemirror()) == null || d.contentDOM.removeEventListener("focus", u),
            (p = f == null ? void 0 : f.getCodemirror()) == null || p.contentDOM.removeEventListener("keydown", h);
        }
      );
    }, [o, u, h, n]),
    C.useEffect(() => {
      r.subscribe(() => {
        var f, d;
        (d = (f = o.current) == null ? void 0 : f.getCodemirror()) == null || d.focus(), u();
      });
    }, [r, o, t, u]),
    o
  );
}
const ape = ({ onChange: t, snippetFileName: e }) => {
    const { sandpack: n } = Bt();
    return t(n.files[e].code), null;
  },
  lpe = ({ nodeKey: t, code: e, focusEmitter: n, preset: r }) => {
    const i = SI(t, "sandpack", "jsx", n),
      [s, o] = nt(sn, ft),
      { setCode: a } = wl(),
      { parentEditor: l, lexicalNode: c } = wl(),
      u = lt();
    return C.createElement(
      "div",
      { className: F.sandPackWrapper },
      C.createElement(
        "div",
        { className: F.codeMirrorToolbar },
        C.createElement(
          "button",
          {
            className: F.iconButton,
            type: "button",
            title: u("codeblock.delete", "Delete code block"),
            onClick: (h) => {
              h.preventDefault(),
                l.update(() => {
                  c.remove();
                });
            },
          },
          o("delete_small")
        )
      ),
      C.createElement(
        Zfe,
        {
          template: r.sandpackTemplate,
          theme: r.sandpackTheme,
          files: {
            [r.snippetFileName]: e,
            ...Object.entries(r.files ?? {}).reduce((h, [f, d]) => ({ ...h, [f]: { code: d, readOnly: !0 } }), {}),
          },
          customSetup: { dependencies: r.dependencies },
        },
        C.createElement(
          cde,
          null,
          C.createElement(ade, { readOnly: s, showLineNumbers: !0, showInlineErrors: !0, ref: i }),
          C.createElement(Ude, null)
        ),
        C.createElement(ape, { onChange: a, snippetFileName: r.snippetFileName })
      )
    );
  },
  cpe = `
export default function App() {
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}
`,
  upe = {
    defaultPreset: "react",
    presets: [
      {
        name: "react",
        meta: "live react",
        label: "React",
        sandpackTemplate: "react",
        sandpackTheme: "light",
        snippetFileName: "/App.js",
        snippetLanguage: "jsx",
        initialSnippetContent: cpe,
      },
    ],
  },
  oa = Se(upe),
  SS = $t((t) => {
    t.link(
      t.pipe(
        SS,
        bt(oa),
        Rr(([e, n]) => {
          const r = e ? n.presets.find((i) => i.name === e) : n.presets.find((i) => i.name == n.defaultPreset);
          if (!r) throw new Error(`No sandpack preset found with name ${e}`);
          return { code: r.initialSnippetContent ?? "", language: r.snippetLanguage ?? "jsx", meta: r.meta };
        })
      ),
      Kh
    );
  }),
  hpe = en({
    init(t, e) {
      t.pubIn({ [oa]: e == null ? void 0 : e.sandpackConfig, [yw]: fpe() });
    },
    update(t, e) {
      t.pub(oa, e == null ? void 0 : e.sandpackConfig);
    },
  });
function fpe() {
  return {
    match(t, e) {
      return !!(e != null && e.startsWith("live"));
    },
    Editor(t) {
      const n = yt(oa).presets.find((r) => r.meta === t.meta);
      if (!n) throw new Error(`No sandpack preset found with ${t.meta}`);
      return C.createElement(lpe, { ...t, preset: n });
    },
    priority: 1,
  };
}
function J(t) {
  return new Tl(Zw.define(t));
}
function Cs(t) {
  return z(
    () => import("./index-3bde5d4a.js"),
    [
      "./index-3bde5d4a.js",
      "./index-7c191284.js",
      "./useResultBannerController-cd95b20f.js",
      "./apis-0c1c184f.js",
      "./iframe-35b6cbe2.js",
      "./useAction-f9651b8b.js",
      "./jsx-runtime-69eee039.js",
      "./index-363833c6.js",
      "./index-f0f16ed8.js",
      "./extends-98964cd2.js",
      "./dateTimeUtils-a817f99d.js",
    ],
    import.meta.url
  ).then((e) => e.sql({ dialect: e[t] }));
}
const dpe = [
    j.of({
      name: "C",
      extensions: ["c", "h", "ino"],
      load() {
        return z(
          () => import("./index-3a3e95c2.js"),
          [
            "./index-3a3e95c2.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.cpp());
      },
    }),
    j.of({
      name: "C++",
      alias: ["cpp"],
      extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
      load() {
        return z(
          () => import("./index-3a3e95c2.js"),
          [
            "./index-3a3e95c2.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.cpp());
      },
    }),
    j.of({
      name: "CQL",
      alias: ["cassandra"],
      extensions: ["cql"],
      load() {
        return Cs("Cassandra");
      },
    }),
    j.of({
      name: "CSS",
      extensions: ["css"],
      load() {
        return z(() => Promise.resolve().then(() => fue), void 0, import.meta.url).then((t) => t.css());
      },
    }),
    j.of({
      name: "Go",
      extensions: ["go"],
      load() {
        return z(
          () => import("./index-9bffac5f.js"),
          [
            "./index-9bffac5f.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.go());
      },
    }),
    j.of({
      name: "HTML",
      alias: ["xhtml"],
      extensions: ["html", "htm", "handlebars", "hbs"],
      load() {
        return z(() => Promise.resolve().then(() => Qhe), void 0, import.meta.url).then((t) => t.html());
      },
    }),
    j.of({
      name: "Java",
      extensions: ["java"],
      load() {
        return z(
          () => import("./index-c467f516.js"),
          [
            "./index-c467f516.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.java());
      },
    }),
    j.of({
      name: "JavaScript",
      alias: ["ecmascript", "js", "node"],
      extensions: ["js", "mjs", "cjs"],
      load() {
        return z(() => Promise.resolve().then(() => Jf), void 0, import.meta.url).then((t) => t.javascript());
      },
    }),
    j.of({
      name: "JSON",
      alias: ["json5"],
      extensions: ["json", "map"],
      load() {
        return z(
          () => import("./index-0ffbe94e.js"),
          [
            "./index-0ffbe94e.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.json());
      },
    }),
    j.of({
      name: "JSX",
      extensions: ["jsx"],
      load() {
        return z(() => Promise.resolve().then(() => Jf), void 0, import.meta.url).then((t) => t.javascript({ jsx: !0 }));
      },
    }),
    j.of({
      name: "LESS",
      extensions: ["less"],
      load() {
        return z(
          () => import("./index-613d98e8.js"),
          [
            "./index-613d98e8.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.less());
      },
    }),
    j.of({
      name: "Liquid",
      extensions: ["liquid"],
      load() {
        return z(
          () => import("./index-18b6788c.js"),
          [
            "./index-18b6788c.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.liquid());
      },
    }),
    j.of({
      name: "MariaDB SQL",
      load() {
        return Cs("MariaSQL");
      },
    }),
    j.of({
      name: "Markdown",
      extensions: ["md", "markdown", "mkd"],
      load() {
        return z(() => Promise.resolve().then(() => ROe), void 0, import.meta.url).then((t) => t.markdown());
      },
    }),
    j.of({
      name: "MS SQL",
      load() {
        return Cs("MSSQL");
      },
    }),
    j.of({
      name: "MySQL",
      load() {
        return Cs("MySQL");
      },
    }),
    j.of({
      name: "PHP",
      extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
      load() {
        return z(
          () => import("./index-b2ec329c.js"),
          [
            "./index-b2ec329c.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.php());
      },
    }),
    j.of({
      name: "PLSQL",
      extensions: ["pls"],
      load() {
        return Cs("PLSQL");
      },
    }),
    j.of({
      name: "PostgreSQL",
      load() {
        return Cs("PostgreSQL");
      },
    }),
    j.of({
      name: "Python",
      extensions: ["BUILD", "bzl", "py", "pyw"],
      filename: /^(BUCK|BUILD)$/,
      load() {
        return z(
          () => import("./index-20418d7a.js"),
          [
            "./index-20418d7a.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.python());
      },
    }),
    j.of({
      name: "Rust",
      extensions: ["rs"],
      load() {
        return z(
          () => import("./index-473ee533.js"),
          [
            "./index-473ee533.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.rust());
      },
    }),
    j.of({
      name: "Sass",
      extensions: ["sass"],
      load() {
        return z(
          () => import("./index-f0b4160a.js"),
          [
            "./index-f0b4160a.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.sass({ indented: !0 }));
      },
    }),
    j.of({
      name: "SCSS",
      extensions: ["scss"],
      load() {
        return z(
          () => import("./index-f0b4160a.js"),
          [
            "./index-f0b4160a.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.sass());
      },
    }),
    j.of({
      name: "SQL",
      extensions: ["sql"],
      load() {
        return Cs("StandardSQL");
      },
    }),
    j.of({
      name: "SQLite",
      load() {
        return Cs("SQLite");
      },
    }),
    j.of({
      name: "TSX",
      extensions: ["tsx"],
      load() {
        return z(() => Promise.resolve().then(() => Jf), void 0, import.meta.url).then((t) => t.javascript({ jsx: !0, typescript: !0 }));
      },
    }),
    j.of({
      name: "TypeScript",
      alias: ["ts"],
      extensions: ["ts", "mts", "cts"],
      load() {
        return z(() => Promise.resolve().then(() => Jf), void 0, import.meta.url).then((t) => t.javascript({ typescript: !0 }));
      },
    }),
    j.of({
      name: "WebAssembly",
      extensions: ["wat", "wast"],
      load() {
        return z(
          () => import("./index-cfd368f2.js"),
          [
            "./index-cfd368f2.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.wast());
      },
    }),
    j.of({
      name: "XML",
      alias: ["rss", "wsdl", "xsd"],
      extensions: ["xml", "xsl", "xsd", "svg"],
      load() {
        return z(
          () => import("./index-f46664cf.js"),
          [
            "./index-f46664cf.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.xml());
      },
    }),
    j.of({
      name: "YAML",
      alias: ["yml"],
      extensions: ["yaml", "yml"],
      load() {
        return z(
          () => import("./index-1a7a5d00.js"),
          [
            "./index-1a7a5d00.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.yaml());
      },
    }),
    j.of({
      name: "APL",
      extensions: ["dyalog", "apl"],
      load() {
        return z(() => import("./apl-f73da2d7.js"), [], import.meta.url).then((t) => J(t.apl));
      },
    }),
    j.of({
      name: "PGP",
      alias: ["asciiarmor"],
      extensions: ["asc", "pgp", "sig"],
      load() {
        return z(() => import("./asciiarmor-e7973ceb.js"), [], import.meta.url).then((t) => J(t.asciiArmor));
      },
    }),
    j.of({
      name: "ASN.1",
      extensions: ["asn", "asn1"],
      load() {
        return z(() => import("./asn1-f9c290f0.js"), [], import.meta.url).then((t) => J(t.asn1({})));
      },
    }),
    j.of({
      name: "Asterisk",
      filename: /^extensions\.conf$/i,
      load() {
        return z(() => import("./asterisk-9c249b4c.js"), [], import.meta.url).then((t) => J(t.asterisk));
      },
    }),
    j.of({
      name: "Brainfuck",
      extensions: ["b", "bf"],
      load() {
        return z(() => import("./brainfuck-637b9bf0.js"), [], import.meta.url).then((t) => J(t.brainfuck));
      },
    }),
    j.of({
      name: "Cobol",
      extensions: ["cob", "cpy"],
      load() {
        return z(() => import("./cobol-3c0e8dcf.js"), [], import.meta.url).then((t) => J(t.cobol));
      },
    }),
    j.of({
      name: "C#",
      alias: ["csharp", "cs"],
      extensions: ["cs"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => J(t.csharp));
      },
    }),
    j.of({
      name: "Clojure",
      extensions: ["clj", "cljc", "cljx"],
      load() {
        return z(() => import("./clojure-46c215dd.js"), [], import.meta.url).then((t) => J(t.clojure));
      },
    }),
    j.of({
      name: "ClojureScript",
      extensions: ["cljs"],
      load() {
        return z(() => import("./clojure-46c215dd.js"), [], import.meta.url).then((t) => J(t.clojure));
      },
    }),
    j.of({
      name: "Closure Stylesheets (GSS)",
      extensions: ["gss"],
      load() {
        return z(() => import("./css-ae0ae1d0.js"), [], import.meta.url).then((t) => J(t.gss));
      },
    }),
    j.of({
      name: "CMake",
      extensions: ["cmake", "cmake.in"],
      filename: /^CMakeLists\.txt$/,
      load() {
        return z(() => import("./cmake-f314e514.js"), [], import.meta.url).then((t) => J(t.cmake));
      },
    }),
    j.of({
      name: "CoffeeScript",
      alias: ["coffee", "coffee-script"],
      extensions: ["coffee"],
      load() {
        return z(() => import("./coffeescript-cf6fb77c.js"), [], import.meta.url).then((t) => J(t.coffeeScript));
      },
    }),
    j.of({
      name: "Common Lisp",
      alias: ["lisp"],
      extensions: ["cl", "lisp", "el"],
      load() {
        return z(() => import("./commonlisp-0ea12945.js"), [], import.meta.url).then((t) => J(t.commonLisp));
      },
    }),
    j.of({
      name: "Cypher",
      extensions: ["cyp", "cypher"],
      load() {
        return z(() => import("./cypher-236a65ad.js"), [], import.meta.url).then((t) => J(t.cypher));
      },
    }),
    j.of({
      name: "Cython",
      extensions: ["pyx", "pxd", "pxi"],
      load() {
        return z(() => import("./python-fa45e8d1.js"), [], import.meta.url).then((t) => J(t.cython));
      },
    }),
    j.of({
      name: "Crystal",
      extensions: ["cr"],
      load() {
        return z(() => import("./crystal-02658b69.js"), [], import.meta.url).then((t) => J(t.crystal));
      },
    }),
    j.of({
      name: "D",
      extensions: ["d"],
      load() {
        return z(() => import("./d-76ab4361.js"), [], import.meta.url).then((t) => J(t.d));
      },
    }),
    j.of({
      name: "Dart",
      extensions: ["dart"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => J(t.dart));
      },
    }),
    j.of({
      name: "diff",
      extensions: ["diff", "patch"],
      load() {
        return z(() => import("./diff-1bf42f34.js"), [], import.meta.url).then((t) => J(t.diff));
      },
    }),
    j.of({
      name: "Dockerfile",
      filename: /^Dockerfile$/,
      load() {
        return z(() => import("./dockerfile-c8a8b9da.js"), ["./dockerfile-c8a8b9da.js", "./simple-mode-851e42ff.js"], import.meta.url).then(
          (t) => J(t.dockerFile)
        );
      },
    }),
    j.of({
      name: "DTD",
      extensions: ["dtd"],
      load() {
        return z(() => import("./dtd-8d673f3f.js"), [], import.meta.url).then((t) => J(t.dtd));
      },
    }),
    j.of({
      name: "Dylan",
      extensions: ["dylan", "dyl", "intr"],
      load() {
        return z(() => import("./dylan-94e68d48.js"), [], import.meta.url).then((t) => J(t.dylan));
      },
    }),
    j.of({
      name: "EBNF",
      load() {
        return z(() => import("./ebnf-9a58f677.js"), [], import.meta.url).then((t) => J(t.ebnf));
      },
    }),
    j.of({
      name: "ECL",
      extensions: ["ecl"],
      load() {
        return z(() => import("./ecl-8c848bde.js"), [], import.meta.url).then((t) => J(t.ecl));
      },
    }),
    j.of({
      name: "edn",
      extensions: ["edn"],
      load() {
        return z(() => import("./clojure-46c215dd.js"), [], import.meta.url).then((t) => J(t.clojure));
      },
    }),
    j.of({
      name: "Eiffel",
      extensions: ["e"],
      load() {
        return z(() => import("./eiffel-c812667a.js"), [], import.meta.url).then((t) => J(t.eiffel));
      },
    }),
    j.of({
      name: "Elm",
      extensions: ["elm"],
      load() {
        return z(() => import("./elm-389625db.js"), [], import.meta.url).then((t) => J(t.elm));
      },
    }),
    j.of({
      name: "Erlang",
      extensions: ["erl"],
      load() {
        return z(() => import("./erlang-72724d5c.js"), [], import.meta.url).then((t) => J(t.erlang));
      },
    }),
    j.of({
      name: "Esper",
      load() {
        return z(() => import("./sql-62feda9f.js"), [], import.meta.url).then((t) => J(t.esper));
      },
    }),
    j.of({
      name: "Factor",
      extensions: ["factor"],
      load() {
        return z(() => import("./factor-7bfcb4fc.js"), ["./factor-7bfcb4fc.js", "./simple-mode-851e42ff.js"], import.meta.url).then((t) =>
          J(t.factor)
        );
      },
    }),
    j.of({
      name: "FCL",
      load() {
        return z(() => import("./fcl-d5e95185.js"), [], import.meta.url).then((t) => J(t.fcl));
      },
    }),
    j.of({
      name: "Forth",
      extensions: ["forth", "fth", "4th"],
      load() {
        return z(() => import("./forth-a6c07be1.js"), [], import.meta.url).then((t) => J(t.forth));
      },
    }),
    j.of({
      name: "Fortran",
      extensions: ["f", "for", "f77", "f90", "f95"],
      load() {
        return z(() => import("./fortran-b746f455.js"), [], import.meta.url).then((t) => J(t.fortran));
      },
    }),
    j.of({
      name: "F#",
      alias: ["fsharp"],
      extensions: ["fs"],
      load() {
        return z(() => import("./mllike-1f866598.js"), [], import.meta.url).then((t) => J(t.fSharp));
      },
    }),
    j.of({
      name: "Gas",
      extensions: ["s"],
      load() {
        return z(() => import("./gas-a519128b.js"), [], import.meta.url).then((t) => J(t.gas));
      },
    }),
    j.of({
      name: "Gherkin",
      extensions: ["feature"],
      load() {
        return z(() => import("./gherkin-0efe02ac.js"), [], import.meta.url).then((t) => J(t.gherkin));
      },
    }),
    j.of({
      name: "Groovy",
      extensions: ["groovy", "gradle"],
      filename: /^Jenkinsfile$/,
      load() {
        return z(() => import("./groovy-4592a472.js"), [], import.meta.url).then((t) => J(t.groovy));
      },
    }),
    j.of({
      name: "Haskell",
      extensions: ["hs"],
      load() {
        return z(() => import("./haskell-b620645c.js"), [], import.meta.url).then((t) => J(t.haskell));
      },
    }),
    j.of({
      name: "Haxe",
      extensions: ["hx"],
      load() {
        return z(() => import("./haxe-7215664e.js"), [], import.meta.url).then((t) => J(t.haxe));
      },
    }),
    j.of({
      name: "HXML",
      extensions: ["hxml"],
      load() {
        return z(() => import("./haxe-7215664e.js"), [], import.meta.url).then((t) => J(t.hxml));
      },
    }),
    j.of({
      name: "HTTP",
      load() {
        return z(() => import("./http-e091c18d.js"), [], import.meta.url).then((t) => J(t.http));
      },
    }),
    j.of({
      name: "IDL",
      extensions: ["pro"],
      load() {
        return z(() => import("./idl-91cb7788.js"), [], import.meta.url).then((t) => J(t.idl));
      },
    }),
    j.of({
      name: "JSON-LD",
      alias: ["jsonld"],
      extensions: ["jsonld"],
      load() {
        return z(() => import("./javascript-da64953c.js"), [], import.meta.url).then((t) => J(t.jsonld));
      },
    }),
    j.of({
      name: "Jinja2",
      extensions: ["j2", "jinja", "jinja2"],
      load() {
        return z(() => import("./jinja2-580c43a7.js"), [], import.meta.url).then((t) => J(t.jinja2));
      },
    }),
    j.of({
      name: "Julia",
      extensions: ["jl"],
      load() {
        return z(() => import("./julia-2f39a740.js"), [], import.meta.url).then((t) => J(t.julia));
      },
    }),
    j.of({
      name: "Kotlin",
      extensions: ["kt", "kts"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => J(t.kotlin));
      },
    }),
    j.of({
      name: "LiveScript",
      alias: ["ls"],
      extensions: ["ls"],
      load() {
        return z(() => import("./livescript-a3318e59.js"), [], import.meta.url).then((t) => J(t.liveScript));
      },
    }),
    j.of({
      name: "Lua",
      extensions: ["lua"],
      load() {
        return z(() => import("./lua-ee237842.js"), [], import.meta.url).then((t) => J(t.lua));
      },
    }),
    j.of({
      name: "mIRC",
      extensions: ["mrc"],
      load() {
        return z(() => import("./mirc-c043bc0a.js"), [], import.meta.url).then((t) => J(t.mirc));
      },
    }),
    j.of({
      name: "Mathematica",
      extensions: ["m", "nb", "wl", "wls"],
      load() {
        return z(() => import("./mathematica-4db1ec63.js"), [], import.meta.url).then((t) => J(t.mathematica));
      },
    }),
    j.of({
      name: "Modelica",
      extensions: ["mo"],
      load() {
        return z(() => import("./modelica-c19c47b8.js"), [], import.meta.url).then((t) => J(t.modelica));
      },
    }),
    j.of({
      name: "MUMPS",
      extensions: ["mps"],
      load() {
        return z(() => import("./mumps-82310ef4.js"), [], import.meta.url).then((t) => J(t.mumps));
      },
    }),
    j.of({
      name: "Mbox",
      extensions: ["mbox"],
      load() {
        return z(() => import("./mbox-b40e52ca.js"), [], import.meta.url).then((t) => J(t.mbox));
      },
    }),
    j.of({
      name: "Nginx",
      filename: /nginx.*\.conf$/i,
      load() {
        return z(() => import("./nginx-0992a7c8.js"), [], import.meta.url).then((t) => J(t.nginx));
      },
    }),
    j.of({
      name: "NSIS",
      extensions: ["nsh", "nsi"],
      load() {
        return z(() => import("./nsis-419655c7.js"), ["./nsis-419655c7.js", "./simple-mode-851e42ff.js"], import.meta.url).then((t) =>
          J(t.nsis)
        );
      },
    }),
    j.of({
      name: "NTriples",
      extensions: ["nt", "nq"],
      load() {
        return z(() => import("./ntriples-8490b09b.js"), [], import.meta.url).then((t) => J(t.ntriples));
      },
    }),
    j.of({
      name: "Objective-C",
      alias: ["objective-c", "objc"],
      extensions: ["m"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => J(t.objectiveC));
      },
    }),
    j.of({
      name: "Objective-C++",
      alias: ["objective-c++", "objc++"],
      extensions: ["mm"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => J(t.objectiveCpp));
      },
    }),
    j.of({
      name: "OCaml",
      extensions: ["ml", "mli", "mll", "mly"],
      load() {
        return z(() => import("./mllike-1f866598.js"), [], import.meta.url).then((t) => J(t.oCaml));
      },
    }),
    j.of({
      name: "Octave",
      extensions: ["m"],
      load() {
        return z(() => import("./octave-3f516c2f.js"), [], import.meta.url).then((t) => J(t.octave));
      },
    }),
    j.of({
      name: "Oz",
      extensions: ["oz"],
      load() {
        return z(() => import("./oz-a640e05c.js"), [], import.meta.url).then((t) => J(t.oz));
      },
    }),
    j.of({
      name: "Pascal",
      extensions: ["p", "pas"],
      load() {
        return z(() => import("./pascal-bcac1c04.js"), [], import.meta.url).then((t) => J(t.pascal));
      },
    }),
    j.of({
      name: "Perl",
      extensions: ["pl", "pm"],
      load() {
        return z(() => import("./perl-a9455719.js"), [], import.meta.url).then((t) => J(t.perl));
      },
    }),
    j.of({
      name: "Pig",
      extensions: ["pig"],
      load() {
        return z(() => import("./pig-3510ca5f.js"), [], import.meta.url).then((t) => J(t.pig));
      },
    }),
    j.of({
      name: "PowerShell",
      extensions: ["ps1", "psd1", "psm1"],
      load() {
        return z(() => import("./powershell-c2c54630.js"), [], import.meta.url).then((t) => J(t.powerShell));
      },
    }),
    j.of({
      name: "Properties files",
      alias: ["ini", "properties"],
      extensions: ["properties", "ini", "in"],
      load() {
        return z(() => import("./properties-aba123c1.js"), [], import.meta.url).then((t) => J(t.properties));
      },
    }),
    j.of({
      name: "ProtoBuf",
      extensions: ["proto"],
      load() {
        return z(() => import("./protobuf-1713bf80.js"), [], import.meta.url).then((t) => J(t.protobuf));
      },
    }),
    j.of({
      name: "Pug",
      alias: ["jade"],
      extensions: ["pug", "jade"],
      load() {
        return z(() => import("./pug-c3549eac.js"), ["./pug-c3549eac.js", "./javascript-da64953c.js"], import.meta.url).then((t) =>
          J(t.pug)
        );
      },
    }),
    j.of({
      name: "Puppet",
      extensions: ["pp"],
      load() {
        return z(() => import("./puppet-3229bfe4.js"), [], import.meta.url).then((t) => J(t.puppet));
      },
    }),
    j.of({
      name: "Q",
      extensions: ["q"],
      load() {
        return z(() => import("./q-887a0cfa.js"), [], import.meta.url).then((t) => J(t.q));
      },
    }),
    j.of({
      name: "R",
      alias: ["rscript"],
      extensions: ["r", "R"],
      load() {
        return z(() => import("./r-3ca97919.js"), [], import.meta.url).then((t) => J(t.r));
      },
    }),
    j.of({
      name: "RPM Changes",
      load() {
        return z(() => import("./rpm-aa81b362.js"), [], import.meta.url).then((t) => J(t.rpmChanges));
      },
    }),
    j.of({
      name: "RPM Spec",
      extensions: ["spec"],
      load() {
        return z(() => import("./rpm-aa81b362.js"), [], import.meta.url).then((t) => J(t.rpmSpec));
      },
    }),
    j.of({
      name: "Ruby",
      alias: ["jruby", "macruby", "rake", "rb", "rbx"],
      extensions: ["rb"],
      filename: /^(Gemfile|Rakefile)$/,
      load() {
        return z(() => import("./ruby-e88f1f8d.js"), [], import.meta.url).then((t) => J(t.ruby));
      },
    }),
    j.of({
      name: "SAS",
      extensions: ["sas"],
      load() {
        return z(() => import("./sas-4096b960.js"), [], import.meta.url).then((t) => J(t.sas));
      },
    }),
    j.of({
      name: "Scala",
      extensions: ["scala"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => J(t.scala));
      },
    }),
    j.of({
      name: "Scheme",
      extensions: ["scm", "ss"],
      load() {
        return z(() => import("./scheme-ca3e6863.js"), [], import.meta.url).then((t) => J(t.scheme));
      },
    }),
    j.of({
      name: "Shell",
      alias: ["bash", "sh", "zsh"],
      extensions: ["sh", "ksh", "bash"],
      filename: /^PKGBUILD$/,
      load() {
        return z(() => import("./shell-61e14131.js"), [], import.meta.url).then((t) => J(t.shell));
      },
    }),
    j.of({
      name: "Sieve",
      extensions: ["siv", "sieve"],
      load() {
        return z(() => import("./sieve-4b1eb6fb.js"), [], import.meta.url).then((t) => J(t.sieve));
      },
    }),
    j.of({
      name: "Smalltalk",
      extensions: ["st"],
      load() {
        return z(() => import("./smalltalk-b41561ee.js"), [], import.meta.url).then((t) => J(t.smalltalk));
      },
    }),
    j.of({
      name: "Solr",
      load() {
        return z(() => import("./solr-eac40f87.js"), [], import.meta.url).then((t) => J(t.solr));
      },
    }),
    j.of({
      name: "SML",
      extensions: ["sml", "sig", "fun", "smackspec"],
      load() {
        return z(() => import("./mllike-1f866598.js"), [], import.meta.url).then((t) => J(t.sml));
      },
    }),
    j.of({
      name: "SPARQL",
      alias: ["sparul"],
      extensions: ["rq", "sparql"],
      load() {
        return z(() => import("./sparql-a1ae2f33.js"), [], import.meta.url).then((t) => J(t.sparql));
      },
    }),
    j.of({
      name: "Spreadsheet",
      alias: ["excel", "formula"],
      load() {
        return z(() => import("./spreadsheet-9f4dc4c6.js"), [], import.meta.url).then((t) => J(t.spreadsheet));
      },
    }),
    j.of({
      name: "Squirrel",
      extensions: ["nut"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => J(t.squirrel));
      },
    }),
    j.of({
      name: "Stylus",
      extensions: ["styl"],
      load() {
        return z(() => import("./stylus-2d29a832.js"), [], import.meta.url).then((t) => J(t.stylus));
      },
    }),
    j.of({
      name: "Swift",
      extensions: ["swift"],
      load() {
        return z(() => import("./swift-b6dd686e.js"), [], import.meta.url).then((t) => J(t.swift));
      },
    }),
    j.of({
      name: "sTeX",
      load() {
        return z(() => import("./stex-611747c4.js"), [], import.meta.url).then((t) => J(t.stex));
      },
    }),
    j.of({
      name: "LaTeX",
      alias: ["tex"],
      extensions: ["text", "ltx", "tex"],
      load() {
        return z(() => import("./stex-611747c4.js"), [], import.meta.url).then((t) => J(t.stex));
      },
    }),
    j.of({
      name: "SystemVerilog",
      extensions: ["v", "sv", "svh"],
      load() {
        return z(() => import("./verilog-701759f4.js"), [], import.meta.url).then((t) => J(t.verilog));
      },
    }),
    j.of({
      name: "Tcl",
      extensions: ["tcl"],
      load() {
        return z(() => import("./tcl-9a9d281f.js"), [], import.meta.url).then((t) => J(t.tcl));
      },
    }),
    j.of({
      name: "Textile",
      extensions: ["textile"],
      load() {
        return z(() => import("./textile-27197230.js"), [], import.meta.url).then((t) => J(t.textile));
      },
    }),
    j.of({
      name: "TiddlyWiki",
      load() {
        return z(() => import("./tiddlywiki-053c4b39.js"), [], import.meta.url).then((t) => J(t.tiddlyWiki));
      },
    }),
    j.of({
      name: "Tiki wiki",
      load() {
        return z(() => import("./tiki-f8970e14.js"), [], import.meta.url).then((t) => J(t.tiki));
      },
    }),
    j.of({
      name: "TOML",
      extensions: ["toml"],
      load() {
        return z(() => import("./toml-fed73c05.js"), [], import.meta.url).then((t) => J(t.toml));
      },
    }),
    j.of({
      name: "Troff",
      extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
      load() {
        return z(() => import("./troff-1c50c70f.js"), [], import.meta.url).then((t) => J(t.troff));
      },
    }),
    j.of({
      name: "TTCN",
      extensions: ["ttcn", "ttcn3", "ttcnpp"],
      load() {
        return z(() => import("./ttcn-a4846d83.js"), [], import.meta.url).then((t) => J(t.ttcn));
      },
    }),
    j.of({
      name: "TTCN_CFG",
      extensions: ["cfg"],
      load() {
        return z(() => import("./ttcn-cfg-0c96bcc1.js"), [], import.meta.url).then((t) => J(t.ttcnCfg));
      },
    }),
    j.of({
      name: "Turtle",
      extensions: ["ttl"],
      load() {
        return z(() => import("./turtle-b550492d.js"), [], import.meta.url).then((t) => J(t.turtle));
      },
    }),
    j.of({
      name: "Web IDL",
      extensions: ["webidl"],
      load() {
        return z(() => import("./webidl-beade871.js"), [], import.meta.url).then((t) => J(t.webIDL));
      },
    }),
    j.of({
      name: "VB.NET",
      extensions: ["vb"],
      load() {
        return z(() => import("./vb-e9655ff4.js"), [], import.meta.url).then((t) => J(t.vb));
      },
    }),
    j.of({
      name: "VBScript",
      extensions: ["vbs"],
      load() {
        return z(() => import("./vbscript-e62417ba.js"), [], import.meta.url).then((t) => J(t.vbScript));
      },
    }),
    j.of({
      name: "Velocity",
      extensions: ["vtl"],
      load() {
        return z(() => import("./velocity-5bdd1b6a.js"), [], import.meta.url).then((t) => J(t.velocity));
      },
    }),
    j.of({
      name: "Verilog",
      extensions: ["v"],
      load() {
        return z(() => import("./verilog-701759f4.js"), [], import.meta.url).then((t) => J(t.verilog));
      },
    }),
    j.of({
      name: "VHDL",
      extensions: ["vhd", "vhdl"],
      load() {
        return z(() => import("./vhdl-288f0dde.js"), [], import.meta.url).then((t) => J(t.vhdl));
      },
    }),
    j.of({
      name: "XQuery",
      extensions: ["xy", "xquery"],
      load() {
        return z(() => import("./xquery-f004ff15.js"), [], import.meta.url).then((t) => J(t.xQuery));
      },
    }),
    j.of({
      name: "Yacas",
      extensions: ["ys"],
      load() {
        return z(() => import("./yacas-d031e2ab.js"), [], import.meta.url).then((t) => J(t.yacas));
      },
    }),
    j.of({
      name: "Z80",
      extensions: ["z80"],
      load() {
        return z(() => import("./z80-bb7f2654.js"), [], import.meta.url).then((t) => J(t.z80));
      },
    }),
    j.of({
      name: "MscGen",
      extensions: ["mscgen", "mscin", "msc"],
      load() {
        return z(() => import("./mscgen-96577242.js"), [], import.meta.url).then((t) => J(t.mscgen));
      },
    }),
    j.of({
      name: "Xù",
      extensions: ["xu"],
      load() {
        return z(() => import("./mscgen-96577242.js"), [], import.meta.url).then((t) => J(t.xu));
      },
    }),
    j.of({
      name: "MsGenny",
      extensions: ["msgenny"],
      load() {
        return z(() => import("./mscgen-96577242.js"), [], import.meta.url).then((t) => J(t.msgenny));
      },
    }),
    j.of({
      name: "Vue",
      extensions: ["vue"],
      load() {
        return z(
          () => import("./index-2c6b9650.js"),
          [
            "./index-2c6b9650.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.vue());
      },
    }),
    j.of({
      name: "Angular Template",
      load() {
        return z(
          () => import("./index-58f0aa7a.js"),
          [
            "./index-58f0aa7a.js",
            "./index-7c191284.js",
            "./useResultBannerController-cd95b20f.js",
            "./apis-0c1c184f.js",
            "./iframe-35b6cbe2.js",
            "./useAction-f9651b8b.js",
            "./jsx-runtime-69eee039.js",
            "./index-363833c6.js",
            "./index-f0f16ed8.js",
            "./extends-98964cd2.js",
            "./dateTimeUtils-a817f99d.js",
          ],
          import.meta.url
        ).then((t) => t.angular());
      },
    }),
  ],
  nT = "#2e3440",
  kS = "#3b4252",
  rT = "#434c5e",
  id = "#4c566a",
  iT = "#e5e9f0",
  gx = "#eceff4",
  k1 = "#8fbcbb",
  sT = "#88c0d0",
  ppe = "#81a1c1",
  jr = "#5e81ac",
  mpe = "#bf616a",
  _a = "#d08770",
  C1 = "#ebcb8b",
  oT = "#a3be8c",
  gpe = "#b48ead",
  aT = "#d30102",
  CS = gx,
  _1 = CS,
  Ope = "#ffffff",
  E1 = kS,
  vpe = CS,
  lT = kS,
  xpe = re.theme(
    {
      "&": { color: nT, backgroundColor: Ope },
      ".cm-content": { caretColor: lT },
      ".cm-cursor, .cm-dropCursor": { borderLeftColor: lT },
      "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: vpe },
      ".cm-panels": { backgroundColor: CS, color: id },
      ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
      ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
      ".cm-searchMatch": { backgroundColor: "#72a1ff59", outline: `1px solid ${id}` },
      ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: iT },
      ".cm-activeLine": { backgroundColor: _1 },
      ".cm-selectionMatch": { backgroundColor: iT },
      "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": { outline: `1px solid ${id}` },
      "&.cm-focused .cm-matchingBracket": { backgroundColor: gx },
      ".cm-gutters": { backgroundColor: gx, color: nT, border: "none" },
      ".cm-activeLineGutter": { backgroundColor: _1 },
      ".cm-foldPlaceholder": { backgroundColor: "transparent", border: "none", color: "#ddd" },
      ".cm-tooltip": { border: "none", backgroundColor: E1 },
      ".cm-tooltip .cm-tooltip-arrow:before": { borderTopColor: "transparent", borderBottomColor: "transparent" },
      ".cm-tooltip .cm-tooltip-arrow:after": { borderTopColor: E1, borderBottomColor: E1 },
      ".cm-tooltip-autocomplete": { "& > ul > li[aria-selected]": { backgroundColor: _1, color: id } },
    },
    { dark: !1 }
  ),
  bpe = ac.define([
    { tag: R.keyword, color: jr },
    { tag: [R.name, R.deleted, R.character, R.propertyName, R.macroName], color: _a },
    { tag: [R.variableName], color: _a },
    { tag: [R.function(R.variableName)], color: jr },
    { tag: [R.labelName], color: ppe },
    { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: jr },
    { tag: [R.definition(R.name), R.separator], color: oT },
    { tag: [R.brace], color: k1 },
    { tag: [R.annotation], color: aT },
    { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: sT },
    { tag: [R.typeName, R.className], color: C1 },
    { tag: [R.operator, R.operatorKeyword], color: oT },
    { tag: [R.tagName], color: gpe },
    { tag: [R.squareBracket], color: mpe },
    { tag: [R.angleBracket], color: _a },
    { tag: [R.attributeName], color: C1 },
    { tag: [R.regexp], color: jr },
    { tag: [R.quote], color: kS },
    { tag: [R.string], color: _a },
    { tag: R.link, color: k1, textDecoration: "underline", textUnderlinePosition: "under" },
    { tag: [R.url, R.escape, R.special(R.string)], color: _a },
    { tag: [R.meta], color: sT },
    { tag: [R.comment], color: rT, fontStyle: "italic" },
    { tag: R.strong, fontWeight: "bold", color: jr },
    { tag: R.emphasis, fontStyle: "italic", color: jr },
    { tag: R.strikethrough, textDecoration: "line-through" },
    { tag: R.heading, fontWeight: "bold", color: jr },
    { tag: R.special(R.heading1), fontWeight: "bold", color: jr },
    { tag: R.heading1, fontWeight: "bold", color: jr },
    { tag: [R.heading2, R.heading3, R.heading4], fontWeight: "bold", color: jr },
    { tag: [R.heading5, R.heading6], color: jr },
    { tag: [R.atom, R.bool, R.special(R.variableName)], color: _a },
    { tag: [R.processingInstruction, R.inserted], color: k1 },
    { tag: [R.contentSeparator], color: C1 },
    { tag: R.invalid, color: rT, borderBottom: `1px dotted ${aT}` },
  ]),
  kI = [xpe, jw(bpe)];
function St() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1,
    n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n)
      if (Object.prototype.hasOwnProperty.call(n, r)) {
        var i = n[r];
        typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++) CI(t, arguments[e]);
  return t;
}
function CI(t, e) {
  if (typeof e == "string") t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null) t.appendChild(e);
    else if (Array.isArray(e)) for (var n = 0; n < e.length; n++) CI(t, e[n]);
    else throw new RangeError("Unsupported child node: " + e);
}
const cT = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class Rl {
  constructor(e, n, r = 0, i = e.length, s, o) {
    (this.test = o),
      (this.value = { from: 0, to: 0 }),
      (this.done = !1),
      (this.matches = []),
      (this.buffer = ""),
      (this.bufferPos = 0),
      (this.iter = e.iterRange(r, i)),
      (this.bufferStart = r),
      (this.normalize = s ? (a) => s(cT(a)) : cT),
      (this.query = this.normalize(n));
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (((this.bufferStart += this.buffer.length), this.iter.next(), this.iter.done)) return -1;
      (this.bufferPos = 0), (this.buffer = this.iter.value);
    }
    return mn(this.buffer, this.bufferPos);
  }
  next() {
    for (; this.matches.length; ) this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (;;) {
      let e = this.peek();
      if (e < 0) return (this.done = !0), this;
      let n = Sw(e),
        r = this.bufferStart + this.bufferPos;
      this.bufferPos += Pr(e);
      let i = this.normalize(n);
      for (let s = 0, o = r; ; s++) {
        let a = i.charCodeAt(s),
          l = this.match(a, o, this.bufferPos + this.bufferStart);
        if (s == i.length - 1) {
          if (l) return (this.value = l), this;
          break;
        }
        o == r && s < n.length && n.charCodeAt(s) == a && o++;
      }
    }
  }
  match(e, n, r) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s],
        a = !1;
      this.query.charCodeAt(o) == e &&
        (o == this.query.length - 1 ? (i = { from: this.matches[s + 1], to: r }) : (this.matches[s]++, (a = !0))),
        a || (this.matches.splice(s, 2), (s -= 2));
    }
    return (
      this.query.charCodeAt(0) == e && (this.query.length == 1 ? (i = { from: n, to: r }) : this.matches.push(1, n)),
      i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null),
      i
    );
  }
}
typeof Symbol < "u" &&
  (Rl.prototype[Symbol.iterator] = function () {
    return this;
  });
const _I = { from: -1, to: -1, match: /.*/.exec("") },
  _S = "gm" + (/x/.unicode == null ? "" : "u");
class EI {
  constructor(e, n, r, i = 0, s = e.length) {
    if (((this.text = e), (this.to = s), (this.curLine = ""), (this.done = !1), (this.value = _I), /\\[sWDnr]|\n|\r|\[\^/.test(n)))
      return new TI(e, n, r, i, s);
    (this.re = new RegExp(n, _S + (r != null && r.ignoreCase ? "i" : ""))),
      (this.test = r == null ? void 0 : r.test),
      (this.iter = e.iter());
    let o = e.lineAt(i);
    (this.curLineStart = o.from), (this.matchPos = im(e, i)), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e),
      this.iter.lineBreak
        ? (this.curLine = "")
        : ((this.curLine = this.iter.value),
          this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)),
          this.iter.next());
  }
  nextLine() {
    (this.curLineStart = this.curLineStart + this.curLine.length + 1), this.curLineStart > this.to ? (this.curLine = "") : this.getLine(0);
  }
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index,
          i = r + n[0].length;
        if (
          ((this.matchPos = im(this.text, i + (r == i ? 1 : 0))),
          r == this.curLineStart + this.curLine.length && this.nextLine(),
          (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
        )
          return (this.value = { from: r, to: i, match: n }), this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) this.nextLine(), (e = 0);
      else return (this.done = !0), this;
    }
  }
}
const T1 = new WeakMap();
class hl {
  constructor(e, n) {
    (this.from = e), (this.text = n);
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, r) {
    let i = T1.get(e);
    if (!i || i.from >= r || i.to <= n) {
      let a = new hl(n, e.sliceString(n, r));
      return T1.set(e, a), a;
    }
    if (i.from == n && i.to == r) return i;
    let { text: s, from: o } = i;
    return (
      o > n && ((s = e.sliceString(n, o) + s), (o = n)),
      i.to < r && (s += e.sliceString(i.to, r)),
      T1.set(e, new hl(o, s)),
      new hl(n, s.slice(n - o, r - o))
    );
  }
}
class TI {
  constructor(e, n, r, i, s) {
    (this.text = e),
      (this.to = s),
      (this.done = !1),
      (this.value = _I),
      (this.matchPos = im(e, i)),
      (this.re = new RegExp(n, _S + (r != null && r.ignoreCase ? "i" : ""))),
      (this.test = r == null ? void 0 : r.test),
      (this.flat = hl.get(e, i, this.chunkEnd(i + 5e3)));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (;;) {
      let e = (this.re.lastIndex = this.matchPos - this.flat.from),
        n = this.re.exec(this.flat.text);
      if ((n && !n[0] && n.index == e && ((this.re.lastIndex = e + 1), (n = this.re.exec(this.flat.text))), n)) {
        let r = this.flat.from + n.index,
          i = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
          return (this.value = { from: r, to: i, match: n }), (this.matchPos = im(this.text, i + (r == i ? 1 : 0))), this;
      }
      if (this.flat.to == this.to) return (this.done = !0), this;
      this.flat = hl.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" &&
  (EI.prototype[Symbol.iterator] = TI.prototype[Symbol.iterator] =
    function () {
      return this;
    });
function ype(t) {
  try {
    return new RegExp(t, _S), !0;
  } catch {
    return !1;
  }
}
function im(t, e) {
  if (e >= t.length) return e;
  let n = t.lineAt(e),
    r;
  for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; ) e++;
  return e;
}
function Ox(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number),
    n = St("input", { class: "cm-textfield", name: "line", value: e }),
    r = St(
      "form",
      {
        class: "cm-gotoLine",
        onkeydown: (s) => {
          s.keyCode == 27
            ? (s.preventDefault(), t.dispatch({ effects: sm.of(!1) }), t.focus())
            : s.keyCode == 13 && (s.preventDefault(), i());
        },
        onsubmit: (s) => {
          s.preventDefault(), i();
        },
      },
      St("label", t.state.phrase("Go to line"), ": ", n),
      " ",
      St("button", { class: "cm-button", type: "submit" }, t.state.phrase("go"))
    );
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!s) return;
    let { state: o } = t,
      a = o.doc.lineAt(o.selection.main.head),
      [, l, c, u, h] = s,
      f = u ? +u.slice(1) : 0,
      d = c ? +c : a.number;
    if (c && h) {
      let O = d / 100;
      l && (O = O * (l == "-" ? -1 : 1) + a.number / o.doc.lines), (d = Math.round(o.doc.lines * O));
    } else c && l && (d = d * (l == "-" ? -1 : 1) + a.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))),
      m = X.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    t.dispatch({ effects: [sm.of(!1), re.scrollIntoView(m.from, { y: "center" })], selection: m }), t.focus();
  }
  return { dom: r };
}
const sm = Ae.define(),
  uT = zt.define({
    create() {
      return !0;
    },
    update(t, e) {
      for (let n of e.effects) n.is(sm) && (t = n.value);
      return t;
    },
    provide: (t) => Xu.from(t, (e) => (e ? Ox : null)),
  }),
  wpe = (t) => {
    let e = Uu(t, Ox);
    if (!e) {
      let n = [sm.of(!0)];
      t.state.field(uT, !1) == null && n.push(Ae.appendConfig.of([uT, Spe])), t.dispatch({ effects: n }), (e = Uu(t, Ox));
    }
    return e && e.dom.querySelector("input").select(), !0;
  },
  Spe = re.baseTheme({ ".cm-panel.cm-gotoLine": { padding: "2px 6px 4px", "& label": { fontSize: "80%" } } }),
  kpe = { highlightWordAroundCursor: !1, minSelectionLength: 1, maxMatches: 100, wholeWords: !1 },
  PI = ye.define({
    combine(t) {
      return Vi(t, kpe, { highlightWordAroundCursor: (e, n) => e || n, minSelectionLength: Math.min, maxMatches: Math.min });
    },
  });
function Cpe(t) {
  let e = [Ape, Ppe];
  return t && e.push(PI.of(t)), e;
}
const _pe = ge.mark({ class: "cm-selectionMatch" }),
  Epe = ge.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function hT(t, e, n, r) {
  return (n == 0 || t(e.sliceDoc(n - 1, n)) != Nt.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != Nt.Word);
}
function Tpe(t, e, n, r) {
  return t(e.sliceDoc(n, n + 1)) == Nt.Word && t(e.sliceDoc(r - 1, r)) == Nt.Word;
}
const Ppe = Dt.fromClass(
    class {
      constructor(t) {
        this.decorations = this.getDeco(t);
      }
      update(t) {
        (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
      }
      getDeco(t) {
        let e = t.state.facet(PI),
          { state: n } = t,
          r = n.selection;
        if (r.ranges.length > 1) return ge.none;
        let i = r.main,
          s,
          o = null;
        if (i.empty) {
          if (!e.highlightWordAroundCursor) return ge.none;
          let l = n.wordAt(i.head);
          if (!l) return ge.none;
          (o = n.charCategorizer(i.head)), (s = n.sliceDoc(l.from, l.to));
        } else {
          let l = i.to - i.from;
          if (l < e.minSelectionLength || l > 200) return ge.none;
          if (e.wholeWords) {
            if (((s = n.sliceDoc(i.from, i.to)), (o = n.charCategorizer(i.head)), !(hT(o, n, i.from, i.to) && Tpe(o, n, i.from, i.to))))
              return ge.none;
          } else if (((s = n.sliceDoc(i.from, i.to)), !s)) return ge.none;
        }
        let a = [];
        for (let l of t.visibleRanges) {
          let c = new Rl(n.doc, s, l.from, l.to);
          for (; !c.next().done; ) {
            let { from: u, to: h } = c.value;
            if (
              (!o || hT(o, n, u, h)) &&
              (i.empty && u <= i.from && h >= i.to ? a.push(Epe.range(u, h)) : (u >= i.to || h <= i.from) && a.push(_pe.range(u, h)),
              a.length > e.maxMatches)
            )
              return ge.none;
          }
        }
        return ge.set(a);
      }
    },
    { decorations: (t) => t.decorations }
  ),
  Ape = re.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" },
  }),
  $pe = ({ state: t, dispatch: e }) => {
    let { selection: n } = t,
      r = X.create(
        n.ranges.map((i) => t.wordAt(i.head) || X.cursor(i.head)),
        n.mainIndex
      );
    return r.eq(n) ? !1 : (e(t.update({ selection: r })), !0);
  };
function Rpe(t, e) {
  let { main: n, ranges: r } = t.selection,
    i = t.wordAt(n.head),
    s = i && i.from == n.from && i.to == n.to;
  for (let o = !1, a = new Rl(t.doc, e, r[r.length - 1].to); ; )
    if ((a.next(), a.done)) {
      if (o) return null;
      (a = new Rl(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1))), (o = !0);
    } else {
      if (o && r.some((l) => l.from == a.value.from)) continue;
      if (s) {
        let l = t.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to) continue;
      }
      return a.value;
    }
}
const Ipe = ({ state: t, dispatch: e }) => {
    let { ranges: n } = t.selection;
    if (n.some((s) => s.from === s.to)) return $pe({ state: t, dispatch: e });
    let r = t.sliceDoc(n[0].from, n[0].to);
    if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != r)) return !1;
    let i = Rpe(t, r);
    return i ? (e(t.update({ selection: t.selection.addRange(X.range(i.from, i.to), !1), effects: re.scrollIntoView(i.to) })), !0) : !1;
  },
  uc = ye.define({
    combine(t) {
      return Vi(t, {
        top: !1,
        caseSensitive: !1,
        literal: !1,
        regexp: !1,
        wholeWord: !1,
        createPanel: (e) => new Wpe(e),
        scrollToMatch: (e) => re.scrollIntoView(e),
      });
    },
  });
class AI {
  constructor(e) {
    (this.search = e.search),
      (this.caseSensitive = !!e.caseSensitive),
      (this.literal = !!e.literal),
      (this.regexp = !!e.regexp),
      (this.replace = e.replace || ""),
      (this.valid = !!this.search && (!this.regexp || ype(this.search))),
      (this.unquoted = this.unquote(this.search)),
      (this.wholeWord = !!e.wholeWord);
  }
  unquote(e) {
    return this.literal
      ? e
      : e.replace(/\\([nrt\\])/g, (n, r) =>
          r == "n"
            ? `
`
            : r == "r"
            ? "\r"
            : r == "t"
            ? "	"
            : "\\"
        );
  }
  eq(e) {
    return (
      this.search == e.search &&
      this.replace == e.replace &&
      this.caseSensitive == e.caseSensitive &&
      this.regexp == e.regexp &&
      this.wholeWord == e.wholeWord
    );
  }
  create() {
    return this.regexp ? new Dpe(this) : new Lpe(this);
  }
  getCursor(e, n = 0, r) {
    let i = e.doc ? e : Qe.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? Ma(this, i, n, r) : La(this, i, n, r);
  }
}
class $I {
  constructor(e) {
    this.spec = e;
  }
}
function La(t, e, n, r) {
  return new Rl(
    e.doc,
    t.unquoted,
    n,
    r,
    t.caseSensitive ? void 0 : (i) => i.toLowerCase(),
    t.wholeWord ? Npe(e.doc, e.charCategorizer(e.selection.main.head)) : void 0
  );
}
function Npe(t, e) {
  return (n, r, i, s) => (
    (s > n || s + i.length < r) && ((s = Math.max(0, n - 2)), (i = t.sliceString(s, Math.min(t.length, r + 2)))),
    (e(om(i, n - s)) != Nt.Word || e(am(i, n - s)) != Nt.Word) && (e(am(i, r - s)) != Nt.Word || e(om(i, r - s)) != Nt.Word)
  );
}
class Lpe extends $I {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, r) {
    let i = La(this.spec, e, r, e.doc.length).nextOverlapping();
    return i.done && (i = La(this.spec, e, 0, n).nextOverlapping()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = r; ; ) {
      let s = Math.max(n, i - 1e4 - this.spec.unquoted.length),
        o = La(this.spec, e, s, i),
        a = null;
      for (; !o.nextOverlapping().done; ) a = o.value;
      if (a) return a;
      if (s == n) return null;
      i -= 1e4;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let r = La(this.spec, e, 0, e.doc.length),
      i = [];
    for (; !r.next().done; ) {
      if (i.length >= n) return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let s = La(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; ) i(s.value.from, s.value.to);
  }
}
function Ma(t, e, n, r) {
  return new EI(
    e.doc,
    t.search,
    { ignoreCase: !t.caseSensitive, test: t.wholeWord ? Mpe(e.charCategorizer(e.selection.main.head)) : void 0 },
    n,
    r
  );
}
function om(t, e) {
  return t.slice(xn(t, e, !1), e);
}
function am(t, e) {
  return t.slice(e, xn(t, e));
}
function Mpe(t) {
  return (e, n, r) =>
    !r[0].length ||
    ((t(om(r.input, r.index)) != Nt.Word || t(am(r.input, r.index)) != Nt.Word) &&
      (t(am(r.input, r.index + r[0].length)) != Nt.Word || t(om(r.input, r.index + r[0].length)) != Nt.Word));
}
class Dpe extends $I {
  nextMatch(e, n, r) {
    let i = Ma(this.spec, e, r, e.doc.length).next();
    return i.done && (i = Ma(this.spec, e, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(n, r - i * 1e4),
        o = Ma(this.spec, e, s, r),
        a = null;
      for (; !o.next().done; ) a = o.value;
      if (a && (s == n || a.from > s + 10)) return a;
      if (s == n) return null;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec
      .unquote(this.spec.replace)
      .replace(/\$([$&\d+])/g, (n, r) => (r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : n));
  }
  matchAll(e, n) {
    let r = Ma(this.spec, e, 0, e.doc.length),
      i = [];
    for (; !r.next().done; ) {
      if (i.length >= n) return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let s = Ma(this.spec, e, Math.max(0, n - 250), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; ) i(s.value.from, s.value.to);
  }
}
const ah = Ae.define(),
  ES = Ae.define(),
  qs = zt.define({
    create(t) {
      return new P1(vx(t).create(), null);
    },
    update(t, e) {
      for (let n of e.effects) n.is(ah) ? (t = new P1(n.value.create(), t.panel)) : n.is(ES) && (t = new P1(t.query, n.value ? TS : null));
      return t;
    },
    provide: (t) => Xu.from(t, (e) => e.panel),
  });
class P1 {
  constructor(e, n) {
    (this.query = e), (this.panel = n);
  }
}
const Qpe = ge.mark({ class: "cm-searchMatch" }),
  Fpe = ge.mark({ class: "cm-searchMatch cm-searchMatch-selected" }),
  Vpe = Dt.fromClass(
    class {
      constructor(t) {
        (this.view = t), (this.decorations = this.highlight(t.state.field(qs)));
      }
      update(t) {
        let e = t.state.field(qs);
        (e != t.startState.field(qs) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
      }
      highlight({ query: t, panel: e }) {
        if (!e || !t.spec.valid) return ge.none;
        let { view: n } = this,
          r = new Or();
        for (let i = 0, s = n.visibleRanges, o = s.length; i < o; i++) {
          let { from: a, to: l } = s[i];
          for (; i < o - 1 && l > s[i + 1].from - 2 * 250; ) l = s[++i].to;
          t.highlight(n.state, a, l, (c, u) => {
            let h = n.state.selection.ranges.some((f) => f.from == c && f.to == u);
            r.add(c, u, h ? Fpe : Qpe);
          });
        }
        return r.finish();
      }
    },
    { decorations: (t) => t.decorations }
  );
function uf(t) {
  return (e) => {
    let n = e.state.field(qs, !1);
    return n && n.query.spec.valid ? t(e, n) : NI(e);
  };
}
const lm = uf((t, { query: e }) => {
    let { to: n } = t.state.selection.main,
      r = e.nextMatch(t.state, n, n);
    if (!r) return !1;
    let i = X.single(r.from, r.to),
      s = t.state.facet(uc);
    return t.dispatch({ selection: i, effects: [PS(t, r), s.scrollToMatch(i.main, t)], userEvent: "select.search" }), II(t), !0;
  }),
  cm = uf((t, { query: e }) => {
    let { state: n } = t,
      { from: r } = n.selection.main,
      i = e.prevMatch(n, r, r);
    if (!i) return !1;
    let s = X.single(i.from, i.to),
      o = t.state.facet(uc);
    return t.dispatch({ selection: s, effects: [PS(t, i), o.scrollToMatch(s.main, t)], userEvent: "select.search" }), II(t), !0;
  }),
  Bpe = uf((t, { query: e }) => {
    let n = e.matchAll(t.state, 1e3);
    return !n || !n.length
      ? !1
      : (t.dispatch({ selection: X.create(n.map((r) => X.range(r.from, r.to))), userEvent: "select.search.matches" }), !0);
  }),
  jpe = ({ state: t, dispatch: e }) => {
    let n = t.selection;
    if (n.ranges.length > 1 || n.main.empty) return !1;
    let { from: r, to: i } = n.main,
      s = [],
      o = 0;
    for (let a = new Rl(t.doc, t.sliceDoc(r, i)); !a.next().done; ) {
      if (s.length > 1e3) return !1;
      a.value.from == r && (o = s.length), s.push(X.range(a.value.from, a.value.to));
    }
    return e(t.update({ selection: X.create(s, o), userEvent: "select.search.matches" })), !0;
  },
  fT = uf((t, { query: e }) => {
    let { state: n } = t,
      { from: r, to: i } = n.selection.main;
    if (n.readOnly) return !1;
    let s = e.nextMatch(n, r, r);
    if (!s) return !1;
    let o = [],
      a,
      l,
      c = [];
    if (
      (s.from == r &&
        s.to == i &&
        ((l = n.toText(e.getReplacement(s))),
        o.push({ from: s.from, to: s.to, insert: l }),
        (s = e.nextMatch(n, s.from, s.to)),
        c.push(re.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))),
      s)
    ) {
      let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - l.length;
      (a = X.single(s.from - u, s.to - u)), c.push(PS(t, s)), c.push(n.facet(uc).scrollToMatch(a.main, t));
    }
    return t.dispatch({ changes: o, selection: a, effects: c, userEvent: "input.replace" }), !0;
  }),
  Zpe = uf((t, { query: e }) => {
    if (t.state.readOnly) return !1;
    let n = e.matchAll(t.state, 1e9).map((i) => {
      let { from: s, to: o } = i;
      return { from: s, to: o, insert: e.getReplacement(i) };
    });
    if (!n.length) return !1;
    let r = t.state.phrase("replaced $ matches", n.length) + ".";
    return t.dispatch({ changes: n, effects: re.announce.of(r), userEvent: "input.replace.all" }), !0;
  });
function TS(t) {
  return t.state.facet(uc).createPanel(t);
}
function vx(t, e) {
  var n, r, i, s, o;
  let a = t.selection.main,
    l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !l) return e;
  let c = t.facet(uc);
  return new AI({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord,
  });
}
function RI(t) {
  let e = Uu(t, TS);
  return e && e.dom.querySelector("[main-field]");
}
function II(t) {
  let e = RI(t);
  e && e == t.root.activeElement && e.select();
}
const NI = (t) => {
    let e = t.state.field(qs, !1);
    if (e && e.panel) {
      let n = RI(t);
      if (n && n != t.root.activeElement) {
        let r = vx(t.state, e.query.spec);
        r.valid && t.dispatch({ effects: ah.of(r) }), n.focus(), n.select();
      }
    } else t.dispatch({ effects: [ES.of(!0), e ? ah.of(vx(t.state, e.query.spec)) : Ae.appendConfig.of(Xpe)] });
    return !0;
  },
  LI = (t) => {
    let e = t.state.field(qs, !1);
    if (!e || !e.panel) return !1;
    let n = Uu(t, TS);
    return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: ES.of(!1) }), !0;
  },
  zpe = [
    { key: "Mod-f", run: NI, scope: "editor search-panel" },
    { key: "F3", run: lm, shift: cm, scope: "editor search-panel", preventDefault: !0 },
    { key: "Mod-g", run: lm, shift: cm, scope: "editor search-panel", preventDefault: !0 },
    { key: "Escape", run: LI, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: jpe },
    { key: "Mod-Alt-g", run: wpe },
    { key: "Mod-d", run: Ipe, preventDefault: !0 },
  ];
class Wpe {
  constructor(e) {
    this.view = e;
    let n = (this.query = e.state.field(qs).query.spec);
    (this.commit = this.commit.bind(this)),
      (this.searchField = St("input", {
        value: n.search,
        placeholder: cr(e, "Find"),
        "aria-label": cr(e, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit,
      })),
      (this.replaceField = St("input", {
        value: n.replace,
        placeholder: cr(e, "Replace"),
        "aria-label": cr(e, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit,
      })),
      (this.caseField = St("input", { type: "checkbox", name: "case", form: "", checked: n.caseSensitive, onchange: this.commit })),
      (this.reField = St("input", { type: "checkbox", name: "re", form: "", checked: n.regexp, onchange: this.commit })),
      (this.wordField = St("input", { type: "checkbox", name: "word", form: "", checked: n.wholeWord, onchange: this.commit }));
    function r(i, s, o) {
      return St("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = St("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => lm(e), [cr(e, "next")]),
      r("prev", () => cm(e), [cr(e, "previous")]),
      r("select", () => Bpe(e), [cr(e, "all")]),
      St("label", null, [this.caseField, cr(e, "match case")]),
      St("label", null, [this.reField, cr(e, "regexp")]),
      St("label", null, [this.wordField, cr(e, "by word")]),
      ...(e.state.readOnly
        ? []
        : [
            St("br"),
            this.replaceField,
            r("replace", () => fT(e), [cr(e, "replace")]),
            r("replaceAll", () => Zpe(e), [cr(e, "replace all")]),
          ]),
      St("button", { name: "close", onclick: () => LI(e), "aria-label": cr(e, "close"), type: "button" }, ["×"]),
    ]);
  }
  commit() {
    let e = new AI({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value,
    });
    e.eq(this.query) || ((this.query = e), this.view.dispatch({ effects: ah.of(e) }));
  }
  keydown(e) {
    wse(this.view, e, "search-panel")
      ? e.preventDefault()
      : e.keyCode == 13 && e.target == this.searchField
      ? (e.preventDefault(), (e.shiftKey ? cm : lm)(this.view))
      : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), fT(this.view));
  }
  update(e) {
    for (let n of e.transactions) for (let r of n.effects) r.is(ah) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    (this.query = e),
      (this.searchField.value = e.search),
      (this.replaceField.value = e.replace),
      (this.caseField.checked = e.caseSensitive),
      (this.reField.checked = e.regexp),
      (this.wordField.checked = e.wholeWord);
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(uc).top;
  }
}
function cr(t, e) {
  return t.state.phrase(e);
}
const sd = 30,
  od = /[\s\.,:;?!]/;
function PS(t, { from: e, to: n }) {
  let r = t.state.doc.lineAt(e),
    i = t.state.doc.lineAt(n).to,
    s = Math.max(r.from, e - sd),
    o = Math.min(i, n + sd),
    a = t.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let l = 0; l < sd; l++)
      if (!od.test(a[l + 1]) && od.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != i) {
    for (let l = a.length - 1; l > a.length - sd; l--)
      if (!od.test(a[l - 1]) && od.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return re.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${r.number}.`);
}
const Upe = re.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0,
      },
      "& input, & button, & label": { margin: ".2em .6em .2em 0" },
      "& input[type=checkbox]": { marginRight: ".2em" },
      "& label": { fontSize: "80%", whiteSpace: "pre" },
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" },
  }),
  Xpe = [qs, ai.low(Vpe), Upe];
class Hpe {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.diagnostic = r);
  }
}
class $o {
  constructor(e, n, r) {
    (this.diagnostics = e), (this.panel = n), (this.selected = r);
  }
  static init(e, n, r) {
    let i = e,
      s = r.facet(lh).markerFilter;
    s && (i = s(i, r));
    let o = ge.set(
      i.map((a) =>
        a.from == a.to || (a.from == a.to - 1 && r.doc.lineAt(a.from).to == a.from)
          ? ge.widget({ widget: new rme(a), diagnostic: a }).range(a.from)
          : ge
              .mark({
                attributes: { class: "cm-lintRange cm-lintRange-" + a.severity + (a.markClass ? " " + a.markClass : "") },
                diagnostic: a,
              })
              .range(a.from, a.to)
      ),
      !0
    );
    return new $o(o, n, Il(o));
  }
}
function Il(t, e = null, n = 0) {
  let r = null;
  return (
    t.between(n, 1e9, (i, s, { spec: o }) => {
      if (!(e && o.diagnostic != e)) return (r = new Hpe(i, s, o.diagnostic)), !1;
    }),
    r
  );
}
function qpe(t, e) {
  let n = e.pos,
    r = e.end || n,
    i = t.state.facet(lh).hideOn(t, n, r);
  if (i != null) return i;
  let s = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((o) => o.is(MI)) || t.changes.touchesRange(s.from, Math.max(s.to, r)));
}
function Ype(t, e) {
  return t.field(gr, !1) ? e : e.concat(Ae.appendConfig.of(ome));
}
const MI = Ae.define(),
  AS = Ae.define(),
  DI = Ae.define(),
  gr = zt.define({
    create() {
      return new $o(ge.none, null, null);
    },
    update(t, e) {
      if (e.docChanged && t.diagnostics.size) {
        let n = t.diagnostics.map(e.changes),
          r = null,
          i = t.panel;
        if (t.selected) {
          let s = e.changes.mapPos(t.selected.from, 1);
          r = Il(n, t.selected.diagnostic, s) || Il(n, null, s);
        }
        !n.size && i && e.state.facet(lh).autoPanel && (i = null), (t = new $o(n, i, r));
      }
      for (let n of e.effects)
        if (n.is(MI)) {
          let r = e.state.facet(lh).autoPanel ? (n.value.length ? ch.open : null) : t.panel;
          t = $o.init(n.value, r, e.state);
        } else
          n.is(AS)
            ? (t = new $o(t.diagnostics, n.value ? ch.open : null, t.selected))
            : n.is(DI) && (t = new $o(t.diagnostics, t.panel, n.value));
      return t;
    },
    provide: (t) => [Xu.from(t, (e) => e.panel), re.decorations.from(t, (e) => e.diagnostics)],
  }),
  Gpe = ge.mark({ class: "cm-lintRange cm-lintRange-active" });
function Jpe(t, e, n) {
  let { diagnostics: r } = t.state.field(gr),
    i = [],
    s = 2e8,
    o = 0;
  r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (l, c, { spec: u }) => {
    e >= l &&
      e <= c &&
      (l == c || ((e > l || n > 0) && (e < c || n < 0))) &&
      (i.push(u.diagnostic), (s = Math.min(l, s)), (o = Math.max(c, o)));
  });
  let a = t.state.facet(lh).tooltipFilter;
  return (
    a && (i = a(i, t.state)),
    i.length
      ? {
          pos: s,
          end: o,
          above: t.state.doc.lineAt(s).to < o,
          create() {
            return { dom: Kpe(t, i) };
          },
        }
      : null
  );
}
function Kpe(t, e) {
  return St(
    "ul",
    { class: "cm-tooltip-lint" },
    e.map((n) => FI(t, n, !1))
  );
}
const eme = (t) => {
    let e = t.state.field(gr, !1);
    (!e || !e.panel) && t.dispatch({ effects: Ype(t.state, [AS.of(!0)]) });
    let n = Uu(t, ch.open);
    return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
  },
  dT = (t) => {
    let e = t.state.field(gr, !1);
    return !e || !e.panel ? !1 : (t.dispatch({ effects: AS.of(!1) }), !0);
  },
  tme = (t) => {
    let e = t.state.field(gr, !1);
    if (!e) return !1;
    let n = t.state.selection.main,
      r = e.diagnostics.iter(n.to + 1);
    return !r.value && ((r = e.diagnostics.iter(0)), !r.value || (r.from == n.from && r.to == n.to))
      ? !1
      : (t.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
  },
  nme = [
    { key: "Mod-Shift-m", run: eme, preventDefault: !0 },
    { key: "F8", run: tme },
  ],
  lh = ye.define({
    combine(t) {
      return Object.assign(
        { sources: t.map((e) => e.source).filter((e) => e != null) },
        Vi(
          t.map((e) => e.config),
          { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null, hideOn: () => null },
          { needsRefresh: (e, n) => (e ? (n ? (r) => e(r) || n(r) : e) : n) }
        )
      );
    },
  });
function QI(t) {
  let e = [];
  if (t)
    e: for (let { name: n } of t) {
      for (let r = 0; r < n.length; r++) {
        let i = n[r];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function FI(t, e, n) {
  var r;
  let i = n ? QI(e.actions) : [];
  return St(
    "li",
    { class: "cm-diagnostic cm-diagnostic-" + e.severity },
    St("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message),
    (r = e.actions) === null || r === void 0
      ? void 0
      : r.map((s, o) => {
          let a = !1,
            l = (f) => {
              if ((f.preventDefault(), a)) return;
              a = !0;
              let d = Il(t.state.field(gr).diagnostics, e);
              d && s.apply(t, d.from, d.to);
            },
            { name: c } = s,
            u = i[o] ? c.indexOf(i[o]) : -1,
            h = u < 0 ? c : [c.slice(0, u), St("u", c.slice(u, u + 1)), c.slice(u + 1)];
          return St(
            "button",
            {
              type: "button",
              class: "cm-diagnosticAction",
              onclick: l,
              onmousedown: l,
              "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[o]})"`}.`,
            },
            h
          );
        }),
    e.source && St("div", { class: "cm-diagnosticSource" }, e.source)
  );
}
class rme extends li {
  constructor(e) {
    super(), (this.diagnostic = e);
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return St("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class pT {
  constructor(e, n) {
    (this.diagnostic = n),
      (this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16)),
      (this.dom = FI(e, n, !0)),
      (this.dom.id = this.id),
      this.dom.setAttribute("role", "option");
  }
}
class ch {
  constructor(e) {
    (this.view = e), (this.items = []);
    let n = (i) => {
        if (i.keyCode == 27) dT(this.view), this.view.focus();
        else if (i.keyCode == 38 || i.keyCode == 33) this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        else if (i.keyCode == 40 || i.keyCode == 34) this.moveSelection((this.selectedIndex + 1) % this.items.length);
        else if (i.keyCode == 36) this.moveSelection(0);
        else if (i.keyCode == 35) this.moveSelection(this.items.length - 1);
        else if (i.keyCode == 13) this.view.focus();
        else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic: s } = this.items[this.selectedIndex],
            o = QI(s.actions);
          for (let a = 0; a < o.length; a++)
            if (o[a].toUpperCase().charCodeAt(0) == i.keyCode) {
              let l = Il(this.view.state.field(gr).diagnostics, s);
              l && s.actions[a].apply(e, l.from, l.to);
            }
        } else return;
        i.preventDefault();
      },
      r = (i) => {
        for (let s = 0; s < this.items.length; s++) this.items[s].dom.contains(i.target) && this.moveSelection(s);
      };
    (this.list = St("ul", { tabIndex: 0, role: "listbox", "aria-label": this.view.state.phrase("Diagnostics"), onkeydown: n, onclick: r })),
      (this.dom = St(
        "div",
        { class: "cm-panel-lint" },
        this.list,
        St("button", { type: "button", name: "close", "aria-label": this.view.state.phrase("close"), onclick: () => dT(this.view) }, "×")
      )),
      this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(gr).selected;
    if (!e) return -1;
    for (let n = 0; n < this.items.length; n++) if (this.items[n].diagnostic == e.diagnostic) return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(gr),
      r = 0,
      i = !1,
      s = null;
    for (
      e.between(0, this.view.state.doc.length, (o, a, { spec: l }) => {
        let c = -1,
          u;
        for (let h = r; h < this.items.length; h++)
          if (this.items[h].diagnostic == l.diagnostic) {
            c = h;
            break;
          }
        c < 0
          ? ((u = new pT(this.view, l.diagnostic)), this.items.splice(r, 0, u), (i = !0))
          : ((u = this.items[c]), c > r && (this.items.splice(r, c - r), (i = !0))),
          n && u.diagnostic == n.diagnostic
            ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), (s = u))
            : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"),
          r++;
      });
      r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0);

    )
      (i = !0), this.items.pop();
    this.items.length == 0 &&
      (this.items.push(new pT(this.view, { from: -1, to: -1, severity: "info", message: this.view.state.phrase("No diagnostics") })),
      (i = !0)),
      s
        ? (this.list.setAttribute("aria-activedescendant", s.id),
          this.view.requestMeasure({
            key: this,
            read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
            write: ({ sel: o, panel: a }) => {
              let l = a.height / this.list.offsetHeight;
              o.top < a.top
                ? (this.list.scrollTop -= (a.top - o.top) / l)
                : o.bottom > a.bottom && (this.list.scrollTop += (o.bottom - a.bottom) / l);
            },
          }))
        : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"),
      i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let r = e;
      (e = r.nextSibling), r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; ) n();
        e = r.dom.nextSibling;
      } else this.list.insertBefore(r.dom, e);
    for (; e; ) n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0) return;
    let n = this.view.state.field(gr),
      r = Il(n.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0, effects: DI.of(r) });
  }
  static open(e) {
    return new ch(e);
  }
}
function ime(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function ad(t) {
  return ime(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const sme = re.baseTheme({
    ".cm-diagnostic": { padding: "3px 6px 3px 8px", marginLeft: "-1px", display: "block", whiteSpace: "pre-wrap" },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer",
    },
    ".cm-diagnosticSource": { fontSize: "70%", opacity: 0.7 },
    ".cm-lintRange": { backgroundPosition: "left bottom", backgroundRepeat: "repeat-x", paddingBottom: "0.7px" },
    ".cm-lintRange-error": { backgroundImage: ad("#d11") },
    ".cm-lintRange-warning": { backgroundImage: ad("orange") },
    ".cm-lintRange-info": { backgroundImage: ad("#999") },
    ".cm-lintRange-hint": { backgroundImage: ad("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": { padding: 0, margin: 0 },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11",
      },
    },
    ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } },
    ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } },
    ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": { backgroundColor: "#ddd", "& u": { textDecoration: "underline" } },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText",
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0,
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0,
      },
    },
  }),
  ome = [
    gr,
    re.decorations.compute([gr], (t) => {
      let { selected: e, panel: n } = t.field(gr);
      return !e || !n || e.from == e.to ? ge.none : ge.set([Gpe.range(e.from, e.to)]);
    }),
    ooe(Jpe, { hideOn: qpe }),
    sme,
  ],
  VI = (() => [
    kg(),
    goe(),
    F4(),
    Z8(),
    oae(),
    Tse(),
    Ise(),
    Qe.allowMultipleSelections.of(!0),
    Hoe(),
    jw(uae, { fallback: !0 }),
    v8(),
    N8(),
    xle(),
    qse(),
    Jse(),
    V4(),
    Cpe(),
    ta.of([...D8, ...xR, ...zpe, ...X8, ...nae, ...F8, ...nme]),
  ])();
function mT(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
function ame(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function BI(...t) {
  return (e) => t.forEach((n) => ame(n, e));
}
function yr(...t) {
  return w.useCallback(BI(...t), t);
}
var $S = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(cme);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(xx, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(xx, { ...r, ref: e, children: n });
});
$S.displayName = "Slot";
var xx = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = hme(n);
    return w.cloneElement(n, { ...ume(r, n.props), ref: e ? BI(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
xx.displayName = "SlotClone";
var lme = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function cme(t) {
  return w.isValidElement(t) && t.type === lme;
}
function ume(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function hme(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var fme = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  Rn = fme.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? $S : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function dme(t, e) {
  t && os.flushSync(() => t.dispatchEvent(e));
}
var pme = "DismissableLayer",
  bx = "dismissableLayer.update",
  mme = "dismissableLayer.pointerDownOutside",
  gme = "dismissableLayer.focusOutside",
  gT,
  jI = w.createContext({ layers: new Set(), layersWithOutsidePointerEventsDisabled: new Set(), branches: new Set() }),
  ZI = w.forwardRef((t, e) => {
    const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: i,
        onFocusOutside: s,
        onInteractOutside: o,
        onDismiss: a,
        ...l
      } = t,
      c = w.useContext(jI),
      [u, h] = w.useState(null),
      f = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document),
      [, d] = w.useState({}),
      p = yr(e, (b) => h(b)),
      m = Array.from(c.layers),
      [O] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
      v = m.indexOf(O),
      g = u ? m.indexOf(u) : -1,
      x = c.layersWithOutsidePointerEventsDisabled.size > 0,
      y = g >= v,
      S = xme((b) => {
        const _ = b.target,
          T = [...c.branches].some((P) => P.contains(_));
        !y || T || (i == null || i(b), o == null || o(b), b.defaultPrevented || a == null || a());
      }, f),
      k = bme((b) => {
        const _ = b.target;
        [...c.branches].some((P) => P.contains(_)) || (s == null || s(b), o == null || o(b), b.defaultPrevented || a == null || a());
      }, f);
    return (
      _P((b) => {
        g === c.layers.size - 1 && (r == null || r(b), !b.defaultPrevented && a && (b.preventDefault(), a()));
      }, f),
      w.useEffect(() => {
        if (u)
          return (
            n &&
              (c.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((gT = f.body.style.pointerEvents), (f.body.style.pointerEvents = "none")),
              c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            OT(),
            () => {
              n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = gT);
            }
          );
      }, [u, f, n, c]),
      w.useEffect(
        () => () => {
          u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), OT());
        },
        [u, c]
      ),
      w.useEffect(() => {
        const b = () => d({});
        return document.addEventListener(bx, b), () => document.removeEventListener(bx, b);
      }, []),
      E.jsx(Rn.div, {
        ...l,
        ref: p,
        style: { pointerEvents: x ? (y ? "auto" : "none") : void 0, ...t.style },
        onFocusCapture: Ye(t.onFocusCapture, k.onFocusCapture),
        onBlurCapture: Ye(t.onBlurCapture, k.onBlurCapture),
        onPointerDownCapture: Ye(t.onPointerDownCapture, S.onPointerDownCapture),
      })
    );
  });
ZI.displayName = pme;
var Ome = "DismissableLayerBranch",
  vme = w.forwardRef((t, e) => {
    const n = w.useContext(jI),
      r = w.useRef(null),
      i = yr(e, r);
    return (
      w.useEffect(() => {
        const s = r.current;
        if (s)
          return (
            n.branches.add(s),
            () => {
              n.branches.delete(s);
            }
          );
      }, [n.branches]),
      E.jsx(Rn.div, { ...t, ref: i })
    );
  });
vme.displayName = Ome;
function xme(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = as(t),
    r = w.useRef(!1),
    i = w.useRef(() => {});
  return (
    w.useEffect(() => {
      const s = (a) => {
          if (a.target && !r.current) {
            let l = function () {
              zI(mme, n, c, { discrete: !0 });
            };
            const c = { originalEvent: a };
            a.pointerType === "touch"
              ? (e.removeEventListener("click", i.current), (i.current = l), e.addEventListener("click", i.current, { once: !0 }))
              : l();
          } else e.removeEventListener("click", i.current);
          r.current = !1;
        },
        o = window.setTimeout(() => {
          e.addEventListener("pointerdown", s);
        }, 0);
      return () => {
        window.clearTimeout(o), e.removeEventListener("pointerdown", s), e.removeEventListener("click", i.current);
      };
    }, [e, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function bme(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = as(t),
    r = w.useRef(!1);
  return (
    w.useEffect(() => {
      const i = (s) => {
        s.target && !r.current && zI(gme, n, { originalEvent: s }, { discrete: !1 });
      };
      return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
    }, [e, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  );
}
function OT() {
  const t = new CustomEvent(bx);
  document.dispatchEvent(t);
}
function zI(t, e, n, { discrete: r }) {
  const i = n.originalEvent.target,
    s = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && i.addEventListener(t, e, { once: !0 }), r ? dme(i, s) : i.dispatchEvent(s);
}
var A1 = 0;
function yme() {
  w.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement("afterbegin", t[0] ?? vT()),
      document.body.insertAdjacentElement("beforeend", t[1] ?? vT()),
      A1++,
      () => {
        A1 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), A1--;
      }
    );
  }, []);
}
function vT() {
  const t = document.createElement("span");
  return (
    t.setAttribute("data-radix-focus-guard", ""),
    (t.tabIndex = 0),
    (t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none"),
    t
  );
}
var $1 = "focusScope.autoFocusOnMount",
  R1 = "focusScope.autoFocusOnUnmount",
  xT = { bubbles: !1, cancelable: !0 },
  wme = "FocusScope",
  WI = w.forwardRef((t, e) => {
    const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: s, ...o } = t,
      [a, l] = w.useState(null),
      c = as(i),
      u = as(s),
      h = w.useRef(null),
      f = yr(e, (m) => l(m)),
      d = w.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    w.useEffect(() => {
      if (r) {
        let m = function (x) {
            if (d.paused || !a) return;
            const y = x.target;
            a.contains(y) ? (h.current = y) : Ts(h.current, { select: !0 });
          },
          O = function (x) {
            if (d.paused || !a) return;
            const y = x.relatedTarget;
            y !== null && (a.contains(y) || Ts(h.current, { select: !0 }));
          },
          v = function (x) {
            if (document.activeElement === document.body) for (const S of x) S.removedNodes.length > 0 && Ts(a);
          };
        document.addEventListener("focusin", m), document.addEventListener("focusout", O);
        const g = new MutationObserver(v);
        return (
          a && g.observe(a, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", m), document.removeEventListener("focusout", O), g.disconnect();
          }
        );
      }
    }, [r, a, d.paused]),
      w.useEffect(() => {
        if (a) {
          yT.add(d);
          const m = document.activeElement;
          if (!a.contains(m)) {
            const v = new CustomEvent($1, xT);
            a.addEventListener($1, c),
              a.dispatchEvent(v),
              v.defaultPrevented || (Sme(Tme(UI(a)), { select: !0 }), document.activeElement === m && Ts(a));
          }
          return () => {
            a.removeEventListener($1, c),
              setTimeout(() => {
                const v = new CustomEvent(R1, xT);
                a.addEventListener(R1, u),
                  a.dispatchEvent(v),
                  v.defaultPrevented || Ts(m ?? document.body, { select: !0 }),
                  a.removeEventListener(R1, u),
                  yT.remove(d);
              }, 0);
          };
        }
      }, [a, c, u, d]);
    const p = w.useCallback(
      (m) => {
        if ((!n && !r) || d.paused) return;
        const O = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey,
          v = document.activeElement;
        if (O && v) {
          const g = m.currentTarget,
            [x, y] = kme(g);
          x && y
            ? !m.shiftKey && v === y
              ? (m.preventDefault(), n && Ts(x, { select: !0 }))
              : m.shiftKey && v === x && (m.preventDefault(), n && Ts(y, { select: !0 }))
            : v === g && m.preventDefault();
        }
      },
      [n, r, d.paused]
    );
    return E.jsx(Rn.div, { tabIndex: -1, ...o, ref: f, onKeyDown: p });
  });
WI.displayName = wme;
function Sme(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t) if ((Ts(r, { select: e }), document.activeElement !== n)) return;
}
function kme(t) {
  const e = UI(t),
    n = bT(e, t),
    r = bT(e.reverse(), t);
  return [n, r];
}
function UI(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      },
    });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function bT(t, e) {
  for (const n of t) if (!Cme(n, { upTo: e })) return n;
}
function Cme(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function _me(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Ts(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && _me(t) && e && t.select();
  }
}
var yT = Eme();
function Eme() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), (t = wT(t, e)), t.unshift(e);
    },
    remove(e) {
      var n;
      (t = wT(t, e)), (n = t[0]) == null || n.resume();
    },
  };
}
function wT(t, e) {
  const n = [...t],
    r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function Tme(t) {
  return t.filter((e) => e.tagName !== "A");
}
function Pme(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function XI(...t) {
  return (e) => t.forEach((n) => Pme(n, e));
}
function HI(...t) {
  return w.useCallback(XI(...t), t);
}
var qI = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find($me);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(yx, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(yx, { ...r, ref: e, children: n });
});
qI.displayName = "Slot";
var yx = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = Ime(n);
    return w.cloneElement(n, { ...Rme(r, n.props), ref: e ? XI(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
yx.displayName = "SlotClone";
var Ame = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function $me(t) {
  return w.isValidElement(t) && t.type === Ame;
}
function Rme(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function Ime(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var Nme = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  RS = Nme.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? qI : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {}),
  Lme = "Arrow",
  YI = w.forwardRef((t, e) => {
    const { children: n, width: r = 10, height: i = 5, ...s } = t;
    return E.jsx(RS.svg, {
      ...s,
      ref: e,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : E.jsx("polygon", { points: "0,0 30,0 15,10" }),
    });
  });
YI.displayName = Lme;
var Mme = YI,
  IS = "Popper",
  [GI, Dg] = da(IS),
  [Dme, JI] = GI(IS),
  KI = (t) => {
    const { __scopePopper: e, children: n } = t,
      [r, i] = w.useState(null);
    return E.jsx(Dme, { scope: e, anchor: r, onAnchorChange: i, children: n });
  };
KI.displayName = IS;
var eN = "PopperAnchor",
  tN = w.forwardRef((t, e) => {
    const { __scopePopper: n, virtualRef: r, ...i } = t,
      s = JI(eN, n),
      o = w.useRef(null),
      a = HI(e, o);
    return (
      w.useEffect(() => {
        s.onAnchorChange((r == null ? void 0 : r.current) || o.current);
      }),
      r ? null : E.jsx(RS.div, { ...i, ref: a })
    );
  });
tN.displayName = eN;
var NS = "PopperContent",
  [Qme, Fme] = GI(NS),
  nN = w.forwardRef((t, e) => {
    var Y, q, se, ue, ve, Pe;
    const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: i = 0,
        align: s = "center",
        alignOffset: o = 0,
        arrowPadding: a = 0,
        avoidCollisions: l = !0,
        collisionBoundary: c = [],
        collisionPadding: u = 0,
        sticky: h = "partial",
        hideWhenDetached: f = !1,
        updatePositionStrategy: d = "optimized",
        onPlaced: p,
        ...m
      } = t,
      O = JI(NS, n),
      [v, g] = w.useState(null),
      x = HI(e, (Fe) => g(Fe)),
      [y, S] = w.useState(null),
      k = GM(y),
      b = (k == null ? void 0 : k.width) ?? 0,
      _ = (k == null ? void 0 : k.height) ?? 0,
      T = r + (s !== "center" ? "-" + s : ""),
      P = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u },
      M = Array.isArray(c) ? c : [c],
      D = M.length > 0,
      V = { padding: P, boundary: M.filter(Bme), altBoundary: D },
      {
        refs: Q,
        floatingStyles: N,
        placement: G,
        isPositioned: H,
        middlewareData: te,
      } = JM({
        strategy: "fixed",
        placement: T,
        whileElementsMounted: (...Fe) => KM(...Fe, { animationFrame: d === "always" }),
        elements: { reference: O.anchor },
        middleware: [
          eD({ mainAxis: i + _, alignmentAxis: o }),
          l && tD({ mainAxis: !0, crossAxis: !1, limiter: h === "partial" ? nD() : void 0, ...V }),
          l && rD({ ...V }),
          iD({
            ...V,
            apply: ({ elements: Fe, rects: rt, availableWidth: Rt, availableHeight: Qt }) => {
              const { width: Ft, height: Ge } = rt.reference,
                Ve = Fe.floating.style;
              Ve.setProperty("--radix-popper-available-width", `${Rt}px`),
                Ve.setProperty("--radix-popper-available-height", `${Qt}px`),
                Ve.setProperty("--radix-popper-anchor-width", `${Ft}px`),
                Ve.setProperty("--radix-popper-anchor-height", `${Ge}px`);
            },
          }),
          y && sD({ element: y, padding: a }),
          jme({ arrowWidth: b, arrowHeight: _ }),
          f && oD({ strategy: "referenceHidden", ...V }),
        ],
      }),
      [le, $] = sN(G),
      B = as(p);
    nr(() => {
      H && (B == null || B());
    }, [H, B]);
    const ie = (Y = te.arrow) == null ? void 0 : Y.x,
      L = (q = te.arrow) == null ? void 0 : q.y,
      pe = ((se = te.arrow) == null ? void 0 : se.centerOffset) !== 0,
      [Ce, me] = w.useState();
    return (
      nr(() => {
        v && me(window.getComputedStyle(v).zIndex);
      }, [v]),
      E.jsx("div", {
        ref: Q.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...N,
          transform: H ? N.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: Ce,
          "--radix-popper-transform-origin": [
            (ue = te.transformOrigin) == null ? void 0 : ue.x,
            (ve = te.transformOrigin) == null ? void 0 : ve.y,
          ].join(" "),
          ...(((Pe = te.hide) == null ? void 0 : Pe.referenceHidden) && { visibility: "hidden", pointerEvents: "none" }),
        },
        dir: t.dir,
        children: E.jsx(Qme, {
          scope: n,
          placedSide: le,
          onArrowChange: S,
          arrowX: ie,
          arrowY: L,
          shouldHideArrow: pe,
          children: E.jsx(RS.div, {
            "data-side": le,
            "data-align": $,
            ...m,
            ref: x,
            style: { ...m.style, animation: H ? void 0 : "none" },
          }),
        }),
      })
    );
  });
nN.displayName = NS;
var rN = "PopperArrow",
  Vme = { top: "bottom", right: "left", bottom: "top", left: "right" },
  iN = w.forwardRef(function (e, n) {
    const { __scopePopper: r, ...i } = e,
      s = Fme(rN, r),
      o = Vme[s.placedSide];
    return E.jsx("span", {
      ref: s.onArrowChange,
      style: {
        position: "absolute",
        left: s.arrowX,
        top: s.arrowY,
        [o]: 0,
        transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[s.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[s.placedSide],
        visibility: s.shouldHideArrow ? "hidden" : void 0,
      },
      children: E.jsx(Mme, { ...i, ref: n, style: { ...i.style, display: "block" } }),
    });
  });
iN.displayName = rN;
function Bme(t) {
  return t !== null;
}
var jme = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var O, v, g;
    const { placement: n, rects: r, middlewareData: i } = e,
      o = ((O = i.arrow) == null ? void 0 : O.centerOffset) !== 0,
      a = o ? 0 : t.arrowWidth,
      l = o ? 0 : t.arrowHeight,
      [c, u] = sN(n),
      h = { start: "0%", center: "50%", end: "100%" }[u],
      f = (((v = i.arrow) == null ? void 0 : v.x) ?? 0) + a / 2,
      d = (((g = i.arrow) == null ? void 0 : g.y) ?? 0) + l / 2;
    let p = "",
      m = "";
    return (
      c === "bottom"
        ? ((p = o ? h : `${f}px`), (m = `${-l}px`))
        : c === "top"
        ? ((p = o ? h : `${f}px`), (m = `${r.floating.height + l}px`))
        : c === "right"
        ? ((p = `${-l}px`), (m = o ? h : `${d}px`))
        : c === "left" && ((p = `${r.floating.width + l}px`), (m = o ? h : `${d}px`)),
      { data: { x: p, y: m } }
    );
  },
});
function sN(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var oN = KI,
  aN = tN,
  lN = nN,
  cN = iN,
  Zme = "Portal",
  uN = w.forwardRef((t, e) => {
    var a;
    const { container: n, ...r } = t,
      [i, s] = w.useState(!1);
    nr(() => s(!0), []);
    const o = n || (i && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body));
    return o ? Ux.createPortal(E.jsx(Rn.div, { ...r, ref: e }), o) : null;
  });
uN.displayName = Zme;
function zme(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function Wme(...t) {
  return (e) => t.forEach((n) => zme(n, e));
}
var hN = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(Xme);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(wx, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(wx, { ...r, ref: e, children: n });
});
hN.displayName = "Slot";
var wx = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = qme(n);
    return w.cloneElement(n, { ...Hme(r, n.props), ref: e ? Wme(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
wx.displayName = "SlotClone";
var Ume = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function Xme(t) {
  return w.isValidElement(t) && t.type === Ume;
}
function Hme(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function qme(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var Yme = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  Gme = Yme.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? hN : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {}),
  Jme = "VisuallyHidden",
  LS = w.forwardRef((t, e) =>
    E.jsx(Gme.span, {
      ...t,
      ref: e,
      style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...t.style,
      },
    })
  );
LS.displayName = Jme;
var Kme = LS,
  fN = G$(),
  I1 = function () {},
  Qg = w.forwardRef(function (t, e) {
    var n = w.useRef(null),
      r = w.useState({ onScrollCapture: I1, onWheelCapture: I1, onTouchMoveCapture: I1 }),
      i = r[0],
      s = r[1],
      o = t.forwardProps,
      a = t.children,
      l = t.className,
      c = t.removeScrollBar,
      u = t.enabled,
      h = t.shards,
      f = t.sideCar,
      d = t.noIsolation,
      p = t.inert,
      m = t.allowPinchZoom,
      O = t.as,
      v = O === void 0 ? "div" : O,
      g = t.gapMode,
      x = Xx(t, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode",
      ]),
      y = f,
      S = Y$([n, e]),
      k = kn(kn({}, x), i);
    return w.createElement(
      w.Fragment,
      null,
      u &&
        w.createElement(y, {
          sideCar: fN,
          removeScrollBar: c,
          shards: h,
          noIsolation: d,
          inert: p,
          setCallbacks: s,
          allowPinchZoom: !!m,
          lockRef: n,
          gapMode: g,
        }),
      o ? w.cloneElement(w.Children.only(a), kn(kn({}, k), { ref: S })) : w.createElement(v, kn({}, k, { className: l, ref: S }), a)
    );
  });
Qg.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
Qg.classNames = { fullWidth: iu, zeroRight: ru };
function ege() {
  if (!document) return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = wP();
  return e && t.setAttribute("nonce", e), t;
}
function tge(t, e) {
  t.styleSheet ? (t.styleSheet.cssText = e) : t.appendChild(document.createTextNode(e));
}
function nge(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var rge = function () {
    var t = 0,
      e = null;
    return {
      add: function (n) {
        t == 0 && (e = ege()) && (tge(e, n), nge(e)), t++;
      },
      remove: function () {
        t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), (e = null));
      },
    };
  },
  ige = function () {
    var t = rge();
    return function (e, n) {
      w.useEffect(
        function () {
          return (
            t.add(e),
            function () {
              t.remove();
            }
          );
        },
        [e && n]
      );
    };
  },
  sge = function () {
    var t = ige(),
      e = function (n) {
        var r = n.styles,
          i = n.dynamic;
        return t(r, i), null;
      };
    return e;
  },
  Sx = !1;
if (typeof window < "u")
  try {
    var ld = Object.defineProperty({}, "passive", {
      get: function () {
        return (Sx = !0), !0;
      },
    });
    window.addEventListener("test", ld, ld), window.removeEventListener("test", ld, ld);
  } catch {
    Sx = !1;
  }
var Ea = Sx ? { passive: !1 } : !1,
  oge = function (t) {
    return t.tagName === "TEXTAREA";
  },
  dN = function (t, e) {
    var n = window.getComputedStyle(t);
    return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !oge(t) && n[e] === "visible");
  },
  age = function (t) {
    return dN(t, "overflowY");
  },
  lge = function (t) {
    return dN(t, "overflowX");
  },
  ST = function (t, e) {
    var n = e.ownerDocument,
      r = e;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var i = pN(t, r);
      if (i) {
        var s = mN(t, r),
          o = s[1],
          a = s[2];
        if (o > a) return !0;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return !1;
  },
  cge = function (t) {
    var e = t.scrollTop,
      n = t.scrollHeight,
      r = t.clientHeight;
    return [e, n, r];
  },
  uge = function (t) {
    var e = t.scrollLeft,
      n = t.scrollWidth,
      r = t.clientWidth;
    return [e, n, r];
  },
  pN = function (t, e) {
    return t === "v" ? age(e) : lge(e);
  },
  mN = function (t, e) {
    return t === "v" ? cge(e) : uge(e);
  },
  hge = function (t, e) {
    return t === "h" && e === "rtl" ? -1 : 1;
  },
  fge = function (t, e, n, r, i) {
    var s = hge(t, window.getComputedStyle(e).direction),
      o = s * r,
      a = n.target,
      l = e.contains(a),
      c = !1,
      u = o > 0,
      h = 0,
      f = 0;
    do {
      var d = mN(t, a),
        p = d[0],
        m = d[1],
        O = d[2],
        v = m - O - s * p;
      (p || v) && pN(t, a) && ((h += v), (f += p)), a instanceof ShadowRoot ? (a = a.host) : (a = a.parentNode);
    } while ((!l && a !== document.body) || (l && (e.contains(a) || e === a)));
    return ((u && ((i && Math.abs(h) < 1) || (!i && o > h))) || (!u && ((i && Math.abs(f) < 1) || (!i && -o > f)))) && (c = !0), c;
  },
  cd = function (t) {
    return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
  },
  kT = function (t) {
    return [t.deltaX, t.deltaY];
  },
  CT = function (t) {
    return t && "current" in t ? t.current : t;
  },
  dge = function (t, e) {
    return t[0] === e[0] && t[1] === e[1];
  },
  pge = function (t) {
    return `
  .block-interactivity-`
      .concat(
        t,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        t,
        ` {pointer-events: all;}
`
      );
  },
  mge = 0,
  Ta = [];
function gge(t) {
  var e = w.useRef([]),
    n = w.useRef([0, 0]),
    r = w.useRef(),
    i = w.useState(mge++)[0],
    s = w.useState(sge)[0],
    o = w.useRef(t);
  w.useEffect(
    function () {
      o.current = t;
    },
    [t]
  ),
    w.useEffect(
      function () {
        if (t.inert) {
          document.body.classList.add("block-interactivity-".concat(i));
          var m = SP([t.lockRef.current], (t.shards || []).map(CT), !0).filter(Boolean);
          return (
            m.forEach(function (O) {
              return O.classList.add("allow-interactivity-".concat(i));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(i)),
                m.forEach(function (O) {
                  return O.classList.remove("allow-interactivity-".concat(i));
                });
            }
          );
        }
      },
      [t.inert, t.lockRef.current, t.shards]
    );
  var a = w.useCallback(function (m, O) {
      if ("touches" in m && m.touches.length === 2) return !o.current.allowPinchZoom;
      var v = cd(m),
        g = n.current,
        x = "deltaX" in m ? m.deltaX : g[0] - v[0],
        y = "deltaY" in m ? m.deltaY : g[1] - v[1],
        S,
        k = m.target,
        b = Math.abs(x) > Math.abs(y) ? "h" : "v";
      if ("touches" in m && b === "h" && k.type === "range") return !1;
      var _ = ST(b, k);
      if (!_) return !0;
      if ((_ ? (S = b) : ((S = b === "v" ? "h" : "v"), (_ = ST(b, k))), !_)) return !1;
      if ((!r.current && "changedTouches" in m && (x || y) && (r.current = S), !S)) return !0;
      var T = r.current || S;
      return fge(T, O, m, T === "h" ? x : y, !0);
    }, []),
    l = w.useCallback(function (m) {
      var O = m;
      if (!(!Ta.length || Ta[Ta.length - 1] !== s)) {
        var v = "deltaY" in O ? kT(O) : cd(O),
          g = e.current.filter(function (S) {
            return S.name === O.type && (S.target === O.target || O.target === S.shadowParent) && dge(S.delta, v);
          })[0];
        if (g && g.should) {
          O.cancelable && O.preventDefault();
          return;
        }
        if (!g) {
          var x = (o.current.shards || [])
              .map(CT)
              .filter(Boolean)
              .filter(function (S) {
                return S.contains(O.target);
              }),
            y = x.length > 0 ? a(O, x[0]) : !o.current.noIsolation;
          y && O.cancelable && O.preventDefault();
        }
      }
    }, []),
    c = w.useCallback(function (m, O, v, g) {
      var x = { name: m, delta: O, target: v, should: g, shadowParent: Oge(v) };
      e.current.push(x),
        setTimeout(function () {
          e.current = e.current.filter(function (y) {
            return y !== x;
          });
        }, 1);
    }, []),
    u = w.useCallback(function (m) {
      (n.current = cd(m)), (r.current = void 0);
    }, []),
    h = w.useCallback(function (m) {
      c(m.type, kT(m), m.target, a(m, t.lockRef.current));
    }, []),
    f = w.useCallback(function (m) {
      c(m.type, cd(m), m.target, a(m, t.lockRef.current));
    }, []);
  w.useEffect(function () {
    return (
      Ta.push(s),
      t.setCallbacks({ onScrollCapture: h, onWheelCapture: h, onTouchMoveCapture: f }),
      document.addEventListener("wheel", l, Ea),
      document.addEventListener("touchmove", l, Ea),
      document.addEventListener("touchstart", u, Ea),
      function () {
        (Ta = Ta.filter(function (m) {
          return m !== s;
        })),
          document.removeEventListener("wheel", l, Ea),
          document.removeEventListener("touchmove", l, Ea),
          document.removeEventListener("touchstart", u, Ea);
      }
    );
  }, []);
  var d = t.removeScrollBar,
    p = t.inert;
  return w.createElement(
    w.Fragment,
    null,
    p ? w.createElement(s, { styles: pge(i) }) : null,
    d ? w.createElement(t9, { gapMode: t.gapMode }) : null
  );
}
function Oge(t) {
  for (var e = null; t !== null; ) t instanceof ShadowRoot && ((e = t.host), (t = t.host)), (t = t.parentNode);
  return e;
}
const vge = K$(fN, gge);
var gN = w.forwardRef(function (t, e) {
  return w.createElement(Qg, kn({}, t, { ref: e, sideCar: vge }));
});
gN.classNames = Qg.classNames;
const xge = gN;
var bge = [" ", "Enter", "ArrowUp", "ArrowDown"],
  yge = [" ", "Enter"],
  hf = "Select",
  [Fg, Vg, wge] = i$(hf),
  [hc, Kve] = da(hf, [wge, Dg]),
  Bg = Dg(),
  [Sge, xo] = hc(hf),
  [kge, Cge] = hc(hf),
  ON = (t) => {
    const {
        __scopeSelect: e,
        children: n,
        open: r,
        defaultOpen: i,
        onOpenChange: s,
        value: o,
        defaultValue: a,
        onValueChange: l,
        dir: c,
        name: u,
        autoComplete: h,
        disabled: f,
        required: d,
      } = t,
      p = Bg(e),
      [m, O] = w.useState(null),
      [v, g] = w.useState(null),
      [x, y] = w.useState(!1),
      S = eg(c),
      [k = !1, b] = Vo({ prop: r, defaultProp: i, onChange: s }),
      [_, T] = Vo({ prop: o, defaultProp: a, onChange: l }),
      P = w.useRef(null),
      M = m ? !!m.closest("form") : !0,
      [D, V] = w.useState(new Set()),
      Q = Array.from(D)
        .map((N) => N.props.value)
        .join(";");
    return E.jsx(oN, {
      ...p,
      children: E.jsxs(Sge, {
        required: d,
        scope: e,
        trigger: m,
        onTriggerChange: O,
        valueNode: v,
        onValueNodeChange: g,
        valueNodeHasChildren: x,
        onValueNodeHasChildrenChange: y,
        contentId: ph(),
        value: _,
        onValueChange: T,
        open: k,
        onOpenChange: b,
        dir: S,
        triggerPointerDownPosRef: P,
        disabled: f,
        children: [
          E.jsx(Fg.Provider, {
            scope: e,
            children: E.jsx(kge, {
              scope: t.__scopeSelect,
              onNativeOptionAdd: w.useCallback((N) => {
                V((G) => new Set(G).add(N));
              }, []),
              onNativeOptionRemove: w.useCallback((N) => {
                V((G) => {
                  const H = new Set(G);
                  return H.delete(N), H;
                });
              }, []),
              children: n,
            }),
          }),
          M
            ? E.jsxs(
                QN,
                {
                  "aria-hidden": !0,
                  required: d,
                  tabIndex: -1,
                  name: u,
                  autoComplete: h,
                  value: _,
                  onChange: (N) => T(N.target.value),
                  disabled: f,
                  children: [_ === void 0 ? E.jsx("option", { value: "" }) : null, Array.from(D)],
                },
                Q
              )
            : null,
        ],
      }),
    });
  };
ON.displayName = hf;
var vN = "SelectTrigger",
  xN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = t,
      s = Bg(n),
      o = xo(vN, n),
      a = o.disabled || r,
      l = yr(e, o.onTriggerChange),
      c = Vg(n),
      [u, h, f] = FN((p) => {
        const m = c().filter((g) => !g.disabled),
          O = m.find((g) => g.value === o.value),
          v = VN(m, p, O);
        v !== void 0 && o.onValueChange(v.value);
      }),
      d = () => {
        a || (o.onOpenChange(!0), f());
      };
    return E.jsx(aN, {
      asChild: !0,
      ...s,
      children: E.jsx(Rn.button, {
        type: "button",
        role: "combobox",
        "aria-controls": o.contentId,
        "aria-expanded": o.open,
        "aria-required": o.required,
        "aria-autocomplete": "none",
        dir: o.dir,
        "data-state": o.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": DN(o.value) ? "" : void 0,
        ...i,
        ref: l,
        onClick: Ye(i.onClick, (p) => {
          p.currentTarget.focus();
        }),
        onPointerDown: Ye(i.onPointerDown, (p) => {
          const m = p.target;
          m.hasPointerCapture(p.pointerId) && m.releasePointerCapture(p.pointerId),
            p.button === 0 &&
              p.ctrlKey === !1 &&
              (d(), (o.triggerPointerDownPosRef.current = { x: Math.round(p.pageX), y: Math.round(p.pageY) }), p.preventDefault());
        }),
        onKeyDown: Ye(i.onKeyDown, (p) => {
          const m = u.current !== "";
          !(p.ctrlKey || p.altKey || p.metaKey) && p.key.length === 1 && h(p.key),
            !(m && p.key === " ") && bge.includes(p.key) && (d(), p.preventDefault());
        }),
      }),
    });
  });
xN.displayName = vN;
var bN = "SelectValue",
  yN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, className: r, style: i, children: s, placeholder: o = "", ...a } = t,
      l = xo(bN, n),
      { onValueNodeHasChildrenChange: c } = l,
      u = s !== void 0,
      h = yr(e, l.onValueNodeChange);
    return (
      nr(() => {
        c(u);
      }, [c, u]),
      E.jsx(Rn.span, { ...a, ref: h, style: { pointerEvents: "none" }, children: DN(l.value) ? E.jsx(E.Fragment, { children: o }) : s })
    );
  });
yN.displayName = bN;
var _ge = "SelectIcon",
  wN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, children: r, ...i } = t;
    return E.jsx(Rn.span, { "aria-hidden": !0, ...i, ref: e, children: r || "▼" });
  });
wN.displayName = _ge;
var Ege = "SelectPortal",
  SN = (t) => E.jsx(uN, { asChild: !0, ...t });
SN.displayName = Ege;
var aa = "SelectContent",
  kN = w.forwardRef((t, e) => {
    const n = xo(aa, t.__scopeSelect),
      [r, i] = w.useState();
    if (
      (nr(() => {
        i(new DocumentFragment());
      }, []),
      !n.open)
    ) {
      const s = r;
      return s
        ? os.createPortal(
            E.jsx(CN, {
              scope: t.__scopeSelect,
              children: E.jsx(Fg.Slot, { scope: t.__scopeSelect, children: E.jsx("div", { children: t.children }) }),
            }),
            s
          )
        : null;
    }
    return E.jsx(_N, { ...t, ref: e });
  });
kN.displayName = aa;
var Hi = 10,
  [CN, bo] = hc(aa),
  Tge = "SelectContentImpl",
  _N = w.forwardRef((t, e) => {
    const {
        __scopeSelect: n,
        position: r = "item-aligned",
        onCloseAutoFocus: i,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        side: a,
        sideOffset: l,
        align: c,
        alignOffset: u,
        arrowPadding: h,
        collisionBoundary: f,
        collisionPadding: d,
        sticky: p,
        hideWhenDetached: m,
        avoidCollisions: O,
        ...v
      } = t,
      g = xo(aa, n),
      [x, y] = w.useState(null),
      [S, k] = w.useState(null),
      b = yr(e, (Y) => y(Y)),
      [_, T] = w.useState(null),
      [P, M] = w.useState(null),
      D = Vg(n),
      [V, Q] = w.useState(!1),
      N = w.useRef(!1);
    w.useEffect(() => {
      if (x) return kP(x);
    }, [x]),
      yme();
    const G = w.useCallback(
        (Y) => {
          const [q, ...se] = D().map((Pe) => Pe.ref.current),
            [ue] = se.slice(-1),
            ve = document.activeElement;
          for (const Pe of Y)
            if (
              Pe === ve ||
              (Pe == null || Pe.scrollIntoView({ block: "nearest" }),
              Pe === q && S && (S.scrollTop = 0),
              Pe === ue && S && (S.scrollTop = S.scrollHeight),
              Pe == null || Pe.focus(),
              document.activeElement !== ve)
            )
              return;
        },
        [D, S]
      ),
      H = w.useCallback(() => G([_, x]), [G, _, x]);
    w.useEffect(() => {
      V && H();
    }, [V, H]);
    const { onOpenChange: te, triggerPointerDownPosRef: le } = g;
    w.useEffect(() => {
      if (x) {
        let Y = { x: 0, y: 0 };
        const q = (ue) => {
            var ve, Pe;
            Y = {
              x: Math.abs(Math.round(ue.pageX) - (((ve = le.current) == null ? void 0 : ve.x) ?? 0)),
              y: Math.abs(Math.round(ue.pageY) - (((Pe = le.current) == null ? void 0 : Pe.y) ?? 0)),
            };
          },
          se = (ue) => {
            Y.x <= 10 && Y.y <= 10 ? ue.preventDefault() : x.contains(ue.target) || te(!1),
              document.removeEventListener("pointermove", q),
              (le.current = null);
          };
        return (
          le.current !== null &&
            (document.addEventListener("pointermove", q), document.addEventListener("pointerup", se, { capture: !0, once: !0 })),
          () => {
            document.removeEventListener("pointermove", q), document.removeEventListener("pointerup", se, { capture: !0 });
          }
        );
      }
    }, [x, te, le]),
      w.useEffect(() => {
        const Y = () => te(!1);
        return (
          window.addEventListener("blur", Y),
          window.addEventListener("resize", Y),
          () => {
            window.removeEventListener("blur", Y), window.removeEventListener("resize", Y);
          }
        );
      }, [te]);
    const [$, B] = FN((Y) => {
        const q = D().filter((ve) => !ve.disabled),
          se = q.find((ve) => ve.ref.current === document.activeElement),
          ue = VN(q, Y, se);
        ue && setTimeout(() => ue.ref.current.focus());
      }),
      ie = w.useCallback(
        (Y, q, se) => {
          const ue = !N.current && !se;
          ((g.value !== void 0 && g.value === q) || ue) && (T(Y), ue && (N.current = !0));
        },
        [g.value]
      ),
      L = w.useCallback(() => (x == null ? void 0 : x.focus()), [x]),
      pe = w.useCallback(
        (Y, q, se) => {
          const ue = !N.current && !se;
          ((g.value !== void 0 && g.value === q) || ue) && M(Y);
        },
        [g.value]
      ),
      Ce = r === "popper" ? kx : EN,
      me =
        Ce === kx
          ? {
              side: a,
              sideOffset: l,
              align: c,
              alignOffset: u,
              arrowPadding: h,
              collisionBoundary: f,
              collisionPadding: d,
              sticky: p,
              hideWhenDetached: m,
              avoidCollisions: O,
            }
          : {};
    return E.jsx(CN, {
      scope: n,
      content: x,
      viewport: S,
      onViewportChange: k,
      itemRefCallback: ie,
      selectedItem: _,
      onItemLeave: L,
      itemTextRefCallback: pe,
      focusSelectedItem: H,
      selectedItemText: P,
      position: r,
      isPositioned: V,
      searchRef: $,
      children: E.jsx(xge, {
        as: $S,
        allowPinchZoom: !0,
        children: E.jsx(WI, {
          asChild: !0,
          trapped: g.open,
          onMountAutoFocus: (Y) => {
            Y.preventDefault();
          },
          onUnmountAutoFocus: Ye(i, (Y) => {
            var q;
            (q = g.trigger) == null || q.focus({ preventScroll: !0 }), Y.preventDefault();
          }),
          children: E.jsx(ZI, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown: s,
            onPointerDownOutside: o,
            onFocusOutside: (Y) => Y.preventDefault(),
            onDismiss: () => g.onOpenChange(!1),
            children: E.jsx(Ce, {
              role: "listbox",
              id: g.contentId,
              "data-state": g.open ? "open" : "closed",
              dir: g.dir,
              onContextMenu: (Y) => Y.preventDefault(),
              ...v,
              ...me,
              onPlaced: () => Q(!0),
              ref: b,
              style: { display: "flex", flexDirection: "column", outline: "none", ...v.style },
              onKeyDown: Ye(v.onKeyDown, (Y) => {
                const q = Y.ctrlKey || Y.altKey || Y.metaKey;
                if (
                  (Y.key === "Tab" && Y.preventDefault(),
                  !q && Y.key.length === 1 && B(Y.key),
                  ["ArrowUp", "ArrowDown", "Home", "End"].includes(Y.key))
                ) {
                  let ue = D()
                    .filter((ve) => !ve.disabled)
                    .map((ve) => ve.ref.current);
                  if ((["ArrowUp", "End"].includes(Y.key) && (ue = ue.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(Y.key))) {
                    const ve = Y.target,
                      Pe = ue.indexOf(ve);
                    ue = ue.slice(Pe + 1);
                  }
                  setTimeout(() => G(ue)), Y.preventDefault();
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
_N.displayName = Tge;
var Pge = "SelectItemAlignedPosition",
  EN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, onPlaced: r, ...i } = t,
      s = xo(aa, n),
      o = bo(aa, n),
      [a, l] = w.useState(null),
      [c, u] = w.useState(null),
      h = yr(e, (b) => u(b)),
      f = Vg(n),
      d = w.useRef(!1),
      p = w.useRef(!0),
      { viewport: m, selectedItem: O, selectedItemText: v, focusSelectedItem: g } = o,
      x = w.useCallback(() => {
        if (s.trigger && s.valueNode && a && c && m && O && v) {
          const b = s.trigger.getBoundingClientRect(),
            _ = c.getBoundingClientRect(),
            T = s.valueNode.getBoundingClientRect(),
            P = v.getBoundingClientRect();
          if (s.dir !== "rtl") {
            const ve = P.left - _.left,
              Pe = T.left - ve,
              Fe = b.left - Pe,
              rt = b.width + Fe,
              Rt = Math.max(rt, _.width),
              Qt = window.innerWidth - Hi,
              Ft = mT(Pe, [Hi, Qt - Rt]);
            (a.style.minWidth = rt + "px"), (a.style.left = Ft + "px");
          } else {
            const ve = _.right - P.right,
              Pe = window.innerWidth - T.right - ve,
              Fe = window.innerWidth - b.right - Pe,
              rt = b.width + Fe,
              Rt = Math.max(rt, _.width),
              Qt = window.innerWidth - Hi,
              Ft = mT(Pe, [Hi, Qt - Rt]);
            (a.style.minWidth = rt + "px"), (a.style.right = Ft + "px");
          }
          const M = f(),
            D = window.innerHeight - Hi * 2,
            V = m.scrollHeight,
            Q = window.getComputedStyle(c),
            N = parseInt(Q.borderTopWidth, 10),
            G = parseInt(Q.paddingTop, 10),
            H = parseInt(Q.borderBottomWidth, 10),
            te = parseInt(Q.paddingBottom, 10),
            le = N + G + V + te + H,
            $ = Math.min(O.offsetHeight * 5, le),
            B = window.getComputedStyle(m),
            ie = parseInt(B.paddingTop, 10),
            L = parseInt(B.paddingBottom, 10),
            pe = b.top + b.height / 2 - Hi,
            Ce = D - pe,
            me = O.offsetHeight / 2,
            Y = O.offsetTop + me,
            q = N + G + Y,
            se = le - q;
          if (q <= pe) {
            const ve = O === M[M.length - 1].ref.current;
            a.style.bottom = "0px";
            const Pe = c.clientHeight - m.offsetTop - m.offsetHeight,
              Fe = Math.max(Ce, me + (ve ? L : 0) + Pe + H),
              rt = q + Fe;
            a.style.height = rt + "px";
          } else {
            const ve = O === M[0].ref.current;
            a.style.top = "0px";
            const Fe = Math.max(pe, N + m.offsetTop + (ve ? ie : 0) + me) + se;
            (a.style.height = Fe + "px"), (m.scrollTop = q - pe + m.offsetTop);
          }
          (a.style.margin = `${Hi}px 0`),
            (a.style.minHeight = $ + "px"),
            (a.style.maxHeight = D + "px"),
            r == null || r(),
            requestAnimationFrame(() => (d.current = !0));
        }
      }, [f, s.trigger, s.valueNode, a, c, m, O, v, s.dir, r]);
    nr(() => x(), [x]);
    const [y, S] = w.useState();
    nr(() => {
      c && S(window.getComputedStyle(c).zIndex);
    }, [c]);
    const k = w.useCallback(
      (b) => {
        b && p.current === !0 && (x(), g == null || g(), (p.current = !1));
      },
      [x, g]
    );
    return E.jsx($ge, {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: d,
      onScrollButtonChange: k,
      children: E.jsx("div", {
        ref: l,
        style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: y },
        children: E.jsx(Rn.div, { ...i, ref: h, style: { boxSizing: "border-box", maxHeight: "100%", ...i.style } }),
      }),
    });
  });
EN.displayName = Pge;
var Age = "SelectPopperPosition",
  kx = w.forwardRef((t, e) => {
    const { __scopeSelect: n, align: r = "start", collisionPadding: i = Hi, ...s } = t,
      o = Bg(n);
    return E.jsx(lN, {
      ...o,
      ...s,
      ref: e,
      align: r,
      collisionPadding: i,
      style: {
        boxSizing: "border-box",
        ...s.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)",
      },
    });
  });
kx.displayName = Age;
var [$ge, MS] = hc(aa, {}),
  Cx = "SelectViewport",
  TN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, nonce: r, ...i } = t,
      s = bo(Cx, n),
      o = MS(Cx, n),
      a = yr(e, s.onViewportChange),
      l = w.useRef(0);
    return E.jsxs(E.Fragment, {
      children: [
        E.jsx("style", {
          dangerouslySetInnerHTML: {
            __html:
              "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}",
          },
          nonce: r,
        }),
        E.jsx(Fg.Slot, {
          scope: n,
          children: E.jsx(Rn.div, {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...i,
            ref: a,
            style: { position: "relative", flex: 1, overflow: "auto", ...i.style },
            onScroll: Ye(i.onScroll, (c) => {
              const u = c.currentTarget,
                { contentWrapper: h, shouldExpandOnScrollRef: f } = o;
              if (f != null && f.current && h) {
                const d = Math.abs(l.current - u.scrollTop);
                if (d > 0) {
                  const p = window.innerHeight - Hi * 2,
                    m = parseFloat(h.style.minHeight),
                    O = parseFloat(h.style.height),
                    v = Math.max(m, O);
                  if (v < p) {
                    const g = v + d,
                      x = Math.min(p, g),
                      y = g - x;
                    (h.style.height = x + "px"),
                      h.style.bottom === "0px" && ((u.scrollTop = y > 0 ? y : 0), (h.style.justifyContent = "flex-end"));
                  }
                }
              }
              l.current = u.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
TN.displayName = Cx;
var PN = "SelectGroup",
  [Rge, Ige] = hc(PN),
  Nge = w.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t,
      i = ph();
    return E.jsx(Rge, { scope: n, id: i, children: E.jsx(Rn.div, { role: "group", "aria-labelledby": i, ...r, ref: e }) });
  });
Nge.displayName = PN;
var AN = "SelectLabel",
  Lge = w.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t,
      i = Ige(AN, n);
    return E.jsx(Rn.div, { id: i.id, ...r, ref: e });
  });
Lge.displayName = AN;
var um = "SelectItem",
  [Mge, $N] = hc(um),
  RN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, value: r, disabled: i = !1, textValue: s, ...o } = t,
      a = xo(um, n),
      l = bo(um, n),
      c = a.value === r,
      [u, h] = w.useState(s ?? ""),
      [f, d] = w.useState(!1),
      p = yr(e, (v) => {
        var g;
        return (g = l.itemRefCallback) == null ? void 0 : g.call(l, v, r, i);
      }),
      m = ph(),
      O = () => {
        i || (a.onValueChange(r), a.onOpenChange(!1));
      };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return E.jsx(Mge, {
      scope: n,
      value: r,
      disabled: i,
      textId: m,
      isSelected: c,
      onItemTextChange: w.useCallback((v) => {
        h((g) => g || ((v == null ? void 0 : v.textContent) ?? "").trim());
      }, []),
      children: E.jsx(Fg.ItemSlot, {
        scope: n,
        value: r,
        disabled: i,
        textValue: u,
        children: E.jsx(Rn.div, {
          role: "option",
          "aria-labelledby": m,
          "data-highlighted": f ? "" : void 0,
          "aria-selected": c && f,
          "data-state": c ? "checked" : "unchecked",
          "aria-disabled": i || void 0,
          "data-disabled": i ? "" : void 0,
          tabIndex: i ? void 0 : -1,
          ...o,
          ref: p,
          onFocus: Ye(o.onFocus, () => d(!0)),
          onBlur: Ye(o.onBlur, () => d(!1)),
          onPointerUp: Ye(o.onPointerUp, O),
          onPointerMove: Ye(o.onPointerMove, (v) => {
            var g;
            i ? (g = l.onItemLeave) == null || g.call(l) : v.currentTarget.focus({ preventScroll: !0 });
          }),
          onPointerLeave: Ye(o.onPointerLeave, (v) => {
            var g;
            v.currentTarget === document.activeElement && ((g = l.onItemLeave) == null || g.call(l));
          }),
          onKeyDown: Ye(o.onKeyDown, (v) => {
            var x;
            (((x = l.searchRef) == null ? void 0 : x.current) !== "" && v.key === " ") ||
              (yge.includes(v.key) && O(), v.key === " " && v.preventDefault());
          }),
        }),
      }),
    });
  });
RN.displayName = um;
var qc = "SelectItemText",
  IN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, className: r, style: i, ...s } = t,
      o = xo(qc, n),
      a = bo(qc, n),
      l = $N(qc, n),
      c = Cge(qc, n),
      [u, h] = w.useState(null),
      f = yr(
        e,
        (v) => h(v),
        l.onItemTextChange,
        (v) => {
          var g;
          return (g = a.itemTextRefCallback) == null ? void 0 : g.call(a, v, l.value, l.disabled);
        }
      ),
      d = u == null ? void 0 : u.textContent,
      p = w.useMemo(() => E.jsx("option", { value: l.value, disabled: l.disabled, children: d }, l.value), [l.disabled, l.value, d]),
      { onNativeOptionAdd: m, onNativeOptionRemove: O } = c;
    return (
      nr(() => (m(p), () => O(p)), [m, O, p]),
      E.jsxs(E.Fragment, {
        children: [
          E.jsx(Rn.span, { id: l.textId, ...s, ref: f }),
          l.isSelected && o.valueNode && !o.valueNodeHasChildren ? os.createPortal(s.children, o.valueNode) : null,
        ],
      })
    );
  });
IN.displayName = qc;
var NN = "SelectItemIndicator",
  Dge = w.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return $N(NN, n).isSelected ? E.jsx(Rn.span, { "aria-hidden": !0, ...r, ref: e }) : null;
  });
Dge.displayName = NN;
var _x = "SelectScrollUpButton",
  Qge = w.forwardRef((t, e) => {
    const n = bo(_x, t.__scopeSelect),
      r = MS(_x, t.__scopeSelect),
      [i, s] = w.useState(!1),
      o = yr(e, r.onScrollButtonChange);
    return (
      nr(() => {
        if (n.viewport && n.isPositioned) {
          let a = function () {
            const c = l.scrollTop > 0;
            s(c);
          };
          const l = n.viewport;
          return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a);
        }
      }, [n.viewport, n.isPositioned]),
      i
        ? E.jsx(LN, {
            ...t,
            ref: o,
            onAutoScroll: () => {
              const { viewport: a, selectedItem: l } = n;
              a && l && (a.scrollTop = a.scrollTop - l.offsetHeight);
            },
          })
        : null
    );
  });
Qge.displayName = _x;
var Ex = "SelectScrollDownButton",
  Fge = w.forwardRef((t, e) => {
    const n = bo(Ex, t.__scopeSelect),
      r = MS(Ex, t.__scopeSelect),
      [i, s] = w.useState(!1),
      o = yr(e, r.onScrollButtonChange);
    return (
      nr(() => {
        if (n.viewport && n.isPositioned) {
          let a = function () {
            const c = l.scrollHeight - l.clientHeight,
              u = Math.ceil(l.scrollTop) < c;
            s(u);
          };
          const l = n.viewport;
          return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a);
        }
      }, [n.viewport, n.isPositioned]),
      i
        ? E.jsx(LN, {
            ...t,
            ref: o,
            onAutoScroll: () => {
              const { viewport: a, selectedItem: l } = n;
              a && l && (a.scrollTop = a.scrollTop + l.offsetHeight);
            },
          })
        : null
    );
  });
Fge.displayName = Ex;
var LN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, onAutoScroll: r, ...i } = t,
      s = bo("SelectScrollButton", n),
      o = w.useRef(null),
      a = Vg(n),
      l = w.useCallback(() => {
        o.current !== null && (window.clearInterval(o.current), (o.current = null));
      }, []);
    return (
      w.useEffect(() => () => l(), [l]),
      nr(() => {
        var u;
        const c = a().find((h) => h.ref.current === document.activeElement);
        (u = c == null ? void 0 : c.ref.current) == null || u.scrollIntoView({ block: "nearest" });
      }, [a]),
      E.jsx(Rn.div, {
        "aria-hidden": !0,
        ...i,
        ref: e,
        style: { flexShrink: 0, ...i.style },
        onPointerDown: Ye(i.onPointerDown, () => {
          o.current === null && (o.current = window.setInterval(r, 50));
        }),
        onPointerMove: Ye(i.onPointerMove, () => {
          var c;
          (c = s.onItemLeave) == null || c.call(s), o.current === null && (o.current = window.setInterval(r, 50));
        }),
        onPointerLeave: Ye(i.onPointerLeave, () => {
          l();
        }),
      })
    );
  }),
  Vge = "SelectSeparator",
  MN = w.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return E.jsx(Rn.div, { "aria-hidden": !0, ...r, ref: e });
  });
MN.displayName = Vge;
var Tx = "SelectArrow",
  Bge = w.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t,
      i = Bg(n),
      s = xo(Tx, n),
      o = bo(Tx, n);
    return s.open && o.position === "popper" ? E.jsx(cN, { ...i, ...r, ref: e }) : null;
  });
Bge.displayName = Tx;
function DN(t) {
  return t === "" || t === void 0;
}
var QN = w.forwardRef((t, e) => {
  const { value: n, ...r } = t,
    i = w.useRef(null),
    s = yr(e, i),
    o = aD(n);
  return (
    w.useEffect(() => {
      const a = i.current,
        l = window.HTMLSelectElement.prototype,
        u = Object.getOwnPropertyDescriptor(l, "value").set;
      if (o !== n && u) {
        const h = new Event("change", { bubbles: !0 });
        u.call(a, n), a.dispatchEvent(h);
      }
    }, [o, n]),
    E.jsx(LS, { asChild: !0, children: E.jsx("select", { ...r, ref: s, defaultValue: n }) })
  );
});
QN.displayName = "BubbleSelect";
function FN(t) {
  const e = as(t),
    n = w.useRef(""),
    r = w.useRef(0),
    i = w.useCallback(
      (o) => {
        const a = n.current + o;
        e(a),
          (function l(c) {
            (n.current = c), window.clearTimeout(r.current), c !== "" && (r.current = window.setTimeout(() => l(""), 1e3));
          })(a);
      },
      [e]
    ),
    s = w.useCallback(() => {
      (n.current = ""), window.clearTimeout(r.current);
    }, []);
  return w.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, s];
}
function VN(t, e, n) {
  const i = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e,
    s = n ? t.indexOf(n) : -1;
  let o = jge(t, Math.max(s, 0));
  i.length === 1 && (o = o.filter((c) => c !== n));
  const l = o.find((c) => c.textValue.toLowerCase().startsWith(i.toLowerCase()));
  return l !== n ? l : void 0;
}
function jge(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var BN = ON,
  jN = xN,
  Zge = yN,
  ZN = wN,
  zge = SN,
  Wge = kN,
  Uge = TN,
  Xge = RN,
  Hge = IN,
  qge = MN;
function Yge(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function zN(...t) {
  return (e) => t.forEach((n) => Yge(n, e));
}
function ff(...t) {
  return w.useCallback(zN(...t), t);
}
var WN = w.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = w.Children.toArray(n),
    s = i.find(Gge);
  if (s) {
    const o = s.props.children,
      a = i.map((l) => (l === s ? (w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null) : l));
    return E.jsx(Px, { ...r, ref: e, children: w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null });
  }
  return E.jsx(Px, { ...r, ref: e, children: n });
});
WN.displayName = "Slot";
var Px = w.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (w.isValidElement(n)) {
    const i = Kge(n);
    return w.cloneElement(n, { ...Jge(r, n.props), ref: e ? zN(e, i) : i });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
Px.displayName = "SlotClone";
var UN = ({ children: t }) => E.jsx(E.Fragment, { children: t });
function Gge(t) {
  return w.isValidElement(t) && t.type === UN;
}
function Jge(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...s })
      : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function Kge(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var e0e = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  jg = e0e.reduce((t, e) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? WN : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), E.jsx(a, { ...o, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function t0e(t, e) {
  t && os.flushSync(() => t.dispatchEvent(e));
}
var n0e = "DismissableLayer",
  Ax = "dismissableLayer.update",
  r0e = "dismissableLayer.pointerDownOutside",
  i0e = "dismissableLayer.focusOutside",
  _T,
  XN = w.createContext({ layers: new Set(), layersWithOutsidePointerEventsDisabled: new Set(), branches: new Set() }),
  HN = w.forwardRef((t, e) => {
    const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: i,
        onFocusOutside: s,
        onInteractOutside: o,
        onDismiss: a,
        ...l
      } = t,
      c = w.useContext(XN),
      [u, h] = w.useState(null),
      f = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document),
      [, d] = w.useState({}),
      p = ff(e, (b) => h(b)),
      m = Array.from(c.layers),
      [O] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
      v = m.indexOf(O),
      g = u ? m.indexOf(u) : -1,
      x = c.layersWithOutsidePointerEventsDisabled.size > 0,
      y = g >= v,
      S = a0e((b) => {
        const _ = b.target,
          T = [...c.branches].some((P) => P.contains(_));
        !y || T || (i == null || i(b), o == null || o(b), b.defaultPrevented || a == null || a());
      }, f),
      k = l0e((b) => {
        const _ = b.target;
        [...c.branches].some((P) => P.contains(_)) || (s == null || s(b), o == null || o(b), b.defaultPrevented || a == null || a());
      }, f);
    return (
      _P((b) => {
        g === c.layers.size - 1 && (r == null || r(b), !b.defaultPrevented && a && (b.preventDefault(), a()));
      }, f),
      w.useEffect(() => {
        if (u)
          return (
            n &&
              (c.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((_T = f.body.style.pointerEvents), (f.body.style.pointerEvents = "none")),
              c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            ET(),
            () => {
              n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = _T);
            }
          );
      }, [u, f, n, c]),
      w.useEffect(
        () => () => {
          u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), ET());
        },
        [u, c]
      ),
      w.useEffect(() => {
        const b = () => d({});
        return document.addEventListener(Ax, b), () => document.removeEventListener(Ax, b);
      }, []),
      E.jsx(jg.div, {
        ...l,
        ref: p,
        style: { pointerEvents: x ? (y ? "auto" : "none") : void 0, ...t.style },
        onFocusCapture: Ye(t.onFocusCapture, k.onFocusCapture),
        onBlurCapture: Ye(t.onBlurCapture, k.onBlurCapture),
        onPointerDownCapture: Ye(t.onPointerDownCapture, S.onPointerDownCapture),
      })
    );
  });
HN.displayName = n0e;
var s0e = "DismissableLayerBranch",
  o0e = w.forwardRef((t, e) => {
    const n = w.useContext(XN),
      r = w.useRef(null),
      i = ff(e, r);
    return (
      w.useEffect(() => {
        const s = r.current;
        if (s)
          return (
            n.branches.add(s),
            () => {
              n.branches.delete(s);
            }
          );
      }, [n.branches]),
      E.jsx(jg.div, { ...t, ref: i })
    );
  });
o0e.displayName = s0e;
function a0e(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = as(t),
    r = w.useRef(!1),
    i = w.useRef(() => {});
  return (
    w.useEffect(() => {
      const s = (a) => {
          if (a.target && !r.current) {
            let l = function () {
              qN(r0e, n, c, { discrete: !0 });
            };
            const c = { originalEvent: a };
            a.pointerType === "touch"
              ? (e.removeEventListener("click", i.current), (i.current = l), e.addEventListener("click", i.current, { once: !0 }))
              : l();
          } else e.removeEventListener("click", i.current);
          r.current = !1;
        },
        o = window.setTimeout(() => {
          e.addEventListener("pointerdown", s);
        }, 0);
      return () => {
        window.clearTimeout(o), e.removeEventListener("pointerdown", s), e.removeEventListener("click", i.current);
      };
    }, [e, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function l0e(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = as(t),
    r = w.useRef(!1);
  return (
    w.useEffect(() => {
      const i = (s) => {
        s.target && !r.current && qN(i0e, n, { originalEvent: s }, { discrete: !1 });
      };
      return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
    }, [e, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  );
}
function ET() {
  const t = new CustomEvent(Ax);
  document.dispatchEvent(t);
}
function qN(t, e, n, { discrete: r }) {
  const i = n.originalEvent.target,
    s = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && i.addEventListener(t, e, { once: !0 }), r ? t0e(i, s) : i.dispatchEvent(s);
}
var c0e = "Portal",
  YN = w.forwardRef((t, e) => {
    var a;
    const { container: n, ...r } = t,
      [i, s] = w.useState(!1);
    nr(() => s(!0), []);
    const o = n || (i && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body));
    return o ? Ux.createPortal(E.jsx(jg.div, { ...r, ref: e }), o) : null;
  });
YN.displayName = c0e;
function u0e(t, e) {
  return w.useReducer((n, r) => e[n][r] ?? n, t);
}
var DS = (t) => {
  const { present: e, children: n } = t,
    r = h0e(e),
    i = typeof n == "function" ? n({ present: r.isPresent }) : w.Children.only(n),
    s = ff(r.ref, f0e(i));
  return typeof n == "function" || r.isPresent ? w.cloneElement(i, { ref: s }) : null;
};
DS.displayName = "Presence";
function h0e(t) {
  const [e, n] = w.useState(),
    r = w.useRef({}),
    i = w.useRef(t),
    s = w.useRef("none"),
    o = t ? "mounted" : "unmounted",
    [a, l] = u0e(o, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    w.useEffect(() => {
      const c = ud(r.current);
      s.current = a === "mounted" ? c : "none";
    }, [a]),
    nr(() => {
      const c = r.current,
        u = i.current;
      if (u !== t) {
        const f = s.current,
          d = ud(c);
        t
          ? l("MOUNT")
          : d === "none" || (c == null ? void 0 : c.display) === "none"
          ? l("UNMOUNT")
          : l(u && f !== d ? "ANIMATION_OUT" : "UNMOUNT"),
          (i.current = t);
      }
    }, [t, l]),
    nr(() => {
      if (e) {
        const c = (h) => {
            const d = ud(r.current).includes(h.animationName);
            h.target === e && d && os.flushSync(() => l("ANIMATION_END"));
          },
          u = (h) => {
            h.target === e && (s.current = ud(r.current));
          };
        return (
          e.addEventListener("animationstart", u),
          e.addEventListener("animationcancel", c),
          e.addEventListener("animationend", c),
          () => {
            e.removeEventListener("animationstart", u),
              e.removeEventListener("animationcancel", c),
              e.removeEventListener("animationend", c);
          }
        );
      } else l("ANIMATION_END");
    }, [e, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(a),
      ref: w.useCallback((c) => {
        c && (r.current = getComputedStyle(c)), n(c);
      }, []),
    }
  );
}
function ud(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function f0e(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var [Zg, exe] = da("Tooltip", [Dg]),
  zg = Dg(),
  GN = "TooltipProvider",
  d0e = 700,
  $x = "tooltip.open",
  [p0e, QS] = Zg(GN),
  JN = (t) => {
    const { __scopeTooltip: e, delayDuration: n = d0e, skipDelayDuration: r = 300, disableHoverableContent: i = !1, children: s } = t,
      [o, a] = w.useState(!0),
      l = w.useRef(!1),
      c = w.useRef(0);
    return (
      w.useEffect(() => {
        const u = c.current;
        return () => window.clearTimeout(u);
      }, []),
      E.jsx(p0e, {
        scope: e,
        isOpenDelayed: o,
        delayDuration: n,
        onOpen: w.useCallback(() => {
          window.clearTimeout(c.current), a(!1);
        }, []),
        onClose: w.useCallback(() => {
          window.clearTimeout(c.current), (c.current = window.setTimeout(() => a(!0), r));
        }, [r]),
        isPointerInTransitRef: l,
        onPointerInTransitChange: w.useCallback((u) => {
          l.current = u;
        }, []),
        disableHoverableContent: i,
        children: s,
      })
    );
  };
JN.displayName = GN;
var Wg = "Tooltip",
  [m0e, df] = Zg(Wg),
  KN = (t) => {
    const {
        __scopeTooltip: e,
        children: n,
        open: r,
        defaultOpen: i = !1,
        onOpenChange: s,
        disableHoverableContent: o,
        delayDuration: a,
      } = t,
      l = QS(Wg, t.__scopeTooltip),
      c = zg(e),
      [u, h] = w.useState(null),
      f = ph(),
      d = w.useRef(0),
      p = o ?? l.disableHoverableContent,
      m = a ?? l.delayDuration,
      O = w.useRef(!1),
      [v = !1, g] = Vo({
        prop: r,
        defaultProp: i,
        onChange: (b) => {
          b ? (l.onOpen(), document.dispatchEvent(new CustomEvent($x))) : l.onClose(), s == null || s(b);
        },
      }),
      x = w.useMemo(() => (v ? (O.current ? "delayed-open" : "instant-open") : "closed"), [v]),
      y = w.useCallback(() => {
        window.clearTimeout(d.current), (O.current = !1), g(!0);
      }, [g]),
      S = w.useCallback(() => {
        window.clearTimeout(d.current), g(!1);
      }, [g]),
      k = w.useCallback(() => {
        window.clearTimeout(d.current),
          (d.current = window.setTimeout(() => {
            (O.current = !0), g(!0);
          }, m));
      }, [m, g]);
    return (
      w.useEffect(() => () => window.clearTimeout(d.current), []),
      E.jsx(oN, {
        ...c,
        children: E.jsx(m0e, {
          scope: e,
          contentId: f,
          open: v,
          stateAttribute: x,
          trigger: u,
          onTriggerChange: h,
          onTriggerEnter: w.useCallback(() => {
            l.isOpenDelayed ? k() : y();
          }, [l.isOpenDelayed, k, y]),
          onTriggerLeave: w.useCallback(() => {
            p ? S() : window.clearTimeout(d.current);
          }, [S, p]),
          onOpen: y,
          onClose: S,
          disableHoverableContent: p,
          children: n,
        }),
      })
    );
  };
KN.displayName = Wg;
var Rx = "TooltipTrigger",
  eL = w.forwardRef((t, e) => {
    const { __scopeTooltip: n, ...r } = t,
      i = df(Rx, n),
      s = QS(Rx, n),
      o = zg(n),
      a = w.useRef(null),
      l = ff(e, a, i.onTriggerChange),
      c = w.useRef(!1),
      u = w.useRef(!1),
      h = w.useCallback(() => (c.current = !1), []);
    return (
      w.useEffect(() => () => document.removeEventListener("pointerup", h), [h]),
      E.jsx(aN, {
        asChild: !0,
        ...o,
        children: E.jsx(jg.button, {
          "aria-describedby": i.open ? i.contentId : void 0,
          "data-state": i.stateAttribute,
          ...r,
          ref: l,
          onPointerMove: Ye(t.onPointerMove, (f) => {
            f.pointerType !== "touch" && !u.current && !s.isPointerInTransitRef.current && (i.onTriggerEnter(), (u.current = !0));
          }),
          onPointerLeave: Ye(t.onPointerLeave, () => {
            i.onTriggerLeave(), (u.current = !1);
          }),
          onPointerDown: Ye(t.onPointerDown, () => {
            (c.current = !0), document.addEventListener("pointerup", h, { once: !0 });
          }),
          onFocus: Ye(t.onFocus, () => {
            c.current || i.onOpen();
          }),
          onBlur: Ye(t.onBlur, i.onClose),
          onClick: Ye(t.onClick, i.onClose),
        }),
      })
    );
  });
eL.displayName = Rx;
var FS = "TooltipPortal",
  [g0e, O0e] = Zg(FS, { forceMount: void 0 }),
  tL = (t) => {
    const { __scopeTooltip: e, forceMount: n, children: r, container: i } = t,
      s = df(FS, e);
    return E.jsx(g0e, {
      scope: e,
      forceMount: n,
      children: E.jsx(DS, { present: n || s.open, children: E.jsx(YN, { asChild: !0, container: i, children: r }) }),
    });
  };
tL.displayName = FS;
var Nl = "TooltipContent",
  nL = w.forwardRef((t, e) => {
    const n = O0e(Nl, t.__scopeTooltip),
      { forceMount: r = n.forceMount, side: i = "top", ...s } = t,
      o = df(Nl, t.__scopeTooltip);
    return E.jsx(DS, {
      present: r || o.open,
      children: o.disableHoverableContent ? E.jsx(rL, { side: i, ...s, ref: e }) : E.jsx(v0e, { side: i, ...s, ref: e }),
    });
  }),
  v0e = w.forwardRef((t, e) => {
    const n = df(Nl, t.__scopeTooltip),
      r = QS(Nl, t.__scopeTooltip),
      i = w.useRef(null),
      s = ff(e, i),
      [o, a] = w.useState(null),
      { trigger: l, onClose: c } = n,
      u = i.current,
      { onPointerInTransitChange: h } = r,
      f = w.useCallback(() => {
        a(null), h(!1);
      }, [h]),
      d = w.useCallback(
        (p, m) => {
          const O = p.currentTarget,
            v = { x: p.clientX, y: p.clientY },
            g = y0e(v, O.getBoundingClientRect()),
            x = w0e(v, g),
            y = S0e(m.getBoundingClientRect()),
            S = C0e([...x, ...y]);
          a(S), h(!0);
        },
        [h]
      );
    return (
      w.useEffect(() => () => f(), [f]),
      w.useEffect(() => {
        if (l && u) {
          const p = (O) => d(O, u),
            m = (O) => d(O, l);
          return (
            l.addEventListener("pointerleave", p),
            u.addEventListener("pointerleave", m),
            () => {
              l.removeEventListener("pointerleave", p), u.removeEventListener("pointerleave", m);
            }
          );
        }
      }, [l, u, d, f]),
      w.useEffect(() => {
        if (o) {
          const p = (m) => {
            const O = m.target,
              v = { x: m.clientX, y: m.clientY },
              g = (l == null ? void 0 : l.contains(O)) || (u == null ? void 0 : u.contains(O)),
              x = !k0e(v, o);
            g ? f() : x && (f(), c());
          };
          return document.addEventListener("pointermove", p), () => document.removeEventListener("pointermove", p);
        }
      }, [l, u, o, c, f]),
      E.jsx(rL, { ...t, ref: s })
    );
  }),
  [x0e, b0e] = Zg(Wg, { isInside: !1 }),
  rL = w.forwardRef((t, e) => {
    const { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: s, onPointerDownOutside: o, ...a } = t,
      l = df(Nl, n),
      c = zg(n),
      { onClose: u } = l;
    return (
      w.useEffect(() => (document.addEventListener($x, u), () => document.removeEventListener($x, u)), [u]),
      w.useEffect(() => {
        if (l.trigger) {
          const h = (f) => {
            const d = f.target;
            d != null && d.contains(l.trigger) && u();
          };
          return window.addEventListener("scroll", h, { capture: !0 }), () => window.removeEventListener("scroll", h, { capture: !0 });
        }
      }, [l.trigger, u]),
      E.jsx(HN, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        onFocusOutside: (h) => h.preventDefault(),
        onDismiss: u,
        children: E.jsxs(lN, {
          "data-state": l.stateAttribute,
          ...c,
          ...a,
          ref: e,
          style: {
            ...a.style,
            "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
            "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)",
          },
          children: [
            E.jsx(UN, { children: r }),
            E.jsx(x0e, { scope: n, isInside: !0, children: E.jsx(Kme, { id: l.contentId, role: "tooltip", children: i || r }) }),
          ],
        }),
      })
    );
  });
nL.displayName = Nl;
var iL = "TooltipArrow",
  sL = w.forwardRef((t, e) => {
    const { __scopeTooltip: n, ...r } = t,
      i = zg(n);
    return b0e(iL, n).isInside ? null : E.jsx(cN, { ...i, ...r, ref: e });
  });
sL.displayName = iL;
function y0e(t, e) {
  const n = Math.abs(e.top - t.y),
    r = Math.abs(e.bottom - t.y),
    i = Math.abs(e.right - t.x),
    s = Math.abs(e.left - t.x);
  switch (Math.min(n, r, i, s)) {
    case s:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function w0e(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push({ x: t.x - n, y: t.y + n }, { x: t.x + n, y: t.y + n });
      break;
    case "bottom":
      r.push({ x: t.x - n, y: t.y - n }, { x: t.x + n, y: t.y - n });
      break;
    case "left":
      r.push({ x: t.x + n, y: t.y - n }, { x: t.x + n, y: t.y + n });
      break;
    case "right":
      r.push({ x: t.x - n, y: t.y - n }, { x: t.x - n, y: t.y + n });
      break;
  }
  return r;
}
function S0e(t) {
  const { top: e, right: n, bottom: r, left: i } = t;
  return [
    { x: i, y: e },
    { x: n, y: e },
    { x: n, y: r },
    { x: i, y: r },
  ];
}
function k0e(t, e) {
  const { x: n, y: r } = t;
  let i = !1;
  for (let s = 0, o = e.length - 1; s < e.length; o = s++) {
    const a = e[s].x,
      l = e[s].y,
      c = e[o].x,
      u = e[o].y;
    l > r != u > r && n < ((c - a) * (r - l)) / (u - l) + a && (i = !i);
  }
  return i;
}
function C0e(t) {
  const e = t.slice();
  return e.sort((n, r) => (n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0)), _0e(e);
}
function _0e(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1],
        o = e[e.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x)) e.pop();
      else break;
    }
    e.push(i);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    for (; n.length >= 2; ) {
      const s = n[n.length - 1],
        o = n[n.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var oL = JN,
  aL = KN,
  lL = eL,
  cL = tL,
  uL = nL,
  E0e = sL;
const yo = C.forwardRef(({ title: t, children: e }, n) => {
    const r = yt(si);
    return C.createElement(
      oL,
      { delayDuration: 100 },
      C.createElement(
        aL,
        null,
        C.createElement(lL, { ref: n, asChild: !0 }, C.createElement("span", { className: F.tooltipTrigger }, e)),
        C.createElement(
          cL,
          { container: r == null ? void 0 : r.current },
          C.createElement(uL, { className: Ze(F.tooltipContent), sideOffset: 10 }, t)
        )
      )
    );
  }),
  VS = C.forwardRef(({ children: t, className: e, ...n }, r) =>
    C.createElement(Xge, { ...n, ref: r, className: Ze(e, F.selectItem) }, C.createElement(Hge, null, t))
  ),
  hL = ({ title: t, placeholder: e, className: n }) => {
    const [r, i] = nt(sn, ft);
    return C.createElement(
      yo,
      { title: t },
      C.createElement(
        jN,
        { "aria-label": e, className: Ze(F.selectTrigger, n), "data-toolbar-item": !0, disabled: r },
        C.createElement(Zge, { placeholder: e }),
        C.createElement(ZN, { className: F.selectDropdownArrow }, i("arrow_drop_down"))
      )
    );
  },
  BS = ({ children: t, className: e = F.selectContainer }) => {
    const n = yt(si);
    return C.createElement(
      zge,
      { container: n == null ? void 0 : n.current },
      C.createElement(
        Wge,
        {
          className: Ze(e, "mdxeditor-select-content"),
          onCloseAutoFocus: (r) => {
            r.preventDefault();
          },
          position: "popper",
        },
        C.createElement(Uge, { "data-editor-dropdown": !0 }, t)
      )
    );
  },
  fL = ({ children: t, title: e, className: n }) => {
    const [r, i] = nt(sn, ft);
    return C.createElement(
      yo,
      { title: e },
      C.createElement(
        jN,
        { className: Ze(F.toolbarButtonSelectTrigger, n), disabled: r },
        t,
        C.createElement(ZN, { className: F.selectDropdownArrow }, i("arrow_drop_down"))
      )
    );
  },
  pf = (t) =>
    C.createElement(
      BN,
      { value: t.value || void 0, onValueChange: t.onChange },
      C.createElement(hL, { title: t.triggerTitle, placeholder: t.placeholder }),
      C.createElement(
        BS,
        null,
        t.items.map((e, n) =>
          e === "separator" ? C.createElement(qge, { key: n }) : C.createElement(VS, { key: n, value: e.value }, e.label)
        )
      )
    ),
  T0e = [],
  TT = "__EMPTY_VALUE__",
  dL = ({ language: t, nodeKey: e, code: n, focusEmitter: r }) => {
    const i = lt(),
      { parentEditor: s, lexicalNode: o } = wl(),
      [a, l, c, u, h] = nt(sn, hm, fm, ft, uh),
      f = SI(e, "codeblock", t, r),
      { setCode: d } = wl(),
      p = C.useRef(null),
      m = C.useRef(null),
      O = C.useRef(d);
    return (
      (O.current = d),
      (f.current = { getCodemirror: () => p.current }),
      C.useEffect(
        () => (
          (async () => {
            const v = [
              ...l,
              VI,
              kI,
              kg(),
              re.lineWrapping,
              re.updateListener.of(({ state: g }) => {
                O.current(g.doc.toString());
              }),
            ];
            if ((a && v.push(Qe.readOnly.of(!0)), t !== "" && c)) {
              const g = dpe.find((x) => x.name === t || x.alias.includes(t) || x.extensions.includes(t));
              if (g)
                try {
                  const x = await g.load();
                  v.push(x.extension);
                } catch {
                  console.warn("failed to load language support for", t);
                }
            }
            (m.current.innerHTML = ""), (p.current = new re({ parent: m.current, state: Qe.create({ doc: n, extensions: v }) }));
          })(),
          () => {
            var v;
            (v = p.current) == null || v.destroy(), (p.current = null);
          }
        ),
        [a, t]
      ),
      C.createElement(
        "div",
        {
          className: F.codeMirrorWrapper,
          onKeyDown: (v) => {
            v.stopPropagation();
          },
        },
        C.createElement(
          "div",
          { className: F.codeMirrorToolbar },
          C.createElement(pf, {
            value: t,
            onChange: (v) => {
              s.update(() => {
                o.setLanguage(v === TT ? "" : v),
                  setTimeout(() => {
                    s.update(() => {
                      o.getLatest().select();
                    });
                  });
              });
            },
            triggerTitle: i("codeBlock.selectLanguage", "Select code block language"),
            placeholder: i("codeBlock.inlineLanguage", "Language"),
            items: Object.entries(h).map(([v, g]) => ({ value: v || TT, label: g })),
          }),
          C.createElement(
            "button",
            {
              className: F.iconButton,
              type: "button",
              title: i("codeblock.delete", "Delete code block"),
              onClick: (v) => {
                v.preventDefault(),
                  s.update(() => {
                    o.remove();
                  });
              },
            },
            u("delete_small")
          )
        ),
        C.createElement("div", { ref: m })
      )
    );
  },
  uh = Se({ js: "JavaScript", ts: "TypeScript", tsx: "TypeScript (React)", jsx: "JavaScript (React)", css: "CSS" }),
  pL = $t((t) => {
    t.link(
      t.pipe(
        pL,
        Rr(({ language: e, code: n }) => ({ code: n, language: e, meta: "" }))
      ),
      Kh
    );
  }),
  hm = Se([]),
  fm = Se(!0),
  P0e = en({
    update(t, e) {
      t.pubIn({
        [uh]: e == null ? void 0 : e.codeBlockLanguages,
        [hm]: (e == null ? void 0 : e.codeMirrorExtensions) ?? [],
        [fm]: (e == null ? void 0 : e.autoLoadLanguageSupport) ?? !0,
      });
    },
    init(t, e) {
      t.pubIn({
        [uh]: e == null ? void 0 : e.codeBlockLanguages,
        [hm]: (e == null ? void 0 : e.codeMirrorExtensions) ?? [],
        [yw]: A0e((e == null ? void 0 : e.codeBlockLanguages) ?? {}),
        [fm]: (e == null ? void 0 : e.autoLoadLanguageSupport) ?? !0,
      });
    },
  });
function A0e(t) {
  return {
    match(e, n) {
      return !!Object.hasOwn(t, e ?? "") && !n;
    },
    priority: 1,
    Editor: dL,
  };
}
const $0e = {}.hasOwnProperty,
  PT = /^[^\t\n\r "#'.<=>`}]+$/;
Bd.peek = F0e;
function R0e() {
  return {
    canContainEols: ["textDirective"],
    enter: {
      directiveContainer: N0e,
      directiveContainerAttributes: L1,
      directiveContainerLabel: D0e,
      directiveLeaf: L0e,
      directiveLeafAttributes: L1,
      directiveText: M0e,
      directiveTextAttributes: L1,
    },
    exit: {
      directiveContainer: B1,
      directiveContainerAttributeClassValue: D1,
      directiveContainerAttributeIdValue: M1,
      directiveContainerAttributeName: F1,
      directiveContainerAttributeValue: Q1,
      directiveContainerAttributes: V1,
      directiveContainerLabel: Q0e,
      directiveContainerName: N1,
      directiveLeaf: B1,
      directiveLeafAttributeClassValue: D1,
      directiveLeafAttributeIdValue: M1,
      directiveLeafAttributeName: F1,
      directiveLeafAttributeValue: Q1,
      directiveLeafAttributes: V1,
      directiveLeafName: N1,
      directiveText: B1,
      directiveTextAttributeClassValue: D1,
      directiveTextAttributeIdValue: M1,
      directiveTextAttributeName: F1,
      directiveTextAttributeValue: Q1,
      directiveTextAttributes: V1,
      directiveTextName: N1,
    },
  };
}
function I0e() {
  return {
    unsafe: [
      { character: "\r", inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"] },
      {
        character: `
`,
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"],
      },
      { before: "[^:]", character: ":", after: "[A-Za-z]", inConstruct: ["phrasing"] },
      { atBreak: !0, character: ":", after: ":" },
    ],
    handlers: { containerDirective: Bd, leafDirective: Bd, textDirective: Bd },
  };
}
function N0e(t) {
  jS.call(this, "containerDirective", t);
}
function L0e(t) {
  jS.call(this, "leafDirective", t);
}
function M0e(t) {
  jS.call(this, "textDirective", t);
}
function jS(t, e) {
  this.enter({ type: t, name: "", attributes: {}, children: [] }, e);
}
function N1(t) {
  const e = this.stack[this.stack.length - 1];
  e.type === "containerDirective" || e.type === "leafDirective" || e.type, (e.name = this.sliceSerialize(t));
}
function D0e(t) {
  this.enter({ type: "paragraph", data: { directiveLabel: !0 }, children: [] }, t);
}
function Q0e(t) {
  this.exit(t);
}
function L1() {
  (this.data.directiveAttributes = []), this.buffer();
}
function M1(t) {
  this.data.directiveAttributes.push(["id", Zm(this.sliceSerialize(t), { attribute: !0 })]);
}
function D1(t) {
  this.data.directiveAttributes.push(["class", Zm(this.sliceSerialize(t), { attribute: !0 })]);
}
function Q1(t) {
  const e = this.data.directiveAttributes;
  e[e.length - 1][1] = Zm(this.sliceSerialize(t), { attribute: !0 });
}
function F1(t) {
  this.data.directiveAttributes.push([this.sliceSerialize(t), ""]);
}
function V1() {
  const t = this.data.directiveAttributes,
    e = {};
  let n = -1;
  for (; ++n < t.length; ) {
    const i = t[n];
    i[0] === "class" && e.class ? (e.class += " " + i[1]) : (e[i[0]] = i[1]);
  }
  (this.data.directiveAttributes = void 0), this.resume();
  const r = this.stack[this.stack.length - 1];
  r.type === "containerDirective" || r.type === "leafDirective" || r.type, (r.attributes = e);
}
function B1(t) {
  this.exit(t);
}
function Bd(t, e, n, r) {
  const i = n.createTracker(r),
    s = B0e(t),
    o = n.enter(t.type);
  let a = i.move(s + (t.name || "")),
    l;
  if (t.type === "containerDirective") {
    const c = (t.children || [])[0];
    l = AT(c) ? c : void 0;
  } else l = t;
  if (l && l.children && l.children.length > 0) {
    const c = n.enter("label"),
      u = `${t.type}Label`,
      h = n.enter(u);
    (a += i.move("[")), (a += i.move(n.containerPhrasing(l, { ...i.current(), before: a, after: "]" }))), (a += i.move("]")), h(), c();
  }
  if (((a += i.move(V0e(t, n))), t.type === "containerDirective")) {
    const c = (t.children || [])[0];
    let u = t;
    AT(c) && (u = Object.assign({}, t, { children: t.children.slice(1) })),
      u &&
        u.children &&
        u.children.length > 0 &&
        ((a += i.move(`
`)),
        (a += i.move(n.containerFlow(u, i.current())))),
      (a += i.move(
        `
` + s
      ));
  }
  return o(), a;
}
function F0e() {
  return ":";
}
function V0e(t, e) {
  const n = e.options.quote || '"',
    r =
      t.type === "textDirective"
        ? [n]
        : [
            n,
            `
`,
            "\r",
          ],
    i = t.attributes || {},
    s = [];
  let o, a, l, c;
  for (c in i)
    if ($0e.call(i, c) && i[c] !== void 0 && i[c] !== null) {
      const h = String(i[c]);
      if (c === "id") l = PT.test(h) ? "#" + h : u("id", h);
      else if (c === "class") {
        const f = h.split(/[\t\n\r ]+/g),
          d = [],
          p = [];
        let m = -1;
        for (; ++m < f.length; ) (PT.test(f[m]) ? p : d).push(f[m]);
        (o = d.length > 0 ? u("class", d.join(" ")) : ""), (a = p.length > 0 ? "." + p.join(".") : "");
      } else s.push(u(c, h));
    }
  return o && s.unshift(o), a && s.unshift(a), l && s.unshift(l), s.length > 0 ? "{" + s.join(" ") + "}" : "";
  function u(h, f) {
    return h + (f ? "=" + n + Z3(f, { subset: r }) + n : "");
  }
}
function AT(t) {
  return !!(t && t.type === "paragraph" && t.data && t.data.directiveLabel);
}
function B0e(t) {
  let e = 0;
  return (
    t.type === "containerDirective"
      ? (rA(t, function (n, r) {
          if (n.type === "containerDirective") {
            let i = r.length,
              s = 0;
            for (; i--; ) r[i].type === "containerDirective" && s++;
            s > e && (e = s);
          }
        }),
        (e += 3))
      : t.type === "leafDirective"
      ? (e = 2)
      : (e = 1),
    ":".repeat(e)
  );
}
function ZS(t, e, n, r, i, s, o, a, l, c, u, h, f, d, p) {
  let m, O;
  return v;
  function v(N) {
    return t.enter(r), t.enter(i), t.consume(N), t.exit(i), g;
  }
  function g(N) {
    return N === 35
      ? ((m = o), x(N))
      : N === 46
      ? ((m = a), x(N))
      : N === 58 || N === 95 || fr(N)
      ? (t.enter(s), t.enter(l), t.consume(N), k)
      : p && Re(N)
      ? Me(t, g, "whitespace")(N)
      : !p && st(N)
      ? Ki(t, g)(N)
      : Q(N);
  }
  function x(N) {
    const G = m + "Marker";
    return t.enter(s), t.enter(m), t.enter(G), t.consume(N), t.exit(G), y;
  }
  function y(N) {
    if (N === null || N === 34 || N === 35 || N === 39 || N === 46 || N === 60 || N === 61 || N === 62 || N === 96 || N === 125 || st(N))
      return n(N);
    const G = m + "Value";
    return t.enter(G), t.consume(N), S;
  }
  function S(N) {
    if (N === null || N === 34 || N === 39 || N === 60 || N === 61 || N === 62 || N === 96) return n(N);
    if (N === 35 || N === 46 || N === 125 || st(N)) {
      const G = m + "Value";
      return t.exit(G), t.exit(m), t.exit(s), g(N);
    }
    return t.consume(N), S;
  }
  function k(N) {
    return N === 45 || N === 46 || N === 58 || N === 95 || pr(N)
      ? (t.consume(N), k)
      : (t.exit(l), p && Re(N) ? Me(t, b, "whitespace")(N) : !p && st(N) ? Ki(t, b)(N) : b(N));
  }
  function b(N) {
    return N === 61 ? (t.enter(c), t.consume(N), t.exit(c), _) : (t.exit(s), g(N));
  }
  function _(N) {
    return N === null || N === 60 || N === 61 || N === 62 || N === 96 || N === 125 || (p && de(N))
      ? n(N)
      : N === 34 || N === 39
      ? (t.enter(u), t.enter(f), t.consume(N), t.exit(f), (O = N), P)
      : p && Re(N)
      ? Me(t, _, "whitespace")(N)
      : !p && st(N)
      ? Ki(t, _)(N)
      : (t.enter(h), t.enter(d), t.consume(N), (O = void 0), T);
  }
  function T(N) {
    return N === null || N === 34 || N === 39 || N === 60 || N === 61 || N === 62 || N === 96
      ? n(N)
      : N === 125 || st(N)
      ? (t.exit(d), t.exit(h), t.exit(s), g(N))
      : (t.consume(N), T);
  }
  function P(N) {
    return N === O ? (t.enter(f), t.consume(N), t.exit(f), t.exit(u), t.exit(s), V) : (t.enter(h), M(N));
  }
  function M(N) {
    return N === O ? (t.exit(h), P(N)) : N === null ? n(N) : de(N) ? (p ? n(N) : Ki(t, M)(N)) : (t.enter(d), t.consume(N), D);
  }
  function D(N) {
    return N === O || N === null || de(N) ? (t.exit(d), M(N)) : (t.consume(N), D);
  }
  function V(N) {
    return N === 125 || st(N) ? g(N) : Q(N);
  }
  function Q(N) {
    return N === 125 ? (t.enter(i), t.consume(N), t.exit(i), t.exit(r), e) : n(N);
  }
}
function zS(t, e, n, r, i, s, o) {
  let a = 0,
    l = 0,
    c;
  return u;
  function u(O) {
    return t.enter(r), t.enter(i), t.consume(O), t.exit(i), h;
  }
  function h(O) {
    return O === 93 ? (t.enter(i), t.consume(O), t.exit(i), t.exit(r), e) : (t.enter(s), f(O));
  }
  function f(O) {
    if (O === 93 && !l) return m(O);
    const v = t.enter("chunkText", { contentType: "text", previous: c });
    return c && (c.next = v), (c = v), d(O);
  }
  function d(O) {
    return O === null || a > 999 || (O === 91 && ++l > 32)
      ? n(O)
      : O === 93 && !l--
      ? (t.exit("chunkText"), m(O))
      : de(O)
      ? o
        ? n(O)
        : (t.consume(O), t.exit("chunkText"), f)
      : (t.consume(O), O === 92 ? p : d);
  }
  function p(O) {
    return O === 91 || O === 92 || O === 93 ? (t.consume(O), a++, d) : d(O);
  }
  function m(O) {
    return t.exit(s), t.enter(i), t.consume(O), t.exit(i), t.exit(r), e;
  }
}
function WS(t, e, n, r) {
  const i = this;
  return s;
  function s(a) {
    return fr(a) ? (t.enter(r), t.consume(a), o) : n(a);
  }
  function o(a) {
    return a === 45 || a === 95 || pr(a) ? (t.consume(a), o) : (t.exit(r), i.previous === 45 || i.previous === 95 ? n(a) : e(a));
  }
}
const j0e = { tokenize: W0e, concrete: !0 },
  Z0e = { tokenize: U0e, partial: !0 },
  z0e = { tokenize: X0e, partial: !0 },
  $T = { tokenize: H0e, partial: !0 };
function W0e(t, e, n) {
  const r = this,
    i = r.events[r.events.length - 1],
    s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0,
    a;
  return l;
  function l(b) {
    return t.enter("directiveContainer"), t.enter("directiveContainerFence"), t.enter("directiveContainerSequence"), c(b);
  }
  function c(b) {
    return b === 58
      ? (t.consume(b), o++, c)
      : o < 3
      ? n(b)
      : (t.exit("directiveContainerSequence"), WS.call(r, t, u, n, "directiveContainerName")(b));
  }
  function u(b) {
    return b === 91 ? t.attempt(Z0e, h, h)(b) : h(b);
  }
  function h(b) {
    return b === 123 ? t.attempt(z0e, f, f)(b) : f(b);
  }
  function f(b) {
    return Me(t, d, "whitespace")(b);
  }
  function d(b) {
    return t.exit("directiveContainerFence"), b === null ? p(b) : de(b) ? (r.interrupt ? e(b) : t.attempt($T, m, p)(b)) : n(b);
  }
  function p(b) {
    return t.exit("directiveContainer"), e(b);
  }
  function m(b) {
    return b === null ? (t.exit("directiveContainer"), e(b)) : (t.enter("directiveContainerContent"), O(b));
  }
  function O(b) {
    return b === null ? S(b) : t.attempt({ tokenize: k, partial: !0 }, S, s ? Me(t, v, "linePrefix", s + 1) : v)(b);
  }
  function v(b) {
    if (b === null) return S(b);
    const _ = t.enter("chunkDocument", { contentType: "document", previous: a });
    return a && (a.next = _), (a = _), g(b);
  }
  function g(b) {
    if (b === null) {
      const _ = t.exit("chunkDocument");
      return (r.parser.lazy[_.start.line] = !1), S(b);
    }
    return de(b) ? t.check($T, x, y)(b) : (t.consume(b), g);
  }
  function x(b) {
    t.consume(b);
    const _ = t.exit("chunkDocument");
    return (r.parser.lazy[_.start.line] = !1), O;
  }
  function y(b) {
    const _ = t.exit("chunkDocument");
    return (r.parser.lazy[_.start.line] = !1), S(b);
  }
  function S(b) {
    return t.exit("directiveContainerContent"), t.exit("directiveContainer"), e(b);
  }
  function k(b, _, T) {
    let P = 0;
    return Me(b, M, "linePrefix", 4);
    function M(Q) {
      return b.enter("directiveContainerFence"), b.enter("directiveContainerSequence"), D(Q);
    }
    function D(Q) {
      return Q === 58 ? (b.consume(Q), P++, D) : P < o ? T(Q) : (b.exit("directiveContainerSequence"), Me(b, V, "whitespace")(Q));
    }
    function V(Q) {
      return Q === null || de(Q) ? (b.exit("directiveContainerFence"), _(Q)) : T(Q);
    }
  }
}
function U0e(t, e, n) {
  return zS(t, e, n, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", !0);
}
function X0e(t, e, n) {
  return ZS(
    t,
    e,
    n,
    "directiveContainerAttributes",
    "directiveContainerAttributesMarker",
    "directiveContainerAttribute",
    "directiveContainerAttributeId",
    "directiveContainerAttributeClass",
    "directiveContainerAttributeName",
    "directiveContainerAttributeInitializerMarker",
    "directiveContainerAttributeValueLiteral",
    "directiveContainerAttributeValue",
    "directiveContainerAttributeValueMarker",
    "directiveContainerAttributeValueData",
    !0
  );
}
function H0e(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), s;
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : e(o);
  }
}
const q0e = { tokenize: J0e },
  Y0e = { tokenize: K0e, partial: !0 },
  G0e = { tokenize: e1e, partial: !0 };
function J0e(t, e, n) {
  const r = this;
  return i;
  function i(u) {
    return t.enter("directiveLeaf"), t.enter("directiveLeafSequence"), t.consume(u), s;
  }
  function s(u) {
    return u === 58 ? (t.consume(u), t.exit("directiveLeafSequence"), WS.call(r, t, o, n, "directiveLeafName")) : n(u);
  }
  function o(u) {
    return u === 91 ? t.attempt(Y0e, a, a)(u) : a(u);
  }
  function a(u) {
    return u === 123 ? t.attempt(G0e, l, l)(u) : l(u);
  }
  function l(u) {
    return Me(t, c, "whitespace")(u);
  }
  function c(u) {
    return u === null || de(u) ? (t.exit("directiveLeaf"), e(u)) : n(u);
  }
}
function K0e(t, e, n) {
  return zS(t, e, n, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", !0);
}
function e1e(t, e, n) {
  return ZS(
    t,
    e,
    n,
    "directiveLeafAttributes",
    "directiveLeafAttributesMarker",
    "directiveLeafAttribute",
    "directiveLeafAttributeId",
    "directiveLeafAttributeClass",
    "directiveLeafAttributeName",
    "directiveLeafAttributeInitializerMarker",
    "directiveLeafAttributeValueLiteral",
    "directiveLeafAttributeValue",
    "directiveLeafAttributeValueMarker",
    "directiveLeafAttributeValueData",
    !0
  );
}
const t1e = { tokenize: s1e, previous: i1e },
  n1e = { tokenize: o1e, partial: !0 },
  r1e = { tokenize: a1e, partial: !0 };
function i1e(t) {
  return t !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function s1e(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return (
      t.enter("directiveText"),
      t.enter("directiveTextMarker"),
      t.consume(l),
      t.exit("directiveTextMarker"),
      WS.call(r, t, s, n, "directiveTextName")
    );
  }
  function s(l) {
    return l === 58 ? n(l) : l === 91 ? t.attempt(n1e, o, o)(l) : o(l);
  }
  function o(l) {
    return l === 123 ? t.attempt(r1e, a, a)(l) : a(l);
  }
  function a(l) {
    return t.exit("directiveText"), e(l);
  }
}
function o1e(t, e, n) {
  return zS(t, e, n, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function a1e(t, e, n) {
  return ZS(
    t,
    e,
    n,
    "directiveTextAttributes",
    "directiveTextAttributesMarker",
    "directiveTextAttribute",
    "directiveTextAttributeId",
    "directiveTextAttributeClass",
    "directiveTextAttributeName",
    "directiveTextAttributeInitializerMarker",
    "directiveTextAttributeValueLiteral",
    "directiveTextAttributeValue",
    "directiveTextAttributeValueMarker",
    "directiveTextAttributeValueData"
  );
}
function l1e() {
  return { text: { 58: t1e }, flow: { 58: [j0e, q0e] } };
}
var c1e = Object.defineProperty,
  u1e = (t, e, n) => (e in t ? c1e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  j1 = (t, e, n) => (u1e(t, typeof e != "symbol" ? e + "" : e, n), n);
class fc extends Mi {
  constructor(e, n) {
    super(n),
      j1(this, "__mdastNode"),
      j1(this, "__focusEmitter", bg()),
      j1(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__mdastNode = e);
  }
  static getType() {
    return "directive";
  }
  static clone(e) {
    return new fc(structuredClone(e.__mdastNode), e.__key);
  }
  static importJSON(e) {
    return Ug(e.mdastNode);
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  exportJSON() {
    return { mdastNode: structuredClone(this.__mdastNode), type: "directive", version: 1 };
  }
  createDOM() {
    return document.createElement(this.__mdastNode.type === "textDirective" ? "span" : "div");
  }
  updateDOM() {
    return !1;
  }
  setMdastNode(e) {
    this.getWritable().__mdastNode = e;
  }
  decorate(e, n) {
    return C.createElement(h1e, {
      lexicalNode: this,
      mdastNode: this.getMdastNode(),
      parentEditor: e,
      config: n,
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return this.__mdastNode.type === "textDirective";
  }
  isKeyboardSelectable() {
    return !0;
  }
}
const h1e = (t) => {
  const { mdastNode: e } = t,
    [n] = nt(zo),
    r = n.find((s) => s.testNode(e));
  if (!r) throw new Error(`No descriptor found for directive ${e.name}`);
  const i = r.Editor;
  return C.createElement(
    Og.Provider,
    { value: t },
    C.createElement(i, { descriptor: r, mdastNode: e, lexicalNode: t.lexicalNode, parentEditor: t.parentEditor })
  );
};
function Ug(t, e) {
  return new fc(t, e);
}
function mL(t) {
  return t instanceof fc;
}
const f1e = {
    testLexicalNode: mL,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      t.appendToParent(e, n.getMdastNode());
    },
  },
  d1e = ["leafDirective", "containerDirective", "textDirective"];
function p1e(t) {
  return d1e.includes(t.type);
}
const m1e = {
    testNode: (t, { directiveDescriptors: e }) => (p1e(t) ? e.find((r) => r.testNode(t)) !== void 0 : !1),
    visitNode({ lexicalParent: t, mdastNode: e }) {
      t.append(Ug(e));
    },
  },
  US = $t((t) => {
    t.link(
      t.pipe(
        US,
        Rr((e) => () => Ug({ children: [], ...e }))
      ),
      Hl
    );
  }),
  g1e = en({
    update: (t, e) => {
      t.pub(zo, (e == null ? void 0 : e.directiveDescriptors) ?? []);
    },
    init: (t, e) => {
      t.pubIn({
        [zo]: (e == null ? void 0 : e.directiveDescriptors) ?? [],
        [eo]: R0e(),
        [Ks]: l1e(),
        [rr]: m1e,
        [vr]: fc,
        [xr]: f1e,
        [fa]: I0e(),
      });
    },
  }),
  Xg = ["note", "tip", "danger", "info", "caution"],
  O1e = {
    name: "admonition",
    attributes: [],
    hasChildren: !0,
    testNode(t) {
      return Xg.includes(t.name);
    },
    Editor({ mdastNode: t }) {
      const {
        config: { theme: e },
      } = qh();
      return C.createElement(
        "div",
        { className: e.admonition[t.name] },
        C.createElement(xg, { block: !0, getContent: (n) => n.children, getUpdatedMdastNode: (n, r) => ({ ...n, children: r }) })
      );
    },
  },
  v1e = ({ mdastNode: t, descriptor: e }) => {
    const n = vg(),
      r = C.useMemo(
        () =>
          e.attributes.reduce((s, o) => {
            var a;
            return (s[o] = ((a = t.attributes) == null ? void 0 : a[o]) ?? ""), s;
          }, {}),
        [t, e]
      ),
      i = C.useCallback(
        (s) => {
          n({ attributes: Object.fromEntries(Object.entries(s).filter(([, o]) => o !== "")) });
        },
        [n]
      );
    return C.createElement(
      "div",
      { className: t.type === "textDirective" ? F.inlineEditor : F.blockEditor },
      e.attributes.length == 0 && e.hasChildren && t.type !== "textDirective"
        ? C.createElement("span", { className: F.genericComponentName }, t.name)
        : null,
      e.attributes.length > 0 ? C.createElement(bw, { properties: r, title: t.name || "", onChange: i }) : null,
      e.hasChildren
        ? C.createElement(xg, {
            block: t.type === "containerDirective",
            getContent: (s) => s.children,
            getUpdatedMdastNode: (s, o) => ({ ...s, children: o }),
          })
        : C.createElement("span", { className: F.genericComponentName }, t.name)
    );
  };
function x1e(t, e) {
  let n = null;
  return (
    t.getEditorState().read(() => {
      n = e();
    }),
    n
  );
}
function gL(t) {
  try {
    const e = t.anchor,
      n = t.focus,
      r = t.anchor.getNode(),
      i = t.focus.getNode();
    return r === i ? r : t.isBackward() ? (e2(n) ? r : i) : e2(e) ? r : i;
  } catch {
    return null;
  }
}
function XS(t) {
  const e = ce(),
    n = window.getSelection(),
    r = document.activeElement,
    i = t.getRootElement();
  if (e !== null && n !== null && i !== null && i.contains(n.anchorNode) && t.isEditable()) {
    const s = n.getRangeAt(0);
    let o;
    if (n.isCollapsed) {
      let a = n.anchorNode;
      (a == null ? void 0 : a.nodeType) == 3 && (a = a.parentNode), (o = a.getBoundingClientRect()), (o.width = 0);
    } else if (n.anchorNode === i) {
      let a = i;
      for (; a.firstElementChild != null; ) a = a.firstElementChild;
      o = a.getBoundingClientRect();
    } else o = s.getBoundingClientRect();
    return { top: Math.round(o.top), left: Math.round(o.left), width: Math.round(o.width), height: Math.round(o.height) };
  } else if (!r || r.className !== "link-input") return null;
  return null;
}
function b1e(t, e) {
  return Jx({ markdown: "" }, (n) => {
    t.getEditorState().read(() => {
      n.markdown = jb({ root: Be(), ...e });
    });
  }).markdown;
}
function y1e({ url: t, title: e, onSubmit: n, onCancel: r, linkAutocompleteSuggestions: i }) {
  const { register: s, handleSubmit: o, control: a, setValue: l, reset: c } = vm({ values: { url: t, title: e } }),
    u = lt();
  return C.createElement(
    "form",
    {
      onSubmit: (h) => {
        o(n)(h), h.stopPropagation(), h.preventDefault();
      },
      onReset: (h) => {
        h.stopPropagation(), r();
      },
      className: Ze(F.multiFieldForm, F.linkDialogEditForm),
    },
    C.createElement(
      "div",
      { className: F.formField },
      C.createElement("label", { htmlFor: "link-url" }, u("createLink.url", "URL")),
      C.createElement($9, {
        register: s,
        initialInputValue: t,
        inputName: "url",
        suggestions: i,
        setValue: l,
        control: a,
        placeholder: u("createLink.urlPlaceholder", "Select or paste an URL"),
        autofocus: !0,
      })
    ),
    C.createElement(
      "div",
      { className: F.formField },
      C.createElement("label", { htmlFor: "link-title" }, u("createLink.title", "Title")),
      C.createElement("input", { id: "link-title", className: F.textInput, size: 40, ...s("title") })
    ),
    C.createElement(
      "div",
      { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
      C.createElement(
        "button",
        {
          type: "submit",
          title: u("createLink.saveTooltip", "Set URL"),
          "aria-label": u("createLink.saveTooltip", "Set URL"),
          className: Ze(F.primaryButton),
        },
        u("dialogControls.save", "Save")
      ),
      C.createElement(
        "button",
        {
          type: "reset",
          title: u("createLink.cancelTooltip", "Cancel change"),
          "aria-label": u("createLink.cancelTooltip", "Cancel change"),
          className: Ze(F.secondaryButton),
        },
        u("dialogControls.cancel", "Cancel")
      )
    )
  );
}
const w1e = () => {
    const [t, e, n, r, i, s] = nt(si, At, ft, Nn, KS, ek),
      o = tt(HS),
      a = tt(qS),
      l = tt(YS),
      c = tt(GS),
      u = tt(JS);
    C.useEffect(() => {
      const O = () => {
        e == null ||
          e.getEditorState().read(() => {
            o(!0);
          });
      };
      return (
        window.addEventListener("resize", O),
        window.addEventListener("scroll", O),
        () => {
          window.removeEventListener("resize", O), window.removeEventListener("scroll", O);
        }
      );
    }, [e, o]);
    const [h, f] = C.useState(!1),
      d = lt(),
      p = r.rectangle,
      m = r.type === "preview" && r.url.startsWith("http");
    return C.createElement(
      mm,
      { open: r.type !== "inactive" },
      C.createElement(lD, {
        "data-visible": r.type === "edit",
        className: F.linkDialogAnchor,
        style: {
          top: `${(p == null ? void 0 : p.top) ?? 0}px`,
          left: `${(p == null ? void 0 : p.left) ?? 0}px`,
          width: `${(p == null ? void 0 : p.width) ?? 0}px`,
          height: `${(p == null ? void 0 : p.height) ?? 0}px`,
        },
      }),
      C.createElement(
        gm,
        { container: t == null ? void 0 : t.current },
        C.createElement(
          CP,
          {
            className: Ze(F.linkDialogPopoverContent),
            sideOffset: 5,
            onOpenAutoFocus: (O) => {
              O.preventDefault();
            },
            key: r.linkNodeKey,
          },
          r.type === "edit" &&
            C.createElement(y1e, { url: r.url, title: r.title, onSubmit: a, onCancel: l.bind(null), linkAutocompleteSuggestions: i }),
          r.type === "preview" &&
            C.createElement(
              C.Fragment,
              null,
              C.createElement(
                "a",
                {
                  className: F.linkDialogPreviewAnchor,
                  href: r.url,
                  ...(m ? { target: "_blank", rel: "noreferrer" } : {}),
                  onClick: (O) => {
                    s !== null && (O.preventDefault(), s(r.url));
                  },
                  title: m ? d("linkPreview.open", "Open {{url}} in new window", { url: r.url }) : r.url,
                },
                C.createElement("span", null, r.url),
                m && n("open_in_new")
              ),
              C.createElement(
                Z1,
                {
                  onClick: () => {
                    c();
                  },
                  title: d("linkPreview.edit", "Edit link URL"),
                  "aria-label": d("linkPreview.edit", "Edit link URL"),
                },
                n("edit")
              ),
              C.createElement(
                oL,
                null,
                C.createElement(
                  aL,
                  { open: h },
                  C.createElement(
                    lL,
                    { asChild: !0 },
                    C.createElement(
                      Z1,
                      {
                        title: d("linkPreview.copyToClipboard", "Copy to clipboard"),
                        "aria-label": d("linkPreview.copyToClipboard", "Copy to clipboard"),
                        onClick: () => {
                          window.navigator.clipboard.writeText(r.url).then(() => {
                            f(!0),
                              setTimeout(() => {
                                f(!1);
                              }, 1e3);
                          });
                        },
                      },
                      n(h ? "check" : "content_copy")
                    )
                  ),
                  C.createElement(
                    cL,
                    { container: t == null ? void 0 : t.current },
                    C.createElement(
                      uL,
                      { className: Ze(F.tooltipContent), sideOffset: 5 },
                      d("linkPreview.copied", "Copied!"),
                      C.createElement(E0e, null)
                    )
                  )
                )
              ),
              C.createElement(
                Z1,
                {
                  title: d("linkPreview.remove", "Remove link"),
                  "aria-label": d("linkPreview.remove", "Remove link"),
                  onClick: () => {
                    u();
                  },
                },
                n("link_off")
              )
            ),
          C.createElement(Om, { className: F.popoverArrow })
        )
      )
    );
  },
  Z1 = C.forwardRef(({ className: t, ...e }, n) => C.createElement("button", { className: Ze(F.actionButton, t), ref: n, ...e }));
function Ix(t) {
  if (!t) return null;
  const e = gL(t);
  if (e === null) return null;
  const n = e.getParent();
  return xi(n) ? n : xi(e) ? e : null;
}
const HS = $t(),
  Nn = Se({ type: "inactive" }, (t) => {
    t.pub(Eu, (e) => e.registerCommand(Oh, () => (t.getValue(Nn).type === "preview" ? (t.pub(Nn, { type: "inactive" }), !0) : !1), Ot)),
      t.pub(Eu, (e) =>
        e.registerCommand(
          DP,
          (n) => {
            if (n.key === "k" && (_u ? n.metaKey : n.ctrlKey) && !t.getValue(sn)) {
              const r = ce();
              return ee(r) ? (t.pub(Hg), n.stopPropagation(), n.preventDefault(), !0) : !1;
            }
            return !1;
          },
          sp
        )
      ),
      t.link(
        t.pipe(
          GS,
          bt(Nn),
          Rr(([, e]) => {
            if (e.type === "preview")
              return { type: "edit", initialUrl: e.url, url: e.url, title: e.title, linkNodeKey: e.linkNodeKey, rectangle: e.rectangle };
            throw new Error("Cannot switch to edit mode when not in preview mode");
          })
        ),
        Nn
      ),
      t.sub(t.pipe(qS, bt(At, Nn, Zo)), ([e, n, r, i]) => {
        var s, o;
        const a = ((s = e.url) == null ? void 0 : s.trim()) ?? "",
          l = ((o = e.title) == null ? void 0 : o.trim()) ?? "";
        if (a !== "") {
          if (i != null && i.isCollapsed()) {
            const c = l || a;
            n == null ||
              n.update(
                () => {
                  const u = Ix(i);
                  if (u) u.setURL(a), u.setTitle(l);
                  else {
                    const h = Xo(a, { title: l });
                    h.append(Et(c)), Zl([h]), h.select();
                  }
                },
                { discrete: !0 }
              );
          } else n == null || n.dispatchCommand(xl, { url: a, title: l });
          t.pub(Nn, { type: "preview", linkNodeKey: r.linkNodeKey, rectangle: r.rectangle, title: l, url: a });
        } else r.type === "edit" && r.initialUrl !== "" && (n == null || n.dispatchCommand(xl, null)), t.pub(Nn, { type: "inactive" });
      }),
      t.link(
        t.pipe(
          YS,
          bt(Nn, At),
          Rr(([, e, n]) => {
            if (e.type === "edit")
              return (
                n == null || n.focus(),
                e.initialUrl === ""
                  ? { type: "inactive" }
                  : { type: "preview", url: e.initialUrl, linkNodeKey: e.linkNodeKey, rectangle: e.rectangle }
              );
            throw new Error("Cannot cancel edit when not in edit mode");
          })
        ),
        Nn
      ),
      t.link(
        t.pipe(
          t.combine(Zo, HS),
          bt(At, Nn, sn),
          Rr(([[e], n, r, i]) => {
            if (ee(e) && n && !i) {
              const s = Ix(e);
              return s
                ? { type: "preview", url: s.getURL(), linkNodeKey: s.getKey(), title: s.getTitle(), rectangle: XS(n) }
                : { type: "inactive" };
            } else return { type: "inactive" };
          })
        ),
        Nn
      );
  }),
  qS = $t(),
  YS = ni(),
  S1e = ni(),
  GS = ni(),
  JS = ni((t) => {
    t.sub(t.pipe(JS, bt(At)), ([, e]) => {
      e == null || e.dispatchCommand(xl, null);
    });
  }),
  Hg = ni((t) => {
    t.sub(
      t.pipe(
        Hg,
        bt(Zo, At),
        Vl(([, e]) => ee(e))
      ),
      ([, e, n]) => {
        n == null ||
          n.focus(() => {
            n.getEditorState().read(() => {
              const r = Ix(e),
                i = XS(n);
              r
                ? t.pub(Nn, {
                    type: "edit",
                    initialUrl: r.getURL(),
                    initialTitle: r.getTitle() ?? "",
                    url: r.getURL(),
                    title: r.getTitle() ?? "",
                    linkNodeKey: r.getKey(),
                    rectangle: i,
                  })
                : t.pub(Nn, { type: "edit", initialUrl: "", initialTitle: "", title: "", url: "", linkNodeKey: "", rectangle: i });
            });
          });
      }
    );
  }),
  KS = Se([]),
  ek = Se(null),
  k1e = en({
    init(t, e) {
      t.pub(fo, (e == null ? void 0 : e.LinkDialog) ?? w1e), t.pub(ek, (e == null ? void 0 : e.onClickLinkCallback) ?? null);
    },
    update(t, e = {}) {
      t.pub(KS, e.linkAutocompleteSuggestions ?? []);
    },
  });
function tk(t, e) {
  return C.forwardRef((n, r) => {
    const i = Ze(e.className, n.className);
    return C.createElement(t, { ...e, ...n, className: i, ref: r });
  });
}
function C1e(t) {
  return ({ title: e, children: n, ...r }) => C.createElement(t, { ...r }, C.createElement(yo, { title: e }, n));
}
const OL = ({ readOnly: t, children: e }) =>
    C.createElement(
      wy,
      { className: Ze("mdxeditor-toolbar", F.toolbarRoot, { [F.readOnlyToolbarRoot]: t }), ...(t ? { tabIndex: -1 } : {}) },
      e
    ),
  vL = tk(ns, { className: F.toolbarButton, "data-toolbar-item": !0 }),
  wo = C1e(vL),
  nk = tk(Cd, { className: F.toolbarToggleItem, "data-toolbar-item": !0 }),
  _1e = tk(rg, { type: "single", className: F.toolbarToggleSingleGroup }),
  rk = C.forwardRef(({ on: t, title: e, children: n, disabled: r, ...i }, s) =>
    C.createElement(
      rg,
      { type: "single", className: F.toolbarToggleSingleGroup, ...i, value: t ? "on" : "off", ref: s },
      C.createElement(nk, { title: e, value: "on", disabled: r }, C.createElement(yo, { title: e }, n))
    )
  ),
  ik = ({ items: t }) =>
    C.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      t.map((e, n) =>
        C.createElement(
          rk,
          {
            key: n,
            title: e.title,
            on: e.active,
            onValueChange: (r) => {
              e.onChange(r === "on");
            },
            disabled: e.disabled,
          },
          e.contents
        )
      )
    ),
  sk = ({ value: t, onChange: e, className: n, items: r }) => {
    const i = lt();
    return C.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      C.createElement(
        rg,
        {
          "aria-label": i("toolbar.toggleGroup", "toggle group"),
          type: "single",
          className: Ze(F.toolbarToggleSingleGroup, n),
          onValueChange: e,
          value: t || "",
          onFocus: (s) => {
            s.preventDefault();
          },
        },
        r.map((s, o) =>
          C.createElement(nk, { key: o, "aria-label": s.title, value: s.value }, C.createElement(yo, { title: s.title }, s.contents))
        )
      )
    );
  },
  ok = (t) => {
    const e = yt(sn);
    return C.createElement(
      C.Fragment,
      null,
      t.items.length === 1
        ? C.createElement(
            wo,
            {
              title: t.title,
              onClick: () => {
                t.onChoose("");
              },
              disabled: e,
            },
            t.children
          )
        : C.createElement(
            BN,
            { value: "", onValueChange: t.onChoose },
            C.createElement(fL, { title: t.title }, t.children),
            C.createElement(
              BS,
              { className: F.toolbarButtonDropdownContainer },
              t.items.map((n, r) => C.createElement(VS, { key: r, value: n.value }, n.label))
            )
          )
    );
  };
function RT(t) {
  return Object.hasOwn(t, "when");
}
const jd = ({ options: t }) => {
    const e = yt(ho),
      n = C.useMemo(() => {
        const r = t.find((i) => {
          if (RT(i)) {
            if (i.when(e)) return !0;
          } else return !0;
        });
        return r ? (RT(r) ? r.contents() : r.fallback()) : null;
      }, [t, e]);
    return C.createElement("div", { style: { display: "flex" } }, n);
  },
  Oi = L$,
  Zd = Se(() => null),
  IT = () =>
    "This is an empty toolbar. Pass `{toolbarContents: () => { return <>toolbar components</> }}` to the toolbarPlugin to customize it.",
  E1e = en({
    init(t, e) {
      t.pubIn({
        [Zd]: (e == null ? void 0 : e.toolbarContents) ?? IT,
        [QA]: () => {
          const [n, r] = nt(Zd, sn);
          return C.createElement(OL, { readOnly: r }, n());
        },
      });
    },
    update(t, e) {
      t.pub(Zd, (e == null ? void 0 : e.toolbarContents) ?? IT);
    },
  });
class Zt {
  constructor(e, n, r, i) {
    (this.fromA = e), (this.toA = n), (this.fromB = r), (this.toB = i);
  }
  offset(e, n) {
    return new Zt(this.fromA + e, this.toA + e, this.fromB + n, this.toB + n);
  }
}
function la(t, e, n, r, i, s) {
  if (t == r) return [];
  let o = ak(t, e, n, r, i, s),
    a = lk(t, e + o, n, r, i + o, s);
  (e += o), (n -= a), (i += o), (s -= a);
  let l = n - e,
    c = s - i;
  if (!l || !c) return [new Zt(e, n, i, s)];
  if (l > c) {
    let h = t.slice(e, n).indexOf(r.slice(i, s));
    if (h > -1) return [new Zt(e, e + h, i, i), new Zt(e + h + c, n, s, s)];
  } else if (c > l) {
    let h = r.slice(i, s).indexOf(t.slice(e, n));
    if (h > -1) return [new Zt(e, e, i, i + h), new Zt(n, n, i + h + l, s)];
  }
  if (l == 1 || c == 1) return [new Zt(e, n, i, s)];
  let u = yL(t, e, n, r, i, s);
  if (u) {
    let [h, f, d] = u;
    return la(t, e, h, r, i, f).concat(la(t, h + d, n, r, f + d, s));
  }
  return T1e(t, e, n, r, i, s);
}
let Yc = 1e9;
function T1e(t, e, n, r, i, s) {
  let o = n - e,
    a = s - i;
  if (Yc < 1e9 && Math.min(o, a) > Yc * 16) return Math.min(o, a) > Yc * 64 ? [new Zt(e, n, i, s)] : NT(t, e, n, r, i, s);
  let l = Math.ceil((o + a) / 2);
  z1.reset(l), W1.reset(l);
  let c = (d, p) => t.charCodeAt(e + d) == r.charCodeAt(i + p),
    u = (d, p) => t.charCodeAt(n - d - 1) == r.charCodeAt(s - p - 1),
    h = (o - a) % 2 != 0 ? W1 : null,
    f = h ? null : z1;
  for (let d = 0; d < l; d++) {
    if (d > Yc) return NT(t, e, n, r, i, s);
    let p = z1.advance(d, o, a, l, h, !1, c) || W1.advance(d, o, a, l, f, !0, u);
    if (p) return P1e(t, e, n, e + p[0], r, i, s, i + p[1]);
  }
  return [new Zt(e, n, i, s)];
}
class xL {
  constructor() {
    this.vec = [];
  }
  reset(e) {
    this.len = e << 1;
    for (let n = 0; n < this.len; n++) this.vec[n] = -1;
    (this.vec[e + 1] = 0), (this.start = this.end = 0);
  }
  advance(e, n, r, i, s, o, a) {
    for (let l = -e + this.start; l <= e - this.end; l += 2) {
      let c = i + l,
        u = l == -e || (l != e && this.vec[c - 1] < this.vec[c + 1]) ? this.vec[c + 1] : this.vec[c - 1] + 1,
        h = u - l;
      for (; u < n && h < r && a(u, h); ) u++, h++;
      if (((this.vec[c] = u), u > n)) this.end += 2;
      else if (h > r) this.start += 2;
      else if (s) {
        let f = i + (n - r) - l;
        if (f >= 0 && f < this.len && s.vec[f] != -1)
          if (o) {
            let d = s.vec[f];
            if (d >= n - u) return [d, i + d - f];
          } else {
            let d = n - s.vec[f];
            if (u >= d) return [u, h];
          }
      }
    }
    return null;
  }
}
const z1 = new xL(),
  W1 = new xL();
function P1e(t, e, n, r, i, s, o, a) {
  let l = !1;
  return (
    !Ll(t, r) && ++r == n && (l = !0),
    !Ll(i, a) && ++a == o && (l = !0),
    l ? [new Zt(e, n, s, o)] : la(t, e, r, i, s, a).concat(la(t, r, n, i, a, o))
  );
}
function bL(t, e) {
  let n = 1,
    r = Math.min(t, e);
  for (; n < r; ) n = n << 1;
  return n;
}
function ak(t, e, n, r, i, s) {
  if (e == n || e == s || t.charCodeAt(e) != r.charCodeAt(i)) return 0;
  let o = bL(n - e, s - i);
  for (let a = e, l = i; ; ) {
    let c = a + o,
      u = l + o;
    if (c > n || u > s || t.slice(a, c) != r.slice(l, u)) {
      if (o == 1) return a - e - (Ll(t, a) ? 0 : 1);
      o = o >> 1;
    } else {
      if (c == n || u == s) return c - e;
      (a = c), (l = u);
    }
  }
}
function lk(t, e, n, r, i, s) {
  if (e == n || i == s || t.charCodeAt(n - 1) != r.charCodeAt(s - 1)) return 0;
  let o = bL(n - e, s - i);
  for (let a = n, l = s; ; ) {
    let c = a - o,
      u = l - o;
    if (c < e || u < i || t.slice(c, a) != r.slice(u, l)) {
      if (o == 1) return n - a - (Ll(t, a) ? 0 : 1);
      o = o >> 1;
    } else {
      if (c == e || u == i) return n - c;
      (a = c), (l = u);
    }
  }
}
function Nx(t, e, n, r, i, s, o, a) {
  let l = r.slice(i, s),
    c = null;
  for (;;) {
    if (c || o < a) return c;
    for (let u = e + o; ; ) {
      Ll(t, u) || u++;
      let h = u + o;
      if ((Ll(t, h) || (h += h == u + 1 ? 1 : -1), h >= n)) break;
      let f = t.slice(u, h),
        d = -1;
      for (; (d = l.indexOf(f, d + 1)) != -1; ) {
        let p = ak(t, h, n, r, i + d + f.length, s),
          m = lk(t, e, u, r, i, i + d),
          O = f.length + p + m;
        (!c || c[2] < O) && (c = [u - m, i + d - m, O]);
      }
      u = h;
    }
    if (a < 0) return c;
    o = o >> 1;
  }
}
function yL(t, e, n, r, i, s) {
  let o = n - e,
    a = s - i;
  if (o < a) {
    let l = yL(r, i, s, t, e, n);
    return l && [l[1], l[0], l[2]];
  }
  return o < 4 || a * 2 < o ? null : Nx(t, e, n, r, i, s, Math.floor(o / 4), -1);
}
function NT(t, e, n, r, i, s) {
  let o = n - e,
    a = s - i,
    l;
  if (o < a) {
    let f = Nx(r, i, s, t, e, n, Math.floor(o / 6), 50);
    l = f && [f[1], f[0], f[2]];
  } else l = Nx(t, e, n, r, i, s, Math.floor(a / 6), 50);
  if (!l) return [new Zt(e, n, i, s)];
  let [c, u, h] = l;
  return la(t, e, c, r, i, u).concat(la(t, c + h, n, r, u + h, s));
}
function wL(t, e) {
  for (let n = 1; n < t.length; n++) {
    let r = t[n - 1],
      i = t[n];
    r.toA > i.fromA - e && r.toB > i.fromB - e && ((t[n - 1] = new Zt(r.fromA, i.toA, r.fromB, i.toB)), t.splice(n--, 1));
  }
}
function A1e(t, e, n) {
  for (;;) {
    wL(n, 1);
    let r = !1;
    for (let i = 0; i < n.length; i++) {
      let s = n[i],
        o,
        a;
      (o = ak(t, s.fromA, s.toA, e, s.fromB, s.toB)) && (s = n[i] = new Zt(s.fromA + o, s.toA, s.fromB + o, s.toB)),
        (a = lk(t, s.fromA, s.toA, e, s.fromB, s.toB)) && (s = n[i] = new Zt(s.fromA, s.toA - a, s.fromB, s.toB - a));
      let l = s.toA - s.fromA,
        c = s.toB - s.fromB;
      if (l && c) continue;
      let u = s.fromA - (i ? n[i - 1].toA : 0),
        h = (i < n.length - 1 ? n[i + 1].fromA : t.length) - s.toA;
      if (!u || !h) continue;
      let f = l ? t.slice(s.fromA, s.toA) : e.slice(s.fromB, s.toB);
      u <= f.length && t.slice(s.fromA - u, s.fromA) == f.slice(f.length - u)
        ? ((n[i] = new Zt(s.fromA - u, s.toA - u, s.fromB - u, s.toB - u)), (r = !0))
        : h <= f.length &&
          t.slice(s.toA, s.toA + h) == f.slice(0, h) &&
          ((n[i] = new Zt(s.fromA + h, s.toA + h, s.fromB + h, s.toB + h)), (r = !0));
    }
    if (!r) break;
  }
  return n;
}
function $1e(t, e, n) {
  for (let r = 0, i = 0; i < t.length; i++) {
    let s = t[i],
      o = s.toA - s.fromA,
      a = s.toB - s.fromB;
    if ((o && a) || o > 3 || a > 3) {
      let l = i == t.length - 1 ? e.length : t[i + 1].fromA,
        c = s.fromA - r,
        u = l - s.toA,
        h = MT(e, s.fromA, Math.min(c, 5)),
        f = LT(e, s.toA, Math.min(u, 5)),
        d = s.fromA - h,
        p = f - s.toA;
      if (!o || !a) {
        let m = Math.max(o, a),
          [O, v, g] = o ? [e, s.fromA, s.toA] : [n, s.fromB, s.toB],
          x,
          y;
        d && p
          ? (m > d && e.slice(h, s.fromA) == O.slice(g - d, g)
              ? ((s = t[i] = new Zt(h, h + o, s.fromB - d, s.toB - d)), (h = s.fromA), (f = LT(e, s.toA, Math.min(l - s.toA, 5))))
              : m > p &&
                e.slice(s.toA, f) == O.slice(v, v + p) &&
                ((s = t[i] = new Zt(f - o, f, s.fromB + p, s.toB + p)), (f = s.toA), (h = MT(e, s.fromA, Math.min(s.fromA - r, 5)))),
            (d = s.fromA - h),
            (p = f - s.toA))
          : !d &&
            !p &&
            (y = s.fromA - (x = R1e(e, s.fromA, c))) &&
            e.slice(x, s.fromA) == O.slice(g - y, g) &&
            (s = t[i] = new Zt(x, x + o, s.fromB - y, s.toB - y));
      }
      (d || p) && (s = t[i] = new Zt(s.fromA - d, s.toA + p, s.fromB - d, s.toB + p)), (r = s.toA);
    }
  }
  return wL(t, 3), t;
}
let Fo;
try {
  Fo = new RegExp("[\\p{Alphabetic}\\p{Number}]", "u");
} catch {}
function SL(t) {
  return (t > 48 && t < 58) || (t > 64 && t < 91) || (t > 96 && t < 123);
}
function kL(t, e) {
  if (e == t.length) return 0;
  let n = t.charCodeAt(e);
  return n < 192
    ? SL(n)
      ? 1
      : 0
    : Fo
    ? !_L(n) || e == t.length - 1
      ? Fo.test(String.fromCharCode(n))
        ? 1
        : 0
      : Fo.test(t.slice(e, e + 2))
      ? 2
      : 0
    : 0;
}
function CL(t, e) {
  if (!e) return 0;
  let n = t.charCodeAt(e - 1);
  return n < 192
    ? SL(n)
      ? 1
      : 0
    : Fo
    ? !EL(n) || e == 1
      ? Fo.test(String.fromCharCode(n))
        ? 1
        : 0
      : Fo.test(t.slice(e - 2, e))
      ? 2
      : 0
    : 0;
}
function LT(t, e, n) {
  if (e == t.length || !CL(t, e)) return e;
  for (let r = e, i = e + n; ; ) {
    let s = kL(t, r);
    if (!s) return r;
    if (((r += s), r > i)) return e;
  }
}
function MT(t, e, n) {
  if (!e || !kL(t, e)) return e;
  for (let r = e, i = e - n; ; ) {
    let s = CL(t, r);
    if (!s) return r;
    if (((r -= s), r < i)) return e;
  }
}
function R1e(t, e, n) {
  for (let r = e, i = e - n; ; ) {
    let s = r ? t.charCodeAt(r - 1) : 10;
    if (s == 10) return r;
    if ((r--, r < i || (s != 32 && s != 9))) return e;
  }
}
const _L = (t) => t >= 55296 && t <= 56319,
  EL = (t) => t >= 56320 && t <= 57343;
function Ll(t, e) {
  return !e || e == t.length || !_L(t.charCodeAt(e - 1)) || !EL(t.charCodeAt(e));
}
function I1e(t, e, n) {
  var r;
  return (
    (Yc = ((r = n == null ? void 0 : n.scanLimit) !== null && r !== void 0 ? r : 1e9) >> 1), A1e(t, e, la(t, 0, t.length, e, 0, e.length))
  );
}
function TL(t, e, n) {
  return $1e(I1e(t, e, n), t, e);
}
const wi = ye.define({ combine: (t) => t[0] }),
  Lx = Ae.define(),
  Ml = zt.define({
    create(t) {
      return null;
    },
    update(t, e) {
      for (let n of e.effects) n.is(Lx) && (t = n.value);
      return t;
    },
  });
class fl {
  constructor(e, n, r, i, s) {
    (this.changes = e), (this.fromA = n), (this.toA = r), (this.fromB = i), (this.toB = s);
  }
  offset(e, n) {
    return e || n ? new fl(this.changes, this.fromA + e, this.toA + e, this.fromB + n, this.toB + n) : this;
  }
  get endA() {
    return Math.max(this.fromA, this.toA - 1);
  }
  get endB() {
    return Math.max(this.fromB, this.toB - 1);
  }
  static build(e, n, r) {
    return PL(TL(e.toString(), n.toString(), r), e, n, 0, 0);
  }
  static updateA(e, n, r, i, s) {
    return BT(VT(e, i, !0, r.length), e, n, r, s);
  }
  static updateB(e, n, r, i, s) {
    return BT(VT(e, i, !1, n.length), e, n, r, s);
  }
}
function DT(t, e, n, r) {
  let i = n.lineAt(t),
    s = r.lineAt(e);
  return i.to == t && s.to == e && t < n.length && e < r.length ? [t + 1, e + 1] : [i.from, s.from];
}
function QT(t, e, n, r) {
  let i = n.lineAt(t),
    s = r.lineAt(e);
  return i.from == t && s.from == e ? [t, e] : [i.to + 1, s.to + 1];
}
function PL(t, e, n, r, i) {
  let s = [];
  for (let o = 0; o < t.length; o++) {
    let a = t[o],
      [l, c] = DT(a.fromA + r, a.fromB + i, e, n),
      [u, h] = QT(a.toA + r, a.toB + i, e, n),
      f = [a.offset(-l + r, -c + i)];
    for (; o < t.length - 1; ) {
      let d = t[o + 1],
        [p, m] = DT(d.fromA + r, d.fromB + i, e, n);
      if (p > u + 1 && m > h + 1) break;
      f.push(d.offset(-l + r, -c + i)), ([u, h] = QT(d.toA + r, d.toB + i, e, n)), o++;
    }
    s.push(new fl(f, l, Math.max(l, u), c, Math.max(c, h)));
  }
  return s;
}
const hd = 1e3;
function FT(t, e, n, r) {
  let i = 0,
    s = t.length;
  for (;;) {
    if (i == s) {
      let u = 0,
        h = 0;
      i && ({ toA: u, toB: h } = t[i - 1]);
      let f = e - (n ? u : h);
      return [u + f, h + f];
    }
    let o = (i + s) >> 1,
      a = t[o],
      [l, c] = n ? [a.fromA, a.toA] : [a.fromB, a.toB];
    if (l > e) s = o;
    else if (c <= e) i = o + 1;
    else return r ? [a.fromA, a.fromB] : [a.toA, a.toB];
  }
}
function VT(t, e, n, r) {
  let i = [];
  return (
    e.iterChangedRanges((s, o, a, l) => {
      let c = 0,
        u = n ? e.length : r,
        h = 0,
        f = n ? r : e.length;
      s > hd && ([c, h] = FT(t, s - hd, n, !0)), o < e.length - hd && ([u, f] = FT(t, o + hd, n, !1));
      let d = l - a - (o - s),
        p,
        [m, O] = n ? [d, 0] : [0, d];
      i.length && (p = i[i.length - 1]).toA >= c
        ? (i[i.length - 1] = { fromA: p.fromA, fromB: p.fromB, toA: u, toB: f, diffA: p.diffA + m, diffB: p.diffB + O })
        : i.push({ fromA: c, toA: u, fromB: h, toB: f, diffA: m, diffB: O });
    }),
    i
  );
}
function BT(t, e, n, r, i) {
  if (!t.length) return e;
  let s = [];
  for (let o = 0, a = 0, l = 0, c = 0; ; o++) {
    let u = o == t.length ? null : t[o],
      h = u ? u.fromA + a : n.length,
      f = u ? u.fromB + l : r.length;
    for (; c < e.length; ) {
      let O = e[c];
      if (O.toA + a > h || O.toB + l > f) break;
      s.push(O.offset(a, l)), c++;
    }
    if (!u) break;
    let d = u.toA + a + u.diffA,
      p = u.toB + l + u.diffB,
      m = TL(n.sliceString(h, d), r.sliceString(f, p), i);
    for (let O of PL(m, n, r, h, f)) s.push(O);
    for (a += u.diffA, l += u.diffB; c < e.length; ) {
      let O = e[c];
      if (O.fromA + a > d && O.fromB + l > p) break;
      c++;
    }
  }
  return s;
}
const N1e = { scanLimit: 500 },
  AL = Dt.fromClass(
    class {
      constructor(t) {
        ({ deco: this.deco, gutter: this.gutter } = zT(t));
      }
      update(t) {
        (t.docChanged || t.viewportChanged || L1e(t.startState, t.state) || M1e(t.startState, t.state)) &&
          ({ deco: this.deco, gutter: this.gutter } = zT(t.view));
      }
    },
    { decorations: (t) => t.deco }
  ),
  fd = ai.low(
    z4({
      class: "cm-changeGutter",
      markers: (t) => {
        var e;
        return ((e = t.plugin(AL)) === null || e === void 0 ? void 0 : e.gutter) || Xe.empty;
      },
    })
  );
function L1e(t, e) {
  return t.field(Ml, !1) != e.field(Ml, !1);
}
function M1e(t, e) {
  return t.facet(wi) != e.facet(wi);
}
const jT = ge.line({ class: "cm-changedLine" }),
  D1e = ge.mark({ class: "cm-changedText" }),
  Q1e = ge.mark({ tagName: "ins", class: "cm-insertedLine" }),
  F1e = ge.mark({ tagName: "del", class: "cm-deletedLine" }),
  ZT = new (class extends Li {
    constructor() {
      super(...arguments), (this.elementClass = "cm-changedLineGutter");
    }
  })();
function V1e(t, e, n, r, i, s) {
  let o = n ? t.fromA : t.fromB,
    a = n ? t.toA : t.toB,
    l = 0;
  if (o != a) {
    i.add(o, o, jT), i.add(o, a, n ? F1e : Q1e), s && s.add(o, o, ZT);
    for (let c = e.iterRange(o, a - 1), u = o; !c.next().done; ) {
      if (c.lineBreak) {
        u++, i.add(u, u, jT), s && s.add(u, u, ZT);
        continue;
      }
      let h = u + c.value.length;
      if (r)
        for (; l < t.changes.length; ) {
          let f = t.changes[l],
            d = o + (n ? f.fromA : f.fromB),
            p = o + (n ? f.toA : f.toB),
            m = Math.max(u, d),
            O = Math.min(h, p);
          if ((m < O && i.add(m, O, D1e), p < h)) l++;
          else break;
        }
      u = h;
    }
  }
}
function zT(t) {
  let e = t.state.field(Ml),
    { side: n, highlightChanges: r, markGutter: i } = t.state.facet(wi),
    s = n == "a",
    o = new Or(),
    a = i ? new Or() : null,
    { from: l, to: c } = t.viewport;
  for (let u of e) {
    if ((s ? u.fromA : u.fromB) >= c) break;
    (s ? u.toA : u.toB) > l && V1e(u, t.state.doc, s, r, o, a);
  }
  return { deco: o.finish(), gutter: a && a.finish() };
}
class dd extends li {
  constructor(e) {
    super(), (this.height = e);
  }
  eq(e) {
    return this.height == e.height;
  }
  toDOM() {
    let e = document.createElement("div");
    return (e.className = "cm-mergeSpacer"), (e.style.height = this.height + "px"), e;
  }
  updateDOM(e) {
    return (e.style.height = this.height + "px"), !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
const dm = Ae.define({ map: (t, e) => t.map(e) }),
  Gc = zt.define({
    create: () => ge.none,
    update: (t, e) => {
      for (let n of e.effects) if (n.is(dm)) return n.value;
      return t.map(e.changes);
    },
    provide: (t) => re.decorations.from(t),
  }),
  pd = 0.01;
function B1e(t, e, n) {
  let r = new Or(),
    i = new Or(),
    s = t.state.field(Gc).iter(),
    o = e.state.field(Gc).iter(),
    a = 0,
    l = 0,
    c = 0,
    u = 0;
  for (let p = 0; ; p++) {
    let m = p < n.length ? n[p] : null;
    if (a < (m ? m.fromA : t.state.doc.length)) {
      let O = t.lineBlockAt(a).top + c,
        v = e.lineBlockAt(l).top + u,
        g = O - v;
      g < -pd
        ? ((c -= g), r.add(a, a, ge.widget({ widget: new dd(-g), block: !0, side: -1 })))
        : g > pd && ((u += g), i.add(l, l, ge.widget({ widget: new dd(g), block: !0, side: -1 })));
    }
    if (!m) break;
    for (a = m.toA, l = m.toB; s.value && s.from < a; ) (c -= s.value.spec.widget.height), s.next();
    for (; o.value && o.from < l; ) (u -= o.value.spec.widget.height), o.next();
  }
  for (; s.value; ) (c -= s.value.spec.widget.height), s.next();
  for (; o.value; ) (u -= o.value.spec.widget.height), o.next();
  let h = t.contentHeight + c - (e.contentHeight + u);
  h < pd
    ? r.add(t.state.doc.length, t.state.doc.length, ge.widget({ widget: new dd(-h), block: !0, side: 1 }))
    : h > pd && i.add(e.state.doc.length, e.state.doc.length, ge.widget({ widget: new dd(h), block: !0, side: 1 }));
  let f = r.finish(),
    d = i.finish();
  Xe.eq([f], [t.state.field(Gc)]) || t.dispatch({ effects: dm.of(f) }),
    Xe.eq([d], [e.state.field(Gc)]) || e.dispatch({ effects: dm.of(d) });
}
const Mx = Ae.define({ map: (t, e) => e.mapPos(t) });
class j1e extends li {
  constructor(e) {
    super(), (this.lines = e);
  }
  eq(e) {
    return this.lines == e.lines;
  }
  toDOM(e) {
    let n = document.createElement("div");
    return (
      (n.className = "cm-collapsedLines"),
      (n.textContent = "⦚ " + e.state.phrase("$ unchanged lines", this.lines) + " ⦚"),
      n.addEventListener("click", (r) => {
        let i = e.posAtDOM(r.target);
        e.dispatch({ effects: Mx.of(i) });
        let { side: s, sibling: o } = e.state.facet(wi);
        o && o().dispatch({ effects: Mx.of(Z1e(i, e.state.field(Ml), s == "a")) });
      }),
      n
    );
  }
  ignoreEvent(e) {
    return e instanceof MouseEvent;
  }
  get estimatedHeight() {
    return 27;
  }
}
function Z1e(t, e, n) {
  let r = 0,
    i = 0;
  for (let s = 0; ; s++) {
    let o = s < e.length ? e[s] : null;
    if (!o || (n ? o.fromA : o.fromB) >= t) return i + (t - r);
    [r, i] = n ? [o.toA, o.toB] : [o.toB, o.toA];
  }
}
const z1e = zt.define({
  create(t) {
    return ge.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects) n.is(Mx) && (t = t.update({ filter: (r) => r != n.value }));
    return t;
  },
  provide: (t) => re.decorations.from(t),
});
function WT({ margin: t = 3, minSize: e = 4 }) {
  return z1e.init((n) => W1e(n, t, e));
}
function W1e(t, e, n) {
  let r = new Or(),
    i = t.facet(wi).side == "a",
    s = t.field(Ml),
    o = 1;
  for (let a = 0; ; a++) {
    let l = a < s.length ? s[a] : null,
      c = a ? o + e : 1,
      u = l ? t.doc.lineAt(i ? l.fromA : l.fromB).number - 1 - e : t.doc.lines,
      h = u - c + 1;
    if ((h >= n && r.add(t.doc.line(c).from, t.doc.line(u).to, ge.replace({ widget: new j1e(h), block: !0 })), !l)) break;
    o = t.doc.lineAt(Math.min(t.doc.length, i ? l.toA : l.toB)).number;
  }
  return r.finish();
}
const U1e = re.styleModule.of(
    new ds({
      ".cm-mergeView": { overflowY: "auto" },
      ".cm-mergeViewEditors": { display: "flex", alignItems: "stretch" },
      ".cm-mergeViewEditor": { flexGrow: 1, flexBasis: 0, overflow: "hidden" },
      ".cm-merge-revert": { width: "1.6em", flexGrow: 0, flexShrink: 0, position: "relative" },
      ".cm-merge-revert button": {
        position: "absolute",
        display: "block",
        width: "100%",
        boxSizing: "border-box",
        textAlign: "center",
        background: "none",
        border: "none",
        font: "inherit",
        cursor: "pointer",
      },
    })
  ),
  X1e = re.baseTheme({
    ".cm-mergeView & .cm-scroller, .cm-mergeView &": { height: "auto !important", overflowY: "visible !important" },
    "&.cm-merge-a .cm-changedLine, .cm-deletedChunk": { backgroundColor: "rgba(160, 128, 100, .08)" },
    "&.cm-merge-b .cm-changedLine": { backgroundColor: "rgba(100, 160, 128, .08)" },
    "&light.cm-merge-a .cm-changedText, &light .cm-deletedChunk .cm-deletedText": {
      background: "linear-gradient(#ee443366, #ee443366) bottom/100% 2px no-repeat",
    },
    "&dark.cm-merge-a .cm-changedText, &dark .cm-deletedChunk .cm-deletedText": {
      background: "linear-gradient(#ffaa9966, #ffaa9966) bottom/100% 2px no-repeat",
    },
    "&light.cm-merge-b .cm-changedText": { background: "linear-gradient(#22bb2266, #22bb2266) bottom/100% 2px no-repeat" },
    "&dark.cm-merge-b .cm-changedText": { background: "linear-gradient(#88ff8866, #88ff8866) bottom/100% 2px no-repeat" },
    ".cm-insertedLine, .cm-deletedLine": { textDecoration: "none" },
    ".cm-deletedChunk": {
      paddingLeft: "6px",
      "& .cm-chunkButtons": { position: "absolute", insetInlineEnd: "5px" },
      "& button": {
        border: "none",
        cursor: "pointer",
        color: "white",
        margin: "0 2px",
        borderRadius: "3px",
        "&[name=accept]": { background: "#2a2" },
        "&[name=reject]": { background: "#d43" },
      },
    },
    ".cm-collapsedLines": { padding: "5px 5px 5px 10px", cursor: "pointer" },
    "&light .cm-collapsedLines": {
      color: "#444",
      background: "linear-gradient(to bottom, transparent 0, #f3f3f3 30%, #f3f3f3 70%, transparent 100%)",
    },
    "&dark .cm-collapsedLines": {
      color: "#ddd",
      background: "linear-gradient(to bottom, transparent 0, #222 30%, #222 70%, transparent 100%)",
    },
    ".cm-changeGutter": { width: "3px", paddingLeft: "1px" },
    "&light.cm-merge-a .cm-changedLineGutter, &light .cm-deletedLineGutter": { background: "#e43" },
    "&dark.cm-merge-a .cm-changedLineGutter, &dark .cm-deletedLineGutter": { background: "#fa9" },
    "&light.cm-merge-b .cm-changedLineGutter": { background: "#2b2" },
    "&dark.cm-merge-b .cm-changedLineGutter": { background: "#8f8" },
  }),
  UT = new rc(),
  md = new rc();
class H1e {
  constructor(e) {
    (this.revertDOM = null), (this.revertToA = !1), (this.revertToLeft = !1), (this.measuring = -1), (this.diffConf = e.diffConfig || N1e);
    let n = [
        ai.low(AL),
        X1e,
        U1e,
        Gc,
        re.updateListener.of((h) => {
          this.measuring < 0 &&
            (h.heightChanged || h.viewportChanged) &&
            !h.transactions.some((f) => f.effects.some((d) => d.is(dm))) &&
            this.measure();
        }),
      ],
      r = [wi.of({ side: "a", sibling: () => this.b, highlightChanges: e.highlightChanges !== !1, markGutter: e.gutter !== !1 })];
    e.gutter !== !1 && r.push(fd);
    let i = Qe.create({
        doc: e.a.doc,
        selection: e.a.selection,
        extensions: [e.a.extensions || [], re.editorAttributes.of({ class: "cm-merge-a" }), md.of(r), n],
      }),
      s = [wi.of({ side: "b", sibling: () => this.a, highlightChanges: e.highlightChanges !== !1, markGutter: e.gutter !== !1 })];
    e.gutter !== !1 && s.push(fd);
    let o = Qe.create({
      doc: e.b.doc,
      selection: e.b.selection,
      extensions: [e.b.extensions || [], re.editorAttributes.of({ class: "cm-merge-b" }), md.of(s), n],
    });
    this.chunks = fl.build(i.doc, o.doc, this.diffConf);
    let a = [Ml.init(() => this.chunks), UT.of(e.collapseUnchanged ? WT(e.collapseUnchanged) : [])];
    (i = i.update({ effects: Ae.appendConfig.of(a) }).state),
      (o = o.update({ effects: Ae.appendConfig.of(a) }).state),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-mergeView"),
      (this.editorDOM = this.dom.appendChild(document.createElement("div"))),
      (this.editorDOM.className = "cm-mergeViewEditors");
    let l = e.orientation || "a-b",
      c = document.createElement("div");
    c.className = "cm-mergeViewEditor";
    let u = document.createElement("div");
    (u.className = "cm-mergeViewEditor"),
      this.editorDOM.appendChild(l == "a-b" ? c : u),
      this.editorDOM.appendChild(l == "a-b" ? u : c),
      (this.a = new re({ state: i, parent: c, root: e.root, dispatchTransactions: (h) => this.dispatch(h, this.a) })),
      (this.b = new re({ state: o, parent: u, root: e.root, dispatchTransactions: (h) => this.dispatch(h, this.b) })),
      this.setupRevertControls(!!e.revertControls, e.revertControls == "b-to-a", e.renderRevertControl),
      e.parent && e.parent.appendChild(this.dom),
      this.scheduleMeasure();
  }
  dispatch(e, n) {
    if (e.some((r) => r.docChanged)) {
      let r = e[e.length - 1],
        i = e.reduce((o, a) => o.compose(a.changes), qt.empty(e[0].startState.doc.length));
      (this.chunks =
        n == this.a
          ? fl.updateA(this.chunks, r.newDoc, this.b.state.doc, i, this.diffConf)
          : fl.updateB(this.chunks, this.a.state.doc, r.newDoc, i, this.diffConf)),
        n.update([...e, r.state.update({ effects: Lx.of(this.chunks) })]);
      let s = n == this.a ? this.b : this.a;
      s.update([s.state.update({ effects: Lx.of(this.chunks) })]), this.scheduleMeasure();
    } else n.update(e);
  }
  reconfigure(e) {
    if (("diffConfig" in e && (this.diffConf = e.diffConfig), "orientation" in e)) {
      let s = e.orientation != "b-a";
      if (s != (this.editorDOM.firstChild == this.a.dom.parentNode)) {
        let o = this.a.dom.parentNode,
          a = this.b.dom.parentNode;
        o.remove(),
          a.remove(),
          this.editorDOM.insertBefore(s ? o : a, this.editorDOM.firstChild),
          this.editorDOM.appendChild(s ? a : o),
          (this.revertToLeft = !this.revertToLeft),
          this.revertDOM && (this.revertDOM.textContent = "");
      }
    }
    if ("revertControls" in e || "renderRevertControl" in e) {
      let s = !!this.revertDOM,
        o = this.revertToA,
        a = this.renderRevert;
      "revertControls" in e && ((s = !!e.revertControls), (o = e.revertControls == "b-to-a")),
        "renderRevertControl" in e && (a = e.renderRevertControl),
        this.setupRevertControls(s, o, a);
    }
    let n = "highlightChanges" in e,
      r = "gutter" in e,
      i = "collapseUnchanged" in e;
    if (n || r || i) {
      let s = [],
        o = [];
      if (n || r) {
        let a = this.a.state.facet(wi),
          l = r ? e.gutter !== !1 : a.markGutter,
          c = n ? e.highlightChanges !== !1 : a.highlightChanges;
        s.push(md.reconfigure([wi.of({ side: "a", sibling: () => this.b, highlightChanges: c, markGutter: l }), l ? fd : []])),
          o.push(md.reconfigure([wi.of({ side: "b", sibling: () => this.a, highlightChanges: c, markGutter: l }), l ? fd : []]));
      }
      if (i) {
        let a = UT.reconfigure(e.collapseUnchanged ? WT(e.collapseUnchanged) : []);
        s.push(a), o.push(a);
      }
      this.a.dispatch({ effects: s }), this.b.dispatch({ effects: o });
    }
    this.scheduleMeasure();
  }
  setupRevertControls(e, n, r) {
    (this.revertToA = n),
      (this.revertToLeft = this.revertToA == (this.editorDOM.firstChild == this.a.dom.parentNode)),
      (this.renderRevert = r),
      !e && this.revertDOM
        ? (this.revertDOM.remove(), (this.revertDOM = null))
        : e && !this.revertDOM
        ? ((this.revertDOM = this.editorDOM.insertBefore(document.createElement("div"), this.editorDOM.firstChild.nextSibling)),
          this.revertDOM.addEventListener("mousedown", (i) => this.revertClicked(i)),
          (this.revertDOM.className = "cm-merge-revert"))
        : this.revertDOM && (this.revertDOM.textContent = "");
  }
  scheduleMeasure() {
    if (this.measuring < 0) {
      let e = this.dom.ownerDocument.defaultView || window;
      this.measuring = e.requestAnimationFrame(() => {
        (this.measuring = -1), this.measure();
      });
    }
  }
  measure() {
    B1e(this.a, this.b, this.chunks), this.revertDOM && this.updateRevertButtons();
  }
  updateRevertButtons() {
    let e = this.revertDOM,
      n = e.firstChild,
      r = this.a.viewport,
      i = this.b.viewport;
    for (let s = 0; s < this.chunks.length; s++) {
      let o = this.chunks[s];
      if (o.fromA > r.to || o.fromB > i.to) break;
      if (o.fromA < r.from || o.fromB < i.from) continue;
      let a = this.a.lineBlockAt(o.fromA).top + "px";
      for (; n && +n.dataset.chunk < s; ) n = XT(n);
      n && n.dataset.chunk == String(s)
        ? (n.style.top != a && (n.style.top = a), (n = n.nextSibling))
        : e.insertBefore(this.renderRevertButton(a, s), n);
    }
    for (; n; ) n = XT(n);
  }
  renderRevertButton(e, n) {
    let r;
    if (this.renderRevert) r = this.renderRevert();
    else {
      r = document.createElement("button");
      let i = this.a.state.phrase("Revert this chunk");
      r.setAttribute("aria-label", i), r.setAttribute("title", i), (r.textContent = this.revertToLeft ? "⇜" : "⇝");
    }
    return (r.style.top = e), r.setAttribute("data-chunk", String(n)), r;
  }
  revertClicked(e) {
    let n = e.target,
      r;
    for (; n && n.parentNode != this.revertDOM; ) n = n.parentNode;
    if (n && (r = this.chunks[n.dataset.chunk])) {
      let [i, s, o, a, l, c] = this.revertToA
          ? [this.b, this.a, r.fromB, r.toB, r.fromA, r.toA]
          : [this.a, this.b, r.fromA, r.toA, r.fromB, r.toB],
        u = i.state.sliceDoc(o, Math.max(o, a - 1));
      o != a && c <= s.state.doc.length && (u += i.state.lineBreak),
        s.dispatch({ changes: { from: l, to: Math.min(s.state.doc.length, c), insert: u }, userEvent: "revert" }),
        e.preventDefault();
    }
  }
  destroy() {
    this.a.destroy(),
      this.b.destroy(),
      this.measuring > -1 && (this.dom.ownerDocument.defaultView || window).cancelAnimationFrame(this.measuring),
      this.dom.remove();
  }
}
function XT(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
class pm {
  static create(e, n, r, i, s) {
    let o = (i + (i << 8) + e + (n << 4)) | 0;
    return new pm(e, n, r, o, s, [], []);
  }
  constructor(e, n, r, i, s, o, a) {
    (this.type = e),
      (this.value = n),
      (this.from = r),
      (this.hash = i),
      (this.end = s),
      (this.children = o),
      (this.positions = a),
      (this.hashProp = [[Ie.contextHash, i]]);
  }
  addChild(e, n) {
    e.prop(Ie.contextHash) != this.hash && (e = new ze(e.type, e.children, e.positions, e.length, this.hashProp)),
      this.children.push(e),
      this.positions.push(n);
  }
  toTree(e, n = this.end) {
    let r = this.children.length - 1;
    return (
      r >= 0 && (n = Math.max(n, this.positions[r] + this.children[r].length + this.from)),
      new ze(e.types[this.type], this.children, this.positions, n - this.from).balance({
        makeTree: (i, s, o) => new ze(Kt.none, i, s, o, this.hashProp),
      })
    );
  }
}
var oe;
(function (t) {
  (t[(t.Document = 1)] = "Document"),
    (t[(t.CodeBlock = 2)] = "CodeBlock"),
    (t[(t.FencedCode = 3)] = "FencedCode"),
    (t[(t.Blockquote = 4)] = "Blockquote"),
    (t[(t.HorizontalRule = 5)] = "HorizontalRule"),
    (t[(t.BulletList = 6)] = "BulletList"),
    (t[(t.OrderedList = 7)] = "OrderedList"),
    (t[(t.ListItem = 8)] = "ListItem"),
    (t[(t.ATXHeading1 = 9)] = "ATXHeading1"),
    (t[(t.ATXHeading2 = 10)] = "ATXHeading2"),
    (t[(t.ATXHeading3 = 11)] = "ATXHeading3"),
    (t[(t.ATXHeading4 = 12)] = "ATXHeading4"),
    (t[(t.ATXHeading5 = 13)] = "ATXHeading5"),
    (t[(t.ATXHeading6 = 14)] = "ATXHeading6"),
    (t[(t.SetextHeading1 = 15)] = "SetextHeading1"),
    (t[(t.SetextHeading2 = 16)] = "SetextHeading2"),
    (t[(t.HTMLBlock = 17)] = "HTMLBlock"),
    (t[(t.LinkReference = 18)] = "LinkReference"),
    (t[(t.Paragraph = 19)] = "Paragraph"),
    (t[(t.CommentBlock = 20)] = "CommentBlock"),
    (t[(t.ProcessingInstructionBlock = 21)] = "ProcessingInstructionBlock"),
    (t[(t.Escape = 22)] = "Escape"),
    (t[(t.Entity = 23)] = "Entity"),
    (t[(t.HardBreak = 24)] = "HardBreak"),
    (t[(t.Emphasis = 25)] = "Emphasis"),
    (t[(t.StrongEmphasis = 26)] = "StrongEmphasis"),
    (t[(t.Link = 27)] = "Link"),
    (t[(t.Image = 28)] = "Image"),
    (t[(t.InlineCode = 29)] = "InlineCode"),
    (t[(t.HTMLTag = 30)] = "HTMLTag"),
    (t[(t.Comment = 31)] = "Comment"),
    (t[(t.ProcessingInstruction = 32)] = "ProcessingInstruction"),
    (t[(t.Autolink = 33)] = "Autolink"),
    (t[(t.HeaderMark = 34)] = "HeaderMark"),
    (t[(t.QuoteMark = 35)] = "QuoteMark"),
    (t[(t.ListMark = 36)] = "ListMark"),
    (t[(t.LinkMark = 37)] = "LinkMark"),
    (t[(t.EmphasisMark = 38)] = "EmphasisMark"),
    (t[(t.CodeMark = 39)] = "CodeMark"),
    (t[(t.CodeText = 40)] = "CodeText"),
    (t[(t.CodeInfo = 41)] = "CodeInfo"),
    (t[(t.LinkTitle = 42)] = "LinkTitle"),
    (t[(t.LinkLabel = 43)] = "LinkLabel"),
    (t[(t.URL = 44)] = "URL");
})(oe || (oe = {}));
class q1e {
  constructor(e, n) {
    (this.start = e), (this.content = n), (this.marks = []), (this.parsers = []);
  }
}
class Y1e {
  constructor() {
    (this.text = ""),
      (this.baseIndent = 0),
      (this.basePos = 0),
      (this.depth = 0),
      (this.markers = []),
      (this.pos = 0),
      (this.indent = 0),
      (this.next = -1);
  }
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    (this.indent = this.countIndent(e, this.pos, this.indent)),
      (this.pos = e),
      (this.next = e == this.text.length ? -1 : this.text.charCodeAt(e));
  }
  skipSpace(e) {
    return Ou(this.text, e);
  }
  reset(e) {
    for (
      this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1;
      this.markers.length;

    )
      this.markers.pop();
  }
  moveBase(e) {
    (this.basePos = e), (this.baseIndent = this.countIndent(e, this.pos, this.indent));
  }
  moveBaseColumn(e) {
    (this.baseIndent = e), (this.basePos = this.findColumn(e));
  }
  addMarker(e) {
    this.markers.push(e);
  }
  countIndent(e, n = 0, r = 0) {
    for (let i = n; i < e; i++) r += this.text.charCodeAt(i) == 9 ? 4 - (r % 4) : 1;
    return r;
  }
  findColumn(e) {
    let n = 0;
    for (let r = 0; n < this.text.length && r < e; n++) r += this.text.charCodeAt(n) == 9 ? 4 - (r % 4) : 1;
    return n;
  }
  scrub() {
    if (!this.baseIndent) return this.text;
    let e = "";
    for (let n = 0; n < this.basePos; n++) e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function HT(t, e, n) {
  if (n.pos == n.text.length || (t != e.block && n.indent >= e.stack[n.depth + 1].value + n.baseIndent)) return !0;
  if (n.indent >= n.baseIndent + 4) return !1;
  let r = (t.type == oe.OrderedList ? hk : uk)(n, e, !1);
  return r > 0 && (t.type != oe.BulletList || ck(n, e, !1) < 0) && n.text.charCodeAt(n.pos + r - 1) == t.value;
}
const $L = {
  [oe.Blockquote](t, e, n) {
    return n.next != 62
      ? !1
      : (n.markers.push(Ke(oe.QuoteMark, e.lineStart + n.pos, e.lineStart + n.pos + 1)),
        n.moveBase(n.pos + (Fr(n.text.charCodeAt(n.pos + 1)) ? 2 : 1)),
        (t.end = e.lineStart + n.text.length),
        !0);
  },
  [oe.ListItem](t, e, n) {
    return n.indent < n.baseIndent + t.value && n.next > -1 ? !1 : (n.moveBaseColumn(n.baseIndent + t.value), !0);
  },
  [oe.OrderedList]: HT,
  [oe.BulletList]: HT,
  [oe.Document]() {
    return !0;
  },
};
function Fr(t) {
  return t == 32 || t == 9 || t == 10 || t == 13;
}
function Ou(t, e = 0) {
  for (; e < t.length && Fr(t.charCodeAt(e)); ) e++;
  return e;
}
function qT(t, e, n) {
  for (; e > n && Fr(t.charCodeAt(e - 1)); ) e--;
  return e;
}
function RL(t) {
  if (t.next != 96 && t.next != 126) return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; ) e++;
  if (e < t.pos + 3) return -1;
  if (t.next == 96) {
    for (let n = e; n < t.text.length; n++) if (t.text.charCodeAt(n) == 96) return -1;
  }
  return e;
}
function IL(t) {
  return t.next != 62 ? -1 : t.text.charCodeAt(t.pos + 1) == 32 ? 2 : 1;
}
function ck(t, e, n) {
  if (t.next != 42 && t.next != 45 && t.next != 95) return -1;
  let r = 1;
  for (let i = t.pos + 1; i < t.text.length; i++) {
    let s = t.text.charCodeAt(i);
    if (s == t.next) r++;
    else if (!Fr(s)) return -1;
  }
  return (n && t.next == 45 && ML(t) > -1 && t.depth == e.stack.length) || r < 3 ? -1 : 1;
}
function NL(t, e) {
  for (let n = t.stack.length - 1; n >= 0; n--) if (t.stack[n].type == e) return !0;
  return !1;
}
function uk(t, e, n) {
  return (t.next == 45 || t.next == 43 || t.next == 42) &&
    (t.pos == t.text.length - 1 || Fr(t.text.charCodeAt(t.pos + 1))) &&
    (!n || NL(e, oe.BulletList) || t.skipSpace(t.pos + 2) < t.text.length)
    ? 1
    : -1;
}
function hk(t, e, n) {
  let r = t.pos,
    i = t.next;
  for (; i >= 48 && i <= 57; ) {
    r++;
    if (r == t.text.length) return -1;
    i = t.text.charCodeAt(r);
  }
  return r == t.pos ||
    r > t.pos + 9 ||
    (i != 46 && i != 41) ||
    (r < t.text.length - 1 && !Fr(t.text.charCodeAt(r + 1))) ||
    (n && !NL(e, oe.OrderedList) && (t.skipSpace(r + 1) == t.text.length || r > t.pos + 1 || t.next != 49))
    ? -1
    : r + 1 - t.pos;
}
function LL(t) {
  if (t.next != 35) return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == 35; ) e++;
  if (e < t.text.length && t.text.charCodeAt(e) != 32) return -1;
  let n = e - t.pos;
  return n > 6 ? -1 : n;
}
function ML(t) {
  if ((t.next != 45 && t.next != 61) || t.indent >= t.baseIndent + 4) return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; ) e++;
  let n = e;
  for (; e < t.text.length && Fr(t.text.charCodeAt(e)); ) e++;
  return e == t.text.length ? n : -1;
}
const Dx = /^[ \t]*$/,
  DL = /-->/,
  QL = /\?>/,
  Qx = [
    [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
    [/^\s*<!--/, DL],
    [/^\s*<\?/, QL],
    [/^\s*<![A-Z]/, />/],
    [/^\s*<!\[CDATA\[/, /\]\]>/],
    [
      /^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i,
      Dx,
    ],
    [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Dx],
  ];
function FL(t, e, n) {
  if (t.next != 60) return -1;
  let r = t.text.slice(t.pos);
  for (let i = 0, s = Qx.length - (n ? 1 : 0); i < s; i++) if (Qx[i][0].test(r)) return i;
  return -1;
}
function YT(t, e) {
  let n = t.countIndent(e, t.pos, t.indent),
    r = t.countIndent(t.skipSpace(e), e, n);
  return r >= n + 5 ? n + 1 : r;
}
function Po(t, e, n) {
  let r = t.length - 1;
  r >= 0 && t[r].to == e && t[r].type == oe.CodeText ? (t[r].to = n) : t.push(Ke(oe.CodeText, e, n));
}
const gd = {
  LinkReference: void 0,
  IndentedCode(t, e) {
    let n = e.baseIndent + 4;
    if (e.indent < n) return !1;
    let r = e.findColumn(n),
      i = t.lineStart + r,
      s = t.lineStart + e.text.length,
      o = [],
      a = [];
    for (Po(o, i, s); t.nextLine() && e.depth >= t.stack.length; )
      if (e.pos == e.text.length) {
        Po(a, t.lineStart - 1, t.lineStart);
        for (let l of e.markers) a.push(l);
      } else {
        if (e.indent < n) break;
        {
          if (a.length) {
            for (let c of a) c.type == oe.CodeText ? Po(o, c.from, c.to) : o.push(c);
            a = [];
          }
          Po(o, t.lineStart - 1, t.lineStart);
          for (let c of e.markers) o.push(c);
          s = t.lineStart + e.text.length;
          let l = t.lineStart + e.findColumn(e.baseIndent + 4);
          l < s && Po(o, l, s);
        }
      }
    return (
      a.length && ((a = a.filter((l) => l.type != oe.CodeText)), a.length && (e.markers = a.concat(e.markers))),
      t.addNode(t.buffer.writeElements(o, -i).finish(oe.CodeBlock, s - i), i),
      !0
    );
  },
  FencedCode(t, e) {
    let n = RL(e);
    if (n < 0) return !1;
    let r = t.lineStart + e.pos,
      i = e.next,
      s = n - e.pos,
      o = e.skipSpace(n),
      a = qT(e.text, e.text.length, o),
      l = [Ke(oe.CodeMark, r, r + s)];
    o < a && l.push(Ke(oe.CodeInfo, t.lineStart + o, t.lineStart + a));
    for (let c = !0; t.nextLine() && e.depth >= t.stack.length; c = !1) {
      let u = e.pos;
      if (e.indent - e.baseIndent < 4) for (; u < e.text.length && e.text.charCodeAt(u) == i; ) u++;
      if (u - e.pos >= s && e.skipSpace(u) == e.text.length) {
        for (let h of e.markers) l.push(h);
        l.push(Ke(oe.CodeMark, t.lineStart + e.pos, t.lineStart + u)), t.nextLine();
        break;
      } else {
        c || Po(l, t.lineStart - 1, t.lineStart);
        for (let d of e.markers) l.push(d);
        let h = t.lineStart + e.basePos,
          f = t.lineStart + e.text.length;
        h < f && Po(l, h, f);
      }
    }
    return t.addNode(t.buffer.writeElements(l, -r).finish(oe.FencedCode, t.prevLineEnd() - r), r), !0;
  },
  Blockquote(t, e) {
    let n = IL(e);
    return n < 0
      ? !1
      : (t.startContext(oe.Blockquote, e.pos),
        t.addNode(oe.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1),
        e.moveBase(e.pos + n),
        null);
  },
  HorizontalRule(t, e) {
    if (ck(e, t, !1) < 0) return !1;
    let n = t.lineStart + e.pos;
    return t.nextLine(), t.addNode(oe.HorizontalRule, n), !0;
  },
  BulletList(t, e) {
    let n = uk(e, t, !1);
    if (n < 0) return !1;
    t.block.type != oe.BulletList && t.startContext(oe.BulletList, e.basePos, e.next);
    let r = YT(e, e.pos + 1);
    return (
      t.startContext(oe.ListItem, e.basePos, r - e.baseIndent),
      t.addNode(oe.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + n),
      e.moveBaseColumn(r),
      null
    );
  },
  OrderedList(t, e) {
    let n = hk(e, t, !1);
    if (n < 0) return !1;
    t.block.type != oe.OrderedList && t.startContext(oe.OrderedList, e.basePos, e.text.charCodeAt(e.pos + n - 1));
    let r = YT(e, e.pos + n);
    return (
      t.startContext(oe.ListItem, e.basePos, r - e.baseIndent),
      t.addNode(oe.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + n),
      e.moveBaseColumn(r),
      null
    );
  },
  ATXHeading(t, e) {
    let n = LL(e);
    if (n < 0) return !1;
    let r = e.pos,
      i = t.lineStart + r,
      s = qT(e.text, e.text.length, r),
      o = s;
    for (; o > r && e.text.charCodeAt(o - 1) == e.next; ) o--;
    (o == s || o == r || !Fr(e.text.charCodeAt(o - 1))) && (o = e.text.length);
    let a = t.buffer.write(oe.HeaderMark, 0, n).writeElements(t.parser.parseInline(e.text.slice(r + n + 1, o), i + n + 1), -i);
    o < e.text.length && a.write(oe.HeaderMark, o - r, s - r);
    let l = a.finish(oe.ATXHeading1 - 1 + n, e.text.length - r);
    return t.nextLine(), t.addNode(l, i), !0;
  },
  HTMLBlock(t, e) {
    let n = FL(e, t, !1);
    if (n < 0) return !1;
    let r = t.lineStart + e.pos,
      i = Qx[n][1],
      s = [],
      o = i != Dx;
    for (; !i.test(e.text) && t.nextLine(); ) {
      if (e.depth < t.stack.length) {
        o = !1;
        break;
      }
      for (let c of e.markers) s.push(c);
    }
    o && t.nextLine();
    let a = i == DL ? oe.CommentBlock : i == QL ? oe.ProcessingInstructionBlock : oe.HTMLBlock,
      l = t.prevLineEnd();
    return t.addNode(t.buffer.writeElements(s, -r).finish(a, l - r), r), !0;
  },
  SetextHeading: void 0,
};
class G1e {
  constructor(e) {
    (this.stage = 0), (this.elts = []), (this.pos = 0), (this.start = e.start), this.advance(e.content);
  }
  nextLine(e, n, r) {
    if (this.stage == -1) return !1;
    let i =
        r.content +
        `
` +
        n.scrub(),
      s = this.advance(i);
    return s > -1 && s < i.length ? this.complete(e, r, s) : !1;
  }
  finish(e, n) {
    return (this.stage == 2 || this.stage == 3) && Ou(n.content, this.pos) == n.content.length ? this.complete(e, n, n.content.length) : !1;
  }
  complete(e, n, r) {
    return e.addLeafElement(n, Ke(oe.LinkReference, this.start, this.start + r, this.elts)), !0;
  }
  nextStage(e) {
    return e ? ((this.pos = e.to - this.start), this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (;;) {
      if (this.stage == -1) return -1;
      if (this.stage == 0) {
        if (!this.nextStage(HL(e, this.pos, this.start, !0))) return -1;
        if (e.charCodeAt(this.pos) != 58) return (this.stage = -1);
        this.elts.push(Ke(oe.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(UL(e, Ou(e, this.pos), this.start))) return -1;
      } else if (this.stage == 2) {
        let n = Ou(e, this.pos),
          r = 0;
        if (n > this.pos) {
          let i = XL(e, n, this.start);
          if (i) {
            let s = U1(e, i.to - this.start);
            s > 0 && (this.nextStage(i), (r = s));
          }
        }
        return r || (r = U1(e, this.pos)), r > 0 && r < e.length ? r : -1;
      } else return U1(e, this.pos);
    }
  }
}
function U1(t, e) {
  for (; e < t.length; e++) {
    let n = t.charCodeAt(e);
    if (n == 10) break;
    if (!Fr(n)) return -1;
  }
  return e;
}
class J1e {
  nextLine(e, n, r) {
    let i = n.depth < e.stack.length ? -1 : ML(n),
      s = n.next;
    if (i < 0) return !1;
    let o = Ke(oe.HeaderMark, e.lineStart + n.pos, e.lineStart + i);
    return (
      e.nextLine(),
      e.addLeafElement(
        r,
        Ke(s == 61 ? oe.SetextHeading1 : oe.SetextHeading2, r.start, e.prevLineEnd(), [...e.parser.parseInline(r.content, r.start), o])
      ),
      !0
    );
  }
  finish() {
    return !1;
  }
}
const K1e = {
    LinkReference(t, e) {
      return e.content.charCodeAt(0) == 91 ? new G1e(e) : null;
    },
    SetextHeading() {
      return new J1e();
    },
  },
  eOe = [
    (t, e) => LL(e) >= 0,
    (t, e) => RL(e) >= 0,
    (t, e) => IL(e) >= 0,
    (t, e) => uk(e, t, !0) >= 0,
    (t, e) => hk(e, t, !0) >= 0,
    (t, e) => ck(e, t, !0) >= 0,
    (t, e) => FL(e, t, !0) >= 0,
  ],
  tOe = { text: "", end: 0 };
class nOe {
  constructor(e, n, r, i) {
    (this.parser = e),
      (this.input = n),
      (this.ranges = i),
      (this.line = new Y1e()),
      (this.atEnd = !1),
      (this.reusePlaceholders = new Map()),
      (this.stoppedAt = null),
      (this.rangeI = 0),
      (this.to = i[i.length - 1].to),
      (this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = i[0].from),
      (this.block = pm.create(oe.Document, 0, this.lineStart, 0, 0)),
      (this.stack = [this.block]),
      (this.fragments = r.length ? new oOe(r, n) : null),
      this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt) return this.finish();
    let { line: e } = this;
    for (;;) {
      for (let r = 0; ; ) {
        let i = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; r < e.markers.length && (!i || e.markers[r].from < i.end); ) {
          let s = e.markers[r++];
          this.addNode(s.type, s.from, s.to);
        }
        if (!i) break;
        this.finishContext();
      }
      if (e.pos < e.text.length) break;
      if (!this.nextLine()) return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos)) return null;
    e: for (;;) {
      for (let r of this.parser.blockParsers)
        if (r) {
          let i = r(this, e);
          if (i != !1) {
            if (i == !0) return null;
            e.forward();
            continue e;
          }
        }
      break;
    }
    let n = new q1e(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let r of this.parser.leafBlockParsers)
      if (r) {
        let i = r(this, n);
        i && n.parsers.push(i);
      }
    e: for (; this.nextLine() && e.pos != e.text.length; ) {
      if (e.indent < e.baseIndent + 4) {
        for (let r of this.parser.endLeafBlock) if (r(this, e, n)) break e;
      }
      for (let r of n.parsers) if (r.nextLine(this, e, n)) return null;
      n.content +=
        `
` + e.scrub();
      for (let r of e.markers) n.marks.push(r);
    }
    return this.finishLeaf(n), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash)) return !1;
    let n = this.fragments.takeNodes(this);
    return n
      ? ((this.absoluteLineStart += n),
        (this.lineStart = qL(this.absoluteLineStart, this.ranges)),
        this.moveRangeI(),
        this.absoluteLineStart < this.to
          ? (this.lineStart++, this.absoluteLineStart++, this.readLine())
          : ((this.atEnd = !0), this.readLine()),
        !0)
      : !1;
  }
  get depth() {
    return this.stack.length;
  }
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  nextLine() {
    return (
      (this.lineStart += this.line.text.length),
      this.absoluteLineEnd >= this.to
        ? ((this.absoluteLineStart = this.absoluteLineEnd), (this.atEnd = !0), this.readLine(), !1)
        : (this.lineStart++, (this.absoluteLineStart = this.absoluteLineEnd + 1), this.moveRangeI(), this.readLine(), !0)
    );
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, (this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from));
  }
  scanLine(e) {
    let n = tOe;
    if (((n.end = e), e >= this.to)) n.text = "";
    else if (((n.text = this.lineChunkAt(e)), (n.end += n.text.length), this.ranges.length > 1)) {
      let r = this.absoluteLineStart,
        i = this.rangeI;
      for (; this.ranges[i].to < n.end; ) {
        i++;
        let s = this.ranges[i].from,
          o = this.lineChunkAt(s);
        (n.end = s + o.length), (n.text = n.text.slice(0, this.ranges[i - 1].to - r) + o), (r = n.end - n.text.length);
      }
    }
    return n;
  }
  readLine() {
    let { line: e } = this,
      { text: n, end: r } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = r, e.reset(n); e.depth < this.stack.length; e.depth++) {
      let i = this.stack[e.depth],
        s = this.parser.skipContextMarkup[i.type];
      if (!s) throw new Error("Unhandled block context " + oe[i.type]);
      if (!s(i, this, e)) break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let n = this.input.chunk(e),
      r;
    if (this.input.lineChunks)
      r =
        n ==
        `
`
          ? ""
          : n;
    else {
      let i = n.indexOf(`
`);
      r = i < 0 ? n : n.slice(0, i);
    }
    return e + r.length > this.to ? r.slice(0, this.to - e) : r;
  }
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  startContext(e, n, r = 0) {
    (this.block = pm.create(e, r, this.lineStart + n, this.block.hash, this.lineStart + this.line.text.length)),
      this.stack.push(this.block);
  }
  startComposite(e, n, r = 0) {
    this.startContext(this.parser.getNodeType(e), n, r);
  }
  addNode(e, n, r) {
    typeof e == "number" && (e = new ze(this.parser.nodeSet.types[e], Dl, Dl, (r ?? this.prevLineEnd()) - n)),
      this.block.addChild(e, n - this.block.from);
  }
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  addLeafElement(e, n) {
    this.addNode(this.buffer.writeElements(Bx(n.children, e.marks), -n.from).finish(n.type, n.to - n.from), n.from);
  }
  finishContext() {
    let e = this.stack.pop(),
      n = this.stack[this.stack.length - 1];
    n.addChild(e.toTree(this.parser.nodeSet), e.from - n.from), (this.block = n);
  }
  finish() {
    for (; this.stack.length > 1; ) this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? VL(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  finishLeaf(e) {
    for (let r of e.parsers) if (r.finish(this, e)) return;
    let n = Bx(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(n, -e.start).finish(oe.Paragraph, e.content.length), e.start);
  }
  elt(e, n, r, i) {
    return typeof e == "string" ? Ke(this.parser.getNodeType(e), n, r, i) : new ZL(e, n);
  }
  get buffer() {
    return new jL(this.parser.nodeSet);
  }
}
function VL(t, e, n, r, i) {
  let s = t[e].to,
    o = [],
    a = [],
    l = n.from + r;
  function c(u, h) {
    for (; h ? u >= s : u > s; ) {
      let f = t[e + 1].from - s;
      (r += f), (u += f), e++, (s = t[e].to);
    }
  }
  for (let u = n.firstChild; u; u = u.nextSibling) {
    c(u.from + r, !0);
    let h = u.from + r,
      f,
      d = i.get(u.tree);
    d ? (f = d) : u.to + r > s ? ((f = VL(t, e, u, r, i)), c(u.to + r, !1)) : (f = u.toTree()), o.push(f), a.push(h - l);
  }
  return c(n.to + r, !1), new ze(n.type, o, a, n.to + r - l, n.tree ? n.tree.propValues : void 0);
}
class qg extends Cg {
  constructor(e, n, r, i, s, o, a, l, c) {
    super(),
      (this.nodeSet = e),
      (this.blockParsers = n),
      (this.leafBlockParsers = r),
      (this.blockNames = i),
      (this.endLeafBlock = s),
      (this.skipContextMarkup = o),
      (this.inlineParsers = a),
      (this.inlineNames = l),
      (this.wrappers = c),
      (this.nodeTypes = Object.create(null));
    for (let u of e.types) this.nodeTypes[u.name] = u.id;
  }
  createParse(e, n, r) {
    let i = new nOe(this, e, n, r);
    for (let s of this.wrappers) i = s(i, e, n, r);
    return i;
  }
  configure(e) {
    let n = Fx(e);
    if (!n) return this;
    let { nodeSet: r, skipContextMarkup: i } = this,
      s = this.blockParsers.slice(),
      o = this.leafBlockParsers.slice(),
      a = this.blockNames.slice(),
      l = this.inlineParsers.slice(),
      c = this.inlineNames.slice(),
      u = this.endLeafBlock.slice(),
      h = this.wrappers;
    if (Ic(n.defineNodes)) {
      i = Object.assign({}, i);
      let f = r.types.slice(),
        d;
      for (let p of n.defineNodes) {
        let { name: m, block: O, composite: v, style: g } = typeof p == "string" ? { name: p } : p;
        if (f.some((S) => S.name == m)) continue;
        v && (i[f.length] = (S, k, b) => v(k, b, S.value));
        let x = f.length,
          y = v
            ? ["Block", "BlockContext"]
            : O
            ? x >= oe.ATXHeading1 && x <= oe.SetextHeading2
              ? ["Block", "LeafBlock", "Heading"]
              : ["Block", "LeafBlock"]
            : void 0;
        f.push(Kt.define({ id: x, name: m, props: y && [[Ie.group, y]] })),
          g && (d || (d = {}), Array.isArray(g) || g instanceof Ur ? (d[m] = g) : Object.assign(d, g));
      }
      (r = new ic(f)), d && (r = r.extend(sc(d)));
    }
    if ((Ic(n.props) && (r = r.extend(...n.props)), Ic(n.remove)))
      for (let f of n.remove) {
        let d = this.blockNames.indexOf(f),
          p = this.inlineNames.indexOf(f);
        d > -1 && (s[d] = o[d] = void 0), p > -1 && (l[p] = void 0);
      }
    if (Ic(n.parseBlock))
      for (let f of n.parseBlock) {
        let d = a.indexOf(f.name);
        if (d > -1) (s[d] = f.parse), (o[d] = f.leaf);
        else {
          let p = f.before ? Od(a, f.before) : f.after ? Od(a, f.after) + 1 : a.length - 1;
          s.splice(p, 0, f.parse), o.splice(p, 0, f.leaf), a.splice(p, 0, f.name);
        }
        f.endLeaf && u.push(f.endLeaf);
      }
    if (Ic(n.parseInline))
      for (let f of n.parseInline) {
        let d = c.indexOf(f.name);
        if (d > -1) l[d] = f.parse;
        else {
          let p = f.before ? Od(c, f.before) : f.after ? Od(c, f.after) + 1 : c.length - 1;
          l.splice(p, 0, f.parse), c.splice(p, 0, f.name);
        }
      }
    return n.wrap && (h = h.concat(n.wrap)), new qg(r, s, o, a, u, i, l, c, h);
  }
  getNodeType(e) {
    let n = this.nodeTypes[e];
    if (n == null) throw new RangeError(`Unknown node type '${e}'`);
    return n;
  }
  parseInline(e, n) {
    let r = new iOe(this, e, n);
    e: for (let i = n; i < r.end; ) {
      let s = r.char(i);
      for (let o of this.inlineParsers)
        if (o) {
          let a = o(r, s, i);
          if (a >= 0) {
            i = a;
            continue e;
          }
        }
      i++;
    }
    return r.resolveMarkers(0);
  }
}
function Ic(t) {
  return t != null && t.length > 0;
}
function Fx(t) {
  if (!Array.isArray(t)) return t;
  if (t.length == 0) return null;
  let e = Fx(t[0]);
  if (t.length == 1) return e;
  let n = Fx(t.slice(1));
  if (!n || !e) return e || n;
  let r = (o, a) => (o || Dl).concat(a || Dl),
    i = e.wrap,
    s = n.wrap;
  return {
    props: r(e.props, n.props),
    defineNodes: r(e.defineNodes, n.defineNodes),
    parseBlock: r(e.parseBlock, n.parseBlock),
    parseInline: r(e.parseInline, n.parseInline),
    remove: r(e.remove, n.remove),
    wrap: i ? (s ? (o, a, l, c) => i(s(o, a, l, c), a, l, c) : i) : s,
  };
}
function Od(t, e) {
  let n = t.indexOf(e);
  if (n < 0) throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return n;
}
let BL = [Kt.none];
for (let t = 1, e; (e = oe[t]); t++)
  BL[t] = Kt.define({
    id: t,
    name: e,
    props: t >= oe.Escape ? [] : [[Ie.group, t in $L ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document",
  });
const Dl = [];
class jL {
  constructor(e) {
    (this.nodeSet = e), (this.content = []), (this.nodes = []);
  }
  write(e, n, r, i = 0) {
    return this.content.push(e, n, r, 4 + i * 4), this;
  }
  writeElements(e, n = 0) {
    for (let r of e) r.writeTo(this, n);
    return this;
  }
  finish(e, n) {
    return ze.build({ buffer: this.content, nodeSet: this.nodeSet, reused: this.nodes, topID: e, length: n });
  }
}
let hh = class {
  constructor(e, n, r, i = Dl) {
    (this.type = e), (this.from = n), (this.to = r), (this.children = i);
  }
  writeTo(e, n) {
    let r = e.content.length;
    e.writeElements(this.children, n), e.content.push(this.type, this.from + n, this.to + n, e.content.length + 4 - r);
  }
  toTree(e) {
    return new jL(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
class ZL {
  constructor(e, n) {
    (this.tree = e), (this.from = n);
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Dl;
  }
  writeTo(e, n) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + n, this.to + n, -1);
  }
  toTree() {
    return this.tree;
  }
}
function Ke(t, e, n, r) {
  return new hh(t, e, n, r);
}
const zL = { resolve: "Emphasis", mark: "EmphasisMark" },
  WL = { resolve: "Emphasis", mark: "EmphasisMark" },
  Da = {},
  Vx = {};
class Cr {
  constructor(e, n, r, i) {
    (this.type = e), (this.from = n), (this.to = r), (this.side = i);
  }
}
const GT = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let fh = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  fh = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {}
const X1 = {
  Escape(t, e, n) {
    if (e != 92 || n == t.end - 1) return -1;
    let r = t.char(n + 1);
    for (let i = 0; i < GT.length; i++) if (GT.charCodeAt(i) == r) return t.append(Ke(oe.Escape, n, n + 2));
    return -1;
  },
  Entity(t, e, n) {
    if (e != 38) return -1;
    let r = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(t.slice(n + 1, n + 31));
    return r ? t.append(Ke(oe.Entity, n, n + 1 + r[0].length)) : -1;
  },
  InlineCode(t, e, n) {
    if (e != 96 || (n && t.char(n - 1) == 96)) return -1;
    let r = n + 1;
    for (; r < t.end && t.char(r) == 96; ) r++;
    let i = r - n,
      s = 0;
    for (; r < t.end; r++)
      if (t.char(r) == 96) {
        if ((s++, s == i && t.char(r + 1) != 96))
          return t.append(Ke(oe.InlineCode, n, r + 1, [Ke(oe.CodeMark, n, n + i), Ke(oe.CodeMark, r + 1 - i, r + 1)]));
      } else s = 0;
    return -1;
  },
  HTMLTag(t, e, n) {
    if (e != 60 || n == t.end - 1) return -1;
    let r = t.slice(n + 1, t.end),
      i =
        /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(
          r
        );
    if (i)
      return t.append(
        Ke(oe.Autolink, n, n + 1 + i[0].length, [
          Ke(oe.LinkMark, n, n + 1),
          Ke(oe.URL, n + 1, n + i[0].length),
          Ke(oe.LinkMark, n + i[0].length, n + 1 + i[0].length),
        ])
      );
    let s = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(r);
    if (s) return t.append(Ke(oe.Comment, n, n + 1 + s[0].length));
    let o = /^\?[^]*?\?>/.exec(r);
    if (o) return t.append(Ke(oe.ProcessingInstruction, n, n + 1 + o[0].length));
    let a =
      /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(
        r
      );
    return a ? t.append(Ke(oe.HTMLTag, n, n + 1 + a[0].length)) : -1;
  },
  Emphasis(t, e, n) {
    if (e != 95 && e != 42) return -1;
    let r = n + 1;
    for (; t.char(r) == e; ) r++;
    let i = t.slice(n - 1, n),
      s = t.slice(r, r + 1),
      o = fh.test(i),
      a = fh.test(s),
      l = /\s|^$/.test(i),
      c = /\s|^$/.test(s),
      u = !c && (!a || l || o),
      h = !l && (!o || c || a),
      f = u && (e == 42 || !h || o),
      d = h && (e == 42 || !u || a);
    return t.append(new Cr(e == 95 ? zL : WL, n, r, (f ? 1 : 0) | (d ? 2 : 0)));
  },
  HardBreak(t, e, n) {
    if (e == 92 && t.char(n + 1) == 10) return t.append(Ke(oe.HardBreak, n, n + 2));
    if (e == 32) {
      let r = n + 1;
      for (; t.char(r) == 32; ) r++;
      if (t.char(r) == 10 && r >= n + 2) return t.append(Ke(oe.HardBreak, n, r + 1));
    }
    return -1;
  },
  Link(t, e, n) {
    return e == 91 ? t.append(new Cr(Da, n, n + 1, 1)) : -1;
  },
  Image(t, e, n) {
    return e == 33 && t.char(n + 1) == 91 ? t.append(new Cr(Vx, n, n + 2, 1)) : -1;
  },
  LinkEnd(t, e, n) {
    if (e != 93) return -1;
    for (let r = t.parts.length - 1; r >= 0; r--) {
      let i = t.parts[r];
      if (i instanceof Cr && (i.type == Da || i.type == Vx)) {
        if (!i.side || (t.skipSpace(i.to) == n && !/[(\[]/.test(t.slice(n + 1, n + 2)))) return (t.parts[r] = null), -1;
        let s = t.takeContent(r),
          o = (t.parts[r] = rOe(t, s, i.type == Da ? oe.Link : oe.Image, i.from, n + 1));
        if (i.type == Da)
          for (let a = 0; a < r; a++) {
            let l = t.parts[a];
            l instanceof Cr && l.type == Da && (l.side = 0);
          }
        return o.to;
      }
    }
    return -1;
  },
};
function rOe(t, e, n, r, i) {
  let { text: s } = t,
    o = t.char(i),
    a = i;
  if ((e.unshift(Ke(oe.LinkMark, r, r + (n == oe.Image ? 2 : 1))), e.push(Ke(oe.LinkMark, i - 1, i)), o == 40)) {
    let l = t.skipSpace(i + 1),
      c = UL(s, l - t.offset, t.offset),
      u;
    c && ((l = t.skipSpace(c.to)), l != c.to && ((u = XL(s, l - t.offset, t.offset)), u && (l = t.skipSpace(u.to)))),
      t.char(l) == 41 && (e.push(Ke(oe.LinkMark, i, i + 1)), (a = l + 1), c && e.push(c), u && e.push(u), e.push(Ke(oe.LinkMark, l, a)));
  } else if (o == 91) {
    let l = HL(s, i - t.offset, t.offset, !1);
    l && (e.push(l), (a = l.to));
  }
  return Ke(n, r, a, e);
}
function UL(t, e, n) {
  if (t.charCodeAt(e) == 60) {
    for (let i = e + 1; i < t.length; i++) {
      let s = t.charCodeAt(i);
      if (s == 62) return Ke(oe.URL, e + n, i + 1 + n);
      if (s == 60 || s == 10) return !1;
    }
    return null;
  } else {
    let i = 0,
      s = e;
    for (let o = !1; s < t.length; s++) {
      let a = t.charCodeAt(s);
      if (Fr(a)) break;
      if (o) o = !1;
      else if (a == 40) i++;
      else if (a == 41) {
        if (!i) break;
        i--;
      } else a == 92 && (o = !0);
    }
    return s > e ? Ke(oe.URL, e + n, s + n) : s == t.length ? null : !1;
  }
}
function XL(t, e, n) {
  let r = t.charCodeAt(e);
  if (r != 39 && r != 34 && r != 40) return !1;
  let i = r == 40 ? 41 : r;
  for (let s = e + 1, o = !1; s < t.length; s++) {
    let a = t.charCodeAt(s);
    if (o) o = !1;
    else {
      if (a == i) return Ke(oe.LinkTitle, e + n, s + 1 + n);
      a == 92 && (o = !0);
    }
  }
  return null;
}
function HL(t, e, n, r) {
  for (let i = !1, s = e + 1, o = Math.min(t.length, s + 999); s < o; s++) {
    let a = t.charCodeAt(s);
    if (i) i = !1;
    else {
      if (a == 93) return r ? !1 : Ke(oe.LinkLabel, e + n, s + 1 + n);
      if ((r && !Fr(a) && (r = !1), a == 91)) return !1;
      a == 92 && (i = !0);
    }
  }
  return null;
}
class iOe {
  constructor(e, n, r) {
    (this.parser = e), (this.text = n), (this.offset = r), (this.parts = []);
  }
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  get end() {
    return this.offset + this.text.length;
  }
  slice(e, n) {
    return this.text.slice(e - this.offset, n - this.offset);
  }
  append(e) {
    return this.parts.push(e), e.to;
  }
  addDelimiter(e, n, r, i, s) {
    return this.append(new Cr(e, n, r, (i ? 1 : 0) | (s ? 2 : 0)));
  }
  get hasOpenLink() {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let n = this.parts[e];
      if (n instanceof Cr && (n.type == Da || n.type == Vx)) return !0;
    }
    return !1;
  }
  addElement(e) {
    return this.append(e);
  }
  resolveMarkers(e) {
    for (let r = e; r < this.parts.length; r++) {
      let i = this.parts[r];
      if (!(i instanceof Cr && i.type.resolve && i.side & 2)) continue;
      let s = i.type == zL || i.type == WL,
        o = i.to - i.from,
        a,
        l = r - 1;
      for (; l >= e; l--) {
        let m = this.parts[l];
        if (
          m instanceof Cr &&
          m.side & 1 &&
          m.type == i.type &&
          !(s && (i.side & 1 || m.side & 2) && (m.to - m.from + o) % 3 == 0 && ((m.to - m.from) % 3 || o % 3))
        ) {
          a = m;
          break;
        }
      }
      if (!a) continue;
      let c = i.type.resolve,
        u = [],
        h = a.from,
        f = i.to;
      if (s) {
        let m = Math.min(2, a.to - a.from, o);
        (h = a.to - m), (f = i.from + m), (c = m == 1 ? "Emphasis" : "StrongEmphasis");
      }
      a.type.mark && u.push(this.elt(a.type.mark, h, a.to));
      for (let m = l + 1; m < r; m++) this.parts[m] instanceof hh && u.push(this.parts[m]), (this.parts[m] = null);
      i.type.mark && u.push(this.elt(i.type.mark, i.from, f));
      let d = this.elt(c, h, f, u);
      (this.parts[l] = s && a.from != h ? new Cr(a.type, a.from, h, a.side) : null),
        (this.parts[r] = s && i.to != f ? new Cr(i.type, f, i.to, i.side) : null) ? this.parts.splice(r, 0, d) : (this.parts[r] = d);
    }
    let n = [];
    for (let r = e; r < this.parts.length; r++) {
      let i = this.parts[r];
      i instanceof hh && n.push(i);
    }
    return n;
  }
  findOpeningDelimiter(e) {
    for (let n = this.parts.length - 1; n >= 0; n--) {
      let r = this.parts[n];
      if (r instanceof Cr && r.type == e) return n;
    }
    return null;
  }
  takeContent(e) {
    let n = this.resolveMarkers(e);
    return (this.parts.length = e), n;
  }
  skipSpace(e) {
    return Ou(this.text, e - this.offset) + this.offset;
  }
  elt(e, n, r, i) {
    return typeof e == "string" ? Ke(this.parser.getNodeType(e), n, r, i) : new ZL(e, n);
  }
}
function Bx(t, e) {
  if (!e.length) return t;
  if (!t.length) return e;
  let n = t.slice(),
    r = 0;
  for (let i of e) {
    for (; r < n.length && n[r].to < i.to; ) r++;
    if (r < n.length && n[r].from < i.from) {
      let s = n[r];
      s instanceof hh && (n[r] = new hh(s.type, s.from, s.to, Bx(s.children, [i])));
    } else n.splice(r++, 0, i);
  }
  return n;
}
const sOe = [oe.CodeBlock, oe.ListItem, oe.OrderedList, oe.BulletList];
class oOe {
  constructor(e, n) {
    (this.fragments = e),
      (this.input = n),
      (this.i = 0),
      (this.fragment = null),
      (this.fragmentEnd = -1),
      (this.cursor = null),
      e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    (this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null), (this.cursor = null), (this.fragmentEnd = -1);
  }
  moveTo(e, n) {
    for (; this.fragment && this.fragment.to <= e; ) this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0)) return !1;
    if (this.fragmentEnd < 0) {
      let s = this.fragment.to;
      for (
        ;
        s > 0 &&
        this.input.read(s - 1, s) !=
          `
`;

      )
        s--;
      this.fragmentEnd = s ? s - 1 : 0;
    }
    let r = this.cursor;
    r || ((r = this.cursor = this.fragment.tree.cursor()), r.firstChild());
    let i = e + this.fragment.offset;
    for (; r.to <= i; ) if (!r.parent()) return !1;
    for (;;) {
      if (r.from >= i) return this.fragment.from <= n;
      if (!r.childAfter(i)) return !1;
    }
  }
  matches(e) {
    let n = this.cursor.tree;
    return n && n.prop(Ie.contextHash) == e;
  }
  takeNodes(e) {
    let n = this.cursor,
      r = this.fragment.offset,
      i = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0),
      s = e.absoluteLineStart,
      o = s,
      a = e.block.children.length,
      l = o,
      c = a;
    for (;;) {
      if (n.to - r > i) {
        if (n.type.isAnonymous && n.firstChild()) continue;
        break;
      }
      let u = qL(n.from - r, e.ranges);
      if (n.to - r <= e.ranges[e.rangeI].to) e.addNode(n.tree, u);
      else {
        let h = new ze(e.parser.nodeSet.types[oe.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(h, n.tree), e.addNode(h, u);
      }
      if (
        (n.type.is("Block") &&
          (sOe.indexOf(n.type.id) < 0
            ? ((o = n.to - r), (a = e.block.children.length))
            : ((o = l), (a = c), (l = n.to - r), (c = e.block.children.length))),
        !n.nextSibling())
      )
        break;
    }
    for (; e.block.children.length > a; ) e.block.children.pop(), e.block.positions.pop();
    return o - s;
  }
}
function qL(t, e) {
  let n = t;
  for (let r = 1; r < e.length; r++) {
    let i = e[r - 1].to,
      s = e[r].from;
    i < t && (n -= s - i);
  }
  return n;
}
const aOe = sc({
    "Blockquote/...": R.quote,
    HorizontalRule: R.contentSeparator,
    "ATXHeading1/... SetextHeading1/...": R.heading1,
    "ATXHeading2/... SetextHeading2/...": R.heading2,
    "ATXHeading3/...": R.heading3,
    "ATXHeading4/...": R.heading4,
    "ATXHeading5/...": R.heading5,
    "ATXHeading6/...": R.heading6,
    "Comment CommentBlock": R.comment,
    Escape: R.escape,
    Entity: R.character,
    "Emphasis/...": R.emphasis,
    "StrongEmphasis/...": R.strong,
    "Link/... Image/...": R.link,
    "OrderedList/... BulletList/...": R.list,
    "BlockQuote/...": R.quote,
    "InlineCode CodeText": R.monospace,
    "URL Autolink": R.url,
    "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": R.processingInstruction,
    "CodeInfo LinkLabel": R.labelName,
    LinkTitle: R.string,
    Paragraph: R.content,
  }),
  lOe = new qg(
    new ic(BL).extend(aOe),
    Object.keys(gd).map((t) => gd[t]),
    Object.keys(gd).map((t) => K1e[t]),
    Object.keys(gd),
    eOe,
    $L,
    Object.keys(X1).map((t) => X1[t]),
    Object.keys(X1),
    []
  );
function cOe(t, e, n) {
  let r = [];
  for (let i = t.firstChild, s = e; ; i = i.nextSibling) {
    let o = i ? i.from : n;
    if ((o > s && r.push({ from: s, to: o }), !i)) break;
    s = i.to;
  }
  return r;
}
function uOe(t) {
  let { codeParser: e, htmlParser: n } = t;
  return {
    wrap: J4((i, s) => {
      let o = i.type.id;
      if (e && (o == oe.CodeBlock || o == oe.FencedCode)) {
        let a = "";
        if (o == oe.FencedCode) {
          let c = i.node.getChild(oe.CodeInfo);
          c && (a = s.read(c.from, c.to));
        }
        let l = e(a);
        if (l) return { parser: l, overlay: (c) => c.type.id == oe.CodeText };
      } else if (n && (o == oe.HTMLBlock || o == oe.HTMLTag)) return { parser: n, overlay: cOe(i.node, i.from, i.to) };
      return null;
    }),
  };
}
const hOe = { resolve: "Strikethrough", mark: "StrikethroughMark" },
  fOe = {
    defineNodes: [
      { name: "Strikethrough", style: { "Strikethrough/...": R.strikethrough } },
      { name: "StrikethroughMark", style: R.processingInstruction },
    ],
    parseInline: [
      {
        name: "Strikethrough",
        parse(t, e, n) {
          if (e != 126 || t.char(n + 1) != 126 || t.char(n + 2) == 126) return -1;
          let r = t.slice(n - 1, n),
            i = t.slice(n + 2, n + 3),
            s = /\s|^$/.test(r),
            o = /\s|^$/.test(i),
            a = fh.test(r),
            l = fh.test(i);
          return t.addDelimiter(hOe, n, n + 2, !o && (!l || s || a), !s && (!a || o || l));
        },
        after: "Emphasis",
      },
    ],
  };
function vu(t, e, n = 0, r, i = 0) {
  let s = 0,
    o = !0,
    a = -1,
    l = -1,
    c = !1,
    u = () => {
      r.push(t.elt("TableCell", i + a, i + l, t.parser.parseInline(e.slice(a, l), i + a)));
    };
  for (let h = n; h < e.length; h++) {
    let f = e.charCodeAt(h);
    f == 124 && !c
      ? ((!o || a > -1) && s++, (o = !1), r && (a > -1 && u(), r.push(t.elt("TableDelimiter", h + i, h + i + 1))), (a = l = -1))
      : (c || (f != 32 && f != 9)) && (a < 0 && (a = h), (l = h + 1)),
      (c = !c && f == 92);
  }
  return a > -1 && (s++, r && u()), s;
}
function JT(t, e) {
  for (let n = e; n < t.length; n++) {
    let r = t.charCodeAt(n);
    if (r == 124) return !0;
    r == 92 && n++;
  }
  return !1;
}
const YL = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class KT {
  constructor() {
    this.rows = null;
  }
  nextLine(e, n, r) {
    if (this.rows == null) {
      this.rows = !1;
      let i;
      if ((n.next == 45 || n.next == 58 || n.next == 124) && YL.test((i = n.text.slice(n.pos)))) {
        let s = [];
        vu(e, r.content, 0, s, r.start) == vu(e, i, n.pos) &&
          (this.rows = [
            e.elt("TableHeader", r.start, r.start + r.content.length, s),
            e.elt("TableDelimiter", e.lineStart + n.pos, e.lineStart + n.text.length),
          ]);
      }
    } else if (this.rows) {
      let i = [];
      vu(e, n.text, n.pos, i, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + n.pos, e.lineStart + n.text.length, i));
    }
    return !1;
  }
  finish(e, n) {
    return this.rows ? (e.addLeafElement(n, e.elt("Table", n.start, n.start + n.content.length, this.rows)), !0) : !1;
  }
}
const dOe = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": R.heading } },
    "TableRow",
    { name: "TableCell", style: R.content },
    { name: "TableDelimiter", style: R.processingInstruction },
  ],
  parseBlock: [
    {
      name: "Table",
      leaf(t, e) {
        return JT(e.content, 0) ? new KT() : null;
      },
      endLeaf(t, e, n) {
        if (n.parsers.some((i) => i instanceof KT) || !JT(e.text, e.basePos)) return !1;
        let r = t.scanLine(t.absoluteLineEnd + 1).text;
        return YL.test(r) && vu(t, e.text, e.basePos) == vu(t, r, e.basePos);
      },
      before: "SetextHeading",
    },
  ],
};
class pOe {
  nextLine() {
    return !1;
  }
  finish(e, n) {
    return (
      e.addLeafElement(
        n,
        e.elt("Task", n.start, n.start + n.content.length, [
          e.elt("TaskMarker", n.start, n.start + 3),
          ...e.parser.parseInline(n.content.slice(3), n.start + 3),
        ])
      ),
      !0
    );
  }
}
const mOe = {
    defineNodes: [
      { name: "Task", block: !0, style: R.list },
      { name: "TaskMarker", style: R.atom },
    ],
    parseBlock: [
      {
        name: "TaskList",
        leaf(t, e) {
          return /^\[[ xX]\][ \t]/.test(e.content) && t.parentType().name == "ListItem" ? new pOe() : null;
        },
        after: "SetextHeading",
      },
    ],
  },
  eP = /(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy,
  tP = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy,
  gOe = /[\w-]+\.[\w-]+($|\/)/,
  nP = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy,
  rP = /\/[a-zA-Z\d@.]+/gy;
function iP(t, e, n, r) {
  let i = 0;
  for (let s = e; s < n; s++) t[s] == r && i++;
  return i;
}
function OOe(t, e) {
  tP.lastIndex = e;
  let n = tP.exec(t);
  if (!n || gOe.exec(n[0])[0].indexOf("_") > -1) return -1;
  let r = e + n[0].length;
  for (;;) {
    let i = t[r - 1],
      s;
    if (/[?!.,:*_~]/.test(i) || (i == ")" && iP(t, e, r, ")") > iP(t, e, r, "("))) r--;
    else if (i == ";" && (s = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(t.slice(e, r)))) r = e + s.index;
    else break;
  }
  return r;
}
function sP(t, e) {
  nP.lastIndex = e;
  let n = nP.exec(t);
  if (!n) return -1;
  let r = n[0][n[0].length - 1];
  return r == "_" || r == "-" ? -1 : e + n[0].length - (r == "." ? 1 : 0);
}
const vOe = {
    parseInline: [
      {
        name: "Autolink",
        parse(t, e, n) {
          let r = n - t.offset;
          eP.lastIndex = r;
          let i = eP.exec(t.text),
            s = -1;
          if (!i) return -1;
          if (i[1] || i[2]) {
            if (((s = OOe(t.text, r + i[0].length)), s > -1 && t.hasOpenLink)) {
              let o = /([^\[\]]|\[[^\]]*\])*/.exec(t.text.slice(r, s));
              s = r + o[0].length;
            }
          } else
            i[3]
              ? (s = sP(t.text, r))
              : ((s = sP(t.text, r + i[0].length)),
                s > -1 && i[0] == "xmpp:" && ((rP.lastIndex = s), (i = rP.exec(t.text)), i && (s = i.index + i[0].length)));
          return s < 0 ? -1 : (t.addElement(t.elt("URL", n, s + t.offset)), s + t.offset);
        },
      },
    ],
  },
  xOe = [dOe, mOe, fOe, vOe];
function GL(t, e, n) {
  return (r, i, s) => {
    if (i != t || r.char(s + 1) == t) return -1;
    let o = [r.elt(n, s, s + 1)];
    for (let a = s + 1; a < r.end; a++) {
      let l = r.char(a);
      if (l == t) return r.addElement(r.elt(e, s, a + 1, o.concat(r.elt(n, a, a + 1))));
      if ((l == 92 && o.push(r.elt("Escape", a, a++ + 2)), Fr(l))) break;
    }
    return -1;
  };
}
const bOe = {
    defineNodes: [
      { name: "Superscript", style: R.special(R.content) },
      { name: "SuperscriptMark", style: R.processingInstruction },
    ],
    parseInline: [{ name: "Superscript", parse: GL(94, "Superscript", "SuperscriptMark") }],
  },
  yOe = {
    defineNodes: [
      { name: "Subscript", style: R.special(R.content) },
      { name: "SubscriptMark", style: R.processingInstruction },
    ],
    parseInline: [{ name: "Subscript", parse: GL(126, "Subscript", "SubscriptMark") }],
  },
  wOe = {
    defineNodes: [{ name: "Emoji", style: R.character }],
    parseInline: [
      {
        name: "Emoji",
        parse(t, e, n) {
          let r;
          return e != 58 || !(r = /^[a-zA-Z_0-9]+:/.exec(t.slice(n + 1, t.end)))
            ? -1
            : t.addElement(t.elt("Emoji", n, n + 1 + r[0].length));
        },
      },
    ],
  },
  JL = _g({ commentTokens: { block: { open: "<!--", close: "-->" } } }),
  KL = new Ie(),
  eM = lOe.configure({
    props: [
      oc.add((t) =>
        !t.is("Block") || t.is("Document") || jx(t) != null || SOe(t) ? void 0 : (e, n) => ({ from: n.doc.lineAt(e.from).to, to: e.to })
      ),
      KL.add(jx),
      of.add({ Document: () => null }),
      js.add({ Document: JL }),
    ],
  });
function jx(t) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(t.name);
  return e ? +e[1] : void 0;
}
function SOe(t) {
  return t.name == "OrderedList" || t.name == "BulletList";
}
function kOe(t, e) {
  let n = t;
  for (;;) {
    let r = n.nextSibling,
      i;
    if (!r || ((i = jx(r.type)) != null && i <= e)) break;
    n = r;
  }
  return n.to;
}
const COe = o8.of((t, e, n) => {
  for (let r = pt(t).resolveInner(n, -1); r && !(r.from < e); r = r.parent) {
    let i = r.type.prop(KL);
    if (i == null) continue;
    let s = kOe(r, i);
    if (s > n) return { from: n, to: s };
  }
  return null;
});
function fk(t) {
  return new mr(JL, t, [COe], "markdown");
}
const tM = fk(eM),
  _Oe = eM.configure([xOe, yOe, bOe, wOe, { props: [oc.add({ Table: (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to }) })] }]),
  dk = fk(_Oe);
function EOe(t, e) {
  return (n) => {
    if (n && t) {
      let r = null;
      if (((n = /\S*/.exec(n)[0]), typeof t == "function" ? (r = t(n)) : (r = j.matchLanguageName(t, n, !0)), r instanceof j))
        return r.support ? r.support.language.parser : na.getSkippingParser(r.load());
      if (r) return r.parser;
    }
    return e ? e.parser : null;
  };
}
class vd {
  constructor(e, n, r, i, s, o, a) {
    (this.node = e), (this.from = n), (this.to = r), (this.spaceBefore = i), (this.spaceAfter = s), (this.type = o), (this.item = a);
  }
  blank(e, n = !0) {
    let r = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; r.length < e; ) r += " ";
      return r;
    } else {
      for (let i = this.to - this.from - r.length - this.spaceAfter.length; i > 0; i--) r += " ";
      return r + (n ? this.spaceAfter : "");
    }
  }
  marker(e, n) {
    let r = this.node.name == "OrderedList" ? String(+rM(this.item, e)[2] + n) : "";
    return this.spaceBefore + r + this.type + this.spaceAfter;
  }
}
function nM(t, e) {
  let n = [];
  for (let i = t; i && i.name != "Document"; i = i.parent)
    (i.name == "ListItem" || i.name == "Blockquote" || i.name == "FencedCode") && n.push(i);
  let r = [];
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i],
      o,
      a = e.lineAt(s.from),
      l = s.from - a.from;
    if (s.name == "FencedCode") r.push(new vd(s, l, l, "", "", "", null));
    else if (s.name == "Blockquote" && (o = /^ *>( ?)/.exec(a.text.slice(l)))) r.push(new vd(s, l, l + o[0].length, "", o[1], ">", null));
    else if (s.name == "ListItem" && s.parent.name == "OrderedList" && (o = /^( *)\d+([.)])( *)/.exec(a.text.slice(l)))) {
      let c = o[3],
        u = o[0].length;
      c.length >= 4 && ((c = c.slice(0, c.length - 4)), (u -= 4)), r.push(new vd(s.parent, l, l + u, o[1], c, o[2], s));
    } else if (s.name == "ListItem" && s.parent.name == "BulletList" && (o = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(a.text.slice(l)))) {
      let c = o[4],
        u = o[0].length;
      c.length > 4 && ((c = c.slice(0, c.length - 4)), (u -= 4));
      let h = o[2];
      o[3] && (h += o[3].replace(/[xX]/, " ")), r.push(new vd(s.parent, l, l + u, o[1], c, h, s));
    }
  }
  return r;
}
function rM(t, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(t.from, t.from + 10));
}
function H1(t, e, n, r = 0) {
  for (let i = -1, s = t; ; ) {
    if (s.name == "ListItem") {
      let a = rM(s, e),
        l = +a[2];
      if (i >= 0) {
        if (l != i + 1) return;
        n.push({ from: s.from + a[1].length, to: s.from + a[0].length, insert: String(i + 2 + r) });
      }
      i = l;
    }
    let o = s.nextSibling;
    if (!o) break;
    s = o;
  }
}
function pk(t, e) {
  let n = /^[ \t]*/.exec(t)[0].length;
  if (!n || e.facet(sf) != "	") return t;
  let r = Kr(t, 4, n),
    i = "";
  for (let s = r; s > 0; ) s >= 4 ? ((i += "	"), (s -= 4)) : ((i += " "), s--);
  return i + t.slice(n);
}
const iM = ({ state: t, dispatch: e }) => {
  let n = pt(t),
    { doc: r } = t,
    i = null,
    s = t.changeByRange((o) => {
      if (!o.empty || !dk.isActiveAt(t, o.from)) return (i = { range: o });
      let a = o.from,
        l = r.lineAt(a),
        c = nM(n.resolveInner(a, -1), r);
      for (; c.length && c[c.length - 1].from > a - l.from; ) c.pop();
      if (!c.length) return (i = { range: o });
      let u = c[c.length - 1];
      if (u.to - u.spaceAfter.length > a - l.from) return (i = { range: o });
      let h = a >= u.to - u.spaceAfter.length && !/\S/.test(l.text.slice(u.to));
      if (u.item && h) {
        let O = u.node.firstChild,
          v = u.node.getChild("ListItem", "ListItem");
        if (O.to >= a || (v && v.to < a) || (l.from > 0 && !/[^\s>]/.test(r.lineAt(l.from - 1).text))) {
          let g = c.length > 1 ? c[c.length - 2] : null,
            x,
            y = "";
          g && g.item ? ((x = l.from + g.from), (y = g.marker(r, 1))) : (x = l.from + (g ? g.to : 0));
          let S = [{ from: x, to: a, insert: y }];
          return (
            u.node.name == "OrderedList" && H1(u.item, r, S, -2),
            g && g.node.name == "OrderedList" && H1(g.item, r, S),
            { range: X.cursor(x + y.length), changes: S }
          );
        } else {
          let g = aP(c, t, l);
          return { range: X.cursor(a + g.length + 1), changes: { from: l.from, insert: g + t.lineBreak } };
        }
      }
      if (u.node.name == "Blockquote" && h && l.from) {
        let O = r.lineAt(l.from - 1),
          v = />\s*$/.exec(O.text);
        if (v && v.index == u.from) {
          let g = t.changes([
            { from: O.from + v.index, to: O.to },
            { from: l.from + u.from, to: l.to },
          ]);
          return { range: o.map(g), changes: g };
        }
      }
      let f = [];
      u.node.name == "OrderedList" && H1(u.item, r, f);
      let d = u.item && u.item.from < l.from,
        p = "";
      if (!d || /^[\s\d.)\-+*>]*/.exec(l.text)[0].length >= u.to)
        for (let O = 0, v = c.length - 1; O <= v; O++)
          p += O == v && !d ? c[O].marker(r, 1) : c[O].blank(O < v ? Kr(l.text, 4, c[O + 1].from) - p.length : null);
      let m = a;
      for (; m > l.from && /\s/.test(l.text.charAt(m - l.from - 1)); ) m--;
      return (
        (p = pk(p, t)),
        TOe(u.node, t.doc) && (p = aP(c, t, l) + t.lineBreak + p),
        f.push({ from: m, to: a, insert: t.lineBreak + p }),
        { range: X.cursor(m + p.length + 1), changes: f }
      );
    });
  return i ? !1 : (e(t.update(s, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function oP(t) {
  return t.name == "QuoteMark" || t.name == "ListMark";
}
function TOe(t, e) {
  if (t.name != "OrderedList" && t.name != "BulletList") return !1;
  let n = t.firstChild,
    r = t.getChild("ListItem", "ListItem");
  if (!r) return !1;
  let i = e.lineAt(n.to),
    s = e.lineAt(r.from),
    o = /^[\s>]*$/.test(i.text);
  return i.number + (o ? 0 : 1) < s.number;
}
function aP(t, e, n) {
  let r = "";
  for (let i = 0, s = t.length - 2; i <= s; i++) r += t[i].blank(i < s ? Kr(n.text, 4, t[i + 1].from) - r.length : null, i < s);
  return pk(r, e);
}
function POe(t, e) {
  let n = t.resolveInner(e, -1),
    r = e;
  oP(n) && ((r = n.from), (n = n.parent));
  for (let i; (i = n.childBefore(r)); )
    if (oP(i)) r = i.from;
    else if (i.name == "OrderedList" || i.name == "BulletList") (n = i.lastChild), (r = n.to);
    else break;
  return n;
}
const sM = ({ state: t, dispatch: e }) => {
    let n = pt(t),
      r = null,
      i = t.changeByRange((s) => {
        let o = s.from,
          { doc: a } = t;
        if (s.empty && dk.isActiveAt(t, s.from)) {
          let l = a.lineAt(o),
            c = nM(POe(n, o), a);
          if (c.length) {
            let u = c[c.length - 1],
              h = u.to - u.spaceAfter.length + (u.spaceAfter ? 1 : 0);
            if (o - l.from > h && !/\S/.test(l.text.slice(h, o - l.from)))
              return { range: X.cursor(l.from + h), changes: { from: l.from + h, to: o } };
            if (o - l.from == h && (!u.item || l.from <= u.item.from || !/\S/.test(l.text.slice(0, u.to)))) {
              let f = l.from + u.from;
              if (u.item && u.node.from < u.item.from && /\S/.test(l.text.slice(u.from, u.to))) {
                let d = u.blank(Kr(l.text, 4, u.to) - Kr(l.text, 4, u.from));
                return f == l.from && (d = pk(d, t)), { range: X.cursor(f + d.length), changes: { from: f, to: l.from + u.to, insert: d } };
              }
              if (f < o) return { range: X.cursor(f), changes: { from: f, to: o } };
            }
          }
        }
        return (r = { range: s });
      });
    return r ? !1 : (e(t.update(i, { scrollIntoView: !0, userEvent: "delete" })), !0);
  },
  oM = [
    { key: "Enter", run: iM },
    { key: "Backspace", run: sM },
  ],
  Zx = dS({ matchClosingTags: !1 });
function aM(t = {}) {
  let { codeLanguages: e, defaultCodeLanguage: n, addKeymap: r = !0, base: { parser: i } = tM, completeHTMLTags: s = !0 } = t;
  if (!(i instanceof qg)) throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let o = t.extensions ? [t.extensions] : [],
    a = [Zx.support],
    l;
  n instanceof Tl ? (a.push(n.support), (l = n.language)) : n && (l = n);
  let c = e || l ? EOe(e, l) : void 0;
  o.push(uOe({ codeParser: c, htmlParser: Zx.language.parser })), r && a.push(ai.high(ta.of(oM)));
  let u = fk(i.configure(o));
  return s && a.push(u.data.of({ autocomplete: AOe })), new Tl(u, a);
}
function AOe(t) {
  let { state: e, pos: n } = t,
    r = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(n - 25, n));
  if (!r) return null;
  let i = pt(e).resolveInner(n, -1);
  for (; i && !i.type.isTop; ) {
    if (
      i.name == "CodeBlock" ||
      i.name == "FencedCode" ||
      i.name == "ProcessingInstructionBlock" ||
      i.name == "CommentBlock" ||
      i.name == "Link" ||
      i.name == "Image"
    )
      return null;
    i = i.parent;
  }
  return { from: n - r[0].length, to: n, options: $Oe(), validFor: /^<[:\-\.\w\u00b7-\uffff]*$/ };
}
let q1 = null;
function $Oe() {
  if (q1) return q1;
  let t = eI(new Uw(Qe.create({ extensions: Zx }), 0, !0));
  return (q1 = t ? t.options : []);
}
const ROe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        commonmarkLanguage: tM,
        deleteMarkupBackward: sM,
        insertNewlineContinueMarkup: iM,
        markdown: aM,
        markdownKeymap: oM,
        markdownLanguage: dk,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  zx = [VI, kI, aM(), kg(), re.lineWrapping],
  IOe = () => {
    const [t, e, n] = nt(Gr, sn, Yg),
      r = tt(Wo),
      i = tt(vl),
      s = C.useRef(null),
      o = C.useCallback(
        (a) => {
          var l;
          if (a !== null) {
            const c = [
              ...n,
              ...zx,
              re.updateListener.of(({ state: u }) => {
                r(u.doc.toString());
              }),
              re.focusChangeEffect.of((u, h) => (h || i(new FocusEvent("blur")), null)),
            ];
            e && c.push(Qe.readOnly.of(!0)),
              (a.innerHTML = ""),
              (s.current = new re({ parent: a, state: Qe.create({ doc: t, extensions: c }) }));
          } else (l = s.current) == null || l.destroy(), (s.current = null);
        },
        [t, e, r, n, i]
      );
    return C.createElement("div", { ref: o, className: "cm-sourceView mdxeditor-source-editor" });
  };
function lP(t, e) {
  t !== void 0 && t.dispatch({ changes: { from: 0, to: t.state.doc.length, insert: e } });
}
const NOe = () => {
    const t = Fl(),
      [e, n, r, i] = nt(Gr, dh, sn, mk),
      s = tt(Wo),
      o = C.useRef(null),
      a = C.useRef(null),
      l = yt(Yg),
      c = tt(vl);
    return (
      C.useEffect(
        () =>
          t.sub(dh, (u) => {
            var h;
            lP((h = a.current) == null ? void 0 : h.a, u);
          }),
        [t]
      ),
      C.useEffect(
        () =>
          t.sub(Gr, (u) => {
            var h;
            lP((h = a.current) == null ? void 0 : h.b, u);
          }),
        [t]
      ),
      C.useEffect(() => {
        const u = r || i,
          h = u
            ? { renderRevertControl: void 0, revertControls: void 0 }
            : {
                renderRevertControl: () => {
                  const f = document.createElement("button");
                  return f.classList.add("cm-merge-revert"), f.appendChild(document.createTextNode("⮕")), f;
                },
                revertControls: "a-to-b",
              };
        return (
          (a.current = new H1e({
            ...h,
            parent: o.current,
            orientation: "a-b",
            gutter: !0,
            a: { doc: n, extensions: [...l, ...zx, Qe.readOnly.of(!0)] },
            b: {
              doc: e,
              extensions: [
                ...l,
                ...zx,
                Qe.readOnly.of(u),
                re.updateListener.of(({ state: f }) => {
                  const d = f.doc.toString();
                  s(d);
                }),
                re.focusChangeEffect.of((f, d) => (d || c(new FocusEvent("blur")), null)),
              ],
            },
          })),
          () => {
            var f;
            (f = a.current) == null || f.destroy(), (a.current = null);
          }
        );
      }, [s, l]),
      C.createElement("div", { ref: o, className: "mdxeditor-diff-editor" })
    );
  },
  LOe = ({ children: t }) => {
    const [e, n] = nt(Ol, to);
    return C.createElement(
      "div",
      { className: "mdxeditor-diff-source-wrapper" },
      e
        ? C.createElement(
            "div",
            { className: F.markdownParseError },
            C.createElement("p", null, e.error, "."),
            C.createElement("p", null, "You can fix the errors in source mode and switch to rich text mode when you are ready.")
          )
        : null,
      C.createElement(
        "div",
        { className: "mdxeditor-rich-text-editor", style: { display: n === "rich-text" && e == null ? "block" : "none" } },
        t
      ),
      n === "diff" ? C.createElement(NOe, null) : null,
      n === "source" ? C.createElement(IOe, null) : null
    );
  },
  dh = Se(""),
  Yg = Se([]),
  mk = Se(!1),
  MOe = en({
    update: (t, e) => {
      t.pub(dh, (e == null ? void 0 : e.diffMarkdown) ?? "");
    },
    init(t, e) {
      t.pubIn({
        [dh]: (e == null ? void 0 : e.diffMarkdown) ?? "",
        [Yg]: (e == null ? void 0 : e.codeMirrorExtensions) ?? [],
        [FA]: LOe,
        [mk]: (e == null ? void 0 : e.readOnlyDiff) ?? !1,
        [to]: (e == null ? void 0 : e.viewMode) ?? "rich-text",
      });
    },
  });
var DOe = { exports: {} };
(function (t) {
  var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */ var n = (function (r) {
    var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,
      s = 0,
      o = {},
      a = {
        manual: r.Prism && r.Prism.manual,
        disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,
        util: {
          encode: function g(x) {
            return x instanceof l
              ? new l(x.type, g(x.content), x.alias)
              : Array.isArray(x)
              ? x.map(g)
              : x
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/\u00a0/g, " ");
          },
          type: function (g) {
            return Object.prototype.toString.call(g).slice(8, -1);
          },
          objId: function (g) {
            return g.__id || Object.defineProperty(g, "__id", { value: ++s }), g.__id;
          },
          clone: function g(x, y) {
            y = y || {};
            var S, k;
            switch (a.util.type(x)) {
              case "Object":
                if (((k = a.util.objId(x)), y[k])) return y[k];
                (S = {}), (y[k] = S);
                for (var b in x) x.hasOwnProperty(b) && (S[b] = g(x[b], y));
                return S;
              case "Array":
                return (
                  (k = a.util.objId(x)),
                  y[k]
                    ? y[k]
                    : ((S = []),
                      (y[k] = S),
                      x.forEach(function (_, T) {
                        S[T] = g(_, y);
                      }),
                      S)
                );
              default:
                return x;
            }
          },
          getLanguage: function (g) {
            for (; g; ) {
              var x = i.exec(g.className);
              if (x) return x[1].toLowerCase();
              g = g.parentElement;
            }
            return "none";
          },
          setLanguage: function (g, x) {
            (g.className = g.className.replace(RegExp(i, "gi"), "")), g.classList.add("language-" + x);
          },
          currentScript: function () {
            if (typeof document > "u") return null;
            if ("currentScript" in document && 1 < 2) return document.currentScript;
            try {
              throw new Error();
            } catch (S) {
              var g = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(S.stack) || [])[1];
              if (g) {
                var x = document.getElementsByTagName("script");
                for (var y in x) if (x[y].src == g) return x[y];
              }
              return null;
            }
          },
          isActive: function (g, x, y) {
            for (var S = "no-" + x; g; ) {
              var k = g.classList;
              if (k.contains(x)) return !0;
              if (k.contains(S)) return !1;
              g = g.parentElement;
            }
            return !!y;
          },
        },
        languages: {
          plain: o,
          plaintext: o,
          text: o,
          txt: o,
          extend: function (g, x) {
            var y = a.util.clone(a.languages[g]);
            for (var S in x) y[S] = x[S];
            return y;
          },
          insertBefore: function (g, x, y, S) {
            S = S || a.languages;
            var k = S[g],
              b = {};
            for (var _ in k)
              if (k.hasOwnProperty(_)) {
                if (_ == x) for (var T in y) y.hasOwnProperty(T) && (b[T] = y[T]);
                y.hasOwnProperty(_) || (b[_] = k[_]);
              }
            var P = S[g];
            return (
              (S[g] = b),
              a.languages.DFS(a.languages, function (M, D) {
                D === P && M != g && (this[M] = b);
              }),
              b
            );
          },
          DFS: function g(x, y, S, k) {
            k = k || {};
            var b = a.util.objId;
            for (var _ in x)
              if (x.hasOwnProperty(_)) {
                y.call(x, _, x[_], S || _);
                var T = x[_],
                  P = a.util.type(T);
                P === "Object" && !k[b(T)]
                  ? ((k[b(T)] = !0), g(T, y, null, k))
                  : P === "Array" && !k[b(T)] && ((k[b(T)] = !0), g(T, y, _, k));
              }
          },
        },
        plugins: {},
        highlightAll: function (g, x) {
          a.highlightAllUnder(document, g, x);
        },
        highlightAllUnder: function (g, x, y) {
          var S = {
            callback: y,
            container: g,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
          };
          a.hooks.run("before-highlightall", S),
            (S.elements = Array.prototype.slice.apply(S.container.querySelectorAll(S.selector))),
            a.hooks.run("before-all-elements-highlight", S);
          for (var k = 0, b; (b = S.elements[k++]); ) a.highlightElement(b, x === !0, S.callback);
        },
        highlightElement: function (g, x, y) {
          var S = a.util.getLanguage(g),
            k = a.languages[S];
          a.util.setLanguage(g, S);
          var b = g.parentElement;
          b && b.nodeName.toLowerCase() === "pre" && a.util.setLanguage(b, S);
          var _ = g.textContent,
            T = { element: g, language: S, grammar: k, code: _ };
          function P(D) {
            (T.highlightedCode = D),
              a.hooks.run("before-insert", T),
              (T.element.innerHTML = T.highlightedCode),
              a.hooks.run("after-highlight", T),
              a.hooks.run("complete", T),
              y && y.call(T.element);
          }
          if (
            (a.hooks.run("before-sanity-check", T),
            (b = T.element.parentElement),
            b && b.nodeName.toLowerCase() === "pre" && !b.hasAttribute("tabindex") && b.setAttribute("tabindex", "0"),
            !T.code)
          ) {
            a.hooks.run("complete", T), y && y.call(T.element);
            return;
          }
          if ((a.hooks.run("before-highlight", T), !T.grammar)) {
            P(a.util.encode(T.code));
            return;
          }
          if (x && r.Worker) {
            var M = new Worker(a.filename);
            (M.onmessage = function (D) {
              P(D.data);
            }),
              M.postMessage(JSON.stringify({ language: T.language, code: T.code, immediateClose: !0 }));
          } else P(a.highlight(T.code, T.grammar, T.language));
        },
        highlight: function (g, x, y) {
          var S = { code: g, grammar: x, language: y };
          if ((a.hooks.run("before-tokenize", S), !S.grammar)) throw new Error('The language "' + S.language + '" has no grammar.');
          return (
            (S.tokens = a.tokenize(S.code, S.grammar)), a.hooks.run("after-tokenize", S), l.stringify(a.util.encode(S.tokens), S.language)
          );
        },
        tokenize: function (g, x) {
          var y = x.rest;
          if (y) {
            for (var S in y) x[S] = y[S];
            delete x.rest;
          }
          var k = new h();
          return f(k, k.head, g), u(g, k, x, k.head, 0), p(k);
        },
        hooks: {
          all: {},
          add: function (g, x) {
            var y = a.hooks.all;
            (y[g] = y[g] || []), y[g].push(x);
          },
          run: function (g, x) {
            var y = a.hooks.all[g];
            if (!(!y || !y.length)) for (var S = 0, k; (k = y[S++]); ) k(x);
          },
        },
        Token: l,
      };
    r.Prism = a;
    function l(g, x, y, S) {
      (this.type = g), (this.content = x), (this.alias = y), (this.length = (S || "").length | 0);
    }
    l.stringify = function g(x, y) {
      if (typeof x == "string") return x;
      if (Array.isArray(x)) {
        var S = "";
        return (
          x.forEach(function (P) {
            S += g(P, y);
          }),
          S
        );
      }
      var k = { type: x.type, content: g(x.content, y), tag: "span", classes: ["token", x.type], attributes: {}, language: y },
        b = x.alias;
      b && (Array.isArray(b) ? Array.prototype.push.apply(k.classes, b) : k.classes.push(b)), a.hooks.run("wrap", k);
      var _ = "";
      for (var T in k.attributes) _ += " " + T + '="' + (k.attributes[T] || "").replace(/"/g, "&quot;") + '"';
      return "<" + k.tag + ' class="' + k.classes.join(" ") + '"' + _ + ">" + k.content + "</" + k.tag + ">";
    };
    function c(g, x, y, S) {
      g.lastIndex = x;
      var k = g.exec(y);
      if (k && S && k[1]) {
        var b = k[1].length;
        (k.index += b), (k[0] = k[0].slice(b));
      }
      return k;
    }
    function u(g, x, y, S, k, b) {
      for (var _ in y)
        if (!(!y.hasOwnProperty(_) || !y[_])) {
          var T = y[_];
          T = Array.isArray(T) ? T : [T];
          for (var P = 0; P < T.length; ++P) {
            if (b && b.cause == _ + "," + P) return;
            var M = T[P],
              D = M.inside,
              V = !!M.lookbehind,
              Q = !!M.greedy,
              N = M.alias;
            if (Q && !M.pattern.global) {
              var G = M.pattern.toString().match(/[imsuy]*$/)[0];
              M.pattern = RegExp(M.pattern.source, G + "g");
            }
            for (var H = M.pattern || M, te = S.next, le = k; te !== x.tail && !(b && le >= b.reach); le += te.value.length, te = te.next) {
              var $ = te.value;
              if (x.length > g.length) return;
              if (!($ instanceof l)) {
                var B = 1,
                  ie;
                if (Q) {
                  if (((ie = c(H, le, g, V)), !ie || ie.index >= g.length)) break;
                  var me = ie.index,
                    L = ie.index + ie[0].length,
                    pe = le;
                  for (pe += te.value.length; me >= pe; ) (te = te.next), (pe += te.value.length);
                  if (((pe -= te.value.length), (le = pe), te.value instanceof l)) continue;
                  for (var Ce = te; Ce !== x.tail && (pe < L || typeof Ce.value == "string"); Ce = Ce.next) B++, (pe += Ce.value.length);
                  B--, ($ = g.slice(le, pe)), (ie.index -= le);
                } else if (((ie = c(H, 0, $, V)), !ie)) continue;
                var me = ie.index,
                  Y = ie[0],
                  q = $.slice(0, me),
                  se = $.slice(me + Y.length),
                  ue = le + $.length;
                b && ue > b.reach && (b.reach = ue);
                var ve = te.prev;
                q && ((ve = f(x, ve, q)), (le += q.length)), d(x, ve, B);
                var Pe = new l(_, D ? a.tokenize(Y, D) : Y, N, Y);
                if (((te = f(x, ve, Pe)), se && f(x, te, se), B > 1)) {
                  var Fe = { cause: _ + "," + P, reach: ue };
                  u(g, x, y, te.prev, le, Fe), b && Fe.reach > b.reach && (b.reach = Fe.reach);
                }
              }
            }
          }
        }
    }
    function h() {
      var g = { value: null, prev: null, next: null },
        x = { value: null, prev: g, next: null };
      (g.next = x), (this.head = g), (this.tail = x), (this.length = 0);
    }
    function f(g, x, y) {
      var S = x.next,
        k = { value: y, prev: x, next: S };
      return (x.next = k), (S.prev = k), g.length++, k;
    }
    function d(g, x, y) {
      for (var S = x.next, k = 0; k < y && S !== g.tail; k++) S = S.next;
      (x.next = S), (S.prev = x), (g.length -= k);
    }
    function p(g) {
      for (var x = [], y = g.head.next; y !== g.tail; ) x.push(y.value), (y = y.next);
      return x;
    }
    if (!r.document)
      return (
        r.addEventListener &&
          (a.disableWorkerMessageHandler ||
            r.addEventListener(
              "message",
              function (g) {
                var x = JSON.parse(g.data),
                  y = x.language,
                  S = x.code,
                  k = x.immediateClose;
                r.postMessage(a.highlight(S, a.languages[y], y)), k && r.close();
              },
              !1
            )),
        a
      );
    var m = a.util.currentScript();
    m && ((a.filename = m.src), m.hasAttribute("data-manual") && (a.manual = !0));
    function O() {
      a.manual || a.highlightAll();
    }
    if (!a.manual) {
      var v = document.readyState;
      v === "loading" || (v === "interactive" && m && m.defer)
        ? document.addEventListener("DOMContentLoaded", O)
        : window.requestAnimationFrame
        ? window.requestAnimationFrame(O)
        : window.setTimeout(O, 16);
    }
    return a;
  })(e);
  t.exports && (t.exports = n),
    typeof xk < "u" && (xk.Prism = n),
    (n.languages.markup = {
      comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
      prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
      doctype: {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null },
          string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/,
        },
      },
      cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                { pattern: /^=/, alias: "attr-equals" },
                { pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
              ],
            },
          },
          punctuation: /\/?>/,
          "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
        },
      },
      entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i],
    }),
    (n.languages.markup.tag.inside["attr-value"].inside.entity = n.languages.markup.entity),
    (n.languages.markup.doctype.inside["internal-subset"].inside = n.languages.markup),
    n.hooks.add("wrap", function (r) {
      r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
    }),
    Object.defineProperty(n.languages.markup.tag, "addInlined", {
      value: function (i, s) {
        var o = {};
        (o["language-" + s] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: n.languages[s] }),
          (o.cdata = /^<!\[CDATA\[|\]\]>$/i);
        var a = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: o } };
        a["language-" + s] = { pattern: /[\s\S]+/, inside: n.languages[s] };
        var l = {};
        (l[i] = {
          pattern: RegExp(
            /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
              return i;
            }),
            "i"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: a,
        }),
          n.languages.insertBefore("markup", "cdata", l);
      },
    }),
    Object.defineProperty(n.languages.markup.tag, "addAttribute", {
      value: function (r, i) {
        n.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(/(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [i, "language-" + i],
                  inside: n.languages[i],
                },
                punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/],
              },
            },
          },
        });
      },
    }),
    (n.languages.html = n.languages.markup),
    (n.languages.mathml = n.languages.markup),
    (n.languages.svg = n.languages.markup),
    (n.languages.xml = n.languages.extend("markup", {})),
    (n.languages.ssml = n.languages.xml),
    (n.languages.atom = n.languages.xml),
    (n.languages.rss = n.languages.xml),
    (function (r) {
      var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      (r.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector",
            },
            keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 },
          },
        },
        url: {
          pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + i.source + "$"), alias: "url" } },
        },
        selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"), lookbehind: !0 },
        string: { pattern: i, greedy: !0 },
        property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 },
        important: /!important\b/i,
        function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 },
        punctuation: /[(){};:,]/,
      }),
        (r.languages.css.atrule.inside.rest = r.languages.css);
      var s = r.languages.markup;
      s && (s.tag.addInlined("style", "css"), s.tag.addAttribute("style", "css"));
    })(n),
    (n.languages.clike = {
      comment: [
        { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 },
        { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
      ],
      string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: { punctuation: /[.\\]/ },
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/,
    }),
    (n.languages.javascript = n.languages.extend("clike", {
      "class-name": [
        n.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0,
        },
      ],
      keyword: [
        { pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
        {
          pattern:
            /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0,
        },
      ],
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source +
            "(?:" +
            (/NaN|Infinity/.source +
              "|" +
              /0[bB][01]+(?:_[01]+)*n?/.source +
              "|" +
              /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
              "|" +
              /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
              "|" +
              /\d+(?:_\d+)*n/.source +
              "|" +
              /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) +
            ")" +
            /(?![\w$])/.source
        ),
        lookbehind: !0,
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
    })),
    (n.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/),
    n.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
            /\//.source +
            "(?:" +
            /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
            "|" +
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
              .source +
            ")" +
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: "language-regex", inside: n.languages.regex },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/,
        },
      },
      "function-variable": {
        pattern:
          /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function",
      },
      parameter: [
        {
          pattern:
            /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
        { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: !0, inside: n.languages.javascript },
        {
          pattern:
            /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
    }),
    n.languages.insertBefore("javascript", "string", {
      hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": { pattern: /^`|`$/, alias: "string" },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: n.languages.javascript },
          },
          string: /[\s\S]+/,
        },
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
      },
    }),
    n.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property",
      },
    }),
    n.languages.markup &&
      (n.languages.markup.tag.addInlined("script", "javascript"),
      n.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
          .source,
        "javascript"
      )),
    (n.languages.js = n.languages.javascript),
    (function () {
      if (typeof n > "u" || typeof document > "u") return;
      Element.prototype.matches ||
        (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var r = "Loading…",
        i = function (m, O) {
          return "✖ Error " + m + " while fetching file: " + O;
        },
        s = "✖ Error: File does not exist or is empty",
        o = {
          js: "javascript",
          py: "python",
          rb: "ruby",
          ps1: "powershell",
          psm1: "powershell",
          sh: "bash",
          bat: "batch",
          h: "c",
          tex: "latex",
        },
        a = "data-src-status",
        l = "loading",
        c = "loaded",
        u = "failed",
        h = "pre[data-src]:not([" + a + '="' + c + '"]):not([' + a + '="' + l + '"])';
      function f(m, O, v) {
        var g = new XMLHttpRequest();
        g.open("GET", m, !0),
          (g.onreadystatechange = function () {
            g.readyState == 4 &&
              (g.status < 400 && g.responseText ? O(g.responseText) : g.status >= 400 ? v(i(g.status, g.statusText)) : v(s));
          }),
          g.send(null);
      }
      function d(m) {
        var O = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(m || "");
        if (O) {
          var v = Number(O[1]),
            g = O[2],
            x = O[3];
          return g ? (x ? [v, Number(x)] : [v, void 0]) : [v, v];
        }
      }
      n.hooks.add("before-highlightall", function (m) {
        m.selector += ", " + h;
      }),
        n.hooks.add("before-sanity-check", function (m) {
          var O = m.element;
          if (O.matches(h)) {
            (m.code = ""), O.setAttribute(a, l);
            var v = O.appendChild(document.createElement("CODE"));
            v.textContent = r;
            var g = O.getAttribute("data-src"),
              x = m.language;
            if (x === "none") {
              var y = (/\.(\w+)$/.exec(g) || [, "none"])[1];
              x = o[y] || y;
            }
            n.util.setLanguage(v, x), n.util.setLanguage(O, x);
            var S = n.plugins.autoloader;
            S && S.loadLanguages(x),
              f(
                g,
                function (k) {
                  O.setAttribute(a, c);
                  var b = d(O.getAttribute("data-range"));
                  if (b) {
                    var _ = k.split(/\r\n?|\n/g),
                      T = b[0],
                      P = b[1] == null ? _.length : b[1];
                    T < 0 && (T += _.length),
                      (T = Math.max(0, Math.min(T - 1, _.length))),
                      P < 0 && (P += _.length),
                      (P = Math.max(0, Math.min(P, _.length))),
                      (k = _.slice(T, P).join(`
`)),
                      O.hasAttribute("data-start") || O.setAttribute("data-start", String(T + 1));
                  }
                  (v.textContent = k), n.highlightElement(v);
                },
                function (k) {
                  O.setAttribute(a, u), (v.textContent = k);
                }
              );
          }
        }),
        (n.plugins.fileHighlight = {
          highlight: function (O) {
            for (var v = (O || document).querySelectorAll(h), g = 0, x; (x = v[g++]); ) n.highlightElement(x);
          },
        });
      var p = !1;
      n.fileHighlight = function () {
        p || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), (p = !0)),
          n.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
})(DOe);
Prism.languages.clike = {
  comment: [
    { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
  ],
  string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: !0,
    inside: { punctuation: /[.\\]/ },
  },
  keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: /[{}[\];(),.:]/,
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: !0 },
  ],
  keyword: [
    { pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
    {
      pattern:
        /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: !0,
    },
  ],
  function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  number: {
    pattern: RegExp(
      /(^|[^\w$])/.source +
        "(?:" +
        (/NaN|Infinity/.source +
          "|" +
          /0[bB][01]+(?:_[01]+)*n?/.source +
          "|" +
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
          "|" +
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
          "|" +
          /\d+(?:_\d+)*n/.source +
          "|" +
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) +
        ")" +
        /(?![\w$])/.source
    ),
    lookbehind: !0,
  },
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: RegExp(
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
        /\//.source +
        "(?:" +
        /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
        "|" +
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
          .source +
        ")" +
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: !0,
    greedy: !0,
    inside: {
      "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: "language-regex", inside: Prism.languages.regex },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/,
    },
  },
  "function-variable": {
    pattern:
      /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function",
  },
  parameter: [
    {
      pattern:
        /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
    { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: !0, inside: Prism.languages.javascript },
    {
      pattern:
        /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
});
Prism.languages.insertBefore("javascript", "string", {
  hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: !0,
    inside: {
      "template-punctuation": { pattern: /^`|`$/, alias: "string" },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: !0,
        inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript },
      },
      string: /[\s\S]+/,
    },
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
  },
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: !0,
    alias: "property",
  },
});
Prism.languages.markup &&
  (Prism.languages.markup.tag.addInlined("script", "javascript"),
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
      .source,
    "javascript"
  ));
Prism.languages.js = Prism.languages.javascript;
Prism.languages.markup = {
  comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
  prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
  doctype: {
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: !0,
    inside: {
      "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null },
      string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
      punctuation: /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      name: /[^\s<>'"]+/,
    },
  },
  cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: !0,
    inside: {
      tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          punctuation: [
            { pattern: /^=/, alias: "attr-equals" },
            { pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
          ],
        },
      },
      punctuation: /\/?>/,
      "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
    },
  },
  entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i],
};
Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity;
Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function (t) {
  t.type === "entity" && (t.attributes.title = t.content.replace(/&amp;/, "&"));
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  value: function (e, n) {
    var r = {};
    (r["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: Prism.languages[n] }),
      (r.cdata = /^<!\[CDATA\[|\]\]>$/i);
    var i = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: r } };
    i["language-" + n] = { pattern: /[\s\S]+/, inside: Prism.languages[n] };
    var s = {};
    (s[e] = {
      pattern: RegExp(
        /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
          return e;
        }),
        "i"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: i,
    }),
      Prism.languages.insertBefore("markup", "cdata", s);
  },
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  value: function (t, e) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + t + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: !0,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            value: {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: !0,
              alias: [e, "language-" + e],
              inside: Prism.languages[e],
            },
            punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/],
          },
        },
      },
    });
  },
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function (t) {
  var e = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n(u) {
    return (
      (u = u.replace(/<inner>/g, function () {
        return e;
      })),
      RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + u + ")")
    );
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source,
    i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () {
      return r;
    }),
    s = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  (t.languages.markdown = t.languages.extend("markup", {})),
    t.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: t.languages.yaml },
        },
      },
      blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" },
      table: {
        pattern: RegExp("^" + i + s + "(?:" + i + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + i + s + ")(?:" + i + ")*$"),
            lookbehind: !0,
            inside: { "table-data": { pattern: RegExp(r), inside: t.languages.markdown }, punctuation: /\|/ },
          },
          "table-line": { pattern: RegExp("^(" + i + ")" + s + "$"), lookbehind: !0, inside: { punctuation: /\||:?-{3,}:?/ } },
          "table-header-row": {
            pattern: RegExp("^" + i + "$"),
            inside: { "table-header": { pattern: RegExp(r), alias: "important", inside: t.languages.markdown }, punctuation: /\|/ },
          },
        },
      },
      code: [
        {
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword",
        },
        {
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: !0 },
            "code-language": { pattern: /^(```).+/, lookbehind: !0 },
            punctuation: /```/,
          },
        },
      ],
      title: [
        { pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } },
        { pattern: /(^\s*)#.+/m, lookbehind: !0, alias: "important", inside: { punctuation: /^#+|#+$/ } },
      ],
      hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: !0, alias: "punctuation" },
      list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: !0, alias: "punctuation" },
      "url-reference": {
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/,
        },
        alias: "url",
      },
      bold: {
        pattern: n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: !0, inside: {} }, punctuation: /\*\*|__/ },
      },
      italic: {
        pattern: n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: !0, inside: {} }, punctuation: /[*_]/ },
      },
      strike: {
        pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: !0, inside: {} }, punctuation: /~~?/ },
      },
      "code-snippet": {
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"],
      },
      url: {
        pattern: n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: !0, inside: {} },
          variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: !0 },
          url: { pattern: /(^\]\()[^\s)]+/, lookbehind: !0 },
          string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: !0 },
        },
      },
    }),
    ["url", "bold", "italic", "strike"].forEach(function (u) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function (h) {
        u !== h && (t.languages.markdown[u].inside.content.inside[h] = t.languages.markdown[h]);
      });
    }),
    t.hooks.add("after-tokenize", function (u) {
      if (u.language !== "markdown" && u.language !== "md") return;
      function h(f) {
        if (!(!f || typeof f == "string"))
          for (var d = 0, p = f.length; d < p; d++) {
            var m = f[d];
            if (m.type !== "code") {
              h(m.content);
              continue;
            }
            var O = m.content[1],
              v = m.content[3];
            if (O && v && O.type === "code-language" && v.type === "code-block" && typeof O.content == "string") {
              var g = O.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              g = (/[a-z][\w-]*/i.exec(g) || [""])[0].toLowerCase();
              var x = "language-" + g;
              v.alias ? (typeof v.alias == "string" ? (v.alias = [v.alias, x]) : v.alias.push(x)) : (v.alias = [x]);
            }
          }
      }
      h(u.tokens);
    }),
    t.hooks.add("wrap", function (u) {
      if (u.type === "code-block") {
        for (var h = "", f = 0, d = u.classes.length; f < d; f++) {
          var p = u.classes[f],
            m = /language-(.+)/.exec(p);
          if (m) {
            h = m[1];
            break;
          }
        }
        var O = t.languages[h];
        if (O) u.content = t.highlight(c(u.content), O, h);
        else if (h && h !== "none" && t.plugins.autoloader) {
          var v = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
          (u.attributes.id = v),
            t.plugins.autoloader.loadLanguages(h, function () {
              var g = document.getElementById(v);
              g && (g.innerHTML = t.highlight(g.textContent, t.languages[h], h));
            });
        }
      }
    });
  var o = RegExp(t.languages.markup.tag.pattern.source, "gi"),
    a = { amp: "&", lt: "<", gt: ">", quot: '"' },
    l = String.fromCodePoint || String.fromCharCode;
  function c(u) {
    var h = u.replace(o, "");
    return (
      (h = h.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (f, d) {
        if (((d = d.toLowerCase()), d[0] === "#")) {
          var p;
          return d[1] === "x" ? (p = parseInt(d.slice(2), 16)) : (p = Number(d.slice(1))), l(p);
        } else {
          var m = a[d];
          return m || f;
        }
      })),
      h
    );
  }
  t.languages.md = t.languages.markdown;
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 },
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
  "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: !0 },
  keyword:
    /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/,
});
Prism.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: !0 } });
Prism.languages.insertBefore("c", "string", {
  macro: {
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
    inside: {
      string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: !0 }, Prism.languages.c.string],
      char: Prism.languages.c.char,
      comment: Prism.languages.c.comment,
      "macro-name": [
        { pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: !0 },
        { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: !0, alias: "function" },
      ],
      directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: !0, alias: "keyword" },
      "directive-hash": /^#/,
      punctuation: /##|\\(?=[\r\n])/,
      expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c },
    },
  },
});
Prism.languages.insertBefore("c", "function", {
  constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/,
});
delete Prism.languages.c.boolean;
(function (t) {
  var e = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  (t.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + e.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        rule: /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: !0,
          alias: "selector",
        },
        keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 },
      },
    },
    url: {
      pattern: RegExp("\\burl\\((?:" + e.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: !0,
      inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + e.source + "$"), alias: "url" } },
    },
    selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + e.source + ")*(?=\\s*\\{)"), lookbehind: !0 },
    string: { pattern: e, greedy: !0 },
    property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 },
    important: /!important\b/i,
    function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 },
    punctuation: /[(){};:,]/,
  }),
    (t.languages.css.atrule.inside.rest = t.languages.css);
  var n = t.languages.markup;
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
  keyword:
    /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/,
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
Prism.languages.sql = {
  comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: !0 },
  variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: !0 }, /@[\w.$]+/],
  string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: !0, lookbehind: !0 },
  identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: !0, lookbehind: !0, inside: { punctuation: /^`|`$/ } },
  function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  keyword:
    /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  punctuation: /[;[\]()`,.]/,
};
(function (t) {
  var e = (t.languages.powershell = {
    comment: [
      { pattern: /(^|[^`])<#[\s\S]*?#>/, lookbehind: !0 },
      { pattern: /(^|[^`])#.*/, lookbehind: !0 },
    ],
    string: [
      { pattern: /"(?:`[\s\S]|[^`"])*"/, greedy: !0, inside: null },
      { pattern: /'(?:[^']|'')*'/, greedy: !0 },
    ],
    namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    boolean: /\$(?:false|true)\b/i,
    variable: /\$\w+\b/,
    function: [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i,
    ],
    keyword:
      /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    operator: {
      pattern:
        /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: !0,
    },
    punctuation: /[|{}[\];(),.]/,
  });
  e.string[0].inside = {
    function: { pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/, lookbehind: !0, inside: e },
    boolean: e.boolean,
    variable: e.variable,
  };
})(Prism);
Prism.languages.python = {
  comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0, greedy: !0 },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: !0,
    inside: {
      interpolation: {
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: !0,
        inside: {
          "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: !0 },
          "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" },
          rest: null,
        },
      },
      string: /[\s\S]+/,
    },
  },
  "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: !0, alias: "string" },
  string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: !0 },
  function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: !0 },
  "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: !0 },
  decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: !0, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } },
  keyword:
    /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  builtin:
    /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  boolean: /\b(?:False|None|True)\b/,
  number:
    /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/,
};
Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function (t) {
  for (var e = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0; n < 2; n++)
    e = e.replace(/<self>/g, function () {
      return e;
    });
  (e = e.replace(/<self>/g, function () {
    return /[^\s\S]/.source;
  })),
    (t.languages.rust = {
      comment: [
        { pattern: RegExp(/(^|[^\\])/.source + e), lookbehind: !0, greedy: !0 },
        { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
      ],
      string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: !0 },
      char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: !0 },
      attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: !0, alias: "attr-name", inside: { string: null } },
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null },
      },
      "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" },
      "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: !0, alias: "punctuation" },
      variable: /\$\w+/,
      "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: !0, alias: "function" },
      "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: !0, alias: "class-name" },
      "module-declaration": [
        { pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: !0, alias: "namespace" },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: { punctuation: /::/ },
        },
      ],
      keyword: [
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/,
      ],
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: { pattern: /\b\w+!/, alias: "property" },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } },
      number:
        /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/,
    }),
    (t.languages.rust["closure-params"].inside.rest = t.languages.rust),
    (t.languages.rust.attribute.inside.string = t.languages.rust.string);
})(Prism);
Prism.languages.swift = {
  comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: !0, greedy: !0 },
  "string-literal": [
    {
      pattern: RegExp(
        /(^|[^"#])/.source +
          "(?:" +
          /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source +
          "|" +
          /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source +
          ")" +
          /(?!["#])/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null },
        "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" },
        punctuation: /\\(?=[\r\n])/,
        string: /[\s\S]+/,
      },
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source +
          "(?:" +
          /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source +
          "|" +
          /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source +
          ")\\2"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null },
        "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" },
        string: /[\s\S]+/,
      },
    },
  ],
  directive: {
    pattern: RegExp(
      /#/.source +
        "(?:" +
        (/(?:elseif|if)\b/.source +
          "(?:[ 	]*" +
          /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source +
          ")+") +
        "|" +
        /(?:else|endif)\b/.source +
        ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      boolean: /\b(?:false|true)\b/,
      number: /\b\d+(?:\.\d+)*\b/,
      operator: /!|&&|\|\||[<>]=?/,
      punctuation: /[(),]/,
    },
  },
  literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" },
  "other-directive": { pattern: /#\w+\b/, alias: "property" },
  attribute: { pattern: /@\w+/, alias: "atrule" },
  "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: !0, alias: "function" },
  label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: !0, alias: "important" },
  keyword:
    /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  boolean: /\b(?:false|true)\b/,
  nil: { pattern: /\bnil\b/, alias: "constant" },
  "short-argument": /\$\d+\b/,
  omit: { pattern: /\b_\b/, alias: "keyword" },
  number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  punctuation: /[{}[\]();,.:\\]/,
};
Prism.languages.swift["string-literal"].forEach(function (t) {
  t.inside.interpolation.inside = Prism.languages.swift;
});
(function (t) {
  (t.languages.typescript = t.languages.extend("javascript", {
    "class-name": {
      pattern:
        /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null,
    },
    builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
  })),
    t.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      /\btype\b(?=\s*(?:[\{*]|$))/
    ),
    delete t.languages.typescript.parameter,
    delete t.languages.typescript["literal-property"];
  var e = t.languages.extend("typescript", {});
  delete e["class-name"],
    (t.languages.typescript["class-name"].inside = e),
    t.languages.insertBefore("typescript", "function", {
      decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } },
      "generic-function": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e },
        },
      },
    }),
    (t.languages.ts = t.languages.typescript);
})(Prism);
(function (t) {
  var e =
      /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,
    n = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source,
    r = {
      pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: { namespace: { pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/, inside: { punctuation: /\./ } }, punctuation: /\./ },
    };
  (t.languages.java = t.languages.extend("clike", {
    string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/, lookbehind: !0, greedy: !0 },
    "class-name": [
      r,
      {
        pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: !0,
        inside: r.inside,
      },
      {
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + n + /[A-Z]\w*\b/.source),
        lookbehind: !0,
        inside: r.inside,
      },
    ],
    keyword: e,
    function: [t.languages.clike.function, { pattern: /(::\s*)[a-z_]\w*/, lookbehind: !0 }],
    number:
      /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    operator: { pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m, lookbehind: !0 },
    constant: /\b[A-Z][A-Z_\d]+\b/,
  })),
    t.languages.insertBefore("java", "string", {
      "triple-quoted-string": { pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/, greedy: !0, alias: "string" },
      char: { pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/, greedy: !0 },
    }),
    t.languages.insertBefore("java", "class-name", {
      annotation: { pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/, lookbehind: !0, alias: "punctuation" },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: { "class-name": r, keyword: e, punctuation: /[<>(),.:]/, operator: /[?&|]/ },
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + n + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: { namespace: r.inside.namespace, punctuation: /\./, operator: /\*/, "class-name": /\w+/ },
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + n + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: { namespace: r.inside.namespace, static: /\b\w+$/, punctuation: /\./, operator: /\*/, "class-name": /\w+/ },
        },
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
            /<keyword>/g,
            function () {
              return e.source;
            }
          )
        ),
        lookbehind: !0,
        inside: { punctuation: /\./ },
      },
    });
})(Prism);
(function (t) {
  var e =
      /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
    n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function () {
      return e.source;
    });
  (t.languages.cpp = t.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(
          /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function () {
            return e.source;
          })
        ),
        lookbehind: !0,
      },
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/,
    ],
    keyword: e,
    number: {
      pattern:
        /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: !0,
    },
    operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    boolean: /\b(?:false|true)\b/,
  })),
    t.languages.insertBefore("cpp", "string", {
      module: {
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source +
            "(?:" +
            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source +
            "|" +
            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function () {
              return n;
            }) +
            ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ },
      },
      "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: !0 },
    }),
    t.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: t.languages.cpp } },
      },
    }),
    t.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }),
    t.languages.insertBefore("cpp", "class-name", {
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: t.languages.extend("cpp", {}),
      },
    }),
    t.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, t.languages.cpp["base-clause"]);
})(Prism);
function QOe(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
QOe(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const cP = (t) => {
  try {
    return !!t && window.Prism.languages.hasOwnProperty(t);
  } catch {
    return !1;
  }
};
function lM(t, e) {
  for (const n of t.childNodes) {
    if (qr(n) && n.tagName === e) return !0;
    lM(n, e);
  }
  return !1;
}
const Jc = "data-language",
  xd = "data-highlight-language";
class mf extends ii {
  static getType() {
    return "code";
  }
  static clone(e) {
    return new mf(e.__language, e.__key);
  }
  constructor(e, n) {
    super(n), (this.__language = e), (this.__isSyntaxHighlightSupported = cP(e));
  }
  createDOM(e) {
    const n = document.createElement("code");
    Yr(n, e.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Jc, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(xd, r)), n;
  }
  updateDOM(e, n, r) {
    const i = this.__language,
      s = e.__language;
    return (
      i
        ? i !== s && (n.setAttribute(Jc, i), this.__isSyntaxHighlightSupported && n.setAttribute(xd, i))
        : s && (n.removeAttribute(Jc), e.__isSyntaxHighlightSupported && n.removeAttribute(xd)),
      !1
    );
  }
  exportDOM(e) {
    const n = document.createElement("pre");
    Yr(n, e._config.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Jc, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(xd, r)), { element: n };
  }
  static importDOM() {
    return {
      code: (e) => (e.textContent != null && (/\r?\n/.test(e.textContent) || lM(e, "BR")) ? { conversion: uP, priority: 1 } : null),
      div: () => ({ conversion: FOe, priority: 1 }),
      pre: () => ({ conversion: uP, priority: 0 }),
      table: (e) => (Y1(e) ? { conversion: VOe, priority: 3 } : null),
      td: (e) => {
        const n = e,
          r = n.closest("table");
        return n.classList.contains("js-file-line") || (r && Y1(r)) ? { conversion: hP, priority: 3 } : null;
      },
      tr: (e) => {
        const n = e.closest("table");
        return n && Y1(n) ? { conversion: hP, priority: 3 } : null;
      },
    };
  }
  static importJSON(e) {
    const n = dc(e.language);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
  }
  insertNewAfter(e, n = !0) {
    const r = this.getChildren(),
      i = r.length;
    if (
      i >= 2 &&
      r[i - 1].getTextContent() ===
        `
` &&
      r[i - 2].getTextContent() ===
        `
` &&
      e.isCollapsed() &&
      e.anchor.key === this.__key &&
      e.anchor.offset === i
    ) {
      r[i - 1].remove(), r[i - 2].remove();
      const l = at();
      return this.insertAfter(l, n), l;
    }
    const { anchor: s, focus: o } = e,
      a = (s.isBefore(o) ? s : o).getNode();
    if (ne(a)) {
      let l = BOe(a);
      const c = [];
      for (;;)
        if (Eb(l)) c.push(jl()), (l = l.getNextSibling());
        else {
          if (!uM(l)) break;
          {
            let O = 0;
            const v = l.getTextContent(),
              g = l.getTextContentSize();
            for (; O < g && v[O] === " "; ) O++;
            if ((O !== 0 && c.push(cM(" ".repeat(O))), O !== g)) break;
            l = l.getNextSibling();
          }
        }
      const u = a.splitText(s.offset)[0],
        h = s.offset === 0 ? 0 : 1,
        f = u.getIndexWithinParent() + h,
        d = a.getParentOrThrow(),
        p = [Ri(), ...c];
      d.splice(f, 0, p);
      const m = c[c.length - 1];
      m ? m.select() : s.offset === 0 ? u.selectPrevious() : u.getNextSibling().selectNext(0, 0);
    }
    if (gk(a)) {
      const { offset: l } = e.anchor;
      a.splice(l, 0, [Ri()]), a.select(l + 1, l + 1);
    }
    return null;
  }
  canIndent() {
    return !1;
  }
  collapseAtStart() {
    const e = at();
    return this.getChildren().forEach((n) => e.append(n)), this.replace(e), !0;
  }
  setLanguage(e) {
    const n = this.getWritable();
    (n.__language = e), (n.__isSyntaxHighlightSupported = cP(e));
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
}
function dc(t) {
  return Zn(new mf(t));
}
function gk(t) {
  return t instanceof mf;
}
function uP(t) {
  return { node: dc(t.getAttribute(Jc)) };
}
function FOe(t) {
  const e = t,
    n = fP(e);
  return n ||
    (function (r) {
      let i = r.parentElement;
      for (; i !== null; ) {
        if (fP(i)) return !0;
        i = i.parentElement;
      }
      return !1;
    })(e)
    ? { node: n ? dc() : null }
    : { node: null };
}
function VOe() {
  return { node: dc() };
}
function hP() {
  return { node: null };
}
function fP(t) {
  return t.style.fontFamily.match("monospace") !== null;
}
function Y1(t) {
  return t.classList.contains("js-file-line-container");
}
class Gg extends Os {
  constructor(e, n, r) {
    super(e, r), (this.__highlightType = n);
  }
  static getType() {
    return "code-highlight";
  }
  static clone(e) {
    return new Gg(e.__text, e.__highlightType || void 0, e.__key);
  }
  getHighlightType() {
    return this.getLatest().__highlightType;
  }
  canHaveFormat() {
    return !1;
  }
  createDOM(e) {
    const n = super.createDOM(e),
      r = G1(e.theme, this.__highlightType);
    return Yr(n, r), n;
  }
  updateDOM(e, n, r) {
    const i = super.updateDOM(e, n, r),
      s = G1(r.theme, e.__highlightType),
      o = G1(r.theme, this.__highlightType);
    return s !== o && (s && Fm(n, s), o && Yr(n, o)), i;
  }
  static importJSON(e) {
    const n = cM(e.text, e.highlightType);
    return n.setFormat(e.format), n.setDetail(e.detail), n.setMode(e.mode), n.setStyle(e.style), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
  }
  setFormat(e) {
    return this;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return dc();
  }
}
function G1(t, e) {
  return e && t && t.codeHighlight && t.codeHighlight[e];
}
function cM(t, e) {
  return Zn(new Gg(t, e));
}
function uM(t) {
  return t instanceof Gg;
}
function BOe(t) {
  let e = t,
    n = t;
  for (; uM(n) || Eb(n); ) (e = n), (n = n.getPreviousSibling());
  return e;
}
function Wx(t, e) {
  const n = {};
  for (const r of t) {
    const i = e(r);
    n[i] ? n[i].push(r) : (n[i] = [r]);
  }
  return n;
}
function jOe(t) {
  const e = Wx(t, (n) => n.type);
  return { element: e.element || [], textFormat: e["text-format"] || [], textMatch: e["text-match"] || [] };
}
const dP = /[!-/:-@[-`{-~\s]/,
  hM = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  ZOe = hM && "documentMode" in document ? document.documentMode : null;
hM && "InputEvent" in window && !ZOe && new window.InputEvent("input");
function zOe(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var WOe = zOe(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function pP(t, e, n) {
  const r = n.length;
  for (let i = e; i >= r; i--) {
    const s = i - r;
    if (fM(t, s, n, 0, r) && t[s + r] !== " ") return s;
  }
  return -1;
}
function fM(t, e, n, r, i) {
  for (let s = 0; s < i; s++) if (t[e + s] !== n[r + s]) return !1;
  return !0;
}
function UOe(t, e = _M) {
  const n = jOe(e),
    r = Wx(n.textFormat, ({ tag: o }) => o[o.length - 1]),
    i = Wx(n.textMatch, ({ trigger: o }) => o);
  for (const o of e) {
    const a = o.type;
    if (a === "element" || a === "text-match") {
      const l = o.dependencies;
      for (const c of l) t.hasNode(c) || WOe(173, c.getType());
    }
  }
  const s = (o, a, l) => {
    (function (c, u, h, f) {
      const d = c.getParent();
      if (!rn(d) || c.getFirstChild() !== u) return !1;
      const p = u.getTextContent();
      if (p[h - 1] !== " ") return !1;
      for (const { regExp: m, replace: O } of f) {
        const v = p.match(m);
        if (v && v[0].length === h) {
          const g = u.getNextSiblings(),
            [x, y] = u.splitText(h);
          return x.remove(), O(c, y ? [y, ...g] : g, v, !1), !0;
        }
      }
      return !1;
    })(o, a, l, n.element) ||
      (function (c, u, h) {
        let f = c.getTextContent();
        const d = h[f[u - 1]];
        if (d == null) return !1;
        u < f.length && (f = f.slice(0, u));
        for (const p of d) {
          const m = f.match(p.regExp);
          if (m === null) continue;
          const O = m.index || 0,
            v = O + m[0].length;
          let g;
          return O === 0 ? ([g] = c.splitText(v)) : ([, g] = c.splitText(O, v)), g.selectNext(0, 0), p.replace(g, m), !0;
        }
        return !1;
      })(a, l, i) ||
      (function (c, u, h) {
        const f = c.getTextContent(),
          d = u - 1,
          p = f[d],
          m = h[p];
        if (!m) return !1;
        for (const O of m) {
          const { tag: v } = O,
            g = v.length,
            x = d - g + 1;
          if ((g > 1 && !fM(f, x, v, 0, g)) || f[x - 1] === " ") continue;
          const y = f[d + 1];
          if (O.intraword === !1 && y && !dP.test(y)) continue;
          const S = c;
          let k = S,
            b = pP(f, x, v),
            _ = k;
          for (; b < 0 && (_ = _.getPreviousSibling()) && !Hr(_); )
            if (ne(_)) {
              const H = _.getTextContent();
              (k = _), (b = pP(H, H.length, v));
            }
          if (b < 0 || (k === S && b + g === x)) continue;
          const T = k.getTextContent();
          if (b > 0 && T[b - 1] === p) continue;
          const P = T[b - 1];
          if (O.intraword === !1 && P && !dP.test(P)) continue;
          const M = S.getTextContent(),
            D = M.slice(0, x) + M.slice(d + 1);
          S.setTextContent(D);
          const V = k === S ? D : T;
          k.setTextContent(V.slice(0, b) + V.slice(b + g));
          const Q = ce(),
            N = Dm();
          yn(N);
          const G = d - g * (k === S ? 2 : 1) + 1;
          N.anchor.set(k.__key, b, "text"), N.focus.set(S.__key, G, "text");
          for (const H of O.format) N.hasFormat(H) || N.formatText(H);
          N.anchor.set(N.focus.key, N.focus.offset, N.focus.type);
          for (const H of O.format) N.hasFormat(H) && N.toggleFormat(H);
          return ee(Q) && (N.format = Q.format), !0;
        }
      })(a, l, r);
  };
  return t.registerUpdateListener(({ tags: o, dirtyLeaves: a, editorState: l, prevEditorState: c }) => {
    if (o.has("collaboration") || o.has("historic") || t.isComposing()) return;
    const u = l.read(ce),
      h = c.read(ce);
    if (!ee(h) || !ee(u) || !u.isCollapsed()) return;
    const f = u.anchor.key,
      d = u.anchor.offset,
      p = l._nodeMap.get(f);
    !ne(p) ||
      !a.has(f) ||
      (d !== 1 && d > h.anchor.offset + 1) ||
      t.update(() => {
        if (p.hasFormat("code")) return;
        const m = p.getParent();
        m === null || gk(m) || s(m, p, u.anchor.offset);
      });
  });
}
const dM = (t) => (e, n, r) => {
    const i = t(r);
    i.append(...n), e.replace(i), i.select(0, 0);
  },
  Ok = (t) => (e, n, r) => {
    const i = e.getPreviousSibling(),
      s = e.getNextSibling(),
      o = Pn(t === "check" ? r[3] === "x" : void 0);
    if (Le(s) && s.getListType() === t) {
      const l = s.getFirstChild();
      l !== null ? l.insertBefore(o) : s.append(o), e.remove();
    } else if (Le(i) && i.getListType() === t) i.append(o), e.remove();
    else {
      const l = _n(t, t === "number" ? Number(r[2]) : void 0);
      l.append(o), e.replace(l);
    }
    o.append(...n), o.select(0, 0);
    const a = (function (l) {
      const c = l.match(/\t/g),
        u = l.match(/ /g);
      let h = 0;
      return c && (h += c.length), u && (h += Math.floor(u.length / 4)), h;
    })(r[1]);
    a && o.setIndent(a);
  },
  Jg = (t, e, n) => {
    const r = [],
      i = t.getChildren();
    let s = 0;
    for (const o of i)
      if (et(o)) {
        if (o.getChildrenSize() === 1) {
          const u = o.getFirstChild();
          if (Le(u)) {
            r.push(Jg(u, e, n + 1));
            continue;
          }
        }
        const a = " ".repeat(4 * n),
          l = t.getListType(),
          c = l === "number" ? `${t.getStart() + s}. ` : l === "check" ? `- [${o.getChecked() ? "x" : " "}] ` : "- ";
        r.push(a + c + e(o)), s++;
      }
    return r.join(`
`);
  },
  XOe = {
    dependencies: [kh],
    export: (t, e) => {
      if (!Bm(t)) return null;
      const n = Number(t.getTag().slice(1));
      return "#".repeat(n) + " " + e(t);
    },
    regExp: /^(#{1,6})\s/,
    replace: dM((t) => {
      const e = "h" + t[1].length;
      return Si(e);
    }),
    type: "element",
  },
  pM = {
    dependencies: [Vm],
    export: (t, e) => {
      if (!yO(t)) return null;
      const n = e(t).split(`
`),
        r = [];
      for (const i of n) r.push("> " + i);
      return r.join(`
`);
    },
    regExp: /^>\s/,
    replace: (t, e, n, r) => {
      if (r) {
        const s = t.getPreviousSibling();
        if (yO(s)) return s.splice(s.getChildrenSize(), 0, [Ri(), ...e]), s.select(0, 0), void t.remove();
      }
      const i = Sh();
      i.append(...e), t.replace(i), i.select(0, 0);
    },
    type: "element",
  },
  mM = {
    dependencies: [mf],
    export: (t) => {
      if (!gk(t)) return null;
      const e = t.getTextContent();
      return (
        "```" +
        (t.getLanguage() || "") +
        (e
          ? `
` + e
          : "") +
        "\n```"
      );
    },
    regExp: /^[ \t]*```(\w{1,10})?\s/,
    replace: dM((t) => dc(t ? t[1] : void 0)),
    type: "element",
  },
  gM = {
    dependencies: [mo, po],
    export: (t, e) => (Le(t) ? Jg(t, e, 0) : null),
    regExp: /^(\s*)[-*+]\s/,
    replace: Ok("bullet"),
    type: "element",
  },
  HOe = {
    dependencies: [mo, po],
    export: (t, e) => (Le(t) ? Jg(t, e, 0) : null),
    regExp: /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i,
    replace: Ok("check"),
    type: "element",
  },
  OM = {
    dependencies: [mo, po],
    export: (t, e) => (Le(t) ? Jg(t, e, 0) : null),
    regExp: /^(\s*)(\d{1,})\.\s/,
    replace: Ok("number"),
    type: "element",
  },
  vM = { format: ["code"], tag: "`", type: "text-format" },
  qOe = { format: ["highlight"], tag: "==", type: "text-format" },
  xM = { format: ["bold", "italic"], tag: "***", type: "text-format" },
  bM = { format: ["bold", "italic"], intraword: !1, tag: "___", type: "text-format" },
  yM = { format: ["bold"], tag: "**", type: "text-format" },
  wM = { format: ["bold"], intraword: !1, tag: "__", type: "text-format" },
  YOe = { format: ["strikethrough"], tag: "~~", type: "text-format" },
  SM = { format: ["italic"], tag: "*", type: "text-format" },
  kM = { format: ["italic"], intraword: !1, tag: "_", type: "text-format" },
  CM = {
    dependencies: [Jl],
    export: (t, e, n) => {
      if (!xi(t)) return null;
      const r = t.getTitle(),
        i = r ? `[${t.getTextContent()}](${t.getURL()} "${r}")` : `[${t.getTextContent()}](${t.getURL()})`,
        s = t.getFirstChild();
      return t.getChildrenSize() === 1 && ne(s) ? n(s, i) : i;
    },
    importRegExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/,
    regExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/,
    replace: (t, e) => {
      const [, n, r, i] = e,
        s = Xo(r, { title: i }),
        o = Et(n);
      o.setFormat(t.getFormat()), s.append(o), t.replace(s);
    },
    trigger: ")",
    type: "text-match",
  },
  GOe = [XOe, pM, mM, gM, OM],
  JOe = [vM, xM, bM, yM, wM, qOe, SM, kM, YOe],
  KOe = [CM],
  _M = [...GOe, ...JOe, ...KOe],
  eve = [
    {
      dependencies: [Km],
      export: (t) => (fy(t) ? "***" : null),
      regExp: /^(---|\*\*\*|___)\s?$/,
      replace: (t, e, n, r) => {
        const i = Ih();
        r || t.getNextSibling() != null ? t.replace(i) : t.insertBefore(i), i.selectNext();
      },
      type: "element",
    },
    ..._M,
  ];
function mP({ transformers: t = eve }) {
  const [e] = jn();
  return w.useEffect(() => UOe(e, t), [e, t]), null;
}
const tve = en({
    init(t) {
      const e = t.getValue(Jm),
        n = e.includes("headings") ? t.getValue(Rh) : [],
        r = rve(e, n);
      t.pubIn({ [fo]: () => C.createElement(mP, { transformers: r }), [sy]: () => C.createElement(mP, { transformers: r }) });
    },
  }),
  nve = (t) => (e, n, r) => {
    const i = t(r);
    i.append(...n), e.replace(i), i.select(0, 0);
  };
function rve(t, e) {
  const n = [xM, bM, yM, wM, vM, SM, kM];
  if (t.includes("headings")) {
    const r = Math.min(...e),
      i = Math.max(...e),
      s = new RegExp(`^(#{${r},${i}})\\s`),
      o = {
        dependencies: [kh],
        export: (a, l) => {
          if (!Bm(a)) return null;
          const c = Number(a.getTag().slice(1));
          return "#".repeat(c) + " " + l(a);
        },
        regExp: s,
        replace: nve((a) => {
          const l = `h${a[1].length}`;
          return Si(l);
        }),
        type: "element",
      };
    n.push(o);
  }
  if (
    (t.includes("quote") && n.push(pM),
    t.includes("link") && n.push(CM),
    t.includes("lists") && n.push(OM, gM, HOe),
    t.includes("codeblock"))
  ) {
    const r = {
      ...mM,
      dependencies: [ga],
      replace: (i, s, o) => {
        const a = Jh({ code: "", language: o[1] ?? "", meta: "" });
        i.replace(a),
          setTimeout(() => {
            a.select();
          }, 80);
      },
    };
    n.push(r);
  }
  return n;
}
const EM = () => {
    const t = tt(Tu),
      e = yt(oy),
      n = yt(Jm),
      r = n.includes("quote"),
      i = n.includes("headings"),
      s = lt();
    if (!r && !i) return null;
    const o = [{ label: s("toolbar.blockTypes.paragraph", "Paragraph"), value: "paragraph" }];
    if ((r && o.push({ label: s("toolbar.blockTypes.quote", "Quote"), value: "quote" }), i)) {
      const a = yt(Rh);
      o.push(...a.map((l) => ({ label: s("toolbar.blockTypes.heading", "Heading {{level}}", { level: l }), value: `h${l}` })));
    }
    return C.createElement(pf, {
      value: e,
      onChange: (a) => {
        switch (a) {
          case "quote":
            t(() => Sh());
            break;
          case "paragraph":
            t(() => at());
            break;
          case "":
            break;
          default:
            if (a.startsWith("h")) t(() => Si(a));
            else throw new Error(`Unknown block type: ${a}`);
        }
      },
      triggerTitle: s("toolbar.blockTypeSelect.selectBlockTypeTooltip", "Select block type"),
      placeholder: s("toolbar.blockTypeSelect.placeholder", "Block type"),
      items: o,
    });
  },
  dl = ({ format: t, addTitle: e, removeTitle: n, icon: r, formatName: i }) => {
    const [s, o] = nt(Hm, ft),
      a = tt(qm),
      l = (s & t) !== 0;
    return C.createElement(
      rk,
      {
        title: l ? n : e,
        on: l,
        onValueChange: () => {
          a(i);
        },
      },
      o(r)
    );
  },
  TM = ({ options: t }) => {
    const e = lt(),
      n = typeof t > "u";
    return C.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      n || t.includes("Bold")
        ? C.createElement(dl, {
            format: Ga,
            addTitle: e("toolbar.bold", "Bold"),
            removeTitle: e("toolbar.removeBold", "Remove bold"),
            icon: "format_bold",
            formatName: "bold",
          })
        : null,
      n || t.includes("Italic")
        ? C.createElement(dl, {
            format: Ja,
            addTitle: e("toolbar.italic", "Italic"),
            removeTitle: e("toolbar.removeItalic", "Remove italic"),
            icon: "format_italic",
            formatName: "italic",
          })
        : null,
      n || t.includes("Underline")
        ? C.createElement(dl, {
            format: el,
            addTitle: e("toolbar.underline", "Underline"),
            removeTitle: e("toolbar.removeUnderline", "Remove underline"),
            icon: "format_underlined",
            formatName: "underline",
          })
        : null
    );
  },
  PM = ({ options: t }) => {
    const e = lt(),
      n = typeof t > "u";
    return C.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      n || t.includes("Strikethrough")
        ? C.createElement(dl, {
            format: Ka,
            addTitle: e("toolbar.strikethrough", "Strikethrough"),
            removeTitle: e("toolbar.removeStrikethrough", "Remove strikethrough"),
            icon: "strikeThrough",
            formatName: "strikethrough",
          })
        : null,
      n || t.includes("Sup")
        ? C.createElement(dl, {
            format: nl,
            addTitle: e("toolbar.superscript", "Superscript"),
            removeTitle: e("toolbar.removeSuperscript", "Remove superscript"),
            icon: "superscript",
            formatName: "superscript",
          })
        : null,
      n || t.includes("Sub")
        ? C.createElement(dl, {
            format: tl,
            addTitle: e("toolbar.subscript", "Subscript"),
            removeTitle: e("toolbar.removeSubscript", "Remove subscript"),
            icon: "subscript",
            formatName: "subscript",
          })
        : null
    );
  };
function vk(t) {
  return {
    note: t("admonitions.note", "Note"),
    tip: t("admonitions.tip", "Tip"),
    danger: t("admonitions.danger", "Danger"),
    info: t("admonitions.info", "Info"),
    caution: t("admonitions.caution", "Caution"),
  };
}
const AM = () => {
    const [t, e] = nt(ho, sr),
      n = t.rootNode,
      r = lt(),
      i = vk(r);
    return C.createElement(pf, {
      value: n.getMdastNode().name,
      onChange: (s) => {
        e == null ||
          e.update(() => {
            n.setMdastNode({ ...n.getMdastNode(), name: s }),
              setTimeout(() => {
                e.update(() => {
                  n.getLatest().select();
                });
              }, 80);
          });
      },
      triggerTitle: r("admonitions.changeType", "Select admonition type"),
      placeholder: r("admonitions.placeholder", "Admonition type"),
      items: Xg.map((s) => ({ label: i[s], value: s })),
    });
  },
  J1 = "__EMPTY_VALUE__",
  $M = () => {
    const [t, e, n] = nt(ho, At, uh),
      r = t.rootNode,
      i = lt();
    let s = r.getLanguage();
    return (
      s === "" && (s = J1),
      C.createElement(
        "div",
        { className: F.selectWithLabel },
        C.createElement("label", null, i("codeBlock.language", "Code block language")),
        C.createElement(pf, {
          value: s,
          onChange: (o) => {
            e == null ||
              e.update(() => {
                r.setLanguage(o === J1 ? "" : o),
                  setTimeout(() => {
                    e.update(() => {
                      r.getLatest().select();
                    });
                  });
              });
          },
          triggerTitle: i("codeBlock.selectLanguage", "Select code block language"),
          placeholder: i("codeBlock.language", "Code block language"),
          items: Object.entries(n).map(([o, a]) => ({ value: o || J1, label: a })),
        })
      )
    );
  },
  RM = () => {
    const [t, e] = nt(Hm, ft),
      n = tt(qm),
      r = lt(),
      i = (t & _h) !== 0,
      s = i ? r("toolbar.removeInlineCode", "Remove code format") : r("toolbar.inlineCode", "Inline code format");
    return C.createElement(ik, { items: [{ title: s, contents: e("code"), active: i, onChange: n.bind(null, "code") }] });
  },
  IM = () => {
    const t = tt(Hg),
      e = yt(ft),
      n = lt();
    return C.createElement(
      wo,
      {
        "aria-label": n("toolbar.link", "Create link"),
        title: n("toolbar.link", "Create link"),
        onClick: (r) => {
          t();
        },
      },
      e("link")
    );
  },
  NM = ({ children: t, options: e = ["rich-text", "diff", "source"] }) => {
    const [n, r] = nt(to, ft),
      i = tt(to),
      s = lt(),
      o = [];
    return (
      e.includes("rich-text") && o.push({ title: s("toolbar.richText", "Rich text"), contents: r("rich_text"), value: "rich-text" }),
      e.includes("diff") && o.push({ title: s("toolbar.diffMode", "Diff mode"), contents: r("difference"), value: "diff" }),
      e.includes("source") && o.push({ title: s("toolbar.source", "Source mode"), contents: r("markdown"), value: "source" }),
      C.createElement(
        C.Fragment,
        null,
        n === "rich-text"
          ? t
          : n === "diff"
          ? C.createElement("span", { className: F.toolbarTitleMode }, s("toolbar.diffMode", "Diff mode"))
          : C.createElement("span", { className: F.toolbarTitleMode }, s("toolbar.source", "Source mode")),
        C.createElement(
          "div",
          { style: { marginLeft: "auto", pointerEvents: "auto", opacity: 1 } },
          C.createElement(sk, {
            className: F.diffSourceToggle,
            value: n,
            items: o,
            onChange: (a) => {
              i(a === "" ? "rich-text" : a);
            },
          })
        )
      )
    );
  },
  LM = () => {
    const t = tt(US),
      e = yt(ft),
      n = lt(),
      r = C.useMemo(() => {
        const i = vk(n);
        return Xg.map((s) => ({ value: s, label: i[s] }));
      }, [n]);
    return C.createElement(
      ok,
      {
        title: n("toolbar.admonition", "Insert Admonition"),
        onChoose: (i) => {
          t({ type: "containerDirective", name: i });
        },
        items: r,
      },
      e("admonition")
    );
  },
  MM = () => {
    const t = tt(Kh),
      e = yt(ft),
      n = lt();
    return C.createElement(
      wo,
      {
        title: n("toolbar.codeBlock", "Insert Code Block"),
        onClick: () => {
          t({});
        },
      },
      e("frame_source")
    );
  },
  DM = () => {
    const t = tt(cw),
      [e, n] = nt(hw, ft),
      r = lt();
    return C.createElement(
      wo,
      {
        title: e ? r("toolbar.editFrontmatter", "Edit frontmatter") : r("toolbar.insertFrontmatter", "Insert frontmatter"),
        className: Ze({ [F.activeToolbarButton]: e }),
        onClick: () => {
          t();
        },
      },
      n("frontmatter")
    );
  },
  QM = C.forwardRef((t, e) => {
    const n = tt(qy),
      [r, i] = nt(sn, ft),
      s = lt();
    return C.createElement(
      ns,
      {
        className: F.toolbarButton,
        ref: e,
        disabled: r,
        onClick: () => {
          n();
        },
      },
      C.createElement(yo, { title: s("toolbar.image", "Insert image") }, i("add_photo"))
    );
  }),
  FM = () => {
    const [t, e] = nt(oa, ft),
      n = tt(SS),
      r = C.useMemo(() => t.presets.map((s) => ({ value: s.name, label: s.label })), [t]),
      i = lt();
    return C.createElement(ok, { title: i("toolbar.insertSandpack", "Insert Sandpack"), onChoose: n, items: r }, e("sandpack"));
  },
  VM = () => {
    const t = yt(ft),
      e = tt(Sy),
      n = lt();
    return C.createElement(
      wo,
      {
        title: n("toolbar.table", "Insert Table"),
        onClick: () => {
          e({ rows: 3, columns: 3 });
        },
      },
      t("table")
    );
  },
  BM = () => {
    const t = tt(dy),
      e = yt(ft),
      n = lt();
    return C.createElement(
      wo,
      {
        title: n("toolbar.thematicBreak", "Insert thematic break"),
        onClick: () => {
          t();
        },
      },
      e("horizontal_rule")
    );
  },
  ive = { bullet: "format_list_bulleted", number: "format_list_numbered", check: "format_list_checked" },
  jM = ({ options: t = ["bullet", "number", "check"] }) => {
    const [e, n] = nt(Op, ft),
      r = tt(my),
      i = lt(),
      s = {
        bullet: i("toolbar.bulletedList", "Bulleted list"),
        number: i("toolbar.numberedList", "Numbered list"),
        check: i("toolbar.checkList", "Check list"),
      },
      o = t.map((a) => ({ value: a, title: s[a], contents: n(ive[a]) }));
    return C.createElement(sk, { value: e || "", items: o, onChange: r });
  },
  ZM = () => {
    const [t, e, n, r] = nt(ho, At, ft, oa),
      i = t.rootNode,
      s = lt(),
      o = r.presets.find((a) => a.meta === i.getMeta());
    return C.createElement(
      "div",
      { className: F.selectWithLabel },
      C.createElement(
        wo,
        {
          title: s("toolbar.deleteSandpack", "Delete this code block"),
          onClick: () => {
            e == null ||
              e.update(() => {
                i.getNextSibling() ? i.selectNext() : i.selectPrevious(), i.remove();
              });
          },
        },
        n("delete_big")
      ),
      C.createElement("label", null, "Sandpack preset: ", o.name)
    );
  },
  zM = () => {
    const [t, e] = nt(ft, At),
      [n, r] = C.useState(!1),
      [i, s] = C.useState(!1),
      o = lt();
    return (
      C.useEffect(() => {
        if (e)
          return ir(
            e.registerCommand(Lc, (a) => (r(a), !1), Gn),
            e.registerCommand(Nc, (a) => (s(a), !1), Gn)
          );
      }, [e]),
      C.createElement(ik, {
        items: [
          {
            title: o("toolbar.undo", "Undo {{shortcut}}", { shortcut: _u ? "⌘Z" : "Ctrl+Z" }),
            disabled: !n,
            contents: t("undo"),
            active: !1,
            onChange: () => (e == null ? void 0 : e.dispatchCommand(wm, void 0)),
          },
          {
            title: o("toolbar.redo", "Redo {{shortcut}}", { shortcut: _u ? "⌘Y" : "Ctrl+Y" }),
            disabled: !i,
            contents: t("redo"),
            active: !1,
            onChange: () => (e == null ? void 0 : e.dispatchCommand(Sm, void 0)),
          },
        ],
      })
    );
  };
function gP(t) {
  const e = t == null ? void 0 : t.rootNode;
  return !e || e.getType() !== "directive" ? !1 : ["note", "tip", "danger", "info", "caution"].includes(e.getMdastNode().name);
}
const sve = () =>
    C.createElement(
      NM,
      null,
      C.createElement(jd, {
        options: [
          { when: (t) => (t == null ? void 0 : t.editorType) === "codeblock", contents: () => C.createElement($M, null) },
          { when: (t) => (t == null ? void 0 : t.editorType) === "sandpack", contents: () => C.createElement(ZM, null) },
          {
            fallback: () =>
              C.createElement(
                C.Fragment,
                null,
                C.createElement(zM, null),
                C.createElement(Oi, null),
                C.createElement(TM, null),
                C.createElement(RM, null),
                C.createElement(Oi, null),
                C.createElement(PM, null),
                C.createElement(Oi, null),
                C.createElement(jM, null),
                C.createElement(Oi, null),
                C.createElement(jd, {
                  options: [{ when: gP, contents: () => C.createElement(AM, null) }, { fallback: () => C.createElement(EM, null) }],
                }),
                C.createElement(Oi, null),
                C.createElement(IM, null),
                C.createElement(QM, null),
                C.createElement(Oi, null),
                C.createElement(VM, null),
                C.createElement(BM, null),
                C.createElement(Oi, null),
                C.createElement(MM, null),
                C.createElement(FM, null),
                C.createElement(jd, {
                  options: [
                    {
                      when: (t) => !gP(t),
                      contents: () => C.createElement(C.Fragment, null, C.createElement(Oi, null), C.createElement(LM, null)),
                    },
                  ],
                }),
                C.createElement(Oi, null),
                C.createElement(DM, null)
              ),
          },
        ],
      })
    ),
  OP = 20,
  ove = C.forwardRef(
    (
      { autocompleteSuggestions: t = [], submitButtonTitle: e, dialogInputPlaceholder: n, onSubmit: r, tooltipTitle: i, buttonContent: s },
      o
    ) => {
      const [a, l] = nt(si, sn),
        [c, u] = C.useState(!1),
        h = C.useCallback(
          (f) => {
            r(f), u(!1);
          },
          [r]
        );
      return C.createElement(
        _y,
        { open: c, onOpenChange: u },
        C.createElement(
          tG,
          { asChild: !0 },
          C.createElement(ns, { className: F.toolbarButton, ref: o, disabled: l }, C.createElement(yo, { title: i }, s))
        ),
        C.createElement(
          Ey,
          { container: a == null ? void 0 : a.current },
          C.createElement(Ty, { className: F.dialogOverlay }),
          C.createElement(
            Py,
            { className: F.dialogContent },
            C.createElement(ave, { submitButtonTitle: e, autocompleteSuggestions: t, onSubmitCallback: h, dialogInputPlaceholder: n })
          )
        )
      );
    }
  ),
  ave = ({ autocompleteSuggestions: t, onSubmitCallback: e, dialogInputPlaceholder: n, submitButtonTitle: r }) => {
    const [i, s] = C.useState(t.slice(0, OP)),
      o = yt(ft),
      a = t.length > 0,
      {
        isOpen: l,
        getToggleButtonProps: c,
        getMenuProps: u,
        getInputProps: h,
        highlightedIndex: f,
        getItemProps: d,
        selectedItem: p,
      } = Xy({
        initialInputValue: "",
        onInputValueChange({ inputValue: y }) {
          y = (y == null ? void 0 : y.toLowerCase()) ?? "";
          const S = [];
          for (const k of t) if (k.toLowerCase().includes(y) && (S.push(k), S.length >= OP)) break;
          s(S);
        },
        items: i,
        itemToString(y) {
          return y ?? "";
        },
      }),
      m = C.useCallback(
        (y) => {
          var S;
          y.key === "Escape"
            ? (S = y.target.form) == null || S.reset()
            : y.key === "Enter" && (!l || i.length === 0) && (y.preventDefault(), e(y.target.value));
        },
        [l, i, e]
      ),
      O = h(),
      v = {
        ...O,
        onKeyDown: (y) => {
          m(y), O.onKeyDown(y);
        },
      },
      g = (y) => {
        y.preventDefault(), y.stopPropagation(), e(v.value);
      },
      x = l && i.length > 0;
    return C.createElement(
      "form",
      { onSubmit: g, className: Ze(F.dialogForm) },
      C.createElement(
        "div",
        { className: F.linkDialogInputContainer },
        C.createElement(
          "div",
          { "data-visible-dropdown": x, className: F.linkDialogInputWrapper },
          C.createElement("input", {
            placeholder: n,
            className: F.linkDialogInput,
            ...v,
            autoFocus: !0,
            size: 30,
            "data-editor-dialog": !0,
          }),
          a && C.createElement("button", { "aria-label": "toggle menu", type: "button", ...c() }, o("arrow_drop_down"))
        ),
        C.createElement(
          "div",
          { className: F.downshiftAutocompleteContainer },
          C.createElement(
            "ul",
            { ...u(), "data-visible": x },
            i.map((y, S) =>
              C.createElement(
                "li",
                { "data-selected": p === y, "data-highlighted": f === S, key: `${y}${S}`, ...d({ item: y, index: S }) },
                y
              )
            )
          )
        )
      ),
      C.createElement(
        "button",
        { type: "submit", title: r, "aria-label": r, className: Ze(F.actionButton, F.primaryActionButton) },
        o("check")
      ),
      C.createElement(Ay, { className: F.actionButton }, o("close"))
    );
  };
function lve(t, e) {
  return t.replace("hsl", "hsla").replace(")", `, ${e})`);
}
const cve = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      $createCodeBlockNode: Jh,
      $createDirectiveNode: Ug,
      $createGenericHTMLNode: Ub,
      $createImageNode: go,
      $createTableNode: sg,
      $isCodeBlockNode: h6,
      $isDirectiveNode: mL,
      $isGenericHTMLNode: NA,
      $isImageNode: $u,
      $isTableNode: F$,
      ADMONITION_TYPES: Xg,
      ALL_HEADING_LEVELS: hy,
      Action: ni,
      AdmonitionDirectiveDescriptor: O1e,
      Appender: zn,
      BlockTypeSelect: EM,
      BoldItalicUnderlineToggles: TM,
      Button: vL,
      ButtonOrDropdownButton: ok,
      ButtonWithTooltip: wo,
      CAN_USE_DOM: zb,
      COMMON_STATE_CONFIG_EXTENSIONS: T0e,
      Cell: Se,
      ChangeAdmonitionType: AM,
      ChangeCodeMirrorLanguage: $M,
      CodeBlockNode: ga,
      CodeMirrorEditor: dL,
      CodeToggle: RM,
      ConditionalContents: jd,
      CreateLink: IM,
      DEFAULT_FORMAT: $Z,
      DialogButton: ove,
      DiffSourceToggleWrapper: NM,
      DirectiveNode: fc,
      GenericDirectiveEditor: v1e,
      GenericHTMLNode: Xl,
      GenericJsxEditor: a6,
      INSERT_IMAGE_COMMAND: Ru,
      IS_APPLE: _u,
      IS_BOLD: Ga,
      IS_CODE: _h,
      IS_HIGHLIGHT: RZ,
      IS_ITALIC: Ja,
      IS_STRIKETHROUGH: Ka,
      IS_SUBSCRIPT: tl,
      IS_SUPERSCRIPT: nl,
      IS_UNDERLINE: el,
      ImageNode: ec,
      InsertAdmonition: LM,
      InsertCodeBlock: MM,
      InsertFrontmatter: DM,
      InsertImage: QM,
      InsertSandpack: FM,
      InsertTable: VM,
      InsertThematicBreak: BM,
      KitchenSinkToolbar: sve,
      ListsToggle: jM,
      MDXEditor: DU,
      MarkdownParseError: cp,
      MultipleChoiceToggleGroup: ik,
      NESTED_EDITOR_UPDATED_COMMAND: Gs,
      NestedEditorsContext: Og,
      NestedLexicalEditor: xg,
      PropertyPopover: bw,
      Realm: qx,
      RealmContext: bm,
      RealmProvider: wD,
      RealmWithPlugins: RP,
      Root: OL,
      Select: pf,
      SelectButtonTrigger: fL,
      SelectContent: BS,
      SelectItem: VS,
      SelectTrigger: hL,
      Separator: Oi,
      ShowSandpackInfo: ZM,
      Signal: $t,
      SingleChoiceToggleGroup: sk,
      SingleToggleGroup: _1e,
      StrikeThroughSupSubToggles: PM,
      TYPE_NAME: TO,
      TableNode: Gl,
      ToggleSingleGroupWithItem: rk,
      ToolbarToggleItem: nk,
      TooltipWrap: yo,
      UndoRedo: zM,
      UnrecognizedMarkdownConstructError: up,
      activeEditor$: At,
      activeEditorSubscriptions$: Jb,
      activePlugins$: Jm,
      addActivePlugin$: ql,
      addComposerChild$: fo,
      addEditorWrapper$: FA,
      addExportVisitor$: xr,
      addImportVisitor$: rr,
      addLexicalNode$: vr,
      addMdastExtension$: eo,
      addNestedEditorChild$: sy,
      addSyntaxExtension$: Ks,
      addToMarkdownExtension$: fa,
      addTopAreaChild$: QA,
      admonitionLabelsMap: vk,
      allowedHeadingLevels$: Rh,
      always: LD,
      appendCodeBlockEditorDescriptor$: yw,
      applyBlockType$: gz,
      applyFormat$: qm,
      applyLinkChanges$: S1e,
      applyListType$: my,
      autoFocus$: PO,
      call: $P,
      cancelLinkEdit$: YS,
      closeImageDialog$: Gy,
      cmExtensions$: Yg,
      codeBlockEditorDescriptors$: ha,
      codeBlockLanguages$: uh,
      codeBlockPlugin: Mne,
      codeMirrorAutoLoadLanguageSupport$: fm,
      codeMirrorExtensions$: hm,
      codeMirrorPlugin: P0e,
      compose: AD,
      composerChildren$: ty,
      contentEditableClassName$: hp,
      controlOrMeta: Wb,
      convertSelectionToNode$: Tu,
      corePlugin: BA,
      createActiveEditorSubscription$: Eu,
      createRootEditorSubscription$: $h,
      currentBlockType$: oy,
      currentFormat$: Hm,
      currentListType$: Op,
      currentSelection$: Zo,
      curry1to0: ID,
      curry2to1: RD,
      debounceTime: _D,
      defaultCodeBlockLanguage$: yg,
      defaultComparator: K1,
      delayWithMicrotask: ED,
      diffMarkdown$: dh,
      diffSourcePlugin: MOe,
      directiveDescriptors$: zo,
      directivesPlugin: g1e,
      disableAutoLink$: U$,
      disableImageResize$: wp,
      disableImageSettingsButton$: Jy,
      editorInFocus$: ho,
      editorRootElementRef$: si,
      editorWrappers$: ry,
      exportLexicalTreeToMdast: Wm,
      exportMarkdownFromLexical: jb,
      exportVisitors$: Ph,
      filter: Vl,
      fromWithinEditorRead: x1e,
      frontmatterDialogOpen$: Du,
      frontmatterPlugin: ete,
      getSelectedNode: gL,
      getSelectionRectangle: XS,
      getStateAsMarkdown: b1e,
      handlePromise: PD,
      hasFrontmatter$: hw,
      headingsPlugin: jU,
      historyState$: VA,
      htmlTags: vA,
      iconComponentFor$: ft,
      imageAutocompleteSuggestions$: yp,
      imageDialogState$: Us,
      imagePlugin: cJ,
      imagePreviewHandler$: Sp,
      imageUploadHandler$: Ds,
      importMarkdownToLexical: IA,
      importMdastTreeToLexical: Um,
      importVisitors$: Eh,
      inFocus$: gl,
      initialMarkdown$: Xb,
      insertCodeBlock$: Kh,
      insertCodeMirror$: pL,
      insertDecoratorNode$: Hl,
      insertDirective$: US,
      insertFrontmatter$: cw,
      insertImage$: R9,
      insertJsx$: c6,
      insertMarkdown$: Gb,
      insertSandpack$: SS,
      insertTable$: Sy,
      insertThematicBreak$: dy,
      isMdastHTMLNode: Bb,
      isMdastJsxNode: l6,
      isPartOftheEditorUI: ig,
      joinProc: MD,
      jsxComponentDescriptors$: Js,
      jsxIsAvailable$: Ah,
      jsxPlugin: Pne,
      linkAutocompleteSuggestions$: KS,
      linkDialogPlugin: k1e,
      linkDialogState$: Nn,
      linkPlugin: Rq,
      listsPlugin: OX,
      makeHslTransparent: lve,
      map: Rr,
      mapTo: Yx,
      markdown$: Gr,
      markdownErrorSignal$: dp,
      markdownProcessingError$: Ol,
      markdownShortcutPlugin: tve,
      markdownSourceEditorValue$: Wo,
      maxLengthPlugin: ite,
      mdastExtensions$: qb,
      muteChange$: mp,
      nestedEditorChildren$: iy,
      noop: Zs,
      onBlur$: vl,
      onClickLinkCallback$: ek,
      onNext: TD,
      onWindowChange$: HS,
      once: kD,
      openEditImageDialog$: Yy,
      openLinkEditDialog$: Hg,
      openNewImageDialog$: qy,
      placeholder$: fp,
      prop: ND,
      quotePlugin: rte,
      readOnly$: sn,
      readOnlyDiff$: mk,
      realmPlugin: en,
      removeFrontmatter$: uw,
      removeLink$: JS,
      rootEditor$: sr,
      rootEditorSubscriptions$: Kb,
      sandpackConfig$: oa,
      sandpackPlugin: hpe,
      saveImage$: Ky,
      scan: Gx,
      setMarkdown$: Gm,
      switchFromPreviewToLinkEdit$: GS,
      syntaxExtensions$: Hb,
      tablePlugin: pq,
      tap: Jx,
      thematicBreakPlugin: HU,
      throttleTime: CD,
      thrush: $D,
      toMarkdownExtensions$: Yb,
      toMarkdownOptions$: pp,
      toolbarContents$: Zd,
      toolbarPlugin: E1e,
      topAreaChildren$: ny,
      translation$: ay,
      updateLink$: qS,
      useCell: SD,
      useCellValue: yt,
      useCellValues: nt,
      useCodeBlockEditorContext: wl,
      useLexicalNodeRemove: s6,
      useMdastNodeUpdater: vg,
      useNestedEditorContext: qh,
      usePublisher: tt,
      useRealm: Fl,
      useTranslation: lt,
      usedLexicalNodes$: Th,
      uuidv4: M$,
      viewMode$: to,
      voidEmitter: bg,
      withLatestFrom: bt,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
const uve =
    (...t) =>
    (e) => {
      for (const n of t) n && (typeof n == "function" ? n(e) : (n.current = e));
    },
  {
    MDXEditor: hve,
    BoldItalicUnderlineToggles: fve,
    ListsToggle: dve,
    CodeToggle: pve,
    CreateLink: mve,
    headingsPlugin: gve,
    listsPlugin: Ove,
    quotePlugin: vve,
    thematicBreakPlugin: xve,
    markdownShortcutPlugin: bve,
    linkDialogPlugin: yve,
    diffSourcePlugin: wve,
    toolbarPlugin: Sve,
    DiffSourceToggleWrapper: kve,
    UndoRedo: Cve,
    BlockTypeSelect: _ve,
    Separator: Eve,
  } = cve,
  WM = vP((t) => {
    var c, u;
    const { formState: e } = hD(),
      { field: n, control: r, editorRef: i, ...s } = t,
      o = xP({ field: n, control: r }),
      a = w.useRef(null);
    w.useEffect(() => {
      var h;
      a.current && a.current.setMarkdown(((h = o.value) == null ? void 0 : h.markdown) ?? "");
    }, [o.value]);
    const l = uve(a, i);
    return C.createElement(hve, {
      plugins: [
        gve(),
        Ove(),
        vve(),
        xve(),
        bve(),
        yve(),
        wve({ diffMarkdown: ((c = fD(e.defaultValues, n)) == null ? void 0 : c.markdown) ?? "", viewMode: "rich-text", readOnlyDiff: !0 }),
        Sve({
          toolbarContents: () =>
            C.createElement(
              kve,
              null,
              C.createElement(Cve, null),
              C.createElement(_ve, null),
              C.createElement(Eve, null),
              C.createElement(fve, null),
              C.createElement(dve, null),
              C.createElement(pve, null),
              C.createElement(mve, null)
            ),
        }),
      ],
      contentEditableClassName: "autoform-prose",
      markdown: ((u = o.value) == null ? void 0 : u.markdown) ?? "",
      onChange: (h) => o.onChange({ markdown: h }),
      ...(l && { ref: l }),
      ...s,
    });
  }),
  Tve = WM;
WM.__docgenInfo = { description: "", methods: [], displayName: "AutoRichTextInput" };
const UM = vP((t) => {
  const e = xP({ field: t.field, control: t.control });
  return C.createElement(
    "div",
    { className: "Polaris-FormLayout__Item" },
    C.createElement(
      "div",
      { className: "Polaris-Labelled__LabelWrapper" },
      C.createElement(dD, { id: e.id, requiredIndicator: e.metadata.requiredArgumentForInput }, t.label ?? e.metadata.name)
    ),
    C.createElement("div", { className: "Autoform-RichTextInput" }, C.createElement(Tve, { ...t }))
  );
});
UM.__docgenInfo = {
  description: "Prefer using the LazyLoadedMUIAutoRichTextInput.tsx variant of this component to reduce the bundle size by default.",
  methods: [],
  displayName: "PolarisAutoRichTextInput",
};
const nxe = Object.freeze(Object.defineProperty({ __proto__: null, default: UM }, Symbol.toStringTag, { value: "Module" }));
export {
  zve as A,
  gre as B,
  Ore as C,
  wre as D,
  ui as E,
  Uoe as F,
  yR as G,
  Hn as H,
  kt as I,
  x8 as J,
  _l as L,
  G4 as N,
  nxe as P,
  T_ as S,
  Zve as _,
  Tl as a,
  Pl as b,
  Dd as c,
  Eae as d,
  _8 as e,
  oc as f,
  pt as g,
  a8 as h,
  of as i,
  _R as j,
  re as k,
  X as l,
  Woe as m,
  dS as n,
  Gp as o,
  J4 as p,
  Lr as q,
  lu as r,
  sc as s,
  R as t,
  vre as u,
  d6 as v,
  Za as w,
  bre as x,
  yre as y,
  D0 as z,
};
