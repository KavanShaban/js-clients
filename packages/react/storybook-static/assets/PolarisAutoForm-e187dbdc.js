import {
  a as $e,
  f as $r,
  aC as $t,
  ac as Ar,
  ax as Br,
  aZ as Bt,
  aq as Ce,
  aj as Cr,
  an as Dr,
  v as Er,
  av as Et,
  az as F,
  aF as Fe,
  am as Fr,
  aP as Gr,
  X as He,
  aD as Hr,
  ay as Ie,
  ad as Ir,
  a1 as It,
  aI as Je,
  aS as Jr,
  aQ as Kr,
  aH as Le,
  u as Lr,
  D as Me,
  ak as Mr,
  E as Ne,
  e as Nr,
  ap as Or,
  aa as Pr,
  aW as Qe,
  aT as Qr,
  as as Rr,
  B as Se,
  ai as Sr,
  I as Te,
  ah as Tr,
  i as Tt,
  aB as Ur,
  aA as Vr,
  ba as Vt,
  aK as Wr,
  aU as Xr,
  aR as Yr,
  aN as Zr,
  ao as _r,
  a_ as aa,
  C as an,
  b8 as bn,
  a7 as br,
  b5 as ca,
  ab as cn,
  b7 as da,
  af as dn,
  S as ea,
  b9 as fa,
  ag as fn,
  F as ga,
  au as gn,
  a4 as gr,
  b3 as hn,
  a6 as hr,
  b2 as ia,
  H as it,
  aO as je,
  w as jr,
  O as kr,
  b as kt,
  b4 as la,
  a5 as ln,
  a9 as lt,
  bb as ma,
  ar as mn,
  aX as na,
  b1 as oa,
  m as oe,
  q as on,
  K as ot,
  bc as pa,
  aE as pe,
  at as pn,
  a2 as pr,
  Y as qe,
  aw as qr,
  aJ as qt,
  aY as ra,
  a$ as rt,
  b0 as sa,
  a3 as sn,
  aV as ta,
  T as te,
  aL as tt,
  b6 as ua,
  c as un,
  a8 as vr,
  k as we,
  al as wr,
  ae as xr,
  h as xt,
  bd as ya,
  aG as yn,
  U as yr,
  J as ze,
  aM as zr,
} from "./apis-d6201c92.js";
import { _ as ba } from "./iframe-5aa777a6.js";
import { R as a, r as d } from "./index-c6dae603.js";
import { u as ha } from "./useAction-e2e8ce4c.js";
var vn = function (t) {
  return a.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    a.createElement("path", {
      fillRule: "evenodd",
      d: "M16.5 10a.75.75 0 0 1-.75.75h-9.69l2.72 2.72a.75.75 0 0 1-1.06 1.06l-4-4a.75.75 0 0 1 0-1.06l4-4a.75.75 0 1 1 1.06 1.06l-2.72 2.72h9.69a.75.75 0 0 1 .75.75Z",
    })
  );
};
vn.displayName = "ArrowLeftIcon";
var En = function (t) {
  return a.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    a.createElement("path", {
      fillRule: "evenodd",
      d: "M3.5 10a.75.75 0 0 1 .75-.75h9.69l-2.72-2.72a.75.75 0 1 1 1.06-1.06l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06-1.06l2.72-2.72h-9.69a.75.75 0 0 1-.75-.75Z",
    })
  );
};
En.displayName = "ArrowRightIcon";
var Pn = function (t) {
  return a.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    a.createElement("path", {
      fillRule: "evenodd",
      d: "M7.75 3.5a.75.75 0 0 0-1.5 0v.407a3.075 3.075 0 0 0-.702.252 3.75 3.75 0 0 0-1.64 1.639c-.226.444-.32.924-.365 1.47-.043.531-.043 1.187-.043 2v1.464c0 .813 0 1.469.043 2 .045.546.14 1.026.366 1.47a3.75 3.75 0 0 0 1.639 1.64c.444.226.924.32 1.47.365.531.043 1.187.043 2 .043h3.383c.323 0 .542 0 .735-.02a3.75 3.75 0 0 0 3.344-3.344c.02-.193.02-.412.02-.735v-2.883c0-.813 0-1.469-.043-2-.045-.546-.14-1.026-.366-1.47a3.75 3.75 0 0 0-1.639-1.64 3.076 3.076 0 0 0-.702-.251v-.407a.75.75 0 0 0-1.5 0v.259c-.373-.009-.794-.009-1.268-.009h-1.964c-.474 0-.895 0-1.268.009v-.259Zm-1.521 1.995c.197-.1.458-.17.912-.207.462-.037 1.057-.038 1.909-.038h1.9c.853 0 1.447 0 1.91.038.453.037.714.107.912.207.423.216.767.56.983.984.1.197.17.458.207.912.014.18.024.38.029.609h-9.982c.006-.228.015-.429.03-.61.036-.453.106-.714.206-.911a2.25 2.25 0 0 1 .984-.984Zm-1.229 4.005v1.2c0 .853 0 1.447.038 1.91.037.453.107.714.207.912.216.423.56.767.984.983.197.1.458.17.912.207.462.037 1.057.038 1.909.038h3.306c.385 0 .52-.001.626-.012a2.25 2.25 0 0 0 2.006-2.006c.011-.106.012-.241.012-.626v-2.606h-10Z",
    })
  );
};
Pn.displayName = "CalendarIcon";
var An = function (t) {
  return a.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    a.createElement("path", { d: "M10.75 6a.75.75 0 0 0-1.5 0v4c0 .199.079.39.22.53l2 2a.75.75 0 1 0 1.06-1.06l-1.78-1.78v-3.69Z" }),
    a.createElement("path", {
      fillRule: "evenodd",
      d: "M17 10a7 7 0 1 1-14 0 7 7 0 0 1 14 0Zm-1.5 0a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z",
    })
  );
};
An.displayName = "ClockIcon";
var St = function (t) {
  return a.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    a.createElement("path", {
      d: "M16.5 6.26a.75.75 0 0 1-1.5 0v-.51a.75.75 0 0 0-.75-.75h-8.5a.75.75 0 0 0-.75.75v.51a.75.75 0 0 1-1.5 0v-.51a2.25 2.25 0 0 1 2.25-2.25h8.5a2.25 2.25 0 0 1 2.25 2.25v.51Z",
    }),
    a.createElement("path", {
      d: "M10.75 16.01a.75.75 0 0 1-1.5 0v-6.69l-1.72 1.72a.75.75 0 1 1-1.06-1.06l3-3a.75.75 0 0 1 1.06 0l3 3a.75.75 0 1 1-1.06 1.06l-1.72-1.72v6.69Z",
    })
  );
};
St.displayName = "UploadIcon";
function va(e) {
  return typeof e[0] == "object" && Object.prototype.hasOwnProperty.call(e[0], "options");
}
var Ea = { Loading: "Polaris-Autocomplete__Loading", SectionWrapper: "Polaris-Autocomplete__SectionWrapper" },
  Xe = {
    Content: "Polaris-Autocomplete-MappedOption__Content",
    Media: "Polaris-Autocomplete-MappedOption__Media",
    singleSelectionMedia: "Polaris-Autocomplete-MappedOption--singleSelectionMedia",
    disabledMedia: "Polaris-Autocomplete-MappedOption--disabledMedia",
  },
  Pa = { Listbox: "Polaris-Listbox" };
const In = d.createContext(void 0),
  kn = d.createContext({}),
  xn = d.createContext({});
function Aa() {
  const e = d.useContext(In);
  if (!e) throw new Error("No Combobox was provided. Your component must be wrapped in a <Combobox> component.");
  return e;
}
function Ia() {
  return d.useContext(kn);
}
function ka(e, t) {
  const n = t.scrollTop,
    r = n + t.clientHeight,
    { offsetHeight: s } = e,
    { offsetTop: o } = e,
    i = o + s;
  if (!(o > n && i < r)) {
    let c = 0;
    i > r ? (c = i + s * 0.85 - r) : o < n && (c = o - s * 0.15 - n),
      requestAnimationFrame(() => {
        t.scrollBy({ top: c, behavior: "auto" });
      });
  }
}
var Ae = {
  TextOption: "Polaris-Listbox-TextOption",
  allowMultiple: "Polaris-Listbox-TextOption--allowMultiple",
  isAction: "Polaris-Listbox-TextOption--isAction",
  disabled: "Polaris-Listbox-TextOption--disabled",
  selected: "Polaris-Listbox-TextOption--selected",
  Content: "Polaris-Listbox-TextOption__Content",
  Checkbox: "Polaris-Listbox-TextOption__Checkbox",
};
const Ct = d.memo(function ({ children: t, selected: n, disabled: r }) {
  const { allowMultiple: s } = d.useContext(xn),
    o = d.useContext(It),
    i = oe(Ae.TextOption, n && !s && Ae.selected, r && Ae.disabled, s && Ae.allowMultiple, o && Ae.isAction),
    l = n
      ? a.createElement(
          $e,
          { width: "100%" },
          a.createElement(
            Te,
            { wrap: !1, align: "space-between", gap: "200" },
            t,
            a.createElement(Te, { align: "end" }, a.createElement(Me, { source: pr }))
          )
        )
      : a.createElement(a.Fragment, null, t);
  return a.createElement(
    "div",
    { className: i },
    a.createElement(
      "div",
      { className: Ae.Content },
      s && !o ? a.createElement("div", { className: Ae.Checkbox }, a.createElement(an, { disabled: r, checked: n, label: t })) : l
    )
  );
});
var Ut = { ListItem: "Polaris-Listbox-Loading__ListItem", Loading: "Polaris-Listbox-Loading" };
function Tn() {
  const e = d.useContext(sn);
  if (!e) throw new Error("No Listbox was provided. Listbox components must be wrapped in a Listbox");
  return e;
}
const xa = d.memo(function ({ children: t, accessibilityLabel: n }) {
    const { setLoading: r } = Tn();
    return (
      d.useEffect(
        () => (
          r(n),
          () => {
            r(void 0);
          }
        ),
        [n, r]
      ),
      a.createElement(
        "li",
        { className: Ut.ListItem, role: "presentation" },
        t || a.createElement("div", { className: Ut.Loading }, a.createElement(gr, { size: "small", accessibilityLabel: n }))
      )
    );
  }),
  Ta = { props: { "data-polaris-listbox-section-item": !0 }, selector: "[data-polaris-listbox-section-item]" },
  Sa = { attribute: "data-polaris-listbox-within-section-item" },
  Sn = d.createContext(null);
var Ht = { SectionGroup: "Polaris-Listbox-Section__SectionGroup", noDivider: "Polaris-Listbox-Section--noDivider" };
function Ca({ children: e, divider: t = !0, title: n }) {
  const r = d.useId();
  return a.createElement(
    Sn.Provider,
    { value: r },
    a.createElement(
      "li",
      Object.assign({ role: "presentation" }, Ta.props),
      n,
      a.createElement("ul", { role: "group", "aria-labelledby": r, className: oe(Ht.SectionGroup, !t && Ht.noDivider) }, e)
    )
  );
}
function Cn() {
  return d.useContext(Sn);
}
function Ma({ children: e }) {
  const t = Cn() || "",
    n =
      typeof e == "string"
        ? a.createElement(
            $e,
            { paddingBlockStart: "200", paddingInlineStart: "400", paddingBlockEnd: "200", paddingInlineEnd: "400" },
            a.createElement(te, { as: "span", variant: "headingSm", tone: "subdued" }, e)
          )
        : e;
  return a.createElement("div", { "aria-hidden": !0, id: t }, n);
}
var ct = { Action: "Polaris-Listbox-Action", ActionDivider: "Polaris-Listbox-Action__ActionDivider", Icon: "Polaris-Listbox-Action__Icon" },
  jt = { Option: "Polaris-Listbox-Option", divider: "Polaris-Listbox-Option--divider" };
const Mn = d.createContext({}),
  wn = d.memo(function ({ value: t, children: n, selected: r, disabled: s = !1, accessibilityLabel: o, divider: i }) {
    const { onOptionSelect: l } = Tn(),
      c = d.useContext(It),
      { role: u, url: f, external: m, onAction: p, destructive: g } = d.useContext(Mn),
      E = d.useRef(null),
      v = d.useId(),
      P = !!Cn(),
      A = d.useCallback(
        (C) => {
          C.preventDefault(), C.stopPropagation(), p && p(), E.current && !p && l({ domId: v, value: t, element: E.current, disabled: s });
        },
        [v, l, t, s, p]
      ),
      b = (C) => {
        C.preventDefault();
      },
      y = typeof n == "string" ? a.createElement(Ct, { selected: r, disabled: s }, n) : n,
      I = { [Sa.attribute]: P },
      k = u || "option",
      x = f ? a.createElement(yr, { url: f, external: m }, y) : y;
    return a.createElement(
      "li",
      Object.assign({}, I, {
        "data-listbox-option": !0,
        "data-listbox-option-action": c,
        "data-listbox-option-value": t,
        "data-listbox-option-destructive": g,
        "data-within-section": P,
        className: oe(jt.Option, i && jt.divider),
        id: v,
        ref: E,
        tabIndex: -1,
        role: k,
        "aria-label": o,
        "aria-selected": r,
        "aria-disabled": s,
        onClick: s ? void 0 : A,
        onKeyDown: s ? void 0 : A,
        onMouseDown: b,
      }),
      x
    );
  });
function wa(e) {
  const { selected: t, disabled: n, children: r, icon: s, divider: o } = e,
    i = s && a.createElement("div", { className: ct.Icon }, a.createElement(Me, { tone: "subdued", source: s })),
    l = oe(ct.Action, o && ct.ActionDivider);
  return a.createElement(
    It.Provider,
    { value: !0 },
    a.createElement(wn, e, a.createElement("div", { className: l }, a.createElement(Ct, { selected: t, disabled: n }, i, r)))
  );
}
let Ee;
(function (e) {
  (e.FirstSelected = "FIRST_SELECTED"), (e.First = "FIRST"), (e.None = "NONE");
})(Ee || (Ee = {}));
const Fa = "[data-listbox-option]",
  ut = "data-listbox-option-value",
  Da = "data-listbox-option-action",
  Wt = "data-focused";
function j({
  children: e,
  autoSelection: t = Ee.FirstSelected,
  enableKeyboardControl: n,
  accessibilityLabel: r,
  customListId: s,
  onSelect: o,
  onActiveOptionChange: i,
}) {
  const [l, c] = d.useState(),
    [u, f] = d.useState(),
    [m, p] = d.useState(!1),
    [g, E] = d.useState([]),
    { value: v, setTrue: h, setFalse: P } = on(!!n),
    A = d.useId(),
    b = s || A,
    y = d.useRef(null),
    I = d.useRef(null),
    {
      listboxId: k,
      textFieldLabelId: x,
      textFieldFocused: C,
      willLoadMoreOptions: T,
      setActiveOptionId: _,
      setListboxId: D,
      onOptionSelected: M,
      onKeyToBottom: w,
    } = Ia(),
    O = !!_;
  d.useEffect(() => {
    D && !k && D(b);
  }, [D, k, b]);
  const U = d.useCallback(() => (I.current ? [...new Set(I.current.querySelectorAll(Fa))] : []), []),
    R = d.useCallback(
      (S) => {
        const L = S.some((Q) => Q.getAttribute("aria-selected") === "true");
        let J = 0;
        const Z = S.find((Q, ue) => {
          const ae = Q.getAttribute("aria-disabled") !== "true";
          let X;
          return L && t === Ee.FirstSelected ? (X = Q.getAttribute("aria-selected") === "true" && ae) : (X = ae), X && (J = ue), X;
        });
        if (Z) return { element: Z, index: J };
      },
      [t]
    ),
    W = d.useCallback((S) => {
      const { current: L } = y;
      L && ka(S.element, L);
    }, []),
    z = ln(W, 50),
    re = d.useCallback(() => {
      if (w) return p(!0), Promise.resolve(w());
    }, [w]),
    G = d.useCallback(
      (S) => {
        if (!S) return f(void 0);
        u == null || u.element.removeAttribute(Wt),
          S.element.setAttribute(Wt, "true"),
          z(S),
          f(S),
          _ == null || _(S.domId),
          i == null || i(S.value, S.domId);
      },
      [u, _, i, z]
    ),
    se = d.useCallback(
      (S, L) => ({
        element: S,
        index: L,
        domId: S.id,
        value: S.getAttribute(ut) || "",
        disabled: S.getAttribute("aria-disabled") === "true",
        isAction: S.getAttribute(Da) === "true",
      }),
      []
    ),
    ie = d.useCallback(() => {
      let S;
      const L = U(),
        J = R(L);
      if (L.length === 0 && g.length > 0) {
        E(L), G();
        return;
      }
      if (J) {
        const { element: de, index: Pe } = J;
        S = se(de, Pe);
      }
      const Z = u !== void 0 && (S == null ? void 0 : S.domId) === (u == null ? void 0 : u.domId),
        Q =
          (u == null ? void 0 : u.isAction) &&
          (S == null ? void 0 : S.isAction) &&
          (S == null ? void 0 : S.value) !== (u == null ? void 0 : u.value),
        ue = g.map((de) => de.getAttribute(ut)),
        ae = L.map((de) => de.getAttribute(ut)),
        X = ae.length === ue.length && ae.every((de, Pe) => ue[Pe] === de),
        Ke = ue.length !== 0 && ae.length > ue.length && ue.every((de, Pe) => ae[Pe] === de);
      if (X) {
        Z && Q && (E(L), G(S));
        return;
      }
      if (Ke) {
        E(L);
        return;
      }
      if ((E(L), m)) {
        p(!1);
        return;
      }
      G(S);
    }, [m, g, u, R, U, se, G]);
  d.useEffect(() => {
    t !== Ee.None && !l && e && d.Children.count(e) > 0 && ie();
  }, [e, t, u, l, ie]),
    d.useEffect(() => {
      I.current && (y.current = I.current.closest(hr.selector));
    }, []),
    d.useEffect(() => {
      n && !v && h();
    }, [n, v, h]);
  const N = d.useCallback(
      (S) => {
        G(S), M && M(), o && o(S.value);
      },
      [G, o, M]
    ),
    Y = d.useCallback(
      (S, L, J) => {
        let Z;
        return J === "down" ? (S === L ? (Z = T ? S + 1 : 0) : (Z = S + 1)) : (Z = S === 0 ? L : S - 1), Z;
      },
      [T]
    ),
    B = d.useCallback(
      async (S) => {
        const L = g.length - 1;
        let J = (u == null ? void 0 : u.index) || 0,
          Z = 0,
          Q = u == null ? void 0 : u.element,
          ue = -1;
        if (!u && t === Ee.None) {
          const ae = U(),
            X = R(ae);
          return E(ae), { element: X == null ? void 0 : X.element, nextIndex: (X == null ? void 0 : X.index) || 0 };
        }
        for (; ue++ < L; ) {
          (Z = Y(J, L, S)), (Q = g[Z]);
          const ae = Z >= L,
            X = (Q == null ? void 0 : Q.getAttribute("aria-disabled")) === "true";
          if ((ae && T && (await re()), X)) {
            (J = Z), (Q = void 0);
            continue;
          }
          break;
        }
        return { element: Q, nextIndex: Z };
      },
      [t, g, u, T, Y, re, R, U]
    ),
    $ = d.useCallback(
      async (S, L) => {
        L.preventDefault();
        const { element: J, nextIndex: Z } = await B(S);
        if (!J) return;
        const Q = se(J, Z);
        G(Q);
      },
      [se, B, G]
    ),
    q = d.useCallback(
      (S) => {
        $("down", S);
      },
      [$]
    ),
    be = d.useCallback(
      (S) => {
        $("up", S);
      },
      [$]
    ),
    ge = d.useCallback(
      (S) => {
        S.preventDefault(), S.stopPropagation(), u && N(u);
      },
      [u, N]
    ),
    Ge = d.useCallback(() => {
      n || h();
    }, [n, h]),
    De = d.useCallback(
      (S) => {
        if ((S.stopPropagation(), v)) {
          const L = R(g);
          if (L) {
            const { element: J, index: Z } = L,
              Q = se(J, Z);
            G(Q);
          }
        }
        n || P();
      },
      [n, g, v, P, R, se, G]
    ),
    _e =
      v || C
        ? a.createElement(
            a.Fragment,
            null,
            a.createElement(ot, { keyEvent: "keydown", keyCode: it.DownArrow, handler: q }),
            a.createElement(ot, { keyEvent: "keydown", keyCode: it.UpArrow, handler: be }),
            a.createElement(ot, { keyEvent: "keydown", keyCode: it.Enter, handler: ge })
          )
        : null,
    ye = d.useMemo(() => ({ onOptionSelect: N, setLoading: c }), [N]);
  return a.createElement(
    a.Fragment,
    null,
    _e,
    a.createElement(te, { as: "span", visuallyHidden: !0 }, a.createElement("div", { "aria-live": "polite" }, l || null)),
    a.createElement(
      sn.Provider,
      { value: ye },
      a.createElement(
        br.Provider,
        { value: !0 },
        e
          ? a.createElement(
              "ul",
              {
                tabIndex: 0,
                role: "listbox",
                className: Pa.Listbox,
                "aria-label": O ? void 0 : r,
                "aria-labelledby": x,
                "aria-busy": !!l,
                "aria-activedescendant": u && u.domId,
                id: b,
                onFocus: O ? void 0 : Ge,
                onBlur: O ? void 0 : De,
                ref: I,
              },
              e
            )
          : null
      )
    )
  );
}
j.Option = wn;
j.TextOption = Ct;
j.Loading = xa;
j.Section = Ca;
j.Header = Ma;
j.Action = wa;
const _a = d.memo(function ({ label: t, value: n, disabled: r, media: s, selected: o, singleSelection: i }) {
  const l = oe(Xe.Media, r && Xe.disabledMedia, i && Xe.singleSelectionMedia),
    c = s ? a.createElement("div", { className: l }, s) : null,
    u = typeof t == "string" ? t : void 0;
  return a.createElement(
    j.Option,
    { accessibilityLabel: u, key: n, selected: o, value: n, disabled: r },
    a.createElement(j.TextOption, { selected: o, disabled: r }, a.createElement("div", { className: Xe.Content }, c, t))
  );
});
var Oa = { Listbox: "Polaris-Combobox__Listbox" };
function Ra({ value: e, id: t, type: n = "text", ariaAutocomplete: r = "list", onFocus: s, onBlur: o, onChange: i, ...l }) {
  const c = Aa(),
    {
      activeOptionId: u,
      listboxId: f,
      expanded: m,
      setTextFieldFocused: p,
      setTextFieldLabelId: g,
      onTextFieldFocus: E,
      onTextFieldChange: v,
      onTextFieldBlur: h,
    } = c,
    P = d.useId(),
    A = d.useMemo(() => t || P, [P, t]),
    b = d.useMemo(() => vr(t || P), [P, t]);
  d.useEffect(() => {
    g && g(b);
  }, [b, g]);
  const y = d.useCallback(
      (x) => {
        s && s(x), E && E(), p && p(!0);
      },
      [s, E, p]
    ),
    I = d.useCallback(
      (x) => {
        o && o(x), h && h(), p && p(!1);
      },
      [o, h, p]
    ),
    k = d.useCallback(
      (x, C) => {
        i && i(x, C), v && v(x);
      },
      [i, v]
    );
  return a.createElement(
    ze,
    Object.assign({}, l, {
      value: e,
      id: A,
      type: n,
      ariaAutocomplete: r,
      "aria-haspopup": "listbox",
      ariaActiveDescendant: u,
      ariaControls: f,
      role: "combobox",
      ariaExpanded: m,
      onFocus: y,
      onBlur: I,
      onChange: k,
    })
  );
}
function he({
  activator: e,
  allowMultiple: t,
  children: n,
  preferredPosition: r = "below",
  willLoadMoreOptions: s,
  height: o,
  onScrolledToBottom: i,
  onClose: l,
}) {
  const [c, u] = d.useState(!1),
    [f, m] = d.useState(),
    [p, g] = d.useState(),
    [E, v] = d.useState(),
    [h, P] = d.useState(!1),
    A = !c,
    b = c && d.Children.count(n) > 0,
    y = d.useRef(null),
    I = d.useCallback(() => {
      u(!1), l == null || l(), m(void 0);
    }, [l]),
    k = d.useCallback(() => {
      u(!0), m(void 0);
    }, []),
    x = d.useCallback(() => {
      var O;
      if (!t) {
        I(), m(void 0);
        return;
      }
      (O = y.current) == null || O.forceUpdatePosition();
    }, [t, I]),
    C = d.useCallback(() => {
      A && k();
    }, [A, k]),
    T = d.useCallback(() => {
      A && k();
    }, [A, k]),
    _ = d.useCallback(() => {
      c && I();
    }, [c, I]),
    D = d.useMemo(
      () => ({
        activeOptionId: f,
        expanded: c,
        listboxId: E,
        setTextFieldFocused: P,
        setTextFieldLabelId: g,
        onTextFieldFocus: C,
        onTextFieldChange: T,
        onTextFieldBlur: _,
      }),
      [f, c, E, P, g, C, T, _]
    ),
    M = d.useMemo(() => ({ allowMultiple: t }), [t]),
    w = d.useMemo(
      () => ({
        listboxId: E,
        textFieldLabelId: p,
        textFieldFocused: h,
        willLoadMoreOptions: s,
        onOptionSelected: x,
        setActiveOptionId: m,
        setListboxId: v,
        onKeyToBottom: i,
      }),
      [E, p, h, s, x, m, v, i]
    );
  return a.createElement(
    He,
    {
      ref: y,
      active: b,
      activator: a.createElement(In.Provider, { value: D }, e),
      autofocusTarget: "none",
      preventFocusOnClose: !0,
      fullWidth: !0,
      preferInputActivator: !1,
      preferredPosition: r,
      onClose: I,
    },
    d.Children.count(n) > 0
      ? a.createElement(
          He.Pane,
          { onScrolledToBottom: i, height: o },
          a.createElement(
            kn.Provider,
            { value: w },
            a.createElement(xn.Provider, { value: M }, a.createElement("div", { className: Oa.Listbox }, n))
          )
        )
      : null
  );
}
he.TextField = Ra;
var ce = {
  ActionContainer: "Polaris-Autocomplete-MappedAction__ActionContainer",
  Action: "Polaris-Autocomplete-MappedAction__Action",
  destructive: "Polaris-Autocomplete-MappedAction--destructive",
  selected: "Polaris-Autocomplete-MappedAction--selected",
  disabled: "Polaris-Autocomplete-MappedAction--disabled",
  Prefix: "Polaris-Autocomplete-MappedAction__Prefix",
  Suffix: "Polaris-Autocomplete-MappedAction__Suffix",
  Content: "Polaris-Autocomplete-MappedAction__Content",
  Text: "Polaris-Autocomplete-MappedAction__Text",
};
function Na({
  active: e,
  content: t,
  disabled: n,
  icon: r,
  image: s,
  prefix: o,
  suffix: i,
  ellipsis: l,
  role: c,
  url: u,
  external: f,
  onAction: m,
  destructive: p,
  badge: g,
  helpText: E,
  wrapOverflow: v = !1,
}) {
  const h = we();
  let P = null;
  o
    ? (P = a.createElement("div", { className: ce.Prefix }, o))
    : r
    ? (P = a.createElement("div", { className: ce.Prefix }, a.createElement(Me, { source: r })))
    : s && (P = a.createElement("div", { role: "presentation", className: ce.Prefix, style: { backgroundImage: `url(${s}` } }));
  const A = g && a.createElement("span", { className: ce.Suffix }, a.createElement(Er, { tone: g.tone }, g.content)),
    b = i && a.createElement("span", { className: ce.Suffix }, i),
    y = l && t ? h.translate("Polaris.Autocomplete.ellipsis", { content: t }) : t,
    I = a.createElement(
      "div",
      { className: ce.Text },
      a.createElement(te, { as: "p", variant: "bodyMd", breakWord: v }, y),
      E ? a.createElement(te, { as: "p", variant: "bodyMd", tone: "subdued" }, E) : null
    ),
    k = d.useMemo(() => ({ role: c, url: u, external: f, onAction: m, destructive: p }), [c, u, f, m, p]),
    x = oe(ce.Action, n && ce.disabled, p && ce.destructive, e && ce.selected);
  return a.createElement(
    Mn.Provider,
    { value: k },
    a.createElement(
      "div",
      { className: ce.ActionContainer },
      a.createElement(
        j.Action,
        { selected: e, disabled: n, value: t || "" },
        a.createElement("div", { className: x }, a.createElement("div", { className: ce.Content }, P, I, A, b))
      )
    )
  );
}
const Pt = function ({
  options: t,
  selected: n,
  textField: r,
  preferredPosition: s,
  listTitle: o,
  allowMultiple: i,
  loading: l,
  actionBefore: c,
  willLoadMoreResults: u,
  emptyState: f,
  onSelect: m,
  onLoadMoreResults: p,
}) {
  const g = we(),
    E = d.useCallback(
      (I) =>
        I.map((k) =>
          a.createElement(_a, Object.assign({ key: k.id || k.value }, k, { selected: n.includes(k.value), singleSelection: !i }))
        ),
      [n, i]
    ),
    v = d.useMemo(() => {
      const I = l && !u ? [] : t;
      if (va(I)) {
        if (I.every(({ options: T }) => T.length === 0)) return null;
        const C = I.map(({ options: T, title: _ }) => {
          if (T.length === 0) return null;
          const D = E(T);
          return a.createElement(j.Section, { divider: !1, title: a.createElement(j.Header, null, _), key: _ }, D);
        });
        return a.createElement("div", { className: Ea.SectionWrapper }, C);
      }
      const k = I.length > 0 ? E(I) : null;
      return o ? a.createElement(j.Section, { divider: !1, title: a.createElement(j.Header, null, o) }, k) : k;
    }, [o, l, t, u, E]),
    h = l ? a.createElement(j.Loading, { accessibilityLabel: g.translate("Polaris.Autocomplete.spinnerAccessibilityLabel") }) : null,
    P = d.useCallback(
      (I) => {
        if (c && I === c.content) {
          c.onAction && c.onAction();
          return;
        }
        i ? (n.includes(I) ? m(n.filter((k) => k !== I)) : m([...n, I])) : m([I]);
      },
      [i, m, n, c]
    ),
    A = c && a.createElement(Na, c),
    b = f && t.length < 1 && !l && a.createElement("div", { role: "status" }, f),
    y = c ? Ee.First : void 0;
  return a.createElement(
    he,
    { activator: r, allowMultiple: i, onScrolledToBottom: p, preferredPosition: s, willLoadMoreOptions: u },
    A || v || h || b ? a.createElement(j, { autoSelection: y, onSelect: P }, A, v && (!l || u) ? v : null, h, b) : null
  );
};
Pt.TextField = he.TextField;
const La = 7;
function $a(e, t, n = 0) {
  const r = new Date(t, e, 1),
    s = r.getDay(),
    o = [[]];
  let i = o[0],
    l = r;
  const c = Fn(n);
  for (let u = 0; u < c.indexOf(s); u++) i.push(null);
  for (; l.getMonth() === e; ) i.length === La && ((i = []), o.push(i)), i.push(l), (l = new Date(t, e, l.getDate() + 1));
  for (; i.length < 7; ) i.push(null);
  return o;
}
function qa(e, t) {
  if (e == null) return !1;
  const { start: n, end: r } = t;
  return !!(n && e > n && r && e < r);
}
function Ba(e, t) {
  if (e == null) return !1;
  const { start: n, end: r } = t;
  return !!((n && me(n, e)) || (r && me(r, e)));
}
function me(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function Va(e, t) {
  if (e == null) return { start: t, end: t };
  const { start: n, end: r } = e;
  return r && (We(n, r) || ke(n, r))
    ? { start: t, end: t }
    : n
    ? ke(t, n)
      ? { start: t, end: t }
      : { start: n, end: t }
    : r
    ? ke(t, r)
      ? { start: t, end: r }
      : { start: n || r, end: t }
    : { start: t, end: t };
}
function zt(e) {
  return e === 11 ? 0 : e + 1;
}
function Zt(e, t) {
  return e === 11 ? t + 1 : t;
}
function Ua(e) {
  return e === 0 ? 11 : e - 1;
}
function Ha(e, t) {
  return e === 0 ? t - 1 : t;
}
function We(e, t) {
  return e.getTime() > t.getTime();
}
function ke(e, t) {
  return e.getTime() < t.getTime();
}
function Be(e, t) {
  return t.some((n) => e.getTime() === n.getTime());
}
const ja = [0, 1, 2, 3, 4, 5, 6];
function Fn(e) {
  const t = [...ja];
  return [...t.splice(e), ...t];
}
function Ve(e) {
  switch (e) {
    case 0:
      return "january";
    case 1:
      return "february";
    case 2:
      return "march";
    case 3:
      return "april";
    case 4:
      return "may";
    case 5:
      return "june";
    case 6:
      return "july";
    case 7:
      return "august";
    case 8:
      return "september";
    case 9:
      return "october";
    case 10:
      return "november";
    case 11:
      return "december";
  }
}
function Gt(e) {
  switch (e) {
    case 0:
      return "sunday";
    case 1:
      return "monday";
    case 2:
      return "tuesday";
    case 3:
      return "wednesday";
    case 4:
      return "thursday";
    case 5:
      return "friday";
    case 6:
      return "saturday";
  }
}
var H = {
  DatePicker: "Polaris-DatePicker",
  MonthLayout: "Polaris-DatePicker__MonthLayout",
  MonthContainer: "Polaris-DatePicker__MonthContainer",
  Month: "Polaris-DatePicker__Month",
  DayCell: "Polaris-DatePicker__DayCell",
  "DayCell-inRange": "Polaris-DatePicker__DayCell--inRange",
  Day: "Polaris-DatePicker__Day",
  "Day-inRange": "Polaris-DatePicker__Day--inRange",
  "Day-selected": "Polaris-DatePicker__Day--selected",
  "Day-disabled": "Polaris-DatePicker__Day--disabled",
  EmptyDayCell: "Polaris-DatePicker__EmptyDayCell",
  Weekday: "Polaris-DatePicker__Weekday",
  Header: "Polaris-DatePicker__Header",
  Title: "Polaris-DatePicker__Title",
  "Day-firstInRange": "Polaris-DatePicker__Day--firstInRange",
  "Day-hasRange": "Polaris-DatePicker__Day--hasRange",
  "Day-hoverRight": "Polaris-DatePicker__Day--hoverRight",
  "Day-lastInRange": "Polaris-DatePicker__Day--lastInRange",
  Week: "Polaris-DatePicker__Week",
};
const Wa = d.memo(function ({ label: t, title: n, current: r }) {
    return a.createElement(
      "th",
      { "aria-label": t, scope: "col", className: H.Weekday },
      a.createElement(
        te,
        { as: "span", variant: "bodySm", alignment: "center", fontWeight: r ? "bold" : "regular", tone: r ? void 0 : "subdued" },
        n
      )
    );
  }),
  Kt = d.memo(function ({
    day: t,
    focused: n,
    onClick: r,
    onHover: s = dt,
    onFocus: o = dt,
    selected: i,
    inRange: l,
    inHoveringRange: c,
    disabled: u,
    lastDayOfMonth: f,
    isLastSelectedDay: m,
    isFirstSelectedDay: p,
    isHoveringRight: g,
    rangeIsDifferent: E,
    weekday: v,
    selectedAccessibilityLabelPrefix: h,
  }) {
    const P = we(),
      A = d.useRef(null),
      b = f || t;
    if (
      (d.useEffect(() => {
        n && A.current && A.current.focus();
      }, [n]),
      !t)
    )
      return a.createElement("td", { className: H.EmptyDayCell, onMouseOver: () => s(b) });
    const y = r && !u ? r.bind(null, t) : dt,
      I = me(new Date(), t),
      k = oe(
        H.DayCell,
        i && H["DayCell-selected"],
        (l || c) && !u && H["DayCell-inRange"],
        m && H["DayCell-lastInRange"],
        p && H["DayCell-firstInRange"],
        g && H["DayCell-hoverRight"],
        E && H["DayCell-hasRange"]
      ),
      x = oe(
        H.Day,
        i && H["Day-selected"],
        u && H["Day-disabled"],
        (l || c) && !u && H["Day-inRange"],
        m && H["Day-lastInRange"],
        p && H["Day-firstInRange"],
        g && H["Day-hoverRight"],
        E && H["Day-hasRange"]
      ),
      C = t.getDate(),
      T = (n || i || I || C === 1) && !u ? 0 : -1,
      _ = [
        i && h ? `${h} ` : "",
        `${I ? P.translate("Polaris.DatePicker.today") : ""}`,
        `${v || ""} `,
        `${P.translate(`Polaris.DatePicker.months.${Ve(t.getMonth())}`)} `,
        `${C} `,
        `${t.getFullYear()}`,
      ].join("");
    return a.createElement(
      "td",
      { className: k },
      a.createElement(
        "button",
        {
          onFocus: () => o(t),
          type: "button",
          ref: A,
          tabIndex: T,
          className: x,
          onMouseOver: () => s(b),
          onClick: y,
          "aria-label": _,
          "aria-disabled": u,
          "aria-pressed": i,
        },
        a.createElement(te, { as: "span", variant: "bodySm", alignment: "center", fontWeight: I ? "bold" : "regular" }, C)
      )
    );
  });
function dt() {}
function Yt({
  focusedDate: e,
  selected: t,
  hoverDate: n,
  disableDatesBefore: r,
  disableDatesAfter: s,
  disableSpecificDates: o,
  allowRange: i,
  onChange: l = ft,
  onHover: c = ft,
  onFocus: u = ft,
  month: f,
  year: m,
  weekStartsOn: p,
  accessibilityLabelPrefixes: g,
}) {
  const E = we(),
    v = i ? za : () => !1,
    h = new Date(),
    P = h.getMonth() === f && h.getFullYear() === m,
    A = d.useMemo(() => $a(f, m, p), [f, p, m]),
    b = Fn(p).map((T) =>
      a.createElement(Wa, {
        key: T,
        title: E.translate(`Polaris.DatePicker.daysAbbreviated.${Gt(T)}`),
        label: C(T),
        current: P && new Date().getDay() === T,
      })
    ),
    y = d.useCallback(
      (T) => {
        l(Va(i ? t : void 0, T));
      },
      [i, l, t]
    ),
    I = d.useMemo(() => new Date(m, f + 1, 0), [f, m]);
  function k(T, _) {
    if (T == null) return a.createElement(Kt, { key: _, onHover: c, lastDayOfMonth: I });
    const D = (r && ke(T, r)) || (s && We(T, s)) || (o && Be(T, o)),
      M = i && t && Ga(T, t),
      w = i && t && ((!me(t.start, t.end) && Za(T, t)) || (n && me(t.start, t.end) && We(n, t.start) && me(T, n) && !M)),
      O = !(t && me(t.start, t.end)),
      U = n && ke(T, n),
      [R, W] = g;
    let z;
    return (
      (i && M) || (!i && R) ? (z = R) : i && w && (z = W),
      a.createElement(Kt, {
        selectedAccessibilityLabelPrefix: z,
        weekday: C(_),
        focused: e != null && me(T, e),
        day: T,
        key: _,
        onFocus: u,
        onClick: y,
        onHover: c,
        selected: t != null && Ba(T, t),
        inRange: t != null && qa(T, t),
        disabled: D,
        inHoveringRange: t != null && n != null && v(T, t, n),
        isLastSelectedDay: w,
        isFirstSelectedDay: M,
        isHoveringRight: U,
        rangeIsDifferent: O,
      })
    );
  }
  const x = A.map((T, _) => a.createElement("tr", { className: H.Week, key: _ }, T.map(k)));
  return a.createElement(
    "div",
    { className: H.MonthContainer },
    a.createElement(
      "table",
      { role: "grid", className: H.Month },
      a.createElement(
        "caption",
        { className: H.Title },
        a.createElement(
          te,
          { as: "span", variant: "bodyMd", alignment: "center", fontWeight: P ? "bold" : "medium" },
          E.translate(`Polaris.DatePicker.months.${Ve(f)}`),
          " ",
          m
        )
      ),
      a.createElement("thead", null, a.createElement("tr", { className: H.WeekHeadings }, b)),
      a.createElement("tbody", null, x)
    )
  );
  function C(T) {
    return E.translate(`Polaris.DatePicker.days.${Gt(T)}`);
  }
}
function ft() {}
function za(e, t, n) {
  if (e == null) return !1;
  const { start: r, end: s } = t;
  return !!(me(r, s) && e > r && e <= n);
}
function Za(e, t) {
  if (e == null) return !1;
  const { end: n } = t;
  return !!(n && me(n, e));
}
function Ga(e, t) {
  if (e == null) return !1;
  const { start: n } = t;
  return !!(n && me(n, e));
}
function Ka({
  id: e,
  selected: t,
  month: n,
  year: r,
  allowRange: s,
  multiMonth: o,
  disableDatesBefore: i,
  disableDatesAfter: l,
  disableSpecificDates: c,
  weekStartsOn: u = 0,
  dayAccessibilityLabelPrefix: f,
  onMonthChange: m,
  onChange: p = Ya,
}) {
  const g = we(),
    [E, v] = d.useState(void 0),
    [h, P] = d.useState(void 0);
  d.useEffect(() => {
    P(void 0);
  }, [t]);
  const A = d.useCallback((N) => {
      P(N);
    }, []),
    b = d.useCallback(
      (N) => {
        m && m(N.getMonth(), N.getFullYear()), v(N), P(N);
      },
      [m]
    ),
    y = d.useCallback(
      (N) => {
        const { end: Y } = N;
        v(Y), P(new Date(Y)), p(N);
      },
      [p]
    ),
    I = d.useCallback(
      (N, Y) => {
        m && (P(void 0), m(N, Y));
      },
      [m]
    ),
    k = d.useCallback((N) => {
      v(N);
    }, []),
    x = d.useCallback(
      (N) => {
        const { key: Y } = N,
          B = mt(t),
          $ = h || (B && B.start);
        if ($ != null) {
          if (Y === "ArrowUp") {
            const q = new Date($);
            q.setDate($.getDate() - 7), (i && ke(q, i)) || (c && Be(q, c)) || b(q);
          }
          if (Y === "ArrowDown") {
            const q = new Date($);
            q.setDate($.getDate() + 7), (l && We(q, l)) || (c && Be(q, c)) || b(q);
          }
          if (Y === "ArrowRight") {
            const q = new Date($);
            q.setDate($.getDate() + 1), (l && We(q, l)) || (c && Be(q, c)) || b(q);
          }
          if (Y === "ArrowLeft") {
            const q = new Date($);
            q.setDate($.getDate() - 1), (i && ke(q, i)) || (c && Be(q, c)) || b(q);
          }
        }
      },
      [l, i, c, h, t, b]
    ),
    C = Zt(n, r),
    T = zt(n),
    _ = Zt(T, C),
    D = zt(T),
    M = Ha(n, r),
    w = Ua(n),
    O = g.translate(`Polaris.DatePicker.months.${Ve(w)}`),
    U = o ? g.translate(`Polaris.DatePicker.months.${Ve(D)}`) : g.translate(`Polaris.DatePicker.months.${Ve(T)}`),
    R = o ? _ : C,
    W = d.useMemo(() => mt(t), [t]),
    z = s ? g.translate("Polaris.DatePicker.start") : f,
    re = g.translate("Polaris.DatePicker.end"),
    G = [z, re],
    se = o
      ? a.createElement(Yt, {
          onFocus: A,
          focusedDate: h,
          month: T,
          year: C,
          selected: W,
          hoverDate: E,
          onChange: y,
          onHover: k,
          disableDatesBefore: i,
          disableDatesAfter: l,
          disableSpecificDates: c,
          allowRange: s,
          weekStartsOn: u,
          accessibilityLabelPrefixes: G,
        })
      : null,
    ie = oe(H.DatePicker);
  return a.createElement(
    "div",
    { id: e, className: ie, onKeyDown: Ja, onKeyUp: x },
    a.createElement(
      "div",
      { className: H.Header },
      a.createElement(Se, {
        variant: "tertiary",
        icon: vn,
        accessibilityLabel: g.translate("Polaris.DatePicker.previousMonth", { previousMonthName: O, showPreviousYear: M }),
        onClick: () => I(w, M),
      }),
      a.createElement(Se, {
        variant: "tertiary",
        icon: En,
        accessibilityLabel: g.translate("Polaris.DatePicker.nextMonth", { nextMonth: U, nextYear: R }),
        onClick: () => I(T, C),
      })
    ),
    a.createElement(
      "div",
      { className: H.MonthLayout },
      a.createElement(Yt, {
        onFocus: A,
        focusedDate: h,
        month: n,
        year: r,
        selected: mt(t),
        hoverDate: E,
        onChange: y,
        onHover: k,
        disableDatesBefore: i,
        disableDatesAfter: l,
        disableSpecificDates: c,
        allowRange: s,
        weekStartsOn: u,
        accessibilityLabelPrefixes: G,
      }),
      se
    )
  );
}
function Ya() {}
function Ja(e) {
  const { key: t } = e;
  (t === "ArrowUp" || t === "ArrowDown" || t === "ArrowLeft" || t === "ArrowRight") && (e.preventDefault(), e.stopPropagation());
}
function mt(e) {
  return e instanceof Date ? { start: e, end: e } : e;
}
function Dn(e = "") {
  const t = e.toLowerCase();
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const Qa = ["dragover", "dragenter", "drop"];
function Xa(e, t) {
  return e.type === "application/x-moz-file" || es(e, t);
}
function Jt(e) {
  if (ts(e) && e.dataTransfer) {
    const t = e.dataTransfer;
    if (t.files && t.files.length) return Array.from(t.files);
    if (t.items && t.items.length) return Array.from(t.items);
  } else if (ns(e) && e.target.files) return Array.from(e.target.files);
  return [];
}
function es(e, t) {
  if (e && t) {
    const n = e.name || "",
      r = e.type || "",
      s = r.replace(/\/.*$/, "");
    return (Array.isArray(t) ? t : t.split(",")).some((i) => {
      const l = i.trim();
      return l.startsWith(".") ? n.toLowerCase().endsWith(l.toLowerCase()) : l.endsWith("/*") ? s === l.replace(/\/.*$/, "") : r === l;
    });
  }
  return !0;
}
function ts(e) {
  return Qa.indexOf(e.type) > 0;
}
function ns(e) {
  return Object.prototype.hasOwnProperty.call(e, "target");
}
const _n = !0;
function On(e) {
  return e ? "allowMultiple" : "single";
}
const Rn = d.createContext({ disabled: !1, focused: !1, size: "extraLarge", type: "file", measuring: !1, allowMultiple: _n });
var fe = {
    DropZone: "Polaris-DropZone",
    focused: "Polaris-DropZone--focused",
    noOutline: "Polaris-DropZone--noOutline",
    hasOutline: "Polaris-DropZone--hasOutline",
    isDisabled: "Polaris-DropZone--isDisabled",
    isDragging: "Polaris-DropZone--isDragging",
    sizeLarge: "Polaris-DropZone--sizeLarge",
    sizeMedium: "Polaris-DropZone--sizeMedium",
    sizeSmall: "Polaris-DropZone--sizeSmall",
    measuring: "Polaris-DropZone--measuring",
    Container: "Polaris-DropZone__Container",
    Overlay: "Polaris-DropZone__Overlay",
    hasError: "Polaris-DropZone--hasError",
  },
  Oe = {
    FileUpload: "Polaris-DropZone-FileUpload",
    large: "Polaris-DropZone-FileUpload--large",
    small: "Polaris-DropZone-FileUpload--small",
    ActionTitle: "Polaris-DropZone-FileUpload__ActionTitle",
    "ActionTitle-disabled": "Polaris-DropZone-FileUpload__ActionTitle--disabled",
    "ActionTitle-focused": "Polaris-DropZone-FileUpload__ActionTitle--focused",
    UploadIcon: "Polaris-DropZone-FileUpload__UploadIcon",
    disabled: "Polaris-DropZone-FileUpload--disabled",
  };
function rs(e) {
  const t = we(),
    { size: n, measuring: r, type: s, disabled: o, allowMultiple: i } = d.useContext(Rn),
    l = Dn(s),
    c = On(i),
    { actionTitle: u = t.translate(`Polaris.DropZone.${c}.actionTitle${l}`), actionHint: f } = e,
    m = a.createElement(Se, { disabled: o }, u),
    p = oe(Oe.FileUpload, r && Oe.measuring, n === "large" && Oe.large, n === "small" && Oe.small),
    g = f && a.createElement(te, { variant: "bodySm", as: "p", tone: "subdued" }, f);
  let E;
  switch (n) {
    case "large":
    case "medium":
      E = a.createElement(kt, { inlineAlign: "center", gap: "200" }, m, g);
      break;
    case "small":
      E = a.createElement("div", { className: oe(Oe.UploadIcon, o && Oe.disabled) }, a.createElement(Me, { source: St }));
      break;
  }
  return a.createElement("div", { className: p }, E);
}
const At = function ({
  dropOnPage: t,
  label: n,
  labelAction: r,
  labelHidden: s,
  children: o,
  disabled: i = !1,
  outline: l = !0,
  accept: c,
  active: u,
  overlay: f = !0,
  allowMultiple: m = _n,
  overlayText: p,
  errorOverlayText: g,
  id: E,
  type: v = "file",
  onClick: h,
  error: P,
  openFileDialog: A,
  variableHeight: b,
  onFileDialogClose: y,
  customValidator: I,
  onDrop: k,
  onDropAccepted: x,
  onDropRejected: C,
  onDragEnter: T,
  onDragOver: _,
  onDragLeave: D,
}) {
  const M = d.useRef(null),
    w = d.useRef(null),
    O = d.useRef([]),
    U = d.useCallback(
      ln(
        () => {
          if (!M.current) return;
          if (b) {
            $(!1);
            return;
          }
          let V = "large";
          const ee = M.current.getBoundingClientRect().width;
          ee < 100 ? (V = "small") : ee < 160 && (V = "medium"), Y(V), B && $(!1);
        },
        50,
        { trailing: !0 }
      ),
      []
    ),
    [R, W] = d.useState(!1),
    [z, re] = d.useState(!1),
    { value: G, setTrue: se, setFalse: ie } = on(!1),
    [N, Y] = d.useState("large"),
    [B, $] = d.useState(!0),
    q = we(),
    be = d.useCallback(
      (V) => {
        const ee = [],
          le = [];
        return (
          Array.from(V).forEach((ve) => {
            !Xa(ve, c) || (I && !I(ve)) ? le.push(ve) : ee.push(ve);
          }),
          m || (ee.splice(1, ee.length), le.push(...ee.slice(1))),
          { files: V, acceptedFiles: ee, rejectedFiles: le }
        );
      },
      [c, m, I]
    ),
    ge = d.useCallback(
      (V) => {
        if ((et(V), i)) return;
        const ee = Jt(V),
          { files: le, acceptedFiles: ve, rejectedFiles: Ye } = be(ee);
        (O.current = []),
          W(!1),
          re(Ye.length > 0),
          k && k(le, ve, Ye),
          x && ve.length && x(ve),
          C && Ye.length && C(Ye),
          V.target && "value" in V.target && (V.target.value = "");
      },
      [i, be, k, x, C]
    ),
    Ge = d.useCallback(
      (V) => {
        if ((et(V), i)) return;
        const ee = Jt(V);
        if ((V.target && !O.current.includes(V.target) && O.current.push(V.target), R)) return;
        const { rejectedFiles: le } = be(ee);
        W(!0), re(le.length > 0), T && T();
      },
      [i, R, be, T]
    ),
    De = d.useCallback(
      (V) => {
        et(V), !i && _ && _();
      },
      [i, _]
    ),
    _e = d.useCallback(
      (V) => {
        V.preventDefault(),
          !i &&
            ((O.current = O.current.filter((ee) => {
              const le = t && !lt ? document : M.current;
              return ee !== V.target && le && le.contains(ee);
            })),
            !(O.current.length > 0) && (W(!1), re(!1), D && D()));
      },
      [t, i, D]
    ),
    ye = t && !lt ? document : M.current;
  qe("drop", ge, ye),
    qe("dragover", De, ye),
    qe("dragenter", Ge, ye),
    qe("dragleave", _e, ye),
    qe("resize", U, lt ? null : window),
    Pr(() => {
      U();
    });
  const S = d.useId(),
    L = E ?? S,
    J = Dn(v),
    Z = On(m),
    Q = p === void 0 ? q.translate(`Polaris.DropZone.${Z}.overlayText${J}`) : p,
    ue = g === void 0 ? q.translate(`Polaris.DropZone.errorOverlayText${J}`) : g,
    ae = n || q.translate(`Polaris.DropZone.${Z}.label${J}`),
    X = n ? s : !0,
    Ke = oe(
      fe.DropZone,
      l && fe.hasOutline,
      !l && fe.noOutline,
      G && fe.focused,
      (u || R) && fe.isDragging,
      i && fe.isDisabled,
      (z || P) && fe.hasError,
      !b && fe[cn("size", N)],
      B && fe.measuring
    ),
    de = (u || R) && !z && !P && f && Lt(St, Q),
    Pe = R && (z || P) && Lt(Ir, ue, "critical"),
    fr = d.useMemo(() => ({ disabled: i, focused: G, size: N, type: v || "file", measuring: B, allowMultiple: m }), [i, G, B, N, v, m]),
    st = d.useCallback(() => {
      w.current && w.current.click();
    }, [w]),
    Nt = d.useCallback(() => {
      st(), y == null || y();
    }, [st, y]);
  function Lt(V, ee, le) {
    return a.createElement(
      "div",
      { className: fe.Overlay },
      a.createElement(
        kt,
        { gap: "200", inlineAlign: "center" },
        N === "small" && a.createElement(Me, { source: V, tone: le }),
        (N === "medium" || N === "large") && a.createElement(te, { variant: "bodySm", as: "p", fontWeight: "bold" }, ee)
      )
    );
  }
  function mr(V) {
    if (!i) return h ? h(V) : st();
  }
  return (
    d.useEffect(() => {
      A && Nt();
    }, [A, Nt]),
    a.createElement(
      Rn.Provider,
      { value: fr },
      a.createElement(
        Ar,
        { id: L, label: ae, action: r, labelHidden: X },
        a.createElement(
          "div",
          { ref: M, className: Ke, "aria-disabled": i, onClick: mr, onDragStart: et },
          de,
          Pe,
          a.createElement(
            te,
            { variant: "bodySm", as: "span", visuallyHidden: !0 },
            a.createElement("input", {
              id: L,
              accept: c,
              disabled: i,
              multiple: m,
              onChange: ge,
              onFocus: se,
              onBlur: ie,
              type: "file",
              ref: w,
              autoComplete: "off",
            })
          ),
          a.createElement("div", { className: fe.Container }, o)
        )
      )
    )
  );
};
function et(e) {
  e.preventDefault(), e.stopPropagation();
}
At.FileUpload = rs;
var Qt = {
  DisplayText: "Polaris-SkeletonDisplayText__DisplayText",
  sizeSmall: "Polaris-SkeletonDisplayText--sizeSmall",
  sizeMedium: "Polaris-SkeletonDisplayText--sizeMedium",
  sizeLarge: "Polaris-SkeletonDisplayText--sizeLarge",
  sizeExtraLarge: "Polaris-SkeletonDisplayText--sizeExtraLarge",
};
function as({ size: e = "medium", maxWidth: t }) {
  const n = oe(Qt.DisplayText, e && Qt[cn("size", e)]),
    r = { "--pc-skeleton-display-text-max-width": t ?? void 0 };
  return a.createElement("div", { className: n, style: kr(r) });
}
const ss = (e, t, n) => {
    const r = un(n),
      s = d.useMemo(
        () => xr(e.operationName, e.findByVariableName, t, e.defaultSelection, e.modelApiIdentifier, r, e.namespace),
        [e, t, r]
      ),
      [o, i] = dn(fn(s, n));
    return [
      d.useMemo(() => {
        const c = xt([e.operationName], e.namespace);
        let u = o.data,
          f = [];
        if (u) {
          const p = Tt(o.data, c);
          p && ((f = Tr(o, p)), (u = f[0]));
        }
        let m = Ne.forMaybeCombinedError(o.error);
        return (
          m ||
            (f.length > 1
              ? (m = Ne.forClientSideError(Sr(e.modelApiIdentifier, e.findByVariableName, t)))
              : o.data &&
                !f[0] &&
                (m = Ne.forClientSideError(new Cr(`${e.modelApiIdentifier} record with ${e.findByVariableName}=${t} not found`)))),
          { ...o, data: u, error: m }
        );
      }, [o, e, t]),
      i,
    ];
  },
  os = (e, t, n) => {
    const r = un(n),
      s = d.useMemo(
        () => Mr(e.findOne.operationName, t, e.findOne.defaultSelection, e.findOne.modelApiIdentifier, r, e.findOne.namespace),
        [e, t, r]
      ),
      [o, i] = dn(fn(s, n));
    return [
      d.useMemo(() => {
        const c = xt([e.findOne.operationName], e.findOne.namespace);
        let u = o.data && Tt(o.data, c);
        u && (u = wr(o, u));
        const f = Ne.errorIfDataAbsent(o, c, n == null ? void 0 : n.pause);
        return { ...o, data: u, error: f };
      }, [e.findOne.operationName, o, n == null ? void 0 : n.pause]),
      i,
    ];
  },
  pt = [{ fetching: !1 }, () => {}],
  is = (e, t, n) => {
    if (!e || !t) return pt;
    if (typeof t == "string") return os(e, t, n);
    if (typeof t == "object" && !Array.isArray(t) && Object.keys(t).length) {
      const [s, o] = Object.entries(t)[0],
        i = `findBy${Fr(s)}`;
      if (!(i in e)) {
        if (n.throwOnInvalidFindByObject === void 0 || n.throwOnInvalidFindByObject)
          throw new Error(`Invalid findBy object: ${JSON.stringify(t)}. ${i} is not a valid findBy operation for this model.`);
        return pt;
      }
      const l = e[i];
      return ss(l, o, n);
    }
    return pt;
  },
  Nn = ["id", "createdAt", "updatedAt", "__typename"],
  Xt = (e) => {
    const t = { ...e };
    for (const n of Nn) delete t[n];
    return t;
  },
  en = (e) => {
    const { modelApiIdentifier: t, data: n, defaultValues: r } = e;
    ls(n);
    const s = Ln(t, n);
    return e.hasAmbiguousDefaultValues ? { ...r, [t]: s } : { ...r, ...s, [t]: s };
  },
  ls = (e) => {
    for (const t of Object.keys(e))
      Array.isArray(e[t]) &&
        e[t].length &&
        (e[t] = e[t].map((r) => (typeof r == "object" && "__typename" in r && r.__typename === "Role" && "key" in r ? r.key : r)));
  },
  Ln = (e, t) => ((t = Xt(t)), e && t[e] && typeof t[e] == "object" && (t[e] = Xt(t[e])), Ue(t)),
  Ue = (e) => {
    if (e !== null || (e !== void 0 && typeof e == "object")) {
      if (Array.isArray(e)) return e.map(Ue);
      if (xe(e)) {
        if (e.edges && Array.isArray(e.edges)) return e.edges.map((n) => Ue(n.node));
        const t = {};
        for (const n of Object.keys(e)) t[n] = Ue(e[n]);
        return t;
      }
      return e;
    }
  },
  cs = (e, t, n) => {
    const r = Ue(t),
      s = Object.keys(r).filter((l) => !Nn.includes(l)),
      o = Object.fromEntries(Object.entries(e).flatMap(([l, c]) => (s.includes(l) ? [] : [[l, c]]))),
      i = { ...e[n.modelApiIdentifier] };
    for (const l of Object.keys(i)) {
      const c = r[l];
      e[n.modelApiIdentifier] &&
      typeof e[n.modelApiIdentifier] == "object" &&
      l in e[n.modelApiIdentifier] &&
      !Dr(c, e[n.modelApiIdentifier][l])
        ? (i[l] = e[n.modelApiIdentifier][l])
        : l in e && c !== e[l] && l in e && c !== e[l] && (i[l] = e[l]);
    }
    return (o[n.modelApiIdentifier] = i), o;
  };
function us(e) {
  const t = {};
  function n(r, s = void 0, o = 0, i) {
    if (Array.isArray(r))
      return r.flatMap((l) => {
        const c = xe(l) && "id" in l ? l.id : void 0;
        if (!c) return [];
        const u = s ? `${s}.${c}` : c.toString();
        return n(l, u, o + 1, !0);
      });
    if (r != null && typeof r == "object") {
      const l = {};
      for (const c of Object.keys(r)) {
        const u = s ? `${s}.${c}` : c;
        l[c] = n(r[c], u, o + 1);
      }
      if (o > 1) {
        const c = i ? (s == null ? void 0 : s.split(".").slice(0, -1).join(".")) : s;
        "id" in r && (t[c] || (t[c] = []), t[c].push(r.id));
      }
      return l;
    }
    return r;
  }
  return n(e), t;
}
const ds = (e) => ({ markdown: e.markdown }),
  fs = (e) =>
    e.base64
      ? { fileName: e.fileName, mimeType: e.mimeType, base64: e.base64 }
      : e.file
      ? { fileName: e.fileName, mimeType: e.mimeType, file: e.file }
      : e.copyUrl
      ? { fileName: e.fileName, mimeType: e.mimeType, copyUrl: e.copyUrl }
      : e.directUploadToken
      ? { fileName: e.fileName, mimeType: e.mimeType, directUploadToken: e.directUploadToken }
      : void 0,
  ms = async (e, t, n) => {
    const r = e[_r];
    if (!r)
      throw new Error("No Gadget model metadata found -- please ensure you are using the latest version of the API client for your app");
    const s = us(t);
    function o(l, c) {
      const { depth: u, path: f, fieldType: m, fieldRelationships: p, idPath: g } = c;
      if (f && Array.isArray(l)) {
        const E = [];
        let v;
        m && g && (m.type == "HasMany" || m.type == "HasManyThrough") && (v = s[g]);
        const h = [];
        return (
          v &&
            g &&
            E.push(
              v.map((P, A) => {
                const b = l.find((y) => y.id == P);
                if (b) {
                  const y = l.findIndex((x) => x.id == P);
                  delete s[g][A], h.push(y);
                  const I = f ? `${f}.${y}` : y.toString(),
                    k = g && xe(b) && b.id ? `${g}.${b.id}` : void 0;
                  return o(b, { depth: u + 1, path: I, idPath: k, fieldType: m, fieldRelationships: p, parent: c });
                } else {
                  const I = Object.entries(s).find(([k, x]) => k.includes(f + "." + P));
                  if (I) {
                    const { 0: k, 1: x } = I;
                    delete s[k];
                  }
                  return { delete: { id: P } };
                }
              })
            ),
          E.push(
            l
              .filter((P, A) => !h.includes(A))
              .map((P, A) => {
                const b = f ? `${f}.${A}` : A.toString(),
                  y = g && xe(P) && P.id ? `${g}.${P.id}` : void 0;
                return o(P, { depth: u + 1, path: b, idPath: y, fieldType: m, fieldRelationships: p, parent: c });
              })
          ),
          E.flatMap((P) => P)
        );
      } else if (xe(l)) {
        let E = {};
        for (const b of Object.keys(l)) {
          const y = f ? `${f}.${b}` : b,
            I = g ? `${g}.${b}` : b,
            k = p ? p[b] : null,
            x = k ? (r == null ? void 0 : r[k.model]) : r == null ? void 0 : r[b];
          E[b] = o(l[b], { depth: u + 1, path: y, idPath: I, fieldType: k, fieldRelationships: x, parent: c });
        }
        const { __typename: v, ...h } = E;
        if (v == "RichText") return ds(h);
        if (v == "StoredFile") return fs(h);
        let P = null;
        const A = p
          ? Object.entries(p)
              .filter(([b, y]) => y.type === "BelongsTo")
              .reduce((b, [y, I]) => ((b[y] = I), b), {})
          : null;
        for (const b of Object.keys(A ?? {}))
          `${b}Id` in l && (P == null && (P = {}), (P = { ...P, [b]: { _link: l[`${b}Id`] } }), delete h[`${b}Id`]);
        if ((P ? (E = { ...h, ...P }) : (E = h), u <= 1 || m == null)) return E;
        switch (m.type) {
          case "HasOne":
            return gs({ input: l, result: E, defaultValues: t, path: f });
          case "HasMany":
          case "HasManyThrough":
            return ys({ input: l, result: E });
          case "BelongsTo":
            return ps({ input: l, result: E, recordIdsAtPath: s, idPath: g });
          default:
            throw new Error(
              `Can't transform input, Unknown field type ${m == null ? void 0 : m.type}. ${JSON.stringify(
                { input: l, path: f, referencedTypes: r },
                null,
                2
              )}`
            );
        }
      }
      return l;
    }
    return o(n, { depth: 0 });
  },
  ps = (e) => {
    const { input: t, result: n, recordIdsAtPath: r, idPath: s } = e,
      { __typename: o, ...i } = n;
    if (!!("_link" in t && t._link)) return { _link: t._link };
    if (!!("_unlink" in t && t._unlink)) return { _link: null };
    const u = "id" in t,
      f = Object.keys(t).filter((p) => p !== "id" && p !== "__typename").length > 0;
    return u
      ? t.id === null
        ? { _link: null }
        : f
        ? { update: { id: t.id, ...i } }
        : { _link: t.id }
      : (s && r[s] && r[s].length > 0 ? r[s][0] : void 0) && !f
      ? { _link: null }
      : { create: { ...i } };
  },
  gs = (e) => {
    const { input: t, result: n, defaultValues: r, path: s } = e,
      { __typename: o, ...i } = n,
      l = Ce(r, s),
      c = l == null ? void 0 : l.id,
      u = i._link ?? t.id;
    if ("_unlink" in t && t._unlink) return { _unlink: t._unlink };
    const f = c && c !== u ? { _unlink: c } : void 0;
    return "_link" in i && i._link
      ? { update: { id: i._link }, ...f }
      : "id" in t
      ? { update: { ...i }, ...f }
      : { create: { ...i }, ...f };
  },
  ys = (e) => {
    const { input: t, result: n } = e,
      { __typename: r, ...s } = n;
    if ("_link" in s && s._link) return { update: { id: s._link } };
    if ("_unlink" in s && s._unlink) {
      const { id: i, inverseFieldApiIdentifier: l } = s._unlink;
      return { update: { id: i, [l]: { _link: null } } };
    }
    return "id" in t ? { update: { ...s } } : { create: { ...s } };
  },
  xe = (e) => {
    if (typeof e != "object" || e === null) return !1;
    let t = e;
    for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(e) === t;
  };
function $n(e) {
  if (typeof e != "object" || e == null) return e === "ReadOnly" ? !0 : e;
  const t = Array.isArray(e) ? [] : {};
  for (const n in e) {
    const r = e[n];
    t[n] = $n(r);
  }
  return t;
}
function Mt(e, t = "") {
  if (!e) return [];
  let n = [];
  for (const r of Object.keys(e)) {
    let s = t ? `${t}.${r}` : r;
    s.includes("edges.node") && (s = s.replace("edges.node", "*")),
      e[r] === "ReadOnly" ? n.push(s) : typeof e[r] == "object" && e[r] != null && (n = n.concat(Mt(e[r], s)));
  }
  return n;
}
function hs(e) {
  const { select: t, send: n, data: r, modelApiIdentifier: s } = e,
    o = Mt(t, s),
    i = (u, f = "") => {
      const m = Object.keys(u || {}).filter((p) => typeof u[p] == "object" && u[p] !== null);
      for (const p of m) {
        const g = f ? `${f}.${p}` : p,
          E = Object.keys(u[p]).map((h) => `${g}.${h}`),
          v = E.filter((h) => o.includes(h));
        v.length > 0 && v.length === E.length ? o.push(g) : i(u[p], g);
      }
    };
  i(t, s);
  for (const u of o) Or(r, u);
  if (!n) return r;
  const l = {},
    c = typeof n == "function" ? n() : n;
  for (const u of c) {
    const f = [u];
    s && f.push(`${s}.${u}`);
    for (const m of f) {
      const p = Ce(r, m);
      if (typeof p < "u") {
        const E = m.split(".").slice(0, -1).join(".");
        Ce(l, E) !== null && mn(l, m, p);
        break;
      }
    }
  }
  return l;
}
const bs = (e) => {
    d.useEffect(() => {
      if (e.type === "stubbedAction") {
        const o = e;
        if (!("reason" in o) || !("dataPath" in o)) return;
        const i = new CustomEvent("gadget:devharness:stubbedActionError", {
          detail: {
            reason: o.reason,
            action: { functionName: o.functionName, actionApiIdentifier: o.actionApiIdentifier, dataPath: o.dataPath },
          },
        });
        globalThis.dispatchEvent(i);
      }
    }, []);
    const t = d.useMemo(() => Rr(e.operationName, e.variables, e.namespace), [e]),
      [n, r] = Nr(t.query);
    return [
      d.useMemo(() => tn(n, e), [n, e]),
      d.useCallback(
        async (o, i) => {
          const l = await r(o ?? {}, i);
          return tn({ fetching: !1, ...l }, e);
        },
        [e, r]
      ),
    ];
  },
  tn = (e, t) => {
    let n = Ne.forMaybeCombinedError(e.error),
      r;
    if (e.data) {
      const s = xt([t.operationName], t.namespace);
      if (((r = Tt(e.data, s)), r)) {
        const o = r.errors;
        (r = r.result), o && o[0] && (n = Ne.forErrorsResponse(o));
      }
    }
    return { ...e, error: n, data: r };
  },
  vs = (e, t) => {
    var C, T, _;
    const n = t && "findBy" in t ? t.findBy : void 0,
      r = t && "findBy" in t ? (t == null ? void 0 : t.throwOnInvalidFindByObject) ?? !0 : !0,
      s = t && "pause" in t ? t.pause : void 0,
      o = pn(),
      i = !!n,
      l = d.useRef(!i),
      c = "modelApiIdentifier" in e,
      u = t != null && t.select ? $n(t.select) : void 0,
      f = c ? gn(o, e.modelApiIdentifier, e.namespace) : void 0,
      [m] = is(f, n || "1", { pause: s || !i, select: u, throwOnInvalidFindByObject: r }),
      p = !i || !!m.data;
    let g = t == null ? void 0 : t.defaultValues;
    c &&
      m.data &&
      (g = en({
        hasAmbiguousDefaultValues: e.hasAmbiguousIdentifier ?? !1,
        modelApiIdentifier: e.modelApiIdentifier,
        defaultValues: t == null ? void 0 : t.defaultValues,
        data: m.data,
      }));
    let E;
    (C = m.data) != null && C.id
      ? (E = m.data.id)
      : g != null && g.id
      ? (E = g.id)
      : c &&
        (T = g == null ? void 0 : g[e.modelApiIdentifier]) != null &&
        T.id &&
        (E = (_ = g == null ? void 0 : g[e.modelApiIdentifier]) == null ? void 0 : _.id);
    const v = Lr({ ...t, defaultValues: Ln(c ? e.modelApiIdentifier : void 0, g) }),
      { handleSubmit: h, formState: P, ...A } = v;
    d.useEffect(() => {
      p && !l.current && g && ((l.current = !0), A.reset(g));
    }, [p, g, A]);
    const [b, y] = c ? ha(e, { select: u }) : bs(e),
      I = d.useCallback(
        (D) => {
          var M;
          if ("executionErrors" in D) {
            const w = D,
              O = w.executionErrors;
            if (O.length > 0)
              for (const U of O)
                if ("validationErrors" in U)
                  for (const R of U.validationErrors) {
                    const W = c ? `${e.modelApiIdentifier}.${R.apiIdentifier}` : R.apiIdentifier;
                    A.setError(W, { message: R.message });
                  }
                else {
                  const R = "code" in U ? `${U.code}: ` : "",
                    W = U.message.replace(R, "");
                  A.setError("root", { message: W });
                }
            else w.networkError && A.setError("root", { message: w.networkError.message });
          }
          (M = t == null ? void 0 : t.onError) == null || M.call(t, D);
        },
        [e, A, t, c]
      ),
      k = d.useCallback(
        async (D) => {
          let M;
          return (
            A.clearErrors(),
            await h(
              async (w) => {
                var U, R;
                t != null &&
                  t.debug &&
                  console.debug("[useActionForm] form submitted", {
                    hasAmbiguousIdentifier: c && e.hasAmbiguousIdentifier,
                    existingRecordId: E,
                    defaultValues: g,
                    data: w,
                    findResultData: m.data,
                  }),
                  c &&
                    (e.hasAmbiguousIdentifier || (m.data ? (w = cs(w, m.data, e)) : (w = $r(e, w))),
                    t != null && t.debug && console.debug("[useActionForm] disambiguated data", { data: w }),
                    ((t != null && t.select) || (t != null && t.send)) &&
                      (w = hs({ data: w, modelApiIdentifier: e.modelApiIdentifier, select: t.select, send: t.send })),
                    t != null && t.debug && console.debug("[useActionForm] reshaping data for graphql api", { data: w, defaultValues: g }),
                    (w = await ms(o, g, w)),
                    t != null && t.debug && console.debug("[useActionForm] reshaped data for graphql api", { data: w }));
                let O = { ...w };
                if ((E && (O.id = E), !c && t != null && t.send)) {
                  const W = O;
                  O = {};
                  for (const z of typeof t.send == "function" ? t.send() : t.send) mn(O, z, Ce(W, z));
                }
                if (
                  ((U = t == null ? void 0 : t.onSubmit) == null || U.call(t),
                  t != null && t.debug && console.debug("[useActionForm] running action", { variables: O }),
                  (M = await y(O)),
                  !M.error && ((R = t == null ? void 0 : t.onSuccess) == null || R.call(t, M.data), c && M.data))
                ) {
                  if (i) {
                    const W = en({
                      data: M.data,
                      defaultValues: t == null ? void 0 : t.defaultValues,
                      modelApiIdentifier: e.modelApiIdentifier,
                      hasAmbiguousDefaultValues: e.hasAmbiguousIdentifier ?? !1,
                    });
                    A.reset(W, { keepValues: !0 });
                  }
                  if (t != null && t.select) {
                    const W = Mt(t.select);
                    for (const z of W) {
                      const re = Ce(M.data, z);
                      A.setValue(z, re), A.setValue(`${e.modelApiIdentifier}.${z}`, re);
                    }
                  }
                }
              },
              (w) => {
                I(w);
              }
            )(D),
            M != null && M.error && I(M.error),
            M
          );
        },
        [A, h, c, E, t, y, e, m.data, o, g, i, I]
      ),
      x = new Proxy(P, {
        get: (D, M) =>
          M === "isSubmitting"
            ? D.isSubmitting || b.fetching
            : M === "isSubmitSuccessful"
            ? D.isSubmitSuccessful && !b.fetching && !b.error
            : M === "isLoading"
            ? D.isLoading || m.fetching
            : M === "isReady"
            ? p
            : D[M],
      });
    return (
      t != null &&
        t.debug &&
        console.debug("[useActionForm] rendering form hook", {
          isReady: p,
          hasSetInitialValues: l.current,
          hasAmbiguousIdentifier: c && e.hasAmbiguousIdentifier,
          isModelAction: c,
          findExistingRecord: i,
          findResult: m,
          actionResult: b,
          defaultValues: g,
          existingRecordId: E,
          modelApiIdentifier: c ? e.modelApiIdentifier : void 0,
          actionSelect: u,
        }),
      { ...A, formState: x, error: m.error || b.error, submit: k, actionData: b.data, originalFormMethods: v }
    );
  };
var nn = function (e, t, n) {
    if (e && "reportValidity" in e) {
      var r = Et(n, t);
      e.setCustomValidity((r && r.message) || ""), e.reportValidity();
    }
  },
  qn = function (e, t) {
    var n = function (s) {
      var o = t.fields[s];
      o && o.ref && "reportValidity" in o.ref
        ? nn(o.ref, s, e)
        : o.refs &&
          o.refs.forEach(function (i) {
            return nn(i, s, e);
          });
    };
    for (var r in t.fields) n(r);
  },
  Es = function (e) {
    return e instanceof Date;
  },
  Ps = function (e) {
    return e == null;
  },
  As = function (e) {
    return typeof e == "object";
  },
  Is = function (e) {
    return !Ps(e) && !Array.isArray(e) && As(e) && !Es(e);
  },
  ks = function (e) {
    return /^\w*$/.test(e);
  },
  gt = function (e, t, n) {
    for (
      var r = -1,
        s = ks(t)
          ? [t]
          : (function (f) {
              return (m = f.replace(/["|']|\]/g, "").split(/\.|\[/)), Array.isArray(m) ? m.filter(Boolean) : [];
              var m;
            })(t),
        o = s.length,
        i = o - 1;
      ++r < o;

    ) {
      var l = s[r],
        c = n;
      if (r !== i) {
        var u = e[l];
        c = Is(u) || Array.isArray(u) ? u : isNaN(+s[r + 1]) ? {} : [];
      }
      (e[l] = c), (e = e[l]);
    }
    return e;
  },
  xs = function (e, t) {
    t.shouldUseNativeValidation && qn(e, t);
    var n = {};
    for (var r in e) {
      var s = Et(t.fields, r),
        o = Object.assign(e[r] || {}, { ref: s && s.ref });
      if (Ts(t.names || Object.keys(e), r)) {
        var i = Object.assign({}, Et(n, r));
        gt(i, "root", o), gt(n, r, i);
      } else gt(n, r, o);
    }
    return n;
  },
  Ts = function (e, t) {
    return e.some(function (n) {
      return n.startsWith(t + ".");
    });
  };
function Ss(e, t, n) {
  return (
    t === void 0 && (t = {}),
    n === void 0 && (n = {}),
    function (r, s, o) {
      try {
        return Promise.resolve(
          (function (i, l) {
            try {
              var c =
                (t.context,
                Promise.resolve(
                  e[n.mode === "sync" ? "validateSync" : "validate"](r, Object.assign({ abortEarly: !1 }, t, { context: s }))
                ).then(function (u) {
                  return o.shouldUseNativeValidation && qn({}, o), { values: n.raw ? r : u, errors: {} };
                }));
            } catch (u) {
              return l(u);
            }
            return c && c.then ? c.then(void 0, l) : c;
          })(0, function (i) {
            if (!i.inner) throw i;
            return {
              values: {},
              errors: xs(
                ((l = i),
                (c = !o.shouldUseNativeValidation && o.criteriaMode === "all"),
                (l.inner || []).reduce(function (u, f) {
                  if ((u[f.path] || (u[f.path] = { message: f.message, type: f.type }), c)) {
                    var m = u[f.path].types,
                      p = m && m[f.type];
                    u[f.path] = qr(f.path, c, u, f.type, p ? [].concat(p, f.message) : f.message);
                  }
                  return u;
                }, {})),
                o
              ),
            };
            var l, c;
          })
        );
      } catch (i) {
        return Promise.reject(i);
      }
    }
  );
}
const Cs = (e) => {
    if (e.isBulk) throw new Error("Bulk actions are not supported in AutoForms");
  },
  Ms = "gadget/trigger/graphql_api",
  ws = "Specify a valid Gagdet action to use AutoForm",
  Fs = '"action" is not a valid Gadget action',
  Bn = '"action" requires an API trigger to be used in AutoForm',
  Ds = ["globalAction", "action"],
  _s = (e) => {
    if (!Ds.includes(e.type)) throw new Error(Bn);
  },
  Os = (e) => {
    if (!("action" in e)) throw new Error(ws);
    if (!e.action) throw new Error(Fs);
    if (e.children) {
      if (e.include) throw new Error("AutoForm components with children cannot use the include option");
      if (e.exclude) throw new Error("AutoForm components with children cannot use the exclude option");
    }
  },
  Rs = (e) => {
    if (!e) return;
    if (
      !((e.__typename === "GadgetGlobalAction" ? e.triggers : e.__typename === "GadgetModel" ? e.action.triggers : []) ?? []).some(
        (r) => r.specID === Ms
      )
    )
      throw new Error(Bn);
  },
  Ns = (e, t) => {
    if (!t || typeof t == "string") return;
    if (!xe(t) || Object.keys(t).length !== 1)
      throw new Error("The findBy prop in AutoForm must be an object containing a single unique Gadget field API identifier as a key.");
    if (!e || !e.length) return;
    const n = Object.keys(t)[0];
    if (
      !e
        .filter((s) => s.metadata.configuration.validations.some((o) => (o == null ? void 0 : o.specID) === "gadget/validation/unique"))
        .map((s) => s.metadata.apiIdentifier)
        .includes(n)
    )
      throw new Error(
        `The findBy prop in AutoForm must be an object containing a unique Gadget field API identifier as a key. "${n}" is not a unique field name.`
      );
  };
function ne(e) {
  const t = (n) => a.createElement(e, { ...n });
  return (t.__autoInput = !0), t;
}
const Ls = (e, t) =>
    d.useMemo(() => {
      if (!e) return;
      const n = Ie(e) ? e.action : e;
      return Ss(Ur(n.inputFields, t));
    }, [e, t]),
  $s = (e) => {
    if (e) return Ie(e) ? e.action.isUpsertMetaAction : !1;
  },
  qs = (e, t) =>
    d.useMemo(() => {
      if (!e) return [];
      const n = Ie(e) ? e.action : e,
        s =
          e.__typename === "GadgetModel"
            ? n.inputFields.filter((u) => u.configuration.__typename === "GadgetObjectFieldConfig" && u.apiIdentifier === e.apiIdentifier)
            : [],
        o = n.inputFields.filter((u) => u.configuration.__typename !== "GadgetObjectFieldConfig"),
        i = $t(o, t).map(([u, f]) => ({ path: u, metadata: f })),
        c = [
          ...s.flatMap((u) =>
            $t(u.configuration.fields, { ...t, isUpsertAction: !0 }).map(([f, m]) => ({ path: `${u.apiIdentifier}.${f}`, metadata: m }))
          ),
          ...i,
        ];
      return Vs(n.apiIdentifier, c), c;
    }, [e, t]),
  Bs = (e, t) => {
    if (!e || !t.length) return;
    const n = t.map((s) => s.path.replace(new RegExp(`^${e}\\.`), "")),
      r = t.map((s) => s.metadata);
    return Hr(e, n, r);
  },
  Vs = (e, t) => {
    const n = new Set(),
      r = new Set();
    for (const { path: s, metadata: o } of t) {
      if (r.has(o.apiIdentifier) || n.has(s)) throw new Error(`Input "${o.apiIdentifier}" is not unique for action "${e}"`);
      r.add(o.apiIdentifier), n.add(s);
    }
  },
  Us = (e) => {
    const { action: t, record: n, onSuccess: r, onFailure: s, findBy: o, children: i } = e;
    let l = e.include,
      c = e.exclude;
    Cs(t), _s(t);
    const { metadata: u, fetching: f, error: m } = Br(e.action);
    Rs(u);
    const p = qs(u, { include: l, exclude: c });
    Ns(p, o);
    const g = u && Ie(u) && u.action.isDeleteAction,
      E = t.type === "globalAction",
      v = !!(u && Ie(u) && u.action.operatesWithRecordIdentity),
      h = t.type == "action" ? t.modelApiIdentifier : void 0,
      P = $s(u),
      A = Bs(h, p),
      b = P && !!o,
      y = d.useMemo(() => p.map(({ path: ie }) => ie), [p]),
      I = d.useMemo(
        () =>
          e.defaultValues ??
          (t.type === "globalAction"
            ? {}
            : { [h]: n ?? (!(v || b) && u && Ie(u) && (u == null ? void 0 : u.defaultRecord)), id: typeof o == "string" ? o : void 0 }),
        [e.defaultValues, t.type, h, n, v, u, o]
      ),
      {
        submit: k,
        error: x,
        reset: C,
        setValue: T,
        getValues: _,
        formState: { isSubmitSuccessful: D, submitCount: M, isLoading: w, isReady: O, isSubmitting: U, touchedFields: R, errors: W },
        originalFormMethods: z,
      } = vs(t, {
        defaultValues: I,
        findBy: "findBy" in e ? e.findBy : void 0,
        throwOnInvalidFindByObject: !1,
        pause: "findBy" in e ? f : void 0,
        select: A,
        resolver: Ls(u, y),
        send: () => {
          const ie = new Set(
              p.flatMap(({ path: B, metadata: $ }) => ($.fieldType === F.HasMany || $.fieldType === F.HasManyThrough ? B : []))
            ),
            N = {};
          for (const { path: B, metadata: $ } of p)
            if ($.fieldType === F.HasManyThrough) {
              const q = $.configuration,
                ge = B.split(".").slice(0, -1);
              N[B] = [...ge, q.joinModelHasManyFieldApiIdentifier].join(".");
            }
          const Y = p
            .filter(({ path: B, metadata: $ }) => {
              var De, _e;
              const q = $.fieldType;
              if (q === F.Password && "findBy" in e && !Ce(R, B)) return !1;
              if (q === F.BelongsTo) {
                const ye = _(B),
                  S = _(`${B}Id`);
                if (ye === null && S) return !1;
              }
              const ge = B.split(".");
              return ge.some((ye, S) => {
                const L = ge.slice(0, S).join(".");
                return ie.has(L);
              })
                ? !1
                : e.include
                ? (De = e.include) == null
                  ? void 0
                  : De.includes($.apiIdentifier)
                : e.exclude
                ? !((_e = e.exclude) != null && _e.includes($.apiIdentifier))
                : !0;
            })
            .map(({ path: B }) => B);
          return (
            v && Y.push("id"),
            e.defaultValues &&
              h &&
              Vr(e.defaultValues).forEach(($) => {
                Y.includes($) || Y.push($);
              }),
            Y.map((B) => (N[B] ? N[B] : B))
          );
        },
        onError: s,
        onSuccess: r,
        debug: e.debug,
      }),
      re = !v && !g && !E && !P,
      G = P && !b;
    d.useEffect(() => {
      if (D && (re || G || E)) {
        const ie = h && A ? Hs(h, I, A) : I;
        C(ie);
      }
    }, [D, re, G, E, C, I, M, A, h]);
    const se = d.useRef(!1);
    return (
      d.useEffect(() => {
        O && !se.current && h && I[h] && ((se.current = !0), z.reset(I));
      }, [O, I, z, h]),
      f || Ws({ operatesWithRecordId: v, hasFindBy: !!o, isUpsertMetaAction: !!P }),
      d.useEffect(() => {
        b && T(`${h}.id`, o);
      }, [_(`${h}.id`), b]),
      {
        metadata: u,
        fetchingMetadata: f,
        metadataError: m,
        fields: p.filter(js(b)),
        submit: k,
        formError: x,
        isSubmitting: U,
        isSubmitSuccessful: D,
        isLoading: w,
        originalFormMethods: z,
      }
    );
  },
  Hs = (e, t, n) => {
    const r = (s) =>
      Object.keys(s).reduce((o, i) => {
        const l = s[i];
        if (xe(l))
          if ("edges" in l) o[i] = [];
          else {
            const c = r(l);
            Object.keys(c).length > 0 && (o[i] = c);
          }
        return o;
      }, {});
    return { ...t, [e]: { ...(t[e] ?? {}), ...r(n) } };
  },
  js = (e) => (t) => t.metadata.fieldType === F.Id ? !e : !0,
  Ws = (e) => {
    const { operatesWithRecordId: t, hasFindBy: n, isUpsertMetaAction: r } = e;
    if (!r) {
      if (t && !n) throw new Error("The 'findBy' prop is required for actions that operate with a record identity.");
      if (!t && n) throw new Error("The 'findBy' prop is only allowed for actions that operate with a record identity.");
    }
  },
  zs = a.lazy(() =>
    ba(
      () => import("./PolarisAutoRichTextInput-c5e8a199.js").then((e) => e.P),
      [
        "./PolarisAutoRichTextInput-c5e8a199.js",
        "./index-c6dae603.js",
        "./index-0511f421.js",
        "./extends-98964cd2.js",
        "./index-eb008d06.js",
        "./apis-d6201c92.js",
        "./iframe-5aa777a6.js",
        "./index-baeb160b.js",
        "./PolarisAutoRichTextInput-8ccf742d.css",
      ],
      import.meta.url
    )
  ),
  Vn = ne((e) => a.createElement(a.Fragment, null, a.createElement(zs, { ...e })));
Vn.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoRichTextInput" };
const Un = ne((e) => {
  const { field: t, control: n, ...r } = e,
    { path: s, metadata: o } = pe(t),
    {
      field: i,
      fieldState: { error: l },
    } = Fe({ control: n, name: s }),
    {
      formState: { defaultValues: c },
    } = yn();
  d.useEffect(() => {
    if (o.requiredArgumentForInput) {
      const p = Ce(c ?? {}, s) ?? !1;
      i.onChange(p);
    }
  }, [o.requiredArgumentForInput, c]);
  const u = e.label ?? o.name,
    { value: f, ...m } = i;
  return a.createElement(an, { ...m, checked: !!i.value, error: l == null ? void 0 : l.message, ...r, label: u });
});
Un.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoBooleanInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const Zs = (e, t, n, r, s) =>
    e.map((o, i) =>
      a.createElement(
        "div",
        { key: i, style: { textAlign: "center", cursor: "default", padding: "0px 4px" } },
        a.createElement(
          j.Option,
          { value: o },
          a.createElement(
            "div",
            { style: { cursor: "pointer" }, onMouseEnter: () => s({ col: n, row: i }), onMouseLeave: () => s({ col: -1, row: -1 }) },
            t.padStart(2, "0") == o.padStart(2, "0") ||
              (parseInt(t, 10) == 0 && o == "12") ||
              ((r == null ? void 0 : r.col) == n && r.row == i)
              ? a.createElement(
                  $e,
                  { padding: "100", background: "bg-inverse", borderRadius: "200", minHeight: "30px", minWidth: "30px" },
                  a.createElement(te, { as: "p", tone: "text-inverse" }, o)
                )
              : a.createElement($e, { minHeight: "30px", minWidth: "30px", padding: "100" }, o)
          )
        )
      )
    ),
  yt = Array.from({ length: 12 }, (e, t) => (t + 1).toString().padStart(2, "0")),
  ht = Array.from({ length: 60 }, (e, t) => t.toString().padStart(2, "0")),
  bt = ["AM", "PM"],
  Gs = new RegExp(/((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))/),
  rn = (e) => (parseInt(e.hour, 10) === 0 ? `12:${e.minute.padStart(2, "0")} AM` : `${e.hour}:${e.minute.padStart(2, "0")} ${e.ampm}`),
  Hn = (e) => {
    var I;
    const [t, n] = d.useState(e.value),
      [r, s] = d.useState(e.localTime ? rn(K(e.localTime)) : ""),
      [o, i] = d.useState(!1),
      [l, c] = d.useState(!1),
      [u, f] = d.useState({ col: -1, row: -1 }),
      m = (k) => {
        var x;
        if (t) {
          (x = e.onChange) == null || x.call(e, Re({ ...K(t), hour: k }));
          return;
        }
        e.fieldProps.onChange(Re({ ...K(e.fieldProps.value ?? new Date()), hour: k }));
      },
      p = (k) => {
        var x;
        if (t) {
          (x = e.onChange) == null || x.call(e, Re({ ...K(t), minute: k }));
          return;
        }
        e.fieldProps.onChange(Re({ ...K(e.fieldProps.value ?? new Date()), minute: k }));
      },
      g = (k) => {
        var x;
        if (t) {
          (x = e.onChange) == null || x.call(e, Re({ ...K(t), ampm: k }));
          return;
        }
        e.fieldProps.onChange(Re({ ...K(e.fieldProps.value ?? new Date()), ampm: k }));
      },
      E = (k) => {
        var W;
        s(k);
        let x = k.trim(),
          C = parseInt(x.split(":")[0], 10);
        const T = x.split(":")[1];
        if ((C === 0 && (x = "12:" + T), !Gs.test(x))) {
          c(!0);
          return;
        }
        c(!1);
        const D = parseInt(T, 10),
          M = x.slice(-2).toUpperCase(),
          w = C.toString(),
          O = D.toString().padStart(2, "0");
        m(w), p(O), g(M);
        const U = new Date();
        M === "PM" && C < 12 ? (C += 12) : M === "AM" && C === 12 && (C = 0), U.setHours(C, D, 0, 0);
        const R = e.localTime ? new Date(e.localTime) : new Date();
        jn(R, U),
          (W = e.onChange) == null || W.call(e, Le(R, e.localTz ?? "UTC")),
          e.fieldProps.onChange(Le(R, e.localTz ?? "UTC")),
          t && n(Le(R, e.localTz ?? "UTC")),
          s(`${parseInt(w, 10) === 0 ? "12" : w}:${O} ${M}`);
      },
      v = (k) => {
        const x = t ?? e.fieldProps.value;
        return `${k}:${x ? K(x).minute.toString().padStart(2, "0") : ht[0]} ${x ? K(x).ampm : bt[0]}`;
      },
      h = (k) => {
        const x = t ?? e.fieldProps.value;
        return `${x ? K(x).hour : yt[0]}:${k.padStart(2, "0")} ${x ? K(x).ampm : bt[0]}`;
      },
      P = (k) => {
        const x = t ?? e.fieldProps.value;
        return `${x ? K(x).hour : yt[0]}:${x ? K(x).minute.toString().padStart(2, "0") : ht[0]} ${k}`;
      },
      A = { array: yt, formatter: v, key: "hour" },
      b = { array: ht, formatter: h, key: "minute" },
      y = { array: bt, formatter: P, key: "ampm" };
    return (
      d.useEffect(() => {
        !e.fieldProps.value || t || s(rn(K(new Date(e.fieldProps.value))));
      }, [e.fieldProps.value, t, s]),
      a.createElement(
        a.Fragment,
        null,
        a.createElement(
          He,
          {
            active: o,
            onClose: () => i(!1),
            preferredAlignment: "right",
            activator: a.createElement(ze, {
              prefix: a.createElement(Me, { source: An }),
              id: e.id ? `${e.id}-time` : void 0,
              "data-testid": e.id ? `${e.id}-time` : void 0,
              label: ((I = e.timePickerProps) == null ? void 0 : I.label) ?? "Time",
              autoComplete: "off",
              value: r,
              onChange: E,
              onFocus: () => i(!0),
              error: l && "Invalid time format",
              ...e.timePickerProps,
            }),
          },
          a.createElement(
            He.Pane,
            { fixed: !0 },
            !e.hideTimePopover &&
              a.createElement(
                "div",
                { style: { overflow: "hidden", padding: "15px 8px" } },
                a.createElement(
                  "div",
                  { style: { display: "flex" } },
                  [A, b, y].map((k, x) =>
                    a.createElement(
                      jr,
                      { key: x, style: { overflowY: "scroll", height: "250px" } },
                      a.createElement(
                        j,
                        { onSelect: (C) => E(k.formatter(C)) },
                        Zs(
                          k.array,
                          t ? `${K(t)[k.key]}` : e.fieldProps.value ? `${K(new Date(e.fieldProps.value))[k.key]}` : k.array[0],
                          x,
                          u,
                          f
                        )
                      )
                    )
                  )
                )
              )
          )
        )
      )
    );
  },
  Ks = Hn;
Hn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoTimePicker",
  props: {
    fieldProps: {
      required: !0,
      tsType: {
        name: "ControllerRenderProps",
        elements: [{ name: "FieldValues" }, { name: "string" }],
        raw: "ControllerRenderProps<FieldValues, string>",
      },
      description: "",
    },
    value: { required: !1, tsType: { name: "Date" }, description: "" },
    onChange: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(value: Date) => void",
        signature: { arguments: [{ type: { name: "Date" }, name: "value" }], return: { name: "void" } },
      },
      description: "",
    },
    localTime: { required: !1, tsType: { name: "Date" }, description: "" },
    id: { required: !1, tsType: { name: "string" }, description: "" },
    timePickerProps: {
      required: !1,
      tsType: { name: "Partial", elements: [{ name: "TextFieldProps" }], raw: "Partial<TextFieldProps>" },
      description: "",
    },
    hideTimePopover: { required: !1, tsType: { name: "boolean" }, description: "" },
    localTz: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
const jn = (e, t) => {
    e.setHours(t.getHours()), e.setMinutes(t.getMinutes()), e.setSeconds(t.getSeconds()), e.setMilliseconds(t.getMilliseconds());
  },
  K = (e) => ({
    month: e.getMonth(),
    year: e.getFullYear(),
    day: e.getDay(),
    hour: e.getHours() > 12 ? (e.getHours() - 12).toString() : e.getHours().toString(),
    minute: e.getMinutes().toString().padStart(2, "0"),
    ampm: e.getHours() >= 12 ? "PM" : "AM",
  }),
  Re = (e) => {
    const t = new Date();
    return (
      t.setMonth(e.month),
      t.setFullYear(e.year),
      t.setDate(e.day),
      t.setHours(e.ampm === "PM" ? parseInt(e.hour) + 12 : parseInt(e.hour)),
      t.setMinutes(parseInt(e.minute)),
      t.setSeconds(0),
      t.setMilliseconds(0),
      t
    );
  },
  Wn = ne((e) => {
    var b;
    const { path: t, metadata: n } = pe(e.field),
      { field: r, fieldState: s } = Fe({ name: t }),
      { onChange: o, value: i } = e,
      l = Intl.DateTimeFormat().resolvedOptions().timeZone,
      c = d.useMemo(() => i || (Je(new Date(r.value)) ? new Date(r.value) : void 0), [i, r.value]),
      [u, f] = d.useState(!1),
      [m, p] = d.useState(K(c ?? qt(new Date(), l)).month),
      [g, E] = d.useState(K(c ?? qt(new Date(), l)).year),
      v = n.configuration,
      h = d.useCallback(
        (y) => {
          (r || i) && jn(y.start, Le(y.start, l));
          const I = i ?? new Date(r.value);
          Je(I) &&
            (y.start.setHours(I.getHours()),
            y.start.setMinutes(I.getMinutes()),
            y.start.setSeconds(I.getSeconds()),
            y.start.setMilliseconds(I.getMilliseconds())),
            o == null || o(Le(y.start, l)),
            r.onChange(Le(y.start, l)),
            f(!1);
        },
        [r, i, l, o]
      ),
      P = d.useCallback(() => {
        p(K(Je(c) && c ? c : new Date()).month), E(K(Je(c) && c ? c : new Date()).year), f((y) => !y);
      }, [c]),
      A = d.useCallback((y, I) => {
        p(y), E(I);
      }, []);
    return a.createElement(
      Te,
      { gap: "400" },
      a.createElement(
        He,
        {
          preferredPosition: "above",
          active: u,
          activator: a.createElement(ze, {
            id: e.id ? `${e.id}-date` : void 0,
            label: e.label ?? n.name ?? "Date",
            prefix: a.createElement(Me, { source: Pn }),
            autoComplete: "off",
            value: c ? Wr(c) : "",
            onFocus: P,
            requiredIndicator: n.requiredArgumentForInput,
            error: e.error ?? ((b = s.error) == null ? void 0 : b.message),
          }),
          onClose: P,
        },
        a.createElement(
          "div",
          { style: { padding: "16px" } },
          a.createElement(Ka, {
            month: m,
            year: g,
            allowRange: !1,
            onChange: h,
            onMonthChange: A,
            selected: c ?? new Date(),
            ...e.datePickerProps,
          })
        )
      ),
      (e.includeTime ?? v.includeTime) &&
        a.createElement(
          "div",
          { style: { width: "130px" } },
          a.createElement(Ks, {
            fieldProps: r,
            id: e.id,
            localTime: c,
            onChange: o,
            hideTimePopover: e.hideTimePopover,
            localTz: l,
            timePickerProps: e.timePickerProps,
            value: i,
          })
        )
    );
  });
Wn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoDateTimePicker",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    id: { required: !1, tsType: { name: "string" }, description: "" },
    value: { required: !1, tsType: { name: "Date" }, description: "" },
    onChange: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(value: Date) => void",
        signature: { arguments: [{ type: { name: "Date" }, name: "value" }], return: { name: "void" } },
      },
      description: "",
    },
    error: { required: !1, tsType: { name: "string" }, description: "" },
    includeTime: { required: !1, tsType: { name: "boolean" }, description: "" },
    hideTimePopover: { required: !1, tsType: { name: "boolean" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
    datePickerProps: {
      required: !1,
      tsType: { name: "Partial", elements: [{ name: "DatePickerProps" }], raw: "Partial<DatePickerProps>" },
      description: "",
    },
    timePickerProps: {
      required: !1,
      tsType: { name: "Partial", elements: [{ name: "TextFieldProps" }], raw: "Partial<TextFieldProps>" },
      description: "",
    },
  },
};
const Ys = { [F.Number]: "number", [F.Email]: "email", [F.Password]: "password", [F.EncryptedString]: "password" },
  Js = {
    [F.String]: "Enter text",
    [F.Number]: "Enter number",
    [F.Email]: "example@email.com",
    [F.Password]: "Value",
    [F.EncryptedString]: "Enter text",
    [F.Color]: "Enter color",
    [F.Url]: "example.com",
  },
  at = (e) => {
    const { field: t, ...n } = e,
      { path: r, metadata: s } = pe(t),
      {
        field: o,
        fieldState: { error: i },
      } = Fe({ name: r, ...n }),
      { value: l, ...c } = o,
      u = Js[s.fieldType];
    return {
      id: r,
      label: s.name,
      type: Ys[s.fieldType],
      isError: !!i,
      errorMessage: i == null ? void 0 : i.message,
      autoComplete: "off",
      placeholder: u,
      metadata: s,
      value: Qs(l, s.fieldType),
      ...c,
    };
  },
  Qs = (e, t) => (t === F.Json ? e : e ?? ""),
  Ze = ne((e) => {
    const { field: t, control: n } = e,
      r = at({ field: t, control: n });
    return a.createElement(ze, {
      ...tt(r),
      requiredIndicator: r.metadata.requiredArgumentForInput,
      type: r.type,
      error: r.errorMessage,
      ...e,
      label: e.label || r.metadata.name,
    });
  });
Ze.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoTextInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const wt = ne((e) => {
  const [t, n] = d.useState(!1),
    r = a.createElement(
      "div",
      { style: { display: "flex" } },
      a.createElement(Se, {
        variant: "plain",
        size: "slim",
        icon: t ? zr : Zr,
        onClick: () => n(!t),
        role: `${e.field}ToggleShowHideButton`,
      })
    );
  return a.createElement(Ze, { type: t ? "text" : "password", suffix: r, ...e });
});
wt.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoEncryptedStringInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const Xs = (e) => {
    const { field: t, control: n } = e,
      { path: r, metadata: s } = pe(t),
      o = s.configuration;
    if (o.__typename !== "GadgetEnumConfig") throw new Error("Field is not an enum type");
    const {
        field: i,
        fieldState: { error: l },
      } = Fe({ control: n, name: r }),
      [c, u] = d.useState(""),
      f = d.useMemo(() => (typeof i.value == "string" ? [i.value] : i.value ?? []), [i.value]),
      m = d.useMemo(() => o.options.map((v) => v.name), [o.options]),
      p = d.useMemo(() => [...new Set([...f, ...m])], [m, f]),
      g = d.useMemo(() => p.filter((v) => !c || v.toLocaleLowerCase().includes(c.trim().toLocaleLowerCase())), [p, c]),
      E = d.useCallback(
        (v) => {
          if ((u(""), o.allowMultiple)) {
            if (v === null) {
              i.onChange([]);
              return;
            }
            const h = new Set([...f]);
            h.has(v) ? h.delete(v) : h.add(v), i.onChange([...h]);
          } else v === null || f.includes(v) ? i.onChange(null) : i.onChange(v);
        },
        [o.allowMultiple, i, f]
      );
    return {
      allowMultiple: o.allowMultiple,
      allowOther: o.allowOther,
      selectedOptions: f,
      providedOptions: m,
      filteredOptions: g,
      allOptions: p,
      searchQuery: { value: c, setValue: u },
      onSelectionChange: E,
      label: s.name,
      metadata: s,
      fieldProps: i,
      isError: !!l,
      errorMessage: l == null ? void 0 : l.message,
    };
  },
  zn = ne((e) => {
    const { field: t, control: n, label: r, ...s } = e,
      {
        allowMultiple: o,
        allowOther: i,
        onSelectionChange: l,
        selectedOptions: c,
        allOptions: u,
        filteredOptions: f,
        searchQuery: m,
        label: p,
        metadata: g,
        isError: E,
        errorMessage: v,
      } = Xs({ field: t, control: n }),
      { value: h, setValue: P } = m;
    let A = null;
    c.length > 0 &&
      (A = a.createElement(
        Te,
        { gap: "150" },
        c.map((T) => a.createElement(je, { key: `option-${T}`, onRemove: () => l(T) }, T))
      ));
    const b = d.useCallback(
      (T) => {
        const _ = h.trim().toLocaleLowerCase(),
          D = T.toLocaleLowerCase().indexOf(_);
        if (!h || D === -1) return T;
        const M = T.slice(0, D),
          w = T.slice(D, D + _.length),
          O = T.slice(D + _.length, T.length);
        return a.createElement("p", null, M, a.createElement(te, { fontWeight: "bold", as: "span" }, w), O);
      },
      [h]
    );
    let y = null;
    u.length > 0 &&
      (y = f.map((T) =>
        a.createElement(
          j.Option,
          { key: T, value: T, selected: c.includes(T), accessibilityLabel: T },
          a.createElement(j.TextOption, { selected: c.includes(T) }, b(T))
        )
      ));
    let I = null;
    i && h && !u.includes(h) && h.trim().length > 0 && (I = a.createElement(j.Action, { value: h }, `Add "${h}"`));
    let k = null;
    !i &&
      (!y || y.length === 0) &&
      h &&
      (k = a.createElement(
        $e,
        { padding: "100" },
        a.createElement(te, { as: "span", alignment: "center", tone: "subdued" }, `No options found matching "${h}"`)
      ));
    let x = null;
    (y || I || k) &&
      (x = a.createElement(
        j,
        {
          autoSelection: Ee.None,
          onSelect: (T) => {
            l(T), o && P("");
          },
        },
        k,
        I,
        y
      ));
    const C = a.createElement(
      a.Fragment,
      null,
      r ?? p,
      " ",
      g.requiredArgumentForInput ? a.createElement("span", { style: { color: "var(--p-color-text-critical)" } }, "*") : null
    );
    return a.createElement(
      he,
      {
        allowMultiple: o,
        activator: a.createElement(he.TextField, {
          autoComplete: "off",
          label: C,
          value: h,
          placeholder: "Search",
          verticalContent: A,
          onChange: P,
          id: `${e.field}-combobox-textfield`,
          error: v,
        }),
        ...s,
      },
      x
    );
  });
zn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoEnumInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
const Zn = ne((e) => {
  var v, h;
  const { field: t, control: n, ...r } = e,
    {
      fieldProps: s,
      errorMessage: o,
      imageThumbnailURL: i,
      onFileUpload: l,
      clearFileValue: c,
      canClearFileValue: u,
      validations: f,
      metadata: m,
    } = Gr({ field: t, control: n }),
    p = d.useMemo(() => {
      if (s.value) return null;
      const P = ["Accepts"];
      if ((f.onlyImages && P.push(`.jpg, .webp, .svg${f.onlyImages.allowAnimatedImages ? ", .gif" : ""}, and .png`), f.fileSize)) {
        const A = f.fileSize,
          b = Kr(A, {
            inRange: (y, I) => `between ${Qe(y)} and ${Qe(I)}`,
            max: (y) => `smaller than ${Qe(y)}`,
            min: (y) => `larger than ${Qe(y)}`,
          });
        b && P.push(b);
      }
      return a.createElement(At.FileUpload, { actionTitle: "Add file", actionHint: P.length === 1 ? "" : P.join(" ") });
    }, [s.value, f.fileSize, f.onlyImages]),
    g = d.useMemo(() => {
      const P = s.value;
      return !P || !Yr(P)
        ? null
        : a.createElement(
            $e,
            { padding: "100", paddingInlineEnd: "400" },
            a.createElement(
              Te,
              { align: "space-between", gap: "400" },
              a.createElement(
                Te,
                { gap: "200", blockAlign: "center" },
                a.createElement(Jr, { size: "small", alt: P.fileName, source: i && [...Qr, "image/gif"].includes(P.mimeType) ? i : Xr }),
                a.createElement("div", null, P.$uploading ? "(Uploading) " : "", P.fileName)
              ),
              u &&
                a.createElement(Se, {
                  icon: ea,
                  variant: "plain",
                  accessibilityLabel: "Delete file",
                  onPointerDown: () => {
                    c();
                  },
                  id: `clear-file-${t}`,
                })
            )
          );
    }, [u, c, t, s.value, i]),
    E = a.createElement(
      a.Fragment,
      null,
      m.name,
      " ",
      m.requiredArgumentForInput ? a.createElement("span", { style: { color: "var(--p-color-text-critical)" } }, "*") : null
    );
  return a.createElement(
    a.Fragment,
    null,
    a.createElement(
      At,
      {
        variableHeight: !0,
        label: E,
        allowMultiple: !1,
        onDrop: (P, A) => {
          l(A);
        },
        ...r,
        accept: (h = (v = f.onlyImages) == null ? void 0 : v.acceptedTypes) == null ? void 0 : h.join(","),
      },
      g,
      p
    ),
    o && a.createElement("div", { style: { marginTop: "4px" } }, a.createElement(ta, { fieldID: t, message: o }))
  );
});
Zn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoFileInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const Gn = ne((e) => {
  const { field: t, label: n } = e,
    { name: r, metadata: s } = at({ field: t });
  if (s.fieldType !== F.Id || t !== "id") throw new Error(`PolarisAutoIdInput: field ${t} is not of type Id`);
  return a.createElement(Ze, { step: 1, field: t, min: 1, type: "number", label: n || "ID", name: r });
});
Gn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoIdInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
function eo(e) {
  const [t, n] = d.useState(!1),
    [r, s] = d.useState(!1),
    o = d.useRef(null),
    i = e ?? o;
  return [
    t,
    {
      onFocus: (u) => {
        if (!u) return;
        const f = u.target === i.current;
        n(!0), f || s(!0);
      },
      onBlur: (u) => {
        if (!u) return;
        const f = u.target === i.current;
        n(!1), f || s(!1);
      },
      ref: i,
    },
    r,
  ];
}
const to = (e) => {
    const t = at(e),
      n = t.value,
      r = ra(n),
      [s, o] = d.useState(t.value && !r ? JSON.stringify(n, null, 2) : "");
    d.useEffect(() => {
      if (typeof n < "u" && n != null && !r)
        try {
          const l = JSON.parse(s);
          na(l, n) || o(JSON.stringify(n, null, 2));
        } catch {
          o(JSON.stringify(n, null, 2));
        }
    }, [n, r]),
      d.useEffect(() => {
        t.value === void 0 && o("");
      }, [t.value]);
    const i = d.useCallback(
      (l) => {
        if ((o(l), l == "")) {
          t.onChange(null);
          return;
        }
        try {
          const c = JSON.parse(l);
          t.onChange(c);
        } catch (c) {
          t.onChange({ $failedParse: !0, raw: l, error: c });
        }
      },
      [t]
    );
    return { ...t, onChange: i, value: s };
  },
  Kn = ne((e) => {
    const [t, n] = eo(),
      { field: r, control: s, ...o } = e,
      { type: i, errorMessage: l, ...c } = to(e),
      u = e.label ?? c.label;
    return a.createElement(
      a.Fragment,
      null,
      a.createElement(ze, {
        multiline: 4,
        monospaced: !0,
        requiredIndicator: c.metadata.requiredArgumentForInput,
        error: !t && l && `Invalid JSON: ${l}`,
        ...tt(c),
        ...tt(n),
        ...o,
        label: u,
      })
    );
  });
Kn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoJSONInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const Yn = ne((e) => {
  const { field: t, control: n } = e,
    { type: r, metadata: s, value: o } = at({ field: t, control: n }),
    l =
      r === "number" && s.configuration.__typename === "GadgetNumberConfig" && s.configuration.decimals && s.configuration.decimals > 0
        ? Bt(s.configuration.decimals)
        : o
        ? Bt(aa(`${o}`))
        : 1;
  return a.createElement(Ze, { step: l, ...e });
});
Yn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoNumberInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const no = "********",
  Jn = ne((e) => {
    const { findBy: t } = rt(),
      { path: n } = pe(e.field),
      { field: r } = Fe({ name: n }),
      [s, o] = d.useState(!t),
      i = () => {
        r.onChange(""), o(!0);
      },
      l = a.createElement(
        "div",
        { style: { display: "flex" } },
        a.createElement(Se, { variant: "plain", size: "slim", icon: sa, onClick: i, role: `${e.field}EditPasswordButton` })
      );
    return a.createElement(wt, { ...(s ? { placeholder: "Password" } : { placeholder: no, suffix: l, disabled: !0 }), ...e });
  });
Jn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoPasswordInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const ro = (e) => {
    const { field: t, control: n } = e,
      { path: r, metadata: s } = pe(t),
      {
        field: o,
        fieldState: { error: i },
      } = Fe({ control: n, name: r }),
      { roles: l, fetching: c, error: u } = oa(),
      f = d.useMemo(() => (l ? l.filter((p) => !ao.includes(p.key)).map((p) => ({ value: p.key, label: p.name })) : []), [l]),
      m = c || f.length === 0;
    return { selectedRoleKeys: o.value ?? [], metadata: s, options: f, fieldProps: o, loading: m, rolesError: u, fieldError: i };
  },
  ao = ["sysadmin"],
  Qn = (e) => {
    var b;
    const { label: t, options: n, value: r, onChange: s, allowMultiple: o, ...i } = e,
      l = d.useMemo(() => (r ? (o ? r : [r]) : []), [o, r]),
      c = n.filter((y) => l.includes(y.value)),
      [u, f] = d.useState(o ? "" : ((b = c[0]) == null ? void 0 : b.label) ?? ""),
      [m, p] = d.useState(e.options),
      g = d.useCallback(
        (y) => {
          s(o ? y : y[0]);
        },
        [o, s]
      ),
      E = d.useCallback(
        (y) => {
          if ((f(y), y === "")) {
            p(e.options);
            return;
          }
          const I = new RegExp(y, "i"),
            k = e.options.filter((x) => x.label.match(I));
          p(k);
        },
        [e.options]
      ),
      v = d.useCallback(
        (y) => {
          const I = y.map((k) => {
            const x = m.find((C) => C.value.match(k));
            return x && x.value;
          });
          g(y), o || f(I[0] || "");
        },
        [g, m]
      ),
      h = d.useCallback(
        (y) => () => {
          const I = [...l];
          I.splice(I.indexOf(y), 1), g(I);
        },
        [g, l]
      ),
      P =
        c.length > 0 && e.allowMultiple
          ? a.createElement(
              Te,
              { gap: "200" },
              c.map((y) => a.createElement(je, { key: `option-${y.value}`, onRemove: h(y.value) }, y.label))
            )
          : null,
      A = a.createElement(Pt.TextField, {
        onChange: E,
        label: t,
        value: u,
        verticalContent: P,
        placeholder: "Search",
        autoComplete: "off",
        id: `${t}_Autocomplete_Textfield`,
      });
    return a.createElement(Pt, { options: m, ...i, selected: l, onSelect: v, textField: A, id: `${t}_Autocomplete`, allowMultiple: o });
  };
Qn.__docgenInfo = { description: "", methods: [], displayName: "PolarisFixedOptionsCombobox" };
const Xn = ne((e) => {
  const { options: t, loading: n, rolesError: r, fieldError: s, selectedRoleKeys: o, fieldProps: i, metadata: l } = ro(e);
  if (r) throw r;
  if (s) throw s;
  return n || !t || t.length === 0
    ? null
    : a.createElement(Qn, { options: t, allowMultiple: !0, label: e.label ?? l.name, ...tt(i), value: o });
});
Xn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoRolesInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const so = (e) => {
    const { apiIdentifier: t, namespace: n } = e,
      r = pn(),
      s = gn(r, t, n);
    if (!s) {
      const o = [...(n ?? []), t].join(".");
      throw new Error(`no model manager for "${o}" found for action function`);
    }
    return s;
  },
  nt = 25,
  oo = (e) => {
    var f, m, p;
    const { field: t } = e,
      { metadata: n } = pe(t),
      { findBy: r } = rt(),
      s = n.configuration.fieldType === F.HasMany,
      o = n.configuration,
      i = (f = o.relatedModel) == null ? void 0 : f.apiIdentifier,
      l = (m = o.relatedModel) == null ? void 0 : m.namespace,
      c = "inverseField" in o ? ((p = o.inverseField) == null ? void 0 : p.apiIdentifier) : void 0;
    return {
      relatedModelRecords: co({
        relatedModel: { apiIdentifier: i, namespace: l },
        filter: s ? io({ enabled: !1, relatedModelInverseFieldApiId: c, findBy: r }) : void 0,
      }),
    };
  },
  io = (e) => {
    const { enabled: t, relatedModelInverseFieldApiId: n, findBy: r } = e;
    if (!(!t || !n)) return { OR: [{ [n + "Id"]: { isSet: !1 } }, ...(r !== void 0 ? [{ [n + "Id"]: { equals: r } }] : [])] };
  },
  Ft = (e, t) => {
    var s;
    const { metadata: n } = pe(e),
      r = n.configuration;
    return ia(
      t ?? ((s = r.relatedModel) == null ? void 0 : s.defaultDisplayField.apiIdentifier),
      "Option label is required for relationships"
    );
  },
  er = (e) => {
    const { field: t } = e,
      n = Ft(t, e.optionLabel),
      { relatedModelRecords: r } = oo(e),
      { relatedModel: s, pagination: o, search: i } = r,
      l = () => hn(nr(s.records, n, e.secondaryLabel, e.tertiaryLabel), "id"),
      [c, u] = d.useState(l()),
      f = lo(s.records);
    return (
      d.useEffect(() => {
        s.fetching || u(l());
      }, [s.fetching, f]),
      {
        options: c,
        searchFilterOptions: c.filter((m) => (i.value ? `${m.label}`.toLowerCase().includes(i.value.toLowerCase()) : !0)),
        relatedModel: s,
        pagination: o,
        search: i,
      }
    );
  },
  vt = (e, t) => (typeof t == "string" ? e[t] : Array.isArray(t) ? t.map((n) => e[n]).join(" ") : t(e)),
  lo = (e) =>
    e == null
      ? void 0
      : e
          .map((t) => t.id)
          .sort()
          .join(","),
  tr = (e, t, n, r) => ({ id: e.id, label: vt(e, t), secondaryLabel: n ? vt(e, n) : void 0, tertiaryLabel: r ? vt(e, r) : void 0 }),
  nr = (e, t, n, r) => (e == null ? void 0 : e.map((s) => tr(s, t, n, r))) ?? [],
  co = (e) => {
    const { optionLabel: t, relatedModel: n } = e;
    let r;
    t && typeof t == "string" ? (r = { id: !0, [t]: !0 }) : t && Array.isArray(t) && (r = t.reduce((b, y) => ((b[y] = !0), b), { id: !0 }));
    const s = so(n),
      [o, i] = d.useState([]),
      [l, c] = d.useState(void 0),
      [u, f] = d.useState(),
      [{ data: m, fetching: p, error: g }, E] = la(s, {
        first: nt,
        ...(e.filter && { filter: e.filter }),
        ...(l && { after: l }),
        ...(u && { search: u }),
        ...(r && { select: r }),
      }),
      v = !!(m != null && m.hasNextPage),
      h = d.useCallback(() => c(void 0), []),
      P = d.useCallback(() => {
        m && m.length >= nt && v && m.endCursor && c(m.endCursor);
      }, [m]),
      A = d.useCallback((b) => {
        h(), f(b === "" ? void 0 : b);
      }, []);
    return (
      d.useEffect(() => {
        if (p || !m) return;
        const b = [...o, ...m.map((k) => k)],
          y = hn(b, "id"),
          I = ca(y, "id");
        i(I);
      }, [l, u, p]),
      {
        relatedModel: { records: o, error: g, fetching: p },
        pagination: { clearPagination: h, loadNextPage: P, hasNextPage: v },
        search: { value: u, set: A },
      }
    );
  },
  uo = (e) => {
    var m;
    const { field: t, primaryLabel: n, secondaryLabel: r, tertiaryLabel: s } = e,
      o = pe(t),
      { path: i } = o,
      l = ua({ name: i }),
      c = er({ field: t, optionLabel: n, secondaryLabel: r, tertiaryLabel: s }),
      u = c.relatedModel.fetching,
      f = (m = c.relatedModel.error) == null ? void 0 : m.message;
    return { record: l, fieldMetadata: o, relatedModelOptions: c, isLoading: u, errorMessage: f };
  },
  fo = (e) => {
    const { field: t, control: n, optionLabel: r } = e,
      { fieldMetadata: s, relatedModelOptions: o, isLoading: i, errorMessage: l } = uo({ field: t, primaryLabel: r }),
      { path: c } = s,
      {
        field: { value: u, onChange: f },
      } = mo({ name: c, control: n }),
      {
        danglingSelectedRecordId: m,
        selectedRecord: p,
        maybeClearDanglingSelectedRecord: g,
      } = po({ path: c, relatedModelOptions: o, selectedRecordIdFromController: u }),
      E = d.useCallback(
        (h) => {
          f(h.id);
        },
        [f]
      ),
      v = d.useCallback(() => {
        f(null), g();
      }, [f, g]);
    return {
      fieldMetadata: s,
      relatedModelOptions: o,
      onSelectRecord: E,
      onRemoveRecord: v,
      selectedRecord: p,
      danglingSelectedRecordId: m,
      isLoading: i,
      errorMessage: l,
    };
  },
  mo = (e) => {
    const { name: t, control: n } = e,
      {
        field: { value: r, onChange: s },
      } = Fe({ name: t, control: n }),
      o = r == null ? void 0 : r.id,
      i = d.useCallback(
        (l) => {
          s({ id: l });
        },
        [s]
      );
    return { field: { value: o, onChange: i } };
  },
  po = (e) => {
    const { path: t, relatedModelOptions: n, selectedRecordIdFromController: r } = e,
      { getValues: s, setValue: o } = yn(),
      i = s(t),
      l = s(`${t}Id`),
      c = l == null,
      u = !c && i === null && l ? l : void 0,
      f = d.useCallback(() => {
        o(`${t}Id`, null);
      }, [o, t]),
      m = n.relatedModel.records.find((p) => p.id === r) ?? i;
    return { noSelectedRecord: c, danglingSelectedRecordId: u, maybeClearDanglingSelectedRecord: f, selectedRecord: m };
  },
  rr = (e) => {
    const { label: t, id: n, selected: r } = e;
    return typeof t == "string"
      ? a.createElement(j.Option, { key: n, value: n, selected: r }, t)
      : a.createElement(j.Action, { key: n, value: n, selected: r }, t);
  },
  Dt = (e) => a.createElement("div", { style: { padding: "16px" } }, a.createElement(te, { as: "p", tone: "subdued" }, e.message)),
  ar = () => a.createElement(Dt, { message: "No records found" }),
  go = (e) =>
    e.includes("GGT_PERMISSION_DENIED")
      ? "Missing permissions. Cannot read related model"
      : e.includes("GGT_INVALID_STORED_DATA")
      ? "Invalid records found in related model"
      : "Cannot retrieve records from related model";
rr.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "SelectableOption",
  props: {
    label: { required: !0, tsType: { name: "ReactReactNode", raw: "React.ReactNode" }, description: "" },
    id: { required: !0, tsType: { name: "string" }, description: "" },
    selected: { required: !0, tsType: { name: "boolean" }, description: "" },
  },
};
Dt.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "ListMessage",
  props: { message: { required: !0, tsType: { name: "string" }, description: "" } },
};
ar.__docgenInfo = { description: "", methods: [], displayName: "NoRecordsMessage" };
const _t = (e) => {
  const { checkSelected: t, onSelect: n, isLoading: r, errorMessage: s, options: o, records: i, actions: l } = e,
    c = [
      ...(l ?? []),
      ...o.map((u) =>
        e.renderOption ? e.renderOption(u) : a.createElement(rr, { ...u, selected: (t == null ? void 0 : t(u.id)) ?? !1, key: u.id })
      ),
    ];
  return a.createElement(
    j,
    {
      autoSelection: e.autoSelection,
      onSelect: (u) => {
        const f = (i == null ? void 0 : i.find((E) => E.id === u)) ?? { id: u },
          { createdAt: m, updatedAt: p, ...g } = f;
        n(g);
      },
    },
    c.length ? c : s ? a.createElement(Dt, { message: go(s) }) : a.createElement(ar, null),
    r && a.createElement(j.Loading, { accessibilityLabel: "Loading" })
  );
};
_t.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "RelatedModelOptions",
  props: {
    options: { required: !0, tsType: { name: "Array", elements: [{ name: "Option" }], raw: "Option[]" }, description: "" },
    records: {
      required: !1,
      tsType: {
        name: "Array",
        elements: [{ name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }],
        raw: "Record<string, any>[]",
      },
      description: "",
    },
    isLoading: { required: !1, tsType: { name: "boolean" }, description: "" },
    errorMessage: { required: !1, tsType: { name: "string" }, description: "" },
    checkSelected: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(id: string) => boolean",
        signature: { arguments: [{ type: { name: "string" }, name: "id" }], return: { name: "boolean" } },
      },
      description: "",
    },
    onSelect: {
      required: !0,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(record: Record<string, any>) => void",
        signature: {
          arguments: [
            { type: { name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }, name: "record" },
          ],
          return: { name: "void" },
        },
      },
      description: "",
    },
    autoSelection: { required: !1, tsType: { name: "AutoSelection" }, description: "" },
    actions: {
      required: !1,
      tsType: { name: "Array", elements: [{ name: "ReactReactNode", raw: "React.ReactNode" }], raw: "React.ReactNode[]" },
      description: "",
    },
    renderOption: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(option: Option) => React.ReactNode",
        signature: {
          arguments: [{ type: { name: "Option" }, name: "option" }],
          return: { name: "ReactReactNode", raw: "React.ReactNode" },
        },
      },
      description: "",
    },
  },
};
const sr = ne((e) => {
  const {
      fieldMetadata: { path: t, metadata: n },
      relatedModelOptions: { options: r, searchFilterOptions: s, pagination: o, search: i, relatedModel: l },
      isLoading: c,
      errorMessage: u,
      selectedRecord: f,
      danglingSelectedRecordId: m,
      onSelectRecord: p,
      onRemoveRecord: g,
    } = fo(e),
    E = Ft(e.field, e.optionLabel),
    v = f ? tr(f, E) : null,
    h =
      v && v.id
        ? a.createElement(
            je,
            { onRemove: g, key: `selectedRecordTag_${v.id}` },
            a.createElement("p", { id: `${v.id}_${v.label}` }, v.label)
          )
        : m
        ? a.createElement(
            je,
            { onRemove: g, key: `selectedRecordTag_${m}` },
            a.createElement("p", { id: `${m}`, style: { color: "red" } }, "id: ", m)
          )
        : null,
    P = (A) => {
      const b = A.id;
      (f == null ? void 0 : f.id) === b ? g() : p(A);
    };
  return a.createElement(
    a.Fragment,
    null,
    a.createElement(
      he,
      {
        activator: a.createElement(he.TextField, {
          requiredIndicator: n.requiredArgumentForInput,
          onChange: i.set,
          value: i.value,
          name: t,
          label: e.label ?? n.name,
          placeholder: "Search",
          autoComplete: "off",
          verticalContent: h,
        }),
        onScrolledToBottom: o.loadNextPage,
        willLoadMoreOptions: o.hasNextPage && r.length >= nt,
      },
      a.createElement(_t, {
        isLoading: c,
        errorMessage: u,
        checkSelected: (A) => A === (f == null ? void 0 : f.id),
        onSelect: P,
        options: s,
        records: l.records,
      })
    )
  );
});
sr.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoBelongsToInput" };
const yo = (e) => {
    const { field: t } = e,
      n = pe(t),
      { path: r } = n,
      s = da({ name: r, keyName: "_fieldArrayKey" }),
      o = d.useMemo(
        () =>
          s.fields.map((i) => {
            const { _fieldArrayKey: l, ...c } = i;
            return c;
          }),
        [s.fields]
      );
    return { fieldArrayPath: r, fieldMetadata: n, fieldArray: s, records: o };
  },
  ho = (e) => {
    var P;
    const { field: t } = e,
      { fieldMetadata: n, fieldArray: r, records: s } = yo({ field: t }),
      { metadata: o } = n,
      i = d.useMemo(() => {
        var A;
        return (A = o.configuration.inverseField) == null ? void 0 : A.apiIdentifier;
      }, [o.configuration]),
      { remove: l, append: c, update: u } = r,
      f = er(e),
      { relatedModel: m } = f,
      p = (P = m.error) == null ? void 0 : P.message,
      g = m.fetching,
      E = d.useMemo(() => (s ?? []).filter((A) => !("_unlink" in A && A._unlink)), [s]),
      v = d.useCallback(
        (A) => {
          const b = s.findIndex((y) => y.id === A.id);
          b < 0 || ("_link" in A ? l(b) : u(b, { ...A, _unlink: { id: A.id, inverseFieldApiIdentifier: i } }));
        },
        [i, s, l, u]
      ),
      h = d.useCallback(
        (A) => {
          const b = (s ?? []).findIndex((y) => y.id === A.id);
          if (b >= 0) {
            const y = s[b];
            if ("_unlink" in y && y._unlink) {
              const { _unlink: I, ...k } = y;
              u(b, k);
            } else v(A);
          } else c({ ...A, _link: A.id });
        },
        [s, v, u, c]
      );
    return {
      fieldMetadata: n,
      relatedModelOptions: f,
      selectedRecords: E,
      errorMessage: p,
      isLoading: g,
      onSelectRecord: h,
      onRemoveRecord: v,
    };
  },
  or = (e) => (e.selectedRecords.length ? a.createElement(bo, { ...e }) : null),
  bo = (e) => {
    const { selectedRecords: t, optionLabel: n, onRemoveRecord: r } = e,
      s = nr(t, n);
    return s.length
      ? s.map((o) =>
          a.createElement(
            je,
            {
              key: `option${o.id}`,
              onRemove: () => {
                const i = t.find((l) => l.id === o.id);
                r(i ?? { id: o.id });
              },
            },
            o.label
          )
        )
      : null;
  };
or.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "getSelectedRelatedRecordTags",
  props: {
    selectedRecords: {
      required: !0,
      tsType: {
        name: "Array",
        elements: [{ name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }],
        raw: "Record<string, any>[]",
      },
      description: "",
    },
    optionLabel: { required: !0, tsType: { name: "OptionLabel" }, description: "" },
    onRemoveRecord: {
      required: !0,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(record: Record<string, any>) => void",
        signature: {
          arguments: [
            { type: { name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }, name: "record" },
          ],
          return: { name: "void" },
        },
      },
      description: "",
    },
  },
};
const ir = ne((e) => {
  const { field: t } = e,
    {
      fieldMetadata: { path: n, metadata: r },
      relatedModelOptions: { options: s, searchFilterOptions: o, search: i, pagination: l, relatedModel: c },
      selectedRecords: u,
      errorMessage: f,
      isLoading: m,
      onSelectRecord: p,
      onRemoveRecord: g,
    } = ho(e),
    E = Ft(t, e.optionLabel),
    v = d.useMemo(() => u.map((h) => h.id).filter((h) => !!h), [u]);
  return a.createElement(
    a.Fragment,
    null,
    a.createElement(
      he,
      {
        activator: a.createElement(he.TextField, {
          onChange: i.set,
          value: i.value,
          label: e.label ?? r.name,
          name: n,
          placeholder: "Search",
          autoComplete: "off",
          verticalContent: or({ selectedRecords: u, onRemoveRecord: g, optionLabel: E }),
        }),
        onScrolledToBottom: l.loadNextPage,
        allowMultiple: !0,
        willLoadMoreOptions: l.hasNextPage && s.length >= nt,
      },
      a.createElement(_t, {
        onSelect: p,
        records: c.records,
        options: o,
        checkSelected: (h) => v.includes(h),
        errorMessage: f,
        isLoading: m,
      })
    )
  );
});
ir.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoHasManyInput" };
const lr = ne((e) => {
  const { metadata: t } = pe(e.field);
  switch (t.configuration.fieldType) {
    case F.Id:
      return a.createElement(Gn, { field: e.field, label: e.label });
    case F.String:
    case F.Email:
    case F.Color:
    case F.Url:
      return a.createElement(Ze, { field: e.field, label: e.label });
    case F.Number:
      return a.createElement(Yn, { field: e.field, label: e.label });
    case F.EncryptedString:
      return a.createElement(wt, { field: e.field, label: e.label });
    case F.Password:
      return a.createElement(Jn, { field: e.field, label: e.label });
    case F.Boolean:
      return a.createElement(Un, { field: e.field, label: e.label });
    case F.DateTime:
      return a.createElement(Wn, { field: e.field, label: e.label });
    case F.Json:
      return a.createElement(Kn, { field: e.field, label: e.label });
    case F.Enum:
      return a.createElement(zn, { field: e.field, label: e.label });
    case F.File:
      return a.createElement(Zn, { field: e.field, label: e.label });
    case F.RoleAssignments:
      return a.createElement(Xn, { field: e.field, label: e.label });
    case F.BelongsTo:
      return a.createElement(sr, { field: e.field, label: e.label });
    case F.HasOne:
      return null;
    case F.HasMany:
      return a.createElement(ir, { field: e.field, label: e.label });
    case F.HasManyThrough:
      return null;
    case F.RichText:
      return a.createElement(Vn, { field: e.field, label: e.label });
    case F.Money:
      return null;
    case F.Vector:
    case F.Computed:
      return null;
    default:
      throw new Error(`Unsupported field type for Polaris AutoForm: ${t.fieldType}`);
  }
});
lr.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
const cr = (e) => {
  const { submitResult: t } = rt(),
    n = t.isSubmitting;
  return a.createElement(Se, { submit: !0, loading: e.isSubmitting ?? n, ...e }, e.children ?? "Submit");
};
cr.__docgenInfo = {
  description: `Button for submitting the AutoForm values

The submission is handled by the  \`submit\` property on Button
Alternatively, the \`submit\` function from useAutoFormMetadata can be used to submit the form

const { submit } = useAutoFormMetadata();`,
  methods: [],
  displayName: "PolarisAutoSubmit",
  props: {
    children: { required: !1, tsType: { name: "ReactNode" }, description: "" },
    isSubmitting: { required: !1, tsType: { name: "boolean" }, description: "" },
  },
};
const ur = () => {
    const { metadata: e, submitResult: t } = rt(),
      [n, r] = d.useState(!0),
      [s, o] = d.useState(void 0),
      i = d.useCallback(() => r(!0), []);
    d.useEffect(() => {
      (!t.isSuccessful && !t.error) || (o(t), r(!1));
    }, [t]);
    const l = d.useMemo(() => {
      var c;
      if (s != null && s.isSuccessful)
        return e && Ie(e) ? `Saved ${`${e == null ? void 0 : e.name} `}successfully.` : `${e == null ? void 0 : e.name} succeeded.`;
      if (s != null && s.error) return (c = s == null ? void 0 : s.error) == null ? void 0 : c.message;
    }, [s, e]);
    return { show: !n, hide: i, successful: s == null ? void 0 : s.isSuccessful, title: l };
  },
  vo = (e) =>
    a.createElement(a.Fragment, null, a.createElement(Ot, { ...e.successBannerProps }), a.createElement(Rt, { ...e.errorBannerProps })),
  Ot = (e) => {
    const { show: t, hide: n, successful: r, ...s } = ur();
    return !t || !r ? null : a.createElement(bn, { tone: "success", onDismiss: n, ...s, ...e });
  },
  Rt = (e) => {
    const { show: t, hide: n, successful: r, ...s } = ur();
    return !t || r ? null : a.createElement(bn, { tone: "critical", onDismiss: n, ...s, ...e });
  };
vo.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisSubmitResultBanner",
  props: {
    successBannerProps: { required: !1, tsType: { name: "BannerProps" }, description: "" },
    errorBannerProps: { required: !1, tsType: { name: "BannerProps" }, description: "" },
  },
};
Ot.__docgenInfo = { description: "", methods: [], displayName: "PolarisSubmitSuccessfulBanner" };
Rt.__docgenInfo = { description: "", methods: [], displayName: "PolarisSubmitErrorBanner" };
const dr = () => a.createElement(a.Fragment, null, a.createElement(as, { size: "medium" }), a.createElement(ya, null)),
  Eo = (e) => {
    const { action: t, findBy: n } = e;
    Os(e);
    const r = `${t.modelApiIdentifier ?? ""}.${t.operationName}.${JSON.stringify(n)}`;
    return a.createElement(Po, { key: r, ...e });
  },
  Po = (e) => {
    const { record: t, action: n, findBy: r, ...s } = e,
      {
        metadata: o,
        fetchingMetadata: i,
        isLoading: l,
        metadataError: c,
        fields: u,
        submit: f,
        formError: m,
        isSubmitting: p,
        isSubmitSuccessful: g,
        originalFormMethods: E,
      } = Us(e),
      v = e.title === void 0 ? fa(n.operationName) : e.title;
    if (e.successContent && g) return e.successContent;
    if (i || l) return a.createElement(Vt, { ...s, onSubmit: f }, a.createElement(ma, null, a.createElement(dr, null)));
    const h = {
        findBy: r,
        submit: f,
        metadata: o,
        submitResult: { isSuccessful: g, error: m ?? c, isSubmitting: p },
        model: { apiIdentifier: n.modelApiIdentifier, namespace: n.namespace },
        fields: u,
      },
      P =
        e.children ??
        a.createElement(
          a.Fragment,
          null,
          v && a.createElement(te, { variant: "headingLg", as: "h5" }, v),
          !e.onSuccess && a.createElement(Ot, null),
          !e.onFailure && a.createElement(Rt, null),
          !c &&
            a.createElement(
              a.Fragment,
              null,
              u.map(({ metadata: A }) => a.createElement(lr, { field: A.apiIdentifier, key: A.apiIdentifier })),
              a.createElement("div", null, a.createElement(cr, null, e.submitLabel ?? "Submit", " "))
            )
        );
    return a.createElement(
      pa.Provider,
      { value: h },
      a.createElement(ga, { ...E }, a.createElement(Vt, { ...s, onSubmit: f }, a.createElement(kt, { gap: "400" }, P)))
    );
  };
dr.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoFormSkeleton" };
Eo.__docgenInfo = {
  description: "Renders a form for an action on a model automatically using Polaris",
  methods: [],
  displayName: "PolarisAutoForm",
  props: {
    action: { required: !0, tsType: { name: "ActionFunc" }, description: "Which action this fom will run on submit" },
    record: {
      required: !1,
      tsType: { name: "GadgetRecord", elements: [{ name: "any" }], raw: "GadgetRecord<any>" },
      description: "A record for this form to act on",
    },
    include: {
      required: !1,
      tsType: { name: "Array", elements: [{ name: "string" }], raw: "string[]" },
      description: "An allowlist of fields to render within the form. Only these fields will be rendered as inputs.",
    },
    exclude: {
      required: !1,
      tsType: { name: "Array", elements: [{ name: "string" }], raw: "string[]" },
      description: "A denylist of fields to render within the form. Every field except these fields will be rendered as inputs.",
    },
    defaultValues: {
      required: !1,
      tsType: { name: "DefaultValues" },
      description: "A set of field values to pre-populate the form with on load. Only applies to create forms.",
    },
    submitLabel: {
      required: !1,
      tsType: { name: "ReactNode" },
      description: "The label to use for the submit button at the bottom of the form",
    },
    successContent: {
      required: !1,
      tsType: { name: "ReactNode" },
      description: "What to show the user once the form has been submitted successfully",
    },
    title: {
      required: !1,
      tsType: { name: "union", raw: "string | false", elements: [{ name: "string" }, { name: "literal", value: "false" }] },
      description: "The title at the top of the form. False to omit",
    },
    onSuccess: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(record: UseActionFormHookStateData<ActionFunc>) => void",
        signature: { arguments: [{ type: { name: "unknown" }, name: "record" }], return: { name: "void" } },
      },
      description: "Called when the form submission completes successfully on the backend",
    },
    onFailure: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: '(error: Error | FieldErrors<ActionFunc["variablesType"]>) => void',
        signature: {
          arguments: [
            {
              type: {
                name: "union",
                raw: 'Error | FieldErrors<ActionFunc["variablesType"]>',
                elements: [
                  { name: "Error" },
                  {
                    name: "FieldErrors",
                    elements: [{ name: 'ActionFunc["variablesType"]', raw: 'ActionFunc["variablesType"]' }],
                    raw: 'FieldErrors<ActionFunc["variablesType"]>',
                  },
                ],
              },
              name: "error",
            },
          ],
          return: { name: "void" },
        },
      },
      description: "Called when the form submission errors before sending, during the API call, or if the API call returns an error.",
    },
    children: {
      required: !1,
      tsType: { name: "ReactNode" },
      description: "Custom components to render within the form. Using this will override all default field rendering.",
    },
    debug: { required: !1, tsType: { name: "boolean" }, description: "Enable debug logging for this form" },
  },
};
export { Eo as P, vn as S, cr as a, lr as b, zn as c, vo as d, Jn as e, Un as f, Zn as g, Kn as h, Ze as i, ne as j, at as u };
