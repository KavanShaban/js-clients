import {
  a8 as $n,
  T as $t,
  a9 as Bn,
  _ as Ct,
  ab as Hn,
  O as Le,
  w as Ln,
  X as On,
  a6 as Rn,
  aa as Ue,
  ac as Un,
  a1 as Vn,
  a3 as Wn,
  F as Yn,
  a2 as Ze,
  a4 as Zn,
  Q as je,
  a5 as jn,
  J as q,
  a7 as qn,
  a0 as zn,
} from "./apis-0c1c184f.js";
import {
  a1 as At,
  ad as Ca,
  $ as De,
  S as Ea,
  B as Ee,
  T as K,
  a5 as Ne,
  a8 as Pa,
  m as Pe,
  o as Re,
  ab as St,
  ac as Ta,
  L as Vt,
  d as Wt,
  K as Xe,
  aa as Yt,
  N as Zt,
  x as _e,
  H as aa,
  a4 as ba,
  g as ca,
  Z as da,
  n as et,
  s as fa,
  G as ft,
  a2 as ga,
  a6 as ha,
  Q as ia,
  Y as jt,
  a as ke,
  R as la,
  _ as ma,
  U as oa,
  h as pa,
  b as pt,
  J as ra,
  O as sa,
  c as te,
  V as tt,
  X as ua,
  a7 as va,
  I as ve,
  y as we,
  a9 as xa,
  u as xe,
  a3 as ya,
  a0 as ze,
  C as zt,
} from "./dateTimeUtils-a817f99d.js";
import { _ as na } from "./iframe-35b6cbe2.js";
import { R as n, r } from "./index-7c191284.js";
import {
  e as Bt,
  a as G,
  f as Gn,
  o as Ht,
  c as Jn,
  d as Kn,
  g as Qn,
  i as Ut,
  h as Xn,
  b as Ye,
  v as ea,
  j as ta,
} from "./useResultBannerController-cd95b20f.js";
var Jt = function (t) {
  return n.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    n.createElement("path", {
      fillRule: "evenodd",
      d: "M16.5 10a.75.75 0 0 1-.75.75h-9.69l2.72 2.72a.75.75 0 0 1-1.06 1.06l-4-4a.75.75 0 0 1 0-1.06l4-4a.75.75 0 1 1 1.06 1.06l-2.72 2.72h9.69a.75.75 0 0 1 .75.75Z",
    })
  );
};
Jt.displayName = "ArrowLeftIcon";
var Kt = function (t) {
  return n.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    n.createElement("path", {
      fillRule: "evenodd",
      d: "M3.5 10a.75.75 0 0 1 .75-.75h9.69l-2.72-2.72a.75.75 0 1 1 1.06-1.06l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06-1.06l2.72-2.72h-9.69a.75.75 0 0 1-.75-.75Z",
    })
  );
};
Kt.displayName = "ArrowRightIcon";
var Gt = function (t) {
  return n.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    n.createElement("path", {
      fillRule: "evenodd",
      d: "M7.75 3.5a.75.75 0 0 0-1.5 0v.407a3.075 3.075 0 0 0-.702.252 3.75 3.75 0 0 0-1.64 1.639c-.226.444-.32.924-.365 1.47-.043.531-.043 1.187-.043 2v1.464c0 .813 0 1.469.043 2 .045.546.14 1.026.366 1.47a3.75 3.75 0 0 0 1.639 1.64c.444.226.924.32 1.47.365.531.043 1.187.043 2 .043h3.383c.323 0 .542 0 .735-.02a3.75 3.75 0 0 0 3.344-3.344c.02-.193.02-.412.02-.735v-2.883c0-.813 0-1.469-.043-2-.045-.546-.14-1.026-.366-1.47a3.75 3.75 0 0 0-1.639-1.64 3.076 3.076 0 0 0-.702-.251v-.407a.75.75 0 0 0-1.5 0v.259c-.373-.009-.794-.009-1.268-.009h-1.964c-.474 0-.895 0-1.268.009v-.259Zm-1.521 1.995c.197-.1.458-.17.912-.207.462-.037 1.057-.038 1.909-.038h1.9c.853 0 1.447 0 1.91.038.453.037.714.107.912.207.423.216.767.56.983.984.1.197.17.458.207.912.014.18.024.38.029.609h-9.982c.006-.228.015-.429.03-.61.036-.453.106-.714.206-.911a2.25 2.25 0 0 1 .984-.984Zm-1.229 4.005v1.2c0 .853 0 1.447.038 1.91.037.453.107.714.207.912.216.423.56.767.984.983.197.1.458.17.912.207.462.037 1.057.038 1.909.038h3.306c.385 0 .52-.001.626-.012a2.25 2.25 0 0 0 2.006-2.006c.011-.106.012-.241.012-.626v-2.606h-10Z",
    })
  );
};
Gt.displayName = "CalendarIcon";
var Qt = function (t) {
  return n.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    n.createElement("path", { d: "M10.75 6a.75.75 0 0 0-1.5 0v4c0 .199.079.39.22.53l2 2a.75.75 0 1 0 1.06-1.06l-1.78-1.78v-3.69Z" }),
    n.createElement("path", {
      fillRule: "evenodd",
      d: "M17 10a7 7 0 1 1-14 0 7 7 0 0 1 14 0Zm-1.5 0a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z",
    })
  );
};
Qt.displayName = "ClockIcon";
var gt = function (t) {
  return n.createElement(
    "svg",
    Object.assign({ viewBox: "0 0 20 20" }, t),
    n.createElement("path", {
      d: "M16.5 6.26a.75.75 0 0 1-1.5 0v-.51a.75.75 0 0 0-.75-.75h-8.5a.75.75 0 0 0-.75.75v.51a.75.75 0 0 1-1.5 0v-.51a2.25 2.25 0 0 1 2.25-2.25h8.5a2.25 2.25 0 0 1 2.25 2.25v.51Z",
    }),
    n.createElement("path", {
      d: "M10.75 16.01a.75.75 0 0 1-1.5 0v-6.69l-1.72 1.72a.75.75 0 1 1-1.06-1.06l3-3a.75.75 0 0 1 1.06 0l3 3a.75.75 0 1 1-1.06 1.06l-1.72-1.72v6.69Z",
    })
  );
};
gt.displayName = "UploadIcon";
function Aa(e) {
  return typeof e[0] == "object" && Object.prototype.hasOwnProperty.call(e[0], "options");
}
var Sa = { Loading: "Polaris-Autocomplete__Loading", SectionWrapper: "Polaris-Autocomplete__SectionWrapper" },
  Ve = {
    Content: "Polaris-Autocomplete-MappedOption__Content",
    Media: "Polaris-Autocomplete-MappedOption__Media",
    singleSelectionMedia: "Polaris-Autocomplete-MappedOption--singleSelectionMedia",
    disabledMedia: "Polaris-Autocomplete-MappedOption--disabledMedia",
  },
  Ia = { Listbox: "Polaris-Listbox" };
const Xt = r.createContext(void 0),
  en = r.createContext({}),
  tn = r.createContext({});
function Da() {
  const e = r.useContext(Xt);
  if (!e) throw new Error("No Combobox was provided. Your component must be wrapped in a <Combobox> component.");
  return e;
}
function ka() {
  return r.useContext(en);
}
function wa(e, t) {
  const a = t.scrollTop,
    s = a + t.clientHeight,
    { offsetHeight: c } = e,
    { offsetTop: i } = e,
    o = i + c;
  if (!(i > a && o < s)) {
    let u = 0;
    o > s ? (u = o + c * 0.85 - s) : i < a && (u = i - c * 0.15 - a),
      requestAnimationFrame(() => {
        t.scrollBy({ top: u, behavior: "auto" });
      });
  }
}
var be = {
  TextOption: "Polaris-Listbox-TextOption",
  allowMultiple: "Polaris-Listbox-TextOption--allowMultiple",
  isAction: "Polaris-Listbox-TextOption--isAction",
  disabled: "Polaris-Listbox-TextOption--disabled",
  selected: "Polaris-Listbox-TextOption--selected",
  Content: "Polaris-Listbox-TextOption__Content",
  Checkbox: "Polaris-Listbox-TextOption__Checkbox",
};
const yt = r.memo(function ({ children: t, selected: a, disabled: s }) {
  const { allowMultiple: c } = r.useContext(tn),
    i = r.useContext(ft),
    o = te(be.TextOption, a && !c && be.selected, s && be.disabled, c && be.allowMultiple, i && be.isAction),
    l = a
      ? n.createElement(
          ke,
          { width: "100%" },
          n.createElement(
            ve,
            { wrap: !1, align: "space-between", gap: "200" },
            t,
            n.createElement(ve, { align: "end" }, n.createElement(Pe, { source: aa }))
          )
        )
      : n.createElement(n.Fragment, null, t);
  return n.createElement(
    "div",
    { className: o },
    n.createElement(
      "div",
      { className: be.Content },
      c && !i ? n.createElement("div", { className: be.Checkbox }, n.createElement(zt, { disabled: s, checked: a, label: t })) : l
    )
  );
});
var It = { ListItem: "Polaris-Listbox-Loading__ListItem", Loading: "Polaris-Listbox-Loading" };
function nn() {
  const e = r.useContext(Vt);
  if (!e) throw new Error("No Listbox was provided. Listbox components must be wrapped in a Listbox");
  return e;
}
const Fa = r.memo(function ({ children: t, accessibilityLabel: a }) {
    const { setLoading: s } = nn();
    return (
      r.useEffect(
        () => (
          s(a),
          () => {
            s(void 0);
          }
        ),
        [a, s]
      ),
      n.createElement(
        "li",
        { className: It.ListItem, role: "presentation" },
        t || n.createElement("div", { className: It.Loading }, n.createElement(ra, { size: "small", accessibilityLabel: a }))
      )
    );
  }),
  Ma = { props: { "data-polaris-listbox-section-item": !0 }, selector: "[data-polaris-listbox-section-item]" },
  _a = { attribute: "data-polaris-listbox-within-section-item" },
  an = r.createContext(null);
var Dt = { SectionGroup: "Polaris-Listbox-Section__SectionGroup", noDivider: "Polaris-Listbox-Section--noDivider" };
function Na({ children: e, divider: t = !0, title: a }) {
  const s = r.useId();
  return n.createElement(
    an.Provider,
    { value: s },
    n.createElement(
      "li",
      Object.assign({ role: "presentation" }, Ma.props),
      a,
      n.createElement("ul", { role: "group", "aria-labelledby": s, className: te(Dt.SectionGroup, !t && Dt.noDivider) }, e)
    )
  );
}
function rn() {
  return r.useContext(an);
}
function Oa({ children: e }) {
  const t = rn() || "",
    a =
      typeof e == "string"
        ? n.createElement(
            ke,
            { paddingBlockStart: "200", paddingInlineStart: "400", paddingBlockEnd: "200", paddingInlineEnd: "400" },
            n.createElement(K, { as: "span", variant: "headingSm", tone: "subdued" }, e)
          )
        : e;
  return n.createElement("div", { "aria-hidden": !0, id: t }, a);
}
var nt = { Action: "Polaris-Listbox-Action", ActionDivider: "Polaris-Listbox-Action__ActionDivider", Icon: "Polaris-Listbox-Action__Icon" },
  kt = { Option: "Polaris-Listbox-Option", divider: "Polaris-Listbox-Option--divider" };
const on = r.createContext({}),
  sn = r.memo(function ({ value: t, children: a, selected: s, disabled: c = !1, accessibilityLabel: i, divider: o }) {
    const { onOptionSelect: l } = nn(),
      u = r.useContext(ft),
      { role: d, url: m, external: f, onAction: x, destructive: h } = r.useContext(on),
      C = r.useRef(null),
      y = r.useId(),
      T = !!rn(),
      S = r.useCallback(
        (D) => {
          D.preventDefault(), D.stopPropagation(), x && x(), C.current && !x && l({ domId: y, value: t, element: C.current, disabled: c });
        },
        [y, l, t, c, x]
      ),
      I = (D) => {
        D.preventDefault();
      },
      p = typeof a == "string" ? n.createElement(yt, { selected: s, disabled: c }, a) : a,
      b = { [_a.attribute]: T },
      P = d || "option",
      E = m ? n.createElement(oa, { url: m, external: f }, p) : p;
    return n.createElement(
      "li",
      Object.assign({}, b, {
        "data-listbox-option": !0,
        "data-listbox-option-action": u,
        "data-listbox-option-value": t,
        "data-listbox-option-destructive": h,
        "data-within-section": T,
        className: te(kt.Option, o && kt.divider),
        id: y,
        ref: C,
        tabIndex: -1,
        role: P,
        "aria-label": i,
        "aria-selected": s,
        "aria-disabled": c,
        onClick: c ? void 0 : S,
        onKeyDown: c ? void 0 : S,
        onMouseDown: I,
      }),
      E
    );
  });
function La(e) {
  const { selected: t, disabled: a, children: s, icon: c, divider: i } = e,
    o = c && n.createElement("div", { className: nt.Icon }, n.createElement(Pe, { tone: "subdued", source: c })),
    l = te(nt.Action, i && nt.ActionDivider);
  return n.createElement(
    ft.Provider,
    { value: !0 },
    n.createElement(sn, e, n.createElement("div", { className: l }, n.createElement(yt, { selected: t, disabled: a }, o, s)))
  );
}
let ge;
(function (e) {
  (e.FirstSelected = "FIRST_SELECTED"), (e.First = "FIRST"), (e.None = "NONE");
})(ge || (ge = {}));
const Ra = "[data-listbox-option]",
  at = "data-listbox-option-value",
  qa = "data-listbox-option-action",
  wt = "data-focused";
function L({
  children: e,
  autoSelection: t = ge.FirstSelected,
  enableKeyboardControl: a,
  accessibilityLabel: s,
  customListId: c,
  onSelect: i,
  onActiveOptionChange: o,
}) {
  const [l, u] = r.useState(),
    [d, m] = r.useState(),
    [f, x] = r.useState(!1),
    [h, C] = r.useState([]),
    { value: y, setTrue: v, setFalse: T } = Wt(!!a),
    S = r.useId(),
    I = c || S,
    p = r.useRef(null),
    b = r.useRef(null),
    {
      listboxId: P,
      textFieldLabelId: E,
      textFieldFocused: D,
      willLoadMoreOptions: g,
      setActiveOptionId: k,
      setListboxId: R,
      onOptionSelected: _,
      onKeyToBottom: $,
    } = ka(),
    B = !!k;
  r.useEffect(() => {
    R && !P && R(I);
  }, [R, P, I]);
  const Q = r.useCallback(() => (b.current ? [...new Set(b.current.querySelectorAll(Ra))] : []), []),
    H = r.useCallback(
      (A) => {
        const w = A.some((W) => W.getAttribute("aria-selected") === "true");
        let V = 0;
        const U = A.find((W, se) => {
          const ee = W.getAttribute("aria-disabled") !== "true";
          let Y;
          return w && t === ge.FirstSelected ? (Y = W.getAttribute("aria-selected") === "true" && ee) : (Y = ee), Y && (V = se), Y;
        });
        if (U) return { element: U, index: V };
      },
      [t]
    ),
    ne = r.useCallback((A) => {
      const { current: w } = p;
      w && wa(A.element, w);
    }, []),
    ae = Zt(ne, 50),
    fe = r.useCallback(() => {
      if ($) return x(!0), Promise.resolve($());
    }, [$]),
    Z = r.useCallback(
      (A) => {
        if (!A) return m(void 0);
        d == null || d.element.removeAttribute(wt),
          A.element.setAttribute(wt, "true"),
          ae(A),
          m(A),
          k == null || k(A.domId),
          o == null || o(A.value, A.domId);
      },
      [d, k, o, ae]
    ),
    ue = r.useCallback(
      (A, w) => ({
        element: A,
        index: w,
        domId: A.id,
        value: A.getAttribute(at) || "",
        disabled: A.getAttribute("aria-disabled") === "true",
        isAction: A.getAttribute(qa) === "true",
      }),
      []
    ),
    Te = r.useCallback(() => {
      let A;
      const w = Q(),
        V = H(w);
      if (w.length === 0 && h.length > 0) {
        C(w), Z();
        return;
      }
      if (V) {
        const { element: ie, index: ye } = V;
        A = ue(ie, ye);
      }
      const U = d !== void 0 && (A == null ? void 0 : A.domId) === (d == null ? void 0 : d.domId),
        W =
          (d == null ? void 0 : d.isAction) &&
          (A == null ? void 0 : A.isAction) &&
          (A == null ? void 0 : A.value) !== (d == null ? void 0 : d.value),
        se = h.map((ie) => ie.getAttribute(at)),
        ee = w.map((ie) => ie.getAttribute(at)),
        Y = ee.length === se.length && ee.every((ie, ye) => se[ye] === ie),
        Be = se.length !== 0 && ee.length > se.length && se.every((ie, ye) => ee[ye] === ie);
      if (Y) {
        U && W && (C(w), Z(A));
        return;
      }
      if (Be) {
        C(w);
        return;
      }
      if ((C(w), f)) {
        x(!1);
        return;
      }
      Z(A);
    }, [f, h, d, H, Q, ue, Z]);
  r.useEffect(() => {
    t !== ge.None && !l && e && r.Children.count(e) > 0 && Te();
  }, [e, t, d, l, Te]),
    r.useEffect(() => {
      b.current && (p.current = b.current.closest(sa.selector));
    }, []),
    r.useEffect(() => {
      a && !y && v();
    }, [a, y, v]);
  const F = r.useCallback(
      (A) => {
        Z(A), _ && _(), i && i(A.value);
      },
      [Z, i, _]
    ),
    X = r.useCallback(
      (A, w, V) => {
        let U;
        return V === "down" ? (A === w ? (U = g ? A + 1 : 0) : (U = A + 1)) : (U = A === 0 ? w : A - 1), U;
      },
      [g]
    ),
    de = r.useCallback(
      async (A) => {
        const w = h.length - 1;
        let V = (d == null ? void 0 : d.index) || 0,
          U = 0,
          W = d == null ? void 0 : d.element,
          se = -1;
        if (!d && t === ge.None) {
          const ee = Q(),
            Y = H(ee);
          return C(ee), { element: Y == null ? void 0 : Y.element, nextIndex: (Y == null ? void 0 : Y.index) || 0 };
        }
        for (; se++ < w; ) {
          (U = X(V, w, A)), (W = h[U]);
          const ee = U >= w,
            Y = (W == null ? void 0 : W.getAttribute("aria-disabled")) === "true";
          if ((ee && g && (await fe()), Y)) {
            (V = U), (W = void 0);
            continue;
          }
          break;
        }
        return { element: W, nextIndex: U };
      },
      [t, h, d, g, X, fe, H, Q]
    ),
    j = r.useCallback(
      async (A, w) => {
        w.preventDefault();
        const { element: V, nextIndex: U } = await de(A);
        if (!V) return;
        const W = ue(V, U);
        Z(W);
      },
      [ue, de, Z]
    ),
    N = r.useCallback(
      (A) => {
        j("down", A);
      },
      [j]
    ),
    Ce = r.useCallback(
      (A) => {
        j("up", A);
      },
      [j]
    ),
    $e = r.useCallback(
      (A) => {
        A.preventDefault(), A.stopPropagation(), d && F(d);
      },
      [d, F]
    ),
    Je = r.useCallback(() => {
      a || v();
    }, [a, v]),
    Ke = r.useCallback(
      (A) => {
        if ((A.stopPropagation(), y)) {
          const w = H(h);
          if (w) {
            const { element: V, index: U } = w,
              W = ue(V, U);
            Z(W);
          }
        }
        a || T();
      },
      [a, h, y, T, H, ue, Z]
    ),
    Ge =
      y || D
        ? n.createElement(
            n.Fragment,
            null,
            n.createElement(Xe, { keyEvent: "keydown", keyCode: et.DownArrow, handler: N }),
            n.createElement(Xe, { keyEvent: "keydown", keyCode: et.UpArrow, handler: Ce }),
            n.createElement(Xe, { keyEvent: "keydown", keyCode: et.Enter, handler: $e })
          )
        : null,
    Ae = r.useMemo(() => ({ onOptionSelect: F, setLoading: u }), [F]);
  return n.createElement(
    n.Fragment,
    null,
    Ge,
    n.createElement(K, { as: "span", visuallyHidden: !0 }, n.createElement("div", { "aria-live": "polite" }, l || null)),
    n.createElement(
      Vt.Provider,
      { value: Ae },
      n.createElement(
        ia.Provider,
        { value: !0 },
        e
          ? n.createElement(
              "ul",
              {
                tabIndex: 0,
                role: "listbox",
                className: Ia.Listbox,
                "aria-label": B ? void 0 : s,
                "aria-labelledby": E,
                "aria-busy": !!l,
                "aria-activedescendant": d && d.domId,
                id: I,
                onFocus: B ? void 0 : Je,
                onBlur: B ? void 0 : Ke,
                ref: b,
              },
              e
            )
          : null
      )
    )
  );
}
L.Option = sn;
L.TextOption = yt;
L.Loading = Fa;
L.Section = Na;
L.Header = Oa;
L.Action = La;
const $a = r.memo(function ({ label: t, value: a, disabled: s, media: c, selected: i, singleSelection: o }) {
  const l = te(Ve.Media, s && Ve.disabledMedia, o && Ve.singleSelectionMedia),
    u = c ? n.createElement("div", { className: l }, c) : null,
    d = typeof t == "string" ? t : void 0;
  return n.createElement(
    L.Option,
    { accessibilityLabel: d, key: a, selected: i, value: a, disabled: s },
    n.createElement(L.TextOption, { selected: i, disabled: s }, n.createElement("div", { className: Ve.Content }, u, t))
  );
});
var Ba = { Listbox: "Polaris-Combobox__Listbox" };
function Ha({ value: e, id: t, type: a = "text", ariaAutocomplete: s = "list", onFocus: c, onBlur: i, onChange: o, ...l }) {
  const u = Da(),
    {
      activeOptionId: d,
      listboxId: m,
      expanded: f,
      setTextFieldFocused: x,
      setTextFieldLabelId: h,
      onTextFieldFocus: C,
      onTextFieldChange: y,
      onTextFieldBlur: v,
    } = u,
    T = r.useId(),
    S = r.useMemo(() => t || T, [T, t]),
    I = r.useMemo(() => la(t || T), [T, t]);
  r.useEffect(() => {
    h && h(I);
  }, [I, h]);
  const p = r.useCallback(
      (E) => {
        c && c(E), C && C(), x && x(!0);
      },
      [c, C, x]
    ),
    b = r.useCallback(
      (E) => {
        i && i(E), v && v(), x && x(!1);
      },
      [i, v, x]
    ),
    P = r.useCallback(
      (E, D) => {
        o && o(E, D), y && y(E);
      },
      [o, y]
    );
  return n.createElement(
    Re,
    Object.assign({}, l, {
      value: e,
      id: S,
      type: a,
      ariaAutocomplete: s,
      "aria-haspopup": "listbox",
      ariaActiveDescendant: d,
      ariaControls: m,
      role: "combobox",
      ariaExpanded: f,
      onFocus: p,
      onBlur: b,
      onChange: P,
    })
  );
}
function me({
  activator: e,
  allowMultiple: t,
  children: a,
  preferredPosition: s = "below",
  willLoadMoreOptions: c,
  height: i,
  onScrolledToBottom: o,
  onClose: l,
}) {
  const [u, d] = r.useState(!1),
    [m, f] = r.useState(),
    [x, h] = r.useState(),
    [C, y] = r.useState(),
    [v, T] = r.useState(!1),
    S = !u,
    I = u && r.Children.count(a) > 0,
    p = r.useRef(null),
    b = r.useCallback(() => {
      d(!1), l == null || l(), f(void 0);
    }, [l]),
    P = r.useCallback(() => {
      d(!0), f(void 0);
    }, []),
    E = r.useCallback(() => {
      var B;
      if (!t) {
        b(), f(void 0);
        return;
      }
      (B = p.current) == null || B.forceUpdatePosition();
    }, [t, b]),
    D = r.useCallback(() => {
      S && P();
    }, [S, P]),
    g = r.useCallback(() => {
      S && P();
    }, [S, P]),
    k = r.useCallback(() => {
      u && b();
    }, [u, b]),
    R = r.useMemo(
      () => ({
        activeOptionId: m,
        expanded: u,
        listboxId: C,
        setTextFieldFocused: T,
        setTextFieldLabelId: h,
        onTextFieldFocus: D,
        onTextFieldChange: g,
        onTextFieldBlur: k,
      }),
      [m, u, C, T, h, D, g, k]
    ),
    _ = r.useMemo(() => ({ allowMultiple: t }), [t]),
    $ = r.useMemo(
      () => ({
        listboxId: C,
        textFieldLabelId: x,
        textFieldFocused: v,
        willLoadMoreOptions: c,
        onOptionSelected: E,
        setActiveOptionId: f,
        setListboxId: y,
        onKeyToBottom: o,
      }),
      [C, x, v, c, E, f, y, o]
    );
  return n.createElement(
    _e,
    {
      ref: p,
      active: I,
      activator: n.createElement(Xt.Provider, { value: R }, e),
      autofocusTarget: "none",
      preventFocusOnClose: !0,
      fullWidth: !0,
      preferInputActivator: !1,
      preferredPosition: s,
      onClose: b,
    },
    r.Children.count(a) > 0
      ? n.createElement(
          _e.Pane,
          { onScrolledToBottom: o, height: i },
          n.createElement(
            en.Provider,
            { value: $ },
            n.createElement(tn.Provider, { value: _ }, n.createElement("div", { className: Ba.Listbox }, a))
          )
        )
      : null
  );
}
me.TextField = Ha;
var oe = {
  ActionContainer: "Polaris-Autocomplete-MappedAction__ActionContainer",
  Action: "Polaris-Autocomplete-MappedAction__Action",
  destructive: "Polaris-Autocomplete-MappedAction--destructive",
  selected: "Polaris-Autocomplete-MappedAction--selected",
  disabled: "Polaris-Autocomplete-MappedAction--disabled",
  Prefix: "Polaris-Autocomplete-MappedAction__Prefix",
  Suffix: "Polaris-Autocomplete-MappedAction__Suffix",
  Content: "Polaris-Autocomplete-MappedAction__Content",
  Text: "Polaris-Autocomplete-MappedAction__Text",
};
function Ua({
  active: e,
  content: t,
  disabled: a,
  icon: s,
  image: c,
  prefix: i,
  suffix: o,
  ellipsis: l,
  role: u,
  url: d,
  external: m,
  onAction: f,
  destructive: x,
  badge: h,
  helpText: C,
  wrapOverflow: y = !1,
}) {
  const v = xe();
  let T = null;
  i
    ? (T = n.createElement("div", { className: oe.Prefix }, i))
    : s
    ? (T = n.createElement("div", { className: oe.Prefix }, n.createElement(Pe, { source: s })))
    : c && (T = n.createElement("div", { role: "presentation", className: oe.Prefix, style: { backgroundImage: `url(${c}` } }));
  const S = h && n.createElement("span", { className: oe.Suffix }, n.createElement(ca, { tone: h.tone }, h.content)),
    I = o && n.createElement("span", { className: oe.Suffix }, o),
    p = l && t ? v.translate("Polaris.Autocomplete.ellipsis", { content: t }) : t,
    b = n.createElement(
      "div",
      { className: oe.Text },
      n.createElement(K, { as: "p", variant: "bodyMd", breakWord: y }, p),
      C ? n.createElement(K, { as: "p", variant: "bodyMd", tone: "subdued" }, C) : null
    ),
    P = r.useMemo(() => ({ role: u, url: d, external: m, onAction: f, destructive: x }), [u, d, m, f, x]),
    E = te(oe.Action, a && oe.disabled, x && oe.destructive, e && oe.selected);
  return n.createElement(
    on.Provider,
    { value: P },
    n.createElement(
      "div",
      { className: oe.ActionContainer },
      n.createElement(
        L.Action,
        { selected: e, disabled: a, value: t || "" },
        n.createElement("div", { className: E }, n.createElement("div", { className: oe.Content }, T, b, S, I))
      )
    )
  );
}
const ut = function ({
  options: t,
  selected: a,
  textField: s,
  preferredPosition: c,
  listTitle: i,
  allowMultiple: o,
  loading: l,
  actionBefore: u,
  willLoadMoreResults: d,
  emptyState: m,
  onSelect: f,
  onLoadMoreResults: x,
}) {
  const h = xe(),
    C = r.useCallback(
      (b) =>
        b.map((P) =>
          n.createElement($a, Object.assign({ key: P.id || P.value }, P, { selected: a.includes(P.value), singleSelection: !o }))
        ),
      [a, o]
    ),
    y = r.useMemo(() => {
      const b = l && !d ? [] : t;
      if (Aa(b)) {
        if (b.every(({ options: g }) => g.length === 0)) return null;
        const D = b.map(({ options: g, title: k }) => {
          if (g.length === 0) return null;
          const R = C(g);
          return n.createElement(L.Section, { divider: !1, title: n.createElement(L.Header, null, k), key: k }, R);
        });
        return n.createElement("div", { className: Sa.SectionWrapper }, D);
      }
      const P = b.length > 0 ? C(b) : null;
      return i ? n.createElement(L.Section, { divider: !1, title: n.createElement(L.Header, null, i) }, P) : P;
    }, [i, l, t, d, C]),
    v = l ? n.createElement(L.Loading, { accessibilityLabel: h.translate("Polaris.Autocomplete.spinnerAccessibilityLabel") }) : null,
    T = r.useCallback(
      (b) => {
        if (u && b === u.content) {
          u.onAction && u.onAction();
          return;
        }
        o ? (a.includes(b) ? f(a.filter((P) => P !== b)) : f([...a, b])) : f([b]);
      },
      [o, f, a, u]
    ),
    S = u && n.createElement(Ua, u),
    I = m && t.length < 1 && !l && n.createElement("div", { role: "status" }, m),
    p = u ? ge.First : void 0;
  return n.createElement(
    me,
    { activator: s, allowMultiple: o, onScrolledToBottom: x, preferredPosition: c, willLoadMoreOptions: d },
    S || y || v || I ? n.createElement(L, { autoSelection: p, onSelect: T }, S, y && (!l || d) ? y : null, v, I) : null
  );
};
ut.TextField = me.TextField;
const za = 7;
function Va(e, t, a = 0) {
  const s = new Date(t, e, 1),
    c = s.getDay(),
    i = [[]];
  let o = i[0],
    l = s;
  const u = ln(a);
  for (let d = 0; d < u.indexOf(c); d++) o.push(null);
  for (; l.getMonth() === e; ) o.length === za && ((o = []), i.push(o)), o.push(l), (l = new Date(t, e, l.getDate() + 1));
  for (; o.length < 7; ) o.push(null);
  return i;
}
function Wa(e, t) {
  if (e == null) return !1;
  const { start: a, end: s } = t;
  return !!(a && e > a && s && e < s);
}
function Za(e, t) {
  if (e == null) return !1;
  const { start: a, end: s } = t;
  return !!((a && ce(a, e)) || (s && ce(s, e)));
}
function ce(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function ja(e, t) {
  if (e == null) return { start: t, end: t };
  const { start: a, end: s } = e;
  return s && (Oe(a, s) || he(a, s))
    ? { start: t, end: t }
    : a
    ? he(t, a)
      ? { start: t, end: t }
      : { start: a, end: t }
    : s
    ? he(t, s)
      ? { start: t, end: s }
      : { start: a || s, end: t }
    : { start: t, end: t };
}
function Ft(e) {
  return e === 11 ? 0 : e + 1;
}
function Mt(e, t) {
  return e === 11 ? t + 1 : t;
}
function Ya(e) {
  return e === 0 ? 11 : e - 1;
}
function Ja(e, t) {
  return e === 0 ? t - 1 : t;
}
function Oe(e, t) {
  return e.getTime() > t.getTime();
}
function he(e, t) {
  return e.getTime() < t.getTime();
}
function Fe(e, t) {
  return t.some((a) => e.getTime() === a.getTime());
}
const Ka = [0, 1, 2, 3, 4, 5, 6];
function ln(e) {
  const t = [...Ka];
  return [...t.splice(e), ...t];
}
function Me(e) {
  switch (e) {
    case 0:
      return "january";
    case 1:
      return "february";
    case 2:
      return "march";
    case 3:
      return "april";
    case 4:
      return "may";
    case 5:
      return "june";
    case 6:
      return "july";
    case 7:
      return "august";
    case 8:
      return "september";
    case 9:
      return "october";
    case 10:
      return "november";
    case 11:
      return "december";
  }
}
function _t(e) {
  switch (e) {
    case 0:
      return "sunday";
    case 1:
      return "monday";
    case 2:
      return "tuesday";
    case 3:
      return "wednesday";
    case 4:
      return "thursday";
    case 5:
      return "friday";
    case 6:
      return "saturday";
  }
}
var O = {
  DatePicker: "Polaris-DatePicker",
  MonthLayout: "Polaris-DatePicker__MonthLayout",
  MonthContainer: "Polaris-DatePicker__MonthContainer",
  Month: "Polaris-DatePicker__Month",
  DayCell: "Polaris-DatePicker__DayCell",
  "DayCell-inRange": "Polaris-DatePicker__DayCell--inRange",
  Day: "Polaris-DatePicker__Day",
  "Day-inRange": "Polaris-DatePicker__Day--inRange",
  "Day-selected": "Polaris-DatePicker__Day--selected",
  "Day-disabled": "Polaris-DatePicker__Day--disabled",
  EmptyDayCell: "Polaris-DatePicker__EmptyDayCell",
  Weekday: "Polaris-DatePicker__Weekday",
  Header: "Polaris-DatePicker__Header",
  Title: "Polaris-DatePicker__Title",
  "Day-firstInRange": "Polaris-DatePicker__Day--firstInRange",
  "Day-hasRange": "Polaris-DatePicker__Day--hasRange",
  "Day-hoverRight": "Polaris-DatePicker__Day--hoverRight",
  "Day-lastInRange": "Polaris-DatePicker__Day--lastInRange",
  Week: "Polaris-DatePicker__Week",
};
const Ga = r.memo(function ({ label: t, title: a, current: s }) {
    return n.createElement(
      "th",
      { "aria-label": t, scope: "col", className: O.Weekday },
      n.createElement(
        K,
        { as: "span", variant: "bodySm", alignment: "center", fontWeight: s ? "bold" : "regular", tone: s ? void 0 : "subdued" },
        a
      )
    );
  }),
  Nt = r.memo(function ({
    day: t,
    focused: a,
    onClick: s,
    onHover: c = rt,
    onFocus: i = rt,
    selected: o,
    inRange: l,
    inHoveringRange: u,
    disabled: d,
    lastDayOfMonth: m,
    isLastSelectedDay: f,
    isFirstSelectedDay: x,
    isHoveringRight: h,
    rangeIsDifferent: C,
    weekday: y,
    selectedAccessibilityLabelPrefix: v,
  }) {
    const T = xe(),
      S = r.useRef(null),
      I = m || t;
    if (
      (r.useEffect(() => {
        a && S.current && S.current.focus();
      }, [a]),
      !t)
    )
      return n.createElement("td", { className: O.EmptyDayCell, onMouseOver: () => c(I) });
    const p = s && !d ? s.bind(null, t) : rt,
      b = ce(new Date(), t),
      P = te(
        O.DayCell,
        o && O["DayCell-selected"],
        (l || u) && !d && O["DayCell-inRange"],
        f && O["DayCell-lastInRange"],
        x && O["DayCell-firstInRange"],
        h && O["DayCell-hoverRight"],
        C && O["DayCell-hasRange"]
      ),
      E = te(
        O.Day,
        o && O["Day-selected"],
        d && O["Day-disabled"],
        (l || u) && !d && O["Day-inRange"],
        f && O["Day-lastInRange"],
        x && O["Day-firstInRange"],
        h && O["Day-hoverRight"],
        C && O["Day-hasRange"]
      ),
      D = t.getDate(),
      g = (a || o || b || D === 1) && !d ? 0 : -1,
      k = [
        o && v ? `${v} ` : "",
        `${b ? T.translate("Polaris.DatePicker.today") : ""}`,
        `${y || ""} `,
        `${T.translate(`Polaris.DatePicker.months.${Me(t.getMonth())}`)} `,
        `${D} `,
        `${t.getFullYear()}`,
      ].join("");
    return n.createElement(
      "td",
      { className: P },
      n.createElement(
        "button",
        {
          onFocus: () => i(t),
          type: "button",
          ref: S,
          tabIndex: g,
          className: E,
          onMouseOver: () => c(I),
          onClick: p,
          "aria-label": k,
          "aria-disabled": d,
          "aria-pressed": o,
        },
        n.createElement(K, { as: "span", variant: "bodySm", alignment: "center", fontWeight: b ? "bold" : "regular" }, D)
      )
    );
  });
function rt() {}
function Ot({
  focusedDate: e,
  selected: t,
  hoverDate: a,
  disableDatesBefore: s,
  disableDatesAfter: c,
  disableSpecificDates: i,
  allowRange: o,
  onChange: l = ot,
  onHover: u = ot,
  onFocus: d = ot,
  month: m,
  year: f,
  weekStartsOn: x,
  accessibilityLabelPrefixes: h,
}) {
  const C = xe(),
    y = o ? Qa : () => !1,
    v = new Date(),
    T = v.getMonth() === m && v.getFullYear() === f,
    S = r.useMemo(() => Va(m, f, x), [m, x, f]),
    I = ln(x).map((g) =>
      n.createElement(Ga, {
        key: g,
        title: C.translate(`Polaris.DatePicker.daysAbbreviated.${_t(g)}`),
        label: D(g),
        current: T && new Date().getDay() === g,
      })
    ),
    p = r.useCallback(
      (g) => {
        l(ja(o ? t : void 0, g));
      },
      [o, l, t]
    ),
    b = r.useMemo(() => new Date(f, m + 1, 0), [m, f]);
  function P(g, k) {
    if (g == null) return n.createElement(Nt, { key: k, onHover: u, lastDayOfMonth: b });
    const R = (s && he(g, s)) || (c && Oe(g, c)) || (i && Fe(g, i)),
      _ = o && t && er(g, t),
      $ = o && t && ((!ce(t.start, t.end) && Xa(g, t)) || (a && ce(t.start, t.end) && Oe(a, t.start) && ce(g, a) && !_)),
      B = !(t && ce(t.start, t.end)),
      Q = a && he(g, a),
      [H, ne] = h;
    let ae;
    return (
      (o && _) || (!o && H) ? (ae = H) : o && $ && (ae = ne),
      n.createElement(Nt, {
        selectedAccessibilityLabelPrefix: ae,
        weekday: D(k),
        focused: e != null && ce(g, e),
        day: g,
        key: k,
        onFocus: d,
        onClick: p,
        onHover: u,
        selected: t != null && Za(g, t),
        inRange: t != null && Wa(g, t),
        disabled: R,
        inHoveringRange: t != null && a != null && y(g, t, a),
        isLastSelectedDay: $,
        isFirstSelectedDay: _,
        isHoveringRight: Q,
        rangeIsDifferent: B,
      })
    );
  }
  const E = S.map((g, k) => n.createElement("tr", { className: O.Week, key: k }, g.map(P)));
  return n.createElement(
    "div",
    { className: O.MonthContainer },
    n.createElement(
      "table",
      { role: "grid", className: O.Month },
      n.createElement(
        "caption",
        { className: O.Title },
        n.createElement(
          K,
          { as: "span", variant: "bodyMd", alignment: "center", fontWeight: T ? "bold" : "medium" },
          C.translate(`Polaris.DatePicker.months.${Me(m)}`),
          " ",
          f
        )
      ),
      n.createElement("thead", null, n.createElement("tr", { className: O.WeekHeadings }, I)),
      n.createElement("tbody", null, E)
    )
  );
  function D(g) {
    return C.translate(`Polaris.DatePicker.days.${_t(g)}`);
  }
}
function ot() {}
function Qa(e, t, a) {
  if (e == null) return !1;
  const { start: s, end: c } = t;
  return !!(ce(s, c) && e > s && e <= a);
}
function Xa(e, t) {
  if (e == null) return !1;
  const { end: a } = t;
  return !!(a && ce(a, e));
}
function er(e, t) {
  if (e == null) return !1;
  const { start: a } = t;
  return !!(a && ce(a, e));
}
function tr({
  id: e,
  selected: t,
  month: a,
  year: s,
  allowRange: c,
  multiMonth: i,
  disableDatesBefore: o,
  disableDatesAfter: l,
  disableSpecificDates: u,
  weekStartsOn: d = 0,
  dayAccessibilityLabelPrefix: m,
  onMonthChange: f,
  onChange: x = nr,
}) {
  const h = xe(),
    [C, y] = r.useState(void 0),
    [v, T] = r.useState(void 0);
  r.useEffect(() => {
    T(void 0);
  }, [t]);
  const S = r.useCallback((F) => {
      T(F);
    }, []),
    I = r.useCallback(
      (F) => {
        f && f(F.getMonth(), F.getFullYear()), y(F), T(F);
      },
      [f]
    ),
    p = r.useCallback(
      (F) => {
        const { end: X } = F;
        y(X), T(new Date(X)), x(F);
      },
      [x]
    ),
    b = r.useCallback(
      (F, X) => {
        f && (T(void 0), f(F, X));
      },
      [f]
    ),
    P = r.useCallback((F) => {
      y(F);
    }, []),
    E = r.useCallback(
      (F) => {
        const { key: X } = F,
          de = st(t),
          j = v || (de && de.start);
        if (j != null) {
          if (X === "ArrowUp") {
            const N = new Date(j);
            N.setDate(j.getDate() - 7), (o && he(N, o)) || (u && Fe(N, u)) || I(N);
          }
          if (X === "ArrowDown") {
            const N = new Date(j);
            N.setDate(j.getDate() + 7), (l && Oe(N, l)) || (u && Fe(N, u)) || I(N);
          }
          if (X === "ArrowRight") {
            const N = new Date(j);
            N.setDate(j.getDate() + 1), (l && Oe(N, l)) || (u && Fe(N, u)) || I(N);
          }
          if (X === "ArrowLeft") {
            const N = new Date(j);
            N.setDate(j.getDate() - 1), (o && he(N, o)) || (u && Fe(N, u)) || I(N);
          }
        }
      },
      [l, o, u, v, t, I]
    ),
    D = Mt(a, s),
    g = Ft(a),
    k = Mt(g, D),
    R = Ft(g),
    _ = Ja(a, s),
    $ = Ya(a),
    B = h.translate(`Polaris.DatePicker.months.${Me($)}`),
    Q = i ? h.translate(`Polaris.DatePicker.months.${Me(R)}`) : h.translate(`Polaris.DatePicker.months.${Me(g)}`),
    H = i ? k : D,
    ne = r.useMemo(() => st(t), [t]),
    ae = c ? h.translate("Polaris.DatePicker.start") : m,
    fe = h.translate("Polaris.DatePicker.end"),
    Z = [ae, fe],
    ue = i
      ? n.createElement(Ot, {
          onFocus: S,
          focusedDate: v,
          month: g,
          year: D,
          selected: ne,
          hoverDate: C,
          onChange: p,
          onHover: P,
          disableDatesBefore: o,
          disableDatesAfter: l,
          disableSpecificDates: u,
          allowRange: c,
          weekStartsOn: d,
          accessibilityLabelPrefixes: Z,
        })
      : null,
    Te = te(O.DatePicker);
  return n.createElement(
    "div",
    { id: e, className: Te, onKeyDown: ar, onKeyUp: E },
    n.createElement(
      "div",
      { className: O.Header },
      n.createElement(Ee, {
        variant: "tertiary",
        icon: Jt,
        accessibilityLabel: h.translate("Polaris.DatePicker.previousMonth", { previousMonthName: B, showPreviousYear: _ }),
        onClick: () => b($, _),
      }),
      n.createElement(Ee, {
        variant: "tertiary",
        icon: Kt,
        accessibilityLabel: h.translate("Polaris.DatePicker.nextMonth", { nextMonth: Q, nextYear: H }),
        onClick: () => b(g, D),
      })
    ),
    n.createElement(
      "div",
      { className: O.MonthLayout },
      n.createElement(Ot, {
        onFocus: S,
        focusedDate: v,
        month: a,
        year: s,
        selected: st(t),
        hoverDate: C,
        onChange: p,
        onHover: P,
        disableDatesBefore: o,
        disableDatesAfter: l,
        disableSpecificDates: u,
        allowRange: c,
        weekStartsOn: d,
        accessibilityLabelPrefixes: Z,
      }),
      ue
    )
  );
}
function nr() {}
function ar(e) {
  const { key: t } = e;
  (t === "ArrowUp" || t === "ArrowDown" || t === "ArrowLeft" || t === "ArrowRight") && (e.preventDefault(), e.stopPropagation());
}
function st(e) {
  return e instanceof Date ? { start: e, end: e } : e;
}
function cn(e = "") {
  const t = e.toLowerCase();
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const rr = ["dragover", "dragenter", "drop"];
function or(e, t) {
  return e.type === "application/x-moz-file" || sr(e, t);
}
function Lt(e) {
  if (ir(e) && e.dataTransfer) {
    const t = e.dataTransfer;
    if (t.files && t.files.length) return Array.from(t.files);
    if (t.items && t.items.length) return Array.from(t.items);
  } else if (lr(e) && e.target.files) return Array.from(e.target.files);
  return [];
}
function sr(e, t) {
  if (e && t) {
    const a = e.name || "",
      s = e.type || "",
      c = s.replace(/\/.*$/, "");
    return (Array.isArray(t) ? t : t.split(",")).some((o) => {
      const l = o.trim();
      return l.startsWith(".") ? a.toLowerCase().endsWith(l.toLowerCase()) : l.endsWith("/*") ? c === l.replace(/\/.*$/, "") : s === l;
    });
  }
  return !0;
}
function ir(e) {
  return rr.indexOf(e.type) > 0;
}
function lr(e) {
  return Object.prototype.hasOwnProperty.call(e, "target");
}
const un = !0;
function dn(e) {
  return e ? "allowMultiple" : "single";
}
const mn = r.createContext({ disabled: !1, focused: !1, size: "extraLarge", type: "file", measuring: !1, allowMultiple: un });
var le = {
    DropZone: "Polaris-DropZone",
    focused: "Polaris-DropZone--focused",
    noOutline: "Polaris-DropZone--noOutline",
    hasOutline: "Polaris-DropZone--hasOutline",
    isDisabled: "Polaris-DropZone--isDisabled",
    isDragging: "Polaris-DropZone--isDragging",
    sizeLarge: "Polaris-DropZone--sizeLarge",
    sizeMedium: "Polaris-DropZone--sizeMedium",
    sizeSmall: "Polaris-DropZone--sizeSmall",
    measuring: "Polaris-DropZone--measuring",
    Container: "Polaris-DropZone__Container",
    Overlay: "Polaris-DropZone__Overlay",
    hasError: "Polaris-DropZone--hasError",
  },
  Se = {
    FileUpload: "Polaris-DropZone-FileUpload",
    large: "Polaris-DropZone-FileUpload--large",
    small: "Polaris-DropZone-FileUpload--small",
    ActionTitle: "Polaris-DropZone-FileUpload__ActionTitle",
    "ActionTitle-disabled": "Polaris-DropZone-FileUpload__ActionTitle--disabled",
    "ActionTitle-focused": "Polaris-DropZone-FileUpload__ActionTitle--focused",
    UploadIcon: "Polaris-DropZone-FileUpload__UploadIcon",
    disabled: "Polaris-DropZone-FileUpload--disabled",
  };
function cr(e) {
  const t = xe(),
    { size: a, measuring: s, type: c, disabled: i, allowMultiple: o } = r.useContext(mn),
    l = cn(c),
    u = dn(o),
    { actionTitle: d = t.translate(`Polaris.DropZone.${u}.actionTitle${l}`), actionHint: m } = e,
    f = n.createElement(Ee, { disabled: i }, d),
    x = te(Se.FileUpload, s && Se.measuring, a === "large" && Se.large, a === "small" && Se.small),
    h = m && n.createElement(K, { variant: "bodySm", as: "p", tone: "subdued" }, m);
  let C;
  switch (a) {
    case "large":
    case "medium":
      C = n.createElement(pt, { inlineAlign: "center", gap: "200" }, f, h);
      break;
    case "small":
      C = n.createElement("div", { className: te(Se.UploadIcon, i && Se.disabled) }, n.createElement(Pe, { source: gt }));
      break;
  }
  return n.createElement("div", { className: x }, C);
}
const dt = function ({
  dropOnPage: t,
  label: a,
  labelAction: s,
  labelHidden: c,
  children: i,
  disabled: o = !1,
  outline: l = !0,
  accept: u,
  active: d,
  overlay: m = !0,
  allowMultiple: f = un,
  overlayText: x,
  errorOverlayText: h,
  id: C,
  type: y = "file",
  onClick: v,
  error: T,
  openFileDialog: S,
  variableHeight: I,
  onFileDialogClose: p,
  customValidator: b,
  onDrop: P,
  onDropAccepted: E,
  onDropRejected: D,
  onDragEnter: g,
  onDragOver: k,
  onDragLeave: R,
}) {
  const _ = r.useRef(null),
    $ = r.useRef(null),
    B = r.useRef([]),
    Q = r.useCallback(
      Zt(
        () => {
          if (!_.current) return;
          if (I) {
            j(!1);
            return;
          }
          let M = "large";
          const J = _.current.getBoundingClientRect().width;
          J < 100 ? (M = "small") : J < 160 && (M = "medium"), X(M), de && j(!1);
        },
        50,
        { trailing: !0 }
      ),
      []
    ),
    [H, ne] = r.useState(!1),
    [ae, fe] = r.useState(!1),
    { value: Z, setTrue: ue, setFalse: Te } = Wt(!1),
    [F, X] = r.useState("large"),
    [de, j] = r.useState(!0),
    N = xe(),
    Ce = r.useCallback(
      (M) => {
        const J = [],
          re = [];
        return (
          Array.from(M).forEach((pe) => {
            !or(pe, u) || (b && !b(pe)) ? re.push(pe) : J.push(pe);
          }),
          f || (J.splice(1, J.length), re.push(...J.slice(1))),
          { files: M, acceptedFiles: J, rejectedFiles: re }
        );
      },
      [u, f, b]
    ),
    $e = r.useCallback(
      (M) => {
        if ((We(M), o)) return;
        const J = Lt(M),
          { files: re, acceptedFiles: pe, rejectedFiles: He } = Ce(J);
        (B.current = []),
          ne(!1),
          fe(He.length > 0),
          P && P(re, pe, He),
          E && pe.length && E(pe),
          D && He.length && D(He),
          M.target && "value" in M.target && (M.target.value = "");
      },
      [o, Ce, P, E, D]
    ),
    Je = r.useCallback(
      (M) => {
        if ((We(M), o)) return;
        const J = Lt(M);
        if ((M.target && !B.current.includes(M.target) && B.current.push(M.target), H)) return;
        const { rejectedFiles: re } = Ce(J);
        ne(!0), fe(re.length > 0), g && g();
      },
      [o, H, Ce, g]
    ),
    Ke = r.useCallback(
      (M) => {
        We(M), !o && k && k();
      },
      [o, k]
    ),
    Ge = r.useCallback(
      (M) => {
        M.preventDefault(),
          !o &&
            ((B.current = B.current.filter((J) => {
              const re = t && !tt ? document : _.current;
              return J !== M.target && re && re.contains(J);
            })),
            !(B.current.length > 0) && (ne(!1), fe(!1), R && R()));
      },
      [t, o, R]
    ),
    Ae = t && !tt ? document : _.current;
  we("drop", $e, Ae),
    we("dragover", Ke, Ae),
    we("dragenter", Je, Ae),
    we("dragleave", Ge, Ae),
    we("resize", Q, tt ? null : window),
    ua(() => {
      Q();
    });
  const A = r.useId(),
    w = C ?? A,
    V = cn(y),
    U = dn(f),
    W = x === void 0 ? N.translate(`Polaris.DropZone.${U}.overlayText${V}`) : x,
    se = h === void 0 ? N.translate(`Polaris.DropZone.errorOverlayText${V}`) : h,
    ee = a || N.translate(`Polaris.DropZone.${U}.label${V}`),
    Y = a ? c : !0,
    Be = te(
      le.DropZone,
      l && le.hasOutline,
      !l && le.noOutline,
      Z && le.focused,
      (d || H) && le.isDragging,
      o && le.isDisabled,
      (ae || T) && le.hasError,
      !I && le[jt("size", F)],
      de && le.measuring
    ),
    ie = (d || H) && !ae && !T && m && Tt(gt, W),
    ye = H && (ae || T) && Tt(ma, se, "critical"),
    _n = r.useMemo(() => ({ disabled: o, focused: Z, size: F, type: y || "file", measuring: de, allowMultiple: f }), [o, Z, de, F, y, f]),
    Qe = r.useCallback(() => {
      $.current && $.current.click();
    }, [$]),
    xt = r.useCallback(() => {
      Qe(), p == null || p();
    }, [Qe, p]);
  function Tt(M, J, re) {
    return n.createElement(
      "div",
      { className: le.Overlay },
      n.createElement(
        pt,
        { gap: "200", inlineAlign: "center" },
        F === "small" && n.createElement(Pe, { source: M, tone: re }),
        (F === "medium" || F === "large") && n.createElement(K, { variant: "bodySm", as: "p", fontWeight: "bold" }, J)
      )
    );
  }
  function Nn(M) {
    if (!o) return v ? v(M) : Qe();
  }
  return (
    r.useEffect(() => {
      S && xt();
    }, [S, xt]),
    n.createElement(
      mn.Provider,
      { value: _n },
      n.createElement(
        da,
        { id: w, label: ee, action: s, labelHidden: Y },
        n.createElement(
          "div",
          { ref: _, className: Be, "aria-disabled": o, onClick: Nn, onDragStart: We },
          ie,
          ye,
          n.createElement(
            K,
            { variant: "bodySm", as: "span", visuallyHidden: !0 },
            n.createElement("input", {
              id: w,
              accept: u,
              disabled: o,
              multiple: f,
              onChange: $e,
              onFocus: ue,
              onBlur: Te,
              type: "file",
              ref: $,
              autoComplete: "off",
            })
          ),
          n.createElement("div", { className: le.Container }, i)
        )
      )
    )
  );
};
function We(e) {
  e.preventDefault(), e.stopPropagation();
}
dt.FileUpload = cr;
var Rt = {
  DisplayText: "Polaris-SkeletonDisplayText__DisplayText",
  sizeSmall: "Polaris-SkeletonDisplayText--sizeSmall",
  sizeMedium: "Polaris-SkeletonDisplayText--sizeMedium",
  sizeLarge: "Polaris-SkeletonDisplayText--sizeLarge",
  sizeExtraLarge: "Polaris-SkeletonDisplayText--sizeExtraLarge",
};
function ur({ size: e = "medium", maxWidth: t }) {
  const a = te(Rt.DisplayText, e && Rt[jt("size", e)]),
    s = { "--pc-skeleton-display-text-max-width": t ?? void 0 };
  return n.createElement("div", { className: a, style: fa(s) });
}
const dr = n.lazy(() =>
    na(
      () => import("./PolarisAutoRichTextInput-11134d05.js").then((e) => e.P),
      [
        "./PolarisAutoRichTextInput-11134d05.js",
        "./index-7c191284.js",
        "./useResultBannerController-cd95b20f.js",
        "./apis-0c1c184f.js",
        "./iframe-35b6cbe2.js",
        "./useAction-f9651b8b.js",
        "./jsx-runtime-69eee039.js",
        "./index-363833c6.js",
        "./index-f0f16ed8.js",
        "./extends-98964cd2.js",
        "./dateTimeUtils-a817f99d.js",
        "./PolarisAutoRichTextInput-8ccf742d.css",
      ],
      import.meta.url
    )
  ),
  fn = G((e) => n.createElement(n.Fragment, null, n.createElement(dr, { ...e })));
fn.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoRichTextInput" };
const pn = G((e) => {
  const { field: t, control: a, ...s } = e,
    { path: c, metadata: i } = Le(t),
    {
      field: o,
      fieldState: { error: l },
    } = je({ control: a, name: c }),
    {
      formState: { defaultValues: u },
    } = On();
  r.useEffect(() => {
    if (i.requiredArgumentForInput) {
      const x = Ln(u ?? {}, c) ?? !1;
      o.onChange(x);
    }
  }, [i.requiredArgumentForInput, u]);
  const d = e.label ?? i.name,
    { value: m, ...f } = o;
  return n.createElement(zt, { ...f, checked: !!o.value, error: l == null ? void 0 : l.message, ...s, label: d });
});
pn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoBooleanInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const mr = (e, t, a, s, c) =>
    e.map((i, o) =>
      n.createElement(
        "div",
        { key: o, style: { textAlign: "center", cursor: "default", padding: "0px 4px" } },
        n.createElement(
          L.Option,
          { value: i },
          n.createElement(
            "div",
            { style: { cursor: "pointer" }, onMouseEnter: () => c({ col: a, row: o }), onMouseLeave: () => c({ col: -1, row: -1 }) },
            t.padStart(2, "0") == i.padStart(2, "0") ||
              (parseInt(t, 10) == 0 && i == "12") ||
              ((s == null ? void 0 : s.col) == a && s.row == o)
              ? n.createElement(
                  ke,
                  { padding: "100", background: "bg-inverse", borderRadius: "200", minHeight: "30px", minWidth: "30px" },
                  n.createElement(K, { as: "p", tone: "text-inverse" }, i)
                )
              : n.createElement(ke, { minHeight: "30px", minWidth: "30px", padding: "100" }, i)
          )
        )
      )
    ),
  it = Array.from({ length: 12 }, (e, t) => (t + 1).toString().padStart(2, "0")),
  lt = Array.from({ length: 60 }, (e, t) => t.toString().padStart(2, "0")),
  ct = ["AM", "PM"],
  fr = new RegExp(/((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))/),
  qt = (e) => (parseInt(e.hour, 10) === 0 ? `12:${e.minute.padStart(2, "0")} AM` : `${e.hour}:${e.minute.padStart(2, "0")} ${e.ampm}`),
  gn = (e) => {
    var b;
    const [t, a] = r.useState(e.value),
      [s, c] = r.useState(e.localTime ? qt(z(e.localTime)) : ""),
      [i, o] = r.useState(!1),
      [l, u] = r.useState(!1),
      [d, m] = r.useState({ col: -1, row: -1 }),
      f = (P) => {
        var E;
        if (t) {
          (E = e.onChange) == null || E.call(e, Ie({ ...z(t), hour: P }));
          return;
        }
        e.fieldProps.onChange(Ie({ ...z(e.fieldProps.value ?? new Date()), hour: P }));
      },
      x = (P) => {
        var E;
        if (t) {
          (E = e.onChange) == null || E.call(e, Ie({ ...z(t), minute: P }));
          return;
        }
        e.fieldProps.onChange(Ie({ ...z(e.fieldProps.value ?? new Date()), minute: P }));
      },
      h = (P) => {
        var E;
        if (t) {
          (E = e.onChange) == null || E.call(e, Ie({ ...z(t), ampm: P }));
          return;
        }
        e.fieldProps.onChange(Ie({ ...z(e.fieldProps.value ?? new Date()), ampm: P }));
      },
      C = (P) => {
        var ne;
        c(P);
        let E = P.trim(),
          D = parseInt(E.split(":")[0], 10);
        const g = E.split(":")[1];
        if ((D === 0 && (E = "12:" + g), !fr.test(E))) {
          u(!0);
          return;
        }
        u(!1);
        const R = parseInt(g, 10),
          _ = E.slice(-2).toUpperCase(),
          $ = D.toString(),
          B = R.toString().padStart(2, "0");
        f($), x(B), h(_);
        const Q = new Date();
        _ === "PM" && D < 12 ? (D += 12) : _ === "AM" && D === 12 && (D = 0), Q.setHours(D, R, 0, 0);
        const H = e.localTime ? new Date(e.localTime) : new Date();
        yn(H, Q),
          (ne = e.onChange) == null || ne.call(e, De(H, e.localTz ?? "UTC")),
          e.fieldProps.onChange(De(H, e.localTz ?? "UTC")),
          t && a(De(H, e.localTz ?? "UTC")),
          c(`${parseInt($, 10) === 0 ? "12" : $}:${B} ${_}`);
      },
      y = (P) => {
        const E = t ?? e.fieldProps.value;
        return `${P}:${E ? z(E).minute.toString().padStart(2, "0") : lt[0]} ${E ? z(E).ampm : ct[0]}`;
      },
      v = (P) => {
        const E = t ?? e.fieldProps.value;
        return `${E ? z(E).hour : it[0]}:${P.padStart(2, "0")} ${E ? z(E).ampm : ct[0]}`;
      },
      T = (P) => {
        const E = t ?? e.fieldProps.value;
        return `${E ? z(E).hour : it[0]}:${E ? z(E).minute.toString().padStart(2, "0") : lt[0]} ${P}`;
      },
      S = { array: it, formatter: y, key: "hour" },
      I = { array: lt, formatter: v, key: "minute" },
      p = { array: ct, formatter: T, key: "ampm" };
    return (
      r.useEffect(() => {
        !e.fieldProps.value || t || c(qt(z(new Date(e.fieldProps.value))));
      }, [e.fieldProps.value, t, c]),
      n.createElement(
        n.Fragment,
        null,
        n.createElement(
          _e,
          {
            active: i,
            onClose: () => o(!1),
            preferredAlignment: "right",
            activator: n.createElement(Re, {
              prefix: n.createElement(Pe, { source: Qt }),
              id: e.id ? `${e.id}-time` : void 0,
              "data-testid": e.id ? `${e.id}-time` : void 0,
              label: ((b = e.timePickerProps) == null ? void 0 : b.label) ?? "Time",
              autoComplete: "off",
              value: s,
              onChange: C,
              onFocus: () => o(!0),
              error: l && "Invalid time format",
              ...e.timePickerProps,
            }),
          },
          n.createElement(
            _e.Pane,
            { fixed: !0 },
            !e.hideTimePopover &&
              n.createElement(
                "div",
                { style: { overflow: "hidden", padding: "15px 8px" } },
                n.createElement(
                  "div",
                  { style: { display: "flex" } },
                  [S, I, p].map((P, E) =>
                    n.createElement(
                      pa,
                      { key: E, style: { overflowY: "scroll", height: "250px" } },
                      n.createElement(
                        L,
                        { onSelect: (D) => C(P.formatter(D)) },
                        mr(
                          P.array,
                          t ? `${z(t)[P.key]}` : e.fieldProps.value ? `${z(new Date(e.fieldProps.value))[P.key]}` : P.array[0],
                          E,
                          d,
                          m
                        )
                      )
                    )
                  )
                )
              )
          )
        )
      )
    );
  },
  pr = gn;
gn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoTimePicker",
  props: {
    fieldProps: {
      required: !0,
      tsType: {
        name: "ControllerRenderProps",
        elements: [{ name: "FieldValues" }, { name: "string" }],
        raw: "ControllerRenderProps<FieldValues, string>",
      },
      description: "",
    },
    value: { required: !1, tsType: { name: "Date" }, description: "" },
    onChange: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(value: Date) => void",
        signature: { arguments: [{ type: { name: "Date" }, name: "value" }], return: { name: "void" } },
      },
      description: "",
    },
    localTime: { required: !1, tsType: { name: "Date" }, description: "" },
    id: { required: !1, tsType: { name: "string" }, description: "" },
    timePickerProps: {
      required: !1,
      tsType: { name: "Partial", elements: [{ name: "TextFieldProps" }], raw: "Partial<TextFieldProps>" },
      description: "",
    },
    hideTimePopover: { required: !1, tsType: { name: "boolean" }, description: "" },
    localTz: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
const yn = (e, t) => {
    e.setHours(t.getHours()), e.setMinutes(t.getMinutes()), e.setSeconds(t.getSeconds()), e.setMilliseconds(t.getMilliseconds());
  },
  z = (e) => ({
    month: e.getMonth(),
    year: e.getFullYear(),
    day: e.getDay(),
    hour: e.getHours() > 12 ? (e.getHours() - 12).toString() : e.getHours().toString(),
    minute: e.getMinutes().toString().padStart(2, "0"),
    ampm: e.getHours() >= 12 ? "PM" : "AM",
  }),
  Ie = (e) => {
    const t = new Date();
    return (
      t.setMonth(e.month),
      t.setFullYear(e.year),
      t.setDate(e.day),
      t.setHours(e.ampm === "PM" ? parseInt(e.hour) + 12 : parseInt(e.hour)),
      t.setMinutes(parseInt(e.minute)),
      t.setSeconds(0),
      t.setMilliseconds(0),
      t
    );
  },
  bn = G((e) => {
    var I;
    const { path: t, metadata: a } = Le(e.field),
      { field: s, fieldState: c } = je({ name: t }),
      { onChange: i, value: o } = e,
      l = Intl.DateTimeFormat().resolvedOptions().timeZone,
      u = r.useMemo(() => o || (ze(new Date(s.value)) ? new Date(s.value) : void 0), [o, s.value]),
      [d, m] = r.useState(!1),
      [f, x] = r.useState(z(u ?? At(new Date(), l)).month),
      [h, C] = r.useState(z(u ?? At(new Date(), l)).year),
      y = a.configuration,
      v = r.useCallback(
        (p) => {
          (s || o) && yn(p.start, De(p.start, l));
          const b = o ?? new Date(s.value);
          ze(b) &&
            (p.start.setHours(b.getHours()),
            p.start.setMinutes(b.getMinutes()),
            p.start.setSeconds(b.getSeconds()),
            p.start.setMilliseconds(b.getMilliseconds())),
            i == null || i(De(p.start, l)),
            s.onChange(De(p.start, l)),
            m(!1);
        },
        [s, o, l, i]
      ),
      T = r.useCallback(() => {
        x(z(ze(u) && u ? u : new Date()).month), C(z(ze(u) && u ? u : new Date()).year), m((p) => !p);
      }, [u]),
      S = r.useCallback((p, b) => {
        x(p), C(b);
      }, []);
    return n.createElement(
      ve,
      { gap: "400" },
      n.createElement(
        _e,
        {
          preferredPosition: "above",
          active: d,
          activator: n.createElement(Re, {
            id: e.id ? `${e.id}-date` : void 0,
            label: e.label ?? a.name ?? "Date",
            prefix: n.createElement(Pe, { source: Gt }),
            autoComplete: "off",
            value: u ? ga(u) : "",
            onFocus: T,
            requiredIndicator: a.requiredArgumentForInput,
            error: e.error ?? ((I = c.error) == null ? void 0 : I.message),
          }),
          onClose: T,
        },
        n.createElement(
          "div",
          { style: { padding: "16px" } },
          n.createElement(tr, {
            month: f,
            year: h,
            allowRange: !1,
            onChange: v,
            onMonthChange: S,
            selected: u ?? new Date(),
            ...e.datePickerProps,
          })
        )
      ),
      (e.includeTime ?? y.includeTime) &&
        n.createElement(
          "div",
          { style: { width: "130px" } },
          n.createElement(pr, {
            fieldProps: s,
            id: e.id,
            localTime: u,
            onChange: i,
            hideTimePopover: e.hideTimePopover,
            localTz: l,
            timePickerProps: e.timePickerProps,
            value: o,
          })
        )
    );
  });
bn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoDateTimePicker",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    id: { required: !1, tsType: { name: "string" }, description: "" },
    value: { required: !1, tsType: { name: "Date" }, description: "" },
    onChange: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(value: Date) => void",
        signature: { arguments: [{ type: { name: "Date" }, name: "value" }], return: { name: "void" } },
      },
      description: "",
    },
    error: { required: !1, tsType: { name: "string" }, description: "" },
    includeTime: { required: !1, tsType: { name: "boolean" }, description: "" },
    hideTimePopover: { required: !1, tsType: { name: "boolean" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
    datePickerProps: {
      required: !1,
      tsType: { name: "Partial", elements: [{ name: "DatePickerProps" }], raw: "Partial<DatePickerProps>" },
      description: "",
    },
    timePickerProps: {
      required: !1,
      tsType: { name: "Partial", elements: [{ name: "TextFieldProps" }], raw: "Partial<TextFieldProps>" },
      description: "",
    },
  },
};
const qe = G((e) => {
  const { field: t, control: a } = e,
    s = Ye({ field: t, control: a });
  return n.createElement(Re, {
    ...Ze(s),
    requiredIndicator: s.metadata.requiredArgumentForInput,
    type: s.type,
    error: s.errorMessage,
    ...e,
    label: e.label || s.metadata.name,
  });
});
qe.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoTextInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const bt = G((e) => {
  const [t, a] = r.useState(!1),
    s = n.createElement(
      "div",
      { style: { display: "flex" } },
      n.createElement(Ee, {
        variant: "plain",
        size: "slim",
        icon: t ? ya : ba,
        onClick: () => a(!t),
        role: `${e.field}ToggleShowHideButton`,
      })
    );
  return n.createElement(qe, { type: t ? "text" : "password", suffix: s, ...e });
});
bt.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoEncryptedStringInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const gr = (e) => {
    const { field: t, control: a } = e,
      { path: s, metadata: c } = Le(t),
      i = c.configuration;
    if (i.__typename !== "GadgetEnumConfig") throw new Error("Field is not an enum type");
    const {
        field: o,
        fieldState: { error: l },
      } = je({ control: a, name: s }),
      [u, d] = r.useState(""),
      m = r.useMemo(() => (typeof o.value == "string" ? [o.value] : o.value ?? []), [o.value]),
      f = r.useMemo(() => i.options.map((y) => y.name), [i.options]),
      x = r.useMemo(() => [...new Set([...m, ...f])], [f, m]),
      h = r.useMemo(() => x.filter((y) => !u || y.toLocaleLowerCase().includes(u.trim().toLocaleLowerCase())), [x, u]),
      C = r.useCallback(
        (y) => {
          if ((d(""), i.allowMultiple)) {
            if (y === null) {
              o.onChange([]);
              return;
            }
            const v = new Set([...m]);
            v.has(y) ? v.delete(y) : v.add(y), o.onChange([...v]);
          } else y === null || m.includes(y) ? o.onChange(null) : o.onChange(y);
        },
        [i.allowMultiple, o, m]
      );
    return {
      allowMultiple: i.allowMultiple,
      allowOther: i.allowOther,
      selectedOptions: m,
      providedOptions: f,
      filteredOptions: h,
      allOptions: x,
      searchQuery: { value: u, setValue: d },
      onSelectionChange: C,
      label: c.name,
      metadata: c,
      fieldProps: o,
      isError: !!l,
      errorMessage: l == null ? void 0 : l.message,
    };
  },
  hn = G((e) => {
    const { field: t, control: a, label: s, ...c } = e,
      {
        allowMultiple: i,
        allowOther: o,
        onSelectionChange: l,
        selectedOptions: u,
        allOptions: d,
        filteredOptions: m,
        searchQuery: f,
        label: x,
        metadata: h,
        isError: C,
        errorMessage: y,
      } = gr({ field: t, control: a }),
      { value: v, setValue: T } = f;
    let S = null;
    u.length > 0 &&
      (S = n.createElement(
        ve,
        { gap: "150" },
        u.map((g) => n.createElement(Ne, { key: `option-${g}`, onRemove: () => l(g) }, g))
      ));
    const I = r.useCallback(
      (g) => {
        const k = v.trim().toLocaleLowerCase(),
          R = g.toLocaleLowerCase().indexOf(k);
        if (!v || R === -1) return g;
        const _ = g.slice(0, R),
          $ = g.slice(R, R + k.length),
          B = g.slice(R + k.length, g.length);
        return n.createElement("p", null, _, n.createElement(K, { fontWeight: "bold", as: "span" }, $), B);
      },
      [v]
    );
    let p = null;
    d.length > 0 &&
      (p = m.map((g) =>
        n.createElement(
          L.Option,
          { key: g, value: g, selected: u.includes(g), accessibilityLabel: g },
          n.createElement(L.TextOption, { selected: u.includes(g) }, I(g))
        )
      ));
    let b = null;
    o && v && !d.includes(v) && v.trim().length > 0 && (b = n.createElement(L.Action, { value: v }, `Add "${v}"`));
    let P = null;
    !o &&
      (!p || p.length === 0) &&
      v &&
      (P = n.createElement(
        ke,
        { padding: "100" },
        n.createElement(K, { as: "span", alignment: "center", tone: "subdued" }, `No options found matching "${v}"`)
      ));
    let E = null;
    (p || b || P) &&
      (E = n.createElement(
        L,
        {
          autoSelection: ge.None,
          onSelect: (g) => {
            l(g), i && T("");
          },
        },
        P,
        b,
        p
      ));
    const D = n.createElement(
      n.Fragment,
      null,
      s ?? x,
      " ",
      h.requiredArgumentForInput ? n.createElement("span", { style: { color: "var(--p-color-text-critical)" } }, "*") : null
    );
    return n.createElement(
      me,
      {
        allowMultiple: i,
        activator: n.createElement(me.TextField, {
          autoComplete: "off",
          label: D,
          value: v,
          placeholder: "Search",
          verticalContent: S,
          onChange: T,
          id: `${e.field}-combobox-textfield`,
          error: y,
        }),
        ...c,
      },
      E
    );
  });
hn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoEnumInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
const vn = G((e) => {
  var y, v;
  const { field: t, control: a, ...s } = e,
    {
      fieldProps: c,
      errorMessage: i,
      imageThumbnailURL: o,
      onFileUpload: l,
      clearFileValue: u,
      canClearFileValue: d,
      validations: m,
      metadata: f,
    } = Rn({ field: t, control: a }),
    x = r.useMemo(() => {
      if (c.value) return null;
      const T = ["Accepts"];
      if ((m.onlyImages && T.push(`.jpg, .webp, .svg${m.onlyImages.allowAnimatedImages ? ", .gif" : ""}, and .png`), m.fileSize)) {
        const S = m.fileSize,
          I = qn(S, {
            inRange: (p, b) => `between ${Ue(p)} and ${Ue(b)}`,
            max: (p) => `smaller than ${Ue(p)}`,
            min: (p) => `larger than ${Ue(p)}`,
          });
        I && T.push(I);
      }
      return n.createElement(dt.FileUpload, { actionTitle: "Add file", actionHint: T.length === 1 ? "" : T.join(" ") });
    }, [c.value, m.fileSize, m.onlyImages]),
    h = r.useMemo(() => {
      const T = c.value;
      return !T || !$n(T)
        ? null
        : n.createElement(
            ke,
            { padding: "100", paddingInlineEnd: "400" },
            n.createElement(
              ve,
              { align: "space-between", gap: "400" },
              n.createElement(
                ve,
                { gap: "200", blockAlign: "center" },
                n.createElement(ha, { size: "small", alt: T.fileName, source: o && [...Bn, "image/gif"].includes(T.mimeType) ? o : va }),
                n.createElement("div", null, T.$uploading ? "(Uploading) " : "", T.fileName)
              ),
              d &&
                n.createElement(Ee, {
                  icon: Ea,
                  variant: "plain",
                  accessibilityLabel: "Delete file",
                  onPointerDown: () => {
                    u();
                  },
                  id: `clear-file-${t}`,
                })
            )
          );
    }, [d, u, t, c.value, o]),
    C = n.createElement(
      n.Fragment,
      null,
      f.name,
      " ",
      f.requiredArgumentForInput ? n.createElement("span", { style: { color: "var(--p-color-text-critical)" } }, "*") : null
    );
  return n.createElement(
    n.Fragment,
    null,
    n.createElement(
      dt,
      {
        variableHeight: !0,
        label: C,
        allowMultiple: !1,
        onDrop: (T, S) => {
          l(S);
        },
        ...s,
        accept: (v = (y = m.onlyImages) == null ? void 0 : y.acceptedTypes) == null ? void 0 : v.join(","),
      },
      h,
      x
    ),
    i && n.createElement("div", { style: { marginTop: "4px" } }, n.createElement(Pa, { fieldID: t, message: i }))
  );
});
vn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoFileInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const En = G((e) => {
  const { field: t, label: a } = e,
    { name: s, metadata: c } = Ye({ field: t });
  if (c.fieldType !== q.Id || t !== "id") throw new Error(`PolarisAutoIdInput: field ${t} is not of type Id`);
  return n.createElement(qe, { step: 1, field: t, min: 1, type: "number", label: a || "ID", name: s });
});
En.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoIdInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
function yr(e) {
  const [t, a] = r.useState(!1),
    [s, c] = r.useState(!1),
    i = r.useRef(null),
    o = e ?? i;
  return [
    t,
    {
      onFocus: (d) => {
        if (!d) return;
        const m = d.target === o.current;
        a(!0), m || c(!0);
      },
      onBlur: (d) => {
        if (!d) return;
        const m = d.target === o.current;
        a(!1), m || c(!1);
      },
      ref: o,
    },
    s,
  ];
}
const br = (e) => {
    const t = Ye(e),
      a = t.value,
      s = Un(a),
      [c, i] = r.useState(t.value && !s ? JSON.stringify(a, null, 2) : "");
    r.useEffect(() => {
      if (typeof a < "u" && a != null && !s)
        try {
          const l = JSON.parse(c);
          Hn(l, a) || i(JSON.stringify(a, null, 2));
        } catch {
          i(JSON.stringify(a, null, 2));
        }
    }, [a, s]),
      r.useEffect(() => {
        t.value === void 0 && i("");
      }, [t.value]);
    const o = r.useCallback(
      (l) => {
        if ((i(l), l == "")) {
          t.onChange(null);
          return;
        }
        try {
          const u = JSON.parse(l);
          t.onChange(u);
        } catch (u) {
          t.onChange({ $failedParse: !0, raw: l, error: u });
        }
      },
      [t]
    );
    return { ...t, onChange: o, value: c };
  },
  Pn = G((e) => {
    const [t, a] = yr(),
      { field: s, control: c, ...i } = e,
      { type: o, errorMessage: l, ...u } = br(e),
      d = e.label ?? u.label;
    return n.createElement(
      n.Fragment,
      null,
      n.createElement(Re, {
        multiline: 4,
        monospaced: !0,
        requiredIndicator: u.metadata.requiredArgumentForInput,
        error: !t && l && `Invalid JSON: ${l}`,
        ...Ze(u),
        ...Ze(a),
        ...i,
        label: d,
      })
    );
  });
Pn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoJSONInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const xn = G((e) => {
  const { field: t, control: a } = e,
    { type: s, metadata: c, value: i } = Ye({ field: t, control: a }),
    l =
      s === "number" && c.configuration.__typename === "GadgetNumberConfig" && c.configuration.decimals && c.configuration.decimals > 0
        ? Ct(c.configuration.decimals)
        : i
        ? Ct(zn(`${i}`))
        : 1;
  return n.createElement(qe, { step: l, ...e });
});
xn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoNumberInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const hr = "********",
  Tn = G((e) => {
    const { findBy: t } = $t(),
      { path: a } = Le(e.field),
      { field: s } = je({ name: a }),
      [c, i] = r.useState(!t),
      o = () => {
        s.onChange(""), i(!0);
      },
      l = n.createElement(
        "div",
        { style: { display: "flex" } },
        n.createElement(Ee, { variant: "plain", size: "slim", icon: xa, onClick: o, role: `${e.field}EditPasswordButton` })
      );
    return n.createElement(bt, { ...(c ? { placeholder: "Password" } : { placeholder: hr, suffix: l, disabled: !0 }), ...e });
  });
Tn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoPasswordInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const Cn = (e) => {
  var I;
  const { label: t, options: a, value: s, onChange: c, allowMultiple: i, ...o } = e,
    l = r.useMemo(() => (s ? (i ? s : [s]) : []), [i, s]),
    u = a.filter((p) => l.includes(p.value)),
    [d, m] = r.useState(i ? "" : ((I = u[0]) == null ? void 0 : I.label) ?? ""),
    [f, x] = r.useState(e.options),
    h = r.useCallback(
      (p) => {
        c(i ? p : p[0]);
      },
      [i, c]
    ),
    C = r.useCallback(
      (p) => {
        if ((m(p), p === "")) {
          x(e.options);
          return;
        }
        const b = new RegExp(p, "i"),
          P = e.options.filter((E) => E.label.match(b));
        x(P);
      },
      [e.options]
    ),
    y = r.useCallback(
      (p) => {
        const b = p.map((P) => {
          const E = f.find((D) => D.value.match(P));
          return E && E.value;
        });
        h(p), i || m(b[0] || "");
      },
      [h, f]
    ),
    v = r.useCallback(
      (p) => () => {
        const b = [...l];
        b.splice(b.indexOf(p), 1), h(b);
      },
      [h, l]
    ),
    T =
      u.length > 0 && e.allowMultiple
        ? n.createElement(
            ve,
            { gap: "200" },
            u.map((p) => n.createElement(Ne, { key: `option-${p.value}`, onRemove: v(p.value) }, p.label))
          )
        : null,
    S = n.createElement(ut.TextField, {
      onChange: C,
      label: t,
      value: d,
      verticalContent: T,
      placeholder: "Search",
      autoComplete: "off",
      id: `${t}_Autocomplete_Textfield`,
    });
  return n.createElement(ut, { options: f, ...o, selected: l, onSelect: y, textField: S, id: `${t}_Autocomplete`, allowMultiple: i });
};
Cn.__docgenInfo = { description: "", methods: [], displayName: "PolarisFixedOptionsCombobox" };
const An = G((e) => {
  const { options: t, loading: a, rolesError: s, fieldError: c, selectedRoleKeys: i, fieldProps: o, metadata: l } = Jn(e);
  if (s) throw s;
  if (c) throw c;
  return a || !t || t.length === 0
    ? null
    : n.createElement(Cn, { options: t, allowMultiple: !0, label: e.label ?? l.name, ...Ze(o), value: i });
});
An.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoRolesInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    control: { required: !1, tsType: { name: "Control", elements: [{ name: "any" }], raw: "Control<any>" }, description: "" },
  },
};
const Sn = (e) => {
    const { label: t, id: a, selected: s } = e;
    return typeof t == "string"
      ? n.createElement(L.Option, { key: a, value: a, selected: s }, t)
      : n.createElement(L.Action, { key: a, value: a, selected: s }, t);
  },
  ht = (e) => n.createElement("div", { style: { padding: "16px" } }, n.createElement(K, { as: "p", tone: "subdued" }, e.message)),
  In = () => n.createElement(ht, { message: "No records found" });
Sn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "SelectableOption",
  props: {
    label: { required: !0, tsType: { name: "ReactReactNode", raw: "React.ReactNode" }, description: "" },
    id: { required: !0, tsType: { name: "string" }, description: "" },
    selected: { required: !0, tsType: { name: "boolean" }, description: "" },
  },
};
ht.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "ListMessage",
  props: { message: { required: !0, tsType: { name: "string" }, description: "" } },
};
In.__docgenInfo = { description: "", methods: [], displayName: "NoRecordsMessage" };
const vt = (e) => {
  const { checkSelected: t, onSelect: a, isLoading: s, errorMessage: c, options: i, records: o, actions: l } = e,
    u = [
      ...(l ?? []),
      ...i.map((d) =>
        e.renderOption ? e.renderOption(d) : n.createElement(Sn, { ...d, selected: (t == null ? void 0 : t(d.id)) ?? !1, key: d.id })
      ),
    ];
  return n.createElement(
    L,
    {
      autoSelection: e.autoSelection,
      onSelect: (d) => {
        const m = (o == null ? void 0 : o.find((C) => C.id === d)) ?? { id: d },
          { createdAt: f, updatedAt: x, ...h } = m;
        a(h);
      },
    },
    u.length ? u : c ? n.createElement(ht, { message: Vn(c) }) : n.createElement(In, null),
    s && n.createElement(L.Loading, { accessibilityLabel: "Loading" })
  );
};
vt.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "RelatedModelOptions",
  props: {
    options: { required: !0, tsType: { name: "Array", elements: [{ name: "Option" }], raw: "Option[]" }, description: "" },
    records: {
      required: !1,
      tsType: {
        name: "Array",
        elements: [{ name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }],
        raw: "Record<string, any>[]",
      },
      description: "",
    },
    isLoading: { required: !1, tsType: { name: "boolean" }, description: "" },
    errorMessage: { required: !1, tsType: { name: "string" }, description: "" },
    checkSelected: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(id: string) => boolean",
        signature: { arguments: [{ type: { name: "string" }, name: "id" }], return: { name: "boolean" } },
      },
      description: "",
    },
    onSelect: {
      required: !0,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(record: Record<string, any>) => void",
        signature: {
          arguments: [
            { type: { name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }, name: "record" },
          ],
          return: { name: "void" },
        },
      },
      description: "",
    },
    autoSelection: { required: !1, tsType: { name: "AutoSelection" }, description: "" },
    actions: {
      required: !1,
      tsType: { name: "Array", elements: [{ name: "ReactReactNode", raw: "React.ReactNode" }], raw: "React.ReactNode[]" },
      description: "",
    },
    renderOption: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(option: Option) => React.ReactNode",
        signature: {
          arguments: [{ type: { name: "Option" }, name: "option" }],
          return: { name: "ReactReactNode", raw: "React.ReactNode" },
        },
      },
      description: "",
    },
  },
};
const Dn = G((e) => {
  const {
      fieldMetadata: { path: t, metadata: a },
      relatedModelOptions: { options: s, searchFilterOptions: c, pagination: i, search: o, relatedModel: l },
      isLoading: u,
      errorMessage: d,
      selectedRecord: m,
      danglingSelectedRecordId: f,
      onSelectRecord: x,
      onRemoveRecord: h,
    } = Kn(e),
    C = Bt(e.field, e.optionLabel),
    y = m ? Gn(m, C) : null,
    v =
      y && y.id
        ? n.createElement(
            Ne,
            { onRemove: h, key: `selectedRecordTag_${y.id}` },
            n.createElement("p", { id: `${y.id}_${y.label}` }, y.label)
          )
        : f
        ? n.createElement(
            Ne,
            { onRemove: h, key: `selectedRecordTag_${f}` },
            n.createElement("p", { id: `${f}`, style: { color: "red" } }, "id: ", f)
          )
        : null,
    T = (S) => {
      const I = S.id;
      (m == null ? void 0 : m.id) === I ? h() : x(S);
    };
  return n.createElement(
    n.Fragment,
    null,
    n.createElement(
      me,
      {
        activator: n.createElement(me.TextField, {
          requiredIndicator: a.requiredArgumentForInput,
          onChange: o.set,
          value: o.value,
          name: t,
          label: e.label ?? a.name,
          placeholder: "Search",
          autoComplete: "off",
          verticalContent: v,
        }),
        onScrolledToBottom: i.loadNextPage,
        willLoadMoreOptions: i.hasNextPage && s.length >= Ht,
      },
      n.createElement(vt, {
        isLoading: u,
        errorMessage: d,
        checkSelected: (S) => S === (m == null ? void 0 : m.id),
        onSelect: T,
        options: c,
        records: l.records,
      })
    )
  );
});
Dn.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoBelongsToInput" };
const kn = (e) => (e.selectedRecords.length ? n.createElement(vr, { ...e }) : null),
  vr = (e) => {
    const { selectedRecords: t, optionLabel: a, onRemoveRecord: s } = e,
      c = Qn(t, a);
    return c.length
      ? c.map((i) =>
          n.createElement(
            Ne,
            {
              key: `option${i.id}`,
              onRemove: () => {
                const o = t.find((l) => l.id === i.id);
                s(o ?? { id: i.id });
              },
            },
            i.label
          )
        )
      : null;
  };
kn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "getSelectedRelatedRecordTags",
  props: {
    selectedRecords: {
      required: !0,
      tsType: {
        name: "Array",
        elements: [{ name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }],
        raw: "Record<string, any>[]",
      },
      description: "",
    },
    optionLabel: { required: !0, tsType: { name: "OptionLabel" }, description: "" },
    onRemoveRecord: {
      required: !0,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(record: Record<string, any>) => void",
        signature: {
          arguments: [
            { type: { name: "Record", elements: [{ name: "string" }, { name: "any" }], raw: "Record<string, any>" }, name: "record" },
          ],
          return: { name: "void" },
        },
      },
      description: "",
    },
  },
};
const wn = G((e) => {
  const { field: t } = e,
    {
      fieldMetadata: { path: a, metadata: s },
      relatedModelOptions: { options: c, searchFilterOptions: i, search: o, pagination: l, relatedModel: u },
      selectedRecords: d,
      errorMessage: m,
      isLoading: f,
      onSelectRecord: x,
      onRemoveRecord: h,
    } = Xn(e),
    C = Bt(t, e.optionLabel),
    y = r.useMemo(() => d.map((v) => v.id).filter((v) => !!v), [d]);
  return n.createElement(
    n.Fragment,
    null,
    n.createElement(
      me,
      {
        activator: n.createElement(me.TextField, {
          onChange: o.set,
          value: o.value,
          label: e.label ?? s.name,
          name: a,
          placeholder: "Search",
          autoComplete: "off",
          verticalContent: kn({ selectedRecords: d, onRemoveRecord: h, optionLabel: C }),
        }),
        onScrolledToBottom: l.loadNextPage,
        allowMultiple: !0,
        willLoadMoreOptions: l.hasNextPage && c.length >= Ht,
      },
      n.createElement(vt, {
        onSelect: x,
        records: u.records,
        options: i,
        checkSelected: (v) => y.includes(v),
        errorMessage: m,
        isLoading: f,
      })
    )
  );
});
wn.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoHasManyInput" };
const Fn = G((e) => {
  const { metadata: t } = Le(e.field);
  switch (t.configuration.fieldType) {
    case q.Id:
      return n.createElement(En, { field: e.field, label: e.label });
    case q.String:
    case q.Email:
    case q.Color:
    case q.Url:
      return n.createElement(qe, { field: e.field, label: e.label });
    case q.Number:
      return n.createElement(xn, { field: e.field, label: e.label });
    case q.EncryptedString:
      return n.createElement(bt, { field: e.field, label: e.label });
    case q.Password:
      return n.createElement(Tn, { field: e.field, label: e.label });
    case q.Boolean:
      return n.createElement(pn, { field: e.field, label: e.label });
    case q.DateTime:
      return n.createElement(bn, { field: e.field, label: e.label });
    case q.Json:
      return n.createElement(Pn, { field: e.field, label: e.label });
    case q.Enum:
      return n.createElement(hn, { field: e.field, label: e.label });
    case q.File:
      return n.createElement(vn, { field: e.field, label: e.label });
    case q.RoleAssignments:
      return n.createElement(An, { field: e.field, label: e.label });
    case q.BelongsTo:
      return n.createElement(Dn, { field: e.field, label: e.label });
    case q.HasOne:
      return null;
    case q.HasMany:
      return n.createElement(wn, { field: e.field, label: e.label });
    case q.HasManyThrough:
      return null;
    case q.RichText:
      return n.createElement(fn, { field: e.field, label: e.label });
    case q.Money:
      return null;
    case q.Vector:
    case q.Computed:
      return null;
    default:
      throw new Error(`Unsupported field type for Polaris AutoForm: ${t.fieldType}`);
  }
});
Fn.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisAutoInput",
  props: {
    field: { required: !0, tsType: { name: "string" }, description: "" },
    label: { required: !1, tsType: { name: "string" }, description: "" },
  },
};
const Mn = (e) => {
  const { submitResult: t } = $t(),
    a = t.isSubmitting;
  return n.createElement(Ee, { submit: !0, loading: e.isSubmitting ?? a, ...e }, e.children ?? "Submit");
};
Mn.__docgenInfo = {
  description: `Button for submitting the AutoForm values

The submission is handled by the  \`submit\` property on Button
Alternatively, the \`submit\` function from useAutoFormMetadata can be used to submit the form

const { submit } = useAutoFormMetadata();`,
  methods: [],
  displayName: "PolarisAutoSubmit",
  props: {
    children: { required: !1, tsType: { name: "ReactNode" }, description: "" },
    isSubmitting: { required: !1, tsType: { name: "boolean" }, description: "" },
  },
};
const Er = (e) =>
    n.createElement(n.Fragment, null, n.createElement(Et, { ...e.successBannerProps }), n.createElement(Pt, { ...e.errorBannerProps })),
  Et = (e) => {
    const { show: t, hide: a, successful: s, ...c } = Ut();
    return !t || !s ? null : n.createElement(Yt, { tone: "success", onDismiss: a, ...c, ...e });
  },
  Pt = (e) => {
    const { show: t, hide: a, successful: s, ...c } = Ut();
    return !t || s ? null : n.createElement(Yt, { tone: "critical", onDismiss: a, ...c, ...e });
  };
Er.__docgenInfo = {
  description: "",
  methods: [],
  displayName: "PolarisSubmitResultBanner",
  props: {
    successBannerProps: { required: !1, tsType: { name: "BannerProps" }, description: "" },
    errorBannerProps: { required: !1, tsType: { name: "BannerProps" }, description: "" },
  },
};
Et.__docgenInfo = { description: "", methods: [], displayName: "PolarisSubmitSuccessfulBanner" };
Pt.__docgenInfo = { description: "", methods: [], displayName: "PolarisSubmitErrorBanner" };
const mt = () =>
    n.createElement(n.Fragment, null, n.createElement(Ta, null, n.createElement(ur, { size: "medium" }), n.createElement(Ca, null))),
  Pr = (e) => {
    const { action: t, findBy: a } = e;
    ea(e);
    const s = `${t.modelApiIdentifier ?? ""}.${t.operationName}.${JSON.stringify(a)}`;
    return n.createElement(Wn, null, n.createElement(xr, { key: s, ...e }));
  },
  xr = (e) => {
    const { record: t, action: a, findBy: s, ...c } = e,
      {
        metadata: i,
        fetchingMetadata: o,
        isLoading: l,
        metadataError: u,
        fields: d,
        submit: m,
        formError: f,
        isSubmitting: x,
        isSubmitSuccessful: h,
        originalFormMethods: C,
      } = ta(e),
      y = e.title === void 0 ? Zn(a.operationName) : e.title;
    if (e.successContent && h) return e.successContent;
    const v = {
      findBy: s,
      submit: m,
      metadata: i,
      submitResult: { isSuccessful: h, error: f ?? u, isSubmitting: x },
      model: { apiIdentifier: a.modelApiIdentifier, namespace: a.namespace },
      fields: d,
    };
    if (o) return n.createElement(St, { ...c, onSubmit: m }, n.createElement(mt, null));
    const T =
      e.children ??
      n.createElement(
        n.Fragment,
        null,
        y && n.createElement(K, { variant: "headingLg", as: "h5" }, y),
        !e.onSuccess && n.createElement(Et, null),
        !e.onFailure && n.createElement(Pt, null),
        !u &&
          n.createElement(
            n.Fragment,
            null,
            d.map(({ metadata: S }) => n.createElement(Fn, { field: S.apiIdentifier, key: S.apiIdentifier })),
            n.createElement("div", null, n.createElement(Mn, null, e.submitLabel ?? "Submit", " "))
          )
      );
    return n.createElement(
      jn.Provider,
      { value: v },
      n.createElement(
        Yn,
        { ...C },
        l && n.createElement(mt, null),
        n.createElement("div", { hidden: l }, n.createElement(St, { ...c, onSubmit: m }, n.createElement(pt, { gap: "400" }, T)))
      )
    );
  };
mt.__docgenInfo = { description: "", methods: [], displayName: "PolarisAutoFormSkeleton" };
Pr.__docgenInfo = {
  description: "Renders a form for an action on a model automatically using Polaris",
  methods: [],
  displayName: "PolarisAutoForm",
  props: {
    action: { required: !0, tsType: { name: "ActionFunc" }, description: "Which action this fom will run on submit" },
    record: {
      required: !1,
      tsType: { name: "GadgetRecord", elements: [{ name: "any" }], raw: "GadgetRecord<any>" },
      description: "A record for this form to act on",
    },
    include: {
      required: !1,
      tsType: { name: "Array", elements: [{ name: "string" }], raw: "string[]" },
      description: "An allowlist of fields to render within the form. Only these fields will be rendered as inputs.",
    },
    exclude: {
      required: !1,
      tsType: { name: "Array", elements: [{ name: "string" }], raw: "string[]" },
      description: "A denylist of fields to render within the form. Every field except these fields will be rendered as inputs.",
    },
    defaultValues: {
      required: !1,
      tsType: { name: "DefaultValues" },
      description: "A set of field values to pre-populate the form with on load. Only applies to create forms.",
    },
    submitLabel: {
      required: !1,
      tsType: { name: "ReactNode" },
      description: "The label to use for the submit button at the bottom of the form",
    },
    successContent: {
      required: !1,
      tsType: { name: "ReactNode" },
      description: "What to show the user once the form has been submitted successfully",
    },
    title: {
      required: !1,
      tsType: { name: "union", raw: "string | false", elements: [{ name: "string" }, { name: "literal", value: "false" }] },
      description: "The title at the top of the form. False to omit",
    },
    select: {
      required: !1,
      tsType: { name: 'GivenOptions["select"]', raw: 'GivenOptions["select"]' },
      description:
        "Selection object to pass to the form to retrieve existing values. This will override the default selection based on included fields",
    },
    onSuccess: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: "(record: UseActionFormHookStateData<ActionFunc>) => void",
        signature: { arguments: [{ type: { name: "unknown" }, name: "record" }], return: { name: "void" } },
      },
      description: "Called when the form submission completes successfully on the backend",
    },
    onFailure: {
      required: !1,
      tsType: {
        name: "signature",
        type: "function",
        raw: '(error: Error | FieldErrors<ActionFunc["variablesType"]>) => void',
        signature: {
          arguments: [
            {
              type: {
                name: "union",
                raw: 'Error | FieldErrors<ActionFunc["variablesType"]>',
                elements: [
                  { name: "Error" },
                  {
                    name: "FieldErrors",
                    elements: [{ name: 'ActionFunc["variablesType"]', raw: 'ActionFunc["variablesType"]' }],
                    raw: 'FieldErrors<ActionFunc["variablesType"]>',
                  },
                ],
              },
              name: "error",
            },
          ],
          return: { name: "void" },
        },
      },
      description: "Called when the form submission errors before sending, during the API call, or if the API call returns an error.",
    },
    children: {
      required: !1,
      tsType: { name: "ReactNode" },
      description: "Custom components to render within the form. Using this will override all default field rendering.",
    },
    debug: { required: !1, tsType: { name: "boolean" }, description: "Enable debug logging for this form" },
  },
};
export { Pr as P, Jt as S, Mn as a, Fn as b, hn as c, Er as d, Tn as e, pn as f, vn as g, Pn as h, qe as i };
