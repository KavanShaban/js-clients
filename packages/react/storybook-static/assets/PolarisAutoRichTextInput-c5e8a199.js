import { j as nT, u as rT } from "./PolarisAutoForm-e187dbdc.js";
import { bQ as $M, aG as IM, bR as LM, aq as MM, b7 as RM, u as jp } from "./apis-d6201c92.js";
import { _ as z } from "./iframe-5aa777a6.js";
import {
  k as CM,
  l as EM,
  e as Hv,
  n as PM,
  z as SM,
  j as T,
  $ as TM,
  d as Uv,
  c as Xv,
  b as Yv,
  R as _M,
  g as bM,
  m as iT,
  s as kM,
  h as po,
  f as qv,
  i as wM,
  _ as xM,
  u as yM,
} from "./index-0511f421.js";
import { r as NM, a as QM, P as le } from "./index-baeb160b.js";
import { R as S, g as Vp, r as _, c as gS, a as vM } from "./index-c6dae603.js";
import { R as AM, r as Ss } from "./index-eb008d06.js";
var DM = Object.defineProperty,
  FM = (t, e, n) => (e in t ? DM(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  ao = (t, e, n) => (FM(t, typeof e != "symbol" ? e + "" : e, n), n);
let BM = class oT {
    constructor(e = new Map()) {
      this.map = e;
    }
    clone() {
      return new oT(new Map(this.map));
    }
    increment(e) {
      const n = this.map.get(e) ?? 0;
      this.map.set(e, n + 1);
    }
    decrement(e, n) {
      let r = this.map.get(e);
      r !== void 0 && ((r -= 1), this.map.set(e, r), r === 0 && n());
    }
  },
  jh = class {
    constructor() {
      ao(this, "map", new Map());
    }
    getOrCreate(e) {
      let n = this.map.get(e);
      return n === void 0 && ((n = new Set()), this.map.set(e, n)), n;
    }
    get(e) {
      return this.map.get(e);
    }
    use(e, n) {
      const r = this.get(e);
      r !== void 0 && n(r);
    }
    delete(e) {
      return this.map.delete(e);
    }
  };
function Sl(t, e) {
  return e(t), t;
}
function Gv() {}
function m0(t, e) {
  return t === e;
}
const Zp = new Map();
let Jv = class {
  constructor(e = {}) {
    ao(this, "subscriptions", new jh()),
      ao(this, "singletonSubscriptions", new Map()),
      ao(this, "graph", new jh()),
      ao(this, "state", new Map()),
      ao(this, "distinctNodes", new Map()),
      ao(this, "executionMaps", new Map()),
      ao(this, "definitionRegistry", new Set());
    for (const n of Object.getOwnPropertySymbols(e)) this.state.set(n, e[n]);
  }
  cellInstance(e, n = !0, r = Symbol()) {
    return (
      this.state.has(r) || this.state.set(r, e), n !== !1 && !this.distinctNodes.has(r) && this.distinctNodes.set(r, n === !0 ? m0 : n), r
    );
  }
  signalInstance(e = !0, n = Symbol()) {
    return e !== !1 && this.distinctNodes.set(n, e === !0 ? m0 : e), n;
  }
  sub(e, n) {
    this.register(e);
    const r = this.subscriptions.getOrCreate(e);
    return r.add(n), () => r.delete(n);
  }
  singletonSub(e, n) {
    return (
      this.register(e),
      n === void 0 ? this.singletonSubscriptions.delete(e) : this.singletonSubscriptions.set(e, n),
      () => this.singletonSubscriptions.delete(e)
    );
  }
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  subMultiple(e, n) {
    const r = this.signalInstance();
    return (
      this.connect({
        map:
          (i) =>
          (...o) => {
            i(o);
          },
        sink: r,
        sources: e,
      }),
      this.sub(r, n)
    );
  }
  pubIn(e) {
    var n;
    const r = Reflect.ownKeys(e),
      i = this.getExecutionMap(r),
      o = i.refCount.clone(),
      s = i.participatingNodes.slice(),
      l = new Map(this.state),
      a = (c) => {
        this.graph.use(c, (u) => {
          for (const { sources: h, sink: d } of u)
            h.has(c) &&
              o.decrement(d, () => {
                s.splice(s.indexOf(d), 1), a(d);
              });
        });
      };
    for (;;) {
      const c = s.shift();
      if (c === void 0) break;
      const u = c;
      let h = !1;
      const d = (f) => {
        const p = this.distinctNodes.get(u);
        if (p !== void 0 && p(l.get(u), f)) {
          h = !1;
          return;
        }
        (h = !0), l.set(u, f), this.state.has(u) && this.state.set(u, f);
      };
      if (
        (Object.prototype.hasOwnProperty.call(e, u)
          ? d(e[u])
          : i.projections.use(u, (f) => {
              for (const p of f) {
                const m = [...Array.from(p.sources), ...Array.from(p.pulls)].map((O) => l.get(O));
                p.map(d)(...m);
              }
            }),
        h)
      ) {
        const f = l.get(u);
        this.subscriptions.use(u, (p) => {
          for (const m of p) m(f);
        }),
          (n = this.singletonSubscriptions.get(u)) == null || n(f);
      } else a(u);
    }
  }
  connect({ sources: e, pulls: n = [], map: r, sink: i }) {
    const o = { map: r, pulls: new Set(n), sink: this.register(i), sources: new Set(e) };
    for (const s of [...e, ...n]) this.register(s), this.graph.getOrCreate(s).add(o);
    this.executionMaps.clear();
  }
  pub(e, n) {
    this.pubIn({ [e]: n });
  }
  pipe(e, ...n) {
    return this.combineOperators(...n)(e);
  }
  transformer(...e) {
    return (n) => Sl(this.signalInstance(), (r) => (this.link(this.pipe(r, ...e), n), r));
  }
  link(e, n) {
    this.connect({
      map: (r) => (i) => {
        r(i);
      },
      sink: n,
      sources: [e],
    });
  }
  combine(...e) {
    return Sl(this.signalInstance(), (n) => {
      this.connect({
        map:
          (r) =>
          (...i) => {
            r(i);
          },
        sink: n,
        sources: e,
      });
    });
  }
  getValue(e) {
    return this.register(e), this.state.get(e);
  }
  getValues(e) {
    return e.map((n) => this.getValue(n));
  }
  register(e) {
    const n = Zp.get(e);
    return n === void 0 || this.definitionRegistry.has(e)
      ? e
      : (this.definitionRegistry.add(e),
        Sl(n.type === "cell" ? this.cellInstance(n.initial, n.distinct, e) : this.signalInstance(n.distinct, e), (r) => {
          n.init(this, r);
        }));
  }
  changeWith(e, n, r) {
    this.connect({
      sources: [n],
      pulls: [e],
      sink: e,
      map: (i) => (o, s) => {
        i(r(s, o));
      },
    });
  }
  calculateExecutionMap(e) {
    const n = [],
      r = new Set(),
      i = new jh(),
      o = new BM(),
      s = new jh(),
      l = (a, c = 0) => {
        o.increment(a),
          !r.has(a) &&
            (this.register(a),
            i.use(a, (u) => {
              c = Math.max(...Array.from(u).map((h) => n.indexOf(h))) + 1;
            }),
            this.graph.use(a, (u) => {
              for (const h of u) h.sources.has(a) ? (s.getOrCreate(h.sink).add(h), l(h.sink, c)) : i.getOrCreate(h.sink).add(a);
            }),
            r.add(a),
            n.splice(c, 0, a));
      };
    return e.forEach(l), { participatingNodes: n, pendingPulls: i, projections: s, refCount: o };
  }
  getExecutionMap(e) {
    let n = e;
    if (e.length === 1) {
      n = e[0];
      const i = this.executionMaps.get(n);
      if (i !== void 0) return i;
    } else
      for (const [i, o] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === e.length && i.every((s) => e.includes(s))) return o;
    const r = this.calculateExecutionMap(e);
    return this.executionMaps.set(n, r), r;
  }
  combineOperators(...e) {
    return (n) => {
      for (const r of e) n = r(n, this);
      return n;
    };
  }
};
function we(t, e = Gv, n = !0) {
  return Sl(Symbol(), (r) => {
    Zp.set(r, { type: "cell", distinct: n, initial: t, init: e });
  });
}
function kt(t = Gv, e = !1) {
  return Sl(Symbol(), (n) => {
    Zp.set(n, { type: "signal", distinct: e, init: t });
  });
}
function Fr(t = Gv) {
  return Sl(Symbol(), (e) => {
    Zp.set(e, { type: "signal", distinct: !1, init: t });
  });
}
const zp = S.createContext(null);
function VM({ children: t, initWith: e, updateWith: n = {} }) {
  const r = S.useMemo(() => new Jv(e), []);
  return (
    S.useEffect(() => {
      r.pubIn(n);
    }, [n, r]),
    T.jsx(zp.Provider, { value: r, children: t })
  );
}
function Oa() {
  const t = S.useContext(zp);
  if (t === null) throw new Error("useRealm must be used within a RealmContextProvider");
  return t;
}
function mt(t) {
  const e = Oa();
  e.register(t);
  const n = S.useCallback((r) => e.sub(t, r), [e, t]);
  return S.useSyncExternalStore(
    n,
    () => e.getValue(t),
    () => e.getValue(t)
  );
}
function Ye(...t) {
  const e = Oa(),
    n = S.useMemo(() => e.getValues(t), []),
    r = S.useRef(n),
    i = S.useCallback(
      (o) => {
        const s = (l) => {
          (r.current = l), o();
        };
        return e.subMultiple(t, s);
      },
      [e, ...t]
    );
  return S.useSyncExternalStore(
    i,
    () => r.current,
    () => r.current
  );
}
function He(t) {
  const e = Oa();
  return (
    e.register(t),
    S.useCallback(
      (n) => {
        e.pub(t, n);
      },
      [e, t]
    )
  );
}
function jM(t) {
  return [mt(t), He(t)];
}
function mr(t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => (o) => {
          i(t(o));
        },
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function pt(...t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map:
          (i) =>
          (...o) => {
            i(o);
          },
        pulls: t,
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function Kv(t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => () => {
          i(t);
        },
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function va(t) {
  return (e, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => (o) => {
          t(o) && i(o);
        },
        sink: r,
        sources: [e],
      }),
      r
    );
  };
}
function ZM() {
  return (t, e) => {
    const n = e.signalInstance();
    let r = !1;
    return (
      e.connect({
        map: (i) => (o) => {
          r || ((r = !0), i(o));
        },
        sink: n,
        sources: [t],
      }),
      n
    );
  };
}
function eb(t, e) {
  return (n, r) => {
    const i = r.signalInstance();
    return (
      r.connect({
        map: (o) => (s) => {
          o((e = t(e, s)));
        },
        sink: i,
        sources: [n],
      }),
      i
    );
  };
}
function zM(t) {
  return (e, n) => {
    const r = n.signalInstance();
    let i,
      o = null;
    return (
      n.sub(e, (s) => {
        (i = s),
          o === null &&
            (o = setTimeout(() => {
              (o = null), n.pub(r, i);
            }, t));
      }),
      r
    );
  };
}
function WM(t) {
  return (e, n) => {
    const r = n.signalInstance();
    let i,
      o = null;
    return (
      n.sub(e, (s) => {
        (i = s),
          o !== null && clearTimeout(o),
          (o = setTimeout(() => {
            n.pub(r, i);
          }, t));
      }),
      r
    );
  };
}
function XM() {
  return (t, e) => {
    const n = e.signalInstance();
    return (
      e.sub(t, (r) => {
        queueMicrotask(() => {
          e.pub(n, r);
        });
      }),
      n
    );
  };
}
function UM(t) {
  return (e, n) => {
    const r = n.signalInstance(),
      i = Symbol();
    let o = i;
    return (
      n.connect({
        map: (s) => (l) => {
          o !== i && (s([o, l]), (o = i));
        },
        sink: r,
        sources: [t],
      }),
      n.sub(e, (s) => (o = s)),
      r
    );
  };
}
function HM(t, e, n) {
  return (r, i) => {
    const o = i.signalInstance();
    return (
      i.sub(r, (s) => {
        s !== null && typeof s == "object" && "then" in s
          ? (i.pub(o, t()),
            s
              .then((l) => {
                i.pub(o, e(l));
              })
              .catch((l) => {
                i.pub(o, n(l));
              }))
          : i.pub(o, e(s));
      }),
      o
    );
  };
}
function qM(t, e) {
  return (n) => t(e(n));
}
function YM(t, e) {
  return e(t);
}
function GM(t, e) {
  return (n) => t(e, n);
}
function JM(t, e) {
  return () => t(e);
}
function KM(t) {
  return (e) => e[t];
}
function tb(t, e) {
  return e(t), t;
}
function sT(t) {
  t();
}
function eL(t) {
  return () => t;
}
function tL(...t) {
  return () => {
    t.map(sT);
  };
}
function Co() {}
function Ut(t) {
  return function (e) {
    return {
      init: (n) => {
        var r;
        return (r = t.init) == null ? void 0 : r.call(t, n, e);
      },
      postInit: (n) => {
        var r;
        return (r = t.postInit) == null ? void 0 : r.call(t, n, e);
      },
      update: (n) => {
        var r;
        return (r = t.update) == null ? void 0 : r.call(t, n, e);
      },
    };
  };
}
function lT({ children: t, plugins: e }) {
  const n = S.useMemo(
    () =>
      tb(new Jv(), (r) => {
        var i, o;
        for (const s of e) (i = s.init) == null || i.call(s, r);
        for (const s of e) (o = s.postInit) == null || o.call(s, r);
      }),
    []
  );
  return (
    S.useEffect(() => {
      var r;
      for (const i of e) (r = i.update) == null || r.call(i, n);
    }),
    S.createElement(zp.Provider, { value: n }, t)
  );
}
function nL(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var rL = nL(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const gf = _.createContext(null);
function aT(t, e) {
  let n = null;
  return (
    t != null && (n = t[1]),
    {
      getTheme: function () {
        return e ?? (n != null ? n.getTheme() : null);
      },
    }
  );
}
function In() {
  const t = _.useContext(gf);
  return t == null && rL(8), t;
}
function Ji(t) {
  return {};
}
const ba = {},
  iL = {},
  Wp = {},
  Os = {},
  kl = {},
  Yc = {},
  Cl = {},
  Wu = {},
  g0 = {},
  Gc = {},
  Jc = {},
  Mi = {},
  Xp = {},
  Up = {},
  nb = {},
  cT = {},
  oL = {},
  rb = {},
  sL = {},
  ib = {},
  ob = {},
  Wl = {},
  uT = {},
  Xu = {},
  Uu = {},
  Hp = {},
  sb = {},
  hT = {},
  lb = {},
  O0 = {},
  ab = {},
  lL = {},
  qp = {},
  cb = {},
  aL = {},
  Yp = {},
  ub = {},
  v0 = {},
  cL = {},
  uL = {},
  pc = {},
  mc = {},
  hb = {},
  Gp = {},
  dT = {},
  Br = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  hL = Br && "documentMode" in document ? document.documentMode : null,
  Cr = Br && /Mac|iPod|iPhone|iPad/.test(navigator.platform),
  _o = Br && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),
  Of = !(!Br || !("InputEvent" in window) || hL) && "getTargetRanges" in new window.InputEvent("input"),
  db = Br && /Version\/[\d.]+.*Safari/.test(navigator.userAgent),
  Jp = Br && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
  dL = Br && /Android/.test(navigator.userAgent),
  fT = Br && /^(?=.*Chrome).*/i.test(navigator.userAgent),
  fL = Br && dL && fT,
  fb = Br && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !fT,
  Hu = 1,
  Wo = 3,
  ks = 0,
  pT = 1,
  Xl = 2,
  pL = 0,
  mL = 1,
  gL = 2,
  vf = 4,
  bf = 8,
  pb = 128,
  OL = 112 | (3 | vf | bf) | pb,
  mb = 1,
  gb = 2,
  Ob = 3,
  vb = 4,
  bb = 5,
  xb = 6,
  Kp = db || Jp || fb ? " " : "​",
  Zi = `

`,
  vL = _o ? " " : Kp,
  mT = "֑-߿יִ-﷽ﹰ-ﻼ",
  gT = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿",
  bL = new RegExp("^[^" + gT + "]*[" + mT + "]"),
  xL = new RegExp("^[^" + mT + "]*[" + gT + "]"),
  Di = { bold: 1, code: 16, highlight: pb, italic: 2, strikethrough: vf, subscript: 32, superscript: 64, underline: bf },
  yL = { directionless: 1, unmergeable: 2 },
  OS = { center: gb, end: xb, justify: vb, left: mb, right: Ob, start: bb },
  wL = { [gb]: "center", [xb]: "end", [vb]: "justify", [mb]: "left", [Ob]: "right", [bb]: "start" },
  SL = { normal: 0, segmented: 2, token: 1 },
  kL = { [pL]: "normal", [gL]: "segmented", [mL]: "token" };
function CL(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ge = CL(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function xf(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
const _L = 100;
let b0 = !1,
  yb = 0;
function EL(t) {
  yb = t.timeStamp;
}
function kg(t, e, n) {
  return e.__lexicalLineBreak === t || t[`__lexicalKey_${n._key}`] !== void 0;
}
function TL(t, e, n) {
  const r = mi(n._window);
  let i = null,
    o = null;
  r !== null && r.anchorNode === t && ((i = r.anchorOffset), (o = r.focusOffset));
  const s = t.nodeValue;
  s !== null && _b(e, s, i, o, !1);
}
function PL(t, e, n) {
  if (ee(t)) {
    const r = t.anchor.getNode();
    if (r.is(n) && t.format !== r.getFormat()) return !1;
  }
  return e.nodeType === Wo && n.isAttached();
}
function OT(t, e, n) {
  b0 = !0;
  const r = performance.now() - yb > _L;
  try {
    er(t, () => {
      const i =
          ae() ||
          (function (d) {
            return d.getEditorState().read(() => {
              const f = ae();
              return f !== null ? f.clone() : null;
            });
          })(t),
        o = new Map(),
        s = t.getRootElement(),
        l = t._editorState,
        a = t._blockCursorElement;
      let c = !1,
        u = "";
      for (let d = 0; d < e.length; d++) {
        const f = e[d],
          p = f.type,
          m = f.target;
        let O = pi(m, l);
        if (!((O === null && m !== s) || ot(O))) {
          if (p === "characterData") r && te(O) && PL(i, m, O) && TL(m, O, t);
          else if (p === "childList") {
            c = !0;
            const v = f.addedNodes;
            for (let x = 0; x < v.length; x++) {
              const k = v[x],
                w = ST(k),
                y = k.parentNode;
              if (y != null && k !== a && w === null && (k.nodeName !== "BR" || !kg(k, y, t))) {
                if (_o) {
                  const C = k.innerText || k.nodeValue;
                  C && (u += C);
                }
                y.removeChild(k);
              }
            }
            const g = f.removedNodes,
              b = g.length;
            if (b > 0) {
              let x = 0;
              for (let k = 0; k < b; k++) {
                const w = g[k];
                ((w.nodeName === "BR" && kg(w, m, t)) || a === w) && (m.appendChild(w), x++);
              }
              b !== x && (m === s && (O = CT(l)), o.set(m, O));
            }
          }
        }
      }
      if (o.size > 0)
        for (const [d, f] of o)
          if (X(f)) {
            const p = f.getChildrenKeys();
            let m = d.firstChild;
            for (let O = 0; O < p.length; O++) {
              const v = p[O],
                g = t.getElementByKey(v);
              g !== null && (m == null ? (d.appendChild(g), (m = g)) : m !== g && d.replaceChild(g, m), (m = m.nextSibling));
            }
          } else te(f) && f.markDirty();
      const h = n.takeRecords();
      if (h.length > 0) {
        for (let d = 0; d < h.length; d++) {
          const f = h[d],
            p = f.addedNodes,
            m = f.target;
          for (let O = 0; O < p.length; O++) {
            const v = p[O],
              g = v.parentNode;
            g == null || v.nodeName !== "BR" || kg(v, m, t) || g.removeChild(v);
          }
        }
        n.takeRecords();
      }
      i !== null && (c && ((i.dirty = !0), pn(i)), _o && PT(t) && i.insertRawText(u));
    });
  } finally {
    b0 = !1;
  }
}
function vT(t) {
  const e = t._observer;
  e !== null && OT(t, e.takeRecords(), e);
}
function bT(t) {
  (function (e) {
    yb === 0 && nm(e).addEventListener("textInput", EL, !0);
  })(t),
    (t._observer = new MutationObserver((e, n) => {
      OT(t, e, n);
    }));
}
function vS(t, e) {
  const n = t.__mode,
    r = t.__format,
    i = t.__style,
    o = e.__mode,
    s = e.__format,
    l = e.__style;
  return !((n !== null && n !== o) || (r !== null && r !== s) || (i !== null && i !== l));
}
function bS(t, e) {
  const n = t.mergeWithSibling(e),
    r = It()._normalizedNodes;
  return r.add(t.__key), r.add(e.__key), n;
}
function xS(t) {
  let e,
    n,
    r = t;
  if (r.__text !== "" || !r.isSimpleText() || r.isUnmergeable()) {
    for (; (e = r.getPreviousSibling()) !== null && te(e) && e.isSimpleText() && !e.isUnmergeable(); ) {
      if (e.__text !== "") {
        if (vS(e, r)) {
          r = bS(e, r);
          break;
        }
        break;
      }
      e.remove();
    }
    for (; (n = r.getNextSibling()) !== null && te(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if (n.__text !== "") {
        if (vS(r, n)) {
          r = bS(r, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else r.remove();
}
function wb(t) {
  return yS(t.anchor), yS(t.focus), t;
}
function yS(t) {
  for (; t.type === "element"; ) {
    const e = t.getNode(),
      n = t.offset;
    let r, i;
    if ((n === e.getChildrenSize() ? ((r = e.getChildAtIndex(n - 1)), (i = !0)) : ((r = e.getChildAtIndex(n)), (i = !1)), te(r))) {
      t.set(r.__key, i ? r.getTextContentSize() : 0, "text");
      break;
    }
    if (!X(r)) break;
    t.set(r.__key, i ? r.getChildrenSize() : 0, "element");
  }
}
let AL = 1;
const $L =
  typeof queueMicrotask == "function"
    ? queueMicrotask
    : (t) => {
        Promise.resolve().then(t);
      };
function Sb(t) {
  const e = document.activeElement;
  if (e === null) return !1;
  const n = e.nodeName;
  return ot(pi(t)) && (n === "INPUT" || n === "TEXTAREA" || (e.contentEditable === "true" && e.__lexicalEditor == null));
}
function qu(t, e, n) {
  const r = t.getRootElement();
  try {
    return r !== null && r.contains(e) && r.contains(n) && e !== null && !Sb(e) && xT(e) === t;
  } catch {
    return !1;
  }
}
function xT(t) {
  let e = t;
  for (; e != null; ) {
    const n = e.__lexicalEditor;
    if (n != null) return n;
    e = tm(e);
  }
  return null;
}
function sl(t) {
  return t.isToken() || t.isSegmented();
}
function RL(t) {
  return t.nodeType === Wo;
}
function yf(t) {
  let e = t;
  for (; e != null; ) {
    if (RL(e)) return e;
    e = e.firstChild;
  }
  return null;
}
function x0(t, e, n) {
  const r = Di[e];
  if (n !== null && (t & r) == (n & r)) return t;
  let i = t ^ r;
  return e === "subscript" ? (i &= ~Di.superscript) : e === "superscript" && (i &= ~Di.subscript), i;
}
function yT(t) {
  return te(t) || Ar(t) || ot(t);
}
function wT(t, e) {
  if (e != null) return void (t.__key = e);
  Cn(), qT();
  const n = It(),
    r = eo(),
    i = "" + AL++;
  r._nodeMap.set(i, t),
    X(t) ? n._dirtyElements.set(i, !0) : n._dirtyLeaves.add(i),
    n._cloneNotNeeded.add(i),
    (n._dirtyType = pT),
    (t.__key = i);
}
function vs(t) {
  const e = t.getParent();
  if (e !== null) {
    const n = t.getWritable(),
      r = e.getWritable(),
      i = t.getPreviousSibling(),
      o = t.getNextSibling();
    if (i === null)
      if (o !== null) {
        const s = o.getWritable();
        (r.__first = o.__key), (s.__prev = null);
      } else r.__first = null;
    else {
      const s = i.getWritable();
      if (o !== null) {
        const l = o.getWritable();
        (l.__prev = s.__key), (s.__next = l.__key);
      } else s.__next = null;
      n.__prev = null;
    }
    if (o === null)
      if (i !== null) {
        const s = i.getWritable();
        (r.__last = i.__key), (s.__next = null);
      } else r.__last = null;
    else {
      const s = o.getWritable();
      if (i !== null) {
        const l = i.getWritable();
        (l.__next = s.__key), (s.__prev = l.__key);
      } else s.__prev = null;
      n.__next = null;
    }
    r.__size--, (n.__parent = null);
  }
}
function wf(t) {
  qT();
  const e = t.getLatest(),
    n = e.__parent,
    r = eo(),
    i = It(),
    o = r._nodeMap,
    s = i._dirtyElements;
  n !== null &&
    (function (a, c, u) {
      let h = a;
      for (; h !== null; ) {
        if (u.has(h)) return;
        const d = c.get(h);
        if (d === void 0) break;
        u.set(h, !1), (h = d.__parent);
      }
    })(n, o, s);
  const l = e.__key;
  (i._dirtyType = pT), X(t) ? s.set(l, !0) : i._dirtyLeaves.add(l);
}
function ln(t) {
  Cn();
  const e = It(),
    n = e._compositionKey;
  if (t !== n) {
    if (((e._compositionKey = t), n !== null)) {
      const r = dt(n);
      r !== null && r.getWritable();
    }
    if (t !== null) {
      const r = dt(t);
      r !== null && r.getWritable();
    }
  }
}
function vo() {
  return Ju() ? null : It()._compositionKey;
}
function dt(t, e) {
  const n = (e || eo())._nodeMap.get(t);
  return n === void 0 ? null : n;
}
function ST(t, e) {
  const n = t[`__lexicalKey_${It()._key}`];
  return n !== void 0 ? dt(n, e) : null;
}
function pi(t, e) {
  let n = t;
  for (; n != null; ) {
    const r = ST(n, e);
    if (r !== null) return r;
    n = tm(n);
  }
  return null;
}
function kT(t) {
  const e = t._decorators,
    n = Object.assign({}, e);
  return (t._pendingDecorators = n), n;
}
function wS(t) {
  return t.read(() => Qe().getTextContent());
}
function Qe() {
  return CT(eo());
}
function CT(t) {
  return t._nodeMap.get("root");
}
function pn(t) {
  Cn();
  const e = eo();
  t !== null && ((t.dirty = !0), t.setCachedNodes(null)), (e._selection = t);
}
function ml(t) {
  const e = It(),
    n = (function (r, i) {
      let o = r;
      for (; o != null; ) {
        const s = o[`__lexicalKey_${i._key}`];
        if (s !== void 0) return s;
        o = tm(o);
      }
      return null;
    })(t, e);
  return n === null ? (t === e.getRootElement() ? dt("root") : null) : dt(n);
}
function SS(t, e) {
  return e ? t.getTextContentSize() : 0;
}
function _T(t) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(t);
}
function kb(t) {
  const e = [];
  let n = t;
  for (; n !== null; ) e.push(n), (n = n._parentEditor);
  return e;
}
function ET() {
  return Math.random()
    .toString(36)
    .replace(/[^a-z]+/g, "")
    .substr(0, 5);
}
function TT(t) {
  return t.nodeType === Wo ? t.nodeValue : null;
}
function Cb(t, e, n) {
  const r = mi(e._window);
  if (r === null) return;
  const i = r.anchorNode;
  let { anchorOffset: o, focusOffset: s } = r;
  if (i !== null) {
    let l = TT(i);
    const a = pi(i);
    if (l !== null && te(a)) {
      if (l === Kp && n) {
        const c = n.length;
        (l = n), (o = c), (s = c);
      }
      l !== null && _b(a, l, o, s, t);
    }
  }
}
function _b(t, e, n, r, i) {
  let o = t;
  if (o.isAttached() && (i || !o.isDirty())) {
    const s = o.isComposing();
    let l = e;
    (s || i) && e[e.length - 1] === Kp && (l = e.slice(0, -1));
    const a = o.getTextContent();
    if (i || l !== a) {
      if (l === "") {
        if ((ln(null), db || Jp || fb)) o.remove();
        else {
          const m = It();
          setTimeout(() => {
            m.update(() => {
              o.isAttached() && o.remove();
            });
          }, 20);
        }
        return;
      }
      const c = o.getParent(),
        u = Ws(),
        h = o.getTextContentSize(),
        d = vo(),
        f = o.getKey();
      if (
        o.isToken() ||
        (d !== null && f === d && !s) ||
        (ee(u) &&
          ((c !== null && !c.canInsertTextBefore() && u.anchor.offset === 0) ||
            (u.anchor.key === t.__key && u.anchor.offset === 0 && !o.canInsertTextBefore() && !s) ||
            (u.focus.key === t.__key && u.focus.offset === h && !o.canInsertTextAfter() && !s)))
      )
        return void o.markDirty();
      const p = ae();
      if (!ee(p) || n === null || r === null) return void o.setTextContent(l);
      if ((p.setTextNodeRange(o, n, o, r), o.isSegmented())) {
        const m = yt(o.getTextContent());
        o.replace(m), (o = m);
      }
      o.setTextContent(l);
    }
  }
}
function IL(t, e) {
  if (e.isSegmented()) return !0;
  if (!t.isCollapsed()) return !1;
  const n = t.anchor.offset,
    r = e.getParentOrThrow(),
    i = e.isToken();
  return n === 0
    ? !e.canInsertTextBefore() ||
        (!r.canInsertTextBefore() && !e.isComposing()) ||
        i ||
        (function (o) {
          const s = o.getPreviousSibling();
          return (te(s) || (X(s) && s.isInline())) && !s.canInsertTextAfter();
        })(e)
    : n === e.getTextContentSize() && (!e.canInsertTextAfter() || (!r.canInsertTextAfter() && !e.isComposing()) || i);
}
function kS(t) {
  return t === "ArrowLeft";
}
function CS(t) {
  return t === "ArrowRight";
}
function gc(t, e) {
  return Cr ? t : e;
}
function _S(t) {
  return t === "Enter";
}
function Ya(t) {
  return t === "Backspace";
}
function Ga(t) {
  return t === "Delete";
}
function ES(t, e, n) {
  return t.toLowerCase() === "a" && gc(e, n);
}
function ML() {
  const t = Qe();
  pn(wb(t.select(0, t.getChildrenSize())));
}
function Ic(t, e) {
  t.__lexicalClassNameCache === void 0 && (t.__lexicalClassNameCache = {});
  const n = t.__lexicalClassNameCache,
    r = n[e];
  if (r !== void 0) return r;
  const i = t[e];
  if (typeof i == "string") {
    const o = xf(i);
    return (n[e] = o), o;
  }
  return i;
}
function Eb(t, e, n, r, i) {
  if (n.size === 0) return;
  const o = r.__type,
    s = r.__key,
    l = e.get(o);
  l === void 0 && ge(33, o);
  const a = l.klass;
  let c = t.get(a);
  c === void 0 && ((c = new Map()), t.set(a, c));
  const u = c.get(s),
    h = u === "destroyed" && i === "created";
  (u === void 0 || h) && c.set(s, h ? "updated" : i);
}
function TS(t, e, n) {
  const r = t.getParent();
  let i = n,
    o = t;
  return (
    r !== null &&
      (e && n === 0
        ? ((i = o.getIndexWithinParent()), (o = r))
        : e || n !== o.getChildrenSize() || ((i = o.getIndexWithinParent() + 1), (o = r))),
    o.getChildAtIndex(e ? i - 1 : i)
  );
}
function Kc(t, e) {
  const n = t.offset;
  if (t.type === "element") return TS(t.getNode(), e, n);
  {
    const r = t.getNode();
    if ((e && n === 0) || (!e && n === r.getTextContentSize())) {
      const i = e ? r.getPreviousSibling() : r.getNextSibling();
      return i === null ? TS(r.getParentOrThrow(), e, r.getIndexWithinParent() + (e ? 0 : 1)) : i;
    }
  }
  return null;
}
function PT(t) {
  const e = nm(t).event,
    n = e && e.inputType;
  return n === "insertFromPaste" || n === "insertFromPasteAsQuotation";
}
function ve(t, e, n) {
  return YT(t, e, n);
}
function em(t) {
  return !tn(t) && !t.isLastChild() && !t.isInline();
}
function Sf(t, e) {
  const n = t._keyToDOMMap.get(e);
  return n === void 0 && ge(75, e), n;
}
function tm(t) {
  const e = t.assignedSlot || t.parentElement;
  return e !== null && e.nodeType === 11 ? e.host : e;
}
function LL(t) {
  Cn(), It()._updateTags.add(t);
}
function y0(t, e) {
  let n = t.getParent();
  for (; n !== null; ) {
    if (n.is(e)) return !0;
    n = n.getParent();
  }
  return !1;
}
function nm(t) {
  const e = t._window;
  return e === null && ge(78), e;
}
function NL(t) {
  let e = t.getParentOrThrow();
  for (; e !== null; ) {
    if (Yt(e)) return e;
    e = e.getParentOrThrow();
  }
  return e;
}
function Yt(t) {
  return tn(t) || (X(t) && t.isShadowRoot());
}
function QL(t) {
  const e = t.constructor.clone(t);
  return wT(e, null), e;
}
function Mn(t) {
  const e = It(),
    n = t.constructor.getType(),
    r = e._nodes.get(n);
  r === void 0 && ge(97);
  const i = r.replace;
  if (i !== null) {
    const o = i(t);
    return o instanceof t.constructor || ge(98), o;
  }
  return t;
}
function Cg(t, e) {
  !tn(t.getParent()) || X(e) || ot(e) || ge(99);
}
function _g(t) {
  return (ot(t) || (X(t) && !t.canBeEmpty())) && !t.isInline();
}
function Tb(t, e, n) {
  n.style.removeProperty("caret-color"), (e._blockCursorElement = null);
  const r = t.parentElement;
  r !== null && r.removeChild(t);
}
function DL(t, e, n) {
  let r = t._blockCursorElement;
  if (ee(n) && n.isCollapsed() && n.anchor.type === "element" && e.contains(document.activeElement)) {
    const i = n.anchor,
      o = i.getNode(),
      s = i.offset;
    let l = !1,
      a = null;
    if (s === o.getChildrenSize()) _g(o.getChildAtIndex(s - 1)) && (l = !0);
    else {
      const c = o.getChildAtIndex(s);
      if (_g(c)) {
        const u = c.getPreviousSibling();
        (u === null || _g(u)) && ((l = !0), (a = t.getElementByKey(c.__key)));
      }
    }
    if (l) {
      const c = t.getElementByKey(o.__key);
      return (
        r === null &&
          (t._blockCursorElement = r =
            (function (u) {
              const h = u.theme,
                d = document.createElement("div");
              (d.contentEditable = "false"), d.setAttribute("data-lexical-cursor", "true");
              let f = h.blockCursor;
              if (f !== void 0) {
                if (typeof f == "string") {
                  const p = xf(f);
                  f = h.blockCursor = p;
                }
                f !== void 0 && d.classList.add(...f);
              }
              return d;
            })(t._config)),
        (e.style.caretColor = "transparent"),
        void (a === null ? c.appendChild(r) : c.insertBefore(r, a))
      );
    }
  }
  r !== null && Tb(r, t, e);
}
function mi(t) {
  return Br ? (t || window).getSelection() : null;
}
function FL(t, e) {
  let n = t.getChildAtIndex(e);
  n == null && (n = t), Yt(t) && ge(102);
  const r = (s) => {
      const l = s.getParentOrThrow(),
        a = Yt(l),
        c = s !== n || a ? QL(s) : s;
      if (a) return (X(s) && X(c)) || ge(133), s.insertAfter(c), [s, c, c];
      {
        const [u, h, d] = r(l),
          f = s.getNextSiblings();
        return d.append(c, ...f), [u, h, c];
      }
    },
    [i, o] = r(n);
  return [i, o];
}
function BL(t) {
  return $r(t) && t.tagName === "A";
}
function $r(t) {
  return t.nodeType === 1;
}
function VL(t) {
  const e = new RegExp(
    /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/,
    "i"
  );
  return t.nodeName.match(e) !== null;
}
function jL(t) {
  const e = new RegExp(
    /^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/,
    "i"
  );
  return t.nodeName.match(e) !== null;
}
function ll(t) {
  if (tn(t) || (ot(t) && !t.isInline())) return !0;
  if (!X(t) || Yt(t)) return !1;
  const e = t.getFirstChild(),
    n = e === null || Ar(e) || te(e) || e.isInline();
  return !t.isInline() && t.canBeEmpty() !== !1 && n;
}
function Eg(t, e) {
  let n = t;
  for (; n !== null && n.getParent() !== null && !e(n); ) n = n.getParentOrThrow();
  return e(n) ? n : null;
}
function AT(t, e, n, r, i, o) {
  let s = t.getFirstChild();
  for (; s !== null; ) {
    const l = s.__key;
    s.__parent === e && (X(s) && AT(s, l, n, r, i, o), n.has(l) || o.delete(l), i.push(l)), (s = s.getNextSibling());
  }
}
let $o,
  Tn,
  eu,
  rm,
  w0,
  S0,
  Cs,
  Pr,
  k0,
  tu,
  Ht = "",
  En = "",
  _r = null,
  Ri = "",
  $T = !1,
  im = !1,
  zd = null;
function kf(t, e) {
  const n = Cs.get(t);
  if (e !== null) {
    const r = E0(t);
    r.parentNode === e && e.removeChild(r);
  }
  if ((Pr.has(t) || Tn._keyToDOMMap.delete(t), X(n))) {
    const r = _f(n, Cs);
    C0(r, 0, r.length - 1, null);
  }
  n !== void 0 && Eb(tu, eu, rm, n, "destroyed");
}
function C0(t, e, n, r) {
  let i = e;
  for (; i <= n; ++i) {
    const o = t[i];
    o !== void 0 && kf(o, r);
  }
}
function ss(t, e) {
  t.setProperty("text-align", e);
}
const ZL = "40px";
function RT(t, e) {
  const n = $o.theme.indent;
  if (typeof n == "string") {
    const i = t.classList.contains(n);
    e > 0 && !i ? t.classList.add(n) : e < 1 && i && t.classList.remove(n);
  }
  const r = getComputedStyle(t).getPropertyValue("--lexical-indent-base-value") || ZL;
  t.style.setProperty("padding-inline-start", e === 0 ? "" : `calc(${e} * ${r})`);
}
function IT(t, e) {
  const n = t.style;
  e === 0
    ? ss(n, "")
    : e === mb
    ? ss(n, "left")
    : e === gb
    ? ss(n, "center")
    : e === Ob
    ? ss(n, "right")
    : e === vb
    ? ss(n, "justify")
    : e === bb
    ? ss(n, "start")
    : e === xb && ss(n, "end");
}
function Cf(t, e, n) {
  const r = Pr.get(t);
  r === void 0 && ge(60);
  const i = r.createDOM($o, Tn);
  if (
    ((function (o, s, l) {
      const a = l._keyToDOMMap;
      (s["__lexicalKey_" + l._key] = o), a.set(o, s);
    })(t, i, Tn),
    te(r) ? i.setAttribute("data-lexical-text", "true") : ot(r) && i.setAttribute("data-lexical-decorator", "true"),
    X(r))
  ) {
    const o = r.__indent,
      s = r.__size;
    if ((o !== 0 && RT(i, o), s !== 0)) {
      const a = s - 1;
      (function (c, u, h, d) {
        const f = En;
        (En = ""), _0(c, h, 0, u, d, null), LT(h, d), (En = f);
      })(_f(r, Pr), a, r, i);
    }
    const l = r.__format;
    l !== 0 && IT(i, l), r.isInline() || MT(null, r, i), em(r) && ((Ht += Zi), (Ri += Zi));
  } else {
    const o = r.getTextContent();
    if (ot(r)) {
      const s = r.decorate(Tn, $o);
      s !== null && NT(t, s), (i.contentEditable = "false");
    } else te(r) && (r.isDirectionless() || (En += o));
    (Ht += o), (Ri += o);
  }
  if (e !== null)
    if (n != null) e.insertBefore(i, n);
    else {
      const o = e.__lexicalLineBreak;
      o != null ? e.insertBefore(i, o) : e.appendChild(i);
    }
  return Eb(tu, eu, rm, r, "created"), i;
}
function _0(t, e, n, r, i, o) {
  const s = Ht;
  Ht = "";
  let l = n;
  for (; l <= r; ++l) {
    Cf(t[l], i, o);
    const a = Pr.get(t[l]);
    a !== null && _r === null && te(a) && (_r = a.getFormat());
  }
  em(e) && (Ht += Zi), (i.__lexicalTextContent = Ht), (Ht = s + Ht);
}
function PS(t, e) {
  const n = e.get(t);
  return Ar(n) || (ot(n) && n.isInline());
}
function MT(t, e, n) {
  const r = t !== null && (t.__size === 0 || PS(t.__last, Cs)),
    i = e.__size === 0 || PS(e.__last, Pr);
  if (r) {
    if (!i) {
      const o = n.__lexicalLineBreak;
      o != null && n.removeChild(o), (n.__lexicalLineBreak = null);
    }
  } else if (i) {
    const o = document.createElement("br");
    (n.__lexicalLineBreak = o), n.appendChild(o);
  }
}
function LT(t, e) {
  const n = e.__lexicalDirTextContent,
    r = e.__lexicalDir;
  if (n !== En || r !== zd) {
    const o = En === "",
      s = o ? zd : ((i = En), bL.test(i) ? "rtl" : xL.test(i) ? "ltr" : null);
    if (s !== r) {
      const l = e.classList,
        a = $o.theme;
      let c = r !== null ? a[r] : void 0,
        u = s !== null ? a[s] : void 0;
      if (c !== void 0) {
        if (typeof c == "string") {
          const h = xf(c);
          c = a[r] = h;
        }
        l.remove(...c);
      }
      if (s === null || (o && s === "ltr")) e.removeAttribute("dir");
      else {
        if (u !== void 0) {
          if (typeof u == "string") {
            const h = xf(u);
            u = a[s] = h;
          }
          u !== void 0 && l.add(...u);
        }
        e.dir = s;
      }
      im || (t.getWritable().__dir = s);
    }
    (zd = s), (e.__lexicalDirTextContent = En), (e.__lexicalDir = s);
  }
  var i;
}
function zL(t, e, n) {
  const r = En;
  var i;
  (En = ""),
    (_r = null),
    (function (o, s, l) {
      const a = Ht,
        c = o.__size,
        u = s.__size;
      if (((Ht = ""), c === 1 && u === 1)) {
        const h = o.__first,
          d = s.__first;
        if (h === d) Oc(h, l);
        else {
          const p = E0(h),
            m = Cf(d, null, null);
          l.replaceChild(m, p), kf(h, null);
        }
        const f = Pr.get(d);
        _r === null && te(f) && (_r = f.getFormat());
      } else {
        const h = _f(o, Cs),
          d = _f(s, Pr);
        if (c === 0) u !== 0 && _0(d, s, 0, u - 1, l, null);
        else if (u === 0) {
          if (c !== 0) {
            const f = l.__lexicalLineBreak == null;
            C0(h, 0, c - 1, f ? null : l), f && (l.textContent = "");
          }
        } else
          (function (f, p, m, O, v, g) {
            const b = O - 1,
              x = v - 1;
            let k,
              w,
              y = ((E = g), E.firstChild),
              C = 0,
              P = 0;
            for (var E; C <= b && P <= x; ) {
              const D = p[C],
                Q = m[P];
              if (D === Q) (y = Tg(Oc(Q, g))), C++, P++;
              else {
                k === void 0 && (k = new Set(p)), w === void 0 && (w = new Set(m));
                const W = w.has(D),
                  B = k.has(Q);
                if (W)
                  if (B) {
                    const K = Sf(Tn, Q);
                    K === y ? (y = Tg(Oc(Q, g))) : (y != null ? g.insertBefore(K, y) : g.appendChild(K), Oc(Q, g)), C++, P++;
                  } else Cf(Q, g, y), P++;
                else (y = Tg(E0(D))), kf(D, g), C++;
              }
              const R = Pr.get(Q);
              R !== null && _r === null && te(R) && (_r = R.getFormat());
            }
            const N = C > b,
              L = P > x;
            if (N && !L) {
              const D = m[x + 1];
              _0(m, f, P, x, g, D === void 0 ? null : Tn.getElementByKey(D));
            } else L && !N && C0(p, C, b, g);
          })(s, h, d, c, u, l);
      }
      em(s) && (Ht += Zi), (l.__lexicalTextContent = Ht), (Ht = a + Ht);
    })(t, e, n),
    LT(e, n),
    zi((i = e)) && _r != null && _r !== i.__textFormat && !im && i.setTextFormat(_r),
    (En = r),
    (_r = null);
}
function _f(t, e) {
  const n = [];
  let r = t.__first;
  for (; r !== null; ) {
    const i = e.get(r);
    i === void 0 && ge(101), n.push(r), (r = i.__next);
  }
  return n;
}
function Oc(t, e) {
  const n = Cs.get(t);
  let r = Pr.get(t);
  (n !== void 0 && r !== void 0) || ge(61);
  const i = $T || S0.has(t) || w0.has(t),
    o = Sf(Tn, t);
  if (n === r && !i) {
    if (X(n)) {
      const s = o.__lexicalTextContent;
      s !== void 0 && ((Ht += s), (Ri += s));
      const l = o.__lexicalDirTextContent;
      l !== void 0 && (En += l);
    } else {
      const s = n.getTextContent();
      te(n) && !n.isDirectionless() && (En += s), (Ri += s), (Ht += s);
    }
    return o;
  }
  if ((n !== r && i && Eb(tu, eu, rm, r, "updated"), r.updateDOM(n, o, $o))) {
    const s = Cf(t, null, null);
    return e === null && ge(62), e.replaceChild(s, o), kf(t, null), s;
  }
  if (X(n) && X(r)) {
    const s = r.__indent;
    s !== n.__indent && RT(o, s);
    const l = r.__format;
    l !== n.__format && IT(o, l), i && (zL(n, r, o), tn(r) || r.isInline() || MT(n, r, o)), em(r) && ((Ht += Zi), (Ri += Zi));
  } else {
    const s = r.getTextContent();
    if (ot(r)) {
      const l = r.decorate(Tn, $o);
      l !== null && NT(t, l);
    } else te(r) && !r.isDirectionless() && (En += s);
    (Ht += s), (Ri += s);
  }
  if (!im && tn(r) && r.__cachedText !== Ri) {
    const s = r.getWritable();
    (s.__cachedText = Ri), (r = s);
  }
  return o;
}
function NT(t, e) {
  let n = Tn._pendingDecorators;
  const r = Tn._decorators;
  if (n === null) {
    if (r[t] === e) return;
    n = kT(Tn);
  }
  n[t] = e;
}
function Tg(t) {
  let e = t.nextSibling;
  return e !== null && e === Tn._blockCursorElement && (e = e.nextSibling), e;
}
function WL(t, e, n, r, i, o) {
  (Ht = ""),
    (Ri = ""),
    (En = ""),
    ($T = r === Xl),
    (zd = null),
    (Tn = n),
    ($o = n._config),
    (eu = n._nodes),
    (rm = Tn._listeners.mutation),
    (w0 = i),
    (S0 = o),
    (Cs = t._nodeMap),
    (Pr = e._nodeMap),
    (im = e._readOnly),
    (k0 = new Map(n._keyToDOMMap));
  const s = new Map();
  return (
    (tu = s),
    Oc("root", null),
    (Tn = void 0),
    (eu = void 0),
    (w0 = void 0),
    (S0 = void 0),
    (Cs = void 0),
    (Pr = void 0),
    ($o = void 0),
    (k0 = void 0),
    (tu = void 0),
    s
  );
}
function E0(t) {
  const e = k0.get(t);
  return e === void 0 && ge(75, t), e;
}
const Ti = Object.freeze({}),
  T0 = 30,
  P0 = [
    [
      "keydown",
      function (t, e) {
        if (((Mc = t.timeStamp), (QT = t.key), e.isComposing())) return;
        const { key: n, shiftKey: r, ctrlKey: i, metaKey: o, altKey: s } = t;
        ve(e, nb, t) ||
          (n != null &&
            ((function (l, a, c, u) {
              return CS(l) && !a && !u && !c;
            })(n, i, s, o)
              ? ve(e, cT, t)
              : (function (l, a, c, u, h) {
                  return CS(l) && !u && !c && (a || h);
                })(n, i, r, s, o)
              ? ve(e, oL, t)
              : (function (l, a, c, u) {
                  return kS(l) && !a && !u && !c;
                })(n, i, s, o)
              ? ve(e, rb, t)
              : (function (l, a, c, u, h) {
                  return kS(l) && !u && !c && (a || h);
                })(n, i, r, s, o)
              ? ve(e, sL, t)
              : (function (l, a, c) {
                  return (
                    (function (u) {
                      return u === "ArrowUp";
                    })(l) &&
                    !a &&
                    !c
                  );
                })(n, i, o)
              ? ve(e, ib, t)
              : (function (l, a, c) {
                  return (
                    (function (u) {
                      return u === "ArrowDown";
                    })(l) &&
                    !a &&
                    !c
                  );
                })(n, i, o)
              ? ve(e, ob, t)
              : (function (l, a) {
                  return _S(l) && a;
                })(n, r)
              ? ((Lc = !0), ve(e, Wl, t))
              : (function (l) {
                  return l === " ";
                })(n)
              ? ve(e, uT, t)
              : (function (l, a) {
                  return Cr && a && l.toLowerCase() === "o";
                })(n, i)
              ? (t.preventDefault(), (Lc = !0), ve(e, kl, !0))
              : (function (l, a) {
                  return _S(l) && !a;
                })(n, r)
              ? ((Lc = !1), ve(e, Wl, t))
              : (function (l, a, c, u) {
                  return Cr ? !a && !c && (Ya(l) || (l.toLowerCase() === "h" && u)) : !(u || a || c) && Ya(l);
                })(n, s, o, i)
              ? Ya(n)
                ? ve(e, Xu, t)
                : (t.preventDefault(), ve(e, Os, !0))
              : (function (l) {
                  return l === "Escape";
                })(n)
              ? ve(e, Uu, t)
              : (function (l, a, c, u, h) {
                  return Cr ? !(c || u || h) && (Ga(l) || (l.toLowerCase() === "d" && a)) : !(a || u || h) && Ga(l);
                })(n, i, r, s, o)
              ? Ga(n)
                ? ve(e, Hp, t)
                : (t.preventDefault(), ve(e, Os, !1))
              : (function (l, a, c) {
                  return Ya(l) && (Cr ? a : c);
                })(n, s, i)
              ? (t.preventDefault(), ve(e, Gc, !0))
              : (function (l, a, c) {
                  return Ga(l) && (Cr ? a : c);
                })(n, s, i)
              ? (t.preventDefault(), ve(e, Gc, !1))
              : (function (l, a) {
                  return Cr && a && Ya(l);
                })(n, o)
              ? (t.preventDefault(), ve(e, Jc, !0))
              : (function (l, a) {
                  return Cr && a && Ga(l);
                })(n, o)
              ? (t.preventDefault(), ve(e, Jc, !1))
              : (function (l, a, c, u) {
                  return l.toLowerCase() === "b" && !a && gc(c, u);
                })(n, s, o, i)
              ? (t.preventDefault(), ve(e, Mi, "bold"))
              : (function (l, a, c, u) {
                  return l.toLowerCase() === "u" && !a && gc(c, u);
                })(n, s, o, i)
              ? (t.preventDefault(), ve(e, Mi, "underline"))
              : (function (l, a, c, u) {
                  return l.toLowerCase() === "i" && !a && gc(c, u);
                })(n, s, o, i)
              ? (t.preventDefault(), ve(e, Mi, "italic"))
              : (function (l, a, c, u) {
                  return l === "Tab" && !a && !c && !u;
                })(n, s, i, o)
              ? ve(e, sb, t)
              : (function (l, a, c, u) {
                  return l.toLowerCase() === "z" && !a && gc(c, u);
                })(n, r, o, i)
              ? (t.preventDefault(), ve(e, Xp, void 0))
              : (function (l, a, c, u) {
                  return Cr ? l.toLowerCase() === "z" && c && a : (l.toLowerCase() === "y" && u) || (l.toLowerCase() === "z" && u && a);
                })(n, r, o, i)
              ? (t.preventDefault(), ve(e, Up, void 0))
              : Vt(e._editorState._selection)
              ? (function (l, a, c, u) {
                  return !a && l.toLowerCase() === "c" && (Cr ? c : u);
                })(n, r, o, i)
                ? (t.preventDefault(), ve(e, Yp, t))
                : (function (l, a, c, u) {
                    return !a && l.toLowerCase() === "x" && (Cr ? c : u);
                  })(n, r, o, i)
                ? (t.preventDefault(), ve(e, ub, t))
                : ES(n, o, i) && (t.preventDefault(), ve(e, v0, t))
              : !_o && ES(n, o, i) && (t.preventDefault(), ve(e, v0, t)),
            (function (l, a, c, u) {
              return l || a || c || u;
            })(i, r, s, o) && ve(e, dT, t)));
      },
    ],
    [
      "pointerdown",
      function (t, e) {
        const n = t.target,
          r = t.pointerType;
        n instanceof Node &&
          r !== "touch" &&
          er(e, () => {
            ot(pi(n)) || ($0 = !0);
          });
      },
    ],
    [
      "compositionstart",
      function (t, e) {
        er(e, () => {
          const n = ae();
          if (ee(n) && !e.isComposing()) {
            const r = n.anchor,
              i = n.anchor.getNode();
            ln(r.key),
              (t.timeStamp < Mc + T0 ||
                r.type === "element" ||
                !n.isCollapsed() ||
                i.getFormat() !== n.format ||
                (te(i) && i.getStyle() !== n.style)) &&
                ve(e, Cl, vL);
          }
        });
      },
    ],
    [
      "compositionend",
      function (t, e) {
        _o
          ? (Ja = !0)
          : er(e, () => {
              Pg(e, t.data);
            });
      },
    ],
    [
      "input",
      function (t, e) {
        t.stopPropagation(),
          er(e, () => {
            const n = ae(),
              r = t.data,
              i = VT(t);
            if (r != null && ee(n) && BT(n, i, r, t.timeStamp, !1)) {
              Ja && (Pg(e, r), (Ja = !1));
              const o = n.anchor.getNode(),
                s = mi(e._window);
              if (s === null) return;
              const l = n.isBackward(),
                a = l ? n.anchor.offset : n.focus.offset,
                c = l ? n.focus.offset : n.anchor.offset;
              (Of &&
                !n.isCollapsed() &&
                te(o) &&
                s.anchorNode !== null &&
                o.getTextContent().slice(0, a) + r + o.getTextContent().slice(a + c) === TT(s.anchorNode)) ||
                ve(e, Cl, r);
              const u = r.length;
              _o && u > 1 && t.inputType === "insertCompositionText" && !e.isComposing() && (n.anchor.offset -= u),
                db || Jp || fb || !e.isComposing() || ((Mc = 0), ln(null));
            } else Cb(!1, e, r !== null ? r : void 0), Ja && (Pg(e, r || void 0), (Ja = !1));
            Cn(), vT(It());
          }),
          (al = null);
      },
    ],
    [
      "click",
      function (t, e) {
        er(e, () => {
          const n = ae(),
            r = mi(e._window),
            i = Ws();
          if (r) {
            if (ee(n)) {
              const o = n.anchor,
                s = o.getNode();
              o.type === "element" &&
              o.offset === 0 &&
              n.isCollapsed() &&
              !tn(s) &&
              Qe().getChildrenSize() === 1 &&
              s.getTopLevelElementOrThrow().isEmpty() &&
              i !== null &&
              n.is(i)
                ? (r.removeAllRanges(), (n.dirty = !0))
                : t.detail === 3 && !n.isCollapsed() && s !== n.focus.getNode() && (X(s) ? s.select(0) : s.getParentOrThrow().select(0));
            } else if (t.pointerType === "touch") {
              const o = r.anchorNode;
              if (o !== null) {
                const s = o.nodeType;
                (s === Hu || s === Wo) && pn($b(i, r, e, t));
              }
            }
          }
          ve(e, Wp, t);
        });
      },
    ],
    ["cut", Ti],
    ["copy", Ti],
    ["dragstart", Ti],
    ["dragover", Ti],
    ["dragend", Ti],
    ["paste", Ti],
    ["focus", Ti],
    ["blur", Ti],
    ["drop", Ti],
  ];
Of &&
  P0.push([
    "beforeinput",
    (t, e) =>
      (function (n, r) {
        const i = n.inputType,
          o = VT(n);
        i === "deleteCompositionText" ||
          (_o && PT(r)) ||
          (i !== "insertCompositionText" &&
            er(r, () => {
              const s = ae();
              if (i === "deleteContentBackward") {
                if (s === null) {
                  const f = Ws();
                  if (!ee(f)) return;
                  pn(f.clone());
                }
                if (ee(s)) {
                  const f = s.anchor.key === s.focus.key;
                  if (((l = n.timeStamp), QT === "MediaLast" && l < Mc + T0 && r.isComposing() && f)) {
                    if (
                      (ln(null),
                      (Mc = 0),
                      setTimeout(() => {
                        er(r, () => {
                          ln(null);
                        });
                      }, T0),
                      ee(s))
                    ) {
                      const p = s.anchor.getNode();
                      p.markDirty(), (s.format = p.getFormat()), te(p) || ge(142), (s.style = p.getStyle());
                    }
                  } else {
                    ln(null), n.preventDefault();
                    const p = s.anchor.getNode().getTextContent(),
                      m = s.anchor.offset === 0 && s.focus.offset === p.length;
                    (fL && f && !m) || ve(r, Os, !0);
                  }
                  return;
                }
              }
              var l;
              if (!ee(s)) return;
              const a = n.data;
              al !== null && Cb(!1, r, al),
                (s.dirty && al === null) || !s.isCollapsed() || tn(s.anchor.getNode()) || o === null || s.applyDOMRange(o),
                (al = null);
              const c = s.anchor,
                u = s.focus,
                h = c.getNode(),
                d = u.getNode();
              if (i !== "insertText" && i !== "insertTranspose")
                switch ((n.preventDefault(), i)) {
                  case "insertFromYank":
                  case "insertFromDrop":
                  case "insertReplacementText":
                    ve(r, Cl, n);
                    break;
                  case "insertFromComposition":
                    ln(null), ve(r, Cl, n);
                    break;
                  case "insertLineBreak":
                    ln(null), ve(r, kl, !1);
                    break;
                  case "insertParagraph":
                    ln(null), Lc && !Jp ? ((Lc = !1), ve(r, kl, !1)) : ve(r, Yc, void 0);
                    break;
                  case "insertFromPaste":
                  case "insertFromPasteAsQuotation":
                    ve(r, Wu, n);
                    break;
                  case "deleteByComposition":
                    (function (f, p) {
                      return f !== p || X(f) || X(p) || !f.isToken() || !p.isToken();
                    })(h, d) && ve(r, g0, n);
                    break;
                  case "deleteByDrag":
                  case "deleteByCut":
                    ve(r, g0, n);
                    break;
                  case "deleteContent":
                    ve(r, Os, !1);
                    break;
                  case "deleteWordBackward":
                    ve(r, Gc, !0);
                    break;
                  case "deleteWordForward":
                    ve(r, Gc, !1);
                    break;
                  case "deleteHardLineBackward":
                  case "deleteSoftLineBackward":
                    ve(r, Jc, !0);
                    break;
                  case "deleteContentForward":
                  case "deleteHardLineForward":
                  case "deleteSoftLineForward":
                    ve(r, Jc, !1);
                    break;
                  case "formatStrikeThrough":
                    ve(r, Mi, "strikethrough");
                    break;
                  case "formatBold":
                    ve(r, Mi, "bold");
                    break;
                  case "formatItalic":
                    ve(r, Mi, "italic");
                    break;
                  case "formatUnderline":
                    ve(r, Mi, "underline");
                    break;
                  case "historyUndo":
                    ve(r, Xp, void 0);
                    break;
                  case "historyRedo":
                    ve(r, Up, void 0);
                }
              else {
                if (
                  a ===
                  `
`
                )
                  n.preventDefault(), ve(r, kl, !1);
                else if (a === Zi) n.preventDefault(), ve(r, Yc, void 0);
                else if (a == null && n.dataTransfer) {
                  const f = n.dataTransfer.getData("text/plain");
                  n.preventDefault(), s.insertRawText(f);
                } else a != null && BT(s, o, a, n.timeStamp, !0) ? (n.preventDefault(), ve(r, Cl, a)) : (al = a);
                DT = n.timeStamp;
              }
            }));
      })(t, e),
  ]);
let Mc = 0,
  QT = null,
  DT = 0,
  al = null;
const Ef = new WeakMap();
let A0 = !1,
  $0 = !1,
  Lc = !1,
  Ja = !1,
  FT = [0, "", 0, "root", 0];
function BT(t, e, n, r, i) {
  const o = t.anchor,
    s = t.focus,
    l = o.getNode(),
    a = It(),
    c = mi(a._window),
    u = c !== null ? c.anchorNode : null,
    h = o.key,
    d = a.getElementByKey(h),
    f = n.length;
  return (
    h !== s.key ||
    !te(l) ||
    (((!i && (!Of || DT < r + 50)) || (l.isDirty() && f < 2) || _T(n)) && o.offset !== s.offset && !l.isComposing()) ||
    sl(l) ||
    (l.isDirty() && f > 1) ||
    ((i || !Of) && d !== null && !l.isComposing() && u !== yf(d)) ||
    (c !== null && e !== null && (!e.collapsed || e.startContainer !== c.anchorNode || e.startOffset !== c.anchorOffset)) ||
    l.getFormat() !== t.format ||
    l.getStyle() !== t.style ||
    IL(t, l)
  );
}
function AS(t, e) {
  return t !== null && t.nodeValue !== null && t.nodeType === Wo && e !== 0 && e !== t.nodeValue.length;
}
function $S(t, e, n) {
  const { anchorNode: r, anchorOffset: i, focusNode: o, focusOffset: s } = t;
  (A0 && ((A0 = !1), AS(r, i) && AS(o, s))) ||
    er(e, () => {
      if (!n) return void pn(null);
      if (!qu(e, r, o)) return;
      const l = ae();
      if (ee(l)) {
        const a = l.anchor,
          c = a.getNode();
        if (l.isCollapsed()) {
          t.type === "Range" && t.anchorNode === t.focusNode && (l.dirty = !0);
          const u = nm(e).event,
            h = u ? u.timeStamp : performance.now(),
            [d, f, p, m, O] = FT,
            v = Qe(),
            g = e.isComposing() === !1 && v.getTextContent() === "";
          if (h < O + 200 && a.offset === p && a.key === m) (l.format = d), (l.style = f);
          else if (a.type === "text") te(c) || ge(141), (l.format = c.getFormat()), (l.style = c.getStyle());
          else if (a.type === "element" && !g) {
            const b = a.getNode();
            b instanceof Xs && b.getChildrenSize() === 0 ? (l.format = b.getTextFormat()) : (l.format = 0), (l.style = "");
          }
        } else {
          const u = a.key,
            h = l.focus.key,
            d = l.getNodes(),
            f = d.length,
            p = l.isBackward(),
            m = p ? s : i,
            O = p ? i : s,
            v = p ? h : u,
            g = p ? u : h;
          let b = OL,
            x = !1;
          for (let k = 0; k < f; k++) {
            const w = d[k],
              y = w.getTextContentSize();
            if (
              te(w) &&
              y !== 0 &&
              !((k === 0 && w.__key === v && m === y) || (k === f - 1 && w.__key === g && O === 0)) &&
              ((x = !0), (b &= w.getFormat()), b === 0)
            )
              break;
          }
          l.format = x ? b : 0;
        }
      }
      ve(e, ba, void 0);
    });
}
function VT(t) {
  if (!t.getTargetRanges) return null;
  const e = t.getTargetRanges();
  return e.length === 0 ? null : e[0];
}
function Pg(t, e) {
  const n = t._compositionKey;
  if ((ln(null), n !== null && e != null)) {
    if (e === "") {
      const r = dt(n),
        i = yf(t.getElementByKey(n));
      return void (i !== null && i.nodeValue !== null && te(r) && _b(r, i.nodeValue, null, null, !0));
    }
    if (
      e[e.length - 1] ===
      `
`
    ) {
      const r = ae();
      if (ee(r)) {
        const i = r.focus;
        return r.anchor.set(i.key, i.offset, i.type), void ve(t, Wl, null);
      }
    }
  }
  Cb(!0, t, e);
}
function jT(t) {
  let e = t.__lexicalEventHandles;
  return e === void 0 && ((e = []), (t.__lexicalEventHandles = e)), e;
}
const _l = new Map();
function ZT(t) {
  const e = t.target,
    n = mi(e == null ? null : e.nodeType === 9 ? e.defaultView : e.ownerDocument.defaultView);
  if (n === null) return;
  const r = xT(n.anchorNode);
  if (r === null) return;
  $0 &&
    (($0 = !1),
    er(r, () => {
      const c = Ws(),
        u = n.anchorNode;
      if (u === null) return;
      const h = u.nodeType;
      (h !== Hu && h !== Wo) || pn($b(c, n, r, t));
    }));
  const i = kb(r),
    o = i[i.length - 1],
    s = o._key,
    l = _l.get(s),
    a = l || o;
  a !== r && $S(n, a, !1), $S(n, r, !0), r !== o ? _l.set(s, r) : l && _l.delete(s);
}
function RS(t) {
  t._lexicalHandled = !0;
}
function IS(t) {
  return t._lexicalHandled === !0;
}
function XL(t) {
  const e = t.ownerDocument,
    n = Ef.get(e);
  n === void 0 && ge(162);
  const r = n - 1;
  r >= 0 || ge(164), Ef.set(e, r), r === 0 && e.removeEventListener("selectionchange", ZT);
  const i = t.__lexicalEditor;
  i != null &&
    ((function (s) {
      if (s._parentEditor !== null) {
        const l = kb(s),
          a = l[l.length - 1]._key;
        _l.get(a) === s && _l.delete(a);
      } else _l.delete(s._key);
    })(i),
    (t.__lexicalEditor = null));
  const o = jT(t);
  for (let s = 0; s < o.length; s++) o[s]();
  t.__lexicalEventHandles = [];
}
function R0(t, e, n) {
  Cn();
  const r = t.__key,
    i = t.getParent();
  if (i === null) return;
  const o = (function (l) {
    const a = ae();
    if (!ee(a) || !X(l)) return a;
    const { anchor: c, focus: u } = a,
      h = c.getNode(),
      d = u.getNode();
    return y0(h, l) && c.set(l.__key, 0, "element"), y0(d, l) && u.set(l.__key, 0, "element"), a;
  })(t);
  let s = !1;
  if (ee(o) && e) {
    const l = o.anchor,
      a = o.focus;
    l.key === r && (Af(l, t, i, t.getPreviousSibling(), t.getNextSibling()), (s = !0)),
      a.key === r && (Af(a, t, i, t.getPreviousSibling(), t.getNextSibling()), (s = !0));
  } else Vt(o) && e && t.isSelected() && t.selectPrevious();
  if (ee(o) && e && !s) {
    const l = t.getIndexWithinParent();
    vs(t), Pf(o, i, l, -1);
  } else vs(t);
  n || Yt(i) || i.canBeEmpty() || !i.isEmpty() || R0(i, e), e && tn(i) && i.isEmpty() && i.selectEnd();
}
class om {
  static getType() {
    ge(64, this.name);
  }
  static clone(e) {
    ge(65, this.name);
  }
  constructor(e) {
    (this.__type = this.constructor.getType()), (this.__parent = null), (this.__prev = null), (this.__next = null), wT(this, e);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    ge(137, this.constructor.name);
  }
  isAttached() {
    let e = this.__key;
    for (; e !== null; ) {
      if (e === "root") return !0;
      const n = dt(e);
      if (n === null) break;
      e = n.__parent;
    }
    return !1;
  }
  isSelected(e) {
    const n = e || ae();
    if (n == null) return !1;
    const r = n.getNodes().some((i) => i.__key === this.__key);
    return (
      (te(this) ||
        !ee(n) ||
        n.anchor.type !== "element" ||
        n.focus.type !== "element" ||
        n.anchor.key !== n.focus.key ||
        n.anchor.offset !== n.focus.offset) &&
      r
    );
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const e = this.getParent();
    if (e === null) return -1;
    let n = e.getFirstChild(),
      r = 0;
    for (; n !== null; ) {
      if (this.is(n)) return r;
      r++, (n = n.getNextSibling());
    }
    return -1;
  }
  getParent() {
    const e = this.getLatest().__parent;
    return e === null ? null : dt(e);
  }
  getParentOrThrow() {
    const e = this.getParent();
    return e === null && ge(66, this.__key), e;
  }
  getTopLevelElement() {
    let e = this;
    for (; e !== null; ) {
      const n = e.getParent();
      if (Yt(n)) return X(e) || ge(138), e;
      e = n;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const e = this.getTopLevelElement();
    return e === null && ge(67, this.__key), e;
  }
  getParents() {
    const e = [];
    let n = this.getParent();
    for (; n !== null; ) e.push(n), (n = n.getParent());
    return e;
  }
  getParentKeys() {
    const e = [];
    let n = this.getParent();
    for (; n !== null; ) e.push(n.__key), (n = n.getParent());
    return e;
  }
  getPreviousSibling() {
    const e = this.getLatest().__prev;
    return e === null ? null : dt(e);
  }
  getPreviousSiblings() {
    const e = [],
      n = this.getParent();
    if (n === null) return e;
    let r = n.getFirstChild();
    for (; r !== null && !r.is(this); ) e.push(r), (r = r.getNextSibling());
    return e;
  }
  getNextSibling() {
    const e = this.getLatest().__next;
    return e === null ? null : dt(e);
  }
  getNextSiblings() {
    const e = [];
    let n = this.getNextSibling();
    for (; n !== null; ) e.push(n), (n = n.getNextSibling());
    return e;
  }
  getCommonAncestor(e) {
    const n = this.getParents(),
      r = e.getParents();
    X(this) && n.unshift(this), X(e) && r.unshift(e);
    const i = n.length,
      o = r.length;
    if (i === 0 || o === 0 || n[i - 1] !== r[o - 1]) return null;
    const s = new Set(r);
    for (let l = 0; l < i; l++) {
      const a = n[l];
      if (s.has(a)) return a;
    }
    return null;
  }
  is(e) {
    return e != null && this.__key === e.__key;
  }
  isBefore(e) {
    if (this === e) return !1;
    if (e.isParentOf(this)) return !0;
    if (this.isParentOf(e)) return !1;
    const n = this.getCommonAncestor(e);
    let r = 0,
      i = 0,
      o = this;
    for (;;) {
      const s = o.getParentOrThrow();
      if (s === n) {
        r = o.getIndexWithinParent();
        break;
      }
      o = s;
    }
    for (o = e; ; ) {
      const s = o.getParentOrThrow();
      if (s === n) {
        i = o.getIndexWithinParent();
        break;
      }
      o = s;
    }
    return r < i;
  }
  isParentOf(e) {
    const n = this.__key;
    if (n === e.__key) return !1;
    let r = e;
    for (; r !== null; ) {
      if (r.__key === n) return !0;
      r = r.getParent();
    }
    return !1;
  }
  getNodesBetween(e) {
    const n = this.isBefore(e),
      r = [],
      i = new Set();
    let o = this;
    for (; o !== null; ) {
      const s = o.__key;
      if ((i.has(s) || (i.add(s), r.push(o)), o === e)) break;
      const l = X(o) ? (n ? o.getFirstChild() : o.getLastChild()) : null;
      if (l !== null) {
        o = l;
        continue;
      }
      const a = n ? o.getNextSibling() : o.getPreviousSibling();
      if (a !== null) {
        o = a;
        continue;
      }
      const c = o.getParentOrThrow();
      if ((i.has(c.__key) || r.push(c), c === e)) break;
      let u = null,
        h = c;
      do {
        if ((h === null && ge(68), (u = n ? h.getNextSibling() : h.getPreviousSibling()), (h = h.getParent()), h === null)) break;
        u !== null || i.has(h.__key) || r.push(h);
      } while (u === null);
      o = u;
    }
    return n || r.reverse(), r;
  }
  isDirty() {
    const e = It()._dirtyLeaves;
    return e !== null && e.has(this.__key);
  }
  getLatest() {
    const e = dt(this.__key);
    return e === null && ge(113), e;
  }
  getWritable() {
    Cn();
    const e = eo(),
      n = It(),
      r = e._nodeMap,
      i = this.__key,
      o = this.getLatest(),
      s = o.__parent,
      l = n._cloneNotNeeded,
      a = ae();
    if ((a !== null && a.setCachedNodes(null), l.has(i))) return wf(o), o;
    const c = o.constructor.clone(o);
    return (
      (c.__parent = s),
      (c.__next = o.__next),
      (c.__prev = o.__prev),
      X(o) && X(c)
        ? (zi(o) && zi(c) && (c.__textFormat = o.__textFormat),
          (c.__first = o.__first),
          (c.__last = o.__last),
          (c.__size = o.__size),
          (c.__indent = o.__indent),
          (c.__format = o.__format),
          (c.__dir = o.__dir))
        : te(o) && te(c) && ((c.__format = o.__format), (c.__style = o.__style), (c.__mode = o.__mode), (c.__detail = o.__detail)),
      l.add(i),
      (c.__key = i),
      wf(c),
      r.set(i, c),
      c
    );
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(e, n) {
    ge(70);
  }
  updateDOM(e, n, r) {
    ge(71);
  }
  exportDOM(e) {
    return { element: this.createDOM(e._config, e) };
  }
  exportJSON() {
    ge(72);
  }
  static importJSON(e) {
    ge(18, this.name);
  }
  static transform() {
    return null;
  }
  remove(e) {
    R0(this, !0, e);
  }
  replace(e, n) {
    Cn();
    let r = ae();
    r !== null && (r = r.clone()), Cg(this, e);
    const i = this.getLatest(),
      o = this.__key,
      s = e.__key,
      l = e.getWritable(),
      a = this.getParentOrThrow().getWritable(),
      c = a.__size;
    vs(l);
    const u = i.getPreviousSibling(),
      h = i.getNextSibling(),
      d = i.__prev,
      f = i.__next,
      p = i.__parent;
    if (
      (R0(i, !1, !0),
      u === null ? (a.__first = s) : (u.getWritable().__next = s),
      (l.__prev = d),
      h === null ? (a.__last = s) : (h.getWritable().__prev = s),
      (l.__next = f),
      (l.__parent = p),
      (a.__size = c),
      n &&
        ((X(this) && X(l)) || ge(139),
        this.getChildren().forEach((m) => {
          l.append(m);
        })),
      ee(r))
    ) {
      pn(r);
      const m = r.anchor,
        O = r.focus;
      m.key === o && DS(m, l), O.key === o && DS(O, l);
    }
    return vo() === o && ln(s), l;
  }
  insertAfter(e, n = !0) {
    Cn(), Cg(this, e);
    const r = this.getWritable(),
      i = e.getWritable(),
      o = i.getParent(),
      s = ae();
    let l = !1,
      a = !1;
    if (o !== null) {
      const f = e.getIndexWithinParent();
      if ((vs(i), ee(s))) {
        const p = o.__key,
          m = s.anchor,
          O = s.focus;
        (l = m.type === "element" && m.key === p && m.offset === f + 1), (a = O.type === "element" && O.key === p && O.offset === f + 1);
      }
    }
    const c = this.getNextSibling(),
      u = this.getParentOrThrow().getWritable(),
      h = i.__key,
      d = r.__next;
    if (
      (c === null ? (u.__last = h) : (c.getWritable().__prev = h),
      u.__size++,
      (r.__next = h),
      (i.__next = d),
      (i.__prev = r.__key),
      (i.__parent = r.__parent),
      n && ee(s))
    ) {
      const f = this.getIndexWithinParent();
      Pf(s, u, f + 1);
      const p = u.__key;
      l && s.anchor.set(p, f + 2, "element"), a && s.focus.set(p, f + 2, "element");
    }
    return e;
  }
  insertBefore(e, n = !0) {
    Cn(), Cg(this, e);
    const r = this.getWritable(),
      i = e.getWritable(),
      o = i.__key;
    vs(i);
    const s = this.getPreviousSibling(),
      l = this.getParentOrThrow().getWritable(),
      a = r.__prev,
      c = this.getIndexWithinParent();
    s === null ? (l.__first = o) : (s.getWritable().__next = o),
      l.__size++,
      (r.__prev = o),
      (i.__prev = a),
      (i.__next = r.__key),
      (i.__parent = r.__parent);
    const u = ae();
    return n && ee(u) && Pf(u, this.getParentOrThrow(), c), e;
  }
  isParentRequired() {
    return !1;
  }
  createParentElementNode() {
    return tt();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(e, n) {
    Cn();
    const r = this.getPreviousSibling(),
      i = this.getParentOrThrow();
    if (r === null) return i.select(0, 0);
    if (X(r)) return r.select();
    if (!te(r)) {
      const o = r.getIndexWithinParent() + 1;
      return i.select(o, o);
    }
    return r.select(e, n);
  }
  selectNext(e, n) {
    Cn();
    const r = this.getNextSibling(),
      i = this.getParentOrThrow();
    if (r === null) return i.select();
    if (X(r)) return r.select(0, 0);
    if (!te(r)) {
      const o = r.getIndexWithinParent();
      return i.select(o, o);
    }
    return r.select(e, n);
  }
  markDirty() {
    this.getWritable();
  }
}
class Yu extends om {
  static getType() {
    return "linebreak";
  }
  static clone(e) {
    return new Yu(e.__key);
  }
  constructor(e) {
    super(e);
  }
  getTextContent() {
    return `
`;
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {
      br: (e) =>
        (function (n) {
          const r = n.parentElement;
          if (r !== null) {
            const i = r.firstChild;
            if (i === n || (i.nextSibling === n && MS(i))) {
              const o = r.lastChild;
              if (o === n || (o.previousSibling === n && MS(o))) return !0;
            }
          }
          return !1;
        })(e)
          ? null
          : { conversion: UL, priority: 0 },
    };
  }
  static importJSON(e) {
    return gi();
  }
  exportJSON() {
    return { type: "linebreak", version: 1 };
  }
}
function UL(t) {
  return { node: gi() };
}
function gi() {
  return Mn(new Yu());
}
function Ar(t) {
  return t instanceof Yu;
}
function MS(t) {
  return t.nodeType === Wo && /^( |\t|\r?\n)+$/.test(t.textContent || "");
}
function Ag(t, e) {
  return 16 & e ? "code" : e & pb ? "mark" : 32 & e ? "sub" : 64 & e ? "sup" : null;
}
function $g(t, e) {
  return 1 & e ? "strong" : 2 & e ? "em" : "span";
}
function zT(t, e, n, r, i) {
  const o = r.classList;
  let s = Ic(i, "base");
  s !== void 0 && o.add(...s), (s = Ic(i, "underlineStrikethrough"));
  let l = !1;
  const a = e & bf && e & vf;
  s !== void 0 && (n & bf && n & vf ? ((l = !0), a || o.add(...s)) : a && o.remove(...s));
  for (const c in Di) {
    const u = Di[c];
    if (((s = Ic(i, c)), s !== void 0))
      if (n & u) {
        if (l && (c === "underline" || c === "strikethrough")) {
          e & u && o.remove(...s);
          continue;
        }
        (e & u && (!a || c !== "underline") && c !== "strikethrough") || o.add(...s);
      } else e & u && o.remove(...s);
  }
}
function WT(t, e, n) {
  const r = e.firstChild,
    i = n.isComposing(),
    o = t + (i ? Kp : "");
  if (r == null) e.textContent = o;
  else {
    const s = r.nodeValue;
    if (s !== o)
      if (i || _o) {
        const [l, a, c] = (function (u, h) {
          const d = u.length,
            f = h.length;
          let p = 0,
            m = 0;
          for (; p < d && p < f && u[p] === h[p]; ) p++;
          for (; m + p < d && m + p < f && u[d - m - 1] === h[f - m - 1]; ) m++;
          return [p, d - p - m, h.slice(p, f - m)];
        })(s, o);
        a !== 0 && r.deleteData(l, a), r.insertData(l, c);
      } else r.nodeValue = o;
  }
}
function LS(t, e, n, r, i, o) {
  WT(i, t, e);
  const s = o.theme.text;
  s !== void 0 && zT(0, 0, r, t, s);
}
function Zh(t, e) {
  const n = document.createElement(e);
  return n.appendChild(t), n;
}
class Ki extends om {
  static getType() {
    return "text";
  }
  static clone(e) {
    return new Ki(e.__text, e.__key);
  }
  constructor(e, n) {
    super(n), (this.__text = e), (this.__format = 0), (this.__style = ""), (this.__mode = 0), (this.__detail = 0);
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const e = this.getLatest();
    return kL[e.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return this.getLatest().__mode === 1;
  }
  isComposing() {
    return this.__key === vo();
  }
  isSegmented() {
    return this.getLatest().__mode === 2;
  }
  isDirectionless() {
    return !!(1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return !!(2 & this.getLatest().__detail);
  }
  hasFormat(e) {
    const n = Di[e];
    return !!(this.getFormat() & n);
  }
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(e, n) {
    return x0(this.getLatest().__format, e, n);
  }
  canHaveFormat() {
    return !0;
  }
  createDOM(e, n) {
    const r = this.__format,
      i = Ag(0, r),
      o = $g(0, r),
      s = i === null ? o : i,
      l = document.createElement(s);
    let a = l;
    this.hasFormat("code") && l.setAttribute("spellcheck", "false"),
      i !== null && ((a = document.createElement(o)), l.appendChild(a)),
      LS(a, this, 0, r, this.__text, e);
    const c = this.__style;
    return c !== "" && (l.style.cssText = c), l;
  }
  updateDOM(e, n, r) {
    const i = this.__text,
      o = e.__format,
      s = this.__format,
      l = Ag(0, o),
      a = Ag(0, s),
      c = $g(0, o),
      u = $g(0, s);
    if ((l === null ? c : l) !== (a === null ? u : a)) return !0;
    if (l === a && c !== u) {
      const m = n.firstChild;
      m == null && ge(48);
      const O = document.createElement(u);
      return LS(O, this, 0, s, i, r), n.replaceChild(O, m), !1;
    }
    let h = n;
    a !== null && l !== null && ((h = n.firstChild), h == null && ge(49)), WT(i, h, this);
    const d = r.theme.text;
    d !== void 0 && o !== s && zT(0, o, s, h, d);
    const f = e.__style,
      p = this.__style;
    return f !== p && (n.style.cssText = p), !1;
  }
  static importDOM() {
    return {
      "#text": () => ({ conversion: GL, priority: 0 }),
      b: () => ({ conversion: qL, priority: 0 }),
      code: () => ({ conversion: no, priority: 0 }),
      em: () => ({ conversion: no, priority: 0 }),
      i: () => ({ conversion: no, priority: 0 }),
      s: () => ({ conversion: no, priority: 0 }),
      span: () => ({ conversion: HL, priority: 0 }),
      strong: () => ({ conversion: no, priority: 0 }),
      sub: () => ({ conversion: no, priority: 0 }),
      sup: () => ({ conversion: no, priority: 0 }),
      u: () => ({ conversion: no, priority: 0 }),
    };
  }
  static importJSON(e) {
    const n = yt(e.text);
    return n.setFormat(e.format), n.setDetail(e.detail), n.setMode(e.mode), n.setStyle(e.style), n;
  }
  exportDOM(e) {
    let { element: n } = super.exportDOM(e);
    return (
      (n !== null && $r(n)) || ge(132),
      (n.style.whiteSpace = "pre-wrap"),
      this.hasFormat("bold") && (n = Zh(n, "b")),
      this.hasFormat("italic") && (n = Zh(n, "i")),
      this.hasFormat("strikethrough") && (n = Zh(n, "s")),
      this.hasFormat("underline") && (n = Zh(n, "u")),
      { element: n }
    );
  }
  exportJSON() {
    return {
      detail: this.getDetail(),
      format: this.getFormat(),
      mode: this.getMode(),
      style: this.getStyle(),
      text: this.getTextContent(),
      type: "text",
      version: 1,
    };
  }
  selectionTransform(e, n) {}
  setFormat(e) {
    const n = this.getWritable();
    return (n.__format = typeof e == "string" ? Di[e] : e), n;
  }
  setDetail(e) {
    const n = this.getWritable();
    return (n.__detail = typeof e == "string" ? yL[e] : e), n;
  }
  setStyle(e) {
    const n = this.getWritable();
    return (n.__style = e), n;
  }
  toggleFormat(e) {
    const n = x0(this.getFormat(), e, null);
    return this.setFormat(n);
  }
  toggleDirectionless() {
    const e = this.getWritable();
    return (e.__detail ^= 1), e;
  }
  toggleUnmergeable() {
    const e = this.getWritable();
    return (e.__detail ^= 2), e;
  }
  setMode(e) {
    const n = SL[e];
    if (this.__mode === n) return this;
    const r = this.getWritable();
    return (r.__mode = n), r;
  }
  setTextContent(e) {
    if (this.__text === e) return this;
    const n = this.getWritable();
    return (n.__text = e), n;
  }
  select(e, n) {
    Cn();
    let r = e,
      i = n;
    const o = ae(),
      s = this.getTextContent(),
      l = this.__key;
    if (typeof s == "string") {
      const a = s.length;
      r === void 0 && (r = a), i === void 0 && (i = a);
    } else (r = 0), (i = 0);
    if (!ee(o)) return HT(l, r, l, i, "text", "text");
    {
      const a = vo();
      (a !== o.anchor.key && a !== o.focus.key) || ln(l), o.setTextNodeRange(this, r, this, i);
    }
    return o;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const e = this.getTextContentSize();
    return this.select(e, e);
  }
  spliceText(e, n, r, i) {
    const o = this.getWritable(),
      s = o.__text,
      l = r.length;
    let a = e;
    a < 0 && ((a = l + a), a < 0 && (a = 0));
    const c = ae();
    if (i && ee(c)) {
      const h = e + l;
      c.setTextNodeRange(o, h, o, h);
    }
    const u = s.slice(0, a) + r + s.slice(a + n);
    return (o.__text = u), o;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  splitText(...e) {
    Cn();
    const n = this.getLatest(),
      r = n.getTextContent(),
      i = n.__key,
      o = vo(),
      s = new Set(e),
      l = [],
      a = r.length;
    let c = "";
    for (let y = 0; y < a; y++) c !== "" && s.has(y) && (l.push(c), (c = "")), (c += r[y]);
    c !== "" && l.push(c);
    const u = l.length;
    if (u === 0) return [];
    if (l[0] === r) return [n];
    const h = l[0],
      d = n.getParentOrThrow();
    let f;
    const p = n.getFormat(),
      m = n.getStyle(),
      O = n.__detail;
    let v = !1;
    n.isSegmented()
      ? ((f = yt(h)), (f.__format = p), (f.__style = m), (f.__detail = O), (v = !0))
      : ((f = n.getWritable()), (f.__text = h));
    const g = ae(),
      b = [f];
    let x = h.length;
    for (let y = 1; y < u; y++) {
      const C = l[y],
        P = C.length,
        E = yt(C).getWritable();
      (E.__format = p), (E.__style = m), (E.__detail = O);
      const N = E.__key,
        L = x + P;
      if (ee(g)) {
        const D = g.anchor,
          Q = g.focus;
        D.key === i && D.type === "text" && D.offset > x && D.offset <= L && ((D.key = N), (D.offset -= x), (g.dirty = !0)),
          Q.key === i && Q.type === "text" && Q.offset > x && Q.offset <= L && ((Q.key = N), (Q.offset -= x), (g.dirty = !0));
      }
      o === i && ln(N), (x = L), b.push(E);
    }
    (function (y) {
      const C = y.getPreviousSibling(),
        P = y.getNextSibling();
      C !== null && wf(C), P !== null && wf(P);
    })(this);
    const k = d.getWritable(),
      w = this.getIndexWithinParent();
    return v ? (k.splice(w, 0, b), this.remove()) : k.splice(w, 1, b), ee(g) && Pf(g, d, w, u - 1), b;
  }
  mergeWithSibling(e) {
    const n = e === this.getPreviousSibling();
    n || e === this.getNextSibling() || ge(50);
    const r = this.__key,
      i = e.__key,
      o = this.__text,
      s = o.length;
    vo() === i && ln(r);
    const l = ae();
    if (ee(l)) {
      const h = l.anchor,
        d = l.focus;
      h !== null && h.key === i && (zS(h, n, r, e, s), (l.dirty = !0)), d !== null && d.key === i && (zS(d, n, r, e, s), (l.dirty = !0));
    }
    const a = e.__text,
      c = n ? a + o : o + a;
    this.setTextContent(c);
    const u = this.getWritable();
    return e.remove(), u;
  }
  isTextEntity() {
    return !1;
  }
}
function HL(t) {
  return { forChild: Pb(t.style), node: null };
}
function qL(t) {
  const e = t,
    n = e.style.fontWeight === "normal";
  return { forChild: Pb(e.style, n ? void 0 : "bold"), node: null };
}
const NS = new WeakMap();
function YL(t) {
  return (
    t.nodeName === "PRE" ||
    (t.nodeType === Hu && t.style !== void 0 && t.style.whiteSpace !== void 0 && t.style.whiteSpace.startsWith("pre"))
  );
}
function GL(t) {
  const e = t;
  t.parentElement === null && ge(129);
  let n = e.textContent || "";
  if (
    (function (r) {
      let i,
        o = r.parentNode;
      const s = [r];
      for (; o !== null && (i = NS.get(o)) === void 0 && !YL(o); ) s.push(o), (o = o.parentNode);
      const l = i === void 0 ? o : i;
      for (let a = 0; a < s.length; a++) NS.set(s[a], l);
      return l;
    })(e) !== null
  ) {
    const r = n.split(/(\r?\n|\t)/),
      i = [],
      o = r.length;
    for (let s = 0; s < o; s++) {
      const l = r[s];
      l ===
        `
` ||
      l ===
        `\r
`
        ? i.push(gi())
        : l === "	"
        ? i.push(xa())
        : l !== "" && i.push(yt(l));
    }
    return { node: i };
  }
  if (((n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " ")), n === "")) return { node: null };
  if (n[0] === " ") {
    let r = e,
      i = !0;
    for (; r !== null && (r = QS(r, !1)) !== null; ) {
      const o = r.textContent || "";
      if (o.length > 0) {
        /[ \t\n]$/.test(o) && (n = n.slice(1)), (i = !1);
        break;
      }
    }
    i && (n = n.slice(1));
  }
  if (n[n.length - 1] === " ") {
    let r = e,
      i = !0;
    for (; r !== null && (r = QS(r, !0)) !== null; )
      if ((r.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        i = !1;
        break;
      }
    i && (n = n.slice(0, n.length - 1));
  }
  return n === "" ? { node: null } : { node: yt(n) };
}
function QS(t, e) {
  let n = t;
  for (;;) {
    let r;
    for (; (r = e ? n.nextSibling : n.previousSibling) === null; ) {
      const o = n.parentElement;
      if (o === null) return null;
      n = o;
    }
    if (((n = r), n.nodeType === Hu)) {
      const o = n.style.display;
      if ((o === "" && !VL(n)) || (o !== "" && !o.startsWith("inline"))) return null;
    }
    let i = n;
    for (; (i = e ? n.firstChild : n.lastChild) !== null; ) n = i;
    if (n.nodeType === Wo) return n;
    if (n.nodeName === "BR") return null;
  }
}
const JL = {
  code: "code",
  em: "italic",
  i: "italic",
  s: "strikethrough",
  strong: "bold",
  sub: "subscript",
  sup: "superscript",
  u: "underline",
};
function no(t) {
  const e = JL[t.nodeName.toLowerCase()];
  return e === void 0 ? { node: null } : { forChild: Pb(t.style, e), node: null };
}
function yt(t = "") {
  return Mn(new Ki(t));
}
function te(t) {
  return t instanceof Ki;
}
function Pb(t, e) {
  const n = t.fontWeight,
    r = t.textDecoration.split(" "),
    i = n === "700" || n === "bold",
    o = r.includes("line-through"),
    s = t.fontStyle === "italic",
    l = r.includes("underline"),
    a = t.verticalAlign;
  return (c) => (
    te(c) &&
      (i && !c.hasFormat("bold") && c.toggleFormat("bold"),
      o && !c.hasFormat("strikethrough") && c.toggleFormat("strikethrough"),
      s && !c.hasFormat("italic") && c.toggleFormat("italic"),
      l && !c.hasFormat("underline") && c.toggleFormat("underline"),
      a !== "sub" || c.hasFormat("subscript") || c.toggleFormat("subscript"),
      a !== "super" || c.hasFormat("superscript") || c.toggleFormat("superscript"),
      e && !c.hasFormat(e) && c.toggleFormat(e)),
    c
  );
}
class Gu extends Ki {
  static getType() {
    return "tab";
  }
  static clone(e) {
    const n = new Gu(e.__key);
    return (n.__text = e.__text), (n.__format = e.__format), (n.__style = e.__style), n;
  }
  constructor(e) {
    super("	", e), (this.__detail = 2);
  }
  static importDOM() {
    return null;
  }
  static importJSON(e) {
    const n = xa();
    return n.setFormat(e.format), n.setStyle(e.style), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "tab", version: 1 };
  }
  setTextContent(e) {
    ge(126);
  }
  setDetail(e) {
    ge(127);
  }
  setMode(e) {
    ge(128);
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
}
function xa() {
  return Mn(new Gu());
}
function Ab(t) {
  return t instanceof Gu;
}
class KL {
  constructor(e, n, r) {
    (this._selection = null), (this.key = e), (this.offset = n), (this.type = r);
  }
  is(e) {
    return this.key === e.key && this.offset === e.offset && this.type === e.type;
  }
  isBefore(e) {
    let n = this.getNode(),
      r = e.getNode();
    const i = this.offset,
      o = e.offset;
    if (X(n)) {
      const s = n.getDescendantByIndex(i);
      n = s ?? n;
    }
    if (X(r)) {
      const s = r.getDescendantByIndex(o);
      r = s ?? r;
    }
    return n === r ? i < o : n.isBefore(r);
  }
  getNode() {
    const e = dt(this.key);
    return e === null && ge(20), e;
  }
  set(e, n, r) {
    const i = this._selection,
      o = this.key;
    (this.key = e),
      (this.offset = n),
      (this.type = r),
      Ju() || (vo() === o && ln(e), i !== null && (i.setCachedNodes(null), (i.dirty = !0)));
  }
}
function Oi(t, e, n) {
  return new KL(t, e, n);
}
function Rg(t, e) {
  let n = e.__key,
    r = t.offset,
    i = "element";
  if (te(e)) {
    i = "text";
    const o = e.getTextContentSize();
    r > o && (r = o);
  } else if (!X(e)) {
    const o = e.getNextSibling();
    if (te(o)) (n = o.__key), (r = 0), (i = "text");
    else {
      const s = e.getParent();
      s && ((n = s.__key), (r = e.getIndexWithinParent() + 1));
    }
  }
  t.set(n, r, i);
}
function DS(t, e) {
  if (X(e)) {
    const n = e.getLastDescendant();
    X(n) || te(n) ? Rg(t, n) : Rg(t, e);
  } else Rg(t, e);
}
function uo(t, e, n, r) {
  (t.key = e), (t.offset = n), (t.type = r);
}
class sm {
  constructor(e) {
    (this._cachedNodes = null), (this._nodes = e), (this.dirty = !1);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    if (!Vt(e)) return !1;
    const n = this._nodes,
      r = e._nodes;
    return n.size === r.size && Array.from(n).every((i) => r.has(i));
  }
  isCollapsed() {
    return !1;
  }
  isBackward() {
    return !1;
  }
  getStartEndPoints() {
    return null;
  }
  add(e) {
    (this.dirty = !0), this._nodes.add(e), (this._cachedNodes = null);
  }
  delete(e) {
    (this.dirty = !0), this._nodes.delete(e), (this._cachedNodes = null);
  }
  clear() {
    (this.dirty = !0), this._nodes.clear(), (this._cachedNodes = null);
  }
  has(e) {
    return this._nodes.has(e);
  }
  clone() {
    return new sm(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(e) {}
  insertText() {}
  insertNodes(e) {
    const n = this.getNodes(),
      r = n.length,
      i = n[r - 1];
    let o;
    if (te(i)) o = i.select();
    else {
      const s = i.getIndexWithinParent() + 1;
      o = i.getParentOrThrow().select(s, s);
    }
    o.insertNodes(e);
    for (let s = 0; s < r; s++) n[s].remove();
  }
  getNodes() {
    const e = this._cachedNodes;
    if (e !== null) return e;
    const n = this._nodes,
      r = [];
    for (const i of n) {
      const o = dt(i);
      o !== null && r.push(o);
    }
    return Ju() || (this._cachedNodes = r), r;
  }
  getTextContent() {
    const e = this.getNodes();
    let n = "";
    for (let r = 0; r < e.length; r++) n += e[r].getTextContent();
    return n;
  }
}
function ee(t) {
  return t instanceof Xo;
}
class Xo {
  constructor(e, n, r, i) {
    (this.anchor = e),
      (this.focus = n),
      (e._selection = this),
      (n._selection = this),
      (this._cachedNodes = null),
      (this.format = r),
      (this.style = i),
      (this.dirty = !1);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    return !!ee(e) && this.anchor.is(e.anchor) && this.focus.is(e.focus) && this.format === e.format && this.style === e.style;
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const e = this._cachedNodes;
    if (e !== null) return e;
    const n = this.anchor,
      r = this.focus,
      i = n.isBefore(r),
      o = i ? n : r,
      s = i ? r : n;
    let l = o.getNode(),
      a = s.getNode();
    const c = o.offset,
      u = s.offset;
    if (X(l)) {
      const d = l.getDescendantByIndex(c);
      l = d ?? l;
    }
    if (X(a)) {
      let d = a.getDescendantByIndex(u);
      d !== null && d !== l && a.getChildAtIndex(u) === d && (d = d.getPreviousSibling()), (a = d ?? a);
    }
    let h;
    return (h = l.is(a) ? (X(l) && l.getChildrenSize() > 0 ? [] : [l]) : l.getNodesBetween(a)), Ju() || (this._cachedNodes = h), h;
  }
  setTextNodeRange(e, n, r, i) {
    uo(this.anchor, e.__key, n, "text"), uo(this.focus, r.__key, i, "text"), (this._cachedNodes = null), (this.dirty = !0);
  }
  getTextContent() {
    const e = this.getNodes();
    if (e.length === 0) return "";
    const n = e[0],
      r = e[e.length - 1],
      i = this.anchor,
      o = this.focus,
      s = i.isBefore(o),
      [l, a] = I0(this);
    let c = "",
      u = !0;
    for (let h = 0; h < e.length; h++) {
      const d = e[h];
      if (X(d) && !d.isInline())
        u ||
          (c += `
`),
          (u = !d.isEmpty());
      else if (((u = !1), te(d))) {
        let f = d.getTextContent();
        d === n
          ? d === r
            ? (i.type === "element" && o.type === "element" && o.offset !== i.offset) || (f = l < a ? f.slice(l, a) : f.slice(a, l))
            : (f = s ? f.slice(l) : f.slice(a))
          : d === r && (f = s ? f.slice(0, a) : f.slice(0, l)),
          (c += f);
      } else (!ot(d) && !Ar(d)) || (d === r && this.isCollapsed()) || (c += d.getTextContent());
    }
    return c;
  }
  applyDOMRange(e) {
    const n = It(),
      r = n.getEditorState()._selection,
      i = UT(e.startContainer, e.startOffset, e.endContainer, e.endOffset, n, r);
    if (i === null) return;
    const [o, s] = i;
    uo(this.anchor, o.key, o.offset, o.type), uo(this.focus, s.key, s.offset, s.type), (this._cachedNodes = null);
  }
  clone() {
    const e = this.anchor,
      n = this.focus;
    return new Xo(Oi(e.key, e.offset, e.type), Oi(n.key, n.offset, n.type), this.format, this.style);
  }
  toggleFormat(e) {
    (this.format = x0(this.format, e, null)), (this.dirty = !0);
  }
  setStyle(e) {
    (this.style = e), (this.dirty = !0);
  }
  hasFormat(e) {
    const n = Di[e];
    return !!(this.format & n);
  }
  insertRawText(e) {
    const n = e.split(/(\r?\n|\t)/),
      r = [],
      i = n.length;
    for (let o = 0; o < i; o++) {
      const s = n[o];
      s ===
        `
` ||
      s ===
        `\r
`
        ? r.push(gi())
        : s === "	"
        ? r.push(xa())
        : r.push(yt(s));
    }
    this.insertNodes(r);
  }
  insertText(e) {
    const n = this.anchor,
      r = this.focus,
      i = this.format,
      o = this.style;
    let s = n,
      l = r;
    !this.isCollapsed() && r.isBefore(n) && ((s = r), (l = n)),
      s.type === "element" &&
        (function (O, v, g, b) {
          const x = O.getNode(),
            k = x.getChildAtIndex(O.offset),
            w = yt(),
            y = tn(x) ? tt().append(w) : w;
          w.setFormat(g),
            w.setStyle(b),
            k === null ? x.append(y) : k.insertBefore(y),
            O.is(v) && v.set(w.__key, 0, "text"),
            O.set(w.__key, 0, "text");
        })(s, l, i, o);
    const a = s.offset;
    let c = l.offset;
    const u = this.getNodes(),
      h = u.length;
    let d = u[0];
    te(d) || ge(26);
    const f = d.getTextContent().length,
      p = d.getParentOrThrow();
    let m = u[h - 1];
    if (
      (h === 1 && l.type === "element" && ((c = f), l.set(s.key, c, "text")),
      this.isCollapsed() &&
        a === f &&
        (d.isSegmented() || d.isToken() || !d.canInsertTextAfter() || (!p.canInsertTextAfter() && d.getNextSibling() === null)))
    ) {
      let O = d.getNextSibling();
      if (
        ((te(O) && O.canInsertTextBefore() && !sl(O)) ||
          ((O = yt()), O.setFormat(i), O.setStyle(o), p.canInsertTextAfter() ? d.insertAfter(O) : p.insertAfter(O)),
        O.select(0, 0),
        (d = O),
        e !== "")
      )
        return void this.insertText(e);
    } else if (
      this.isCollapsed() &&
      a === 0 &&
      (d.isSegmented() || d.isToken() || !d.canInsertTextBefore() || (!p.canInsertTextBefore() && d.getPreviousSibling() === null))
    ) {
      let O = d.getPreviousSibling();
      if (
        ((te(O) && !sl(O)) || ((O = yt()), O.setFormat(i), p.canInsertTextBefore() ? d.insertBefore(O) : p.insertBefore(O)),
        O.select(),
        (d = O),
        e !== "")
      )
        return void this.insertText(e);
    } else if (d.isSegmented() && a !== f) {
      const O = yt(d.getTextContent());
      O.setFormat(i), d.replace(O), (d = O);
    } else if (!this.isCollapsed() && e !== "") {
      const O = m.getParent();
      if (!p.canInsertTextBefore() || !p.canInsertTextAfter() || (X(O) && (!O.canInsertTextBefore() || !O.canInsertTextAfter())))
        return this.insertText(""), XT(this.anchor, this.focus, null), void this.insertText(e);
    }
    if (h === 1) {
      if (d.isToken()) {
        const b = yt(e);
        return b.select(), void d.replace(b);
      }
      const O = d.getFormat(),
        v = d.getStyle();
      if (a !== c || (O === i && v === o)) {
        if (Ab(d)) {
          const b = yt(e);
          return b.setFormat(i), b.setStyle(o), b.select(), void d.replace(b);
        }
      } else {
        if (d.getTextContent() !== "") {
          const b = yt(e);
          if ((b.setFormat(i), b.setStyle(o), b.select(), a === 0)) d.insertBefore(b, !1);
          else {
            const [x] = d.splitText(a);
            x.insertAfter(b, !1);
          }
          return void (b.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length));
        }
        d.setFormat(i), d.setStyle(o);
      }
      const g = c - a;
      (d = d.spliceText(a, g, e, !0)),
        d.getTextContent() === ""
          ? d.remove()
          : this.anchor.type === "text" && (d.isComposing() ? (this.anchor.offset -= e.length) : ((this.format = O), (this.style = v)));
    } else {
      const O = new Set([...d.getParentKeys(), ...m.getParentKeys()]),
        v = X(d) ? d : d.getParentOrThrow();
      let g = X(m) ? m : m.getParentOrThrow(),
        b = m;
      if (!v.is(g) && g.isInline())
        do (b = g), (g = g.getParentOrThrow());
        while (g.isInline());
      if ((l.type === "text" && (c !== 0 || m.getTextContent() === "")) || (l.type === "element" && m.getIndexWithinParent() < c))
        if (te(m) && !m.isToken() && c !== m.getTextContentSize()) {
          if (m.isSegmented()) {
            const C = yt(m.getTextContent());
            m.replace(C), (m = C);
          }
          tn(l.getNode()) || l.type !== "text" || (m = m.spliceText(0, c, "")), O.add(m.__key);
        } else {
          const C = m.getParentOrThrow();
          C.canBeEmpty() || C.getChildrenSize() !== 1 ? m.remove() : C.remove();
        }
      else O.add(m.__key);
      const x = g.getChildren(),
        k = new Set(u),
        w = v.is(g),
        y = v.isInline() && d.getNextSibling() === null ? v : d;
      for (let C = x.length - 1; C >= 0; C--) {
        const P = x[C];
        if (P.is(d) || (X(P) && P.isParentOf(d))) break;
        P.isAttached() && (!k.has(P) || P.is(b) ? w || y.insertAfter(P, !1) : P.remove());
      }
      if (!w) {
        let C = g,
          P = null;
        for (; C !== null; ) {
          const E = C.getChildren(),
            N = E.length;
          (N === 0 || E[N - 1].is(P)) && (O.delete(C.__key), (P = C)), (C = C.getParent());
        }
      }
      if (d.isToken())
        if (a === f) d.select();
        else {
          const C = yt(e);
          C.select(), d.replace(C);
        }
      else
        (d = d.spliceText(a, f - a, e, !0)),
          d.getTextContent() === "" ? d.remove() : d.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length);
      for (let C = 1; C < h; C++) {
        const P = u[C],
          E = P.__key;
        O.has(E) || P.remove();
      }
    }
  }
  removeText() {
    this.insertText("");
  }
  formatText(e) {
    if (this.isCollapsed()) return this.toggleFormat(e), void ln(null);
    const n = this.getNodes(),
      r = [];
    for (const g of n) te(g) && r.push(g);
    const i = r.length;
    if (i === 0) return this.toggleFormat(e), void ln(null);
    const o = this.anchor,
      s = this.focus,
      l = this.isBackward(),
      a = l ? s : o,
      c = l ? o : s;
    let u = 0,
      h = r[0],
      d = a.type === "element" ? 0 : a.offset;
    if ((a.type === "text" && d === h.getTextContentSize() && ((u = 1), (h = r[1]), (d = 0)), h == null)) return;
    const f = h.getFormatFlags(e, null),
      p = i - 1;
    let m = r[p];
    const O = c.type === "text" ? c.offset : m.getTextContentSize();
    if (h.is(m)) {
      if (d === O) return;
      if (sl(h) || (d === 0 && O === h.getTextContentSize())) h.setFormat(f);
      else {
        const g = h.splitText(d, O),
          b = d === 0 ? g[0] : g[1];
        b.setFormat(f), a.type === "text" && a.set(b.__key, 0, "text"), c.type === "text" && c.set(b.__key, O - d, "text");
      }
      return void (this.format = f);
    }
    d === 0 || sl(h) || (([, h] = h.splitText(d)), (d = 0)), h.setFormat(f);
    const v = m.getFormatFlags(e, f);
    O > 0 && (O === m.getTextContentSize() || sl(m) || ([m] = m.splitText(O)), m.setFormat(v));
    for (let g = u + 1; g < p; g++) {
      const b = r[g],
        x = b.getFormatFlags(e, v);
      b.setFormat(x);
    }
    a.type === "text" && a.set(h.__key, d, "text"), c.type === "text" && c.set(m.__key, O, "text"), (this.format = f | v);
  }
  insertNodes(e) {
    if (e.length === 0) return;
    if (this.anchor.key === "root") {
      this.insertParagraph();
      const p = ae();
      return ee(p) || ge(134), p.insertNodes(e);
    }
    const n = Eg((this.isBackward() ? this.focus : this.anchor).getNode(), ll),
      r = e[e.length - 1];
    if ("__language" in n && X(n)) {
      if ("__language" in e[0]) this.insertText(e[0].getTextContent());
      else {
        const p = Ig(this);
        n.splice(p, 0, e), r.selectEnd();
      }
      return;
    }
    if (!e.some((p) => (X(p) || ot(p)) && !p.isInline())) {
      X(n) || ge(135);
      const p = Ig(this);
      return n.splice(p, 0, e), void r.selectEnd();
    }
    const i = (function (p) {
        const m = tt();
        let O = null;
        for (let v = 0; v < p.length; v++) {
          const g = p[v],
            b = Ar(g);
          if (b || (ot(g) && g.isInline()) || (X(g) && g.isInline()) || te(g) || g.isParentRequired()) {
            if (O === null && ((O = g.createParentElementNode()), m.append(O), b)) continue;
            O !== null && O.append(g);
          } else m.append(g), (O = null);
        }
        return m;
      })(e),
      o = i.getLastDescendant(),
      s = i.getChildren(),
      l = (p) => "__value" in p && "__checked" in p,
      a = !X(n) || !n.isEmpty() ? this.insertParagraph() : null,
      c = s[s.length - 1];
    let u = s[0];
    var h;
    X((h = u)) && ll(h) && !h.isEmpty() && X(n) && (!n.isEmpty() || l(n)) && (X(n) || ge(135), n.append(...u.getChildren()), (u = s[1])),
      u &&
        (function (p, m, O) {
          const v = m.getParentOrThrow().getLastChild();
          let g = m;
          const b = [m];
          for (; g !== v; ) g.getNextSibling() || ge(140), (g = g.getNextSibling()), b.push(g);
          let x = p;
          for (const k of b) x = x.insertAfter(k);
        })(n, u);
    const d = Eg(o, ll);
    a && X(d) && (l(a) || ll(c)) && (d.append(...a.getChildren()), a.remove()), X(n) && n.isEmpty() && n.remove(), o.selectEnd();
    const f = X(n) ? n.getLastChild() : null;
    Ar(f) && d !== n && f.remove();
  }
  insertParagraph() {
    if (this.anchor.key === "root") {
      const s = tt();
      return Qe().splice(this.anchor.offset, 0, [s]), s.select(), s;
    }
    const e = Ig(this),
      n = Eg(this.anchor.getNode(), ll);
    X(n) || ge(136);
    const r = n.getChildAtIndex(e),
      i = r ? [r, ...r.getNextSiblings()] : [],
      o = n.insertNewAfter(this, !1);
    return o ? (o.append(...i), o.selectStart(), o) : null;
  }
  insertLineBreak(e) {
    const n = gi();
    if ((this.insertNodes([n]), e)) {
      const r = n.getParentOrThrow(),
        i = n.getIndexWithinParent();
      r.select(i, i);
    }
  }
  extract() {
    const e = this.getNodes(),
      n = e.length,
      r = n - 1,
      i = this.anchor,
      o = this.focus;
    let s = e[0],
      l = e[r];
    const [a, c] = I0(this);
    if (n === 0) return [];
    if (n === 1) {
      if (te(s) && !this.isCollapsed()) {
        const h = a > c ? c : a,
          d = a > c ? a : c,
          f = s.splitText(h, d),
          p = h === 0 ? f[0] : f[1];
        return p != null ? [p] : [];
      }
      return [s];
    }
    const u = i.isBefore(o);
    if (te(s)) {
      const h = u ? a : c;
      h === s.getTextContentSize() ? e.shift() : h !== 0 && (([, s] = s.splitText(h)), (e[0] = s));
    }
    if (te(l)) {
      const h = l.getTextContent().length,
        d = u ? c : a;
      d === 0 ? e.pop() : d !== h && (([l] = l.splitText(d)), (e[r] = l));
    }
    return e;
  }
  modify(e, n, r) {
    const i = this.focus,
      o = this.anchor,
      s = e === "move",
      l = Kc(i, n);
    if (ot(l) && !l.isIsolated()) {
      if (s && l.isKeyboardSelectable()) {
        const f = M0();
        return f.add(l.__key), void pn(f);
      }
      const d = n ? l.getPreviousSibling() : l.getNextSibling();
      if (te(d)) {
        const f = d.__key,
          p = n ? d.getTextContent().length : 0;
        return i.set(f, p, "text"), void (s && o.set(f, p, "text"));
      }
      {
        const f = l.getParentOrThrow();
        let p, m;
        return (
          X(d) ? ((m = d.__key), (p = n ? d.getChildrenSize() : 0)) : ((p = l.getIndexWithinParent()), (m = f.__key), n || p++),
          i.set(m, p, "element"),
          void (s && o.set(m, p, "element"))
        );
      }
    }
    const a = It(),
      c = mi(a._window);
    if (!c) return;
    const u = a._blockCursorElement,
      h = a._rootElement;
    if (
      (h === null || u === null || !X(l) || l.isInline() || l.canBeEmpty() || Tb(u, a, h),
      (function (d, f, p, m) {
        d.modify(f, p, m);
      })(c, e, n ? "backward" : "forward", r),
      c.rangeCount > 0)
    ) {
      const d = c.getRangeAt(0),
        f = this.anchor.getNode(),
        p = tn(f) ? f : NL(f);
      if ((this.applyDOMRange(d), (this.dirty = !0), !s)) {
        const m = this.getNodes(),
          O = [];
        let v = !1;
        for (let g = 0; g < m.length; g++) {
          const b = m[g];
          y0(b, p) ? O.push(b) : (v = !0);
        }
        if (v && O.length > 0)
          if (n) {
            const g = O[0];
            X(g) ? g.selectStart() : g.getParentOrThrow().selectStart();
          } else {
            const g = O[O.length - 1];
            X(g) ? g.selectEnd() : g.getParentOrThrow().selectEnd();
          }
        (c.anchorNode === d.startContainer && c.anchorOffset === d.startOffset) ||
          (function (g) {
            const b = g.focus,
              x = g.anchor,
              k = x.key,
              w = x.offset,
              y = x.type;
            uo(x, b.key, b.offset, b.type), uo(b, k, w, y), (g._cachedNodes = null);
          })(this);
      }
    }
  }
  forwardDeletion(e, n, r) {
    if (
      !r &&
      ((e.type === "element" && X(n) && e.offset === n.getChildrenSize()) || (e.type === "text" && e.offset === n.getTextContentSize()))
    ) {
      const i = n.getParent(),
        o = n.getNextSibling() || (i === null ? null : i.getNextSibling());
      if (X(o) && o.isShadowRoot()) return !0;
    }
    return !1;
  }
  deleteCharacter(e) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const r = this.anchor;
      let i = r.getNode();
      if (this.forwardDeletion(r, i, e)) return;
      const o = this.focus,
        s = Kc(o, e);
      if (ot(s) && !s.isIsolated()) {
        if (s.isKeyboardSelectable() && X(i) && i.getChildrenSize() === 0) {
          i.remove();
          const l = M0();
          l.add(s.__key), pn(l);
        } else s.remove(), It().dispatchCommand(ba, void 0);
        return;
      }
      if (!e && X(s) && X(i) && i.isEmpty()) return i.remove(), void s.selectStart();
      if ((this.modify("extend", e, "character"), this.isCollapsed())) {
        if (e && r.offset === 0 && (r.type === "element" ? r.getNode() : r.getNode().getParentOrThrow()).collapseAtStart(this)) return;
      } else {
        const l = o.type === "text" ? o.getNode() : null;
        if (((i = r.type === "text" ? r.getNode() : null), l !== null && l.isSegmented())) {
          const a = o.offset,
            c = l.getTextContentSize();
          if (l.is(i) || (e && a !== c) || (!e && a !== 0)) return void BS(l, e, a);
        } else if (i !== null && i.isSegmented()) {
          const a = r.offset,
            c = i.getTextContentSize();
          if (i.is(l) || (e && a !== 0) || (!e && a !== c)) return void BS(i, e, a);
        }
        (function (a, c) {
          const u = a.anchor,
            h = a.focus,
            d = u.getNode(),
            f = h.getNode();
          if (d === f && u.type === "text" && h.type === "text") {
            const p = u.offset,
              m = h.offset,
              O = p < m,
              v = O ? p : m,
              g = O ? m : p,
              b = g - 1;
            v !== b && (_T(d.getTextContent().slice(v, g)) || (c ? (h.offset = b) : (u.offset = b)));
          }
        })(this, e);
      }
    }
    if ((this.removeText(), e && !n && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0)) {
      const r = this.anchor.getNode();
      r.isEmpty() && tn(r.getParent()) && r.getIndexWithinParent() === 0 && r.collapseAtStart(this);
    }
  }
  deleteLine(e) {
    if (this.isCollapsed()) {
      const n = this.anchor.type === "element";
      if (
        (n && this.insertText(" "),
        this.modify("extend", e, "lineboundary"),
        (e ? this.focus : this.anchor).offset === 0 && this.modify("extend", e, "character"),
        n)
      ) {
        const r = e ? this.anchor : this.focus;
        r.set(r.key, r.offset + 1, r.type);
      }
    }
    this.removeText();
  }
  deleteWord(e) {
    if (this.isCollapsed()) {
      const n = this.anchor,
        r = n.getNode();
      if (this.forwardDeletion(n, r, e)) return;
      this.modify("extend", e, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
}
function Vt(t) {
  return t instanceof sm;
}
function FS(t) {
  const e = t.offset;
  if (t.type === "text") return e;
  const n = t.getNode();
  return e === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function I0(t) {
  const e = t.getStartEndPoints();
  if (e === null) return [0, 0];
  const [n, r] = e;
  return n.type === "element" && r.type === "element" && n.key === r.key && n.offset === r.offset ? [0, 0] : [FS(n), FS(r)];
}
function BS(t, e, n) {
  const r = t,
    i = r.getTextContent().split(/(?=\s)/g),
    o = i.length;
  let s = 0,
    l = 0;
  for (let c = 0; c < o; c++) {
    const u = c === o - 1;
    if (((l = s), (s += i[c].length), (e && s === n) || s > n || u)) {
      i.splice(c, 1), u && (l = void 0);
      break;
    }
  }
  const a = i.join("").trim();
  a === "" ? r.remove() : (r.setTextContent(a), r.select(l, l));
}
function VS(t, e, n, r) {
  let i,
    o = e;
  if (t.nodeType === Hu) {
    let s = !1;
    const l = t.childNodes,
      a = l.length,
      c = r._blockCursorElement;
    o === a && ((s = !0), (o = a - 1));
    let u = l[o],
      h = !1;
    if (u === c) (u = l[o + 1]), (h = !0);
    else if (c !== null) {
      const d = c.parentNode;
      t === d && e > Array.prototype.indexOf.call(d.children, c) && o--;
    }
    if (((i = ml(u)), te(i))) o = SS(i, s);
    else {
      let d = ml(t);
      if (d === null) return null;
      if (X(d)) {
        o = Math.min(d.getChildrenSize(), o);
        let f = d.getChildAtIndex(o);
        if (
          X(f) &&
          (function (p, m, O) {
            const v = p.getParent();
            return O === null || v === null || !v.canBeEmpty() || v !== O.getNode();
          })(f, 0, n)
        ) {
          const p = s ? f.getLastDescendant() : f.getFirstDescendant();
          p === null ? (d = f) : ((f = p), (d = X(f) ? f : f.getParentOrThrow())), (o = 0);
        }
        te(f) ? ((i = f), (d = null), (o = SS(f, s))) : f !== d && s && !h && o++;
      } else {
        const f = d.getIndexWithinParent();
        (o = e === 0 && ot(d) && ml(t) === d ? f : f + 1), (d = d.getParentOrThrow());
      }
      if (X(d)) return Oi(d.__key, o, "element");
    }
  } else i = ml(t);
  return te(i) ? Oi(i.__key, o, "text") : null;
}
function jS(t, e, n) {
  const r = t.offset,
    i = t.getNode();
  if (r === 0) {
    const o = i.getPreviousSibling(),
      s = i.getParent();
    if (e) {
      if ((n || !e) && o === null && X(s) && s.isInline()) {
        const l = s.getPreviousSibling();
        te(l) && ((t.key = l.__key), (t.offset = l.getTextContent().length));
      }
    } else
      X(o) && !n && o.isInline()
        ? ((t.key = o.__key), (t.offset = o.getChildrenSize()), (t.type = "element"))
        : te(o) && ((t.key = o.__key), (t.offset = o.getTextContent().length));
  } else if (r === i.getTextContent().length) {
    const o = i.getNextSibling(),
      s = i.getParent();
    if (e && X(o) && o.isInline()) (t.key = o.__key), (t.offset = 0), (t.type = "element");
    else if ((n || e) && o === null && X(s) && s.isInline() && !s.canInsertTextAfter()) {
      const l = s.getNextSibling();
      te(l) && ((t.key = l.__key), (t.offset = 0));
    }
  }
}
function XT(t, e, n) {
  if (t.type === "text" && e.type === "text") {
    const r = t.isBefore(e),
      i = t.is(e);
    jS(t, r, i), jS(e, !r, i), i && ((e.key = t.key), (e.offset = t.offset), (e.type = t.type));
    const o = It();
    if (o.isComposing() && o._compositionKey !== t.key && ee(n)) {
      const s = n.anchor,
        l = n.focus;
      uo(t, s.key, s.offset, s.type), uo(e, l.key, l.offset, l.type);
    }
  }
}
function UT(t, e, n, r, i, o) {
  if (t === null || n === null || !qu(i, t, n)) return null;
  const s = VS(t, e, ee(o) ? o.anchor : null, i);
  if (s === null) return null;
  const l = VS(n, r, ee(o) ? o.focus : null, i);
  if (l === null) return null;
  if (s.type === "element" && l.type === "element") {
    const a = ml(t),
      c = ml(n);
    if (ot(a) && ot(c)) return null;
  }
  return XT(s, l, o), [s, l];
}
function Tf(t) {
  return X(t) && !t.isInline();
}
function HT(t, e, n, r, i, o) {
  const s = eo(),
    l = new Xo(Oi(t, e, i), Oi(n, r, o), 0, "");
  return (l.dirty = !0), (s._selection = l), l;
}
function lm() {
  const t = Oi("root", 0, "element"),
    e = Oi("root", 0, "element");
  return new Xo(t, e, 0, "");
}
function M0() {
  return new sm(new Set());
}
function $b(t, e, n, r) {
  const i = n._window;
  if (i === null) return null;
  const o = r || i.event,
    s = o ? o.type : void 0,
    l = s === "selectionchange",
    a =
      !b0 &&
      (l ||
        s === "beforeinput" ||
        s === "compositionstart" ||
        s === "compositionend" ||
        (s === "click" && o && o.detail === 3) ||
        s === "drop" ||
        s === void 0);
  let c, u, h, d;
  if (ee(t) && !a) return t.clone();
  if (e === null) return null;
  if (((c = e.anchorNode), (u = e.focusNode), (h = e.anchorOffset), (d = e.focusOffset), l && ee(t) && !qu(n, c, u))) return t.clone();
  const f = UT(c, h, u, d, n, t);
  if (f === null) return null;
  const [p, m] = f;
  return new Xo(p, m, ee(t) ? t.format : 0, ee(t) ? t.style : "");
}
function ae() {
  return eo()._selection;
}
function Ws() {
  return It()._editorState._selection;
}
function Pf(t, e, n, r = 1) {
  const i = t.anchor,
    o = t.focus,
    s = i.getNode(),
    l = o.getNode();
  if (!e.is(s) && !e.is(l)) return;
  const a = e.__key;
  if (t.isCollapsed()) {
    const c = i.offset;
    if ((n <= c && r > 0) || (n < c && r < 0)) {
      const u = Math.max(0, c + r);
      i.set(a, u, "element"), o.set(a, u, "element"), ZS(t);
    }
  } else {
    const c = t.isBackward(),
      u = c ? o : i,
      h = u.getNode(),
      d = c ? i : o,
      f = d.getNode();
    if (e.is(h)) {
      const p = u.offset;
      ((n <= p && r > 0) || (n < p && r < 0)) && u.set(a, Math.max(0, p + r), "element");
    }
    if (e.is(f)) {
      const p = d.offset;
      ((n <= p && r > 0) || (n < p && r < 0)) && d.set(a, Math.max(0, p + r), "element");
    }
  }
  ZS(t);
}
function ZS(t) {
  const e = t.anchor,
    n = e.offset,
    r = t.focus,
    i = r.offset,
    o = e.getNode(),
    s = r.getNode();
  if (t.isCollapsed()) {
    if (!X(o)) return;
    const l = o.getChildrenSize(),
      a = n >= l,
      c = a ? o.getChildAtIndex(l - 1) : o.getChildAtIndex(n);
    if (te(c)) {
      let u = 0;
      a && (u = c.getTextContentSize()), e.set(c.__key, u, "text"), r.set(c.__key, u, "text");
    }
  } else {
    if (X(o)) {
      const l = o.getChildrenSize(),
        a = n >= l,
        c = a ? o.getChildAtIndex(l - 1) : o.getChildAtIndex(n);
      if (te(c)) {
        let u = 0;
        a && (u = c.getTextContentSize()), e.set(c.__key, u, "text");
      }
    }
    if (X(s)) {
      const l = s.getChildrenSize(),
        a = i >= l,
        c = a ? s.getChildAtIndex(l - 1) : s.getChildAtIndex(i);
      if (te(c)) {
        let u = 0;
        a && (u = c.getTextContentSize()), r.set(c.__key, u, "text");
      }
    }
  }
}
function Af(t, e, n, r, i) {
  let o = null,
    s = 0,
    l = null;
  r !== null
    ? ((o = r.__key), te(r) ? ((s = r.getTextContentSize()), (l = "text")) : X(r) && ((s = r.getChildrenSize()), (l = "element")))
    : i !== null && ((o = i.__key), te(i) ? (l = "text") : X(i) && (l = "element")),
    o !== null && l !== null
      ? t.set(o, s, l)
      : ((s = e.getIndexWithinParent()), s === -1 && (s = n.getChildrenSize()), t.set(n.__key, s, "element"));
}
function zS(t, e, n, r, i) {
  t.type === "text" ? ((t.key = n), e || (t.offset += i)) : t.offset > r.getIndexWithinParent() && (t.offset -= 1);
}
function eN(t, e, n, r, i, o, s) {
  const l = r.anchorNode,
    a = r.focusNode,
    c = r.anchorOffset,
    u = r.focusOffset,
    h = document.activeElement;
  if ((i.has("collaboration") && h !== o) || (h !== null && Sb(h))) return;
  if (!ee(e)) return void (t !== null && qu(n, l, a) && r.removeAllRanges());
  const d = e.anchor,
    f = e.focus,
    p = d.key,
    m = f.key,
    O = Sf(n, p),
    v = Sf(n, m),
    g = d.offset,
    b = f.offset,
    x = e.format,
    k = e.style,
    w = e.isCollapsed();
  let y = O,
    C = v,
    P = !1;
  if (d.type === "text") {
    y = yf(O);
    const R = d.getNode();
    P = R.getFormat() !== x || R.getStyle() !== k;
  } else ee(t) && t.anchor.type === "text" && (P = !0);
  var E, N, L, D, Q;
  if (
    (f.type === "text" && (C = yf(v)),
    y !== null &&
      C !== null &&
      (w &&
        (t === null || P || (ee(t) && (t.format !== x || t.style !== k))) &&
        ((E = x), (N = k), (L = g), (D = p), (Q = performance.now()), (FT = [E, N, L, D, Q])),
      c !== g ||
        u !== b ||
        l !== y ||
        a !== C ||
        (r.type === "Range" && w) ||
        ((h !== null && o.contains(h)) || o.focus({ preventScroll: !0 }), d.type === "element")))
  ) {
    try {
      r.setBaseAndExtent(y, g, C, b);
    } catch {}
    if (!i.has("skip-scroll-into-view") && e.isCollapsed() && o !== null && o === document.activeElement) {
      const R = e instanceof Xo && e.anchor.type === "element" ? y.childNodes[g] || null : r.rangeCount > 0 ? r.getRangeAt(0) : null;
      if (R !== null) {
        let W;
        if (R instanceof Text) {
          const B = document.createRange();
          B.selectNode(R), (W = B.getBoundingClientRect());
        } else W = R.getBoundingClientRect();
        (function (B, K, ne) {
          const A = ne.ownerDocument,
            V = A.defaultView;
          if (V === null) return;
          let { top: ie, bottom: M } = K,
            fe = 0,
            Se = 0,
            pe = ne;
          for (; pe !== null; ) {
            const Y = pe === A.body;
            if (Y) (fe = 0), (Se = nm(B).innerHeight);
            else {
              const oe = pe.getBoundingClientRect();
              (fe = oe.top), (Se = oe.bottom);
            }
            let q = 0;
            if ((ie < fe ? (q = -(fe - ie)) : M > Se && (q = M - Se), q !== 0))
              if (Y) V.scrollBy(0, q);
              else {
                const oe = pe.scrollTop;
                pe.scrollTop += q;
                const ce = pe.scrollTop - oe;
                (ie -= ce), (M -= ce);
              }
            if (Y) break;
            pe = tm(pe);
          }
        })(n, W, o);
      }
    }
    A0 = !0;
  }
}
function ya(t) {
  let e = ae() || Ws();
  e === null && (e = Qe().selectEnd()), e.insertNodes(t);
}
function Ig(t) {
  let e = t;
  t.isCollapsed() || e.removeText();
  const n = ae();
  ee(n) && (e = n), ee(e) || ge(161);
  const r = e.anchor;
  let i = r.getNode(),
    o = r.offset;
  for (; !ll(i); ) [i, o] = tN(i, o);
  return o;
}
function tN(t, e) {
  const n = t.getParent();
  if (!n) {
    const i = tt();
    return Qe().append(i), i.select(), [Qe(), 0];
  }
  if (te(t)) {
    const i = t.splitText(e);
    if (i.length === 0) return [n, t.getIndexWithinParent()];
    const o = e === 0 ? 0 : 1;
    return [n, i[0].getIndexWithinParent() + o];
  }
  if (!X(t) || e === 0) return [n, t.getIndexWithinParent()];
  const r = t.getChildAtIndex(e);
  if (r) {
    const i = new Xo(Oi(t.__key, e, "element"), Oi(t.__key, e, "element"), 0, ""),
      o = t.insertNewAfter(i);
    o && o.append(r, ...r.getNextSiblings());
  }
  return [n, t.getIndexWithinParent() + 1];
}
let Kt = null,
  en = null,
  zn = !1,
  Mg = !1,
  Wd = 0;
const WS = { characterData: !0, childList: !0, subtree: !0 };
function Ju() {
  return zn || (Kt !== null && Kt._readOnly);
}
function Cn() {
  zn && ge(13);
}
function qT() {
  Wd > 99 && ge(14);
}
function eo() {
  return Kt === null && ge(15), Kt;
}
function It() {
  return en === null && ge(16), en;
}
function nN() {
  return en;
}
function XS(t, e, n) {
  const r = e.__type,
    i = (function (l, a) {
      const c = l._nodes.get(a);
      return c === void 0 && ge(30, a), c;
    })(t, r);
  let o = n.get(r);
  o === void 0 && ((o = Array.from(i.transforms)), n.set(r, o));
  const s = o.length;
  for (let l = 0; l < s && (o[l](e), e.isAttached()); l++);
}
function US(t, e) {
  return t !== void 0 && t.__key !== e && t.isAttached();
}
function rN(t) {
  return Rb(t, It()._nodes);
}
function Rb(t, e) {
  const n = t.type,
    r = e.get(n);
  r === void 0 && ge(17, n);
  const i = r.klass;
  t.type !== i.getType() && ge(18, i.name);
  const o = i.importJSON(t),
    s = t.children;
  if (X(o) && Array.isArray(s))
    for (let l = 0; l < s.length; l++) {
      const a = Rb(s[l], e);
      o.append(a);
    }
  return o;
}
function HS(t, e) {
  const n = Kt,
    r = zn,
    i = en;
  (Kt = t), (zn = !0), (en = null);
  try {
    return e();
  } finally {
    (Kt = n), (zn = r), (en = i);
  }
}
function bs(t, e) {
  const n = t._pendingEditorState,
    r = t._rootElement,
    i = t._headless || r === null;
  if (n === null) return;
  const o = t._editorState,
    s = o._selection,
    l = n._selection,
    a = t._dirtyType !== ks,
    c = Kt,
    u = zn,
    h = en,
    d = t._updating,
    f = t._observer;
  let p = null;
  if (((t._pendingEditorState = null), (t._editorState = n), !i && a && f !== null)) {
    (en = t), (Kt = n), (zn = !1), (t._updating = !0);
    try {
      const w = t._dirtyType,
        y = t._dirtyElements,
        C = t._dirtyLeaves;
      f.disconnect(), (p = WL(o, n, t, w, y, C));
    } catch (w) {
      if ((w instanceof Error && t._onError(w), Mg)) throw w;
      return KT(t, null, r, n), bT(t), (t._dirtyType = Xl), (Mg = !0), bs(t, o), void (Mg = !1);
    } finally {
      f.observe(r, WS), (t._updating = d), (Kt = c), (zn = u), (en = h);
    }
  }
  n._readOnly || (n._readOnly = !0);
  const m = t._dirtyLeaves,
    O = t._dirtyElements,
    v = t._normalizedNodes,
    g = t._updateTags,
    b = t._deferred;
  a &&
    ((t._dirtyType = ks),
    t._cloneNotNeeded.clear(),
    (t._dirtyLeaves = new Set()),
    (t._dirtyElements = new Map()),
    (t._normalizedNodes = new Set()),
    (t._updateTags = new Set())),
    (function (w, y) {
      const C = w._decorators;
      let P = w._pendingDecorators || C;
      const E = y._nodeMap;
      let N;
      for (N in P) E.has(N) || (P === C && (P = kT(w)), delete P[N]);
    })(t, n);
  const x = i ? null : mi(t._window);
  if (t._editable && x !== null && (a || l === null || l.dirty)) {
    (en = t), (Kt = n);
    try {
      if ((f !== null && f.disconnect(), a || l === null || l.dirty)) {
        const w = t._blockCursorElement;
        w !== null && Tb(w, t, r), eN(s, l, t, x, g, r);
      }
      DL(t, r, l), f !== null && f.observe(r, WS);
    } finally {
      (en = h), (Kt = c);
    }
  }
  p !== null &&
    (function (w, y, C, P, E) {
      const N = Array.from(w._listeners.mutation),
        L = N.length;
      for (let D = 0; D < L; D++) {
        const [Q, R] = N[D],
          W = y.get(R);
        W !== void 0 && Q(W, { dirtyLeaves: P, prevEditorState: E, updateTags: C });
      }
    })(t, p, g, m, o),
    ee(l) || l === null || (s !== null && s.is(l)) || t.dispatchCommand(ba, void 0);
  const k = t._pendingDecorators;
  k !== null && ((t._decorators = k), (t._pendingDecorators = null), Nc("decorator", t, !0, k)),
    (function (w, y, C) {
      const P = wS(y),
        E = wS(C);
      P !== E && Nc("textcontent", w, !0, E);
    })(t, e || o, n),
    Nc("update", t, !0, { dirtyElements: O, dirtyLeaves: m, editorState: n, normalizedNodes: v, prevEditorState: e || o, tags: g }),
    (function (w, y) {
      if (((w._deferred = []), y.length !== 0)) {
        const C = w._updating;
        w._updating = !0;
        try {
          for (let P = 0; P < y.length; P++) y[P]();
        } finally {
          w._updating = C;
        }
      }
    })(t, b),
    (function (w) {
      const y = w._updates;
      if (y.length !== 0) {
        const C = y.shift();
        if (C) {
          const [P, E] = C;
          GT(w, P, E);
        }
      }
    })(t);
}
function Nc(t, e, n, ...r) {
  const i = e._updating;
  e._updating = n;
  try {
    const o = Array.from(e._listeners[t]);
    for (let s = 0; s < o.length; s++) o[s].apply(null, r);
  } finally {
    e._updating = i;
  }
}
function YT(t, e, n) {
  if (t._updating === !1 || en !== t) {
    let i = !1;
    return (
      t.update(() => {
        i = YT(t, e, n);
      }),
      i
    );
  }
  const r = kb(t);
  for (let i = 4; i >= 0; i--)
    for (let o = 0; o < r.length; o++) {
      const s = r[o]._commands.get(e);
      if (s !== void 0) {
        const l = s[i];
        if (l !== void 0) {
          const a = Array.from(l),
            c = a.length;
          for (let u = 0; u < c; u++) if (a[u](n, t) === !0) return !0;
        }
      }
    }
  return !1;
}
function qS(t, e) {
  const n = t._updates;
  let r = e || !1;
  for (; n.length !== 0; ) {
    const i = n.shift();
    if (i) {
      const [o, s] = i;
      let l, a;
      s !== void 0 && ((l = s.onUpdate), (a = s.tag), s.skipTransforms && (r = !0), l && t._deferred.push(l), a && t._updateTags.add(a)),
        o();
    }
  }
  return r;
}
function GT(t, e, n) {
  const r = t._updateTags;
  let i,
    o,
    s = !1,
    l = !1;
  n !== void 0 && ((i = n.onUpdate), (o = n.tag), o != null && r.add(o), (s = n.skipTransforms || !1), (l = n.discrete || !1)),
    i && t._deferred.push(i);
  const a = t._editorState;
  let c = t._pendingEditorState,
    u = !1;
  (c === null || c._readOnly) && ((c = t._pendingEditorState = new am(new Map((c || a)._nodeMap))), (u = !0)), (c._flushSync = l);
  const h = Kt,
    d = zn,
    f = en,
    p = t._updating;
  (Kt = c), (zn = !1), (t._updating = !0), (en = t);
  try {
    u &&
      (t._headless
        ? a._selection !== null && (c._selection = a._selection.clone())
        : (c._selection = (function (g) {
            const b = g.getEditorState()._selection,
              x = mi(g._window);
            return ee(b) || b == null ? $b(b, x, g, null) : b.clone();
          })(t)));
    const O = t._compositionKey;
    e(),
      (s = qS(t, s)),
      (function (g, b) {
        const x = b.getEditorState()._selection,
          k = g._selection;
        if (ee(k)) {
          const w = k.anchor,
            y = k.focus;
          let C;
          if ((w.type === "text" && ((C = w.getNode()), C.selectionTransform(x, k)), y.type === "text")) {
            const P = y.getNode();
            C !== P && P.selectionTransform(x, k);
          }
        }
      })(c, t),
      t._dirtyType !== ks &&
        (s
          ? (function (g, b) {
              const x = b._dirtyLeaves,
                k = g._nodeMap;
              for (const w of x) {
                const y = k.get(w);
                te(y) && y.isAttached() && y.isSimpleText() && !y.isUnmergeable() && xS(y);
              }
            })(c, t)
          : (function (g, b) {
              const x = b._dirtyLeaves,
                k = b._dirtyElements,
                w = g._nodeMap,
                y = vo(),
                C = new Map();
              let P = x,
                E = P.size,
                N = k,
                L = N.size;
              for (; E > 0 || L > 0; ) {
                if (E > 0) {
                  b._dirtyLeaves = new Set();
                  for (const D of P) {
                    const Q = w.get(D);
                    te(Q) && Q.isAttached() && Q.isSimpleText() && !Q.isUnmergeable() && xS(Q),
                      Q !== void 0 && US(Q, y) && XS(b, Q, C),
                      x.add(D);
                  }
                  if (((P = b._dirtyLeaves), (E = P.size), E > 0)) {
                    Wd++;
                    continue;
                  }
                }
                (b._dirtyLeaves = new Set()), (b._dirtyElements = new Map());
                for (const D of N) {
                  const Q = D[0],
                    R = D[1];
                  if (Q !== "root" && !R) continue;
                  const W = w.get(Q);
                  W !== void 0 && US(W, y) && XS(b, W, C), k.set(Q, R);
                }
                (P = b._dirtyLeaves), (E = P.size), (N = b._dirtyElements), (L = N.size), Wd++;
              }
              (b._dirtyLeaves = x), (b._dirtyElements = k);
            })(c, t),
        qS(t),
        (function (g, b, x, k) {
          const w = g._nodeMap,
            y = b._nodeMap,
            C = [];
          for (const [P] of k) {
            const E = y.get(P);
            E !== void 0 && (E.isAttached() || (X(E) && AT(E, P, w, y, C, k), w.has(P) || k.delete(P), C.push(P)));
          }
          for (const P of C) y.delete(P);
          for (const P of x) {
            const E = y.get(P);
            E === void 0 || E.isAttached() || (w.has(P) || x.delete(P), y.delete(P));
          }
        })(a, c, t._dirtyLeaves, t._dirtyElements)),
      O !== t._compositionKey && (c._flushSync = !0);
    const v = c._selection;
    if (ee(v)) {
      const g = c._nodeMap,
        b = v.anchor.key,
        x = v.focus.key;
      (g.get(b) !== void 0 && g.get(x) !== void 0) || ge(19);
    } else Vt(v) && v._nodes.size === 0 && (c._selection = null);
  } catch (O) {
    return (
      O instanceof Error && t._onError(O),
      (t._pendingEditorState = a),
      (t._dirtyType = Xl),
      t._cloneNotNeeded.clear(),
      (t._dirtyLeaves = new Set()),
      t._dirtyElements.clear(),
      void bs(t)
    );
  } finally {
    (Kt = h), (zn = d), (en = f), (t._updating = p), (Wd = 0);
  }
  t._dirtyType !== ks ||
  (function (O, v) {
    const g = v.getEditorState()._selection,
      b = O._selection;
    if (b !== null) {
      if (b.dirty || !b.is(g)) return !0;
    } else if (g !== null) return !0;
    return !1;
  })(c, t)
    ? c._flushSync
      ? ((c._flushSync = !1), bs(t))
      : u &&
        $L(() => {
          bs(t);
        })
    : ((c._flushSync = !1), u && (r.clear(), (t._deferred = []), (t._pendingEditorState = null)));
}
function er(t, e, n) {
  t._updating ? t._updates.push([e, n]) : GT(t, e, n);
}
class Vr extends om {
  constructor(e) {
    super(e), (this.__first = null), (this.__last = null), (this.__size = 0), (this.__format = 0), (this.__indent = 0), (this.__dir = null);
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const e = this.getFormat();
    return wL[e] || "";
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) e.push(n), (n = n.getNextSibling());
    return e;
  }
  getChildrenKeys() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) e.push(n.__key), (n = n.getNextSibling());
    return e;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const e = It()._dirtyElements;
    return e !== null && e.has(this.__key);
  }
  isLastChild() {
    const e = this.getLatest(),
      n = this.getParentOrThrow().getLastChild();
    return n !== null && n.is(e);
  }
  getAllTextNodes() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) {
      if ((te(n) && e.push(n), X(n))) {
        const r = n.getAllTextNodes();
        e.push(...r);
      }
      n = n.getNextSibling();
    }
    return e;
  }
  getFirstDescendant() {
    let e = this.getFirstChild();
    for (; X(e); ) {
      const n = e.getFirstChild();
      if (n === null) break;
      e = n;
    }
    return e;
  }
  getLastDescendant() {
    let e = this.getLastChild();
    for (; X(e); ) {
      const n = e.getLastChild();
      if (n === null) break;
      e = n;
    }
    return e;
  }
  getDescendantByIndex(e) {
    const n = this.getChildren(),
      r = n.length;
    if (e >= r) {
      const o = n[r - 1];
      return (X(o) && o.getLastDescendant()) || o || null;
    }
    const i = n[e];
    return (X(i) && i.getFirstDescendant()) || i || null;
  }
  getFirstChild() {
    const e = this.getLatest().__first;
    return e === null ? null : dt(e);
  }
  getFirstChildOrThrow() {
    const e = this.getFirstChild();
    return e === null && ge(45, this.__key), e;
  }
  getLastChild() {
    const e = this.getLatest().__last;
    return e === null ? null : dt(e);
  }
  getLastChildOrThrow() {
    const e = this.getLastChild();
    return e === null && ge(96, this.__key), e;
  }
  getChildAtIndex(e) {
    const n = this.getChildrenSize();
    let r, i;
    if (e < n / 2) {
      for (r = this.getFirstChild(), i = 0; r !== null && i <= e; ) {
        if (i === e) return r;
        (r = r.getNextSibling()), i++;
      }
      return null;
    }
    for (r = this.getLastChild(), i = n - 1; r !== null && i >= e; ) {
      if (i === e) return r;
      (r = r.getPreviousSibling()), i--;
    }
    return null;
  }
  getTextContent() {
    let e = "";
    const n = this.getChildren(),
      r = n.length;
    for (let i = 0; i < r; i++) {
      const o = n[i];
      (e += o.getTextContent()), X(o) && i !== r - 1 && !o.isInline() && (e += Zi);
    }
    return e;
  }
  getTextContentSize() {
    let e = 0;
    const n = this.getChildren(),
      r = n.length;
    for (let i = 0; i < r; i++) {
      const o = n[i];
      (e += o.getTextContentSize()), X(o) && i !== r - 1 && !o.isInline() && (e += Zi.length);
    }
    return e;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  hasFormat(e) {
    if (e !== "") {
      const n = OS[e];
      return !!(this.getFormat() & n);
    }
    return !1;
  }
  select(e, n) {
    Cn();
    const r = ae();
    let i = e,
      o = n;
    const s = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (e === 0 && n === 0) {
        const a = this.getFirstChild();
        if (te(a) || X(a)) return a.select(0, 0);
      } else if (!((e !== void 0 && e !== s) || (n !== void 0 && n !== s))) {
        const a = this.getLastChild();
        if (te(a) || X(a)) return a.select();
      }
    }
    i === void 0 && (i = s), o === void 0 && (o = s);
    const l = this.__key;
    return ee(r) ? (r.anchor.set(l, i, "element"), r.focus.set(l, o, "element"), (r.dirty = !0), r) : HT(l, i, l, o, "element", "element");
  }
  selectStart() {
    const e = this.getFirstDescendant();
    return e ? e.selectStart() : this.select();
  }
  selectEnd() {
    const e = this.getLastDescendant();
    return e ? e.selectEnd() : this.select();
  }
  clear() {
    const e = this.getWritable();
    return this.getChildren().forEach((n) => n.remove()), e;
  }
  append(...e) {
    return this.splice(this.getChildrenSize(), 0, e);
  }
  setDirection(e) {
    const n = this.getWritable();
    return (n.__dir = e), n;
  }
  setFormat(e) {
    return (this.getWritable().__format = e !== "" ? OS[e] : 0), this;
  }
  setIndent(e) {
    return (this.getWritable().__indent = e), this;
  }
  splice(e, n, r) {
    const i = r.length,
      o = this.getChildrenSize(),
      s = this.getWritable(),
      l = s.__key,
      a = [],
      c = [],
      u = this.getChildAtIndex(e + n);
    let h = null,
      d = o - n + i;
    if (e !== 0)
      if (e === o) h = this.getLastChild();
      else {
        const p = this.getChildAtIndex(e);
        p !== null && (h = p.getPreviousSibling());
      }
    if (n > 0) {
      let p = h === null ? this.getFirstChild() : h.getNextSibling();
      for (let m = 0; m < n; m++) {
        p === null && ge(100);
        const O = p.getNextSibling(),
          v = p.__key;
        vs(p.getWritable()), c.push(v), (p = O);
      }
    }
    let f = h;
    for (let p = 0; p < i; p++) {
      const m = r[p];
      f !== null && m.is(f) && (h = f = f.getPreviousSibling());
      const O = m.getWritable();
      O.__parent === l && d--, vs(O);
      const v = m.__key;
      if (f === null) (s.__first = v), (O.__prev = null);
      else {
        const g = f.getWritable();
        (g.__next = v), (O.__prev = g.__key);
      }
      m.__key === l && ge(76), (O.__parent = l), a.push(v), (f = m);
    }
    if (e + n === o) f !== null && ((f.getWritable().__next = null), (s.__last = f.__key));
    else if (u !== null) {
      const p = u.getWritable();
      if (f !== null) {
        const m = f.getWritable();
        (p.__prev = f.__key), (m.__next = u.__key);
      } else p.__prev = null;
    }
    if (((s.__size = d), c.length)) {
      const p = ae();
      if (ee(p)) {
        const m = new Set(c),
          O = new Set(a),
          { anchor: v, focus: g } = p;
        YS(v, m, O) && Af(v, v.getNode(), this, h, u),
          YS(g, m, O) && Af(g, g.getNode(), this, h, u),
          d !== 0 || this.canBeEmpty() || Yt(this) || this.remove();
      }
    }
    return s;
  }
  exportJSON() {
    return {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      type: "element",
      version: 1,
    };
  }
  insertNewAfter(e, n) {
    return null;
  }
  canIndent() {
    return !0;
  }
  collapseAtStart(e) {
    return !1;
  }
  excludeFromCopy(e) {
    return !1;
  }
  canReplaceWith(e) {
    return !0;
  }
  canInsertAfter(e) {
    return !0;
  }
  canBeEmpty() {
    return !0;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  isInline() {
    return !1;
  }
  isShadowRoot() {
    return !1;
  }
  canMergeWith(e) {
    return !1;
  }
  extractWithChild(e, n, r) {
    return !1;
  }
}
function X(t) {
  return t instanceof Vr;
}
function YS(t, e, n) {
  let r = t.getNode();
  for (; r; ) {
    const i = r.__key;
    if (e.has(i) && !n.has(i)) return !0;
    r = r.getParent();
  }
  return !1;
}
class wi extends om {
  constructor(e) {
    super(e);
  }
  decorate(e, n) {
    ge(47);
  }
  isIsolated() {
    return !1;
  }
  isInline() {
    return !0;
  }
  isKeyboardSelectable() {
    return !0;
  }
}
function ot(t) {
  return t instanceof wi;
}
class wa extends Vr {
  static getType() {
    return "root";
  }
  static clone() {
    return new wa();
  }
  constructor() {
    super("root"), (this.__cachedText = null);
  }
  getTopLevelElementOrThrow() {
    ge(51);
  }
  getTextContent() {
    const e = this.__cachedText;
    return (!Ju() && It()._dirtyType !== ks) || e === null ? super.getTextContent() : e;
  }
  remove() {
    ge(52);
  }
  replace(e) {
    ge(53);
  }
  insertBefore(e) {
    ge(54);
  }
  insertAfter(e) {
    ge(55);
  }
  updateDOM(e, n) {
    return !1;
  }
  append(...e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      X(r) || ot(r) || ge(56);
    }
    return super.append(...e);
  }
  static importJSON(e) {
    const n = Qe();
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      type: "root",
      version: 1,
    };
  }
  collapseAtStart() {
    return !0;
  }
}
function tn(t) {
  return t instanceof wa;
}
function Ib() {
  return new am(new Map([["root", new wa()]]));
}
function JT(t) {
  const e = t.exportJSON(),
    n = t.constructor;
  if ((e.type !== n.getType() && ge(130, n.name), X(t))) {
    const r = e.children;
    Array.isArray(r) || ge(59, n.name);
    const i = t.getChildren();
    for (let o = 0; o < i.length; o++) {
      const s = JT(i[o]);
      r.push(s);
    }
  }
  return e;
}
class am {
  constructor(e, n) {
    (this._nodeMap = e), (this._selection = n || null), (this._flushSync = !1), (this._readOnly = !1);
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(e) {
    return HS(this, e);
  }
  clone(e) {
    const n = new am(this._nodeMap, e === void 0 ? this._selection : e);
    return (n._readOnly = !0), n;
  }
  toJSON() {
    return HS(this, () => ({ root: JT(Qe()) }));
  }
}
class Mb extends Vr {
  static getType() {
    return "artificial";
  }
  createDOM(e) {
    return document.createElement("div");
  }
}
class Xs extends Vr {
  constructor(e) {
    super(e), (this.__textFormat = 0);
  }
  static getType() {
    return "paragraph";
  }
  getTextFormat() {
    return this.getLatest().__textFormat;
  }
  setTextFormat(e) {
    const n = this.getWritable();
    return (n.__textFormat = e), n;
  }
  hasTextFormat(e) {
    const n = Di[e];
    return !!(this.getTextFormat() & n);
  }
  static clone(e) {
    return new Xs(e.__key);
  }
  createDOM(e) {
    const n = document.createElement("p"),
      r = Ic(e.theme, "paragraph");
    return r !== void 0 && n.classList.add(...r), n;
  }
  updateDOM(e, n, r) {
    return !1;
  }
  static importDOM() {
    return { p: (e) => ({ conversion: iN, priority: 0 }) };
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (n && $r(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
      const o = this.getIndent();
      o > 0 && (n.style.textIndent = 20 * o + "px");
    }
    return { element: n };
  }
  static importJSON(e) {
    const n = tt();
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n.setTextFormat(e.textFormat), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), textFormat: this.getTextFormat(), type: "paragraph", version: 1 };
  }
  insertNewAfter(e, n) {
    const r = tt();
    r.setTextFormat(e.format);
    const i = this.getDirection();
    return r.setDirection(i), r.setFormat(this.getFormatType()), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const e = this.getChildren();
    if (e.length === 0 || (te(e[0]) && e[0].getTextContent().trim() === "")) {
      if (this.getNextSibling() !== null) return this.selectNext(), this.remove(), !0;
      if (this.getPreviousSibling() !== null) return this.selectPrevious(), this.remove(), !0;
    }
    return !1;
  }
}
function iN(t) {
  const e = tt();
  if (t.style) {
    e.setFormat(t.style.textAlign);
    const n = parseInt(t.style.textIndent, 10) / 20;
    n > 0 && e.setIndent(n);
  }
  return { node: e };
}
function tt() {
  return Mn(new Xs());
}
function zi(t) {
  return t instanceof Xs;
}
const Ze = 0,
  ht = 1,
  $f = 3,
  Bn = 4;
function KT(t, e, n, r) {
  const i = t._keyToDOMMap;
  i.clear(),
    (t._editorState = Ib()),
    (t._pendingEditorState = r),
    (t._compositionKey = null),
    (t._dirtyType = ks),
    t._cloneNotNeeded.clear(),
    (t._dirtyLeaves = new Set()),
    t._dirtyElements.clear(),
    (t._normalizedNodes = new Set()),
    (t._updateTags = new Set()),
    (t._updates = []),
    (t._blockCursorElement = null);
  const o = t._observer;
  o !== null && (o.disconnect(), (t._observer = null)),
    e !== null && (e.textContent = ""),
    n !== null && ((n.textContent = ""), i.set("root", n));
}
function Lb(t) {
  const e = t || {},
    n = nN(),
    r = e.theme || {},
    i = t === void 0 ? n : e.parentEditor || null,
    o = e.disableEvents || !1,
    s = Ib(),
    l = e.namespace || (i !== null ? i._config.namespace : ET()),
    a = e.editorState,
    c = [wa, Ki, Yu, Gu, Xs, Mb, ...(e.nodes || [])],
    { onError: u, html: h } = e,
    d = e.editable === void 0 || e.editable;
  let f;
  if (t === void 0 && n !== null) f = n._nodes;
  else {
    f = new Map();
    for (let m = 0; m < c.length; m++) {
      let O = c[m],
        v = null,
        g = null;
      if (typeof O != "function") {
        const w = O;
        (O = w.replace), (v = w.with), (g = w.withKlass || null);
      }
      const b = O.getType(),
        x = O.transform(),
        k = new Set();
      x !== null && k.add(x),
        f.set(b, { exportDOM: h && h.export ? h.export.get(O) : void 0, klass: O, replace: v, replaceWithKlass: g, transforms: k });
    }
  }
  const p = new oN(
    s,
    i,
    f,
    { disableEvents: o, namespace: l, theme: r },
    u || console.error,
    (function (m, O) {
      const v = new Map(),
        g = new Set(),
        b = (x) => {
          Object.keys(x).forEach((k) => {
            let w = v.get(k);
            w === void 0 && ((w = []), v.set(k, w)), w.push(x[k]);
          });
        };
      return (
        m.forEach((x) => {
          const k = x.klass.importDOM;
          if (k == null || g.has(k)) return;
          g.add(k);
          const w = k.call(x.klass);
          w !== null && b(w);
        }),
        O && b(O),
        v
      );
    })(f, h ? h.import : void 0),
    d
  );
  return a !== void 0 && ((p._pendingEditorState = a), (p._dirtyType = Xl)), p;
}
class oN {
  constructor(e, n, r, i, o, s, l) {
    (this._parentEditor = n),
      (this._rootElement = null),
      (this._editorState = e),
      (this._pendingEditorState = null),
      (this._compositionKey = null),
      (this._deferred = []),
      (this._keyToDOMMap = new Map()),
      (this._updates = []),
      (this._updating = !1),
      (this._listeners = {
        decorator: new Set(),
        editable: new Set(),
        mutation: new Map(),
        root: new Set(),
        textcontent: new Set(),
        update: new Set(),
      }),
      (this._commands = new Map()),
      (this._config = i),
      (this._nodes = r),
      (this._decorators = {}),
      (this._pendingDecorators = null),
      (this._dirtyType = ks),
      (this._cloneNotNeeded = new Set()),
      (this._dirtyLeaves = new Set()),
      (this._dirtyElements = new Map()),
      (this._normalizedNodes = new Set()),
      (this._updateTags = new Set()),
      (this._observer = null),
      (this._key = ET()),
      (this._onError = o),
      (this._htmlConversions = s),
      (this._editable = l),
      (this._headless = n !== null && n._headless),
      (this._window = null),
      (this._blockCursorElement = null);
  }
  isComposing() {
    return this._compositionKey != null;
  }
  registerUpdateListener(e) {
    const n = this._listeners.update;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerEditableListener(e) {
    const n = this._listeners.editable;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerDecoratorListener(e) {
    const n = this._listeners.decorator;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerTextContentListener(e) {
    const n = this._listeners.textcontent;
    return (
      n.add(e),
      () => {
        n.delete(e);
      }
    );
  }
  registerRootListener(e) {
    const n = this._listeners.root;
    return (
      e(this._rootElement, null),
      n.add(e),
      () => {
        e(null, this._rootElement), n.delete(e);
      }
    );
  }
  registerCommand(e, n, r) {
    r === void 0 && ge(35);
    const i = this._commands;
    i.has(e) || i.set(e, [new Set(), new Set(), new Set(), new Set(), new Set()]);
    const o = i.get(e);
    o === void 0 && ge(36, String(e));
    const s = o[r];
    return (
      s.add(n),
      () => {
        s.delete(n), o.every((l) => l.size === 0) && i.delete(e);
      }
    );
  }
  registerMutationListener(e, n) {
    let r = this._nodes.get(e.getType());
    r === void 0 && ge(37, e.name);
    let i = e,
      o = null;
    for (; (o = r.replaceWithKlass); ) (i = o), (r = this._nodes.get(o.getType())), r === void 0 && ge(37, o.name);
    const s = this._listeners.mutation;
    return (
      s.set(n, i),
      () => {
        s.delete(n);
      }
    );
  }
  registerNodeTransformToKlass(e, n) {
    const r = e.getType(),
      i = this._nodes.get(r);
    return i === void 0 && ge(37, e.name), i.transforms.add(n), i;
  }
  registerNodeTransform(e, n) {
    const r = this.registerNodeTransformToKlass(e, n),
      i = [r],
      o = r.replaceWithKlass;
    if (o != null) {
      const a = this.registerNodeTransformToKlass(o, n);
      i.push(a);
    }
    var s, l;
    return (
      (s = this),
      (l = e.getType()),
      er(
        s,
        () => {
          const a = eo();
          if (a.isEmpty()) return;
          if (l === "root") return void Qe().markDirty();
          const c = a._nodeMap;
          for (const [, u] of c) u.markDirty();
        },
        s._pendingEditorState === null ? { tag: "history-merge" } : void 0
      ),
      () => {
        i.forEach((a) => a.transforms.delete(n));
      }
    );
  }
  hasNode(e) {
    return this._nodes.has(e.getType());
  }
  hasNodes(e) {
    return e.every(this.hasNode.bind(this));
  }
  dispatchCommand(e, n) {
    return ve(this, e, n);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(e) {
    const n = this._rootElement;
    if (e !== n) {
      const r = Ic(this._config.theme, "root"),
        i = this._pendingEditorState || this._editorState;
      if (
        ((this._rootElement = e),
        KT(this, n, e, i),
        n !== null && (this._config.disableEvents || XL(n), r != null && n.classList.remove(...r)),
        e !== null)
      ) {
        const o = (function (l) {
            const a = l.ownerDocument;
            return (a && a.defaultView) || null;
          })(e),
          s = e.style;
        (s.userSelect = "text"),
          (s.whiteSpace = "pre-wrap"),
          (s.wordBreak = "break-word"),
          e.setAttribute("data-lexical-editor", "true"),
          (this._window = o),
          (this._dirtyType = Xl),
          bT(this),
          this._updateTags.add("history-merge"),
          bs(this),
          this._config.disableEvents ||
            (function (l, a) {
              const c = l.ownerDocument,
                u = Ef.get(c);
              (u === void 0 || u < 1) && c.addEventListener("selectionchange", ZT), Ef.set(c, (u || 0) + 1), (l.__lexicalEditor = a);
              const h = jT(l);
              for (let d = 0; d < P0.length; d++) {
                const [f, p] = P0[d],
                  m =
                    typeof p == "function"
                      ? (O) => {
                          IS(O) || (RS(O), (a.isEditable() || f === "click") && p(O, a));
                        }
                      : (O) => {
                          if (IS(O)) return;
                          RS(O);
                          const v = a.isEditable();
                          switch (f) {
                            case "cut":
                              return v && ve(a, ub, O);
                            case "copy":
                              return ve(a, Yp, O);
                            case "paste":
                              return v && ve(a, Wu, O);
                            case "dragstart":
                              return v && ve(a, qp, O);
                            case "dragover":
                              return v && ve(a, cb, O);
                            case "dragend":
                              return v && ve(a, aL, O);
                            case "focus":
                              return v && ve(a, hb, O);
                            case "blur":
                              return v && ve(a, Gp, O);
                            case "drop":
                              return v && ve(a, ab, O);
                          }
                        };
                l.addEventListener(f, m),
                  h.push(() => {
                    l.removeEventListener(f, m);
                  });
              }
            })(e, this),
          r != null && e.classList.add(...r);
      } else (this._editorState = i), (this._pendingEditorState = null), (this._window = null);
      Nc("root", this, !1, e, n);
    }
  }
  getElementByKey(e) {
    return this._keyToDOMMap.get(e) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(e, n) {
    e.isEmpty() && ge(38), vT(this);
    const r = this._pendingEditorState,
      i = this._updateTags,
      o = n !== void 0 ? n.tag : null;
    r === null || r.isEmpty() || (o != null && i.add(o), bs(this)),
      (this._pendingEditorState = e),
      (this._dirtyType = Xl),
      this._dirtyElements.set("root", !1),
      (this._compositionKey = null),
      o != null && i.add(o),
      bs(this);
  }
  parseEditorState(e, n) {
    return (function (r, i, o) {
      const s = Ib(),
        l = Kt,
        a = zn,
        c = en,
        u = i._dirtyElements,
        h = i._dirtyLeaves,
        d = i._cloneNotNeeded,
        f = i._dirtyType;
      (i._dirtyElements = new Map()),
        (i._dirtyLeaves = new Set()),
        (i._cloneNotNeeded = new Set()),
        (i._dirtyType = 0),
        (Kt = s),
        (zn = !1),
        (en = i);
      try {
        const p = i._nodes;
        Rb(r.root, p), o && o(), (s._readOnly = !0);
      } catch (p) {
        p instanceof Error && i._onError(p);
      } finally {
        (i._dirtyElements = u), (i._dirtyLeaves = h), (i._cloneNotNeeded = d), (i._dirtyType = f), (Kt = l), (zn = a), (en = c);
      }
      return s;
    })(typeof e == "string" ? JSON.parse(e) : e, this, n);
  }
  update(e, n) {
    er(this, e, n);
  }
  focus(e, n = {}) {
    const r = this._rootElement;
    r !== null &&
      (r.setAttribute("autocapitalize", "off"),
      er(
        this,
        () => {
          const i = ae(),
            o = Qe();
          i !== null ? (i.dirty = !0) : o.getChildrenSize() !== 0 && (n.defaultSelection === "rootStart" ? o.selectStart() : o.selectEnd());
        },
        {
          onUpdate: () => {
            r.removeAttribute("autocapitalize"), e && e();
          },
          tag: "focus",
        }
      ),
      this._pendingEditorState === null && r.removeAttribute("autocapitalize"));
  }
  blur() {
    const e = this._rootElement;
    e !== null && e.blur();
    const n = mi(this._window);
    n !== null && n.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(e) {
    this._editable !== e && ((this._editable = e), Nc("editable", this, !0, e));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
}
function sN(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var eP = sN(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const lN = new Map();
function aN(t) {
  const e = {},
    n = t.split(";");
  for (const r of n)
    if (r !== "") {
      const [i, o] = r.split(/:([^]+)/);
      i && o && (e[i.trim()] = o.trim());
    }
  return e;
}
function Nb(t) {
  const e = t.constructor.clone(t);
  return (
    (e.__parent = t.__parent),
    (e.__next = t.__next),
    (e.__prev = t.__prev),
    X(t) && X(e)
      ? ((r = t),
        ((n = e).__first = r.__first),
        (n.__last = r.__last),
        (n.__size = r.__size),
        (n.__format = r.__format),
        (n.__indent = r.__indent),
        (n.__dir = r.__dir),
        n)
      : te(t) && te(e)
      ? (function (i, o) {
          return (i.__format = o.__format), (i.__style = o.__style), (i.__mode = o.__mode), (i.__detail = o.__detail), i;
        })(e, t)
      : zi(t) && zi(e)
      ? (function (i, o) {
          return (i.__textFormat = o.__textFormat), i;
        })(e, t)
      : e
  );
  var n, r;
}
function tP(t, e) {
  const n = t.getStartEndPoints();
  if (e.isSelected(t) && !e.isSegmented() && !e.isToken() && n !== null) {
    const [r, i] = n,
      o = t.isBackward(),
      s = r.getNode(),
      l = i.getNode(),
      a = e.is(s),
      c = e.is(l);
    if (a || c) {
      const [u, h] = I0(t),
        d = s.is(l),
        f = e.is(o ? l : s),
        p = e.is(o ? s : l);
      let m,
        O = 0;
      return (
        d ? ((O = u > h ? h : u), (m = u > h ? u : h)) : f ? ((O = o ? h : u), (m = void 0)) : p && ((O = 0), (m = o ? u : h)),
        (e.__text = e.__text.slice(O, m)),
        e
      );
    }
  }
  return e;
}
function GS(t) {
  if (t.type === "text") return t.offset === t.getNode().getTextContentSize();
  const e = t.getNode();
  return X(e) || eP(177), t.offset === e.getChildrenSize();
}
function cN(t, e, n) {
  let r = e.getNode(),
    i = n;
  if (X(r)) {
    const o = r.getDescendantByIndex(e.offset);
    o !== null && (r = o);
  }
  for (; i > 0 && r !== null; ) {
    if (X(r)) {
      const c = r.getLastDescendant();
      c !== null && (r = c);
    }
    let o = r.getPreviousSibling(),
      s = 0;
    if (o === null) {
      let c = r.getParentOrThrow(),
        u = c.getPreviousSibling();
      for (; u === null; ) {
        if (((c = c.getParent()), c === null)) {
          o = null;
          break;
        }
        u = c.getPreviousSibling();
      }
      c !== null && ((s = c.isInline() ? 0 : 2), (o = u));
    }
    let l = r.getTextContent();
    l === "" &&
      X(r) &&
      !r.isInline() &&
      (l = `

`);
    const a = l.length;
    if (!te(r) || i >= a) {
      const c = r.getParent();
      r.remove(), c == null || c.getChildrenSize() !== 0 || tn(c) || c.remove(), (i -= a + s), (r = o);
    } else {
      const c = r.getKey(),
        u = t.getEditorState().read(() => {
          const f = dt(c);
          return te(f) && f.isSimpleText() ? f.getTextContent() : null;
        }),
        h = a - i,
        d = l.slice(0, h);
      if (u !== null && u !== l) {
        const f = Ws();
        let p = r;
        if (r.isSimpleText()) r.setTextContent(u);
        else {
          const m = yt(u);
          r.replace(m), (p = m);
        }
        if (ee(f) && f.isCollapsed()) {
          const m = f.anchor.offset;
          p.select(m, m);
        }
      } else if (r.isSimpleText()) {
        const f = e.key === c;
        let p = e.offset;
        p < i && (p = a);
        const m = f ? p - i : 0,
          O = f ? p : h;
        if (f && m === 0) {
          const [v] = r.splitText(m, O);
          v.remove();
        } else {
          const [, v] = r.splitText(m, O);
          v.remove();
        }
      } else {
        const f = yt(d);
        r.replace(f);
      }
      i = 0;
    }
  }
}
function uN(t) {
  const e = t.getStyle(),
    n = aN(e);
  lN.set(e, n);
}
function hN(t, e) {
  if (t === null) return;
  const n = t.getStartEndPoints(),
    r = n ? n[0] : null;
  if (r !== null && r.key === "root") {
    const s = e(),
      l = Qe(),
      a = l.getFirstChild();
    return void (a ? a.replace(s, !0) : l.append(s));
  }
  const i = t.getNodes(),
    o =
      r !== null &&
      (function (s, l) {
        let a = s;
        for (; a !== null && a.getParent() !== null && !l(a); ) a = a.getParentOrThrow();
        return l(a) ? a : null;
      })(r.getNode(), ek);
  o && i.indexOf(o) === -1 && i.push(o);
  for (let s = 0; s < i.length; s++) {
    const l = i[s];
    if (!ek(l)) continue;
    X(l) || eP(178);
    const a = e();
    a.setFormat(l.getFormatType()), a.setIndent(l.getIndent()), l.replace(a, !0);
  }
}
function JS(t, e) {
  const n = Kc(t.focus, e);
  return (ot(n) && !n.isIsolated()) || (X(n) && !n.isInline() && !n.canBeEmpty());
}
function dN(t, e, n, r) {
  t.modify(e ? "extend" : "move", n, r);
}
function fN(t) {
  const e = t.anchor.getNode();
  return (tn(e) ? e : e.getParentOrThrow()).getDirection() === "rtl";
}
function KS(t, e, n) {
  const r = fN(t);
  dN(t, e, n ? !r : r, "character");
}
function ek(t) {
  if (ot(t) || !X(t) || Yt(t)) return !1;
  const e = t.getFirstChild(),
    n = e === null || Ar(e) || te(e) || e.isInline();
  return !t.isInline() && t.canBeEmpty() !== !1 && n;
}
const pN = cN;
function mN(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var nP = mN(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const Qb = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  gN = Qb && "documentMode" in document ? document.documentMode : null,
  ON = Qb && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
!(!Qb || !("InputEvent" in window) || gN) && "getTargetRanges" in new window.InputEvent("input");
function rP(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
function Xn(...t) {
  return () => {
    for (let e = t.length - 1; e >= 0; e--) t[e]();
    t.length = 0;
  };
}
const vN = ON;
function Rr(t, ...e) {
  const n = rP(...e);
  n.length > 0 && t.classList.add(...n);
}
function cm(t, ...e) {
  const n = rP(...e);
  n.length > 0 && t.classList.remove(...n);
}
function iP(t, e) {
  let n = t;
  for (; n != null; ) {
    if (n instanceof e) return n;
    n = n.getParent();
  }
  return null;
}
function oP(t) {
  const e = Sa(t, (n) => X(n) && !n.isInline());
  return X(e) || nP(4, t.__key), e;
}
const Sa = (t, e) => {
  let n = t;
  for (; n !== Qe() && n != null; ) {
    if (e(n)) return n;
    n = n.getParent();
  }
  return null;
};
function bN(t, e) {
  const n = new Map(),
    r = t._pendingEditorState;
  for (const [o, s] of e._nodeMap) {
    const l = Nb(s);
    te(l) && (te(s) || nP(180), (l.__text = s.__text)), n.set(o, l);
  }
  r && (r._nodeMap = n), (t._dirtyType = 2);
  const i = e._selection;
  pn(i === null ? null : i.clone());
}
function sP(t) {
  const e = ae() || Ws();
  if (ee(e)) {
    const { focus: n } = e,
      r = n.getNode(),
      i = n.offset;
    if (Yt(r)) {
      const o = r.getChildAtIndex(i);
      o == null ? r.append(t) : o.insertBefore(t), t.selectNext();
    } else {
      let o, s;
      te(r) ? ((o = r.getParentOrThrow()), (s = r.getIndexWithinParent()), i > 0 && ((s += 1), r.splitText(i))) : ((o = r), (s = i));
      const [, l] = FL(o, s);
      l.insertBefore(t), l.selectStart();
    }
  } else {
    if (e != null) {
      const r = e.getNodes();
      r[r.length - 1].getTopLevelElementOrThrow().insertAfter(t);
    } else Qe().append(t);
    const n = tt();
    t.insertAfter(n), n.select();
  }
  return t.getLatest();
}
function Db(t, e) {
  const n = e();
  return t.replace(n), n.append(t), n;
}
function bo(t, e) {
  return t !== null && Object.getPrototypeOf(t).constructor.name === e.name;
}
function xN(t, e) {
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const i = e(t[r]);
    i !== null && n.push(i);
  }
  return n;
}
function yN(t) {
  if (vN) return 1;
  let e = 1;
  for (; t; ) (e *= Number(window.getComputedStyle(t).getPropertyValue("zoom"))), (t = t.parentElement);
  return e;
}
const zh = 0,
  L0 = 1,
  N0 = 2,
  Er = 0,
  wN = 1,
  tk = 2,
  SN = 3,
  kN = 4;
function CN(t, e, n, r, i) {
  if (t === null || (n.size === 0 && r.size === 0 && !i)) return Er;
  const o = e._selection,
    s = t._selection;
  if (i) return wN;
  if (!(ee(o) && ee(s) && s.isCollapsed() && o.isCollapsed())) return Er;
  const l = (function (v, g, b) {
    const x = v._nodeMap,
      k = [];
    for (const w of g) {
      const y = x.get(w);
      y !== void 0 && k.push(y);
    }
    for (const [w, y] of b) {
      if (!y) continue;
      const C = x.get(w);
      C === void 0 || tn(C) || k.push(C);
    }
    return k;
  })(e, n, r);
  if (l.length === 0) return Er;
  if (l.length > 1) {
    const v = e._nodeMap,
      g = v.get(o.anchor.key),
      b = v.get(s.anchor.key);
    return g && b && !t._nodeMap.has(g.__key) && te(g) && g.__text.length === 1 && o.anchor.offset === 1 ? tk : Er;
  }
  const a = l[0],
    c = t._nodeMap.get(a.__key);
  if (!te(c) || !te(a) || c.__mode !== a.__mode) return Er;
  const u = c.__text,
    h = a.__text;
  if (u === h) return Er;
  const d = o.anchor,
    f = s.anchor;
  if (d.key !== f.key || d.type !== "text") return Er;
  const p = d.offset,
    m = f.offset,
    O = h.length - u.length;
  return O === 1 && m === p - 1 ? tk : O === -1 && m === p + 1 ? SN : O === -1 && m === p ? kN : Er;
}
function _N(t, e) {
  let n = Date.now(),
    r = Er;
  return (i, o, s, l, a, c) => {
    const u = Date.now();
    if (c.has("historic")) return (r = Er), (n = u), N0;
    const h = CN(i, o, l, a, t.isComposing()),
      d = (() => {
        const f = s === null || s.editor === t,
          p = c.has("history-push");
        if (!p && f && c.has("history-merge")) return zh;
        if (i === null) return L0;
        const m = o._selection;
        return l.size > 0 || a.size > 0
          ? (p === !1 && h !== Er && h === r && u < n + e && f) ||
            (l.size === 1 &&
              (function (O, v, g) {
                const b = v._nodeMap.get(O),
                  x = g._nodeMap.get(O),
                  k = v._selection,
                  w = g._selection;
                let y = !1;
                return (
                  ee(k) &&
                    ee(w) &&
                    (y = k.anchor.type === "element" && k.focus.type === "element" && w.anchor.type === "text" && w.focus.type === "text"),
                  !(y || !te(b) || !te(x)) &&
                    b.__type === x.__type &&
                    b.__text === x.__text &&
                    b.__mode === x.__mode &&
                    b.__detail === x.__detail &&
                    b.__style === x.__style &&
                    b.__format === x.__format &&
                    b.__parent === x.__parent
                );
              })(Array.from(l)[0], i, o))
            ? zh
            : L0
          : m !== null
          ? zh
          : N0;
      })();
    return (n = u), (r = h), d;
  };
}
function nk(t) {
  (t.undoStack = []), (t.redoStack = []), (t.current = null);
}
function EN(t, e, n) {
  const r = _N(t, n);
  return Xn(
    t.registerCommand(
      Xp,
      () => (
        (function (o, s) {
          const l = s.redoStack,
            a = s.undoStack;
          if (a.length !== 0) {
            const c = s.current,
              u = a.pop();
            c !== null && (l.push(c), o.dispatchCommand(pc, !0)),
              a.length === 0 && o.dispatchCommand(mc, !1),
              (s.current = u || null),
              u && u.editor.setEditorState(u.editorState, { tag: "historic" });
          }
        })(t, e),
        !0
      ),
      Ze
    ),
    t.registerCommand(
      Up,
      () => (
        (function (o, s) {
          const l = s.redoStack,
            a = s.undoStack;
          if (l.length !== 0) {
            const c = s.current;
            c !== null && (a.push(c), o.dispatchCommand(mc, !0));
            const u = l.pop();
            l.length === 0 && o.dispatchCommand(pc, !1),
              (s.current = u || null),
              u && u.editor.setEditorState(u.editorState, { tag: "historic" });
          }
        })(t, e),
        !0
      ),
      Ze
    ),
    t.registerCommand(cL, () => (nk(e), !1), Ze),
    t.registerCommand(uL, () => (nk(e), t.dispatchCommand(pc, !1), t.dispatchCommand(mc, !1), !0), Ze),
    t.registerUpdateListener(({ editorState: o, prevEditorState: s, dirtyLeaves: l, dirtyElements: a, tags: c }) => {
      const u = e.current,
        h = e.redoStack,
        d = e.undoStack,
        f = u === null ? null : u.editorState;
      if (u !== null && o === f) return;
      const p = r(s, o, u, l, a, c);
      if (p === L0)
        h.length !== 0 && ((e.redoStack = []), t.dispatchCommand(pc, !1)), u !== null && (d.push({ ...u }), t.dispatchCommand(mc, !0));
      else if (p === N0) return;
      e.current = { editor: t, editorState: o };
    })
  );
}
function lP() {
  return { current: null, redoStack: [], undoStack: [] };
}
function aP({ externalHistoryState: t }) {
  const [e] = In();
  return (
    (function (n, r, i = 1e3) {
      const o = _.useMemo(() => r || lP(), [r]);
      _.useEffect(() => EN(n, o, i), [i, n, o]);
    })(e, t),
    null
  );
}
function TN(t, e) {
  const n = e.body ? e.body.childNodes : [];
  let r = [];
  const i = [];
  for (let o = 0; o < n.length; o++) {
    const s = n[o];
    if (!uP.has(s.nodeName)) {
      const l = hP(s, t, i, !1);
      l !== null && (r = r.concat(l));
    }
  }
  return (
    (function (o) {
      for (const s of o) s.getNextSibling() instanceof Mb && s.insertAfter(gi());
      for (const s of o) {
        const l = s.getChildren();
        for (const a of l) s.insertBefore(a);
        s.remove();
      }
    })(i),
    r
  );
}
function PN(t, e) {
  if (typeof document > "u" || (typeof window > "u" && global.window === void 0))
    throw new Error(
      "To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function."
    );
  const n = document.createElement("div"),
    r = Qe().getChildren();
  for (let i = 0; i < r.length; i++) cP(t, r[i], n, e);
  return n.innerHTML;
}
function cP(t, e, n, r = null) {
  let i = r === null || e.isSelected(r);
  const o = X(e) && e.excludeFromCopy("html");
  let s = e;
  if (r !== null) {
    let f = Nb(e);
    (f = te(f) && r !== null ? tP(r, f) : f), (s = f);
  }
  const l = X(s) ? s.getChildren() : [],
    a = t._nodes.get(s.getType());
  let c;
  c = a && a.exportDOM !== void 0 ? a.exportDOM(t, s) : s.exportDOM(t);
  const { element: u, after: h } = c;
  if (!u) return !1;
  const d = document.createDocumentFragment();
  for (let f = 0; f < l.length; f++) {
    const p = l[f],
      m = cP(t, p, d, r);
    !i && X(e) && m && e.extractWithChild(p, r, "html") && (i = !0);
  }
  if (i && !o) {
    if (($r(u) && u.append(d), n.append(u), h)) {
      const f = h.call(s, u);
      f && u.replaceWith(f);
    }
  } else n.append(d);
  return i;
}
const uP = new Set(["STYLE", "SCRIPT"]);
function hP(t, e, n, r, i = new Map(), o) {
  let s = [];
  if (uP.has(t.nodeName)) return s;
  let l = null;
  const a = (function (p, m) {
      const { nodeName: O } = p,
        v = m._htmlConversions.get(O.toLowerCase());
      let g = null;
      if (v !== void 0)
        for (const b of v) {
          const x = b(p);
          x !== null && (g === null || (g.priority || 0) < (x.priority || 0)) && (g = x);
        }
      return g !== null ? g.conversion : null;
    })(t, e),
    c = a ? a(t) : null;
  let u = null;
  if (c !== null) {
    u = c.after;
    const p = c.node;
    if (((l = Array.isArray(p) ? p[p.length - 1] : p), l !== null)) {
      for (const [, m] of i) if (((l = m(l, o)), !l)) break;
      l && s.push(...(Array.isArray(p) ? p : [l]));
    }
    c.forChild != null && i.set(t.nodeName, c.forChild);
  }
  const h = t.childNodes;
  let d = [];
  const f = (l == null || !Yt(l)) && ((l != null && Tf(l)) || r);
  for (let p = 0; p < h.length; p++) d.push(...hP(h[p], e, n, f, new Map(i), l));
  return (
    u != null && (d = u(d)),
    jL(t) &&
      (d = AN(
        t,
        d,
        f
          ? () => {
              const p = new Mb();
              return n.push(p), p;
            }
          : tt
      )),
    l == null ? (s = s.concat(d)) : X(l) && l.append(...d),
    s
  );
}
function AN(t, e, n) {
  const r = t.style.textAlign,
    i = [];
  let o = [];
  for (let s = 0; s < e.length; s++) {
    const l = e[s];
    if (Tf(l)) r && !l.getFormat() && l.setFormat(r), i.push(l);
    else if ((o.push(l), s === e.length - 1 || (s < e.length - 1 && Tf(e[s + 1])))) {
      const a = n();
      a.setFormat(r), a.append(...o), i.push(a), (o = []);
    }
  }
  return i;
}
function $N(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Rf = $N(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const RN = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  dP = (t) => (RN ? (t || window).getSelection() : null);
function IN(t) {
  const e = ae();
  return e == null && Rf(166), (ee(e) && e.isCollapsed()) || e.getNodes().length === 0 ? "" : PN(t, e);
}
function MN(t) {
  const e = ae();
  return e == null && Rf(166), (ee(e) && e.isCollapsed()) || e.getNodes().length === 0 ? null : JSON.stringify(LN(t, e));
}
function rk(t, e, n) {
  const r = t.getData("application/x-lexical-editor");
  if (r)
    try {
      const s = JSON.parse(r);
      if (s.namespace === n._config.namespace && Array.isArray(s.nodes)) return ik(n, NN(s.nodes), e);
    } catch {}
  const i = t.getData("text/html");
  if (i)
    try {
      const s = new DOMParser().parseFromString(i, "text/html");
      return ik(n, TN(n, s), e);
    } catch {}
  const o = t.getData("text/plain") || t.getData("text/uri-list");
  if (o != null)
    if (ee(e)) {
      const s = o.split(/(\r?\n|\t)/);
      s[s.length - 1] === "" && s.pop();
      for (let l = 0; l < s.length; l++) {
        const a = ae();
        if (ee(a)) {
          const c = s[l];
          c ===
            `
` ||
          c ===
            `\r
`
            ? a.insertParagraph()
            : c === "	"
            ? a.insertNodes([xa()])
            : a.insertText(c);
        }
      }
    } else e.insertRawText(o);
}
function ik(t, e, n) {
  t.dispatchCommand(iL, { nodes: e, selection: n }) || n.insertNodes(e);
}
function fP(t, e, n, r = []) {
  let i = e === null || n.isSelected(e);
  const o = X(n) && n.excludeFromCopy("html");
  let s = n;
  if (e !== null) {
    let c = Nb(n);
    (c = te(c) && e !== null ? tP(e, c) : c), (s = c);
  }
  const l = X(s) ? s.getChildren() : [],
    a = (function (c) {
      const u = c.exportJSON(),
        h = c.constructor;
      if ((u.type !== h.getType() && Rf(58, h.name), X(c))) {
        const d = u.children;
        Array.isArray(d) || Rf(59, h.name);
      }
      return u;
    })(s);
  if (te(s)) {
    const c = s.__text;
    c.length > 0 ? (a.text = c) : (i = !1);
  }
  for (let c = 0; c < l.length; c++) {
    const u = l[c],
      h = fP(t, e, u, a.children);
    !i && X(n) && h && n.extractWithChild(u, e, "clone") && (i = !0);
  }
  if (i && !o) r.push(a);
  else if (Array.isArray(a.children))
    for (let c = 0; c < a.children.length; c++) {
      const u = a.children[c];
      r.push(u);
    }
  return i;
}
function LN(t, e) {
  const n = [],
    r = Qe().getChildren();
  for (let i = 0; i < r.length; i++) fP(t, e, r[i], n);
  return { namespace: t._config.namespace, nodes: n };
}
function NN(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n],
      i = rN(r);
    te(i) && uN(i), e.push(i);
  }
  return e;
}
let Gs = null;
async function ok(t, e) {
  if (Gs !== null) return !1;
  if (e !== null)
    return new Promise((l, a) => {
      t.update(() => {
        l(sk(t, e));
      });
    });
  const n = t.getRootElement(),
    r = t._window == null ? window.document : t._window.document,
    i = dP(t._window);
  if (n === null || i === null) return !1;
  const o = r.createElement("span");
  (o.style.cssText = "position: fixed; top: -1000px;"), o.append(r.createTextNode("#")), n.append(o);
  const s = new Range();
  return (
    s.setStart(o, 0),
    s.setEnd(o, 1),
    i.removeAllRanges(),
    i.addRange(s),
    new Promise((l, a) => {
      const c = t.registerCommand(
        Yp,
        (u) => (bo(u, ClipboardEvent) && (c(), Gs !== null && (window.clearTimeout(Gs), (Gs = null)), l(sk(t, u))), !0),
        Bn
      );
      (Gs = window.setTimeout(() => {
        c(), (Gs = null), l(!1);
      }, 50)),
        r.execCommand("copy"),
        o.remove();
    })
  );
}
function sk(t, e) {
  const n = dP(t._window);
  if (!n) return !1;
  const r = n.anchorNode,
    i = n.focusNode;
  if (r !== null && i !== null && !qu(t, r, i)) return !1;
  e.preventDefault();
  const o = e.clipboardData,
    s = ae();
  if (o === null || s === null) return !1;
  const l = IN(t),
    a = MN(t);
  let c = "";
  return (
    s !== null && (c = s.getTextContent()),
    l !== null && o.setData("text/html", l),
    a !== null && o.setData("application/x-lexical-editor", a),
    o.setData("text/plain", c),
    !0
  );
}
function lk(t, e) {
  if (document.caretRangeFromPoint !== void 0) {
    const n = document.caretRangeFromPoint(t, e);
    return n === null ? null : { node: n.startContainer, offset: n.startOffset };
  }
  if (document.caretPositionFromPoint !== "undefined") {
    const n = document.caretPositionFromPoint(t, e);
    return n === null ? null : { node: n.offsetNode, offset: n.offset };
  }
  return null;
}
const ka = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  QN = ka && "documentMode" in document ? document.documentMode : null,
  DN = !(!ka || !("InputEvent" in window) || QN) && "getTargetRanges" in new window.InputEvent("input"),
  FN = ka && /Version\/[\d.]+.*Safari/.test(navigator.userAgent),
  BN = ka && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
  VN = ka && /^(?=.*Chrome).*/i.test(navigator.userAgent),
  jN = ka && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !VN,
  ak = Ji();
let um = class pP extends Vr {
  static getType() {
    return "quote";
  }
  static clone(e) {
    return new pP(e.__key);
  }
  constructor(e) {
    super(e);
  }
  createDOM(e) {
    const n = document.createElement("blockquote");
    return Rr(n, e.theme.quote), n;
  }
  updateDOM(e, n) {
    return !1;
  }
  static importDOM() {
    return { blockquote: (e) => ({ conversion: ZN, priority: 0 }) };
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (n && $r(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(e) {
    const n = Ku();
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "quote" };
  }
  insertNewAfter(e, n) {
    const r = tt(),
      i = this.getDirection();
    return r.setDirection(i), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const e = tt();
    return this.getChildren().forEach((n) => e.append(n)), this.replace(e), !0;
  }
};
function Ku() {
  return Mn(new um());
}
function Q0(t) {
  return t instanceof um;
}
let eh = class mP extends Vr {
  static getType() {
    return "heading";
  }
  static clone(e) {
    return new mP(e.__tag, e.__key);
  }
  constructor(e, n) {
    super(n), (this.__tag = e);
  }
  getTag() {
    return this.__tag;
  }
  createDOM(e) {
    const n = this.__tag,
      r = document.createElement(n),
      i = e.theme.heading;
    if (i !== void 0) {
      const o = i[n];
      Rr(r, o);
    }
    return r;
  }
  updateDOM(e, n) {
    return !1;
  }
  static importDOM() {
    return {
      h1: (e) => ({ conversion: Js, priority: 0 }),
      h2: (e) => ({ conversion: Js, priority: 0 }),
      h3: (e) => ({ conversion: Js, priority: 0 }),
      h4: (e) => ({ conversion: Js, priority: 0 }),
      h5: (e) => ({ conversion: Js, priority: 0 }),
      h6: (e) => ({ conversion: Js, priority: 0 }),
      p: (e) => {
        const n = e.firstChild;
        return n !== null && ck(n) ? { conversion: () => ({ node: null }), priority: 3 } : null;
      },
      span: (e) => (ck(e) ? { conversion: (n) => ({ node: si("h1") }), priority: 3 } : null),
    };
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (n && $r(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(e) {
    const n = si(e.tag);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
  }
  insertNewAfter(e, n = !0) {
    const r = e ? e.anchor.offset : 0,
      i = r !== this.getTextContentSize() && e ? si(this.getTag()) : tt(),
      o = this.getDirection();
    if ((i.setDirection(o), this.insertAfter(i, n), r === 0 && !this.isEmpty() && e)) {
      const s = tt();
      s.select(), this.replace(s, !0);
    }
    return i;
  }
  collapseAtStart() {
    const e = this.isEmpty() ? tt() : si(this.getTag());
    return this.getChildren().forEach((n) => e.append(n)), this.replace(e), !0;
  }
  extractWithChild() {
    return !0;
  }
};
function ck(t) {
  return t.nodeName.toLowerCase() === "span" && t.style.fontSize === "26pt";
}
function Js(t) {
  const e = t.nodeName.toLowerCase();
  let n = null;
  return (
    (e !== "h1" && e !== "h2" && e !== "h3" && e !== "h4" && e !== "h5" && e !== "h6") ||
      ((n = si(e)), t.style !== null && n.setFormat(t.style.textAlign)),
    { node: n }
  );
}
function ZN(t) {
  const e = Ku();
  return t.style !== null && e.setFormat(t.style.textAlign), { node: e };
}
function si(t) {
  return Mn(new eh(t));
}
function hm(t) {
  return t instanceof eh;
}
function Wh(t) {
  let e = null;
  if ((bo(t, DragEvent) ? (e = t.dataTransfer) : bo(t, ClipboardEvent) && (e = t.clipboardData), e === null)) return [!1, [], !1];
  const n = e.types,
    r = n.includes("Files"),
    i = n.includes("text/html") || n.includes("text/plain");
  return [r, Array.from(e.files), i];
}
function uk(t) {
  const e = ae();
  if (!ee(e)) return !1;
  const n = new Set(),
    r = e.getNodes();
  for (let i = 0; i < r.length; i++) {
    const o = r[i],
      s = o.getKey();
    if (n.has(s)) continue;
    const l = Sa(o, (c) => X(c) && !c.isInline());
    if (l === null) continue;
    const a = l.getKey();
    l.canIndent() && !n.has(a) && (n.add(a), t(l));
  }
  return n.size > 0;
}
function Xh(t) {
  const e = pi(t);
  return ot(e);
}
function zN(t) {
  return Xn(
    t.registerCommand(
      Wp,
      (e) => {
        const n = ae();
        return !!Vt(n) && (n.clear(), !0);
      },
      0
    ),
    t.registerCommand(
      Os,
      (e) => {
        const n = ae();
        return !!ee(n) && (n.deleteCharacter(e), !0);
      },
      Ze
    ),
    t.registerCommand(
      Gc,
      (e) => {
        const n = ae();
        return !!ee(n) && (n.deleteWord(e), !0);
      },
      Ze
    ),
    t.registerCommand(
      Jc,
      (e) => {
        const n = ae();
        return !!ee(n) && (n.deleteLine(e), !0);
      },
      Ze
    ),
    t.registerCommand(
      Cl,
      (e) => {
        const n = ae();
        if (typeof e == "string") n !== null && n.insertText(e);
        else {
          if (n === null) return !1;
          const r = e.dataTransfer;
          if (r != null) rk(r, n, t);
          else if (ee(n)) {
            const i = e.data;
            return i && n.insertText(i), !0;
          }
        }
        return !0;
      },
      Ze
    ),
    t.registerCommand(
      g0,
      () => {
        const e = ae();
        return !!ee(e) && (e.removeText(), !0);
      },
      Ze
    ),
    t.registerCommand(
      Mi,
      (e) => {
        const n = ae();
        return !!ee(n) && (n.formatText(e), !0);
      },
      Ze
    ),
    t.registerCommand(
      lL,
      (e) => {
        const n = ae();
        if (!ee(n) && !Vt(n)) return !1;
        const r = n.getNodes();
        for (const i of r) {
          const o = Sa(i, (s) => X(s) && !s.isInline());
          o !== null && o.setFormat(e);
        }
        return !0;
      },
      Ze
    ),
    t.registerCommand(
      kl,
      (e) => {
        const n = ae();
        return !!ee(n) && (n.insertLineBreak(e), !0);
      },
      Ze
    ),
    t.registerCommand(
      Yc,
      () => {
        const e = ae();
        return !!ee(e) && (e.insertParagraph(), !0);
      },
      Ze
    ),
    t.registerCommand(hT, () => (ya([xa()]), !0), Ze),
    t.registerCommand(
      lb,
      () =>
        uk((e) => {
          const n = e.getIndent();
          e.setIndent(n + 1);
        }),
      Ze
    ),
    t.registerCommand(
      O0,
      () =>
        uk((e) => {
          const n = e.getIndent();
          n > 0 && e.setIndent(n - 1);
        }),
      Ze
    ),
    t.registerCommand(
      ib,
      (e) => {
        const n = ae();
        if (Vt(n) && !Xh(e.target)) {
          const r = n.getNodes();
          if (r.length > 0) return r[0].selectPrevious(), !0;
        } else if (ee(n)) {
          const r = Kc(n.focus, !0);
          if (!e.shiftKey && ot(r) && !r.isIsolated() && !r.isInline()) return r.selectPrevious(), e.preventDefault(), !0;
        }
        return !1;
      },
      Ze
    ),
    t.registerCommand(
      ob,
      (e) => {
        const n = ae();
        if (Vt(n)) {
          const r = n.getNodes();
          if (r.length > 0) return r[0].selectNext(0, 0), !0;
        } else if (ee(n)) {
          if (
            (function (i) {
              const o = i.focus;
              return o.key === "root" && o.offset === Qe().getChildrenSize();
            })(n)
          )
            return e.preventDefault(), !0;
          const r = Kc(n.focus, !1);
          if (!e.shiftKey && ot(r) && !r.isIsolated() && !r.isInline()) return r.selectNext(), e.preventDefault(), !0;
        }
        return !1;
      },
      Ze
    ),
    t.registerCommand(
      rb,
      (e) => {
        const n = ae();
        if (Vt(n)) {
          const r = n.getNodes();
          if (r.length > 0) return e.preventDefault(), r[0].selectPrevious(), !0;
        }
        if (!ee(n)) return !1;
        if (JS(n, !0)) {
          const r = e.shiftKey;
          return e.preventDefault(), KS(n, r, !0), !0;
        }
        return !1;
      },
      Ze
    ),
    t.registerCommand(
      cT,
      (e) => {
        const n = ae();
        if (Vt(n) && !Xh(e.target)) {
          const i = n.getNodes();
          if (i.length > 0) return e.preventDefault(), i[0].selectNext(0, 0), !0;
        }
        if (!ee(n)) return !1;
        const r = e.shiftKey;
        return !!JS(n, !1) && (e.preventDefault(), KS(n, r, !1), !0);
      },
      Ze
    ),
    t.registerCommand(
      Xu,
      (e) => {
        if (Xh(e.target)) return !1;
        const n = ae();
        if (!ee(n)) return !1;
        e.preventDefault();
        const { anchor: r } = n,
          i = r.getNode();
        return n.isCollapsed() && r.offset === 0 && !tn(i) && oP(i).getIndent() > 0
          ? t.dispatchCommand(O0, void 0)
          : t.dispatchCommand(Os, !0);
      },
      Ze
    ),
    t.registerCommand(
      Hp,
      (e) => {
        if (Xh(e.target)) return !1;
        const n = ae();
        return !!ee(n) && (e.preventDefault(), t.dispatchCommand(Os, !1));
      },
      Ze
    ),
    t.registerCommand(
      Wl,
      (e) => {
        const n = ae();
        if (!ee(n)) return !1;
        if (e !== null) {
          if ((BN || FN || jN) && DN) return !1;
          if ((e.preventDefault(), e.shiftKey)) return t.dispatchCommand(kl, !1);
        }
        return t.dispatchCommand(Yc, void 0);
      },
      Ze
    ),
    t.registerCommand(
      Uu,
      () => {
        const e = ae();
        return !!ee(e) && (t.blur(), !0);
      },
      Ze
    ),
    t.registerCommand(
      ab,
      (e) => {
        const [, n] = Wh(e);
        if (n.length > 0) {
          const i = lk(e.clientX, e.clientY);
          if (i !== null) {
            const { offset: o, node: s } = i,
              l = pi(s);
            if (l !== null) {
              const a = lm();
              if (te(l)) a.anchor.set(l.getKey(), o, "text"), a.focus.set(l.getKey(), o, "text");
              else {
                const u = l.getParentOrThrow().getKey(),
                  h = l.getIndexWithinParent() + 1;
                a.anchor.set(u, h, "element"), a.focus.set(u, h, "element");
              }
              const c = wb(a);
              pn(c);
            }
            t.dispatchCommand(ak, n);
          }
          return e.preventDefault(), !0;
        }
        const r = ae();
        return !!ee(r);
      },
      Ze
    ),
    t.registerCommand(
      qp,
      (e) => {
        const [n] = Wh(e),
          r = ae();
        return !(n && !ee(r));
      },
      Ze
    ),
    t.registerCommand(
      cb,
      (e) => {
        const [n] = Wh(e),
          r = ae();
        if (n && !ee(r)) return !1;
        const i = lk(e.clientX, e.clientY);
        if (i !== null) {
          const o = pi(i.node);
          ot(o) && e.preventDefault();
        }
        return !0;
      },
      Ze
    ),
    t.registerCommand(v0, () => (ML(), !0), Ze),
    t.registerCommand(Yp, (e) => (ok(t, bo(e, ClipboardEvent) ? e : null), !0), Ze),
    t.registerCommand(
      ub,
      (e) => (
        (async function (n, r) {
          await ok(r, bo(n, ClipboardEvent) ? n : null),
            r.update(() => {
              const i = ae();
              ee(i) ? i.removeText() : Vt(i) && i.getNodes().forEach((o) => o.remove());
            });
        })(e, t),
        !0
      ),
      Ze
    ),
    t.registerCommand(
      Wu,
      (e) => {
        const [, n, r] = Wh(e);
        return n.length > 0 && !r
          ? (t.dispatchCommand(ak, n), !0)
          : Sb(e.target)
          ? !1
          : ae() !== null &&
            ((function (i, o) {
              i.preventDefault(),
                o.update(
                  () => {
                    const s = ae(),
                      l = bo(i, InputEvent) || bo(i, KeyboardEvent) ? null : i.clipboardData;
                    l != null && s !== null && rk(l, s, o);
                  },
                  { tag: "paste" }
                );
            })(e, t),
            !0);
      },
      Ze
    )
  );
}
function gr(t, e, n, r) {
  const i = t.length;
  let o = 0,
    s;
  if ((e < 0 ? (e = -e > i ? 0 : i + e) : (e = e > i ? i : e), (n = n > 0 ? n : 0), r.length < 1e4))
    (s = Array.from(r)), s.unshift(e, n), t.splice(...s);
  else for (n && t.splice(e, n); o < r.length; ) (s = r.slice(o, o + 1e4)), s.unshift(e, 0), t.splice(...s), (o += 1e4), (e += 1e4);
}
function hr(t, e) {
  return t.length > 0 ? (gr(t, t.length, 0, e), t) : e;
}
const tr = Uo(/[A-Za-z]/),
  rr = Uo(/[\dA-Za-z]/),
  WN = Uo(/[#-'*+\--9=?A-Z^-~]/);
function D0(t) {
  return t !== null && (t < 32 || t === 127);
}
const F0 = Uo(/\d/),
  XN = Uo(/[\dA-Fa-f]/),
  UN = Uo(/[!-/:-@[-`{-~]/);
function de(t) {
  return t !== null && t < -2;
}
function Ke(t) {
  return t !== null && (t < 0 || t === 32);
}
function Pe(t) {
  return t === -2 || t === -1 || t === 32;
}
const HN = Uo(/\p{P}|\p{S}/u),
  Ai = Uo(/\s/);
function Uo(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function If(t) {
  if (t === null || Ke(t) || Ai(t)) return 1;
  if (HN(t)) return 2;
}
function dm(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const o = t[i].resolveAll;
    o && !r.includes(o) && ((e = o(e, n)), r.push(o));
  }
  return e;
}
function qN(t) {
  let n = (t || {}).singleTilde;
  const r = { name: "strikethrough", tokenize: o, resolveAll: i };
  return n == null && (n = !0), { text: { 126: r }, insideSpan: { null: [r] }, attentionMarkers: { null: [126] } };
  function i(s, l) {
    let a = -1;
    for (; ++a < s.length; )
      if (s[a][0] === "enter" && s[a][1].type === "strikethroughSequenceTemporary" && s[a][1]._close) {
        let c = a;
        for (; c--; )
          if (
            s[c][0] === "exit" &&
            s[c][1].type === "strikethroughSequenceTemporary" &&
            s[c][1]._open &&
            s[a][1].end.offset - s[a][1].start.offset === s[c][1].end.offset - s[c][1].start.offset
          ) {
            (s[a][1].type = "strikethroughSequence"), (s[c][1].type = "strikethroughSequence");
            const u = { type: "strikethrough", start: Object.assign({}, s[c][1].start), end: Object.assign({}, s[a][1].end) },
              h = { type: "strikethroughText", start: Object.assign({}, s[c][1].end), end: Object.assign({}, s[a][1].start) },
              d = [
                ["enter", u, l],
                ["enter", s[c][1], l],
                ["exit", s[c][1], l],
                ["enter", h, l],
              ],
              f = l.parser.constructs.insideSpan.null;
            f && gr(d, d.length, 0, dm(f, s.slice(c + 1, a), l)),
              gr(d, d.length, 0, [
                ["exit", h, l],
                ["enter", s[a][1], l],
                ["exit", s[a][1], l],
                ["exit", u, l],
              ]),
              gr(s, c - 1, a - c + 3, d),
              (a = c + d.length - 2);
            break;
          }
      }
    for (a = -1; ++a < s.length; ) s[a][1].type === "strikethroughSequenceTemporary" && (s[a][1].type = "data");
    return s;
  }
  function o(s, l, a) {
    const c = this.previous,
      u = this.events;
    let h = 0;
    return d;
    function d(p) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? a(p) : (s.enter("strikethroughSequenceTemporary"), f(p));
    }
    function f(p) {
      const m = If(c);
      if (p === 126) return h > 1 ? a(p) : (s.consume(p), h++, f);
      if (h < 2 && !n) return a(p);
      const O = s.exit("strikethroughSequenceTemporary"),
        v = If(p);
      return (O._open = !v || (v === 2 && !!m)), (O._close = !m || (m === 2 && !!v)), l(p);
    }
  }
}
const YN = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"];
gP.peek = tQ;
function GN() {
  return { canContainEols: ["delete"], enter: { strikethrough: KN }, exit: { strikethrough: eQ } };
}
function JN() {
  return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: YN }], handlers: { delete: gP } };
}
function KN(t) {
  this.enter({ type: "delete", children: [] }, t);
}
function eQ(t) {
  this.exit(t);
}
function gP(t, e, n, r) {
  const i = n.createTracker(r),
    o = n.enter("strikethrough");
  let s = i.move("~~");
  return (s += n.containerPhrasing(t, { ...i.current(), before: s, after: "~" })), (s += i.move("~~")), o(), s;
}
function tQ() {
  return "~";
}
function hk(t, e) {
  const n = String(t);
  if (typeof e != "string") throw new TypeError("Expected character");
  let r = 0,
    i = n.indexOf(e);
  for (; i !== -1; ) r++, (i = n.indexOf(e, i + e.length));
  return r;
}
const nQ = [
    "AElig",
    "AMP",
    "Aacute",
    "Acirc",
    "Agrave",
    "Aring",
    "Atilde",
    "Auml",
    "COPY",
    "Ccedil",
    "ETH",
    "Eacute",
    "Ecirc",
    "Egrave",
    "Euml",
    "GT",
    "Iacute",
    "Icirc",
    "Igrave",
    "Iuml",
    "LT",
    "Ntilde",
    "Oacute",
    "Ocirc",
    "Ograve",
    "Oslash",
    "Otilde",
    "Ouml",
    "QUOT",
    "REG",
    "THORN",
    "Uacute",
    "Ucirc",
    "Ugrave",
    "Uuml",
    "Yacute",
    "aacute",
    "acirc",
    "acute",
    "aelig",
    "agrave",
    "amp",
    "aring",
    "atilde",
    "auml",
    "brvbar",
    "ccedil",
    "cedil",
    "cent",
    "copy",
    "curren",
    "deg",
    "divide",
    "eacute",
    "ecirc",
    "egrave",
    "eth",
    "euml",
    "frac12",
    "frac14",
    "frac34",
    "gt",
    "iacute",
    "icirc",
    "iexcl",
    "igrave",
    "iquest",
    "iuml",
    "laquo",
    "lt",
    "macr",
    "micro",
    "middot",
    "nbsp",
    "not",
    "ntilde",
    "oacute",
    "ocirc",
    "ograve",
    "ordf",
    "ordm",
    "oslash",
    "otilde",
    "ouml",
    "para",
    "plusmn",
    "pound",
    "quot",
    "raquo",
    "reg",
    "sect",
    "shy",
    "sup1",
    "sup2",
    "sup3",
    "szlig",
    "thorn",
    "times",
    "uacute",
    "ucirc",
    "ugrave",
    "uml",
    "uuml",
    "yacute",
    "yen",
    "yuml",
  ],
  dk = {
    0: "�",
    128: "€",
    130: "‚",
    131: "ƒ",
    132: "„",
    133: "…",
    134: "†",
    135: "‡",
    136: "ˆ",
    137: "‰",
    138: "Š",
    139: "‹",
    140: "Œ",
    142: "Ž",
    145: "‘",
    146: "’",
    147: "“",
    148: "”",
    149: "•",
    150: "–",
    151: "—",
    152: "˜",
    153: "™",
    154: "š",
    155: "›",
    156: "œ",
    158: "ž",
    159: "Ÿ",
  };
function OP(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 48 && e <= 57;
}
function rQ(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return (e >= 97 && e <= 102) || (e >= 65 && e <= 70) || (e >= 48 && e <= 57);
}
function iQ(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
}
function fk(t) {
  return iQ(t) || OP(t);
}
const pk = document.createElement("i");
function nu(t) {
  const e = "&" + t + ";";
  pk.innerHTML = e;
  const n = pk.textContent;
  return (n.charCodeAt(n.length - 1) === 59 && t !== "semi") || n === e ? !1 : n;
}
const Ks = String.fromCharCode,
  oQ = [
    "",
    "Named character references must be terminated by a semicolon",
    "Numeric character references must be terminated by a semicolon",
    "Named character references cannot be empty",
    "Numeric character references cannot be empty",
    "Named character references must be known",
    "Numeric character references cannot be disallowed",
    "Numeric character references cannot be outside the permissible Unicode range",
  ];
function fm(t, e = {}) {
  const n = typeof e.additional == "string" ? e.additional.charCodeAt(0) : e.additional,
    r = [];
  let i = 0,
    o = -1,
    s = "",
    l,
    a;
  e.position && ("start" in e.position || "indent" in e.position ? ((a = e.position.indent), (l = e.position.start)) : (l = e.position));
  let c = (l ? l.line : 0) || 1,
    u = (l ? l.column : 0) || 1,
    h = f(),
    d;
  for (i--; ++i <= t.length; )
    if ((d === 10 && (u = (a ? a[o] : 0) || 1), (d = t.charCodeAt(i)), d === 38)) {
      const O = t.charCodeAt(i + 1);
      if (O === 9 || O === 10 || O === 12 || O === 32 || O === 38 || O === 60 || Number.isNaN(O) || (n && O === n)) {
        (s += Ks(d)), u++;
        continue;
      }
      const v = i + 1;
      let g = v,
        b = v,
        x;
      if (O === 35) {
        b = ++g;
        const L = t.charCodeAt(b);
        L === 88 || L === 120 ? ((x = "hexadecimal"), (b = ++g)) : (x = "decimal");
      } else x = "named";
      let k = "",
        w = "",
        y = "";
      const C = x === "named" ? fk : x === "decimal" ? OP : rQ;
      for (b--; ++b <= t.length; ) {
        const L = t.charCodeAt(b);
        if (!C(L)) break;
        (y += Ks(L)), x === "named" && nQ.includes(y) && ((k = y), (w = nu(y)));
      }
      let P = t.charCodeAt(b) === 59;
      if (P) {
        b++;
        const L = x === "named" ? nu(y) : !1;
        L && ((k = y), (w = L));
      }
      let E = 1 + b - v,
        N = "";
      if (!(!P && e.nonTerminated === !1))
        if (!y) x !== "named" && p(4, E);
        else if (x === "named") {
          if (P && !w) p(5, 1);
          else if ((k !== y && ((b = g + k.length), (E = 1 + b - g), (P = !1)), !P)) {
            const L = k ? 1 : 3;
            if (e.attribute) {
              const D = t.charCodeAt(b);
              D === 61 ? (p(L, E), (w = "")) : fk(D) ? (w = "") : p(L, E);
            } else p(L, E);
          }
          N = w;
        } else {
          P || p(2, E);
          let L = Number.parseInt(y, x === "hexadecimal" ? 16 : 10);
          if (sQ(L)) p(7, E), (N = Ks(65533));
          else if (L in dk) p(6, E), (N = dk[L]);
          else {
            let D = "";
            lQ(L) && p(6, E), L > 65535 && ((L -= 65536), (D += Ks((L >>> 10) | 55296)), (L = 56320 | (L & 1023))), (N = D + Ks(L));
          }
        }
      if (N) {
        m(), (h = f()), (i = b - 1), (u += b - v + 1), r.push(N);
        const L = f();
        L.offset++, e.reference && e.reference.call(e.referenceContext, N, { start: h, end: L }, t.slice(v - 1, b)), (h = L);
      } else (y = t.slice(v - 1, b)), (s += y), (u += y.length), (i = b - 1);
    } else d === 10 && (c++, o++, (u = 0)), Number.isNaN(d) ? m() : ((s += Ks(d)), u++);
  return r.join("");
  function f() {
    return { line: c, column: u, offset: i + ((l ? l.offset : 0) || 0) };
  }
  function p(O, v) {
    let g;
    e.warning && ((g = f()), (g.column += v), (g.offset += v), e.warning.call(e.warningContext, oQ[O], g, O));
  }
  function m() {
    s && (r.push(s), e.text && e.text.call(e.textContext, s, { start: h, end: f() }), (s = ""));
  }
}
function sQ(t) {
  return (t >= 55296 && t <= 57343) || t > 1114111;
}
function lQ(t) {
  return (
    (t >= 1 && t <= 8) ||
    t === 11 ||
    (t >= 13 && t <= 31) ||
    (t >= 127 && t <= 159) ||
    (t >= 64976 && t <= 65007) ||
    (t & 65535) === 65535 ||
    (t & 65535) === 65534
  );
}
const aQ = /["&'<>`]/g,
  cQ = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  uQ = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
  hQ = /[|\\{}()[\]^$+*?.]/g,
  mk = new WeakMap();
function dQ(t, e) {
  if (((t = t.replace(e.subset ? fQ(e.subset) : aQ, r)), e.subset || e.escapeOnly)) return t;
  return t.replace(cQ, n).replace(uQ, r);
  function n(i, o, s) {
    return e.format((i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536, s.charCodeAt(o + 2), e);
  }
  function r(i, o, s) {
    return e.format(i.charCodeAt(0), s.charCodeAt(o + 1), e);
  }
}
function fQ(t) {
  let e = mk.get(t);
  return e || ((e = pQ(t)), mk.set(t, e)), e;
}
function pQ(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; ) e.push(t[n].replace(hQ, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
function mQ(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function vP(t, e) {
  return dQ(t, Object.assign({ format: mQ }, e));
}
function Li(t) {
  return !t || typeof t != "object"
    ? ""
    : "position" in t || "type" in t
    ? gk(t.position)
    : "start" in t || "end" in t
    ? gk(t)
    : "line" in t || "column" in t
    ? B0(t)
    : "";
}
function B0(t) {
  return Ok(t && t.line) + ":" + Ok(t && t.column);
}
function gk(t) {
  return B0(t && t.start) + "-" + B0(t && t.end);
}
function Ok(t) {
  return t && typeof t == "number" ? t : 1;
}
class rt extends Error {
  constructor(e, n, r) {
    super(), typeof n == "string" && ((r = n), (n = void 0));
    let i = "",
      o = {},
      s = !1;
    if (
      (n &&
        ("line" in n && "column" in n
          ? (o = { place: n })
          : "start" in n && "end" in n
          ? (o = { place: n })
          : "type" in n
          ? (o = { ancestors: [n], place: n.position })
          : (o = { ...n })),
      typeof e == "string" ? (i = e) : !o.cause && e && ((s = !0), (i = e.message), (o.cause = e)),
      !o.ruleId && !o.source && typeof r == "string")
    ) {
      const a = r.indexOf(":");
      a === -1 ? (o.ruleId = r) : ((o.source = r.slice(0, a)), (o.ruleId = r.slice(a + 1)));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const a = o.ancestors[o.ancestors.length - 1];
      a && (o.place = a.position);
    }
    const l = o.place && "start" in o.place ? o.place.start : o.place;
    (this.ancestors = o.ancestors || void 0),
      (this.cause = o.cause || void 0),
      (this.column = l ? l.column : void 0),
      (this.fatal = void 0),
      this.file,
      (this.message = i),
      (this.line = l ? l.line : void 0),
      (this.name = Li(o.place) || "1:1"),
      (this.place = o.place || void 0),
      (this.reason = this.message),
      (this.ruleId = o.ruleId || void 0),
      (this.source = o.source || void 0),
      (this.stack = s && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : ""),
      this.actual,
      this.expected,
      this.note,
      this.url;
  }
}
rt.prototype.file = "";
rt.prototype.name = "";
rt.prototype.reason = "";
rt.prototype.message = "";
rt.prototype.stack = "";
rt.prototype.column = void 0;
rt.prototype.line = void 0;
rt.prototype.ancestors = void 0;
rt.prototype.cause = void 0;
rt.prototype.fatal = void 0;
rt.prototype.place = void 0;
rt.prototype.ruleId = void 0;
rt.prototype.source = void 0;
const bP = "  ";
function xP() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: r,
      mdxJsxFlowTagClosingMarker: i,
      mdxJsxFlowTagAttribute: h,
      mdxJsxFlowTagExpressionAttribute: d,
      mdxJsxFlowTagAttributeValueLiteral: t,
      mdxJsxFlowTagAttributeValueExpression: t,
      mdxJsxFlowTagSelfClosingMarker: s,
      mdxJsxTextTag: r,
      mdxJsxTextTagClosingMarker: i,
      mdxJsxTextTagAttribute: h,
      mdxJsxTextTagExpressionAttribute: d,
      mdxJsxTextTagAttributeValueLiteral: t,
      mdxJsxTextTagAttributeValueExpression: t,
      mdxJsxTextTagSelfClosingMarker: s,
    },
    exit: {
      mdxJsxFlowTagClosingMarker: l,
      mdxJsxFlowTagNamePrimary: a,
      mdxJsxFlowTagNameMember: c,
      mdxJsxFlowTagNameLocal: u,
      mdxJsxFlowTagExpressionAttribute: f,
      mdxJsxFlowTagExpressionAttributeValue: n,
      mdxJsxFlowTagAttributeNamePrimary: p,
      mdxJsxFlowTagAttributeNameLocal: m,
      mdxJsxFlowTagAttributeValueLiteral: O,
      mdxJsxFlowTagAttributeValueLiteralValue: n,
      mdxJsxFlowTagAttributeValueExpression: v,
      mdxJsxFlowTagAttributeValueExpressionValue: n,
      mdxJsxFlowTagSelfClosingMarker: g,
      mdxJsxFlowTag: b,
      mdxJsxTextTagClosingMarker: l,
      mdxJsxTextTagNamePrimary: a,
      mdxJsxTextTagNameMember: c,
      mdxJsxTextTagNameLocal: u,
      mdxJsxTextTagExpressionAttribute: f,
      mdxJsxTextTagExpressionAttributeValue: n,
      mdxJsxTextTagAttributeNamePrimary: p,
      mdxJsxTextTagAttributeNameLocal: m,
      mdxJsxTextTagAttributeValueLiteral: O,
      mdxJsxTextTagAttributeValueLiteralValue: n,
      mdxJsxTextTagAttributeValueExpression: v,
      mdxJsxTextTagAttributeValueExpressionValue: n,
      mdxJsxTextTagSelfClosingMarker: g,
      mdxJsxTextTag: b,
    },
  };
  function t() {
    this.buffer();
  }
  function e(y) {
    return { line: y.line, column: y.column, offset: y.offset };
  }
  function n(y) {
    this.config.enter.data.call(this, y), this.config.exit.data.call(this, y);
  }
  function r(y) {
    const C = { name: void 0, attributes: [], close: !1, selfClosing: !1, start: y.start, end: y.end };
    this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), (this.data.mdxJsxTag = C), this.buffer();
  }
  function i(y) {
    if (this.data.mdxJsxTagStack.length === 0)
      throw new rt(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
  }
  function o(y) {
    if (this.data.mdxJsxTag.close)
      throw new rt(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
  }
  function s(y) {
    if (this.data.mdxJsxTag.close)
      throw new rt(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
  }
  function l() {
    const y = this.data.mdxJsxTag;
    y.close = !0;
  }
  function a(y) {
    const C = this.data.mdxJsxTag;
    C.name = this.sliceSerialize(y);
  }
  function c(y) {
    const C = this.data.mdxJsxTag;
    C.name += "." + this.sliceSerialize(y);
  }
  function u(y) {
    const C = this.data.mdxJsxTag;
    C.name += ":" + this.sliceSerialize(y);
  }
  function h(y) {
    const C = this.data.mdxJsxTag;
    o.call(this, y), C.attributes.push({ type: "mdxJsxAttribute", name: "", value: null, position: { start: e(y.start), end: void 0 } });
  }
  function d(y) {
    const C = this.data.mdxJsxTag;
    o.call(this, y), C.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" }), this.buffer();
  }
  function f(y) {
    const C = this.data.mdxJsxTag,
      P = C.attributes[C.attributes.length - 1];
    P.type;
    const E = y.estree;
    (P.value = this.resume()), E && (P.data = { estree: E });
  }
  function p(y) {
    const C = this.data.mdxJsxTag,
      P = C.attributes[C.attributes.length - 1];
    P.type, (P.name = this.sliceSerialize(y)), P.position, (P.position.end = e(y.end));
  }
  function m(y) {
    const C = this.data.mdxJsxTag,
      P = C.attributes[C.attributes.length - 1];
    P.type, (P.name += ":" + this.sliceSerialize(y)), P.position, (P.position.end = e(y.end));
  }
  function O(y) {
    const C = this.data.mdxJsxTag,
      P = C.attributes[C.attributes.length - 1];
    (P.value = fm(this.resume(), { nonTerminated: !1 })), P.position, (P.position.end = e(y.end));
  }
  function v(y) {
    const C = this.data.mdxJsxTag,
      P = C.attributes[C.attributes.length - 1];
    P.type;
    const E = { type: "mdxJsxAttributeValueExpression", value: this.resume() },
      N = y.estree;
    N && (E.data = { estree: N }), (P.value = E), P.position, (P.position.end = e(y.end));
  }
  function g() {
    const y = this.data.mdxJsxTag;
    y.selfClosing = !0;
  }
  function b(y) {
    const C = this.data.mdxJsxTag,
      P = this.data.mdxJsxTagStack,
      E = P[P.length - 1];
    if (C.close && E.name !== C.name)
      throw new rt(
        "Unexpected closing tag `" + w(C) + "`, expected corresponding closing tag for `" + w(E) + "` (" + Li(E) + ")",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    this.resume(),
      C.close
        ? P.pop()
        : this.enter(
            {
              type: y.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
              name: C.name || null,
              attributes: C.attributes,
              children: [],
            },
            y,
            x
          ),
      C.selfClosing || C.close ? this.exit(y, k) : P.push(C);
  }
  function x(y, C) {
    const P = this.data.mdxJsxTagStack,
      E = P[P.length - 1],
      N = y ? " before the end of `" + y.type + "`" : "",
      L = y ? { start: y.start, end: y.end } : void 0;
    throw new rt(
      "Expected a closing tag for `" + w(E) + "` (" + Li({ start: C.start, end: C.end }) + ")" + N,
      L,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function k(y, C) {
    const P = this.data.mdxJsxTag;
    throw new rt(
      "Expected the closing tag `" +
        w(P) +
        "` either after the end of `" +
        C.type +
        "` (" +
        Li(C.end) +
        ") or another opening tag after the start of `" +
        C.type +
        "` (" +
        Li(C.start) +
        ")",
      { start: y.start, end: y.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function w(y) {
    return "<" + (y.close ? "/" : "") + (y.name || "") + ">";
  }
}
function yP(t) {
  const e = t || {},
    n = e.quote || '"',
    r = e.quoteSmart || !1,
    i = e.tightSelfClosing || !1,
    o = e.printWidth || Number.POSITIVE_INFINITY,
    s = n === '"' ? "'" : '"';
  if (n !== '"' && n !== "'")
    throw new Error("Cannot serialize attribute values with `" + n + "` for `options.quote`, expected `\"`, or `'`");
  return (
    (l.peek = OQ),
    {
      handlers: { mdxJsxFlowElement: l, mdxJsxTextElement: l },
      unsafe: [
        { character: "<", inConstruct: ["phrasing"] },
        { atBreak: !0, character: "<" },
      ],
      fences: !0,
      resourceLink: !0,
    }
  );
  function l(a, c, u, h) {
    const d = a.type === "mdxJsxFlowElement",
      f = a.name ? !a.children || a.children.length === 0 : !1,
      p = wP(u),
      m = SP(p),
      O = u.createTracker(h),
      v = u.createTracker(h),
      g = [],
      b = (d ? m : "") + "<" + (a.name || ""),
      x = u.enter(a.type);
    if ((O.move(b), v.move(b), a.attributes && a.attributes.length > 0)) {
      if (!a.name) throw new Error("Cannot serialize fragment w/ attributes");
      let P = -1;
      for (; ++P < a.attributes.length; ) {
        const E = a.attributes[P];
        let N;
        if (E.type === "mdxJsxExpressionAttribute") N = "{" + (E.value || "") + "}";
        else {
          if (!E.name) throw new Error("Cannot serialize attribute w/o name");
          const L = E.value,
            D = E.name;
          let Q = "";
          if (L != null)
            if (typeof L == "object") Q = "{" + (L.value || "") + "}";
            else {
              const R = r && hk(L, n) > hk(L, s) ? s : n;
              Q = R + vP(L, { subset: [R] }) + R;
            }
          N = D + (Q ? "=" : "") + Q;
        }
        g.push(N);
      }
    }
    let k = !1;
    const w = g.join(" ");
    d && (/\r?\n|\r/.test(w) || O.current().now.column + w.length + (f ? (i ? 2 : 3) : 1) > o) && (k = !0);
    let y = O,
      C = b;
    if (k) {
      y = v;
      let P = -1;
      for (; ++P < g.length; ) g[P] = m + bP + g[P];
      C += y.move(
        `
` +
          g.join(`
`) +
          `
` +
          m
      );
    } else w && (C += y.move(" " + w));
    return (
      f && (C += y.move((i || k ? "" : " ") + "/")),
      (C += y.move(">")),
      a.children &&
        a.children.length > 0 &&
        (a.type === "mdxJsxTextElement"
          ? (C += y.move(u.containerPhrasing(a, { ...y.current(), before: ">", after: "<" })))
          : (y.shift(2),
            (C += y.move(`
`)),
            (C += y.move(gQ(a, u, y.current()))),
            (C += y.move(`
`)))),
      f || (C += y.move((d ? m : "") + "</" + (a.name || "") + ">")),
      x(),
      C
    );
  }
}
function gQ(t, e, n) {
  const r = e.indexStack,
    i = t.children,
    o = e.createTracker(n),
    s = SP(wP(e)),
    l = [];
  let a = -1;
  for (r.push(-1); ++a < i.length; ) {
    const c = i[a];
    r[r.length - 1] = a;
    const u = {
        before: `
`,
        after: `
`,
        ...o.current(),
      },
      h = e.handle(c, t, e, u),
      d =
        c.type === "mdxJsxFlowElement"
          ? h
          : e.indentLines(h, function (f, p, m) {
              return (m ? "" : s) + f;
            });
    l.push(o.move(d)),
      c.type !== "list" && (e.bulletLastUsed = void 0),
      a < i.length - 1 &&
        l.push(
          o.move(`

`)
        );
  }
  return r.pop(), l.join("");
}
function wP(t) {
  let e = 0,
    n = t.stack.length;
  for (; --n > -1; ) {
    const r = t.stack[n];
    if (r === "blockquote" || r === "listItem") break;
    r === "mdxJsxFlowElement" && e++;
  }
  return e;
}
function SP(t) {
  return bP.repeat(t);
}
function OQ() {
  return "<";
}
const vQ = /[$_\p{ID_Start}]/u,
  bQ = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u,
  xQ = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u,
  yQ = {};
function wr(t) {
  return t ? vQ.test(String.fromCodePoint(t)) : !1;
}
function Ka(t, e) {
  const r = (e || yQ).jsx ? xQ : bQ;
  return t ? r.test(String.fromCodePoint(t)) : !1;
}
const wQ = {}.hasOwnProperty,
  SQ = Symbol("continue"),
  Lg = Symbol("exit"),
  kQ = Symbol("skip");
function CQ(t, e) {
  let n, r;
  typeof e == "function" ? (n = e) : e && typeof e == "object" && (e.enter && (n = e.enter), e.leave && (r = e.leave)),
    i(t, void 0, void 0, [])();
  function i(o, s, l, a) {
    return Ng(o) && (c.displayName = "node (" + o.type + ")"), c;
    function c() {
      const u = n ? vk(n(o, s, l, a)) : [];
      if (u[0] === Lg) return u;
      if (u[0] !== kQ) {
        let h;
        for (h in o)
          if (wQ.call(o, h) && o[h] && typeof o[h] == "object" && h !== "data" && h !== "position") {
            const d = a.concat(o),
              f = o[h];
            if (Array.isArray(f)) {
              const p = f;
              let m = 0;
              for (; m > -1 && m < p.length; ) {
                const O = p[m];
                if (Ng(O)) {
                  const v = i(O, h, m, d)();
                  if (v[0] === Lg) return v;
                  m = typeof v[1] == "number" ? v[1] : m + 1;
                } else m++;
              }
            } else if (Ng(f)) {
              const p = i(f, h, void 0, d)();
              if (p[0] === Lg) return p;
            }
          }
      }
      return r ? vk(r(o, s, l, a)) : u;
    }
  }
}
function vk(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [SQ, t] : [t];
}
function Ng(t) {
  return !!(t && typeof t == "object" && "type" in t && typeof t.type == "string" && t.type.length > 0);
}
function kP(t, e) {
  const n = e.prefix || "",
    r = e.suffix || "",
    i = Object.assign({}, e.acornOptions),
    o = [],
    s = [],
    l = i.onComment,
    a = i.onToken;
  let c = !1,
    u,
    h;
  const d = Object.assign({}, i, { onComment: o, preserveParens: !0 });
  a && (d.onToken = s);
  const f = _Q(t, e.tokenTypes),
    p = f.value,
    m = n + p + r,
    O = e.expression && bk(p);
  if (O && !e.allowEmpty)
    throw new rt("Unexpected empty expression", {
      place: g(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression",
    });
  try {
    u = e.expression && !O ? e.acorn.parseExpressionAt(m, 0, d) : e.acorn.parse(m, d);
  } catch (b) {
    const x = b,
      k = g(x.pos);
    (x.message = String(x.message).replace(/ \(\d+:\d+\)$/, "")),
      (x.pos = k.offset),
      (x.loc = { line: k.line, column: k.column - 1 }),
      (h = x),
      (c = x.raisedAt >= n.length + p.length || x.message === "Unterminated comment");
  }
  if (u && e.expression && !O)
    if (bk(m.slice(u.end, m.length - r.length)))
      u = {
        type: "Program",
        start: 0,
        end: n.length + p.length,
        body: [{ type: "ExpressionStatement", expression: u, start: 0, end: n.length + p.length }],
        sourceType: "module",
        comments: [],
      };
    else {
      const b = g(u.end),
        x = new Error("Unexpected content after expression");
      (x.pos = b.offset), (x.loc = { line: b.line, column: b.column - 1 }), (h = x), (u = void 0);
    }
  if (u) {
    if (
      ((u.comments = o),
      CQ(u, function (b, x, k, w) {
        let y = w[w.length - 1],
          C = x;
        b.type === "ParenthesizedExpression" && y && C && (typeof k == "number" && ((y = y[C]), (C = k)), (y[C] = b.expression)), v(b);
      }),
      Array.isArray(l))
    )
      l.push(...o);
    else if (typeof l == "function") for (const b of o) l(b.type === "Block", b.value, b.start, b.end, b.loc.start, b.loc.end);
    for (const b of s) b.end <= n.length || b.start - n.length >= p.length || (v(b), Array.isArray(a) ? a.push(b) : a(b));
  }
  return { estree: u, error: h, swallow: c };
  function v(b) {
    const x = g(b.start),
      k = g(b.end);
    (b.start = x.offset),
      (b.end = k.offset),
      (b.loc = {
        start: { line: x.line, column: x.column - 1, offset: x.offset },
        end: { line: k.line, column: k.column - 1, offset: k.offset },
      }),
      (b.range = [b.start, b.end]);
  }
  function g(b) {
    let x = b - n.length;
    x < 0 ? (x = 0) : x > p.length && (x = p.length);
    let k = EQ(f.stops, x);
    return k || (k = { line: e.start.line, column: e.start.column, offset: e.start.offset }), k;
  }
}
function bk(t) {
  return /^\s*$/.test(t.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
}
function _Q(t, e) {
  const n = { value: "", stops: [] };
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r];
    if (i[0] === "enter") {
      const o = i[1].type;
      if (o === "lineEnding" || e.includes(o)) {
        const s = i[2].sliceStream(i[1]);
        for (; s.length > 0 && s[0] === -1; ) s.shift();
        const l = TQ(s);
        n.stops.push([n.value.length, i[1].start]), (n.value += l), n.stops.push([n.value.length, i[1].end]);
      }
    }
  }
  return n;
}
function EQ(t, e) {
  let n = 0;
  for (; n < t.length && t[n][0] <= e; ) n += 1;
  if (n === 0) return;
  const [r, i] = t[n - 1],
    o = e - r;
  return { line: i.line, column: i.column + o, offset: i.offset + o };
}
function TQ(t) {
  let e = -1;
  const n = [];
  let r;
  for (; ++e < t.length; ) {
    const i = t[e];
    let o;
    if (typeof i == "string") o = i;
    else
      switch (i) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = "	";
          break;
        }
        case -1: {
          if (r) continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(i);
      }
    (r = i === -2), n.push(o);
  }
  return n.join("");
}
function Xd(t) {
  const e = t || {},
    n = e.loc || {},
    r = e.range || [void 0, void 0],
    i = xk(n.start, r[0] || e.start),
    o = xk(n.end, r[1] || e.end);
  if (i && o) return { start: i, end: o };
}
function xk(t, e) {
  if (t && typeof t == "object") {
    const n = "line" in t ? Qg(t.line) : void 0,
      r = "column" in t ? Qg(t.column) : void 0;
    if (n && r !== void 0) return { line: n, column: r + 1, offset: Qg(e) };
  }
}
function Qg(t) {
  return typeof t == "number" && t > -1 ? t : void 0;
}
const gl = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression",
  PQ = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-",
  AQ = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed",
  yk = "#unexpected-type-in-code-expected-an-object-spread-spread",
  $Q = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported",
  RQ = "#could-not-parse-expression-with-acorn";
function Mf(t, e, n, r, i, o, s, l, a, c, u) {
  const h = this,
    d = this.events.length + 3;
  let f = 0,
    p,
    m;
  return O;
  function O(x) {
    return t.enter(n), t.enter(r), t.consume(x), t.exit(r), (p = h.now()), v;
  }
  function v(x) {
    if (x === null) {
      if (m) throw m;
      const k = new rt("Unexpected end of file in expression, expected a corresponding closing brace for `{`", {
        place: h.now(),
        ruleId: "unexpected-eof",
        source: "micromark-extension-mdx-expression",
      });
      throw ((k.url = gl + PQ), k);
    }
    if (de(x)) return t.enter("lineEnding"), t.consume(x), t.exit("lineEnding"), b;
    if (x === 125 && f === 0) {
      const k = o ? IQ.call(h, o, s, i, d, p, c || !1, a || !1) : { type: "ok", estree: void 0 };
      if (k.type === "ok") {
        t.enter(r), t.consume(x), t.exit(r);
        const w = t.exit(n);
        return l && k.estree && Object.assign(w, { estree: k.estree }), e;
      }
      return (m = k.message), t.enter(i), t.consume(x), g;
    }
    return t.enter(i), g(x);
  }
  function g(x) {
    return (x === 125 && f === 0) || x === null || de(x)
      ? (t.exit(i), v(x))
      : (x === 123 && !o ? (f += 1) : x === 125 && (f -= 1), t.consume(x), g);
  }
  function b(x) {
    const k = h.now();
    if (k.line !== p.line && !u && h.parser.lazy[k.line]) {
      const w = new rt(
        "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        { place: h.now(), ruleId: "unexpected-lazy", source: "micromark-extension-mdx-expression" }
      );
      throw ((w.url = gl + AQ), w);
    }
    return v(x);
  }
}
function IQ(t, e, n, r, i, o, s) {
  const l = kP(this.events.slice(r), {
      acorn: t,
      tokenTypes: [n],
      acornOptions: e,
      start: i,
      expression: !0,
      allowEmpty: o,
      prefix: s ? "({" : "",
      suffix: s ? "})" : "",
    }),
    a = l.estree;
  if (s && a) {
    const c = a.body[0];
    if (c.type !== "ExpressionStatement" || c.expression.type !== "ObjectExpression") {
      const u = Xd(c),
        h = new rt("Unexpected `" + c.type + "` in code: expected an object spread (`{...spread}`)", {
          place: u.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression",
        });
      throw ((h.url = gl + yk), h);
    }
    if (c.expression.properties[1]) {
      const u = Xd(c.expression.properties[1]),
        h = new rt("Unexpected extra content in spread: only a single spread is supported", {
          place: u.start,
          ruleId: "spread-extra",
          source: "micromark-extension-mdx-expression",
        });
      throw ((h.url = gl + $Q), h);
    }
    if (c.expression.properties[0] && c.expression.properties[0].type !== "SpreadElement") {
      const u = Xd(c.expression.properties[0]),
        h = new rt("Unexpected `" + c.expression.properties[0].type + "` in code: only spread elements are supported", {
          place: u.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression",
        });
      throw ((h.url = gl + yk), h);
    }
  }
  if (l.error) {
    const c = new rt("Could not parse expression with acorn", {
      cause: l.error,
      place: { line: l.error.loc.line, column: l.error.loc.column + 1, offset: l.error.pos },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression",
    });
    return (c.url = gl + RQ), { type: "nok", message: c };
  }
  return { type: "ok", estree: a };
}
const wk = "https://github.com/micromark/micromark-extension-mdx-jsx";
function CP(t, e, n, r, i, o, s, l, a, c, u, h, d, f, p, m, O, v, g, b, x, k, w, y, C, P, E, N, L, D, Q, R) {
  const W = this;
  let B, K;
  return ne;
  function ne(I) {
    return t.enter(l), t.enter(a), t.consume(I), t.exit(a), A;
  }
  function A(I) {
    return Ke(I) ? n(I) : ((B = V), Je(I));
  }
  function V(I) {
    if (I === 47) return t.enter(c), t.consume(I), t.exit(c), (B = ie), Je;
    if (I === 62) return Tt(I);
    if (I !== null && I >= 0 && wr(I)) return t.enter(h), t.enter(d), t.consume(I), M;
    J(
      I,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")
    );
  }
  function ie(I) {
    if (I === 62) return Tt(I);
    if (I !== null && I >= 0 && wr(I)) return t.enter(h), t.enter(d), t.consume(I), M;
    J(
      I,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 42 || I === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function M(I) {
    if (I !== null && I >= 0 && Ka(I, { jsx: !0 })) return t.consume(I), M;
    if (I === 46 || I === 47 || I === 58 || I === 62 || I === 123 || Ke(I) || Ai(I)) return t.exit(d), (B = fe), Je(I);
    J(
      I,
      "in name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
        (I === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function fe(I) {
    if (I === 46) return t.enter(f), t.consume(I), t.exit(f), (B = Se), Je;
    if (I === 58) return t.enter(m), t.consume(I), t.exit(m), (B = q), Je;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && wr(I))) return t.exit(h), Oe(I);
    J(
      I,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function Se(I) {
    if (I !== null && I >= 0 && wr(I)) return t.enter(p), t.consume(I), pe;
    J(
      I,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function pe(I) {
    if (I !== null && I >= 0 && Ka(I, { jsx: !0 })) return t.consume(I), pe;
    if (I === 46 || I === 47 || I === 62 || I === 123 || Ke(I) || Ai(I)) return t.exit(p), (B = Y), Je(I);
    J(
      I,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
        (I === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function Y(I) {
    if (I === 46) return t.enter(f), t.consume(I), t.exit(f), (B = Se), Je;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && wr(I))) return t.exit(h), Oe(I);
    J(
      I,
      "after member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function q(I) {
    if (I !== null && I >= 0 && wr(I)) return t.enter(O), t.consume(I), oe;
    J(
      I,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 43 || (I !== null && I > 46 && I < 58) ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function oe(I) {
    if (I !== null && I >= 0 && Ka(I, { jsx: !0 })) return t.consume(I), oe;
    if (I === 47 || I === 62 || I === 123 || Ke(I) || Ai(I)) return t.exit(O), (B = ce), Je(I);
    J(I, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function ce(I) {
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && wr(I))) return t.exit(h), Oe(I);
    J(
      I,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function Oe(I) {
    if (I === 47) return t.enter(u), t.consume(I), t.exit(u), (B = Ft), Je;
    if (I === 62) return Tt(I);
    if (I === 123) return Mf.call(W, t, _e, v, g, b, r, i, o, !0, !1, s)(I);
    if (I !== null && I >= 0 && wr(I)) return t.enter(x), t.enter(k), t.enter(w), t.consume(I), Le;
    J(
      I,
      "before attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function _e(I) {
    return (B = Oe), Je(I);
  }
  function Le(I) {
    if (I !== null && I >= 0 && Ka(I, { jsx: !0 })) return t.consume(I), Le;
    if (I === 47 || I === 58 || I === 61 || I === 62 || I === 123 || Ke(I) || Ai(I)) return t.exit(w), (B = Ge), Je(I);
    J(
      I,
      "in attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function Ge(I) {
    if (I === 58) return t.enter(y), t.consume(I), t.exit(y), (B = Ct), Je;
    if (I === 61) return t.exit(k), t.enter(P), t.consume(I), t.exit(P), (B = We), Je;
    if (I === 47 || I === 62 || I === 123 || Ke(I) || Ai(I) || (I !== null && I >= 0 && wr(I)))
      return t.exit(k), t.exit(x), (B = Oe), Je(I);
    J(
      I,
      "after attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function Ct(I) {
    if (I !== null && I >= 0 && wr(I)) return t.enter(C), t.consume(I), $t;
    J(
      I,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function $t(I) {
    if (I !== null && I >= 0 && Ka(I, { jsx: !0 })) return t.consume(I), $t;
    if (I === 47 || I === 61 || I === 62 || I === 123 || Ke(I) || Ai(I)) return t.exit(C), t.exit(k), (B = Rt), Je(I);
    J(
      I,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function Rt(I) {
    if (I === 61) return t.enter(P), t.consume(I), t.exit(P), (B = We), Je;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && wr(I))) return t.exit(x), Oe(I);
    J(
      I,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function We(I) {
    if (I === 34 || I === 39) return t.enter(E), t.enter(N), t.consume(I), t.exit(N), (K = I), je;
    if (I === 123) return Mf.call(W, t, Ne, D, Q, R, r, i, o, !1, !1, s)(I);
    J(
      I,
      "before attribute value",
      "a character that can start an attribute value, such as `\"`, `'`, or `{`" +
        (I === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")
    );
  }
  function Ne(I) {
    return t.exit(x), (B = Oe), Je(I);
  }
  function je(I) {
    return (
      I === null && J(I, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(K) + "`"),
      I === K
        ? (t.enter(N), t.consume(I), t.exit(N), t.exit(E), t.exit(x), (K = void 0), (B = Oe), Je)
        : de(I)
        ? ((B = je), Je(I))
        : (t.enter(L), Ie(I))
    );
  }
  function Ie(I) {
    return I === null || I === K || de(I) ? (t.exit(L), je(I)) : (t.consume(I), Ie);
  }
  function Ft(I) {
    if (I === 62) return Tt(I);
    J(
      I,
      "after self-closing slash",
      "`>` to end the tag" + (I === 42 || I === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function Tt(I) {
    return t.enter(a), t.consume(I), t.exit(a), t.exit(l), e;
  }
  function Je(I) {
    return de(I)
      ? (t.enter("lineEnding"), t.consume(I), t.exit("lineEnding"), U)
      : Pe(I) || Ai(I)
      ? (t.enter("esWhitespace"), rn(I))
      : B(I);
  }
  function rn(I) {
    return de(I) ? (t.exit("esWhitespace"), Je(I)) : Pe(I) || Ai(I) ? (t.consume(I), rn) : (t.exit("esWhitespace"), B(I));
  }
  function U(I) {
    if (!s && W.parser.lazy[W.now().line]) {
      const Te = new rt(
        "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        W.now(),
        "micromark-extension-mdx-jsx:unexpected-lazy"
      );
      throw ((Te.url = wk + "#unexpected-lazy-line-in-container-expected-line-to-be"), Te);
    }
    return Je(I);
  }
  function J(I, Te, De) {
    const gt = new rt(
      "Unexpected " +
        (I === null ? "end of file" : "character `" + (I === 96 ? "` ` `" : String.fromCodePoint(I)) + "` (" + MQ(I) + ")") +
        " " +
        Te +
        ", expected " +
        De,
      W.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (I === null ? "eof" : "character")
    );
    throw ((gt.url = wk + (I === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect")), gt);
  }
}
function MQ(t) {
  return "U+" + t.toString(16).toUpperCase().padStart(4, "0");
}
function LQ(t, e) {
  return { name: "mdxJsxTextTag", tokenize: n };
  function n(r, i, o) {
    return CP.call(
      this,
      r,
      i,
      o,
      t,
      e.acornOptions,
      e.addResult,
      !0,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue"
    );
  }
}
function Re(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return s;
  function s(a) {
    return Pe(a) ? (t.enter(n), l(a)) : e(a);
  }
  function l(a) {
    return Pe(a) && o++ < i ? (t.consume(a), l) : (t.exit(n), e(a));
  }
}
function NQ(t, e) {
  return { name: "mdxJsxFlowTag", tokenize: n, concrete: !0 };
  function n(r, i, o) {
    const s = this;
    return l;
    function l(h) {
      return a(h);
    }
    function a(h) {
      return CP.call(
        s,
        r,
        c,
        o,
        t,
        e.acornOptions,
        e.addResult,
        !1,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue"
      )(h);
    }
    function c(h) {
      return Pe(h) ? Re(r, u, "whitespace")(h) : u(h);
    }
    function u(h) {
      const d = s.parser.constructs.flow[123],
        p = (Array.isArray(d) ? d : d ? [d] : []).find((m) => m.name === "mdxFlowExpression");
      return h === 60 ? l(h) : h === 123 && p ? r.attempt(p, u, o)(h) : h === null || de(h) ? i(h) : o(h);
    }
  }
}
function _P(t) {
  const e = t || {},
    n = e.acorn;
  let r;
  if (n) {
    if (!n.parse || !n.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    r = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, e.acornOptions, { locations: !0 });
  } else if (e.acornOptions || e.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: { 60: NQ(n || void 0, { acornOptions: r, addResult: e.addResult || void 0 }) },
    text: { 60: LQ(n || void 0, { acornOptions: r, addResult: e.addResult || void 0 }) },
  };
}
function EP() {
  return { disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] } };
}
const Sk = {}.hasOwnProperty;
function QQ(t, e) {
  const n = e || {};
  function r(i, ...o) {
    let s = r.invalid;
    const l = r.handlers;
    if (i && Sk.call(i, t)) {
      const a = String(i[t]);
      s = Sk.call(l, a) ? l[a] : r.unknown;
    }
    if (s) return s.call(this, i, ...o);
  }
  return (r.handlers = n.handlers || {}), (r.invalid = n.invalid), (r.unknown = n.unknown), r;
}
const DQ = {}.hasOwnProperty;
function TP(t, e) {
  let n = -1,
    r;
  if (e.extensions) for (; ++n < e.extensions.length; ) TP(t, e.extensions[n]);
  for (r in e)
    if (DQ.call(e, r))
      switch (r) {
        case "extensions":
          break;
        case "unsafe": {
          kk(t[r], e[r]);
          break;
        }
        case "join": {
          kk(t[r], e[r]);
          break;
        }
        case "handlers": {
          FQ(t[r], e[r]);
          break;
        }
        default:
          t.options[r] = e[r];
      }
  return t;
}
function kk(t, e) {
  e && t.push(...e);
}
function FQ(t, e) {
  e && Object.assign(t, e);
}
function BQ(t, e, n, r) {
  const i = n.enter("blockquote"),
    o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const s = n.indentLines(n.containerFlow(t, o.current()), VQ);
  return i(), s;
}
function VQ(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function PP(t, e) {
  return Ck(t, e.inConstruct, !0) && !Ck(t, e.notInConstruct, !1);
}
function Ck(t, e, n) {
  if ((typeof e == "string" && (e = [e]), !e || e.length === 0)) return n;
  let r = -1;
  for (; ++r < e.length; ) if (t.includes(e[r])) return !0;
  return !1;
}
function _k(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (
      n.unsafe[i].character ===
        `
` &&
      PP(n.stack, n.unsafe[i])
    )
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function jQ(t, e) {
  const n = String(t);
  let r = n.indexOf(e),
    i = r,
    o = 0,
    s = 0;
  if (typeof e != "string") throw new TypeError("Expected substring");
  for (; r !== -1; ) r === i ? ++o > s && (s = o) : (o = 1), (i = r + e.length), (r = n.indexOf(e, i));
  return s;
}
function V0(t, e) {
  return !!(
    e.options.fences === !1 &&
    t.value &&
    !t.lang &&
    /[^ \r\n]/.test(t.value) &&
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value)
  );
}
function ZQ(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~") throw new Error("Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`");
  return e;
}
function zQ(t, e, n, r) {
  const i = ZQ(n),
    o = t.value || "",
    s = i === "`" ? "GraveAccent" : "Tilde";
  if (V0(t, n)) {
    const h = n.enter("codeIndented"),
      d = n.indentLines(o, WQ);
    return h(), d;
  }
  const l = n.createTracker(r),
    a = i.repeat(Math.max(jQ(o, i) + 1, 3)),
    c = n.enter("codeFenced");
  let u = l.move(a);
  if (t.lang) {
    const h = n.enter(`codeFencedLang${s}`);
    (u += l.move(n.safe(t.lang, { before: u, after: " ", encode: ["`"], ...l.current() }))), h();
  }
  if (t.lang && t.meta) {
    const h = n.enter(`codeFencedMeta${s}`);
    (u += l.move(" ")),
      (u += l.move(
        n.safe(t.meta, {
          before: u,
          after: `
`,
          encode: ["`"],
          ...l.current(),
        })
      )),
      h();
  }
  return (
    (u += l.move(`
`)),
    o &&
      (u += l.move(
        o +
          `
`
      )),
    (u += l.move(a)),
    c(),
    u
  );
}
function WQ(t, e, n) {
  return (n ? "" : "    ") + t;
}
function Fb(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'") throw new Error("Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`");
  return e;
}
function XQ(t, e, n, r) {
  const i = Fb(n),
    o = i === '"' ? "Quote" : "Apostrophe",
    s = n.enter("definition");
  let l = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("[");
  return (
    (c += a.move(n.safe(n.associationId(t), { before: c, after: "]", ...a.current() }))),
    (c += a.move("]: ")),
    l(),
    !t.url || /[\0- \u007F]/.test(t.url)
      ? ((l = n.enter("destinationLiteral")),
        (c += a.move("<")),
        (c += a.move(n.safe(t.url, { before: c, after: ">", ...a.current() }))),
        (c += a.move(">")))
      : ((l = n.enter("destinationRaw")),
        (c += a.move(
          n.safe(t.url, {
            before: c,
            after: t.title
              ? " "
              : `
`,
            ...a.current(),
          })
        ))),
    l(),
    t.title &&
      ((l = n.enter(`title${o}`)),
      (c += a.move(" " + i)),
      (c += a.move(n.safe(t.title, { before: c, after: i, ...a.current() }))),
      (c += a.move(i)),
      l()),
    s(),
    c
  );
}
function UQ(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_") throw new Error("Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`");
  return e;
}
AP.peek = HQ;
function AP(t, e, n, r) {
  const i = UQ(n),
    o = n.enter("emphasis"),
    s = n.createTracker(r);
  let l = s.move(i);
  return (l += s.move(n.containerPhrasing(t, { before: l, after: i, ...s.current() }))), (l += s.move(i)), o(), l;
}
function HQ(t, e, n) {
  return n.options.emphasis || "*";
}
const Bb = function (t) {
  if (t == null) return JQ;
  if (typeof t == "function") return pm(t);
  if (typeof t == "object") return Array.isArray(t) ? qQ(t) : YQ(t);
  if (typeof t == "string") return GQ(t);
  throw new Error("Expected function, string, or object as test");
};
function qQ(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; ) e[n] = Bb(t[n]);
  return pm(r);
  function r(...i) {
    let o = -1;
    for (; ++o < e.length; ) if (e[o].apply(this, i)) return !0;
    return !1;
  }
}
function YQ(t) {
  const e = t;
  return pm(n);
  function n(r) {
    const i = r;
    let o;
    for (o in t) if (i[o] !== e[o]) return !1;
    return !0;
  }
}
function GQ(t) {
  return pm(e);
  function e(n) {
    return n && n.type === t;
  }
}
function pm(t) {
  return e;
  function e(n, r, i) {
    return !!(KQ(n) && t.call(this, n, typeof r == "number" ? r : void 0, i || void 0));
  }
}
function JQ() {
  return !0;
}
function KQ(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const $P = [],
  eD = !0,
  j0 = !1,
  tD = "skip";
function RP(t, e, n, r) {
  let i;
  typeof e == "function" && typeof n != "function" ? ((r = n), (n = e)) : (i = e);
  const o = Bb(i),
    s = r ? -1 : 1;
  l(t, void 0, [])();
  function l(a, c, u) {
    const h = a && typeof a == "object" ? a : {};
    if (typeof h.type == "string") {
      const f = typeof h.tagName == "string" ? h.tagName : typeof h.name == "string" ? h.name : void 0;
      Object.defineProperty(d, "name", { value: "node (" + (a.type + (f ? "<" + f + ">" : "")) + ")" });
    }
    return d;
    function d() {
      let f = $P,
        p,
        m,
        O;
      if ((!e || o(a, c, u[u.length - 1] || void 0)) && ((f = nD(n(a, u))), f[0] === j0)) return f;
      if ("children" in a && a.children) {
        const v = a;
        if (v.children && f[0] !== tD)
          for (m = (r ? v.children.length : -1) + s, O = u.concat(v); m > -1 && m < v.children.length; ) {
            const g = v.children[m];
            if (((p = l(g, m, O)()), p[0] === j0)) return p;
            m = typeof p[1] == "number" ? p[1] : m + s;
          }
      }
      return f;
    }
  }
}
function nD(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [eD, t] : t == null ? $P : [t];
}
function rD(t, e, n, r) {
  let i, o, s;
  typeof e == "function" && typeof n != "function" ? ((o = void 0), (s = e), (i = n)) : ((o = e), (s = n), (i = r)), RP(t, o, l, i);
  function l(a, c) {
    const u = c[c.length - 1],
      h = u ? u.children.indexOf(a) : void 0;
    return s(a, h, u);
  }
}
const iD = {};
function Vb(t, e) {
  const n = e || iD,
    r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0,
    i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return IP(t, r, i);
}
function IP(t, e, n) {
  if (oD(t)) {
    if ("value" in t) return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt) return t.alt;
    if ("children" in t) return Ek(t.children, e, n);
  }
  return Array.isArray(t) ? Ek(t, e, n) : "";
}
function Ek(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) r[i] = IP(t[i], e, n);
  return r.join("");
}
function oD(t) {
  return !!(t && typeof t == "object");
}
function MP(t, e) {
  let n = !1;
  return (
    rD(t, function (r) {
      if (("value" in r && /\r?\n|\r/.test(r.value)) || r.type === "break") return (n = !0), j0;
    }),
    !!((!t.depth || t.depth < 3) && Vb(t) && (e.options.setext || n))
  );
}
function sD(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1),
    o = n.createTracker(r);
  if (MP(t, n)) {
    const u = n.enter("headingSetext"),
      h = n.enter("phrasing"),
      d = n.containerPhrasing(t, {
        ...o.current(),
        before: `
`,
        after: `
`,
      });
    return (
      h(),
      u(),
      d +
        `
` +
        (i === 1 ? "=" : "-").repeat(
          d.length -
            (Math.max(
              d.lastIndexOf("\r"),
              d.lastIndexOf(`
`)
            ) +
              1)
        )
    );
  }
  const s = "#".repeat(i),
    l = n.enter("headingAtx"),
    a = n.enter("phrasing");
  o.move(s + " ");
  let c = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...o.current(),
  });
  return (
    /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)),
    (c = c ? s + " " + c : s),
    n.options.closeAtx && (c += " " + s),
    a(),
    l(),
    c
  );
}
LP.peek = lD;
function LP(t) {
  return t.value || "";
}
function lD() {
  return "<";
}
NP.peek = aD;
function NP(t, e, n, r) {
  const i = Fb(n),
    o = i === '"' ? "Quote" : "Apostrophe",
    s = n.enter("image");
  let l = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("![");
  return (
    (c += a.move(n.safe(t.alt, { before: c, after: "]", ...a.current() }))),
    (c += a.move("](")),
    l(),
    (!t.url && t.title) || /[\0- \u007F]/.test(t.url)
      ? ((l = n.enter("destinationLiteral")),
        (c += a.move("<")),
        (c += a.move(n.safe(t.url, { before: c, after: ">", ...a.current() }))),
        (c += a.move(">")))
      : ((l = n.enter("destinationRaw")), (c += a.move(n.safe(t.url, { before: c, after: t.title ? " " : ")", ...a.current() })))),
    l(),
    t.title &&
      ((l = n.enter(`title${o}`)),
      (c += a.move(" " + i)),
      (c += a.move(n.safe(t.title, { before: c, after: i, ...a.current() }))),
      (c += a.move(i)),
      l()),
    (c += a.move(")")),
    s(),
    c
  );
}
function aD() {
  return "!";
}
QP.peek = cD;
function QP(t, e, n, r) {
  const i = t.referenceType,
    o = n.enter("imageReference");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let a = l.move("![");
  const c = n.safe(t.alt, { before: a, after: "]", ...l.current() });
  (a += l.move(c + "][")), s();
  const u = n.stack;
  (n.stack = []), (s = n.enter("reference"));
  const h = n.safe(n.associationId(t), { before: a, after: "]", ...l.current() });
  return (
    s(),
    (n.stack = u),
    o(),
    i === "full" || !c || c !== h ? (a += l.move(h + "]")) : i === "shortcut" ? (a = a.slice(0, -1)) : (a += l.move("]")),
    a
  );
}
function cD() {
  return "!";
}
DP.peek = uD;
function DP(t, e, n) {
  let r = t.value || "",
    i = "`",
    o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); ) i += "`";
  for (
    /[^ \r\n]/.test(r) && ((/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r)) || /^`|`$/.test(r)) && (r = " " + r + " ");
    ++o < n.unsafe.length;

  ) {
    const s = n.unsafe[o],
      l = n.compilePattern(s);
    let a;
    if (s.atBreak)
      for (; (a = l.exec(r)); ) {
        let c = a.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, (r = r.slice(0, c) + " " + r.slice(a.index + 1));
      }
  }
  return i + r + i;
}
function uD() {
  return "`";
}
function FP(t, e) {
  const n = Vb(t);
  return !!(
    !e.options.resourceLink &&
    t.url &&
    !t.title &&
    t.children &&
    t.children.length === 1 &&
    t.children[0].type === "text" &&
    (n === t.url || "mailto:" + n === t.url) &&
    /^[a-z][a-z+.-]+:/i.test(t.url) &&
    !/[\0- <>\u007F]/.test(t.url)
  );
}
BP.peek = hD;
function BP(t, e, n, r) {
  const i = Fb(n),
    o = i === '"' ? "Quote" : "Apostrophe",
    s = n.createTracker(r);
  let l, a;
  if (FP(t, n)) {
    const u = n.stack;
    (n.stack = []), (l = n.enter("autolink"));
    let h = s.move("<");
    return (h += s.move(n.containerPhrasing(t, { before: h, after: ">", ...s.current() }))), (h += s.move(">")), l(), (n.stack = u), h;
  }
  (l = n.enter("link")), (a = n.enter("label"));
  let c = s.move("[");
  return (
    (c += s.move(n.containerPhrasing(t, { before: c, after: "](", ...s.current() }))),
    (c += s.move("](")),
    a(),
    (!t.url && t.title) || /[\0- \u007F]/.test(t.url)
      ? ((a = n.enter("destinationLiteral")),
        (c += s.move("<")),
        (c += s.move(n.safe(t.url, { before: c, after: ">", ...s.current() }))),
        (c += s.move(">")))
      : ((a = n.enter("destinationRaw")), (c += s.move(n.safe(t.url, { before: c, after: t.title ? " " : ")", ...s.current() })))),
    a(),
    t.title &&
      ((a = n.enter(`title${o}`)),
      (c += s.move(" " + i)),
      (c += s.move(n.safe(t.title, { before: c, after: i, ...s.current() }))),
      (c += s.move(i)),
      a()),
    (c += s.move(")")),
    l(),
    c
  );
}
function hD(t, e, n) {
  return FP(t, n) ? "<" : "[";
}
VP.peek = dD;
function VP(t, e, n, r) {
  const i = t.referenceType,
    o = n.enter("linkReference");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let a = l.move("[");
  const c = n.containerPhrasing(t, { before: a, after: "]", ...l.current() });
  (a += l.move(c + "][")), s();
  const u = n.stack;
  (n.stack = []), (s = n.enter("reference"));
  const h = n.safe(n.associationId(t), { before: a, after: "]", ...l.current() });
  return (
    s(),
    (n.stack = u),
    o(),
    i === "full" || !c || c !== h ? (a += l.move(h + "]")) : i === "shortcut" ? (a = a.slice(0, -1)) : (a += l.move("]")),
    a
  );
}
function dD() {
  return "[";
}
function jb(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error("Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`");
  return e;
}
function fD(t) {
  const e = jb(t),
    n = t.options.bulletOther;
  if (!n) return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
  if (n === e) throw new Error("Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different");
  return n;
}
function pD(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")") throw new Error("Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`");
  return e;
}
function jP(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error("Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`");
  return e;
}
function mD(t, e, n, r) {
  const i = n.enter("list"),
    o = n.bulletCurrent;
  let s = t.ordered ? pD(n) : jb(n);
  const l = t.ordered ? (s === "." ? ")" : ".") : fD(n);
  let a = e && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const u = t.children ? t.children[0] : void 0;
    if (
      ((s === "*" || s === "-") &&
        u &&
        (!u.children || !u.children[0]) &&
        n.stack[n.stack.length - 1] === "list" &&
        n.stack[n.stack.length - 2] === "listItem" &&
        n.stack[n.stack.length - 3] === "list" &&
        n.stack[n.stack.length - 4] === "listItem" &&
        n.indexStack[n.indexStack.length - 1] === 0 &&
        n.indexStack[n.indexStack.length - 2] === 0 &&
        n.indexStack[n.indexStack.length - 3] === 0 &&
        (a = !0),
      jP(n) === s && u)
    ) {
      let h = -1;
      for (; ++h < t.children.length; ) {
        const d = t.children[h];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          a = !0;
          break;
        }
      }
    }
  }
  a && (s = l), (n.bulletCurrent = s);
  const c = n.containerFlow(t, r);
  return (n.bulletLastUsed = s), (n.bulletCurrent = o), i(), c;
}
function gD(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error("Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  return e;
}
function OD(t, e, n, r) {
  const i = gD(n);
  let o = n.bulletCurrent || jb(n);
  e &&
    e.type === "list" &&
    e.ordered &&
    (o =
      (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + o);
  let s = o.length + 1;
  (i === "tab" || (i === "mixed" && ((e && e.type === "list" && e.spread) || t.spread))) && (s = Math.ceil(s / 4) * 4);
  const l = n.createTracker(r);
  l.move(o + " ".repeat(s - o.length)), l.shift(s);
  const a = n.enter("listItem"),
    c = n.indentLines(n.containerFlow(t, l.current()), u);
  return a(), c;
  function u(h, d, f) {
    return d ? (f ? "" : " ".repeat(s)) + h : (f ? o : o + " ".repeat(s - o.length)) + h;
  }
}
function vD(t, e, n, r) {
  const i = n.enter("paragraph"),
    o = n.enter("phrasing"),
    s = n.containerPhrasing(t, r);
  return o(), i(), s;
}
const bD = Bb([
  "break",
  "delete",
  "emphasis",
  "footnote",
  "footnoteReference",
  "image",
  "imageReference",
  "inlineCode",
  "inlineMath",
  "link",
  "linkReference",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "strong",
  "text",
  "textDirective",
]);
function xD(t, e, n, r) {
  return (
    t.children.some(function (s) {
      return bD(s);
    })
      ? n.containerPhrasing
      : n.containerFlow
  ).call(n, t, r);
}
function yD(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_") throw new Error("Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`");
  return e;
}
ZP.peek = wD;
function ZP(t, e, n, r) {
  const i = yD(n),
    o = n.enter("strong"),
    s = n.createTracker(r);
  let l = s.move(i + i);
  return (l += s.move(n.containerPhrasing(t, { before: l, after: i, ...s.current() }))), (l += s.move(i + i)), o(), l;
}
function wD(t, e, n) {
  return n.options.strong || "*";
}
function SD(t, e, n, r) {
  return n.safe(t.value, r);
}
function kD(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3) throw new Error("Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more");
  return e;
}
function CD(t, e, n) {
  const r = (jP(n) + (n.options.ruleSpaces ? " " : "")).repeat(kD(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Zb = {
    blockquote: BQ,
    break: _k,
    code: zQ,
    definition: XQ,
    emphasis: AP,
    hardBreak: _k,
    heading: sD,
    html: LP,
    image: NP,
    imageReference: QP,
    inlineCode: DP,
    link: BP,
    linkReference: VP,
    list: mD,
    listItem: OD,
    paragraph: vD,
    root: xD,
    strong: ZP,
    text: SD,
    thematicBreak: CD,
  },
  _D = [ED];
function ED(t, e, n, r) {
  if (e.type === "code" && V0(e, r) && (t.type === "list" || (t.type === e.type && V0(t, r)))) return !1;
  if ("spread" in n && typeof n.spread == "boolean")
    return t.type === "paragraph" && (t.type === e.type || e.type === "definition" || (e.type === "heading" && MP(e, r)))
      ? void 0
      : n.spread
      ? 1
      : 0;
}
const ls = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"],
  TD = [
    { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx",
      ],
    },
    {
      character: `
`,
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx",
      ],
    },
    { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] },
    { character: "!", after: "\\[", inConstruct: "phrasing", notInConstruct: ls },
    { character: '"', inConstruct: "titleQuote" },
    { atBreak: !0, character: "#" },
    {
      character: "#",
      inConstruct: "headingAtx",
      after: `(?:[\r
]|$)`,
    },
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    { character: "'", inConstruct: "titleApostrophe" },
    { character: "(", inConstruct: "destinationRaw" },
    { before: "\\]", character: "(", inConstruct: "phrasing", notInConstruct: ls },
    { atBreak: !0, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    {
      atBreak: !0,
      character: "*",
      after: `(?:[ 	\r
*])`,
    },
    { character: "*", inConstruct: "phrasing", notInConstruct: ls },
    {
      atBreak: !0,
      character: "+",
      after: `(?:[ 	\r
])`,
    },
    {
      atBreak: !0,
      character: "-",
      after: `(?:[ 	\r
-])`,
    },
    {
      atBreak: !0,
      before: "\\d+",
      character: ".",
      after: `(?:[ 	\r
]|$)`,
    },
    { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
    { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing", notInConstruct: ls },
    { character: "<", inConstruct: "destinationLiteral" },
    { atBreak: !0, character: "=" },
    { atBreak: !0, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    { atBreak: !0, character: "[" },
    { character: "[", inConstruct: "phrasing", notInConstruct: ls },
    { character: "[", inConstruct: ["label", "reference"] },
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "]", inConstruct: ["label", "reference"] },
    { atBreak: !0, character: "_" },
    { character: "_", inConstruct: "phrasing", notInConstruct: ls },
    { atBreak: !0, character: "`" },
    { character: "`", inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"] },
    { character: "`", inConstruct: "phrasing", notInConstruct: ls },
    { atBreak: !0, character: "~" },
  ];
function zP(t, e) {
  const n = Number.parseInt(t, e);
  return n < 9 ||
    n === 11 ||
    (n > 13 && n < 32) ||
    (n > 126 && n < 160) ||
    (n > 55295 && n < 57344) ||
    (n > 64975 && n < 65008) ||
    (n & 65535) === 65535 ||
    (n & 65535) === 65534 ||
    n > 1114111
    ? "�"
    : String.fromCodePoint(n);
}
const PD = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function WP(t) {
  return t.replace(PD, AD);
}
function AD(t, e, n) {
  if (e) return e;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1),
      o = i === 120 || i === 88;
    return zP(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return nu(n) || t;
}
function $D(t) {
  return t.label || !t.identifier ? t.label || "" : WP(t.identifier);
}
function RD(t) {
  if (!t._compiled) {
    const e = (t.atBreak ? "[\\r\\n][\\t ]*" : "") + (t.before ? "(?:" + t.before + ")" : "");
    t._compiled = new RegExp(
      (e ? "(" + e + ")" : "") +
        (/[|\\{}()[\]^$+*?.-]/.test(t.character) ? "\\" : "") +
        t.character +
        (t.after ? "(?:" + t.after + ")" : ""),
      "g"
    );
  }
  return t._compiled;
}
function ID(t, e, n) {
  const r = e.indexStack,
    i = t.children || [],
    o = [];
  let s = -1,
    l = n.before;
  r.push(-1);
  let a = e.createTracker(n);
  for (; ++s < i.length; ) {
    const c = i[s];
    let u;
    if (((r[r.length - 1] = s), s + 1 < i.length)) {
      let h = e.handle.handlers[i[s + 1].type];
      h && h.peek && (h = h.peek), (u = h ? h(i[s + 1], t, e, { before: "", after: "", ...a.current() }).charAt(0) : "");
    } else u = n.after;
    o.length > 0 &&
      (l === "\r" ||
        l ===
          `
`) &&
      c.type === "html" &&
      ((o[o.length - 1] = o[o.length - 1].replace(/(\r?\n|\r)$/, " ")), (l = " "), (a = e.createTracker(n)), a.move(o.join(""))),
      o.push(a.move(e.handle(c, t, e, { ...a.current(), before: l, after: u }))),
      (l = o[o.length - 1].slice(-1));
  }
  return r.pop(), o.join("");
}
function MD(t, e, n) {
  const r = e.indexStack,
    i = t.children || [],
    o = e.createTracker(n),
    s = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const a = i[l];
    (r[r.length - 1] = l),
      s.push(
        o.move(
          e.handle(a, t, e, {
            before: `
`,
            after: `
`,
            ...o.current(),
          })
        )
      ),
      a.type !== "list" && (e.bulletLastUsed = void 0),
      l < i.length - 1 && s.push(o.move(LD(a, i[l + 1], t, e)));
  }
  return r.pop(), s.join("");
}
function LD(t, e, n, r) {
  let i = r.join.length;
  for (; i--; ) {
    const o = r.join[i](t, e, n, r);
    if (o === !0 || o === 1) break;
    if (typeof o == "number")
      return `
`.repeat(1 + o);
    if (o === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const ND = /\r?\n|\r/g;
function QD(t, e) {
  const n = [];
  let r = 0,
    i = 0,
    o;
  for (; (o = ND.exec(t)); ) s(t.slice(r, o.index)), n.push(o[0]), (r = o.index + o[0].length), i++;
  return s(t.slice(r)), n.join("");
  function s(l) {
    n.push(e(l, i, !l));
  }
}
function DD(t, e, n) {
  const r = (n.before || "") + (e || "") + (n.after || ""),
    i = [],
    o = [],
    s = {};
  let l = -1;
  for (; ++l < t.unsafe.length; ) {
    const u = t.unsafe[l];
    if (!PP(t.stack, u)) continue;
    const h = t.compilePattern(u);
    let d;
    for (; (d = h.exec(r)); ) {
      const f = "before" in u || !!u.atBreak,
        p = "after" in u,
        m = d.index + (f ? d[1].length : 0);
      i.includes(m)
        ? (s[m].before && !f && (s[m].before = !1), s[m].after && !p && (s[m].after = !1))
        : (i.push(m), (s[m] = { before: f, after: p }));
    }
  }
  i.sort(FD);
  let a = n.before ? n.before.length : 0;
  const c = r.length - (n.after ? n.after.length : 0);
  for (l = -1; ++l < i.length; ) {
    const u = i[l];
    u < a ||
      u >= c ||
      (u + 1 < c && i[l + 1] === u + 1 && s[u].after && !s[u + 1].before && !s[u + 1].after) ||
      (i[l - 1] === u - 1 && s[u].before && !s[u - 1].before && !s[u - 1].after) ||
      (a !== u && o.push(Tk(r.slice(a, u), "\\")),
      (a = u),
      /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!n.encode || !n.encode.includes(r.charAt(u)))
        ? o.push("\\")
        : (o.push("&#x" + r.charCodeAt(u).toString(16).toUpperCase() + ";"), a++));
  }
  return o.push(Tk(r.slice(a, c), n.after)), o.join("");
}
function FD(t, e) {
  return t - e;
}
function Tk(t, e) {
  const n = /\\(?=[!-/:-@[-`{-~])/g,
    r = [],
    i = [],
    o = t + e;
  let s = -1,
    l = 0,
    a;
  for (; (a = n.exec(o)); ) r.push(a.index);
  for (; ++s < r.length; ) l !== r[s] && i.push(t.slice(l, r[s])), i.push("\\"), (l = r[s]);
  return i.push(t.slice(l)), i.join("");
}
function BD(t) {
  const e = t || {},
    n = e.now || {};
  let r = e.lineShift || 0,
    i = n.line || 1,
    o = n.column || 1;
  return { move: a, current: s, shift: l };
  function s() {
    return { now: { line: i, column: o }, lineShift: r };
  }
  function l(c) {
    r += c;
  }
  function a(c) {
    const u = c || "",
      h = u.split(/\r?\n|\r/g),
      d = h[h.length - 1];
    return (i += h.length - 1), (o = h.length === 1 ? o + d.length : 1 + d.length + r), u;
  }
}
function XP(t, e = {}) {
  const n = {
    enter: i,
    indentLines: QD,
    associationId: $D,
    containerPhrasing: zD,
    containerFlow: WD,
    createTracker: BD,
    compilePattern: RD,
    safe: XD,
    stack: [],
    unsafe: [...TD],
    join: [..._D],
    handlers: { ...Zb },
    options: {},
    indexStack: [],
    handle: void 0,
  };
  TP(n, e), n.options.tightDefinitions && n.join.push(ZD), (n.handle = QQ("type", { invalid: VD, unknown: jD, handlers: n.handlers }));
  let r = n.handle(t, void 0, n, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0,
  });
  return (
    r &&
      r.charCodeAt(r.length - 1) !== 10 &&
      r.charCodeAt(r.length - 1) !== 13 &&
      (r += `
`),
    r
  );
  function i(o) {
    return n.stack.push(o), s;
    function s() {
      n.stack.pop();
    }
  }
}
function VD(t) {
  throw new Error("Cannot handle value `" + t + "`, expected node");
}
function jD(t) {
  const e = t;
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function ZD(t, e) {
  if (t.type === "definition" && t.type === e.type) return 0;
}
function zD(t, e) {
  return ID(t, this, e);
}
function WD(t, e) {
  return MD(t, this, e);
}
function XD(t, e) {
  return DD(this, t, e);
}
const UD = ["mdxJsxTextElement", "mdxJsxFlowElement"];
function zb(t) {
  return UD.includes(t.type) && UP.includes(t.name.toLowerCase());
}
const UP = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
];
function HD(t, e) {
  const n = Pk(t),
    r = Pk(e),
    i = { ...n, ...r };
  return qD(i);
}
function Pk(t) {
  const e = {};
  return (
    t
      .split(";")
      .filter((r) => r.trim() !== "")
      .forEach((r) => {
        const [i, o] = r.split(":").map((s) => s.trim());
        e[i] = o;
      }),
    e
  );
}
function qD(t) {
  return Object.entries(t)
    .map(([e, n]) => `${e}: ${n}`)
    .join("; ");
}
function YD(t) {
  return t.children instanceof Array;
}
function mm({ root: t, visitors: e, jsxComponentDescriptors: n, jsxIsAvailable: r, addImportStatements: i = !0 }) {
  let o = null;
  const s = new Set();
  (e = e.sort((O, v) => (v.priority ?? 0) - (O.priority ?? 0))), u(t, null);
  function l(O) {
    s.add(O);
  }
  function a(O, v) {
    if (o === null) return (o = v), o;
    if (!YD(O)) throw new Error("Attempting to append children to a non-parent");
    const g = O.children,
      b = g.at(-1);
    if (b) {
      const x = e.find((k) => {
        var w;
        return (w = k.shouldJoin) == null ? void 0 : w.call(k, b, v);
      });
      if (x) {
        const k = x.join(b, v);
        return g.splice(g.length - 1, 1, k), k;
      }
    }
    return g.push(v), v;
  }
  function c(O, v) {
    O.getChildren().forEach((g) => {
      u(g, v);
    });
  }
  function u(O, v) {
    var g;
    const b = e.find((x) => {
      var k;
      return (k = x.testLexicalNode) == null ? void 0 : k.call(x, O);
    });
    if (!b) throw new Error(`no lexical visitor found for ${O.getType()}`, { cause: O });
    (g = b.visitLexicalNode) == null ||
      g.call(b, {
        lexicalNode: O,
        mdastParent: v,
        actions: {
          addAndStepInto(x, k = {}, w = !0) {
            const y = { type: x, ...k, ...(w ? { children: [] } : {}) };
            a(v, y), X(O) && w && c(O, y);
          },
          appendToParent: a,
          visitChildren: c,
          registerReferredComponent: l,
        },
      });
  }
  if (o === null) throw new Error("traversal ended with no root element");
  const h = new Map(),
    d = new Map();
  for (const O of s) {
    const v = n.find((g) => g.name === O);
    if (!v) throw new Error(`Component ${O} is used but not imported`);
    if (v.source)
      if (v.defaultExport) d.set(O, v.source);
      else {
        const { source: g } = v,
          b = h.get(g);
        b ? b.push(O) : h.set(g, [O]);
      }
  }
  const f = Array.from(h).map(([O, v]) => ({ type: "mdxjsEsm", value: `import { ${v.join(", ")} } from '${O}'` }));
  f.push(...Array.from(d).map(([O, v]) => ({ type: "mdxjsEsm", value: `import ${O} from '${v}'` })));
  const p = o,
    m = p.children.find((O) => O.type === "yaml");
  return i && (m ? p.children.splice(p.children.indexOf(m) + 1, 0, ...f) : p.children.unshift(...f)), Ud(p, []), HP(p), r || qP(p), p;
}
function HP(t) {
  if ("children" in t && t.children.length > 0) {
    if (zb(t) && t.children.length === 1) {
      const e = t.children[0];
      e.type === "mdxJsxTextElement" &&
        e.name === "span" &&
        (e.attributes.forEach((n) => {
          if (n.type === "mdxJsxAttribute") {
            const r = t.attributes.find((i) => i.type === "mdxJsxAttribute" && i.name === n.name);
            if (r)
              if (n.name === "className") {
                const i = new Set([...r.value.split(" "), ...n.value.split(" ")]);
                r.value = Array.from(i).join(" ");
              } else n.name === "style" && (r.value = HD(r.value, n.value));
            else t.attributes.push(n);
          }
        }),
        (t.children = e.children));
    }
    t.children.forEach((e) => {
      HP(e);
    });
  }
}
function qP(t) {
  if (Object.hasOwn(t, "children")) {
    const e = t,
      n = [];
    e.children.forEach((r) => {
      r.type === "mdxJsxTextElement" && r.name === "u"
        ? n.push({ type: "html", value: "<u>" }, ...r.children, { type: "html", value: "</u>" })
        : (n.push(r), qP(r));
    }),
      (e.children = n);
  }
}
const Ak = /\s+$/,
  $k = /^\s+/;
function Ud(t, e) {
  if (t.type === "strong" || t.type === "emphasis") {
    const n = t.children.at(-1);
    if ((n == null ? void 0 : n.type) === "text") {
      const i = n.value.match(Ak);
      if (i) {
        n.value = n.value.replace(Ak, "");
        const o = e.at(-1);
        o && (o.children.splice(o.children.indexOf(t) + 1, 0, { type: "text", value: i[0] }), Ud(o, e.slice(0, -1)));
      }
    }
    const r = t.children.at(0);
    if ((r == null ? void 0 : r.type) === "text") {
      const i = r.value.match($k);
      if (i) {
        r.value = r.value.replace($k, "");
        const o = e.at(-1);
        o && (o.children.splice(o.children.indexOf(t), 0, { type: "text", value: i[0] }), Ud(o, e.slice(0, -1)));
      }
    }
  }
  if ("children" in t && t.children.length > 0) {
    const n = t;
    n.children.forEach((r) => {
      Ud(r, [...e, n]);
    });
  }
}
function Wb({ root: t, toMarkdownOptions: e, toMarkdownExtensions: n, visitors: r, jsxComponentDescriptors: i, jsxIsAvailable: o }) {
  return (
    XP(mm({ root: t, visitors: r, jsxComponentDescriptors: i, jsxIsAvailable: o }), { extensions: n, ...e }) +
    `
`
  );
}
const Rk = {}.hasOwnProperty;
function YP(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; ) GD(e, t[n]);
  return e;
}
function GD(t, e) {
  let n;
  for (n in e) {
    const i = (Rk.call(t, n) ? t[n] : void 0) || (t[n] = {}),
      o = e[n];
    let s;
    if (o)
      for (s in o) {
        Rk.call(i, s) || (i[s] = []);
        const l = o[s];
        JD(i[s], Array.isArray(l) ? l : l ? [l] : []);
      }
  }
}
function JD(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; ) (e[n].add === "after" ? t : r).push(e[n]);
  gr(t, 0, 0, r);
}
function El(t) {
  return t
    .replace(/[\t\n\r ]+/g, " ")
    .replace(/^ | $/g, "")
    .toLowerCase()
    .toUpperCase();
}
const KD = { tokenize: eF };
function eF(t) {
  const e = t.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return e;
  function r(l) {
    if (l === null) {
      t.consume(l);
      return;
    }
    return t.enter("lineEnding"), t.consume(l), t.exit("lineEnding"), Re(t, e, "linePrefix");
  }
  function i(l) {
    return t.enter("paragraph"), o(l);
  }
  function o(l) {
    const a = t.enter("chunkText", { contentType: "text", previous: n });
    return n && (n.next = a), (n = a), s(l);
  }
  function s(l) {
    if (l === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(l);
      return;
    }
    return de(l) ? (t.consume(l), t.exit("chunkText"), o) : (t.consume(l), s);
  }
}
const tF = { tokenize: nF },
  Ik = { tokenize: rF };
function nF(t) {
  const e = this,
    n = [];
  let r = 0,
    i,
    o,
    s;
  return l;
  function l(b) {
    if (r < n.length) {
      const x = n[r];
      return (e.containerState = x[1]), t.attempt(x[0].continuation, a, c)(b);
    }
    return c(b);
  }
  function a(b) {
    if ((r++, e.containerState._closeFlow)) {
      (e.containerState._closeFlow = void 0), i && g();
      const x = e.events.length;
      let k = x,
        w;
      for (; k--; )
        if (e.events[k][0] === "exit" && e.events[k][1].type === "chunkFlow") {
          w = e.events[k][1].end;
          break;
        }
      v(r);
      let y = x;
      for (; y < e.events.length; ) (e.events[y][1].end = Object.assign({}, w)), y++;
      return gr(e.events, k + 1, 0, e.events.slice(x)), (e.events.length = y), c(b);
    }
    return l(b);
  }
  function c(b) {
    if (r === n.length) {
      if (!i) return d(b);
      if (i.currentConstruct && i.currentConstruct.concrete) return p(b);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return (e.containerState = {}), t.check(Ik, u, h)(b);
  }
  function u(b) {
    return i && g(), v(r), d(b);
  }
  function h(b) {
    return (e.parser.lazy[e.now().line] = r !== n.length), (s = e.now().offset), p(b);
  }
  function d(b) {
    return (e.containerState = {}), t.attempt(Ik, f, p)(b);
  }
  function f(b) {
    return r++, n.push([e.currentConstruct, e.containerState]), d(b);
  }
  function p(b) {
    if (b === null) {
      i && g(), v(0), t.consume(b);
      return;
    }
    return (i = i || e.parser.flow(e.now())), t.enter("chunkFlow", { contentType: "flow", previous: o, _tokenizer: i }), m(b);
  }
  function m(b) {
    if (b === null) {
      O(t.exit("chunkFlow"), !0), v(0), t.consume(b);
      return;
    }
    return de(b) ? (t.consume(b), O(t.exit("chunkFlow")), (r = 0), (e.interrupt = void 0), l) : (t.consume(b), m);
  }
  function O(b, x) {
    const k = e.sliceStream(b);
    if ((x && k.push(null), (b.previous = o), o && (o.next = b), (o = b), i.defineSkip(b.start), i.write(k), e.parser.lazy[b.start.line])) {
      let w = i.events.length;
      for (; w--; ) if (i.events[w][1].start.offset < s && (!i.events[w][1].end || i.events[w][1].end.offset > s)) return;
      const y = e.events.length;
      let C = y,
        P,
        E;
      for (; C--; )
        if (e.events[C][0] === "exit" && e.events[C][1].type === "chunkFlow") {
          if (P) {
            E = e.events[C][1].end;
            break;
          }
          P = !0;
        }
      for (v(r), w = y; w < e.events.length; ) (e.events[w][1].end = Object.assign({}, E)), w++;
      gr(e.events, C + 1, 0, e.events.slice(y)), (e.events.length = w);
    }
  }
  function v(b) {
    let x = n.length;
    for (; x-- > b; ) {
      const k = n[x];
      (e.containerState = k[1]), k[0].exit.call(e, t);
    }
    n.length = b;
  }
  function g() {
    i.write([null]), (o = void 0), (i = void 0), (e.containerState._closeFlow = void 0);
  }
}
function rF(t, e, n) {
  return Re(
    t,
    t.attempt(this.parser.constructs.document, e, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const Z0 = { name: "attention", tokenize: oF, resolveAll: iF };
function iF(t, e) {
  let n = -1,
    r,
    i,
    o,
    s,
    l,
    a,
    c,
    u;
  for (; ++n < t.length; )
    if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
      for (r = n; r--; )
        if (
          t[r][0] === "exit" &&
          t[r][1].type === "attentionSequence" &&
          t[r][1]._open &&
          e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)
        ) {
          if (
            (t[r][1]._close || t[n][1]._open) &&
            (t[n][1].end.offset - t[n][1].start.offset) % 3 &&
            !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3)
          )
            continue;
          a = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
          const h = Object.assign({}, t[r][1].end),
            d = Object.assign({}, t[n][1].start);
          Mk(h, -a),
            Mk(d, a),
            (s = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: h, end: Object.assign({}, t[r][1].end) }),
            (l = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: Object.assign({}, t[n][1].start), end: d }),
            (o = {
              type: a > 1 ? "strongText" : "emphasisText",
              start: Object.assign({}, t[r][1].end),
              end: Object.assign({}, t[n][1].start),
            }),
            (i = { type: a > 1 ? "strong" : "emphasis", start: Object.assign({}, s.start), end: Object.assign({}, l.end) }),
            (t[r][1].end = Object.assign({}, s.start)),
            (t[n][1].start = Object.assign({}, l.end)),
            (c = []),
            t[r][1].end.offset - t[r][1].start.offset &&
              (c = hr(c, [
                ["enter", t[r][1], e],
                ["exit", t[r][1], e],
              ])),
            (c = hr(c, [
              ["enter", i, e],
              ["enter", s, e],
              ["exit", s, e],
              ["enter", o, e],
            ])),
            (c = hr(c, dm(e.parser.constructs.insideSpan.null, t.slice(r + 1, n), e))),
            (c = hr(c, [
              ["exit", o, e],
              ["enter", l, e],
              ["exit", l, e],
              ["exit", i, e],
            ])),
            t[n][1].end.offset - t[n][1].start.offset
              ? ((u = 2),
                (c = hr(c, [
                  ["enter", t[n][1], e],
                  ["exit", t[n][1], e],
                ])))
              : (u = 0),
            gr(t, r - 1, n - r + 3, c),
            (n = r + c.length - u - 2);
          break;
        }
    }
  for (n = -1; ++n < t.length; ) t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
  return t;
}
function oF(t, e) {
  const n = this.parser.constructs.attentionMarkers.null,
    r = this.previous,
    i = If(r);
  let o;
  return s;
  function s(a) {
    return (o = a), t.enter("attentionSequence"), l(a);
  }
  function l(a) {
    if (a === o) return t.consume(a), l;
    const c = t.exit("attentionSequence"),
      u = If(a),
      h = !u || (u === 2 && i) || n.includes(a),
      d = !i || (i === 2 && u) || n.includes(r);
    return (c._open = !!(o === 42 ? h : h && (i || !d))), (c._close = !!(o === 42 ? d : d && (u || !h))), e(a);
  }
}
function Mk(t, e) {
  (t.column += e), (t.offset += e), (t._bufferIndex += e);
}
const sF = { name: "autolink", tokenize: lF };
function lF(t, e, n) {
  let r = 0;
  return i;
  function i(f) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(f), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), o;
  }
  function o(f) {
    return tr(f) ? (t.consume(f), s) : f === 64 ? n(f) : c(f);
  }
  function s(f) {
    return f === 43 || f === 45 || f === 46 || rr(f) ? ((r = 1), l(f)) : c(f);
  }
  function l(f) {
    return f === 58
      ? (t.consume(f), (r = 0), a)
      : (f === 43 || f === 45 || f === 46 || rr(f)) && r++ < 32
      ? (t.consume(f), l)
      : ((r = 0), c(f));
  }
  function a(f) {
    return f === 62
      ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(f), t.exit("autolinkMarker"), t.exit("autolink"), e)
      : f === null || f === 32 || f === 60 || D0(f)
      ? n(f)
      : (t.consume(f), a);
  }
  function c(f) {
    return f === 64 ? (t.consume(f), u) : WN(f) ? (t.consume(f), c) : n(f);
  }
  function u(f) {
    return rr(f) ? h(f) : n(f);
  }
  function h(f) {
    return f === 46
      ? (t.consume(f), (r = 0), u)
      : f === 62
      ? ((t.exit("autolinkProtocol").type = "autolinkEmail"),
        t.enter("autolinkMarker"),
        t.consume(f),
        t.exit("autolinkMarker"),
        t.exit("autolink"),
        e)
      : d(f);
  }
  function d(f) {
    if ((f === 45 || rr(f)) && r++ < 63) {
      const p = f === 45 ? d : h;
      return t.consume(f), p;
    }
    return n(f);
  }
}
const th = { tokenize: aF, partial: !0 };
function aF(t, e, n) {
  return r;
  function r(o) {
    return Pe(o) ? Re(t, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || de(o) ? e(o) : n(o);
  }
}
const GP = { name: "blockQuote", tokenize: cF, continuation: { tokenize: uF }, exit: hF };
function cF(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const l = r.containerState;
      return (
        l.open || (t.enter("blockQuote", { _container: !0 }), (l.open = !0)),
        t.enter("blockQuotePrefix"),
        t.enter("blockQuoteMarker"),
        t.consume(s),
        t.exit("blockQuoteMarker"),
        o
      );
    }
    return n(s);
  }
  function o(s) {
    return Pe(s)
      ? (t.enter("blockQuotePrefixWhitespace"), t.consume(s), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e)
      : (t.exit("blockQuotePrefix"), e(s));
  }
}
function uF(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    return Pe(s) ? Re(t, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : o(s);
  }
  function o(s) {
    return t.attempt(GP, e, n)(s);
  }
}
function hF(t) {
  t.exit("blockQuote");
}
const JP = { name: "characterEscape", tokenize: dF };
function dF(t, e, n) {
  return r;
  function r(o) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(o), t.exit("escapeMarker"), i;
  }
  function i(o) {
    return UN(o) ? (t.enter("characterEscapeValue"), t.consume(o), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(o);
  }
}
const KP = { name: "characterReference", tokenize: fF };
function fF(t, e, n) {
  const r = this;
  let i = 0,
    o,
    s;
  return l;
  function l(h) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), a;
  }
  function a(h) {
    return h === 35
      ? (t.enter("characterReferenceMarkerNumeric"), t.consume(h), t.exit("characterReferenceMarkerNumeric"), c)
      : (t.enter("characterReferenceValue"), (o = 31), (s = rr), u(h));
  }
  function c(h) {
    return h === 88 || h === 120
      ? (t.enter("characterReferenceMarkerHexadecimal"),
        t.consume(h),
        t.exit("characterReferenceMarkerHexadecimal"),
        t.enter("characterReferenceValue"),
        (o = 6),
        (s = XN),
        u)
      : (t.enter("characterReferenceValue"), (o = 7), (s = F0), u(h));
  }
  function u(h) {
    if (h === 59 && i) {
      const d = t.exit("characterReferenceValue");
      return s === rr && !nu(r.sliceSerialize(d))
        ? n(h)
        : (t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), t.exit("characterReference"), e);
    }
    return s(h) && i++ < o ? (t.consume(h), u) : n(h);
  }
}
const Lk = { tokenize: mF, partial: !0 },
  Nk = { name: "codeFenced", tokenize: pF, concrete: !0 };
function pF(t, e, n) {
  const r = this,
    i = { tokenize: k, partial: !0 };
  let o = 0,
    s = 0,
    l;
  return a;
  function a(w) {
    return c(w);
  }
  function c(w) {
    const y = r.events[r.events.length - 1];
    return (
      (o = y && y[1].type === "linePrefix" ? y[2].sliceSerialize(y[1], !0).length : 0),
      (l = w),
      t.enter("codeFenced"),
      t.enter("codeFencedFence"),
      t.enter("codeFencedFenceSequence"),
      u(w)
    );
  }
  function u(w) {
    return w === l ? (s++, t.consume(w), u) : s < 3 ? n(w) : (t.exit("codeFencedFenceSequence"), Pe(w) ? Re(t, h, "whitespace")(w) : h(w));
  }
  function h(w) {
    return w === null || de(w)
      ? (t.exit("codeFencedFence"), r.interrupt ? e(w) : t.check(Lk, m, x)(w))
      : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", { contentType: "string" }), d(w));
  }
  function d(w) {
    return w === null || de(w)
      ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), h(w))
      : Pe(w)
      ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), Re(t, f, "whitespace")(w))
      : w === 96 && w === l
      ? n(w)
      : (t.consume(w), d);
  }
  function f(w) {
    return w === null || de(w) ? h(w) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", { contentType: "string" }), p(w));
  }
  function p(w) {
    return w === null || de(w)
      ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), h(w))
      : w === 96 && w === l
      ? n(w)
      : (t.consume(w), p);
  }
  function m(w) {
    return t.attempt(i, x, O)(w);
  }
  function O(w) {
    return t.enter("lineEnding"), t.consume(w), t.exit("lineEnding"), v;
  }
  function v(w) {
    return o > 0 && Pe(w) ? Re(t, g, "linePrefix", o + 1)(w) : g(w);
  }
  function g(w) {
    return w === null || de(w) ? t.check(Lk, m, x)(w) : (t.enter("codeFlowValue"), b(w));
  }
  function b(w) {
    return w === null || de(w) ? (t.exit("codeFlowValue"), g(w)) : (t.consume(w), b);
  }
  function x(w) {
    return t.exit("codeFenced"), e(w);
  }
  function k(w, y, C) {
    let P = 0;
    return E;
    function E(R) {
      return w.enter("lineEnding"), w.consume(R), w.exit("lineEnding"), N;
    }
    function N(R) {
      return (
        w.enter("codeFencedFence"),
        Pe(R) ? Re(w, L, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : L(R)
      );
    }
    function L(R) {
      return R === l ? (w.enter("codeFencedFenceSequence"), D(R)) : C(R);
    }
    function D(R) {
      return R === l
        ? (P++, w.consume(R), D)
        : P >= s
        ? (w.exit("codeFencedFenceSequence"), Pe(R) ? Re(w, Q, "whitespace")(R) : Q(R))
        : C(R);
    }
    function Q(R) {
      return R === null || de(R) ? (w.exit("codeFencedFence"), y(R)) : C(R);
    }
  }
}
function mF(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), o);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : e(s);
  }
}
const Dg = { name: "codeIndented", tokenize: OF },
  gF = { tokenize: vF, partial: !0 };
function OF(t, e, n) {
  const r = this;
  return i;
  function i(c) {
    return t.enter("codeIndented"), Re(t, o, "linePrefix", 4 + 1)(c);
  }
  function o(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? s(c) : n(c);
  }
  function s(c) {
    return c === null ? a(c) : de(c) ? t.attempt(gF, s, a)(c) : (t.enter("codeFlowValue"), l(c));
  }
  function l(c) {
    return c === null || de(c) ? (t.exit("codeFlowValue"), s(c)) : (t.consume(c), l);
  }
  function a(c) {
    return t.exit("codeIndented"), e(c);
  }
}
function vF(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line]
      ? n(s)
      : de(s)
      ? (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), i)
      : Re(t, o, "linePrefix", 4 + 1)(s);
  }
  function o(s) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(s) : de(s) ? i(s) : n(s);
  }
}
const bF = { name: "codeText", tokenize: wF, resolve: xF, previous: yF };
function xF(t) {
  let e = t.length - 4,
    n = 3,
    r,
    i;
  if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
    for (r = n; ++r < e; )
      if (t[r][1].type === "codeTextData") {
        (t[n][1].type = "codeTextPadding"), (t[e][1].type = "codeTextPadding"), (n += 2), (e -= 2);
        break;
      }
  }
  for (r = n - 1, e++; ++r <= e; )
    i === void 0
      ? r !== e && t[r][1].type !== "lineEnding" && (i = r)
      : (r === e || t[r][1].type === "lineEnding") &&
        ((t[i][1].type = "codeTextData"),
        r !== i + 2 && ((t[i][1].end = t[r - 1][1].end), t.splice(i + 2, r - i - 2), (e -= r - i - 2), (r = i + 2)),
        (i = void 0));
  return t;
}
function yF(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function wF(t, e, n) {
  let r = 0,
    i,
    o;
  return s;
  function s(h) {
    return t.enter("codeText"), t.enter("codeTextSequence"), l(h);
  }
  function l(h) {
    return h === 96 ? (t.consume(h), r++, l) : (t.exit("codeTextSequence"), a(h));
  }
  function a(h) {
    return h === null
      ? n(h)
      : h === 32
      ? (t.enter("space"), t.consume(h), t.exit("space"), a)
      : h === 96
      ? ((o = t.enter("codeTextSequence")), (i = 0), u(h))
      : de(h)
      ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), a)
      : (t.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || de(h) ? (t.exit("codeTextData"), a(h)) : (t.consume(h), c);
  }
  function u(h) {
    return h === 96
      ? (t.consume(h), i++, u)
      : i === r
      ? (t.exit("codeTextSequence"), t.exit("codeText"), e(h))
      : ((o.type = "codeTextData"), c(h));
  }
}
class SF {
  constructor(e) {
    (this.left = e ? [...e] : []), (this.right = []);
  }
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  get length() {
    return this.left.length + this.right.length;
  }
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  slice(e, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length
      ? this.left.slice(e, r)
      : e > this.left.length
      ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse()
      : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  splice(e, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(e));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && ec(this.left, r), o.reverse();
  }
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), ec(this.left, e);
  }
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  unshiftMany(e) {
    this.setCursor(0), ec(this.right, e.reverse());
  }
  setCursor(e) {
    if (!(e === this.left.length || (e > this.left.length && this.right.length === 0) || (e < 0 && this.left.length === 0)))
      if (e < this.left.length) {
        const n = this.left.splice(e, Number.POSITIVE_INFINITY);
        ec(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        ec(this.left, n.reverse());
      }
  }
}
function ec(t, e) {
  let n = 0;
  if (e.length < 1e4) t.push(...e);
  else for (; n < e.length; ) t.push(...e.slice(n, n + 1e4)), (n += 1e4);
}
function eA(t) {
  const e = {};
  let n = -1,
    r,
    i,
    o,
    s,
    l,
    a,
    c;
  const u = new SF(t);
  for (; ++n < u.length; ) {
    for (; n in e; ) n = e[n];
    if (
      ((r = u.get(n)),
      n &&
        r[1].type === "chunkFlow" &&
        u.get(n - 1)[1].type === "listItemPrefix" &&
        ((a = r[1]._tokenizer.events),
        (o = 0),
        o < a.length && a[o][1].type === "lineEndingBlank" && (o += 2),
        o < a.length && a[o][1].type === "content"))
    )
      for (; ++o < a.length && a[o][1].type !== "content"; )
        a[o][1].type === "chunkText" && ((a[o][1]._isInFirstContentOfListItem = !0), o++);
    if (r[0] === "enter") r[1].contentType && (Object.assign(e, kF(u, n)), (n = e[n]), (c = !0));
    else if (r[1]._container) {
      for (o = n, i = void 0; o-- && ((s = u.get(o)), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank"); )
        s[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), (s[1].type = "lineEnding"), (i = o));
      i && ((r[1].end = Object.assign({}, u.get(i)[1].start)), (l = u.slice(i, n)), l.unshift(r), u.splice(i, n - i + 1, l));
    }
  }
  return gr(t, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function kF(t, e) {
  const n = t.get(e)[1],
    r = t.get(e)[2];
  let i = e - 1;
  const o = [],
    s = n._tokenizer || r.parser[n.contentType](n.start),
    l = s.events,
    a = [],
    c = {};
  let u,
    h,
    d = -1,
    f = n,
    p = 0,
    m = 0;
  const O = [m];
  for (; f; ) {
    for (; t.get(++i)[1] !== f; );
    o.push(i),
      f._tokenizer ||
        ((u = r.sliceStream(f)),
        f.next || u.push(null),
        h && s.defineSkip(f.start),
        f._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0),
        s.write(u),
        f._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)),
      (h = f),
      (f = f.next);
  }
  for (f = n; ++d < l.length; )
    l[d][0] === "exit" &&
      l[d - 1][0] === "enter" &&
      l[d][1].type === l[d - 1][1].type &&
      l[d][1].start.line !== l[d][1].end.line &&
      ((m = d + 1), O.push(m), (f._tokenizer = void 0), (f.previous = void 0), (f = f.next));
  for (s.events = [], f ? ((f._tokenizer = void 0), (f.previous = void 0)) : O.pop(), d = O.length; d--; ) {
    const v = l.slice(O[d], O[d + 1]),
      g = o.pop();
    a.push([g, g + v.length - 1]), t.splice(g, 2, v);
  }
  for (a.reverse(), d = -1; ++d < a.length; ) (c[p + a[d][0]] = p + a[d][1]), (p += a[d][1] - a[d][0] - 1);
  return c;
}
const CF = { tokenize: TF, resolve: EF },
  _F = { tokenize: PF, partial: !0 };
function EF(t) {
  return eA(t), t;
}
function TF(t, e) {
  let n;
  return r;
  function r(l) {
    return t.enter("content"), (n = t.enter("chunkContent", { contentType: "content" })), i(l);
  }
  function i(l) {
    return l === null ? o(l) : de(l) ? t.check(_F, s, o)(l) : (t.consume(l), i);
  }
  function o(l) {
    return t.exit("chunkContent"), t.exit("content"), e(l);
  }
  function s(l) {
    return (
      t.consume(l), t.exit("chunkContent"), (n.next = t.enter("chunkContent", { contentType: "content", previous: n })), (n = n.next), i
    );
  }
}
function PF(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), Re(t, o, "linePrefix");
  }
  function o(s) {
    if (s === null || de(s)) return n(s);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") &&
      l &&
      l[1].type === "linePrefix" &&
      l[2].sliceSerialize(l[1], !0).length >= 4
      ? e(s)
      : t.interrupt(r.parser.constructs.flow, n, e)(s);
  }
}
function tA(t, e, n, r, i, o, s, l, a) {
  const c = a || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(v) {
    return v === 60
      ? (t.enter(r), t.enter(i), t.enter(o), t.consume(v), t.exit(o), d)
      : v === null || v === 32 || v === 41 || D0(v)
      ? n(v)
      : (t.enter(r), t.enter(s), t.enter(l), t.enter("chunkString", { contentType: "string" }), m(v));
  }
  function d(v) {
    return v === 62
      ? (t.enter(o), t.consume(v), t.exit(o), t.exit(i), t.exit(r), e)
      : (t.enter(l), t.enter("chunkString", { contentType: "string" }), f(v));
  }
  function f(v) {
    return v === 62 ? (t.exit("chunkString"), t.exit(l), d(v)) : v === null || v === 60 || de(v) ? n(v) : (t.consume(v), v === 92 ? p : f);
  }
  function p(v) {
    return v === 60 || v === 62 || v === 92 ? (t.consume(v), f) : f(v);
  }
  function m(v) {
    return !u && (v === null || v === 41 || Ke(v))
      ? (t.exit("chunkString"), t.exit(l), t.exit(s), t.exit(r), e(v))
      : u < c && v === 40
      ? (t.consume(v), u++, m)
      : v === 41
      ? (t.consume(v), u--, m)
      : v === null || v === 32 || v === 40 || D0(v)
      ? n(v)
      : (t.consume(v), v === 92 ? O : m);
  }
  function O(v) {
    return v === 40 || v === 41 || v === 92 ? (t.consume(v), m) : m(v);
  }
}
function nA(t, e, n, r, i, o) {
  const s = this;
  let l = 0,
    a;
  return c;
  function c(f) {
    return t.enter(r), t.enter(i), t.consume(f), t.exit(i), t.enter(o), u;
  }
  function u(f) {
    return l > 999 || f === null || f === 91 || (f === 93 && !a) || (f === 94 && !l && "_hiddenFootnoteSupport" in s.parser.constructs)
      ? n(f)
      : f === 93
      ? (t.exit(o), t.enter(i), t.consume(f), t.exit(i), t.exit(r), e)
      : de(f)
      ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), u)
      : (t.enter("chunkString", { contentType: "string" }), h(f));
  }
  function h(f) {
    return f === null || f === 91 || f === 93 || de(f) || l++ > 999
      ? (t.exit("chunkString"), u(f))
      : (t.consume(f), a || (a = !Pe(f)), f === 92 ? d : h);
  }
  function d(f) {
    return f === 91 || f === 92 || f === 93 ? (t.consume(f), l++, h) : h(f);
  }
}
function rA(t, e, n, r, i, o) {
  let s;
  return l;
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? (t.enter(r), t.enter(i), t.consume(d), t.exit(i), (s = d === 40 ? 41 : d), a) : n(d);
  }
  function a(d) {
    return d === s ? (t.enter(i), t.consume(d), t.exit(i), t.exit(r), e) : (t.enter(o), c(d));
  }
  function c(d) {
    return d === s
      ? (t.exit(o), a(s))
      : d === null
      ? n(d)
      : de(d)
      ? (t.enter("lineEnding"), t.consume(d), t.exit("lineEnding"), Re(t, c, "linePrefix"))
      : (t.enter("chunkString", { contentType: "string" }), u(d));
  }
  function u(d) {
    return d === s || d === null || de(d) ? (t.exit("chunkString"), c(d)) : (t.consume(d), d === 92 ? h : u);
  }
  function h(d) {
    return d === s || d === 92 ? (t.consume(d), u) : u(d);
  }
}
function Ni(t, e) {
  let n;
  return r;
  function r(i) {
    return de(i)
      ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), (n = !0), r)
      : Pe(i)
      ? Re(t, r, n ? "linePrefix" : "lineSuffix")(i)
      : e(i);
  }
}
const AF = { name: "definition", tokenize: RF },
  $F = { tokenize: IF, partial: !0 };
function RF(t, e, n) {
  const r = this;
  let i;
  return o;
  function o(f) {
    return t.enter("definition"), s(f);
  }
  function s(f) {
    return nA.call(r, t, l, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(f);
  }
  function l(f) {
    return (
      (i = El(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))),
      f === 58 ? (t.enter("definitionMarker"), t.consume(f), t.exit("definitionMarker"), a) : n(f)
    );
  }
  function a(f) {
    return Ke(f) ? Ni(t, c)(f) : c(f);
  }
  function c(f) {
    return tA(
      t,
      u,
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(f);
  }
  function u(f) {
    return t.attempt($F, h, h)(f);
  }
  function h(f) {
    return Pe(f) ? Re(t, d, "whitespace")(f) : d(f);
  }
  function d(f) {
    return f === null || de(f) ? (t.exit("definition"), r.parser.defined.push(i), e(f)) : n(f);
  }
}
function IF(t, e, n) {
  return r;
  function r(l) {
    return Ke(l) ? Ni(t, i)(l) : n(l);
  }
  function i(l) {
    return rA(t, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function o(l) {
    return Pe(l) ? Re(t, s, "whitespace")(l) : s(l);
  }
  function s(l) {
    return l === null || de(l) ? e(l) : n(l);
  }
}
const MF = { name: "hardBreakEscape", tokenize: LF };
function LF(t, e, n) {
  return r;
  function r(o) {
    return t.enter("hardBreakEscape"), t.consume(o), i;
  }
  function i(o) {
    return de(o) ? (t.exit("hardBreakEscape"), e(o)) : n(o);
  }
}
const NF = { name: "headingAtx", tokenize: DF, resolve: QF };
function QF(t, e) {
  let n = t.length - 2,
    r = 3,
    i,
    o;
  return (
    t[r][1].type === "whitespace" && (r += 2),
    n - 2 > r && t[n][1].type === "whitespace" && (n -= 2),
    t[n][1].type === "atxHeadingSequence" &&
      (r === n - 1 || (n - 4 > r && t[n - 2][1].type === "whitespace")) &&
      (n -= r + 1 === n ? 2 : 4),
    n > r &&
      ((i = { type: "atxHeadingText", start: t[r][1].start, end: t[n][1].end }),
      (o = { type: "chunkText", start: t[r][1].start, end: t[n][1].end, contentType: "text" }),
      gr(t, r, n - r + 1, [
        ["enter", i, e],
        ["enter", o, e],
        ["exit", o, e],
        ["exit", i, e],
      ])),
    t
  );
}
function DF(t, e, n) {
  let r = 0;
  return i;
  function i(u) {
    return t.enter("atxHeading"), o(u);
  }
  function o(u) {
    return t.enter("atxHeadingSequence"), s(u);
  }
  function s(u) {
    return u === 35 && r++ < 6 ? (t.consume(u), s) : u === null || Ke(u) ? (t.exit("atxHeadingSequence"), l(u)) : n(u);
  }
  function l(u) {
    return u === 35
      ? (t.enter("atxHeadingSequence"), a(u))
      : u === null || de(u)
      ? (t.exit("atxHeading"), e(u))
      : Pe(u)
      ? Re(t, l, "whitespace")(u)
      : (t.enter("atxHeadingText"), c(u));
  }
  function a(u) {
    return u === 35 ? (t.consume(u), a) : (t.exit("atxHeadingSequence"), l(u));
  }
  function c(u) {
    return u === null || u === 35 || Ke(u) ? (t.exit("atxHeadingText"), l(u)) : (t.consume(u), c);
  }
}
const FF = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul",
  ],
  Qk = ["pre", "script", "style", "textarea"],
  BF = { name: "htmlFlow", tokenize: zF, resolveTo: ZF, concrete: !0 },
  VF = { tokenize: XF, partial: !0 },
  jF = { tokenize: WF, partial: !0 };
function ZF(t) {
  let e = t.length;
  for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); );
  return (
    e > 1 &&
      t[e - 2][1].type === "linePrefix" &&
      ((t[e][1].start = t[e - 2][1].start), (t[e + 1][1].start = t[e - 2][1].start), t.splice(e - 2, 2)),
    t
  );
}
function zF(t, e, n) {
  const r = this;
  let i, o, s, l, a;
  return c;
  function c(M) {
    return u(M);
  }
  function u(M) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(M), h;
  }
  function h(M) {
    return M === 33
      ? (t.consume(M), d)
      : M === 47
      ? (t.consume(M), (o = !0), m)
      : M === 63
      ? (t.consume(M), (i = 3), r.interrupt ? e : A)
      : tr(M)
      ? (t.consume(M), (s = String.fromCharCode(M)), O)
      : n(M);
  }
  function d(M) {
    return M === 45
      ? (t.consume(M), (i = 2), f)
      : M === 91
      ? (t.consume(M), (i = 5), (l = 0), p)
      : tr(M)
      ? (t.consume(M), (i = 4), r.interrupt ? e : A)
      : n(M);
  }
  function f(M) {
    return M === 45 ? (t.consume(M), r.interrupt ? e : A) : n(M);
  }
  function p(M) {
    const fe = "CDATA[";
    return M === fe.charCodeAt(l++) ? (t.consume(M), l === fe.length ? (r.interrupt ? e : L) : p) : n(M);
  }
  function m(M) {
    return tr(M) ? (t.consume(M), (s = String.fromCharCode(M)), O) : n(M);
  }
  function O(M) {
    if (M === null || M === 47 || M === 62 || Ke(M)) {
      const fe = M === 47,
        Se = s.toLowerCase();
      return !fe && !o && Qk.includes(Se)
        ? ((i = 1), r.interrupt ? e(M) : L(M))
        : FF.includes(s.toLowerCase())
        ? ((i = 6), fe ? (t.consume(M), v) : r.interrupt ? e(M) : L(M))
        : ((i = 7), r.interrupt && !r.parser.lazy[r.now().line] ? n(M) : o ? g(M) : b(M));
    }
    return M === 45 || rr(M) ? (t.consume(M), (s += String.fromCharCode(M)), O) : n(M);
  }
  function v(M) {
    return M === 62 ? (t.consume(M), r.interrupt ? e : L) : n(M);
  }
  function g(M) {
    return Pe(M) ? (t.consume(M), g) : E(M);
  }
  function b(M) {
    return M === 47 ? (t.consume(M), E) : M === 58 || M === 95 || tr(M) ? (t.consume(M), x) : Pe(M) ? (t.consume(M), b) : E(M);
  }
  function x(M) {
    return M === 45 || M === 46 || M === 58 || M === 95 || rr(M) ? (t.consume(M), x) : k(M);
  }
  function k(M) {
    return M === 61 ? (t.consume(M), w) : Pe(M) ? (t.consume(M), k) : b(M);
  }
  function w(M) {
    return M === null || M === 60 || M === 61 || M === 62 || M === 96
      ? n(M)
      : M === 34 || M === 39
      ? (t.consume(M), (a = M), y)
      : Pe(M)
      ? (t.consume(M), w)
      : C(M);
  }
  function y(M) {
    return M === a ? (t.consume(M), (a = null), P) : M === null || de(M) ? n(M) : (t.consume(M), y);
  }
  function C(M) {
    return M === null || M === 34 || M === 39 || M === 47 || M === 60 || M === 61 || M === 62 || M === 96 || Ke(M)
      ? k(M)
      : (t.consume(M), C);
  }
  function P(M) {
    return M === 47 || M === 62 || Pe(M) ? b(M) : n(M);
  }
  function E(M) {
    return M === 62 ? (t.consume(M), N) : n(M);
  }
  function N(M) {
    return M === null || de(M) ? L(M) : Pe(M) ? (t.consume(M), N) : n(M);
  }
  function L(M) {
    return M === 45 && i === 2
      ? (t.consume(M), W)
      : M === 60 && i === 1
      ? (t.consume(M), B)
      : M === 62 && i === 4
      ? (t.consume(M), V)
      : M === 63 && i === 3
      ? (t.consume(M), A)
      : M === 93 && i === 5
      ? (t.consume(M), ne)
      : de(M) && (i === 6 || i === 7)
      ? (t.exit("htmlFlowData"), t.check(VF, ie, D)(M))
      : M === null || de(M)
      ? (t.exit("htmlFlowData"), D(M))
      : (t.consume(M), L);
  }
  function D(M) {
    return t.check(jF, Q, ie)(M);
  }
  function Q(M) {
    return t.enter("lineEnding"), t.consume(M), t.exit("lineEnding"), R;
  }
  function R(M) {
    return M === null || de(M) ? D(M) : (t.enter("htmlFlowData"), L(M));
  }
  function W(M) {
    return M === 45 ? (t.consume(M), A) : L(M);
  }
  function B(M) {
    return M === 47 ? (t.consume(M), (s = ""), K) : L(M);
  }
  function K(M) {
    if (M === 62) {
      const fe = s.toLowerCase();
      return Qk.includes(fe) ? (t.consume(M), V) : L(M);
    }
    return tr(M) && s.length < 8 ? (t.consume(M), (s += String.fromCharCode(M)), K) : L(M);
  }
  function ne(M) {
    return M === 93 ? (t.consume(M), A) : L(M);
  }
  function A(M) {
    return M === 62 ? (t.consume(M), V) : M === 45 && i === 2 ? (t.consume(M), A) : L(M);
  }
  function V(M) {
    return M === null || de(M) ? (t.exit("htmlFlowData"), ie(M)) : (t.consume(M), V);
  }
  function ie(M) {
    return t.exit("htmlFlow"), e(M);
  }
}
function WF(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    return de(s) ? (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), o) : n(s);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : e(s);
  }
}
function XF(t, e, n) {
  return r;
  function r(i) {
    return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), t.attempt(th, e, n);
  }
}
const UF = { name: "htmlText", tokenize: HF };
function HF(t, e, n) {
  const r = this;
  let i, o, s;
  return l;
  function l(A) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(A), a;
  }
  function a(A) {
    return A === 33 ? (t.consume(A), c) : A === 47 ? (t.consume(A), k) : A === 63 ? (t.consume(A), b) : tr(A) ? (t.consume(A), C) : n(A);
  }
  function c(A) {
    return A === 45 ? (t.consume(A), u) : A === 91 ? (t.consume(A), (o = 0), p) : tr(A) ? (t.consume(A), g) : n(A);
  }
  function u(A) {
    return A === 45 ? (t.consume(A), f) : n(A);
  }
  function h(A) {
    return A === null ? n(A) : A === 45 ? (t.consume(A), d) : de(A) ? ((s = h), B(A)) : (t.consume(A), h);
  }
  function d(A) {
    return A === 45 ? (t.consume(A), f) : h(A);
  }
  function f(A) {
    return A === 62 ? W(A) : A === 45 ? d(A) : h(A);
  }
  function p(A) {
    const V = "CDATA[";
    return A === V.charCodeAt(o++) ? (t.consume(A), o === V.length ? m : p) : n(A);
  }
  function m(A) {
    return A === null ? n(A) : A === 93 ? (t.consume(A), O) : de(A) ? ((s = m), B(A)) : (t.consume(A), m);
  }
  function O(A) {
    return A === 93 ? (t.consume(A), v) : m(A);
  }
  function v(A) {
    return A === 62 ? W(A) : A === 93 ? (t.consume(A), v) : m(A);
  }
  function g(A) {
    return A === null || A === 62 ? W(A) : de(A) ? ((s = g), B(A)) : (t.consume(A), g);
  }
  function b(A) {
    return A === null ? n(A) : A === 63 ? (t.consume(A), x) : de(A) ? ((s = b), B(A)) : (t.consume(A), b);
  }
  function x(A) {
    return A === 62 ? W(A) : b(A);
  }
  function k(A) {
    return tr(A) ? (t.consume(A), w) : n(A);
  }
  function w(A) {
    return A === 45 || rr(A) ? (t.consume(A), w) : y(A);
  }
  function y(A) {
    return de(A) ? ((s = y), B(A)) : Pe(A) ? (t.consume(A), y) : W(A);
  }
  function C(A) {
    return A === 45 || rr(A) ? (t.consume(A), C) : A === 47 || A === 62 || Ke(A) ? P(A) : n(A);
  }
  function P(A) {
    return A === 47
      ? (t.consume(A), W)
      : A === 58 || A === 95 || tr(A)
      ? (t.consume(A), E)
      : de(A)
      ? ((s = P), B(A))
      : Pe(A)
      ? (t.consume(A), P)
      : W(A);
  }
  function E(A) {
    return A === 45 || A === 46 || A === 58 || A === 95 || rr(A) ? (t.consume(A), E) : N(A);
  }
  function N(A) {
    return A === 61 ? (t.consume(A), L) : de(A) ? ((s = N), B(A)) : Pe(A) ? (t.consume(A), N) : P(A);
  }
  function L(A) {
    return A === null || A === 60 || A === 61 || A === 62 || A === 96
      ? n(A)
      : A === 34 || A === 39
      ? (t.consume(A), (i = A), D)
      : de(A)
      ? ((s = L), B(A))
      : Pe(A)
      ? (t.consume(A), L)
      : (t.consume(A), Q);
  }
  function D(A) {
    return A === i ? (t.consume(A), (i = void 0), R) : A === null ? n(A) : de(A) ? ((s = D), B(A)) : (t.consume(A), D);
  }
  function Q(A) {
    return A === null || A === 34 || A === 39 || A === 60 || A === 61 || A === 96
      ? n(A)
      : A === 47 || A === 62 || Ke(A)
      ? P(A)
      : (t.consume(A), Q);
  }
  function R(A) {
    return A === 47 || A === 62 || Ke(A) ? P(A) : n(A);
  }
  function W(A) {
    return A === 62 ? (t.consume(A), t.exit("htmlTextData"), t.exit("htmlText"), e) : n(A);
  }
  function B(A) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(A), t.exit("lineEnding"), K;
  }
  function K(A) {
    return Pe(A) ? Re(t, ne, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(A) : ne(A);
  }
  function ne(A) {
    return t.enter("htmlTextData"), s(A);
  }
}
const Xb = { name: "labelEnd", tokenize: eB, resolveTo: KF, resolveAll: JF },
  qF = { tokenize: tB },
  YF = { tokenize: nB },
  GF = { tokenize: rB };
function JF(t) {
  let e = -1;
  for (; ++e < t.length; ) {
    const n = t[e][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") &&
      (t.splice(e + 1, n.type === "labelImage" ? 4 : 2), (n.type = "data"), e++);
  }
  return t;
}
function KF(t, e) {
  let n = t.length,
    r = 0,
    i,
    o,
    s,
    l;
  for (; n--; )
    if (((i = t[n][1]), o)) {
      if (i.type === "link" || (i.type === "labelLink" && i._inactive)) break;
      t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && ((o = n), i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const a = {
      type: t[o][1].type === "labelLink" ? "link" : "image",
      start: Object.assign({}, t[o][1].start),
      end: Object.assign({}, t[t.length - 1][1].end),
    },
    c = { type: "label", start: Object.assign({}, t[o][1].start), end: Object.assign({}, t[s][1].end) },
    u = { type: "labelText", start: Object.assign({}, t[o + r + 2][1].end), end: Object.assign({}, t[s - 2][1].start) };
  return (
    (l = [
      ["enter", a, e],
      ["enter", c, e],
    ]),
    (l = hr(l, t.slice(o + 1, o + r + 3))),
    (l = hr(l, [["enter", u, e]])),
    (l = hr(l, dm(e.parser.constructs.insideSpan.null, t.slice(o + r + 4, s - 3), e))),
    (l = hr(l, [["exit", u, e], t[s - 2], t[s - 1], ["exit", c, e]])),
    (l = hr(l, t.slice(s + 1))),
    (l = hr(l, [["exit", a, e]])),
    gr(t, o, t.length, l),
    t
  );
}
function eB(t, e, n) {
  const r = this;
  let i = r.events.length,
    o,
    s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return l;
  function l(d) {
    return o
      ? o._inactive
        ? h(d)
        : ((s = r.parser.defined.includes(El(r.sliceSerialize({ start: o.end, end: r.now() })))),
          t.enter("labelEnd"),
          t.enter("labelMarker"),
          t.consume(d),
          t.exit("labelMarker"),
          t.exit("labelEnd"),
          a)
      : n(d);
  }
  function a(d) {
    return d === 40 ? t.attempt(qF, u, s ? u : h)(d) : d === 91 ? t.attempt(YF, u, s ? c : h)(d) : s ? u(d) : h(d);
  }
  function c(d) {
    return t.attempt(GF, u, h)(d);
  }
  function u(d) {
    return e(d);
  }
  function h(d) {
    return (o._balanced = !0), n(d);
  }
}
function tB(t, e, n) {
  return r;
  function r(h) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), i;
  }
  function i(h) {
    return Ke(h) ? Ni(t, o)(h) : o(h);
  }
  function o(h) {
    return h === 41
      ? u(h)
      : tA(
          t,
          s,
          l,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          32
        )(h);
  }
  function s(h) {
    return Ke(h) ? Ni(t, a)(h) : u(h);
  }
  function l(h) {
    return n(h);
  }
  function a(h) {
    return h === 34 || h === 39 || h === 40 ? rA(t, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return Ke(h) ? Ni(t, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), t.exit("resource"), e) : n(h);
  }
}
function nB(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return nA.call(r, t, o, s, "reference", "referenceMarker", "referenceString")(l);
  }
  function o(l) {
    return r.parser.defined.includes(El(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(l) : n(l);
  }
  function s(l) {
    return n(l);
  }
}
function rB(t, e, n) {
  return r;
  function r(o) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(o), t.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (t.enter("referenceMarker"), t.consume(o), t.exit("referenceMarker"), t.exit("reference"), e) : n(o);
  }
}
const iB = { name: "labelStartImage", tokenize: oB, resolveAll: Xb.resolveAll };
function oB(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(l), t.exit("labelImageMarker"), o;
  }
  function o(l) {
    return l === 91 ? (t.enter("labelMarker"), t.consume(l), t.exit("labelMarker"), t.exit("labelImage"), s) : n(l);
  }
  function s(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(l) : e(l);
  }
}
const sB = { name: "labelStartLink", tokenize: lB, resolveAll: Xb.resolveAll };
function lB(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(s), t.exit("labelMarker"), t.exit("labelLink"), o;
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : e(s);
  }
}
const Fg = { name: "lineEnding", tokenize: aB };
function aB(t, e) {
  return n;
  function n(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), Re(t, e, "linePrefix");
  }
}
const Hd = { name: "thematicBreak", tokenize: cB };
function cB(t, e, n) {
  let r = 0,
    i;
  return o;
  function o(c) {
    return t.enter("thematicBreak"), s(c);
  }
  function s(c) {
    return (i = c), l(c);
  }
  function l(c) {
    return c === i ? (t.enter("thematicBreakSequence"), a(c)) : r >= 3 && (c === null || de(c)) ? (t.exit("thematicBreak"), e(c)) : n(c);
  }
  function a(c) {
    return c === i ? (t.consume(c), r++, a) : (t.exit("thematicBreakSequence"), Pe(c) ? Re(t, l, "whitespace")(c) : l(c));
  }
}
const Nn = { name: "list", tokenize: dB, continuation: { tokenize: fB }, exit: mB },
  uB = { tokenize: gB, partial: !0 },
  hB = { tokenize: pB, partial: !0 };
function dB(t, e, n) {
  const r = this,
    i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0,
    s = 0;
  return l;
  function l(f) {
    const p = r.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || f === r.containerState.marker : F0(f)) {
      if ((r.containerState.type || ((r.containerState.type = p), t.enter(p, { _container: !0 })), p === "listUnordered"))
        return t.enter("listItemPrefix"), f === 42 || f === 45 ? t.check(Hd, n, c)(f) : c(f);
      if (!r.interrupt || f === 49) return t.enter("listItemPrefix"), t.enter("listItemValue"), a(f);
    }
    return n(f);
  }
  function a(f) {
    return F0(f) && ++s < 10
      ? (t.consume(f), a)
      : (!r.interrupt || s < 2) && (r.containerState.marker ? f === r.containerState.marker : f === 41 || f === 46)
      ? (t.exit("listItemValue"), c(f))
      : n(f);
  }
  function c(f) {
    return (
      t.enter("listItemMarker"),
      t.consume(f),
      t.exit("listItemMarker"),
      (r.containerState.marker = r.containerState.marker || f),
      t.check(th, r.interrupt ? n : u, t.attempt(uB, d, h))
    );
  }
  function u(f) {
    return (r.containerState.initialBlankLine = !0), o++, d(f);
  }
  function h(f) {
    return Pe(f) ? (t.enter("listItemPrefixWhitespace"), t.consume(f), t.exit("listItemPrefixWhitespace"), d) : n(f);
  }
  function d(f) {
    return (r.containerState.size = o + r.sliceSerialize(t.exit("listItemPrefix"), !0).length), e(f);
  }
}
function fB(t, e, n) {
  const r = this;
  return (r.containerState._closeFlow = void 0), t.check(th, i, o);
  function i(l) {
    return (
      (r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine),
      Re(t, e, "listItemIndent", r.containerState.size + 1)(l)
    );
  }
  function o(l) {
    return r.containerState.furtherBlankLines || !Pe(l)
      ? ((r.containerState.furtherBlankLines = void 0), (r.containerState.initialBlankLine = void 0), s(l))
      : ((r.containerState.furtherBlankLines = void 0), (r.containerState.initialBlankLine = void 0), t.attempt(hB, e, s)(l));
  }
  function s(l) {
    return (
      (r.containerState._closeFlow = !0),
      (r.interrupt = void 0),
      Re(t, t.attempt(Nn, e, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l)
    );
  }
}
function pB(t, e, n) {
  const r = this;
  return Re(t, i, "listItemIndent", r.containerState.size + 1);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? e(o) : n(o);
  }
}
function mB(t) {
  t.exit(this.containerState.type);
}
function gB(t, e, n) {
  const r = this;
  return Re(t, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return !Pe(o) && s && s[1].type === "listItemPrefixWhitespace" ? e(o) : n(o);
  }
}
const Dk = { name: "setextUnderline", tokenize: vB, resolveTo: OB };
function OB(t, e) {
  let n = t.length,
    r,
    i,
    o;
  for (; n--; )
    if (t[n][0] === "enter") {
      if (t[n][1].type === "content") {
        r = n;
        break;
      }
      t[n][1].type === "paragraph" && (i = n);
    } else t[n][1].type === "content" && t.splice(n, 1), !o && t[n][1].type === "definition" && (o = n);
  const s = { type: "setextHeading", start: Object.assign({}, t[i][1].start), end: Object.assign({}, t[t.length - 1][1].end) };
  return (
    (t[i][1].type = "setextHeadingText"),
    o
      ? (t.splice(i, 0, ["enter", s, e]), t.splice(o + 1, 0, ["exit", t[r][1], e]), (t[r][1].end = Object.assign({}, t[o][1].end)))
      : (t[r][1] = s),
    t.push(["exit", s, e]),
    t
  );
}
function vB(t, e, n) {
  const r = this;
  let i;
  return o;
  function o(c) {
    let u = r.events.length,
      h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (t.enter("setextHeadingLine"), (i = c), s(c)) : n(c);
  }
  function s(c) {
    return t.enter("setextHeadingLineSequence"), l(c);
  }
  function l(c) {
    return c === i ? (t.consume(c), l) : (t.exit("setextHeadingLineSequence"), Pe(c) ? Re(t, a, "lineSuffix")(c) : a(c));
  }
  function a(c) {
    return c === null || de(c) ? (t.exit("setextHeadingLine"), e(c)) : n(c);
  }
}
const bB = { tokenize: xB };
function xB(t) {
  const e = this,
    n = t.attempt(
      th,
      r,
      t.attempt(this.parser.constructs.flowInitial, i, Re(t, t.attempt(this.parser.constructs.flow, i, t.attempt(CF, i)), "linePrefix"))
    );
  return n;
  function r(o) {
    if (o === null) {
      t.consume(o);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(o), t.exit("lineEndingBlank"), (e.currentConstruct = void 0), n;
  }
  function i(o) {
    if (o === null) {
      t.consume(o);
      return;
    }
    return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), (e.currentConstruct = void 0), n;
  }
}
const yB = { resolveAll: oA() },
  wB = iA("string"),
  SB = iA("text");
function iA(t) {
  return { tokenize: e, resolveAll: oA(t === "text" ? kB : void 0) };
  function e(n) {
    const r = this,
      i = this.parser.constructs[t],
      o = n.attempt(i, s, l);
    return s;
    function s(u) {
      return c(u) ? o(u) : l(u);
    }
    function l(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), a;
    }
    function a(u) {
      return c(u) ? (n.exit("data"), o(u)) : (n.consume(u), a);
    }
    function c(u) {
      if (u === null) return !0;
      const h = i[u];
      let d = -1;
      if (h)
        for (; ++d < h.length; ) {
          const f = h[d];
          if (!f.previous || f.previous.call(r, r.previous)) return !0;
        }
      return !1;
    }
  }
}
function oA(t) {
  return e;
  function e(n, r) {
    let i = -1,
      o;
    for (; ++i <= n.length; )
      o === void 0
        ? n[i] && n[i][1].type === "data" && ((o = i), i++)
        : (!n[i] || n[i][1].type !== "data") &&
          (i !== o + 2 && ((n[o][1].end = n[i - 1][1].end), n.splice(o + 2, i - o - 2), (i = o + 2)), (o = void 0));
    return t ? t(n, r) : n;
  }
}
function kB(t, e) {
  let n = 0;
  for (; ++n <= t.length; )
    if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
      const r = t[n - 1][1],
        i = e.sliceStream(r);
      let o = i.length,
        s = -1,
        l = 0,
        a;
      for (; o--; ) {
        const c = i[o];
        if (typeof c == "string") {
          for (s = c.length; c.charCodeAt(s - 1) === 32; ) l++, s--;
          if (s) break;
          s = -1;
        } else if (c === -2) (a = !0), l++;
        else if (c !== -1) {
          o++;
          break;
        }
      }
      if (l) {
        const c = {
          type: n === t.length || a || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l,
            _index: r.start._index + o,
            _bufferIndex: o ? s : r.start._bufferIndex + s,
          },
          end: Object.assign({}, r.end),
        };
        (r.end = Object.assign({}, c.start)),
          r.start.offset === r.end.offset ? Object.assign(r, c) : (t.splice(n, 0, ["enter", c, e], ["exit", c, e]), (n += 2));
      }
      n++;
    }
  return t;
}
function CB(t, e, n) {
  let r = Object.assign(n ? Object.assign({}, n) : { line: 1, column: 1, offset: 0 }, { _index: 0, _bufferIndex: -1 });
  const i = {},
    o = [];
  let s = [],
    l = [];
  const a = { consume: g, enter: b, exit: x, attempt: y(k), check: y(w), interrupt: y(w, { interrupt: !0 }) },
    c = {
      previous: null,
      code: null,
      containerState: {},
      events: [],
      parser: t,
      sliceStream: f,
      sliceSerialize: d,
      now: p,
      defineSkip: m,
      write: h,
    };
  let u = e.tokenize.call(c, a);
  return e.resolveAll && o.push(e), c;
  function h(N) {
    return (s = hr(s, N)), O(), s[s.length - 1] !== null ? [] : (C(e, 0), (c.events = dm(o, c.events, c)), c.events);
  }
  function d(N, L) {
    return EB(f(N), L);
  }
  function f(N) {
    return _B(s, N);
  }
  function p() {
    const { line: N, column: L, offset: D, _index: Q, _bufferIndex: R } = r;
    return { line: N, column: L, offset: D, _index: Q, _bufferIndex: R };
  }
  function m(N) {
    (i[N.line] = N.column), E();
  }
  function O() {
    let N;
    for (; r._index < s.length; ) {
      const L = s[r._index];
      if (typeof L == "string")
        for (N = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === N && r._bufferIndex < L.length; )
          v(L.charCodeAt(r._bufferIndex));
      else v(L);
    }
  }
  function v(N) {
    u = u(N);
  }
  function g(N) {
    de(N) ? (r.line++, (r.column = 1), (r.offset += N === -3 ? 2 : 1), E()) : N !== -1 && (r.column++, r.offset++),
      r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === s[r._index].length && ((r._bufferIndex = -1), r._index++)),
      (c.previous = N);
  }
  function b(N, L) {
    const D = L || {};
    return (D.type = N), (D.start = p()), c.events.push(["enter", D, c]), l.push(D), D;
  }
  function x(N) {
    const L = l.pop();
    return (L.end = p()), c.events.push(["exit", L, c]), L;
  }
  function k(N, L) {
    C(N, L.from);
  }
  function w(N, L) {
    L.restore();
  }
  function y(N, L) {
    return D;
    function D(Q, R, W) {
      let B, K, ne, A;
      return Array.isArray(Q) ? ie(Q) : "tokenize" in Q ? ie([Q]) : V(Q);
      function V(pe) {
        return Y;
        function Y(q) {
          const oe = q !== null && pe[q],
            ce = q !== null && pe.null,
            Oe = [...(Array.isArray(oe) ? oe : oe ? [oe] : []), ...(Array.isArray(ce) ? ce : ce ? [ce] : [])];
          return ie(Oe)(q);
        }
      }
      function ie(pe) {
        return (B = pe), (K = 0), pe.length === 0 ? W : M(pe[K]);
      }
      function M(pe) {
        return Y;
        function Y(q) {
          return (
            (A = P()),
            (ne = pe),
            pe.partial || (c.currentConstruct = pe),
            pe.name && c.parser.constructs.disable.null.includes(pe.name)
              ? Se()
              : pe.tokenize.call(L ? Object.assign(Object.create(c), L) : c, a, fe, Se)(q)
          );
        }
      }
      function fe(pe) {
        return N(ne, A), R;
      }
      function Se(pe) {
        return A.restore(), ++K < B.length ? M(B[K]) : W;
      }
    }
  }
  function C(N, L) {
    N.resolveAll && !o.includes(N) && o.push(N),
      N.resolve && gr(c.events, L, c.events.length - L, N.resolve(c.events.slice(L), c)),
      N.resolveTo && (c.events = N.resolveTo(c.events, c));
  }
  function P() {
    const N = p(),
      L = c.previous,
      D = c.currentConstruct,
      Q = c.events.length,
      R = Array.from(l);
    return { restore: W, from: Q };
    function W() {
      (r = N), (c.previous = L), (c.currentConstruct = D), (c.events.length = Q), (l = R), E();
    }
  }
  function E() {
    r.line in i && r.column < 2 && ((r.column = i[r.line]), (r.offset += i[r.line] - 1));
  }
}
function _B(t, e) {
  const n = e.start._index,
    r = e.start._bufferIndex,
    i = e.end._index,
    o = e.end._bufferIndex;
  let s;
  if (n === i) s = [t[n].slice(r, o)];
  else {
    if (((s = t.slice(n, i)), r > -1)) {
      const l = s[0];
      typeof l == "string" ? (s[0] = l.slice(r)) : s.shift();
    }
    o > 0 && s.push(t[i].slice(0, o));
  }
  return s;
}
function EB(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < t.length; ) {
    const o = t[n];
    let s;
    if (typeof o == "string") s = o;
    else
      switch (o) {
        case -5: {
          s = "\r";
          break;
        }
        case -4: {
          s = `
`;
          break;
        }
        case -3: {
          s = `\r
`;
          break;
        }
        case -2: {
          s = e ? " " : "	";
          break;
        }
        case -1: {
          if (!e && i) continue;
          s = " ";
          break;
        }
        default:
          s = String.fromCharCode(o);
      }
    (i = o === -2), r.push(s);
  }
  return r.join("");
}
const TB = { 42: Nn, 43: Nn, 45: Nn, 48: Nn, 49: Nn, 50: Nn, 51: Nn, 52: Nn, 53: Nn, 54: Nn, 55: Nn, 56: Nn, 57: Nn, 62: GP },
  PB = { 91: AF },
  AB = { [-2]: Dg, [-1]: Dg, 32: Dg },
  $B = { 35: NF, 42: Hd, 45: [Dk, Hd], 60: BF, 61: Dk, 95: Hd, 96: Nk, 126: Nk },
  RB = { 38: KP, 92: JP },
  IB = { [-5]: Fg, [-4]: Fg, [-3]: Fg, 33: iB, 38: KP, 42: Z0, 60: [sF, UF], 91: sB, 92: [MF, JP], 93: Xb, 95: Z0, 96: bF },
  MB = { null: [Z0, yB] },
  LB = { null: [42, 95] },
  NB = { null: [] },
  QB = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        attentionMarkers: LB,
        contentInitial: PB,
        disable: NB,
        document: TB,
        flow: $B,
        flowInitial: AB,
        insideSpan: MB,
        string: RB,
        text: IB,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
function DB(t) {
  const n = YP([QB, ...((t || {}).extensions || [])]),
    r = { defined: [], lazy: {}, constructs: n, content: i(KD), document: i(tF), flow: i(bB), string: i(wB), text: i(SB) };
  return r;
  function i(o) {
    return s;
    function s(l) {
      return CB(r, o, l);
    }
  }
}
function FB(t) {
  for (; !eA(t); );
  return t;
}
const Fk = /[\0\t\n\r]/g;
function BB() {
  let t = 1,
    e = "",
    n = !0,
    r;
  return i;
  function i(o, s, l) {
    const a = [];
    let c, u, h, d, f;
    for (
      o = e + (typeof o == "string" ? o.toString() : new TextDecoder(s || void 0).decode(o)),
        h = 0,
        e = "",
        n && (o.charCodeAt(0) === 65279 && h++, (n = void 0));
      h < o.length;

    ) {
      if (((Fk.lastIndex = h), (c = Fk.exec(o)), (d = c && c.index !== void 0 ? c.index : o.length), (f = o.charCodeAt(d)), !c)) {
        e = o.slice(h);
        break;
      }
      if (f === 10 && h === d && r) a.push(-3), (r = void 0);
      else
        switch ((r && (a.push(-5), (r = void 0)), h < d && (a.push(o.slice(h, d)), (t += d - h)), f)) {
          case 0: {
            a.push(65533), t++;
            break;
          }
          case 9: {
            for (u = Math.ceil(t / 4) * 4, a.push(-2); t++ < u; ) a.push(-1);
            break;
          }
          case 10: {
            a.push(-4), (t = 1);
            break;
          }
          default:
            (r = !0), (t = 1);
        }
      h = d + 1;
    }
    return l && (r && a.push(-5), e && a.push(e), a.push(null)), a;
  }
}
const sA = {}.hasOwnProperty;
function VB(t, e, n) {
  return typeof e != "string" && ((n = e), (e = void 0)), jB(n)(FB(DB(n).document().write(BB()(t, e, !0))));
}
function jB(t) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(Ne),
      autolinkProtocol: P,
      autolinkEmail: P,
      atxHeading: o(Ct),
      blockQuote: o(ce),
      characterEscape: P,
      characterReference: P,
      codeFenced: o(Oe),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: o(Oe, s),
      codeText: o(_e, s),
      codeTextData: P,
      data: P,
      codeFlowValue: P,
      definition: o(Le),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: o(Ge),
      hardBreakEscape: o($t),
      hardBreakTrailing: o($t),
      htmlFlow: o(Rt, s),
      htmlFlowData: P,
      htmlText: o(Rt, s),
      htmlTextData: P,
      image: o(We),
      label: s,
      link: o(Ne),
      listItem: o(Ie),
      listItemValue: d,
      listOrdered: o(je, h),
      listUnordered: o(je),
      paragraph: o(Ft),
      reference: M,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: o(Ct),
      strong: o(Tt),
      thematicBreak: o(rn),
    },
    exit: {
      atxHeading: a(),
      atxHeadingSequence: k,
      autolink: a(),
      autolinkEmail: oe,
      autolinkProtocol: q,
      blockQuote: a(),
      characterEscapeValue: E,
      characterReferenceMarkerHexadecimal: Se,
      characterReferenceMarkerNumeric: Se,
      characterReferenceValue: pe,
      characterReference: Y,
      codeFenced: a(O),
      codeFencedFence: m,
      codeFencedFenceInfo: f,
      codeFencedFenceMeta: p,
      codeFlowValue: E,
      codeIndented: a(v),
      codeText: a(R),
      codeTextData: E,
      data: E,
      definition: a(),
      definitionDestinationString: x,
      definitionLabelString: g,
      definitionTitleString: b,
      emphasis: a(),
      hardBreakEscape: a(L),
      hardBreakTrailing: a(L),
      htmlFlow: a(D),
      htmlFlowData: E,
      htmlText: a(Q),
      htmlTextData: E,
      image: a(B),
      label: ne,
      labelText: K,
      lineEnding: N,
      link: a(W),
      listItem: a(),
      listOrdered: a(),
      listUnordered: a(),
      paragraph: a(),
      referenceString: fe,
      resourceDestinationString: A,
      resourceTitleString: V,
      resource: ie,
      setextHeading: a(C),
      setextHeadingLineSequence: y,
      setextHeadingText: w,
      strong: a(),
      thematicBreak: a(),
    },
  };
  lA(e, (t || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(U) {
    let J = { type: "root", children: [] };
    const I = { stack: [J], tokenStack: [], config: e, enter: l, exit: c, buffer: s, resume: u, data: n },
      Te = [];
    let De = -1;
    for (; ++De < U.length; )
      if (U[De][1].type === "listOrdered" || U[De][1].type === "listUnordered")
        if (U[De][0] === "enter") Te.push(De);
        else {
          const gt = Te.pop();
          De = i(U, gt, De);
        }
    for (De = -1; ++De < U.length; ) {
      const gt = e[U[De][0]];
      sA.call(gt, U[De][1].type) && gt[U[De][1].type].call(Object.assign({ sliceSerialize: U[De][2].sliceSerialize }, I), U[De][1]);
    }
    if (I.tokenStack.length > 0) {
      const gt = I.tokenStack[I.tokenStack.length - 1];
      (gt[1] || Bk).call(I, void 0, gt[0]);
    }
    for (
      J.position = {
        start: ro(U.length > 0 ? U[0][1].start : { line: 1, column: 1, offset: 0 }),
        end: ro(U.length > 0 ? U[U.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
      },
        De = -1;
      ++De < e.transforms.length;

    )
      J = e.transforms[De](J) || J;
    return J;
  }
  function i(U, J, I) {
    let Te = J - 1,
      De = -1,
      gt = !1,
      Ci,
      _i,
      Ha,
      qa;
    for (; ++Te <= I; ) {
      const Hn = U[Te];
      switch (Hn[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Hn[0] === "enter" ? De++ : De--, (qa = void 0);
          break;
        }
        case "lineEndingBlank": {
          Hn[0] === "enter" && (Ci && !qa && !De && !Ha && (Ha = Te), (qa = void 0));
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          qa = void 0;
      }
      if (
        (!De && Hn[0] === "enter" && Hn[1].type === "listItemPrefix") ||
        (De === -1 && Hn[0] === "exit" && (Hn[1].type === "listUnordered" || Hn[1].type === "listOrdered"))
      ) {
        if (Ci) {
          let Ys = Te;
          for (_i = void 0; Ys--; ) {
            const Ei = U[Ys];
            if (Ei[1].type === "lineEnding" || Ei[1].type === "lineEndingBlank") {
              if (Ei[0] === "exit") continue;
              _i && ((U[_i][1].type = "lineEndingBlank"), (gt = !0)), (Ei[1].type = "lineEnding"), (_i = Ys);
            } else if (
              !(
                Ei[1].type === "linePrefix" ||
                Ei[1].type === "blockQuotePrefix" ||
                Ei[1].type === "blockQuotePrefixWhitespace" ||
                Ei[1].type === "blockQuoteMarker" ||
                Ei[1].type === "listItemIndent"
              )
            )
              break;
          }
          Ha && (!_i || Ha < _i) && (Ci._spread = !0),
            (Ci.end = Object.assign({}, _i ? U[_i][1].start : Hn[1].end)),
            U.splice(_i || Te, 0, ["exit", Ci, Hn[2]]),
            Te++,
            I++;
        }
        if (Hn[1].type === "listItemPrefix") {
          const Ys = { type: "listItem", _spread: !1, start: Object.assign({}, Hn[1].start), end: void 0 };
          (Ci = Ys), U.splice(Te, 0, ["enter", Ys, Hn[2]]), Te++, I++, (Ha = void 0), (qa = !0);
        }
      }
    }
    return (U[J][1]._spread = gt), I;
  }
  function o(U, J) {
    return I;
    function I(Te) {
      l.call(this, U(Te), Te), J && J.call(this, Te);
    }
  }
  function s() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function l(U, J, I) {
    this.stack[this.stack.length - 1].children.push(U),
      this.stack.push(U),
      this.tokenStack.push([J, I]),
      (U.position = { start: ro(J.start), end: void 0 });
  }
  function a(U) {
    return J;
    function J(I) {
      U && U.call(this, I), c.call(this, I);
    }
  }
  function c(U, J) {
    const I = this.stack.pop(),
      Te = this.tokenStack.pop();
    if (Te) Te[0].type !== U.type && (J ? J.call(this, U, Te[0]) : (Te[1] || Bk).call(this, U, Te[0]));
    else throw new Error("Cannot close `" + U.type + "` (" + Li({ start: U.start, end: U.end }) + "): it’s not open");
    I.position.end = ro(U.end);
  }
  function u() {
    return Vb(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function d(U) {
    if (this.data.expectingFirstListItemValue) {
      const J = this.stack[this.stack.length - 2];
      (J.start = Number.parseInt(this.sliceSerialize(U), 10)), (this.data.expectingFirstListItemValue = void 0);
    }
  }
  function f() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.lang = U;
  }
  function p() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.meta = U;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), (this.data.flowCodeInside = !0));
  }
  function O() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    (J.value = U.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")), (this.data.flowCodeInside = void 0);
  }
  function v() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.value = U.replace(/(\r?\n|\r)$/g, "");
  }
  function g(U) {
    const J = this.resume(),
      I = this.stack[this.stack.length - 1];
    (I.label = J), (I.identifier = El(this.sliceSerialize(U)).toLowerCase());
  }
  function b() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.title = U;
  }
  function x() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.url = U;
  }
  function k(U) {
    const J = this.stack[this.stack.length - 1];
    if (!J.depth) {
      const I = this.sliceSerialize(U).length;
      J.depth = I;
    }
  }
  function w() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function y(U) {
    const J = this.stack[this.stack.length - 1];
    J.depth = this.sliceSerialize(U).codePointAt(0) === 61 ? 1 : 2;
  }
  function C() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function P(U) {
    const I = this.stack[this.stack.length - 1].children;
    let Te = I[I.length - 1];
    (!Te || Te.type !== "text") && ((Te = Je()), (Te.position = { start: ro(U.start), end: void 0 }), I.push(Te)), this.stack.push(Te);
  }
  function E(U) {
    const J = this.stack.pop();
    (J.value += this.sliceSerialize(U)), (J.position.end = ro(U.end));
  }
  function N(U) {
    const J = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const I = J.children[J.children.length - 1];
      (I.position.end = ro(U.end)), (this.data.atHardBreak = void 0);
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(J.type) && (P.call(this, U), E.call(this, U));
  }
  function L() {
    this.data.atHardBreak = !0;
  }
  function D() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.value = U;
  }
  function Q() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.value = U;
  }
  function R() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.value = U;
  }
  function W() {
    const U = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const J = this.data.referenceType || "shortcut";
      (U.type += "Reference"), (U.referenceType = J), delete U.url, delete U.title;
    } else delete U.identifier, delete U.label;
    this.data.referenceType = void 0;
  }
  function B() {
    const U = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const J = this.data.referenceType || "shortcut";
      (U.type += "Reference"), (U.referenceType = J), delete U.url, delete U.title;
    } else delete U.identifier, delete U.label;
    this.data.referenceType = void 0;
  }
  function K(U) {
    const J = this.sliceSerialize(U),
      I = this.stack[this.stack.length - 2];
    (I.label = WP(J)), (I.identifier = El(J).toLowerCase());
  }
  function ne() {
    const U = this.stack[this.stack.length - 1],
      J = this.resume(),
      I = this.stack[this.stack.length - 1];
    if (((this.data.inReference = !0), I.type === "link")) {
      const Te = U.children;
      I.children = Te;
    } else I.alt = J;
  }
  function A() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.url = U;
  }
  function V() {
    const U = this.resume(),
      J = this.stack[this.stack.length - 1];
    J.title = U;
  }
  function ie() {
    this.data.inReference = void 0;
  }
  function M() {
    this.data.referenceType = "collapsed";
  }
  function fe(U) {
    const J = this.resume(),
      I = this.stack[this.stack.length - 1];
    (I.label = J), (I.identifier = El(this.sliceSerialize(U)).toLowerCase()), (this.data.referenceType = "full");
  }
  function Se(U) {
    this.data.characterReferenceType = U.type;
  }
  function pe(U) {
    const J = this.sliceSerialize(U),
      I = this.data.characterReferenceType;
    let Te;
    I ? ((Te = zP(J, I === "characterReferenceMarkerNumeric" ? 10 : 16)), (this.data.characterReferenceType = void 0)) : (Te = nu(J));
    const De = this.stack[this.stack.length - 1];
    De.value += Te;
  }
  function Y(U) {
    const J = this.stack.pop();
    J.position.end = ro(U.end);
  }
  function q(U) {
    E.call(this, U);
    const J = this.stack[this.stack.length - 1];
    J.url = this.sliceSerialize(U);
  }
  function oe(U) {
    E.call(this, U);
    const J = this.stack[this.stack.length - 1];
    J.url = "mailto:" + this.sliceSerialize(U);
  }
  function ce() {
    return { type: "blockquote", children: [] };
  }
  function Oe() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function _e() {
    return { type: "inlineCode", value: "" };
  }
  function Le() {
    return { type: "definition", identifier: "", label: null, title: null, url: "" };
  }
  function Ge() {
    return { type: "emphasis", children: [] };
  }
  function Ct() {
    return { type: "heading", depth: 0, children: [] };
  }
  function $t() {
    return { type: "break" };
  }
  function Rt() {
    return { type: "html", value: "" };
  }
  function We() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function Ne() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function je(U) {
    return { type: "list", ordered: U.type === "listOrdered", start: null, spread: U._spread, children: [] };
  }
  function Ie(U) {
    return { type: "listItem", spread: U._spread, checked: null, children: [] };
  }
  function Ft() {
    return { type: "paragraph", children: [] };
  }
  function Tt() {
    return { type: "strong", children: [] };
  }
  function Je() {
    return { type: "text", value: "" };
  }
  function rn() {
    return { type: "thematicBreak" };
  }
}
function ro(t) {
  return { line: t.line, column: t.column, offset: t.offset };
}
function lA(t, e) {
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    Array.isArray(r) ? lA(t, r) : ZB(t, r);
  }
}
function ZB(t, e) {
  let n;
  for (n in e)
    if (sA.call(e, n))
      switch (n) {
        case "canContainEols": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "transforms": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[n];
          r && Object.assign(t[n], r);
          break;
        }
      }
}
function Bk(t, e) {
  throw t
    ? new Error(
        "Cannot close `" +
          t.type +
          "` (" +
          Li({ start: t.start, end: t.end }) +
          "): a different token (`" +
          e.type +
          "`, " +
          Li({ start: e.start, end: e.end }) +
          ") is open"
      )
    : new Error("Cannot close document, a token (`" + e.type + "`, " + Li({ start: e.start, end: e.end }) + ") is still open");
}
function Uh(t) {
  return t.children instanceof Array;
}
class Lf extends Error {
  constructor(e, n) {
    super(e), (this.name = "MarkdownParseError"), (this.cause = n);
  }
}
class Nf extends Error {
  constructor(e) {
    super(e), (this.name = "UnrecognizedMarkdownConstructError");
  }
}
function aA({ root: t, markdown: e, visitors: n, syntaxExtensions: r, mdastExtensions: i, ...o }) {
  var s;
  let l;
  try {
    l = VB(e, { extensions: r, mdastExtensions: i });
  } catch (a) {
    throw a instanceof Error ? new Lf(`Error parsing markdown: ${a.message}`, a) : new Lf(`Error parsing markdown: ${a}`, a);
  }
  l.children.length === 0 && l.children.push({ type: "paragraph", children: [] }),
    ((s = l.children.at(-1)) == null ? void 0 : s.type) !== "paragraph" && l.children.push({ type: "paragraph", children: [] }),
    gm({ root: t, mdastRoot: l, visitors: n, ...o });
}
function gm({ root: t, mdastRoot: e, visitors: n, ...r }) {
  const i = new WeakMap();
  n = n.sort((l, a) => (a.priority ?? 0) - (l.priority ?? 0));
  function o(l, a) {
    if (!Uh(l)) throw new Error("Attempting to visit children of a non-parent");
    l.children.forEach((c) => {
      s(c, a, l);
    });
  }
  function s(l, a, c) {
    const u = n.find((h) => (typeof h.testNode == "string" ? h.testNode === l.type : h.testNode(l, r)));
    if (!u)
      try {
        throw new Nf(`Unsupported markdown syntax: ${XP(l)}`);
      } catch {
        throw new Nf(
          `Parsing of the following markdown structure failed: ${JSON.stringify({ type: l.type, name: "name" in l ? l.name : "N/A" })}`
        );
      }
    u.visitNode({
      mdastNode: l,
      lexicalParent: a,
      mdastParent: c,
      actions: {
        visitChildren: o,
        addAndStepInto(h) {
          a.append(h), Uh(l) && o(l, h);
        },
        addFormatting(h, d) {
          d || (Uh(l) && (d = l)), d && i.set(d, h | (i.get(c) ?? 0));
        },
        removeFormatting(h, d) {
          d || (Uh(l) && (d = l)), d && i.set(d, h ^ (i.get(c) ?? 0));
        },
        getParentFormatting() {
          return i.get(c) ?? 0;
        },
      },
    });
  }
  s(e, t, null);
}
const Ub = typeof window < "u" && typeof window.document.createElement < "u",
  ru = Ub && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
function Hb(t, e) {
  return ru ? t : e;
}
var zB = Object.defineProperty,
  WB = (t, e, n) => (e in t ? zB(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  Bg = (t, e, n) => (WB(t, typeof e != "symbol" ? e + "" : e, n), n);
const z0 = "generic-html";
class Ca extends Vr {
  constructor(e, n, r, i) {
    super(i),
      Bg(this, "__tag"),
      Bg(this, "__nodeType"),
      Bg(this, "__attributes"),
      (this.__tag = e),
      (this.__nodeType = n),
      (this.__attributes = r);
  }
  static getType() {
    return z0;
  }
  static clone(e) {
    return new Ca(e.__tag, e.__nodeType, e.__attributes, e.__key);
  }
  getTag() {
    return this.__tag;
  }
  getNodeType() {
    return this.__nodeType;
  }
  getAttributes() {
    return this.__attributes;
  }
  updateAttributes(e) {
    const n = this.getWritable();
    n.__attributes = e;
  }
  getStyle() {
    var e;
    return (e = this.__attributes.find((n) => n.name === "style")) == null ? void 0 : e.value;
  }
  createDOM() {
    const e = this.__tag,
      n = document.createElement(e);
    return (
      this.__attributes.forEach((r) => {
        n.setAttribute(r.name, r.value);
      }),
      n
    );
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return { element: n };
  }
  static importJSON(e) {
    const n = qb(e.tag, e.mdxType, e.attributes);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag(), attributes: this.__attributes, mdxType: this.__nodeType, type: z0, version: 1 };
  }
  extractWithChild() {
    return !0;
  }
  isInline() {
    return this.__nodeType === "mdxJsxTextElement";
  }
}
function qb(t, e, n) {
  return Mn(new Ca(t, e, n));
}
function cA(t) {
  return t instanceof Ca;
}
const XB = {
    testLexicalNode: cA,
    visitLexicalNode({ actions: t, lexicalNode: e }) {
      t.addAndStepInto("mdxJsxTextElement", { name: e.getTag(), type: e.getNodeType(), attributes: e.getAttributes() });
    },
    priority: -100,
  },
  UB = {
    testLexicalNode: Ar,
    visitLexicalNode: ({ mdastParent: t, actions: e }) => {
      e.appendToParent(t, {
        type: "text",
        value: `
`,
      });
    },
  },
  HB = {
    testLexicalNode: zi,
    visitLexicalNode: ({ actions: t }) => {
      t.addAndStepInto("paragraph");
    },
  },
  qB = {
    testLexicalNode: tn,
    visitLexicalNode: ({ actions: t }) => {
      t.addAndStepInto("root");
    },
  },
  YB = 0,
  Tl = 1,
  Pl = 2,
  Al = 4,
  $l = 8,
  nh = 16,
  Rl = 32,
  Il = 64,
  GB = 128;
function Vk(t) {
  return t.type === "text";
}
const JB = ["u", "span", "sub", "sup"],
  KB = {
    shouldJoin: (t, e) => {
      if (["text", "emphasis", "strong"].includes(t.type)) return t.type === e.type;
      if (t.type === "mdxJsxTextElement" && e.type === "mdxJsxTextElement" && JB.includes(e.name)) {
        const n = e;
        return t.name === n.name && JSON.stringify(t.attributes) === JSON.stringify(n.attributes);
      }
      return !1;
    },
    join(t, e) {
      return Vk(t) && Vk(e) ? { type: "text", value: t.value + e.value } : { ...t, children: [...t.children, ...e.children] };
    },
    testLexicalNode: te,
    visitLexicalNode: ({ lexicalNode: t, mdastParent: e, actions: n }) => {
      const r = t.getPreviousSibling(),
        i = te(r) ? r.getFormat() : 0,
        o = t.getTextContent(),
        s = t.getFormat(),
        l = t.getStyle();
      let a = e;
      if (
        (l &&
          (a = n.appendToParent(a, {
            type: "mdxJsxTextElement",
            name: "span",
            children: [],
            attributes: [{ type: "mdxJsxAttribute", name: "style", value: l }],
          })),
        i & s & Pl && (a = n.appendToParent(a, { type: "emphasis", children: [] })),
        i & s & Tl && (a = n.appendToParent(a, { type: "strong", children: [] })),
        i & s & $l && (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "u", children: [], attributes: [] })),
        i & s & Al && (a = n.appendToParent(a, { type: "delete", children: [] })),
        i & s & Il && (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sup", children: [], attributes: [] })),
        i & s & Rl && (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sub", children: [], attributes: [] })),
        s & Pl && !(i & Pl) && (a = n.appendToParent(a, { type: "emphasis", children: [] })),
        s & Tl && !(i & Tl) && (a = n.appendToParent(a, { type: "strong", children: [] })),
        s & $l && !(i & $l) && (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "u", children: [], attributes: [] })),
        s & Al && !(i & Al) && (a = n.appendToParent(a, { type: "delete", children: [] })),
        s & Il && !(i & Il) && (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sup", children: [], attributes: [] })),
        s & Rl && !(i & Rl) && (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sub", children: [], attributes: [] })),
        s & nh)
      ) {
        n.appendToParent(a, { type: "inlineCode", value: o });
        return;
      }
      n.appendToParent(a, { type: "text", value: o });
    },
  },
  eV = {
    testNode: "break",
    visitNode: function ({ lexicalParent: t }) {
      t.append(gi());
    },
  };
function Hh(t, e) {
  return [
    {
      testNode: (n) => n.type === "mdxJsxTextElement" && n.name === t,
      visitNode({ actions: n, mdastNode: r, lexicalParent: i }) {
        n.addFormatting(e), n.visitChildren(r, i);
      },
    },
    {
      testNode: (n) => n.type === "html" && n.value === `<${t}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.addFormatting(e, r);
      },
    },
    {
      testNode: (n) => n.type === "html" && n.value === `</${t}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.removeFormatting(e, r);
      },
    },
  ];
}
const tV = {
    testNode: "delete",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      e.addFormatting(Al), e.visitChildren(t, n);
    },
  },
  nV = {
    testNode: "inlineCode",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(yt(t.value).setFormat(e.getParentFormatting() | nh));
    },
  },
  rV = {
    testNode: "emphasis",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      e.addFormatting(Pl), e.visitChildren(t, n);
    },
  },
  iV = {
    testNode: "strong",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      e.addFormatting(Tl), e.visitChildren(t, n);
    },
  },
  oV = [rV, iV, ...Hh("u", $l), ...Hh("code", nh), nV, tV, ...Hh("sup", Il), ...Hh("sub", Rl)],
  sV = {
    testNode: zb,
    visitNode: function ({ mdastNode: t, actions: e }) {
      e.addAndStepInto(qb(t.name, t.type, t.attributes));
    },
    priority: -100,
  },
  lV = ["listitem", "quote", "admonition"],
  aV = {
    testNode: "paragraph",
    visitNode: function ({ mdastNode: t, lexicalParent: e, actions: n }) {
      lV.includes(e.getType()) ? n.visitChildren(t, e) : n.addAndStepInto(tt());
    },
  },
  cV = {
    testNode: "root",
    visitNode({ actions: t, mdastNode: e, lexicalParent: n }) {
      t.visitChildren(e, n);
    },
  },
  uV = {
    testNode: "text",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(yt(t.value).setFormat(e.getParentFormatting()));
    },
  },
  uA = () => S.createElement(aP, { externalHistoryState: mt(mA) }),
  Sr = {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    lf: 10,
    vt: 11,
    ff: 12,
    cr: 13,
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    quotationMark: 34,
    numberSign: 35,
    dollarSign: 36,
    percentSign: 37,
    ampersand: 38,
    apostrophe: 39,
    leftParenthesis: 40,
    rightParenthesis: 41,
    asterisk: 42,
    plusSign: 43,
    comma: 44,
    dash: 45,
    dot: 46,
    slash: 47,
    digit0: 48,
    digit1: 49,
    digit2: 50,
    digit3: 51,
    digit4: 52,
    digit5: 53,
    digit6: 54,
    digit7: 55,
    digit8: 56,
    digit9: 57,
    colon: 58,
    semicolon: 59,
    lessThan: 60,
    equalsTo: 61,
    greaterThan: 62,
    questionMark: 63,
    atSign: 64,
    uppercaseA: 65,
    uppercaseB: 66,
    uppercaseC: 67,
    uppercaseD: 68,
    uppercaseE: 69,
    uppercaseF: 70,
    uppercaseG: 71,
    uppercaseH: 72,
    uppercaseI: 73,
    uppercaseJ: 74,
    uppercaseK: 75,
    uppercaseL: 76,
    uppercaseM: 77,
    uppercaseN: 78,
    uppercaseO: 79,
    uppercaseP: 80,
    uppercaseQ: 81,
    uppercaseR: 82,
    uppercaseS: 83,
    uppercaseT: 84,
    uppercaseU: 85,
    uppercaseV: 86,
    uppercaseW: 87,
    uppercaseX: 88,
    uppercaseY: 89,
    uppercaseZ: 90,
    leftSquareBracket: 91,
    backslash: 92,
    rightSquareBracket: 93,
    caret: 94,
    underscore: 95,
    graveAccent: 96,
    lowercaseA: 97,
    lowercaseB: 98,
    lowercaseC: 99,
    lowercaseD: 100,
    lowercaseE: 101,
    lowercaseF: 102,
    lowercaseG: 103,
    lowercaseH: 104,
    lowercaseI: 105,
    lowercaseJ: 106,
    lowercaseK: 107,
    lowercaseL: 108,
    lowercaseM: 109,
    lowercaseN: 110,
    lowercaseO: 111,
    lowercaseP: 112,
    lowercaseQ: 113,
    lowercaseR: 114,
    lowercaseS: 115,
    lowercaseT: 116,
    lowercaseU: 117,
    lowercaseV: 118,
    lowercaseW: 119,
    lowercaseX: 120,
    lowercaseY: 121,
    lowercaseZ: 122,
    leftCurlyBrace: 123,
    verticalBar: 124,
    rightCurlyBrace: 125,
    tilde: 126,
    del: 127,
    byteOrderMarker: 65279,
    replacementCharacter: 65533,
  },
  as = {
    data: "data",
    whitespace: "whitespace",
    lineEnding: "lineEnding",
    lineEndingBlank: "lineEndingBlank",
    linePrefix: "linePrefix",
    lineSuffix: "lineSuffix",
    atxHeading: "atxHeading",
    atxHeadingSequence: "atxHeadingSequence",
    atxHeadingText: "atxHeadingText",
    autolink: "autolink",
    autolinkEmail: "autolinkEmail",
    autolinkMarker: "autolinkMarker",
    autolinkProtocol: "autolinkProtocol",
    characterEscape: "characterEscape",
    characterEscapeValue: "characterEscapeValue",
    characterReference: "characterReference",
    characterReferenceMarker: "characterReferenceMarker",
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    characterReferenceValue: "characterReferenceValue",
    codeFenced: "codeFenced",
    codeFencedFence: "codeFencedFence",
    codeFencedFenceSequence: "codeFencedFenceSequence",
    codeFencedFenceInfo: "codeFencedFenceInfo",
    codeFencedFenceMeta: "codeFencedFenceMeta",
    codeFlowValue: "codeFlowValue",
    codeIndented: "codeIndented",
    codeText: "codeText",
    codeTextData: "codeTextData",
    codeTextPadding: "codeTextPadding",
    codeTextSequence: "codeTextSequence",
    content: "content",
    definition: "definition",
    definitionDestination: "definitionDestination",
    definitionDestinationLiteral: "definitionDestinationLiteral",
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    definitionDestinationRaw: "definitionDestinationRaw",
    definitionDestinationString: "definitionDestinationString",
    definitionLabel: "definitionLabel",
    definitionLabelMarker: "definitionLabelMarker",
    definitionLabelString: "definitionLabelString",
    definitionMarker: "definitionMarker",
    definitionTitle: "definitionTitle",
    definitionTitleMarker: "definitionTitleMarker",
    definitionTitleString: "definitionTitleString",
    emphasis: "emphasis",
    emphasisSequence: "emphasisSequence",
    emphasisText: "emphasisText",
    escapeMarker: "escapeMarker",
    hardBreakEscape: "hardBreakEscape",
    hardBreakTrailing: "hardBreakTrailing",
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    image: "image",
    label: "label",
    labelText: "labelText",
    labelLink: "labelLink",
    labelImage: "labelImage",
    labelMarker: "labelMarker",
    labelImageMarker: "labelImageMarker",
    labelEnd: "labelEnd",
    link: "link",
    paragraph: "paragraph",
    reference: "reference",
    referenceMarker: "referenceMarker",
    referenceString: "referenceString",
    resource: "resource",
    resourceDestination: "resourceDestination",
    resourceDestinationLiteral: "resourceDestinationLiteral",
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    resourceDestinationRaw: "resourceDestinationRaw",
    resourceDestinationString: "resourceDestinationString",
    resourceMarker: "resourceMarker",
    resourceTitle: "resourceTitle",
    resourceTitleMarker: "resourceTitleMarker",
    resourceTitleString: "resourceTitleString",
    setextHeading: "setextHeading",
    setextHeadingText: "setextHeadingText",
    setextHeadingLine: "setextHeadingLine",
    setextHeadingLineSequence: "setextHeadingLineSequence",
    strong: "strong",
    strongSequence: "strongSequence",
    strongText: "strongText",
    thematicBreak: "thematicBreak",
    thematicBreakSequence: "thematicBreakSequence",
    blockQuote: "blockQuote",
    blockQuotePrefix: "blockQuotePrefix",
    blockQuoteMarker: "blockQuoteMarker",
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    listOrdered: "listOrdered",
    listUnordered: "listUnordered",
    listItemIndent: "listItemIndent",
    listItemMarker: "listItemMarker",
    listItemPrefix: "listItemPrefix",
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    listItemValue: "listItemValue",
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString",
  };
function hV(t) {
  return {
    canContainEols: ["comment"],
    enter: {
      comment(e) {
        this.buffer();
      },
    },
    exit: {
      comment(e) {
        const n = this.resume();
        t.ast && (this.enter({ type: "comment", value: "", commentValue: n.slice(0, -2) }, e), this.exit(e));
      },
    },
  };
}
const jk = (t, e, n) => {
    return r;
    function r(p) {
      return t.enter("comment"), t.consume(p), i;
    }
    function i(p) {
      return p === Sr.exclamationMark ? (t.consume(p), o) : n(p);
    }
    function o(p) {
      return p === Sr.dash ? (t.consume(p), s) : n(p);
    }
    function s(p) {
      return p === Sr.dash ? (t.consume(p), l) : n(p);
    }
    function l(p) {
      return p === Sr.greaterThan ? n(p) : de(p) ? u(p) : (t.enter(as.data), p === Sr.dash ? (t.consume(p), a) : c(p));
    }
    function a(p) {
      return p === Sr.greaterThan ? n(p) : c(p);
    }
    function c(p) {
      return p === Sr.eof ? n(p) : p === Sr.dash ? (t.consume(p), d) : de(p) ? (t.exit(as.data), u(p)) : (t.consume(p), c);
    }
    function u(p) {
      return t.enter(as.lineEnding), t.consume(p), t.exit(as.lineEnding), Re(t, h, as.linePrefix);
    }
    function h(p) {
      return de(p) ? u(p) : (t.enter(as.data), c(p));
    }
    function d(p) {
      return p === Sr.dash ? (t.consume(p), f) : c(p);
    }
    function f(p) {
      return p === Sr.greaterThan
        ? (t.exit(as.data), t.enter("commentEnd"), t.consume(p), t.exit("commentEnd"), t.exit("comment"), e(p))
        : p === Sr.dash
        ? (t.consume(p), f)
        : c(p);
    }
  },
  dV = { flow: { 60: { tokenize: jk, concrete: !0 } }, text: { 60: { tokenize: jk } } },
  fV = "_light_1tncs_1",
  pV = "_light-theme_1tncs_1",
  mV = "_dark_1tncs_1",
  gV = "_dark-theme_1tncs_1",
  OV = "_bold_1tncs_10",
  vV = "_italic_1tncs_14",
  bV = "_underline_1tncs_18",
  xV = "_strikethrough_1tncs_34",
  yV = "_underlineStrikethrough_1tncs_38",
  wV = "_subscript_1tncs_42",
  SV = "_superscript_1tncs_47",
  kV = "_code_1tncs_52",
  CV = "_nestedListItem_1tncs_59",
  _V = "_listitem_1tncs_69",
  EV = "_listItemChecked_1tncs_73",
  TV = "_listItemUnchecked_1tncs_74",
  PV = "_admonitionDanger_1tncs_151",
  AV = "_admonitionInfo_1tncs_152",
  $V = "_admonitionNote_1tncs_153",
  RV = "_admonitionTip_1tncs_154",
  IV = "_admonitionCaution_1tncs_155",
  MV = "_mdxExpression_1tncs_188",
  Jt = {
    light: fV,
    lightTheme: pV,
    dark: mV,
    darkTheme: gV,
    bold: OV,
    italic: vV,
    underline: bV,
    strikethrough: xV,
    underlineStrikethrough: yV,
    subscript: wV,
    superscript: SV,
    code: kV,
    nestedListItem: CV,
    listitem: _V,
    listItemChecked: EV,
    listItemUnchecked: TV,
    admonitionDanger: PV,
    admonitionInfo: AV,
    admonitionNote: $V,
    admonitionTip: RV,
    admonitionCaution: IV,
    mdxExpression: MV,
  },
  Om = {
    text: {
      bold: Jt.bold,
      italic: Jt.italic,
      underline: Jt.underline,
      code: Jt.code,
      strikethrough: Jt.strikethrough,
      subscript: Jt.subscript,
      superscript: Jt.superscript,
      underlineStrikethrough: Jt.underlineStrikethrough,
    },
    list: {
      listitem: Jt.listitem,
      listitemChecked: Jt.listItemChecked,
      listitemUnchecked: Jt.listItemUnchecked,
      nested: { listitem: Jt.nestedListItem },
    },
    admonition: {
      danger: Jt.admonitionDanger,
      info: Jt.admonitionInfo,
      note: Jt.admonitionNote,
      tip: Jt.admonitionTip,
      caution: Jt.admonitionCaution,
    },
  },
  Ro = Ji(),
  Un = we(null),
  St = we(null),
  Qf = we(""),
  Gt = we(!1, (t) => {
    t.sub(t.pipe(Gt, pt(Un)), ([e, n]) => {
      n == null || n.setEditable(!e);
    });
  }),
  Df = we(""),
  W0 = we(!1),
  Ul = we(!1),
  vm = we(0),
  Hl = we(null),
  Ff = kt((t) => {
    t.link(
      t.pipe(
        Hl,
        va((e) => e !== null)
      ),
      Ff
    );
  }),
  bm = kt((t) => {
    t.sub(t.pipe(bm, pt(St)), ([e, n]) => {
      n == null || n.dispatchCommand(Mi, e);
    });
  }),
  _s = we(null, (t) => {
    t.sub(t.pipe(_s, pt(St)), ([e, n]) => {
      if (!e || !n) return;
      const r = e.anchor.getNode();
      let i =
        r.getKey() === "root"
          ? r
          : Sa(r, (l) => {
              const a = l.getParent();
              return a !== null && Yt(a);
            });
      i === null && (i = r.getTopLevelElementOrThrow());
      const o = i.getKey();
      if (n.getElementByKey(o) !== null) {
        const l = hm(i) ? i.getTag() : i.getType();
        t.pub(cx, l);
      }
    });
  }),
  Yb = we(""),
  Ir = we(""),
  xm = kt((t) => {
    t.link(Ir, xm), t.link(Yb, Ir);
  }),
  X0 = kt((t) => {
    t.link(
      t.pipe(
        xm,
        pt(Vf),
        va(([, e]) => !e),
        mr(([e]) => e)
      ),
      X0
    );
  }),
  rh = we([]),
  ih = we([]),
  Gb = we([]),
  Jb = we([]),
  oh = we([]),
  Kb = we([]),
  Bf = we({}),
  sh = we(!1),
  Io = we([]),
  Es = we([]),
  Us = we([]),
  jr = we(null),
  ar = Ln(ih),
  Wn = Ln(rh),
  Mo = Ln(Gb),
  Lo = Ln(Jb),
  cr = Ln(oh),
  Hs = Ln(Kb),
  Vf = we(!1),
  ym = kt((t) => {
    t.sub(
      t.pipe(
        ym,
        pt(Ir, Un, Ul),
        va(([e, n]) => e.trim() !== n.trim())
      ),
      ([e, , n, r]) => {
        t.pub(Vf, !0),
          n == null ||
            n.update(
              () => {
                Qe().clear(), rx(t, Qe(), e), r ? n.focus() : pn(null);
              },
              {
                onUpdate: () => {
                  t.pub(Vf, !1);
                },
              }
            );
      }
    );
  }),
  ex = kt((t) => {
    t.sub(t.pipe(ex, pt(St, Ul)), ([e, n, r]) => {
      n == null ||
        n.update(() => {
          const i = ae();
          if (i !== null) {
            const o = {
              children: [],
              append(s) {
                this.children.push(s);
              },
              getType() {
                return i.getNodes()[0].getType();
              },
            };
            rx(t, o, e), ya(o.children);
          }
          r ? n.focus() : pn(null);
        });
    });
  });
function hA() {
  return eb(
    (t, [e, n]) => (
      t.forEach((r) => {
        if (!r) throw new Error("You have a subscription that does not return a teardown");
        r();
      }),
      n ? e.map((r) => r(n)) : []
    ),
    []
  );
}
const tx = we([], (t) => {
    t.pipe(t.combine(tx, St), hA());
  }),
  nx = we([], (t) => {
    t.pipe(t.combine(nx, Un), hA());
  }),
  Ho = we(null),
  ql = kt(),
  st = we((t) => {
    throw new Error(`No icon component for ${t}`);
  });
function Ln(t, e) {
  return kt((n, r) => {
    n.changeWith(t, r, (i, o) => {
      Array.isArray(o) || (o = [o]);
      let s = i;
      for (const l of o) i.includes(l) || (s = [...s, l]);
      return s;
    }),
      e == null || e(n, r);
  });
}
function dA(t) {
  const e = ae();
  ee(e) && t.pubIn({ [_s]: e, [vm]: e.format });
}
const lh = Ln(nx, (t, e) => {
    t.pub(e, [
      (n) =>
        n.registerCommand(
          ba,
          (r, i) => (
            t.pubIn({ [St]: i, [Ul]: !0 }),
            i._parentEditor === null &&
              i.getEditorState().read(() => {
                t.pub(Ho, { rootNode: Qe(), editorType: "lexical" });
              }),
            dA(t),
            !1
          ),
          Bn
        ),
      (n) =>
        n.registerUpdateListener(({ dirtyElements: r, dirtyLeaves: i, editorState: o }) => {
          if (t.getValue(Hl) !== null || (r.size === 0 && i.size === 0)) return;
          let l;
          o.read(() => {
            Qe().getLastChild() instanceof wi &&
              n.update(
                () => {
                  Qe().append(tt());
                },
                { discrete: !0 }
              ),
              (l = Wb({
                root: Qe(),
                visitors: t.getValue(oh),
                jsxComponentDescriptors: t.getValue(Io),
                toMarkdownExtensions: t.getValue(Kb),
                toMarkdownOptions: t.getValue(Bf),
                jsxIsAvailable: t.getValue(sh),
              }));
          }),
            t.pub(Ir, l.trim());
        }),
      (n) => n.registerCommand(hb, () => (t.pub(Ul, !0), !1), Bn),
      (n) =>
        n.registerCommand(
          nb,
          (r) => {
            const { keyCode: i, ctrlKey: o, metaKey: s } = r;
            if (i === 65 && Hb(s, o)) {
              let l = !1;
              if (
                (n.getEditorState().read(() => {
                  l = ot(Qe().getFirstChild()) || ot(Qe().getLastChild());
                }),
                l)
              )
                return (
                  r.preventDefault(),
                  r.stopImmediatePropagation(),
                  n.update(() => {
                    var a;
                    const c = n.getRootElement();
                    (a = window.getSelection()) == null || a.selectAllChildren(c), c.focus({ preventScroll: !0 });
                  }),
                  !0
                );
            }
            return !1;
          },
          Bn
        ),
    ]);
  }),
  iu = Ln(tx, (t, e) => {
    t.pub(e, [
      (n) =>
        n.registerUpdateListener(({ editorState: r }) => {
          r.read(() => {
            dA(t);
          });
        }),
      (n) =>
        n.registerCommand(
          Gp,
          (r) => {
            var i;
            const o = t.getValue(Un);
            return o && !((i = o.getRootElement()) != null && i.contains(r.relatedTarget)) && t.pubIn({ [Ul]: !1, [ql]: r }), !1;
          },
          Bn
        ),
    ]);
  });
function rx(t, e, n) {
  try {
    aA({
      root: e,
      visitors: t.getValue(rh),
      mdastExtensions: t.getValue(Jb),
      markdown: n,
      syntaxExtensions: t.getValue(Gb),
      jsxComponentDescriptors: t.getValue(Io),
      directiveDescriptors: t.getValue(Es),
      codeBlockEditorDescriptors: t.getValue(Us),
    }),
      t.pub(Hl, null);
  } catch (r) {
    if (r instanceof Lf || r instanceof Nf) t.pubIn({ [Ir]: n, [Hl]: { error: r.message, source: n } });
    else throw r;
  }
}
const ix = we([]),
  qo = Ln(ix),
  ox = we([]),
  fA = Ln(ox),
  sx = we([]),
  pA = Ln(sx),
  lx = we([]),
  ax = Ln(lx),
  mA = we(lP()),
  cx = we(""),
  LV = kt(),
  ou = kt((t) => {
    t.sub(t.pipe(ou, pt(St)), ([e, n]) => {
      n == null ||
        n.update(() => {
          const r = ae();
          ee(r) &&
            (hN(r, e),
            setTimeout(() => {
              n.focus();
            }));
        });
    });
  }),
  _a = kt((t) => {
    t.sub(t.pipe(_a, pt(St)), ([e, n]) => {
      n == null ||
        n.focus(
          () => {
            n.getEditorState().read(() => {
              const r = ae();
              ee(r) &&
                (n.update(() => {
                  const i = e();
                  i.isInline() ? (ya([i]), Yt(i.getParentOrThrow()) && Db(i, tt).selectEnd()) : sP(i),
                    setTimeout(() => {
                      "select" in i && typeof i.select == "function" && i.select();
                    });
                }),
                setTimeout(() => {
                  n.dispatchCommand(Ro, void 0);
                }));
            });
          },
          { defaultSelection: "rootEnd" }
        );
    });
  }),
  No = we("rich-text", (t) => {
    function e() {
      return eb((n, r) => ({ current: n.next, next: r }), { current: "rich-text", next: "rich-text" });
    }
    t.sub(t.pipe(No, e(), pt(Ts)), ([{ current: n }, r]) => {
      (n === "source" || n === "diff") && t.pub(ym, r);
    }),
      t.sub(
        t.pipe(
          No,
          e(),
          va((n) => n.current === "rich-text"),
          pt(St)
        ),
        ([, n]) => {
          n == null || n.dispatchCommand(Ro, void 0);
        }
      );
  }),
  Ts = we("", (t) => {
    t.link(Ir, Ts), t.link(Ts, xm);
  }),
  wm = we([]),
  Ea = Ln(wm),
  ux = we(() => {
    throw new Error("No translation function provided");
  }),
  gA = Ut({
    init(t, e) {
      t.register(lh),
        t.register(iu),
        t.register(xm),
        t.pubIn({
          [Yb]: e == null ? void 0 : e.initialMarkdown.trim(),
          [st]: e == null ? void 0 : e.iconComponentFor,
          [Wn]: [cV, aV, uV, eV, ...oV],
          [ar]: [Xs, Ki, Ca],
          [cr]: [qB, HB, KB, UB, XB],
          [qo]: uA,
          [Qf]: e == null ? void 0 : e.contentEditableClassName,
          [Bf]: e == null ? void 0 : e.toMarkdownOptions,
          [W0]: e == null ? void 0 : e.autoFocus,
          [Df]: e == null ? void 0 : e.placeholder,
          [Gt]: e == null ? void 0 : e.readOnly,
          [ux]: e == null ? void 0 : e.translation,
          [Lo]: GN(),
          [Mo]: qN(),
          [Hs]: [yP(), JN()],
        }),
        t.singletonSub(Ff, e == null ? void 0 : e.onError),
        t.singletonSub(X0, e == null ? void 0 : e.onChange),
        t.singletonSub(ql, e == null ? void 0 : e.onBlur),
        (e != null && e.suppressHtmlProcessing) || t.pubIn({ [Lo]: [xP(), hV({ ast: !1 })], [Mo]: [_P(), EP(), dV], [Wn]: sV });
    },
    postInit(t, e) {
      const n = Lb({
        editable: (e == null ? void 0 : e.readOnly) !== !0,
        namespace: "MDXEditor",
        nodes: t.getValue(ih),
        onError: (r) => {
          throw r;
        },
        theme: Om,
      });
      n.update(() => {
        const r = (e == null ? void 0 : e.initialMarkdown.trim()) ?? "";
        rx(t, Qe(), r);
        const i = e == null ? void 0 : e.autoFocus;
        if (i) {
          if (i === !0) {
            setTimeout(() => {
              n.focus(Co, { defaultSelection: "rootStart" });
            });
            return;
          }
          setTimeout(() => {
            n.focus(Co, { defaultSelection: i.defaultSelection ?? "rootStart" });
          });
        }
      }),
        t.pub(Un, n),
        t.pub(St, n);
    },
    update(t, e) {
      t.pubIn({
        [Qf]: e == null ? void 0 : e.contentEditableClassName,
        [Bf]: e == null ? void 0 : e.toMarkdownOptions,
        [W0]: e == null ? void 0 : e.autoFocus,
        [Df]: e == null ? void 0 : e.placeholder,
        [Gt]: e == null ? void 0 : e.readOnly,
      }),
        t.singletonSub(X0, e == null ? void 0 : e.onChange),
        t.singletonSub(ql, e == null ? void 0 : e.onBlur),
        t.singletonSub(Ff, e == null ? void 0 : e.onError);
    },
  });
function nt() {
  return mt(ux);
}
const NV = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? _.useLayoutEffect : _.useEffect;
function hx({
  ariaActiveDescendant: t,
  ariaAutoComplete: e,
  ariaControls: n,
  ariaDescribedBy: r,
  ariaExpanded: i,
  ariaLabel: o,
  ariaLabelledBy: s,
  ariaMultiline: l,
  ariaOwns: a,
  ariaRequired: c,
  autoCapitalize: u,
  className: h,
  id: d,
  role: f = "textbox",
  spellCheck: p = !0,
  style: m,
  tabIndex: O,
  "data-testid": v,
  ...g
}) {
  const [b] = In(),
    [x, k] = _.useState(!1),
    w = _.useCallback(
      (y) => {
        y && y.ownerDocument && y.ownerDocument.defaultView && b.setRootElement(y);
      },
      [b]
    );
  return (
    NV(
      () => (
        k(b.isEditable()),
        b.registerEditableListener((y) => {
          k(y);
        })
      ),
      [b]
    ),
    T.jsx("div", {
      ...g,
      "aria-activedescendant": x ? t : void 0,
      "aria-autocomplete": x ? e : "none",
      "aria-controls": x ? n : void 0,
      "aria-describedby": r,
      "aria-expanded": x && f === "combobox" ? !!i : void 0,
      "aria-label": o,
      "aria-labelledby": s,
      "aria-multiline": l,
      "aria-owns": x ? a : void 0,
      "aria-readonly": !x || void 0,
      "aria-required": c,
      autoCapitalize: u,
      className: h,
      contentEditable: x,
      "data-testid": v,
      id: d,
      ref: w,
      role: f,
      spellCheck: p,
      style: m,
      tabIndex: O,
    })
  );
}
function U0(t, e) {
  return (
    (U0 = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, r) {
          return (n.__proto__ = r), n;
        }),
    U0(t, e)
  );
}
var Zk = { error: null },
  QV = (function (t) {
    var e, n;
    function r() {
      for (var o, s = arguments.length, l = new Array(s), a = 0; a < s; a++) l[a] = arguments[a];
      return (
        ((o = t.call.apply(t, [this].concat(l)) || this).state = Zk),
        (o.resetErrorBoundary = function () {
          for (var c, u = arguments.length, h = new Array(u), d = 0; d < u; d++) h[d] = arguments[d];
          o.props.onReset == null || (c = o.props).onReset.apply(c, h), o.reset();
        }),
        o
      );
    }
    (n = t),
      ((e = r).prototype = Object.create(n.prototype)),
      (e.prototype.constructor = e),
      U0(e, n),
      (r.getDerivedStateFromError = function (o) {
        return { error: o };
      });
    var i = r.prototype;
    return (
      (i.reset = function () {
        this.setState(Zk);
      }),
      (i.componentDidCatch = function (o, s) {
        var l, a;
        (l = (a = this.props).onError) == null || l.call(a, o, s);
      }),
      (i.componentDidUpdate = function (o, s) {
        var l,
          a,
          c,
          u,
          h = this.state.error,
          d = this.props.resetKeys;
        h !== null &&
          s.error !== null &&
          ((c = o.resetKeys) === void 0 && (c = []),
          (u = d) === void 0 && (u = []),
          c.length !== u.length ||
            c.some(function (f, p) {
              return !Object.is(f, u[p]);
            })) &&
          ((l = (a = this.props).onResetKeysChange) == null || l.call(a, o.resetKeys, d), this.reset());
      }),
      (i.render = function () {
        var o = this.state.error,
          s = this.props,
          l = s.fallbackRender,
          a = s.FallbackComponent,
          c = s.fallback;
        if (o !== null) {
          var u = { error: o, resetErrorBoundary: this.resetErrorBoundary };
          if (_.isValidElement(c)) return c;
          if (typeof l == "function") return l(u);
          if (a) return _.createElement(a, u);
          throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
        }
        return this.props.children;
      }),
      r
    );
  })(_.Component);
function dx({ children: t, onError: e }) {
  return T.jsx(QV, {
    fallback: T.jsx("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" }, children: "An error was thrown." }),
    onError: e,
    children: t,
  });
}
const DV = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? _.useLayoutEffect : _.useEffect;
function FV(t) {
  return { initialValueFn: () => t.isEditable(), subscribe: (e) => t.registerEditableListener(e) };
}
function BV() {
  return (function (t) {
    const [e] = In(),
      n = _.useMemo(() => t(e), [e, t]),
      r = _.useRef(n.initialValueFn()),
      [i, o] = _.useState(r.current);
    return (
      DV(() => {
        const { initialValueFn: s, subscribe: l } = n,
          a = s();
        return (
          r.current !== a && ((r.current = a), o(a)),
          l((c) => {
            (r.current = c), o(c);
          })
        );
      }, [n, t]),
      i
    );
  })(FV);
}
function VV() {
  return Qe().getTextContent();
}
function jV(t, e = !0) {
  if (t) return !1;
  let n = VV();
  return e && (n = n.trim()), n === "";
}
function ZV(t) {
  if (!jV(t, !1)) return !1;
  const e = Qe().getChildren(),
    n = e.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const i = e[r];
    if (ot(i)) return !1;
    if (X(i)) {
      if (!zi(i) || i.__indent !== 0) return !1;
      const o = i.getChildren(),
        s = o.length;
      for (let l = 0; l < s; l++) {
        const a = o[r];
        if (!te(a)) return !1;
      }
    }
  }
  return !0;
}
function zV(t) {
  return () => ZV(t);
}
function WV(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
WV(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function XV(t) {
  const e = window.location.origin,
    n = (r) => {
      if (r.origin !== e) return;
      const i = t.getRootElement();
      if (document.activeElement !== i) return;
      const o = r.data;
      if (typeof o == "string") {
        let s;
        try {
          s = JSON.parse(o);
        } catch {
          return;
        }
        if (s && s.protocol === "nuanria_messaging" && s.type === "request") {
          const l = s.payload;
          if (l && l.functionId === "makeChanges") {
            const a = l.args;
            if (a) {
              const [c, u, h, d, f, p] = a;
              t.update(() => {
                const m = ae();
                if (ee(m)) {
                  const O = m.anchor;
                  let v = O.getNode(),
                    g = 0,
                    b = 0;
                  if (
                    (te(v) && c >= 0 && u >= 0 && ((g = c), (b = c + u), m.setTextNodeRange(v, g, v, b)),
                    (g === b && h === "") || (m.insertRawText(h), (v = O.getNode())),
                    te(v))
                  ) {
                    (g = d), (b = d + f);
                    const x = v.getTextContentSize();
                    (g = g > x ? x : g), (b = b > x ? x : b), m.setTextNodeRange(v, g, v, b);
                  }
                  r.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
  return (
    window.addEventListener("message", n, !0),
    () => {
      window.removeEventListener("message", n, !0);
    }
  );
}
const H0 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? _.useLayoutEffect : _.useEffect;
function zk(t) {
  return t.getEditorState().read(zV(t.isComposing()));
}
function fx({ contentEditable: t, placeholder: e, ErrorBoundary: n }) {
  const [r] = In(),
    i = (function (o, s) {
      const [l, a] = _.useState(() => o.getDecorators());
      return (
        H0(
          () =>
            o.registerDecoratorListener((c) => {
              Ss.flushSync(() => {
                a(c);
              });
            }),
          [o]
        ),
        _.useEffect(() => {
          a(o.getDecorators());
        }, [o]),
        _.useMemo(() => {
          const c = [],
            u = Object.keys(l);
          for (let h = 0; h < u.length; h++) {
            const d = u[h],
              f = T.jsx(s, { onError: (m) => o._onError(m), children: T.jsx(_.Suspense, { fallback: null, children: l[d] }) }),
              p = o.getElementByKey(d);
            p !== null && c.push(Ss.createPortal(f, p, d));
          }
          return c;
        }, [s, l, o])
      );
    })(r, n);
  return (
    (function (o) {
      H0(() => Xn(zN(o), XV(o)), [o]);
    })(r),
    T.jsxs(T.Fragment, { children: [t, T.jsx(UV, { content: e }), i] })
  );
}
function UV({ content: t }) {
  const [e] = In(),
    n = (function (i) {
      const [o, s] = _.useState(() => zk(i));
      return (
        H0(() => {
          function l() {
            const a = zk(i);
            s(a);
          }
          return (
            l(),
            Xn(
              i.registerUpdateListener(() => {
                l();
              }),
              i.registerEditableListener(() => {
                l();
              })
            )
          );
        }, [i]),
        o
      );
    })(e),
    r = BV();
  return n ? (typeof t == "function" ? t(r) : t) : null;
}
var OA = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (t) {
  (function () {
    var e = {}.hasOwnProperty;
    function n() {
      for (var o = "", s = 0; s < arguments.length; s++) {
        var l = arguments[s];
        l && (o = i(o, r(l)));
      }
      return o;
    }
    function r(o) {
      if (typeof o == "string" || typeof o == "number") return o;
      if (typeof o != "object") return "";
      if (Array.isArray(o)) return n.apply(null, o);
      if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]")) return o.toString();
      var s = "";
      for (var l in o) e.call(o, l) && o[l] && (s = i(s, l));
      return s;
    }
    function i(o, s) {
      return s ? (o ? o + " " + s : o + s) : o;
    }
    t.exports ? ((n.default = n), (t.exports = n)) : (window.classNames = n);
  })();
})(OA);
var HV = OA.exports;
const Fe = Vp(HV),
  qV = "_editorRoot_yms4a_53",
  YV = "_editorWrapper_yms4a_154",
  GV = "_nestedListItem_yms4a_156",
  JV = "_toolbarRoot_yms4a_160",
  KV = "_readOnlyToolbarRoot_yms4a_187",
  ej = "_toolbarModeSwitch_yms4a_196",
  tj = "_toolbarToggleItem_yms4a_206",
  nj = "_toolbarGroupOfGroups_yms4a_217",
  rj = "_toolbarToggleSingleGroup_yms4a_222",
  ij = "_toolbarButton_yms4a_237",
  oj = "_activeToolbarButton_yms4a_274",
  sj = "_toolbarNodeKindSelectContainer_yms4a_284",
  lj = "_toolbarButtonDropdownContainer_yms4a_285",
  aj = "_toolbarCodeBlockLanguageSelectContent_yms4a_286",
  cj = "_selectContainer_yms4a_287",
  uj = "_selectItem_yms4a_300",
  hj = "_toolbarNodeKindSelectTrigger_yms4a_305",
  dj = "_toolbarButtonSelectTrigger_yms4a_306",
  fj = "_selectTrigger_yms4a_307",
  pj = "_toolbarCodeBlockLanguageSelectTrigger_yms4a_342",
  mj = "_toolbarNodeKindSelectItem_yms4a_347",
  gj = "_toolbarNodeKindSelectDropdownArrow_yms4a_372",
  Oj = "_selectDropdownArrow_yms4a_373",
  vj = "_contentEditable_yms4a_379",
  bj = "_codeMirrorWrapper_yms4a_391",
  xj = "_sandPackWrapper_yms4a_400",
  yj = "_codeMirrorToolbar_yms4a_408",
  wj = "_frontmatterWrapper_yms4a_412",
  Sj = "_frontmatterToggleButton_yms4a_422",
  kj = "_propertyPanelTitle_yms4a_430",
  Cj = "_propertyEditorTable_yms4a_438",
  _j = "_iconButton_yms4a_456",
  Ej = "_readOnlyColumnCell_yms4a_461",
  Tj = "_propertyEditorLabelCell_yms4a_466",
  Pj = "_buttonsFooter_yms4a_474",
  Aj = "_propertyEditorInput_yms4a_480",
  $j = "_primaryButton_yms4a_506",
  Rj = "_secondaryButton_yms4a_507",
  Ij = "_smallButton_yms4a_522",
  Mj = "_dialogForm_yms4a_534",
  Lj = "_linkDialogEditForm_yms4a_540",
  Nj = "_linkDialogInputContainer_yms4a_548",
  Qj = "_linkDialogInputWrapper_yms4a_554",
  Dj = "_linkDialogInput_yms4a_548",
  Fj = "_dialogInput_yms4a_575",
  Bj = "_linkDialogAnchor_yms4a_586",
  Vj = "_linkDialogPopoverContent_yms4a_600",
  jj = "_tableColumnEditorPopoverContent_yms4a_601",
  Zj = "_dialogContent_yms4a_602",
  zj = "_largeDialogContent_yms4a_614",
  Wj = "_dialogTitle_yms4a_624",
  Xj = "_dialogCloseButton_yms4a_630",
  Uj = "_popoverContent_yms4a_637",
  Hj = "_popoverArrow_yms4a_649",
  qj = "_linkDialogPreviewAnchor_yms4a_653",
  Yj = "_tooltipTrigger_yms4a_676",
  Gj = "_tooltipContent_yms4a_680",
  Jj = "_actionButton_yms4a_694",
  Kj = "_primaryActionButton_yms4a_701",
  eZ = "_tableEditor_yms4a_713",
  tZ = "_toolCell_yms4a_724",
  nZ = "_tableColumnEditorTrigger_yms4a_743",
  rZ = "_tableRowEditorTrigger_yms4a_744",
  iZ = "_addRowButton_yms4a_745",
  oZ = "_addColumnButton_yms4a_746",
  sZ = "_tableColumnEditorToolbar_yms4a_789",
  lZ = "_toggleGroupRoot_yms4a_803",
  aZ = "_tableToolsColumn_yms4a_821",
  cZ = "_leftAlignedCell_yms4a_830",
  uZ = "_rightAlignedCell_yms4a_834",
  hZ = "_centeredCell_yms4a_838",
  dZ = "_dialogOverlay_yms4a_871",
  fZ = "_overlayShow_yms4a_1",
  pZ = "_contentShow_yms4a_1",
  mZ = "_focusedImage_yms4a_918",
  gZ = "_imageWrapper_yms4a_922",
  OZ = "_editImageToolbar_yms4a_935",
  vZ = "_editImageButton_yms4a_939",
  bZ = "_inlineEditor_yms4a_945",
  xZ = "_blockEditor_yms4a_954",
  yZ = "_nestedEditor_yms4a_963",
  wZ = "_genericComponentName_yms4a_982",
  SZ = "_diffSourceToggle_yms4a_988",
  kZ = "_selectWithLabel_yms4a_1002",
  CZ = "_toolbarTitleMode_yms4a_1017",
  _Z = "_imageControlWrapperResizing_yms4a_1023",
  EZ = "_imageResizer_yms4a_1027",
  TZ = "_imageResizerN_yms4a_1036",
  PZ = "_imageResizerNe_yms4a_1042",
  AZ = "_imageResizerE_yms4a_1048",
  $Z = "_imageResizerSe_yms4a_1054",
  RZ = "_imageResizerS_yms4a_1054",
  IZ = "_imageResizerSw_yms4a_1066",
  MZ = "_imageResizerW_yms4a_1072",
  LZ = "_imageResizerNw_yms4a_1078",
  NZ = "_placeholder_yms4a_1084",
  QZ = "_rootContentEditableWrapper_yms4a_1097",
  DZ = "_downshiftContainer_yms4a_1103",
  FZ = "_downshiftInputWrapper_yms4a_1109",
  BZ = "_downshiftInput_yms4a_1109",
  VZ = "_downshiftAutocompleteContainer_yms4a_1140",
  jZ = "_textInput_yms4a_1186",
  ZZ = "_multiFieldForm_yms4a_1194",
  zZ = "_formField_yms4a_1200",
  WZ = "_markdownParseError_yms4a_1211",
  XZ = "_popupContainer_yms4a_1220",
  UZ = "_inputSizer_yms4a_1225",
  F = {
    editorRoot: qV,
    editorWrapper: YV,
    nestedListItem: GV,
    toolbarRoot: JV,
    readOnlyToolbarRoot: KV,
    toolbarModeSwitch: ej,
    toolbarToggleItem: tj,
    toolbarGroupOfGroups: nj,
    toolbarToggleSingleGroup: rj,
    toolbarButton: ij,
    activeToolbarButton: oj,
    toolbarNodeKindSelectContainer: sj,
    toolbarButtonDropdownContainer: lj,
    toolbarCodeBlockLanguageSelectContent: aj,
    selectContainer: cj,
    selectItem: uj,
    toolbarNodeKindSelectTrigger: hj,
    toolbarButtonSelectTrigger: dj,
    selectTrigger: fj,
    toolbarCodeBlockLanguageSelectTrigger: pj,
    toolbarNodeKindSelectItem: mj,
    toolbarNodeKindSelectDropdownArrow: gj,
    selectDropdownArrow: Oj,
    contentEditable: vj,
    codeMirrorWrapper: bj,
    sandPackWrapper: xj,
    codeMirrorToolbar: yj,
    frontmatterWrapper: wj,
    frontmatterToggleButton: Sj,
    propertyPanelTitle: kj,
    propertyEditorTable: Cj,
    iconButton: _j,
    readOnlyColumnCell: Ej,
    propertyEditorLabelCell: Tj,
    buttonsFooter: Pj,
    propertyEditorInput: Aj,
    primaryButton: $j,
    secondaryButton: Rj,
    smallButton: Ij,
    dialogForm: Mj,
    linkDialogEditForm: Lj,
    linkDialogInputContainer: Nj,
    linkDialogInputWrapper: Qj,
    linkDialogInput: Dj,
    dialogInput: Fj,
    linkDialogAnchor: Bj,
    linkDialogPopoverContent: Vj,
    tableColumnEditorPopoverContent: jj,
    dialogContent: Zj,
    largeDialogContent: zj,
    dialogTitle: Wj,
    dialogCloseButton: Xj,
    popoverContent: Uj,
    popoverArrow: Hj,
    linkDialogPreviewAnchor: qj,
    tooltipTrigger: Yj,
    tooltipContent: Gj,
    actionButton: Jj,
    primaryActionButton: Kj,
    tableEditor: eZ,
    toolCell: tZ,
    tableColumnEditorTrigger: nZ,
    tableRowEditorTrigger: rZ,
    addRowButton: iZ,
    addColumnButton: oZ,
    tableColumnEditorToolbar: sZ,
    toggleGroupRoot: lZ,
    tableToolsColumn: aZ,
    leftAlignedCell: cZ,
    rightAlignedCell: uZ,
    centeredCell: hZ,
    dialogOverlay: dZ,
    overlayShow: fZ,
    contentShow: pZ,
    focusedImage: mZ,
    imageWrapper: gZ,
    editImageToolbar: OZ,
    editImageButton: vZ,
    inlineEditor: bZ,
    blockEditor: xZ,
    nestedEditor: yZ,
    genericComponentName: wZ,
    diffSourceToggle: SZ,
    selectWithLabel: kZ,
    toolbarTitleMode: CZ,
    imageControlWrapperResizing: _Z,
    imageResizer: EZ,
    imageResizerN: TZ,
    imageResizerNe: PZ,
    imageResizerE: AZ,
    imageResizerSe: $Z,
    imageResizerS: RZ,
    imageResizerSw: IZ,
    imageResizerW: MZ,
    imageResizerNw: LZ,
    placeholder: NZ,
    rootContentEditableWrapper: QZ,
    downshiftContainer: DZ,
    downshiftInputWrapper: FZ,
    downshiftInput: BZ,
    downshiftAutocompleteContainer: VZ,
    textInput: jZ,
    multiFieldForm: ZZ,
    formField: zZ,
    markdownParseError: WZ,
    popupContainer: XZ,
    inputSizer: UZ,
  },
  HZ = {
    undo: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M7.202 18.5V17H14.3788C15.4224 17 16.3205 16.6554 17.073 15.9663C17.8257 15.2773 18.202 14.4263 18.202 13.4135C18.202 12.4007 17.8257 11.5512 17.073 10.8652C16.3205 10.1794 15.4224 9.8365 14.3788 9.8365H7.35775L10.1402 12.6193L9.0865 13.673L4.5 9.0865L9.0865 4.5L10.1402 5.55375L7.35775 8.3365H14.3788C15.8416 8.3365 17.0945 8.82467 18.1375 9.801C19.1805 10.7773 19.702 11.9815 19.702 13.4135C19.702 14.8455 19.1805 16.0513 18.1375 17.0308C17.0945 18.0103 15.8416 18.5 14.3788 18.5H7.202Z",
        fill: "currentColor",
      })
    ),
    redo: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M9.6211 18.5C8.15827 18.5 6.90535 18.0103 5.86235 17.0308C4.81935 16.0513 4.29785 14.8455 4.29785 13.4135C4.29785 11.9815 4.81935 10.7773 5.86235 9.801C6.90535 8.82467 8.15827 8.3365 9.6211 8.3365H16.6421L13.8596 5.55375L14.9134 4.5L19.4999 9.0865L14.9134 13.673L13.8596 12.6193L16.6421 9.8365H9.6211C8.57744 9.8365 7.67935 10.1794 6.92685 10.8652C6.17418 11.5512 5.79785 12.4007 5.79785 13.4135C5.79785 14.4263 6.17418 15.2773 6.92685 15.9663C7.67935 16.6554 8.57744 17 9.6211 17H16.7979V18.5H9.6211Z",
        fill: "currentColor",
      })
    ),
    format_bold: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M7.33838 18.625V5.375H12.1999C13.219 5.375 14.1405 5.69233 14.9644 6.327C15.788 6.9615 16.1999 7.816 16.1999 8.8905C16.1999 9.63783 16.0194 10.2471 15.6584 10.7182C15.2975 11.1894 14.9088 11.5314 14.4921 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3158 16.6614 14.0193 16.6614 14.9038C16.6614 16.1819 16.1902 17.1217 15.2479 17.723C14.3055 18.3243 13.3562 18.625 12.3999 18.625H7.33838ZM9.48838 16.6328H12.3191C13.1063 16.6328 13.6627 16.4142 13.9884 15.977C14.314 15.5398 14.4769 15.1206 14.4769 14.7192C14.4769 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8058 12.2729 12.8058H9.48838V16.6328ZM9.48838 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5279 10.3538C13.8835 10.0064 14.0614 9.59042 14.0614 9.10575C14.0614 8.59042 13.8733 8.16925 13.4971 7.84225C13.1208 7.51542 12.6595 7.352 12.1134 7.352H9.48838V10.875Z",
        fill: "currentColor",
      })
    ),
    format_italic: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M5.39404 18.625V16.8173H9.21129L12.4518 7.18275H8.63454V5.375H17.7883V7.18275H14.2785L11.0383 16.8173H14.5478V18.625H5.39404Z",
        fill: "currentColor",
      })
    ),
    format_underlined: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M5.34619 22.125V20.625H18.6537V22.125H5.34619ZM11.9999 18.5287C10.4448 18.5287 9.23102 18.0566 8.35869 17.1125C7.48619 16.1683 7.04994 14.9032 7.04994 13.3172V5.41345H8.90369V13.4095C8.90369 14.4198 9.17228 15.2295 9.70944 15.8385C10.2466 16.4475 11.0101 16.752 11.9999 16.752C12.9898 16.752 13.7533 16.4475 14.2904 15.8385C14.8276 15.2295 15.0962 14.4198 15.0962 13.4095V5.41345H16.9499V13.3172C16.9499 14.9032 16.5137 16.1683 15.6412 17.1125C14.7689 18.0566 13.5551 18.5287 11.9999 18.5287Z",
        fill: "currentColor",
      })
    ),
    code: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M7.99994 17.6537L2.34619 11.9999L7.99994 6.34619L9.06919 7.41544L4.46919 12.0154L9.05369 16.5999L7.99994 17.6537ZM15.9999 17.6537L14.9307 16.5844L19.5307 11.9844L14.9462 7.39994L15.9999 6.34619L21.6537 11.9999L15.9999 17.6537Z",
        fill: "currentColor",
      })
    ),
    strikeThrough: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M12.15 19.6923C10.9732 19.6923 9.9315 19.359 9.025 18.6923C8.11867 18.0256 7.45525 17.1128 7.03475 15.9538L8.6385 15.2635C8.91667 16.0444 9.3545 16.6867 9.952 17.1905C10.5493 17.6944 11.2923 17.9463 12.1808 17.9463C12.9578 17.9463 13.6744 17.7508 14.3307 17.3598C14.9872 16.9686 15.3155 16.3487 15.3155 15.5C15.3155 15.123 15.2555 14.7968 15.1355 14.5213C15.0157 14.2456 14.8462 13.9885 14.627 13.75H16.677C16.7987 13.9705 16.8932 14.2256 16.9605 14.5153C17.0278 14.8051 17.0615 15.1334 17.0615 15.5C17.0615 16.8372 16.5747 17.8702 15.601 18.599C14.6272 19.3279 13.4768 19.6923 12.15 19.6923ZM2.25 11.75V10.25H21.75V11.75H2.25ZM12.05 4.19629C13.0475 4.19629 13.9123 4.42704 14.6443 4.88854C15.3763 5.35004 15.9673 6.05896 16.4173 7.01529L14.823 7.73079C14.6218 7.26029 14.2978 6.84462 13.851 6.48379C13.4042 6.12279 12.8141 5.94229 12.0808 5.94229C11.2244 5.94229 10.5392 6.16221 10.025 6.60204C9.51083 7.04171 9.264 7.59104 9.2845 8.25004H7.5385C7.50133 7.16421 7.89783 6.21712 8.728 5.40879C9.558 4.60046 10.6653 4.19629 12.05 4.19629Z",
        fill: "currentColor",
      })
    ),
    superscript: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M16.6924 8V6.2115C16.6924 5.95383 16.7786 5.73875 16.9511 5.56625C17.1235 5.39392 17.3385 5.30775 17.5961 5.30775H19.5001V4.38475H16.6924V3.5H19.4809C19.7385 3.5 19.9536 3.58625 20.1261 3.75875C20.2985 3.93108 20.3846 4.14617 20.3846 4.404V5.2885C20.3846 5.54617 20.2985 5.76125 20.1261 5.93375C19.9536 6.10608 19.7385 6.19225 19.4809 6.19225H17.5771V7.1155H20.3846V8H16.6924ZM4.44238 18.5L8.84638 11.6287L4.77713 5.30775H6.74438L9.95963 10.404H10.0214L13.2501 5.30775H15.2329L11.1194 11.6287L15.5579 18.5H13.5751L10.0214 12.9308H9.95963L6.42513 18.5H4.44238Z",
        fill: "currentColor",
      })
    ),
    subscript: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M16.6924 20.5V18.7115C16.6924 18.4538 16.7786 18.2387 16.9511 18.0662C17.1235 17.8939 17.3385 17.8077 17.5961 17.8077H19.5001V16.8845H16.6924V16H19.4809C19.7385 16 19.9536 16.0863 20.1261 16.2587C20.2985 16.4311 20.3846 16.6461 20.3846 16.9038V17.7885C20.3846 18.0462 20.2985 18.2612 20.1261 18.4337C19.9536 18.6061 19.7385 18.6923 19.4809 18.6923H17.5771V19.6152H20.3846V20.5H16.6924ZM4.44238 18.6923L8.84638 11.8212L4.77713 5.5H6.74438L9.95963 10.5962H10.0214L13.2501 5.5H15.2329L11.1194 11.8212L15.5579 18.6923H13.5751L10.0214 13.123H9.95963L6.42513 18.6923H4.44238Z",
        fill: "currentColor",
      })
    ),
    format_list_bulleted: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75005V5.25005H20.5V6.75005H9.30775ZM5.1635 19.6635C4.706 19.6635 4.31442 19.5006 3.98875 19.1748C3.66292 18.8491 3.5 18.4575 3.5 18C3.5 17.5425 3.66292 17.151 3.98875 16.8253C4.31442 16.4995 4.706 16.3365 5.1635 16.3365C5.621 16.3365 6.01258 16.4995 6.33825 16.8253C6.66408 17.151 6.827 17.5425 6.827 18C6.827 18.4575 6.66408 18.8491 6.33825 19.1748C6.01258 19.5006 5.621 19.6635 5.1635 19.6635ZM5.1635 13.6635C4.706 13.6635 4.31442 13.5006 3.98875 13.1748C3.66292 12.8491 3.5 12.4575 3.5 12C3.5 11.5425 3.66292 11.151 3.98875 10.8253C4.31442 10.4995 4.706 10.3365 5.1635 10.3365C5.621 10.3365 6.01258 10.4995 6.33825 10.8253C6.66408 11.151 6.827 11.5425 6.827 12C6.827 12.4575 6.66408 12.8491 6.33825 13.1748C6.01258 13.5006 5.621 13.6635 5.1635 13.6635ZM5.1635 7.66355C4.706 7.66355 4.31442 7.50063 3.98875 7.1748C3.66292 6.84913 3.5 6.45755 3.5 6.00005C3.5 5.54255 3.66292 5.15096 3.98875 4.8253C4.31442 4.49946 4.706 4.33655 5.1635 4.33655C5.621 4.33655 6.01258 4.49946 6.33825 4.8253C6.66408 5.15096 6.827 5.54255 6.827 6.00005C6.827 6.45755 6.66408 6.84913 6.33825 7.1748C6.01258 7.50063 5.621 7.66355 5.1635 7.66355Z",
        fill: "currentColor",
      })
    ),
    format_list_numbered: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M3.5 21.5V20.3078H6V19.25H4.5V18.0577H6V17H3.5V15.8077H6.34625C6.58592 15.8077 6.78683 15.8888 6.949 16.051C7.11117 16.2132 7.19225 16.4141 7.19225 16.6538V17.8462C7.19225 18.0859 7.11117 18.2868 6.949 18.449C6.78683 18.6112 6.58592 18.6923 6.34625 18.6923C6.58592 18.6923 6.78683 18.7733 6.949 18.9355C7.11117 19.0977 7.19225 19.2987 7.19225 19.5385V20.6538C7.19225 20.8936 7.11117 21.0946 6.949 21.2568C6.78683 21.4189 6.58592 21.5 6.34625 21.5H3.5ZM3.5 14.8463V12.25C3.5 12.0103 3.58108 11.8093 3.74325 11.647C3.90542 11.4848 4.10642 11.4038 4.34625 11.4038H6V10.3462H3.5V9.15375H6.34625C6.58592 9.15375 6.78683 9.23483 6.949 9.397C7.11117 9.55933 7.19225 9.76033 7.19225 10V11.75C7.19225 11.9897 7.11117 12.1907 6.949 12.353C6.78683 12.5152 6.58592 12.5963 6.34625 12.5963H4.69225V13.6538H7.19225V14.8463H3.5ZM5 8.19225V3.69225H3.5V2.5H6.19225V8.19225H5ZM9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75V5.25H20.5V6.75H9.30775Z",
        fill: "currentColor",
      })
    ),
    format_list_checked: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M5.69425 18.452L2.5 15.2578L3.54425 14.2135L5.66925 16.3385L9.91925 12.0885L10.9635 13.1578L5.69425 18.452ZM5.69425 10.8365L2.5 7.64227L3.54425 6.59802L5.66925 8.72302L9.91925 4.47302L10.9635 5.54227L5.69425 10.8365ZM13.0095 16.5578V15.0578H21.5095V16.5578H13.0095ZM13.0095 8.94227V7.44227H21.5095V8.94227H13.0095Z",
        fill: "currentColor",
      })
    ),
    link: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M10.8077 16.5385H7.0385C5.78283 16.5385 4.7125 16.096 3.8275 15.211C2.9425 14.3262 2.5 13.256 2.5 12.0005C2.5 10.745 2.9425 9.67471 3.8275 8.78955C4.7125 7.90421 5.78283 7.46155 7.0385 7.46155H10.8077V8.96155H7.0385C6.19867 8.96155 5.48233 9.25805 4.8895 9.85105C4.2965 10.444 4 11.1604 4 12C4 12.8397 4.2965 13.556 4.8895 14.149C5.48233 14.742 6.19867 15.0385 7.0385 15.0385H10.8077V16.5385ZM8.25 12.75V11.25H15.75V12.75H8.25ZM13.1923 16.5385V15.0385H16.9615C17.8013 15.0385 18.5177 14.742 19.1105 14.149C19.7035 13.556 20 12.8397 20 12C20 11.1604 19.7035 10.444 19.1105 9.85105C18.5177 9.25805 17.8013 8.96155 16.9615 8.96155H13.1923V7.46155H16.9615C18.2172 7.46155 19.2875 7.90405 20.1725 8.78905C21.0575 9.67388 21.5 10.744 21.5 11.9995C21.5 13.255 21.0575 14.3254 20.1725 15.2105C19.2875 16.0959 18.2172 16.5385 16.9615 16.5385H13.1923Z",
        fill: "currentColor",
      })
    ),
    add_photo: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M5.11537 20.5C4.6182 20.5 4.19262 20.323 3.83862 19.969C3.48462 19.615 3.30762 19.1894 3.30762 18.6922V5.30773C3.30762 4.81056 3.48462 4.38498 3.83862 4.03098C4.19262 3.67698 4.6182 3.49998 5.11537 3.49998H13.8076V4.99998H5.11537C5.02553 4.99998 4.95178 5.02881 4.89412 5.08648C4.83645 5.14415 4.80762 5.2179 4.80762 5.30773V18.6922C4.80762 18.7821 4.83645 18.8558 4.89412 18.9135C4.95178 18.9711 5.02553 19 5.11537 19H18.4999C18.5895 19 18.6633 18.9711 18.7211 18.9135C18.7788 18.8558 18.8076 18.7821 18.8076 18.6922V9.99998H20.3076V18.6922C20.3076 19.1894 20.1306 19.615 19.7766 19.969C19.4226 20.323 18.997 20.5 18.4999 20.5H5.11537ZM17.1921 8.61523V6.61523H15.1921V5.11548H17.1921V3.11548H18.6921V5.11548H20.6921V6.61523H18.6921V8.61523H17.1921ZM6.55762 16.75H17.1344L13.8459 12.3655L11.0384 16.0192L9.03837 13.4615L6.55762 16.75Z",
        fill: "currentColor",
      })
    ),
    table: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M3.5 18.6923V5.30775C3.5 4.81058 3.677 4.385 4.031 4.031C4.385 3.677 4.81058 3.5 5.30775 3.5H18.6923C19.1894 3.5 19.615 3.677 19.969 4.031C20.323 4.385 20.5 4.81058 20.5 5.30775V18.6923C20.5 19.1894 20.323 19.615 19.969 19.969C19.615 20.323 19.1894 20.5 18.6923 20.5H5.30775C4.81058 20.5 4.385 20.323 4.031 19.969C3.677 19.615 3.5 19.1894 3.5 18.6923ZM5 9.077H19V5.30775C19 5.21792 18.9712 5.14417 18.9135 5.0865C18.8558 5.02883 18.7821 5 18.6923 5H5.30775C5.21792 5 5.14417 5.02883 5.0865 5.0865C5.02883 5.14417 5 5.21792 5 5.30775V9.077ZM10.1615 14.0385H13.8385V10.577H10.1615V14.0385ZM10.1615 19H13.8385V15.5385H10.1615V19ZM5 14.0385H8.6615V10.577H5V14.0385ZM15.3385 14.0385H19V10.577H15.3385V14.0385ZM5.30775 19H8.6615V15.5385H5V18.6923C5 18.7821 5.02883 18.8558 5.0865 18.9135C5.14417 18.9712 5.21792 19 5.30775 19ZM15.3385 19H18.6923C18.7821 19 18.8558 18.9712 18.9135 18.9135C18.9712 18.8558 19 18.7821 19 18.6923V15.5385H15.3385V19Z",
        fill: "currentColor",
      })
    ),
    horizontal_rule: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", { d: "M4.5 12.75V11.25H19.5V12.75H4.5Z", fill: "currentColor" })
    ),
    frontmatter: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", { d: "M4.5 8.75V7.25H8.5V8.75H4.5Z", fill: "currentColor" }),
      S.createElement("path", { d: "M4.5 14.75V13.25H8.5V14.75H4.5Z", fill: "currentColor" }),
      S.createElement("path", { d: "M9.5 8.75V7.25H13.5V8.75H9.5Z", fill: "currentColor" }),
      S.createElement("path", { d: "M9.5 14.75V13.25H13.5V14.75H9.5Z", fill: "currentColor" }),
      S.createElement("path", { d: "M14.5 8.75V7.25H18.5V8.75H14.5Z", fill: "currentColor" }),
      S.createElement("path", { d: "M14.5 14.75V13.25H18.5V14.75H14.5Z", fill: "currentColor" })
    ),
    frame_source: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M8.6 15.2443L5.35575 12L8.6 8.75575L9.64425 9.825L7.46925 12L9.64425 14.175L8.6 15.2443ZM15.4 15.2443L14.3558 14.175L16.5307 12L14.3558 9.825L15.4 8.75575L18.6443 12L15.4 15.2443ZM5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V15H5V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H9V20.5H5.30775ZM15 20.5V19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V15H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H15ZM3.5 9V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H9V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V9H3.5ZM19 9V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H15V3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V9H19Z",
        fill: "currentColor",
      })
    ),
    arrow_drop_down: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", { d: "M11.9999 14.6537L7.59619 10.25H16.4037L11.9999 14.6537Z", fill: "currentColor" })
    ),
    admonition: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M12.0001 21.4C11.7654 21.4 11.5385 21.3548 11.3193 21.2645C11.1002 21.174 10.9002 21.0435 10.7193 20.873L3.1271 13.2807C2.9566 13.0999 2.8261 12.8999 2.7356 12.6807C2.64526 12.4616 2.6001 12.2346 2.6001 12C2.6001 11.7653 2.64526 11.5358 2.7356 11.3115C2.8261 11.0871 2.9566 10.8897 3.1271 10.7192L10.7193 3.12698C10.9002 2.94614 11.1002 2.81314 11.3193 2.72798C11.5385 2.64264 11.7654 2.59998 12.0001 2.59998C12.2348 2.59998 12.4643 2.64264 12.6886 2.72798C12.9129 2.81314 13.1103 2.94614 13.2808 3.12698L20.8731 10.7192C21.0539 10.8897 21.1869 11.0871 21.2721 11.3115C21.3574 11.5358 21.4001 11.7653 21.4001 12C21.4001 12.2346 21.3574 12.4616 21.2721 12.6807C21.1869 12.8999 21.0539 13.0999 20.8731 13.2807L13.2808 20.873C13.1103 21.0435 12.9129 21.174 12.6886 21.2645C12.4643 21.3548 12.2348 21.4 12.0001 21.4ZM12.2213 19.8037L19.8039 12.2212C19.8552 12.1699 19.8808 12.0961 19.8808 12C19.8808 11.9038 19.8552 11.8301 19.8039 11.7787L12.2213 4.19623C12.17 4.14489 12.0963 4.11923 12.0001 4.11923C11.9039 4.11923 11.8302 4.14489 11.7788 4.19623L4.19635 11.7787C4.14501 11.8301 4.11935 11.9038 4.11935 12C4.11935 12.0961 4.14501 12.1699 4.19635 12.2212L11.7788 19.8037C11.8302 19.8551 11.9039 19.8807 12.0001 19.8807C12.0963 19.8807 12.17 19.8551 12.2213 19.8037ZM11.2501 13.0865H12.7501V7.47123H11.2501V13.0865ZM12.0001 15.702C12.2258 15.702 12.4168 15.6237 12.5731 15.4672C12.7296 15.3109 12.8078 15.1199 12.8078 14.8942C12.8078 14.6686 12.7296 14.4776 12.5731 14.3212C12.4168 14.1647 12.2258 14.0865 12.0001 14.0865C11.7744 14.0865 11.5834 14.1647 11.4271 14.3212C11.2706 14.4776 11.1923 14.6686 11.1923 14.8942C11.1923 15.1199 11.2706 15.3109 11.4271 15.4672C11.5834 15.6237 11.7744 15.702 12.0001 15.702Z",
        fill: "currentColor",
      })
    ),
    sandpack: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M12.9999 22.5C12.4947 22.5 12.0671 22.325 11.7171 21.975C11.3671 21.625 11.1921 21.1974 11.1921 20.6922V7.30775C11.1921 6.80258 11.3671 6.375 11.7171 6.025C12.0671 5.675 12.4947 5.5 12.9999 5.5H16.3844C16.8895 5.5 17.3171 5.675 17.6671 6.025C18.0171 6.375 18.1921 6.80258 18.1921 7.30775V20.6922C18.1921 21.1974 18.0171 21.625 17.6671 21.975C17.3171 22.325 16.8895 22.5 16.3844 22.5H12.9999ZM12.6921 7.30775V20.6922C12.6921 20.7692 12.7242 20.8398 12.7884 20.9038C12.8524 20.9679 12.9229 21 12.9999 21H16.3844C16.4614 21 16.5319 20.9679 16.5959 20.9038C16.66 20.8398 16.6921 20.7692 16.6921 20.6922V7.30775C16.6921 7.23075 16.66 7.16025 16.5959 7.09625C16.5319 7.03208 16.4614 7 16.3844 7H12.9999C12.9229 7 12.8524 7.03208 12.7884 7.09625C12.7242 7.16025 12.6921 7.23075 12.6921 7.30775ZM6.61537 18.5C6.1102 18.5 5.68262 18.325 5.33262 17.975C4.98262 17.625 4.80762 17.1974 4.80762 16.6923V3.30775C4.80762 2.80258 4.98262 2.375 5.33262 2.025C5.68262 1.675 6.1102 1.5 6.61537 1.5H9.99987C10.505 1.5 10.9326 1.675 11.2826 2.025C11.6326 2.375 11.8076 2.80258 11.8076 3.30775V16.6923C11.8076 17.1974 11.6326 17.625 11.2826 17.975C10.9326 18.325 10.505 18.5 9.99987 18.5H6.61537ZM6.30762 3.30775V16.6923C6.30762 16.7692 6.3397 16.8398 6.40387 16.9038C6.46787 16.9679 6.53837 17 6.61537 17H9.99987C10.0769 17 10.1474 16.9679 10.2114 16.9038C10.2755 16.8398 10.3076 16.7692 10.3076 16.6923V3.30775C10.3076 3.23075 10.2755 3.16025 10.2114 3.09625C10.1474 3.03208 10.0769 3 9.99987 3H6.61537C6.53837 3 6.46787 3.03208 6.40387 3.09625C6.3397 3.16025 6.30762 3.23075 6.30762 3.30775Z",
        fill: "currentColor",
      })
    ),
    rich_text: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19ZM6.75 17H17.3268L14 12.3655L11.2308 16.0192L9 13.4615L6.75 17Z",
        fill: "currentColor",
      }),
      S.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6 12V6.5H9.1925C9.5925 6.5 9.9425 6.65 10.2425 6.95C10.5425 7.25 10.6925 7.6 10.6925 8V8.6925C10.6925 9.03733 10.605 9.32675 10.43 9.56075C10.255 9.79458 10.0168 9.97817 9.7155 10.1115L10.6155 12H9.404L8.504 10.1925H7.1925V12H6ZM9.1925 9H7.1925V7.6925H9.1925C9.26933 7.6925 9.33983 7.7245 9.404 7.7885C9.468 7.85267 9.5 7.92317 9.5 8V8.6925C9.5 8.76933 9.468 8.83983 9.404 8.904C9.33983 8.968 9.26933 9 9.1925 9Z",
        fill: "currentColor",
      }),
      S.createElement("path", { d: "M12.5 7H17.5V8.25H12.5V7Z", fill: "currentColor" }),
      S.createElement("path", { d: "M12.5 9.25H17.5V10.5H12.5V9.25Z", fill: "currentColor" })
    ),
    difference: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
        fill: "currentColor",
      }),
      S.createElement("rect", { x: "9", y: "10", width: "5.5", height: "1.5", fill: "currentColor" }),
      S.createElement("rect", { x: "9", y: "15", width: "5.5", height: "1.5", fill: "currentColor" }),
      S.createElement("rect", { x: "11", y: "8", width: "1.5", height: "5.5", fill: "currentColor" })
    ),
    markdown: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
        fill: "currentColor",
      }),
      S.createElement("path", { d: "M13 15H11.5V11L9.5 14L7.5 11V15H6V8H7.5L9.5 11L11.5 8H13V15Z", fill: "currentColor" }),
      S.createElement("path", {
        d: "M15.9921 15.5833L13.2886 12.8797L14.0546 12.1137L15.4504 13.5016V7.99597L16.5336 7.99993V13.5016L17.9296 12.1137L18.6954 12.8797L15.9921 15.5833Z",
        fill: "currentColor",
      })
    ),
    open_in_new: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H11.6152V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V12.3848H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM9.71925 15.3345L8.6655 14.2808L17.9462 5H14V3.5H20.5V10H19V6.05375L9.71925 15.3345Z",
        fill: "currentColor",
      })
    ),
    link_off: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M18.8843 16.1038L17.7498 14.9385C18.4228 14.7552 18.9661 14.3946 19.3796 13.8568C19.7931 13.319 19.9998 12.7 19.9998 12C19.9998 11.1604 19.705 10.444 19.1153 9.85105C18.5255 9.25805 17.8139 8.96155 16.9806 8.96155H13.1728V7.46155H16.9806C18.2293 7.46155 19.2947 7.90422 20.1768 8.78955C21.0588 9.67472 21.4998 10.7449 21.4998 12C21.4998 12.8859 21.262 13.6951 20.7863 14.4278C20.3107 15.1606 19.6767 15.7193 18.8843 16.1038ZM15.5806 12.75L14.0806 11.25H15.7306V12.75H15.5806ZM20.1461 22.2538L1.74609 3.8538L2.79984 2.80005L21.1998 21.2L20.1461 22.2538ZM10.8268 16.5386H7.03834C5.78318 16.5386 4.71301 16.0959 3.82784 15.2105C2.94251 14.3254 2.49984 13.2552 2.49984 12C2.49984 10.8885 2.85784 9.91322 3.57384 9.07405C4.28984 8.23505 5.18826 7.72838 6.26909 7.55405H6.49984L7.90759 8.96155H7.03834C6.19851 8.96155 5.48218 9.25805 4.88934 9.85105C4.29634 10.444 3.99984 11.1604 3.99984 12C3.99984 12.8397 4.29634 13.556 4.88934 14.149C5.48218 14.742 6.19851 15.0385 7.03834 15.0385H10.8268V16.5386ZM8.26909 12.75V11.25H10.2113L11.6863 12.75H8.26909Z",
        fill: "currentColor",
      })
    ),
    edit: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M5 19H6.2615L16.498 8.7635L15.2365 7.502L5 17.7385V19ZM3.5 20.5V17.1155L16.6905 3.93075C16.8417 3.79342 17.0086 3.68733 17.1913 3.6125C17.3741 3.5375 17.5658 3.5 17.7663 3.5C17.9668 3.5 18.1609 3.53558 18.3488 3.60675C18.5367 3.67792 18.7032 3.79108 18.848 3.94625L20.0693 5.18275C20.2244 5.32758 20.335 5.49425 20.401 5.68275C20.467 5.87125 20.5 6.05975 20.5 6.24825C20.5 6.44942 20.4657 6.64133 20.397 6.824C20.3283 7.00683 20.2191 7.17383 20.0693 7.325L6.8845 20.5H3.5ZM15.8562 8.14375L15.2365 7.502L16.498 8.7635L15.8562 8.14375Z",
        fill: "currentColor",
      })
    ),
    content_copy: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M9.05775 17.5C8.55258 17.5 8.125 17.325 7.775 16.975C7.425 16.625 7.25 16.1974 7.25 15.6923V4.30775C7.25 3.80258 7.425 3.375 7.775 3.025C8.125 2.675 8.55258 2.5 9.05775 2.5H17.4423C17.9474 2.5 18.375 2.675 18.725 3.025C19.075 3.375 19.25 3.80258 19.25 4.30775V15.6923C19.25 16.1974 19.075 16.625 18.725 16.975C18.375 17.325 17.9474 17.5 17.4423 17.5H9.05775ZM9.05775 16H17.4423C17.5192 16 17.5898 15.9679 17.6538 15.9038C17.7179 15.8398 17.75 15.7692 17.75 15.6923V4.30775C17.75 4.23075 17.7179 4.16025 17.6538 4.09625C17.5898 4.03208 17.5192 4 17.4423 4H9.05775C8.98075 4 8.91025 4.03208 8.84625 4.09625C8.78208 4.16025 8.75 4.23075 8.75 4.30775V15.6923C8.75 15.7692 8.78208 15.8398 8.84625 15.9038C8.91025 15.9679 8.98075 16 9.05775 16ZM5.55775 21C5.05258 21 4.625 20.825 4.275 20.475C3.925 20.125 3.75 19.6974 3.75 19.1923V6.30775H5.25V19.1923C5.25 19.2693 5.28208 19.3398 5.34625 19.4038C5.41025 19.4679 5.48075 19.5 5.55775 19.5H15.4423V21H5.55775Z",
        fill: "currentColor",
      })
    ),
    more_horiz: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M6.23096 13.5C5.81846 13.5 5.46537 13.3531 5.17171 13.0592C4.87787 12.7656 4.73096 12.4125 4.73096 12C4.73096 11.5875 4.87787 11.2344 5.17171 10.9408C5.46537 10.6469 5.81846 10.5 6.23096 10.5C6.64346 10.5 6.99662 10.6469 7.29046 10.9408C7.58412 11.2344 7.73096 11.5875 7.73096 12C7.73096 12.4125 7.58412 12.7656 7.29046 13.0592C6.99662 13.3531 6.64346 13.5 6.23096 13.5ZM12.0002 13.5C11.5877 13.5 11.2346 13.3531 10.941 13.0592C10.6471 12.7656 10.5002 12.4125 10.5002 12C10.5002 11.5875 10.6471 11.2344 10.941 10.9408C11.2346 10.6469 11.5877 10.5 12.0002 10.5C12.4127 10.5 12.7658 10.6469 13.0595 10.9408C13.3533 11.2344 13.5002 11.5875 13.5002 12C13.5002 12.4125 13.3533 12.7656 13.0595 13.0592C12.7658 13.3531 12.4127 13.5 12.0002 13.5ZM17.7695 13.5C17.357 13.5 17.0038 13.3531 16.71 13.0592C16.4163 12.7656 16.2695 12.4125 16.2695 12C16.2695 11.5875 16.4163 11.2344 16.71 10.9408C17.0038 10.6469 17.357 10.5 17.7695 10.5C18.182 10.5 18.535 10.6469 18.8287 10.9408C19.1225 11.2344 19.2695 11.5875 19.2695 12C19.2695 12.4125 19.1225 12.7656 18.8287 13.0592C18.535 13.3531 18.182 13.5 17.7695 13.5Z",
        fill: "currentColor",
      })
    ),
    more_vert: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M12 19.2692C11.5875 19.2692 11.2344 19.1223 10.9408 18.8285C10.6469 18.5348 10.5 18.1817 10.5 17.7692C10.5 17.3567 10.6469 17.0035 10.9408 16.7097C11.2344 16.416 11.5875 16.2692 12 16.2692C12.4125 16.2692 12.7656 16.416 13.0592 16.7097C13.3531 17.0035 13.5 17.3567 13.5 17.7692C13.5 18.1817 13.3531 18.5348 13.0592 18.8285C12.7656 19.1223 12.4125 19.2692 12 19.2692ZM12 13.5C11.5875 13.5 11.2344 13.353 10.9408 13.0592C10.6469 12.7655 10.5 12.4125 10.5 12C10.5 11.5875 10.6469 11.2344 10.9408 10.9407C11.2344 10.6469 11.5875 10.5 12 10.5C12.4125 10.5 12.7656 10.6469 13.0592 10.9407C13.3531 11.2344 13.5 11.5875 13.5 12C13.5 12.4125 13.3531 12.7655 13.0592 13.0592C12.7656 13.353 12.4125 13.5 12 13.5ZM12 7.73071C11.5875 7.73071 11.2344 7.58388 10.9408 7.29021C10.6469 6.99638 10.5 6.64321 10.5 6.23071C10.5 5.81821 10.6469 5.46513 10.9408 5.17146C11.2344 4.87763 11.5875 4.73071 12 4.73071C12.4125 4.73071 12.7656 4.87763 13.0592 5.17146C13.3531 5.46513 13.5 5.81821 13.5 6.23071C13.5 6.64321 13.3531 6.99638 13.0592 7.29021C12.7656 7.58388 12.4125 7.73071 12 7.73071Z",
        fill: "currentColor",
      })
    ),
    close: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M6.39994 18.6538L5.34619 17.6L10.9462 12L5.34619 6.4L6.39994 5.34625L11.9999 10.9463L17.5999 5.34625L18.6537 6.4L13.0537 12L18.6537 17.6L17.5999 18.6538L11.9999 13.0538L6.39994 18.6538Z",
        fill: "currentColor",
      })
    ),
    settings: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M9.69225 21.5L9.3115 18.4538C9.04367 18.3641 8.769 18.2385 8.4875 18.077C8.20617 17.9153 7.95459 17.7422 7.73275 17.5577L4.9115 18.75L2.604 14.75L5.04425 12.9058C5.02125 12.7571 5.00492 12.6077 4.99525 12.4578C4.98559 12.3078 4.98075 12.1583 4.98075 12.0095C4.98075 11.8673 4.98559 11.7228 4.99525 11.576C5.00492 11.4292 5.02125 11.2686 5.04425 11.0943L2.604 9.25L4.9115 5.26925L7.723 6.452C7.96417 6.261 8.22159 6.08633 8.49525 5.928C8.76892 5.76967 9.03784 5.64242 9.302 5.54625L9.69225 2.5H14.3078L14.6885 5.55575C14.9885 5.66475 15.2599 5.792 15.5028 5.9375C15.7458 6.083 15.991 6.2545 16.2385 6.452L19.0885 5.26925L21.396 9.25L18.9173 11.123C18.9531 11.2845 18.9727 11.4355 18.976 11.576C18.9792 11.7163 18.9808 11.8577 18.9808 12C18.9808 12.1358 18.9775 12.274 18.971 12.4145C18.9647 12.5548 18.9417 12.7154 18.902 12.8963L21.3615 14.75L19.0538 18.75L16.2385 17.548C15.991 17.7455 15.7384 17.9202 15.4808 18.072C15.2231 18.224 14.959 18.3481 14.6885 18.4443L14.3078 21.5H9.69225ZM11 20H12.9655L13.325 17.3212C13.8353 17.1879 14.3017 16.9985 14.724 16.753C15.1465 16.5073 15.5539 16.1916 15.9463 15.8057L18.4308 16.85L19.4155 15.15L17.2463 13.5155C17.3296 13.2565 17.3863 13.0026 17.4163 12.7537C17.4464 12.5051 17.4615 12.2538 17.4615 12C17.4615 11.7397 17.4464 11.4884 17.4163 11.2463C17.3863 11.0039 17.3296 10.7564 17.2463 10.5038L19.4345 8.85L18.45 7.15L15.9365 8.2095C15.6018 7.85183 15.2009 7.53583 14.7338 7.2615C14.2664 6.98717 13.7937 6.79292 13.3155 6.67875L13 4H11.0155L10.6845 6.66925C10.1743 6.78975 9.70325 6.97433 9.27125 7.223C8.83909 7.47183 8.42684 7.79233 8.0345 8.1845L5.55 7.15L4.5655 8.85L6.725 10.4595C6.64167 10.6968 6.58334 10.9437 6.55 11.2C6.51667 11.4563 6.5 11.7262 6.5 12.0095C6.5 12.2698 6.51667 12.525 6.55 12.775C6.58334 13.025 6.6385 13.2718 6.7155 13.5155L4.5655 15.15L5.55 16.85L8.025 15.8C8.4045 16.1897 8.81025 16.5089 9.24225 16.7578C9.67442 17.0064 10.152 17.1974 10.675 17.3307L11 20ZM12.0115 15C12.8435 15 13.5515 14.708 14.1355 14.124C14.7195 13.54 15.0115 12.832 15.0115 12C15.0115 11.168 14.7195 10.46 14.1355 9.876C13.5515 9.292 12.8435 9 12.0115 9C11.1692 9 10.4586 9.292 9.87975 9.876C9.30092 10.46 9.0115 11.168 9.0115 12C9.0115 12.832 9.30092 13.54 9.87975 14.124C10.4586 14.708 11.1692 15 12.0115 15Z",
        fill: "currentColor",
      })
    ),
    delete_big: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
        fill: "currentColor",
      })
    ),
    delete_small: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
        fill: "currentColor",
      })
    ),
    format_align_center: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M3.5 20.5V19H20.5V20.5H3.5ZM7.5 16.625V15.125H16.5V16.625H7.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM7.5 8.875V7.375H16.5V8.875H7.5ZM3.5 5V3.5H20.5V5H3.5Z",
        fill: "currentColor",
      })
    ),
    format_align_left: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M3.5 20.5V19H20.5V20.5H3.5ZM3.5 16.625V15.125H14.5V16.625H3.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM3.5 8.875V7.375H14.5V8.875H3.5ZM3.5 5V3.5H20.5V5H3.5Z",
        fill: "currentColor",
      })
    ),
    format_align_right: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M3.5 5V3.5H20.5V5H3.5ZM9.5 8.875V7.375H20.5V8.875H9.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM9.5 16.625V15.125H20.5V16.625H9.5ZM3.5 20.5V19H20.5V20.5H3.5Z",
        fill: "currentColor",
      })
    ),
    add_row: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M4.025 10.2077C4.375 9.85775 4.80258 9.68275 5.30775 9.68275H6.5V11.1827H5.30775C5.21792 11.1827 5.14417 11.2116 5.0865 11.2693C5.02883 11.3269 5 11.4007 5 11.4905V16.1923C5 16.2821 5.02883 16.3558 5.0865 16.4135C5.14417 16.4712 5.21792 16.5 5.30775 16.5H18.6923C18.7821 16.5 18.8558 16.4712 18.9135 16.4135C18.9712 16.3558 19 16.2821 19 16.1923V11.4905C19 11.4007 18.9712 11.3269 18.9135 11.2693C18.8558 11.2116 18.7821 11.1827 18.6923 11.1827H17.6923V9.68275H18.6923C19.1974 9.68275 19.625 9.85775 19.975 10.2077C20.325 10.5577 20.5 10.9853 20.5 11.4905V16.1923C20.5 16.6974 20.325 17.125 19.975 17.475C19.625 17.825 19.1974 18 18.6923 18H5.30775C4.80258 18 4.375 17.825 4.025 17.475C3.675 17.125 3.5 16.6974 3.5 16.1923V11.4905C3.5 10.9853 3.675 10.5577 4.025 10.2077Z",
        fill: "currentColor",
      }),
      S.createElement("path", {
        d: "M11.3848 9.68275V7.5H12.8848V9.68275H15V11.1827H12.8848V13.2307H11.3848V11.1827H9.26925V9.68275H11.3848Z",
        fill: "currentColor",
      })
    ),
    add_column: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9.70775 4.025C9.35775 4.375 9.18275 4.80258 9.18275 5.30775V6.5H10.6827V5.30775C10.6827 5.21792 10.7116 5.14417 10.7693 5.0865C10.8269 5.02883 10.9007 5 10.9905 5H15.6923C15.7821 5 15.8558 5.02883 15.9135 5.0865C15.9712 5.14417 16 5.21792 16 5.30775V18.6923C16 18.7821 15.9712 18.8558 15.9135 18.9135C15.8558 18.9712 15.7821 19 15.6923 19H10.9905C10.9007 19 10.8269 18.9712 10.7693 18.9135C10.7116 18.8558 10.6827 18.7821 10.6827 18.6923V17.6923H9.18275V18.6923C9.18275 19.1974 9.35775 19.625 9.70775 19.975C10.0577 20.325 10.4853 20.5 10.9905 20.5H15.6923C16.1974 20.5 16.625 20.325 16.975 19.975C17.325 19.625 17.5 19.1974 17.5 18.6923V5.30775C17.5 4.80258 17.325 4.375 16.975 4.025C16.625 3.675 16.1974 3.5 15.6923 3.5H10.9905C10.4853 3.5 10.0577 3.675 9.70775 4.025Z",
        fill: "currentColor",
      }),
      S.createElement("path", {
        d: "M9.18275 11.3848H7V12.8848H9.18275V15H10.6827V12.8848H12.7307V11.3848H10.6827V9.26925H9.18275V11.3848Z",
        fill: "currentColor",
      })
    ),
    insert_col_left: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M13.0001 20.1152H8.67713H8.75388H8.69238H13.0001ZM7.19238 19.8075C7.19238 20.3127 7.36738 20.7402 7.71738 21.0902C8.06738 21.4402 8.49497 21.6152 9.00013 21.6152H12.6924C13.1975 21.6152 13.6251 21.4402 13.9751 21.0902C14.3251 20.7402 14.5001 20.3127 14.5001 19.8075V10.423H13.0001V19.8075C13.0001 19.8973 12.9713 19.9711 12.9136 20.0287C12.856 20.0864 12.7822 20.1152 12.6924 20.1152H9.00013C8.9103 20.1152 8.83655 20.0864 8.77888 20.0287C8.72122 19.9711 8.69238 19.8973 8.69238 19.8075V4.69223C8.26422 4.74357 7.90722 4.93299 7.62138 5.26048C7.33538 5.58798 7.19238 5.97548 7.19238 6.42298V19.8075ZM13.0001 2.49998V4.61523H10.8846V6.11523H13.0001V8.23073H14.5001V6.11523H16.6154V4.61523H14.5001V2.49998H13.0001Z",
        fill: "currentColor",
      })
    ),
    insert_row_above: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M20.1152 9.99987V14.3229V14.2461V14.3076V9.99987ZM19.8075 15.8076C20.3127 15.8076 20.7402 15.6326 21.0902 15.2826C21.4402 14.9326 21.6152 14.505 21.6152 13.9999V10.3076C21.6152 9.80245 21.4402 9.37487 21.0902 9.02487C20.7402 8.67487 20.3127 8.49987 19.8075 8.49987H10.423V9.99987H19.8075C19.8973 9.99987 19.9711 10.0287 20.0287 10.0864C20.0864 10.144 20.1152 10.2178 20.1152 10.3076V13.9999C20.1152 14.0897 20.0864 14.1635 20.0287 14.2211C19.9711 14.2788 19.8973 14.3076 19.8075 14.3076H4.69223C4.74357 14.7358 4.93299 15.0928 5.26048 15.3786C5.58798 15.6646 5.97548 15.8076 6.42298 15.8076H19.8075ZM2.49998 9.99987H4.61523V12.1154H6.11523V9.99987H8.23073V8.49987H6.11523V6.38462H4.61523V8.49987H2.49998V9.99987Z",
        fill: "currentColor",
      })
    ),
    insert_row_below: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M20.1152 14.1924V9.86939V9.94614V9.88464V14.1924ZM19.8075 8.38464C20.3127 8.38464 20.7402 8.55964 21.0902 8.90964C21.4402 9.25964 21.6152 9.68723 21.6152 10.1924V13.8846C21.6152 14.3898 21.4402 14.8174 21.0902 15.1674C20.7402 15.5174 20.3127 15.6924 19.8075 15.6924H10.423V14.1924H19.8075C19.8973 14.1924 19.9711 14.1636 20.0287 14.1059C20.0864 14.0482 20.1152 13.9745 20.1152 13.8846V10.1924C20.1152 10.1026 20.0864 10.0288 20.0287 9.97114C19.9711 9.91348 19.8973 9.88464 19.8075 9.88464H4.69223C4.74357 9.45648 4.93299 9.09948 5.26048 8.81364C5.58798 8.52764 5.97548 8.38464 6.42298 8.38464H19.8075ZM2.49998 14.1924H4.61523V12.0769H6.11523V14.1924H8.23073V15.6924H6.11523V17.8076H4.61523V15.6924H2.49998V14.1924Z",
        fill: "currentColor",
      })
    ),
    insert_col_right: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M10.8075 20.1152H15.1305H15.0537H15.1152H10.8075ZM16.6152 19.8075C16.6152 20.3127 16.4402 20.7402 16.0902 21.0902C15.7402 21.4402 15.3127 21.6152 14.8075 21.6152H11.1152C10.6101 21.6152 10.1825 21.4402 9.83248 21.0902C9.48248 20.7402 9.30748 20.3127 9.30748 19.8075V10.423H10.8075V19.8075C10.8075 19.8973 10.8363 19.9711 10.894 20.0287C10.9517 20.0864 11.0254 20.1152 11.1152 20.1152H14.8075C14.8973 20.1152 14.9711 20.0864 15.0287 20.0287C15.0864 19.9711 15.1152 19.8973 15.1152 19.8075V4.69223C15.5434 4.74357 15.9004 4.93299 16.1862 5.26048C16.4722 5.58798 16.6152 5.97548 16.6152 6.42298V19.8075ZM10.8075 2.49998V4.61523H12.923V6.11523H10.8075V8.23073H9.30748V6.11523H7.19223V4.61523H9.30748V2.49998H10.8075Z",
        fill: "currentColor",
      })
    ),
    check: S.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      S.createElement("path", {
        d: "M9.54983 17.6537L4.21533 12.3192L5.28433 11.25L9.54983 15.5155L18.7153 6.34998L19.7843 7.41923L9.54983 17.6537Z",
        fill: "currentColor",
      })
    ),
  },
  qZ = ({ children: t }) => {
    const e = mt(Un),
      n = S.useMemo(() => [e, aT(null, Om)], [e]);
    return S.createElement(gf.Provider, { value: n }, t);
  },
  YZ = () => {
    const t = nt(),
      [e, n, r, i, o] = Ye(Qf, ix, ox, sx, Df);
    return S.createElement(
      S.Fragment,
      null,
      r.map((s, l) => S.createElement(s, { key: l })),
      S.createElement(
        vA,
        { wrappers: i },
        S.createElement(
          "div",
          { className: Fe(F.rootContentEditableWrapper, "mdxeditor-root-contenteditable") },
          S.createElement(fx, {
            contentEditable: S.createElement(hx, {
              className: Fe(F.contentEditable, e),
              ariaLabel: t("contentArea.editableMarkdown", "editable markdown"),
            }),
            placeholder: S.createElement("div", { className: Fe(F.contentEditable, F.placeholder, e) }, S.createElement("p", null, o)),
            ErrorBoundary: dx,
          })
        )
      ),
      n.map((s, l) => S.createElement(s, { key: l }))
    );
  },
  GZ = { listItemIndent: "one" },
  JZ = (t) => HZ[t];
function KZ(t, e, n = {}) {
  let r = e;
  for (const [i, o] of Object.entries(n)) r = r.replaceAll(`{{${i}}}`, String(o));
  return r;
}
const vA = ({ wrappers: t, children: e }) => {
    if (t.length === 0) return S.createElement(S.Fragment, null, e);
    const n = t[0];
    return S.createElement(n, null, S.createElement(vA, { wrappers: t.slice(1) }, e));
  },
  ez = ({ children: t, className: e }) => {
    const n = S.useRef(null),
      r = He(jr);
    return (
      S.useEffect(() => {
        const i = document.createElement("div");
        return (
          i.classList.add("mdxeditor-popup-container", F.editorRoot, F.popupContainer, ...(e ?? "").trim().split(" ").filter(Boolean)),
          document.body.appendChild(i),
          (n.current = i),
          r(n),
          () => {
            i.remove();
          }
        );
      }, [e, n, r]),
      S.createElement("div", { className: Fe("mdxeditor", F.editorRoot, F.editorWrapper, e) }, t)
    );
  },
  tz = ({ mdxRef: t }) => {
    const e = Oa();
    return (
      S.useImperativeHandle(
        t,
        () => ({
          getMarkdown: () => (e.getValue(No) === "source" ? e.getValue(Ts) : e.getValue(Ir)),
          setMarkdown: (n) => {
            e.pub(ym, n);
          },
          insertMarkdown: (n) => {
            e.pub(ex, n);
          },
          focus: (n, r) => {
            var i;
            (i = e.getValue(Un)) == null || i.focus(n, r);
          },
        }),
        [e]
      ),
      null
    );
  },
  nz = S.forwardRef((t, e) =>
    S.createElement(
      lT,
      {
        plugins: [
          gA({
            contentEditableClassName: t.contentEditableClassName ?? "",
            initialMarkdown: t.markdown,
            onChange: t.onChange ?? Co,
            onBlur: t.onBlur ?? Co,
            toMarkdownOptions: t.toMarkdownOptions ?? GZ,
            autoFocus: t.autoFocus ?? !1,
            placeholder: t.placeholder ?? "",
            readOnly: !!t.readOnly,
            iconComponentFor: t.iconComponentFor ?? JZ,
            suppressHtmlProcessing: t.suppressHtmlProcessing ?? !1,
            onError: t.onError ?? Co,
            translation: t.translation ?? KZ,
          }),
          ...(t.plugins ?? []),
        ],
      },
      S.createElement(ez, { className: t.className }, S.createElement(qZ, null, S.createElement(YZ, null))),
      S.createElement(tz, { mdxRef: e })
    )
  ),
  rz = {
    testLexicalNode: hm,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      const n = parseInt(t.getTag()[1], 10);
      e.addAndStepInto("heading", { depth: n });
    },
  },
  iz = {
    testNode: "heading",
    visitNode: function ({ mdastNode: t, actions: e }) {
      e.addAndStepInto(si(`h${t.depth}`));
    },
  },
  oz = [48, 49, 50, 51, 52, 53, 54],
  px = [1, 2, 3, 4, 5, 6],
  sz = { 49: 1, 50: 2, 51: 3, 52: 4, 53: 5, 54: 6 },
  ah = we(px, (t) => {
    t.pub(lh, (e) =>
      e.registerCommand(
        nb,
        (n) => {
          const { keyCode: r, ctrlKey: i, metaKey: o, altKey: s } = n;
          return oz.includes(r) && Hb(o, i) && s
            ? (n.preventDefault(),
              e.update(() => {
                if (r === 48) t.pub(ou, () => tt());
                else {
                  const l = t.getValue(ah),
                    a = sz[r];
                  l.includes(a) || t.pub(ou, () => si(`h${a}`));
                }
              }),
              !0)
            : !1;
        },
        ht
      )
    );
  }),
  lz = Ut({
    init(t) {
      t.pubIn({ [Ea]: "headings", [Wn]: iz, [ar]: eh, [cr]: rz });
    },
    update(t, e) {
      t.pub(ah, (e == null ? void 0 : e.allowedHeadingLevels) ?? px);
    },
  });
function Wk(t, e) {
  return t.getEditorState().read(() => {
    const n = dt(e);
    return n !== null && n.isSelected();
  });
}
function bA(t) {
  const [e] = In(),
    [n, r] = _.useState(() => Wk(e, t));
  return (
    _.useEffect(() => {
      let i = !0;
      const o = e.registerUpdateListener(() => {
        i && r(Wk(e, t));
      });
      return () => {
        (i = !1), o();
      };
    }, [e, t]),
    [
      n,
      _.useCallback(
        (i) => {
          e.update(() => {
            let o = ae();
            Vt(o) || ((o = M0()), pn(o)), Vt(o) && (i ? o.add(t) : o.delete(t));
          });
        },
        [e, t]
      ),
      _.useCallback(() => {
        e.update(() => {
          const i = ae();
          Vt(i) && i.clear();
        });
      }, [e]),
    ]
  );
}
const xA = Ji();
function az({ nodeKey: t }) {
  const [e] = In(),
    [n, r, i] = bA(t),
    o = _.useCallback(
      (s) => {
        if (n && Vt(ae())) {
          s.preventDefault();
          const l = dt(t);
          if (mx(l)) return l.remove(), !0;
        }
        return !1;
      },
      [n, t]
    );
  return (
    _.useEffect(
      () =>
        Xn(
          e.registerCommand(
            Wp,
            (s) => {
              const l = e.getElementByKey(t);
              return s.target === l && (s.shiftKey || i(), r(!n), !0);
            },
            ht
          ),
          e.registerCommand(Hp, o, ht),
          e.registerCommand(Xu, o, ht)
        ),
      [i, e, n, t, o, r]
    ),
    _.useEffect(() => {
      const s = e.getElementByKey(t),
        l = "selected";
      s !== null && (n ? Rr(s, l) : cm(s, l));
    }, [e, n, t]),
    null
  );
}
let Sm = class yA extends wi {
  static getType() {
    return "horizontalrule";
  }
  static clone(e) {
    return new yA(e.__key);
  }
  static importJSON(e) {
    return ch();
  }
  static importDOM() {
    return { hr: () => ({ conversion: cz, priority: 0 }) };
  }
  exportJSON() {
    return { type: "horizontalrule", version: 1 };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM(e) {
    const n = document.createElement("hr");
    return Rr(n, e.theme.hr), n;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return T.jsx(az, { nodeKey: this.__key });
  }
};
function cz() {
  return { node: ch() };
}
function ch() {
  return Mn(new Sm());
}
function mx(t) {
  return t instanceof Sm;
}
function uz() {
  const [t] = In();
  return (
    _.useEffect(
      () =>
        t.registerCommand(
          xA,
          (e) => {
            const n = ae();
            if (!ee(n)) return !1;
            if (n.focus.getNode() !== null) {
              const r = ch();
              sP(r);
            }
            return !0;
          },
          Ze
        ),
      [t]
    ),
    null
  );
}
const hz = {
    testLexicalNode: mx,
    visitLexicalNode({ actions: t }) {
      t.addAndStepInto("thematicBreak");
    },
  },
  dz = {
    testNode: "thematicBreak",
    visitNode({ actions: t }) {
      t.addAndStepInto(ch());
    },
  },
  gx = Fr((t) => {
    t.sub(t.pipe(gx, pt(St)), ([, e]) => {
      e == null || e.dispatchCommand(xA, void 0);
    });
  }),
  fz = Ut({
    init(t) {
      t.pubIn({ [Wn]: dz, [ar]: Sm, [cr]: hz, [qo]: uz });
    },
  });
function pz(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Qi = pz(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function q0(t) {
  let e = 1,
    n = t.getParent();
  for (; n != null; ) {
    if (Ue(n)) {
      const r = n.getParent();
      if ($e(r)) {
        e++, (n = r.getParent());
        continue;
      }
      Qi(40);
    }
    return e;
  }
  return e;
}
function Y0(t) {
  let e = t.getParent();
  $e(e) || Qi(40);
  let n = e;
  for (; n !== null; ) (n = n.getParent()), $e(n) && (e = n);
  return e;
}
function wA(t) {
  let e = [];
  const n = t.getChildren().filter(Ue);
  for (let r = 0; r < n.length; r++) {
    const i = n[r],
      o = i.getFirstChild();
    $e(o) ? (e = e.concat(wA(o))) : e.push(i);
  }
  return e;
}
function ti(t) {
  return Ue(t) && $e(t.getFirstChild());
}
function Xk(t) {
  return xn().append(t);
}
function SA(t, e) {
  return Ue(t) && (e.length === 0 || (e.length === 1 && t.is(e[0]) && t.getChildrenSize() === 0));
}
function G0(t, e) {
  t.update(() => {
    const n = ae();
    if (n !== null) {
      const r = n.getNodes();
      if (ee(n)) {
        const o = n.getStartEndPoints();
        o === null && Qi(143);
        const [s] = o,
          l = s.getNode(),
          a = l.getParent();
        if (SA(l, r)) {
          const c = vn(e);
          if (Yt(a)) {
            l.replace(c);
            const u = xn();
            X(l) && (u.setFormat(l.getFormatType()), u.setIndent(l.getIndent())), c.append(u);
          } else if (Ue(l)) {
            const u = l.getParentOrThrow();
            Ps(c, u.getChildren()), u.replace(c);
          }
          return;
        }
      }
      const i = new Set();
      for (let o = 0; o < r.length; o++) {
        const s = r[o];
        if (!X(s) || !s.isEmpty() || Ue(s) || i.has(s.getKey())) {
          if (yT(s)) {
            let l = s.getParent();
            for (; l != null; ) {
              const a = l.getKey();
              if ($e(l)) {
                if (!i.has(a)) {
                  const c = vn(e);
                  Ps(c, l.getChildren()), l.replace(c), i.add(a);
                }
                break;
              }
              {
                const c = l.getParent();
                if (Yt(c) && !i.has(a)) {
                  i.add(a), Uk(l, e);
                  break;
                }
                l = c;
              }
            }
          }
        } else Uk(s, e);
      }
    }
  });
}
function Ps(t, e) {
  t.splice(t.getChildrenSize(), 0, e);
}
function Uk(t, e) {
  if ($e(t)) return t;
  const n = t.getPreviousSibling(),
    r = t.getNextSibling(),
    i = xn();
  if ((i.setFormat(t.getFormatType()), i.setIndent(t.getIndent()), Ps(i, t.getChildren()), $e(n) && e === n.getListType()))
    return n.append(i), t.remove(), $e(r) && e === r.getListType() && (Ps(n, r.getChildren()), r.remove()), n;
  if ($e(r) && e === r.getListType()) return r.getFirstChildOrThrow().insertBefore(i), t.remove(), r;
  {
    const o = vn(e);
    return o.append(i), t.replace(o), o;
  }
}
function Ox(t, e) {
  const n = t.getLastChild(),
    r = e.getFirstChild();
  n && r && ti(n) && ti(r) && (Ox(n.getFirstChild(), r.getFirstChild()), r.remove());
  const i = e.getChildren();
  i.length > 0 && t.append(...i), e.remove();
}
function mz(t) {
  t.update(() => {
    const e = ae();
    if (ee(e)) {
      const n = new Set(),
        r = e.getNodes(),
        i = e.anchor.getNode();
      if (SA(i, r)) n.add(Y0(i));
      else
        for (let o = 0; o < r.length; o++) {
          const s = r[o];
          if (yT(s)) {
            const l = iP(s, Yo);
            l != null && n.add(Y0(l));
          }
        }
      for (const o of n) {
        let s = o;
        const l = wA(o);
        for (const a of l) {
          const c = tt();
          Ps(c, a.getChildren()),
            s.insertAfter(c),
            (s = c),
            a.__key === e.anchor.key && e.anchor.set(c.getKey(), 0, "element"),
            a.__key === e.focus.key && e.focus.set(c.getKey(), 0, "element"),
            a.remove();
        }
        o.remove();
      }
    }
  });
}
function gz(t) {
  const e = new Set();
  if (ti(t) || e.has(t.getKey())) return;
  const n = t.getParent(),
    r = t.getNextSibling(),
    i = t.getPreviousSibling();
  if (ti(r) && ti(i)) {
    const o = i.getFirstChild();
    if ($e(o)) {
      o.append(t);
      const s = r.getFirstChild();
      $e(s) && (Ps(o, s.getChildren()), r.remove(), e.add(r.getKey()));
    }
  } else if (ti(r)) {
    const o = r.getFirstChild();
    if ($e(o)) {
      const s = o.getFirstChild();
      s !== null && s.insertBefore(t);
    }
  } else if (ti(i)) {
    const o = i.getFirstChild();
    $e(o) && o.append(t);
  } else if ($e(n)) {
    const o = xn(),
      s = vn(n.getListType());
    o.append(s), s.append(t), i ? i.insertAfter(o) : r ? r.insertBefore(o) : n.append(o);
  }
}
function Oz(t) {
  if (ti(t)) return;
  const e = t.getParent(),
    n = e ? e.getParent() : void 0;
  if ($e(n ? n.getParent() : void 0) && Ue(n) && $e(e)) {
    const r = e ? e.getFirstChild() : void 0,
      i = e ? e.getLastChild() : void 0;
    if (t.is(r)) n.insertBefore(t), e.isEmpty() && n.remove();
    else if (t.is(i)) n.insertAfter(t), e.isEmpty() && n.remove();
    else {
      const o = e.getListType(),
        s = xn(),
        l = vn(o);
      s.append(l), t.getPreviousSiblings().forEach((u) => l.append(u));
      const a = xn(),
        c = vn(o);
      a.append(c), Ps(c, t.getNextSiblings()), n.insertBefore(s), n.insertAfter(a), n.replace(t);
    }
  }
}
function vz() {
  const t = ae();
  if (!ee(t) || !t.isCollapsed()) return !1;
  const e = t.anchor.getNode();
  if (!Ue(e) || e.getChildrenSize() !== 0) return !1;
  const n = Y0(e),
    r = e.getParent();
  $e(r) || Qi(40);
  const i = r.getParent();
  let o;
  if (Yt(i)) (o = tt()), n.insertAfter(o);
  else {
    if (!Ue(i)) return !1;
    (o = xn()), i.insertAfter(o);
  }
  o.select();
  const s = e.getNextSiblings();
  if (s.length > 0) {
    const l = vn(r.getListType());
    if (zi(o)) o.insertAfter(l);
    else {
      const a = xn();
      a.append(l), o.insertAfter(a);
    }
    s.forEach((a) => {
      a.remove(), l.append(a);
    });
  }
  return (
    (function (l) {
      let a = l;
      for (; a.getNextSibling() == null && a.getPreviousSibling() == null; ) {
        const c = a.getParent();
        if (c == null || (!Ue(a) && !$e(a))) break;
        a = c;
      }
      a.remove();
    })(e),
    !0
  );
}
function jf(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
let Yo = class kA extends Vr {
  static getType() {
    return "listitem";
  }
  static clone(e) {
    return new kA(e.__value, e.__checked, e.__key);
  }
  constructor(e, n, r) {
    super(r), (this.__value = e === void 0 ? 1 : e), (this.__checked = n);
  }
  createDOM(e) {
    const n = document.createElement("li"),
      r = this.getParent();
    return $e(r) && r.getListType() === "check" && qk(n, this, null), (n.value = this.__value), Hk(n, e.theme, this), n;
  }
  updateDOM(e, n, r) {
    const i = this.getParent();
    return $e(i) && i.getListType() === "check" && qk(n, this, e), (n.value = this.__value), Hk(n, r.theme, this), !1;
  }
  static transform() {
    return (e) => {
      if ((Ue(e) || Qi(144), e.__checked == null)) return;
      const n = e.getParent();
      $e(n) && n.getListType() !== "check" && e.getChecked() != null && e.setChecked(void 0);
    };
  }
  static importDOM() {
    return { li: () => ({ conversion: bz, priority: 0 }) };
  }
  static importJSON(e) {
    const n = xn();
    return n.setChecked(e.checked), n.setValue(e.value), n.setFormat(e.format), n.setDirection(e.direction), n;
  }
  exportDOM(e) {
    const n = this.createDOM(e._config);
    return (n.style.textAlign = this.getFormatType()), { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), checked: this.getChecked(), type: "listitem", value: this.getValue(), version: 1 };
  }
  append(...e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (X(r) && this.canMergeWith(r)) {
        const i = r.getChildren();
        this.append(...i), r.remove();
      } else super.append(r);
    }
    return this;
  }
  replace(e, n) {
    if (Ue(e)) return super.replace(e);
    this.setIndent(0);
    const r = this.getParentOrThrow();
    if (!$e(r)) return e;
    if (r.__first === this.getKey()) r.insertBefore(e);
    else if (r.__last === this.getKey()) r.insertAfter(e);
    else {
      const i = vn(r.getListType());
      let o = this.getNextSibling();
      for (; o; ) {
        const s = o;
        (o = o.getNextSibling()), i.append(s);
      }
      r.insertAfter(e), e.insertAfter(i);
    }
    return (
      n &&
        (X(e) || Qi(139),
        this.getChildren().forEach((i) => {
          e.append(i);
        })),
      this.remove(),
      r.getChildrenSize() === 0 && r.remove(),
      e
    );
  }
  insertAfter(e, n = !0) {
    const r = this.getParentOrThrow();
    if (($e(r) || Qi(39), Ue(e))) return super.insertAfter(e, n);
    const i = this.getNextSiblings();
    if ((r.insertAfter(e, n), i.length !== 0)) {
      const o = vn(r.getListType());
      i.forEach((s) => o.append(s)), e.insertAfter(o, n);
    }
    return e;
  }
  remove(e) {
    const n = this.getPreviousSibling(),
      r = this.getNextSibling();
    super.remove(e), n && r && ti(n) && ti(r) && (Ox(n.getFirstChild(), r.getFirstChild()), r.remove());
  }
  insertNewAfter(e, n = !0) {
    const r = xn(this.__checked == null && void 0);
    return this.insertAfter(r, n), r;
  }
  collapseAtStart(e) {
    const n = tt();
    this.getChildren().forEach((s) => n.append(s));
    const r = this.getParentOrThrow(),
      i = r.getParentOrThrow(),
      o = Ue(i);
    if (r.getChildrenSize() === 1)
      if (o) r.remove(), i.select();
      else {
        r.insertBefore(n), r.remove();
        const s = e.anchor,
          l = e.focus,
          a = n.getKey();
        s.type === "element" && s.getNode().is(this) && s.set(a, s.offset, "element"),
          l.type === "element" && l.getNode().is(this) && l.set(a, l.offset, "element");
      }
    else r.insertBefore(n), this.remove();
    return !0;
  }
  getValue() {
    return this.getLatest().__value;
  }
  setValue(e) {
    this.getWritable().__value = e;
  }
  getChecked() {
    return this.getLatest().__checked;
  }
  setChecked(e) {
    this.getWritable().__checked = e;
  }
  toggleChecked() {
    this.setChecked(!this.__checked);
  }
  getIndent() {
    const e = this.getParent();
    if (e === null) return this.getLatest().__indent;
    let n = e.getParentOrThrow(),
      r = 0;
    for (; Ue(n); ) (n = n.getParentOrThrow().getParentOrThrow()), r++;
    return r;
  }
  setIndent(e) {
    (typeof e == "number" && e > -1) || Qi(117);
    let n = this.getIndent();
    for (; n !== e; ) n < e ? (gz(this), n++) : (Oz(this), n--);
    return this;
  }
  canInsertAfter(e) {
    return Ue(e);
  }
  canReplaceWith(e) {
    return Ue(e);
  }
  canMergeWith(e) {
    return zi(e) || Ue(e);
  }
  extractWithChild(e, n) {
    if (!ee(n)) return !1;
    const r = n.anchor.getNode(),
      i = n.focus.getNode();
    return this.isParentOf(r) && this.isParentOf(i) && this.getTextContent().length === n.getTextContent().length;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return vn("bullet");
  }
};
function Hk(t, e, n) {
  const r = [],
    i = [],
    o = e.list,
    s = o ? o.listitem : void 0;
  let l;
  if ((o && o.nested && (l = o.nested.listitem), s !== void 0 && r.push(...jf(s)), o)) {
    const a = n.getParent(),
      c = $e(a) && a.getListType() === "check",
      u = n.getChecked();
    (c && !u) || i.push(o.listitemUnchecked),
      (c && u) || i.push(o.listitemChecked),
      c && r.push(u ? o.listitemChecked : o.listitemUnchecked);
  }
  if (l !== void 0) {
    const a = jf(l);
    n.getChildren().some((c) => $e(c)) ? r.push(...a) : i.push(...a);
  }
  i.length > 0 && cm(t, ...i), r.length > 0 && Rr(t, ...r);
}
function qk(t, e, n, r) {
  $e(e.getFirstChild())
    ? (t.removeAttribute("role"), t.removeAttribute("tabIndex"), t.removeAttribute("aria-checked"))
    : (t.setAttribute("role", "checkbox"),
      t.setAttribute("tabIndex", "-1"),
      (n && e.__checked === n.__checked) || t.setAttribute("aria-checked", e.getChecked() ? "true" : "false"));
}
function bz(t) {
  if (t.classList.contains("task-list-item")) {
    for (const n of t.children) if (n.tagName === "INPUT") return xz(n);
  }
  const e = t.getAttribute("aria-checked");
  return { node: xn(e === "true" || (e !== "false" && void 0)) };
}
function xz(t) {
  return t.getAttribute("type") !== "checkbox" ? { node: null } : { node: xn(t.hasAttribute("checked")) };
}
function xn(t) {
  return Mn(new Yo(void 0, t));
}
function Ue(t) {
  return t instanceof Yo;
}
let Go = class CA extends Vr {
  static getType() {
    return "list";
  }
  static clone(e) {
    const n = e.__listType || Jk[e.__tag];
    return new CA(n, e.__start, e.__key);
  }
  constructor(e, n, r) {
    super(r);
    const i = Jk[e] || e;
    (this.__listType = i), (this.__tag = i === "number" ? "ol" : "ul"), (this.__start = n);
  }
  getTag() {
    return this.__tag;
  }
  setListType(e) {
    const n = this.getWritable();
    (n.__listType = e), (n.__tag = e === "number" ? "ol" : "ul");
  }
  getListType() {
    return this.__listType;
  }
  getStart() {
    return this.__start;
  }
  createDOM(e, n) {
    const r = this.__tag,
      i = document.createElement(r);
    return (
      this.__start !== 1 && i.setAttribute("start", String(this.__start)), (i.__lexicalListType = this.__listType), Yk(i, e.theme, this), i
    );
  }
  updateDOM(e, n, r) {
    return e.__tag !== this.__tag || (Yk(n, r.theme, this), !1);
  }
  static transform() {
    return (e) => {
      $e(e) || Qi(163),
        (function (n) {
          const r = n.getNextSibling();
          $e(r) && n.getListType() === r.getListType() && Ox(n, r);
        })(e),
        (function (n) {
          const r = n.getListType() !== "check";
          let i = n.getStart();
          for (const o of n.getChildren())
            Ue(o) &&
              (o.getValue() !== i && o.setValue(i), r && o.getChecked() != null && o.setChecked(void 0), $e(o.getFirstChild()) || i++);
        })(e);
    };
  }
  static importDOM() {
    return { ol: () => ({ conversion: Gk, priority: 0 }), ul: () => ({ conversion: Gk, priority: 0 }) };
  }
  static importJSON(e) {
    const n = vn(e.listType, e.start);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return (
      n &&
        $r(n) &&
        (this.__start !== 1 && n.setAttribute("start", String(this.__start)),
        this.__listType === "check" && n.setAttribute("__lexicalListType", "check")),
      { element: n }
    );
  }
  exportJSON() {
    return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
  append(...e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (Ue(r)) super.append(r);
      else {
        const i = xn();
        if ($e(r)) i.append(r);
        else if (X(r)) {
          const o = yt(r.getTextContent());
          i.append(o);
        } else i.append(r);
        super.append(i);
      }
    }
    return this;
  }
  extractWithChild(e) {
    return Ue(e);
  }
};
function Yk(t, e, n) {
  const r = [],
    i = [],
    o = e.list;
  if (o !== void 0) {
    const s = o[`${n.__tag}Depth`] || [],
      l = q0(n) - 1,
      a = l % s.length,
      c = s[a],
      u = o[n.__tag];
    let h;
    const d = o.nested,
      f = o.checklist;
    if (
      (d !== void 0 && d.list && (h = d.list),
      u !== void 0 && r.push(u),
      f !== void 0 && n.__listType === "check" && r.push(f),
      c !== void 0)
    ) {
      r.push(...jf(c));
      for (let p = 0; p < s.length; p++) p !== a && i.push(n.__tag + p);
    }
    if (h !== void 0) {
      const p = jf(h);
      l > 1 ? r.push(...p) : i.push(...p);
    }
  }
  i.length > 0 && cm(t, ...i), r.length > 0 && Rr(t, ...r);
}
function yz(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (Ue(r)) {
      e.push(r);
      const i = r.getChildren();
      i.length > 1 &&
        i.forEach((o) => {
          $e(o) && e.push(Xk(o));
        });
    } else e.push(Xk(r));
  }
  return e;
}
function Gk(t) {
  const e = t.nodeName.toLowerCase();
  let n = null;
  return (
    e === "ol"
      ? (n = vn("number", t.start))
      : e === "ul" &&
        (n = (function (r) {
          if (r.getAttribute("__lexicallisttype") === "check" || r.classList.contains("contains-task-list")) return !0;
          for (const i of r.childNodes) if ($r(i) && i.hasAttribute("aria-checked")) return !0;
          return !1;
        })(t)
          ? vn("check")
          : vn("bullet")),
    { after: yz, node: n }
  );
}
const Jk = { ol: "number", ul: "bullet" };
function vn(t, e = 1) {
  return Mn(new Go(t, e));
}
function $e(t) {
  return t instanceof Go;
}
const _A = Ji(),
  EA = Ji(),
  TA = Ji(),
  PA = Ji(),
  wz = {
    testNode: "list",
    visitNode: function ({ mdastNode: t, lexicalParent: e, actions: n }) {
      const r = t.children.some((o) => typeof o.checked == "boolean") ? "check" : t.ordered ? "number" : "bullet",
        i = vn(r);
      if (Ue(e)) {
        const o = xn();
        o.append(i), e.insertAfter(o);
      } else e.append(i);
      n.visitChildren(t, i);
    },
  },
  Sz = {
    testNode: "listItem",
    visitNode({ mdastNode: t, actions: e, lexicalParent: n }) {
      const r = n.getListType() === "check" ? t.checked ?? !1 : void 0;
      e.addAndStepInto(xn(r));
    },
  },
  kz = {
    testLexicalNode: $e,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      e.addAndStepInto("list", { ordered: t.getListType() === "number", spread: !1 });
    },
  },
  Cz = {
    testLexicalNode: Ue,
    visitLexicalNode: ({ lexicalNode: t, mdastParent: e, actions: n }) => {
      const r = t.getChildren(),
        i = r[0];
      if (r.length === 1 && $e(i)) {
        const o = e.children.at(-1);
        n.visitChildren(t, o);
      } else {
        const o = t.getParent(),
          s = n.appendToParent(e, {
            type: "listItem",
            checked: o.getListType() === "check" ? !!t.getChecked() : void 0,
            spread: !1,
            children: [{ type: "paragraph", children: [] }],
          });
        n.visitChildren(t, s.children[0]);
      }
    },
  };
function _z(t) {
  return t.registerCommand(
    sb,
    (e) => {
      const n = ae();
      if (!ee(n)) return !1;
      e.preventDefault();
      const r = (function (i) {
        const o = i.getNodes();
        if (xN(o, (h) => (Tf(h) && h.canIndent() ? h : null)).length > 0) return !0;
        const s = i.anchor,
          l = i.focus,
          a = l.isBefore(s) ? l : s,
          c = a.getNode(),
          u = oP(c);
        if (u.canIndent()) {
          const h = u.getKey();
          let d = lm();
          if ((d.anchor.set(h, 0, "element"), d.focus.set(h, 0, "element"), (d = wb(d)), d.anchor.is(a))) return !0;
        }
        return !1;
      })(n)
        ? e.shiftKey
          ? O0
          : lb
        : hT;
      return t.dispatchCommand(r, void 0);
    },
    Ze
  );
}
function Kk() {
  const [t] = In();
  return _.useEffect(() => _z(t)), null;
}
function eC() {
  const [t] = In();
  return (
    _.useEffect(() =>
      Xn(
        t.registerCommand(TA, () => (G0(t, "check"), !0), ht),
        t.registerCommand(ob, (e) => rC(e, t, !1), ht),
        t.registerCommand(ib, (e) => rC(e, t, !0), ht),
        t.registerCommand(
          Uu,
          (e) => {
            if (J0() != null) {
              const n = t.getRootElement();
              return n != null && n.focus(), !0;
            }
            return !1;
          },
          ht
        ),
        t.registerCommand(
          uT,
          (e) => {
            const n = J0();
            return (
              !(n == null || !t.isEditable()) &&
              (t.update(() => {
                const r = pi(n);
                Ue(r) && (e.preventDefault(), r.toggleChecked());
              }),
              !0)
            );
          },
          ht
        ),
        t.registerCommand(
          rb,
          (e) =>
            t.getEditorState().read(() => {
              const n = ae();
              if (ee(n) && n.isCollapsed()) {
                const { anchor: r } = n,
                  i = r.type === "element";
                if (i || r.offset === 0) {
                  const o = r.getNode(),
                    s = Sa(o, (l) => X(l) && !l.isInline());
                  if (Ue(s)) {
                    const l = s.getParent();
                    if ($e(l) && l.getListType() === "check" && (i || s.getFirstDescendant() === o)) {
                      const a = t.getElementByKey(s.__key);
                      if (a != null && document.activeElement !== a) return a.focus(), e.preventDefault(), !0;
                    }
                  }
                }
              }
              return !1;
            }),
          ht
        ),
        t.registerRootListener((e, n) => {
          e !== null && (e.addEventListener("click", tC), e.addEventListener("pointerdown", nC)),
            n !== null && (n.removeEventListener("click", tC), n.removeEventListener("pointerdown", nC));
        })
      )
    ),
    null
  );
}
function AA(t, e) {
  const n = t.target;
  if (n === null || !$r(n)) return;
  const r = n.firstChild;
  if (r != null && $r(r) && (r.tagName === "UL" || r.tagName === "OL")) return;
  const i = n.parentNode;
  if (!i || i.__lexicalListType !== "check") return;
  const o = n.getBoundingClientRect(),
    s = t.pageX / yN(n);
  (n.dir === "rtl" ? s < o.right && s > o.right - 20 : s > o.left && s < o.left + 20) && e();
}
function tC(t) {
  AA(t, () => {
    const e = t.target,
      n = (function (r) {
        let i = r;
        for (; i; ) {
          if (i.__lexicalEditor) return i.__lexicalEditor;
          i = i.parentNode;
        }
        return null;
      })(e);
    n != null &&
      n.isEditable() &&
      n.update(() => {
        if (t.target) {
          const r = pi(e);
          Ue(r) && (e.focus(), r.toggleChecked());
        }
      });
  });
}
function nC(t) {
  AA(t, () => {
    t.preventDefault();
  });
}
function J0() {
  const t = document.activeElement;
  return t != null && t.tagName === "LI" && t.parentNode != null && t.parentNode.__lexicalListType === "check" ? t : null;
}
function rC(t, e, n) {
  const r = J0();
  return (
    r != null &&
      e.update(() => {
        const i = pi(r);
        if (!Ue(i)) return;
        const o = (function (s, l) {
          let a = l ? s.getPreviousSibling() : s.getNextSibling(),
            c = s;
          for (; a == null && Ue(c); )
            (c = c.getParentOrThrow().getParent()), c != null && (a = l ? c.getPreviousSibling() : c.getNextSibling());
          for (; Ue(a); ) {
            const u = l ? a.getLastChild() : a.getFirstChild();
            if (!$e(u)) return a;
            a = l ? u.getLastChild() : u.getFirstChild();
          }
          return null;
        })(i, n);
        if (o != null) {
          o.selectStart();
          const s = e.getElementByKey(o.__key);
          s != null &&
            (t.preventDefault(),
            setTimeout(() => {
              s.focus();
            }, 0));
        }
      }),
    !1
  );
}
function iC() {
  const [t] = In();
  return (
    _.useEffect(() => {
      if (!t.hasNodes([Go, Yo])) throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [t]),
    (function (e) {
      _.useEffect(
        () =>
          Xn(
            e.registerCommand(EA, () => (G0(e, "number"), !0), ht),
            e.registerCommand(_A, () => (G0(e, "bullet"), !0), ht),
            e.registerCommand(PA, () => (mz(e), !0), ht),
            e.registerCommand(Yc, () => !!vz(), ht)
          ),
        [e]
      );
    })(t),
    null
  );
}
const Ez = { name: "tasklistCheck", tokenize: Pz };
function Tz() {
  return { text: { 91: Ez } };
}
function Pz(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return r.previous !== null || !r._gfmTasklistFirstContentOfListItem
      ? n(a)
      : (t.enter("taskListCheck"), t.enter("taskListCheckMarker"), t.consume(a), t.exit("taskListCheckMarker"), o);
  }
  function o(a) {
    return Ke(a)
      ? (t.enter("taskListCheckValueUnchecked"), t.consume(a), t.exit("taskListCheckValueUnchecked"), s)
      : a === 88 || a === 120
      ? (t.enter("taskListCheckValueChecked"), t.consume(a), t.exit("taskListCheckValueChecked"), s)
      : n(a);
  }
  function s(a) {
    return a === 93 ? (t.enter("taskListCheckMarker"), t.consume(a), t.exit("taskListCheckMarker"), t.exit("taskListCheck"), l) : n(a);
  }
  function l(a) {
    return de(a) ? e(a) : Pe(a) ? t.check({ tokenize: Az }, e, n)(a) : n(a);
  }
}
function Az(t, e, n) {
  return Re(t, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : e(i);
  }
}
function $z() {
  return { exit: { taskListCheckValueChecked: oC, taskListCheckValueUnchecked: oC, paragraph: Iz } };
}
function Rz() {
  return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: Mz } };
}
function oC(t) {
  const e = this.stack[this.stack.length - 2];
  e.type, (e.checked = t.type === "taskListCheckValueChecked");
}
function Iz(t) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let o = -1,
        s;
      for (; ++o < i.length; ) {
        const l = i[o];
        if (l.type === "paragraph") {
          s = l;
          break;
        }
      }
      s === n &&
        ((r.value = r.value.slice(1)),
        r.value.length === 0
          ? n.children.shift()
          : n.position &&
            r.position &&
            typeof r.position.start.offset == "number" &&
            (r.position.start.column++, r.position.start.offset++, (n.position.start = Object.assign({}, r.position.start))));
    }
  }
  this.exit(t);
}
function Mz(t, e, n, r) {
  const i = t.children[0],
    o = typeof t.checked == "boolean" && i && i.type === "paragraph",
    s = "[" + (t.checked ? "x" : " ") + "] ",
    l = n.createTracker(r);
  o && l.move(s);
  let a = Zb.listItem(t, e, n, { ...r, ...l.current() });
  return o && (a = a.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), a;
  function c(u) {
    return u + s;
  }
}
const Lz = new Map([
    ["number", EA],
    ["bullet", _A],
    ["check", TA],
    ["", PA],
  ]),
  Zf = we("", (t) => {
    t.sub(t.pipe(_s, pt(St)), ([e, n]) => {
      if (!e || !n) return;
      const r = e.anchor.getNode();
      let i =
        r.getKey() === "root"
          ? r
          : Sa(r, (l) => {
              const a = l.getParent();
              return a !== null && Yt(a);
            });
      i === null && (i = r.getTopLevelElementOrThrow());
      const o = i.getKey();
      if (n.getElementByKey(o) !== null)
        if ($e(i)) {
          const l = iP(r, Go),
            a = l ? l.getListType() : i.getListType();
          t.pub(Zf, a);
        } else t.pub(Zf, "");
    });
  }),
  vx = kt((t) => {
    t.sub(t.pipe(vx, pt(St)), ([e, n]) => {
      n == null || n.dispatchCommand(Lz.get(e), void 0);
    });
  }),
  Nz = Ut({
    init(t) {
      var e;
      (e = t.getValue(Un)) == null || e.registerCommand(lb, () => !Dz(7), Bn),
        t.pubIn({
          [Ea]: "lists",
          [Lo]: $z(),
          [Mo]: Tz(),
          [Wn]: [wz, Sz],
          [ar]: [Yo, Go],
          [cr]: [kz, Cz],
          [Hs]: Rz(),
          [qo]: [Kk, iC, eC],
          [ax]: [Kk, iC, eC],
        });
    },
  });
function Qz(t) {
  const e = t.getNodes();
  return e.length === 0
    ? new Set([t.anchor.getNode().getParentOrThrow(), t.focus.getNode().getParentOrThrow()])
    : new Set(e.map((n) => (X(n) ? n : n.getParentOrThrow())));
}
function Dz(t) {
  const e = ae();
  if (!ee(e)) return !1;
  const n = Qz(e);
  let r = 0;
  for (const i of n)
    if ($e(i)) r = Math.max(q0(i) + 1, r);
    else if (Ue(i)) {
      const o = i.getParent();
      if ((o == null ? void 0 : o.getChildren().length) === 1) {
        const s = o.getParent();
        if (Ue(s) && s.getChildren().length === 1) return !1;
      }
      if (!$e(o)) throw new Error("ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.");
      r = Math.max(q0(o) + 1, r);
    }
  return r <= t;
}
function Fz(t, e = {}) {
  const n = (e.align || []).concat(),
    r = e.stringLength || Vz,
    i = [],
    o = [],
    s = [],
    l = [];
  let a = 0,
    c = -1;
  for (; ++c < t.length; ) {
    const p = [],
      m = [];
    let O = -1;
    for (t[c].length > a && (a = t[c].length); ++O < t[c].length; ) {
      const v = Bz(t[c][O]);
      if (e.alignDelimiters !== !1) {
        const g = r(v);
        (m[O] = g), (l[O] === void 0 || g > l[O]) && (l[O] = g);
      }
      p.push(v);
    }
    (o[c] = p), (s[c] = m);
  }
  let u = -1;
  if (typeof n == "object" && "length" in n) for (; ++u < a; ) i[u] = sC(n[u]);
  else {
    const p = sC(n);
    for (; ++u < a; ) i[u] = p;
  }
  u = -1;
  const h = [],
    d = [];
  for (; ++u < a; ) {
    const p = i[u];
    let m = "",
      O = "";
    p === 99 ? ((m = ":"), (O = ":")) : p === 108 ? (m = ":") : p === 114 && (O = ":");
    let v = e.alignDelimiters === !1 ? 1 : Math.max(1, l[u] - m.length - O.length);
    const g = m + "-".repeat(v) + O;
    e.alignDelimiters !== !1 && ((v = m.length + v + O.length), v > l[u] && (l[u] = v), (d[u] = v)), (h[u] = g);
  }
  o.splice(1, 0, h), s.splice(1, 0, d), (c = -1);
  const f = [];
  for (; ++c < o.length; ) {
    const p = o[c],
      m = s[c];
    u = -1;
    const O = [];
    for (; ++u < a; ) {
      const v = p[u] || "";
      let g = "",
        b = "";
      if (e.alignDelimiters !== !1) {
        const x = l[u] - (m[u] || 0),
          k = i[u];
        k === 114
          ? (g = " ".repeat(x))
          : k === 99
          ? x % 2
            ? ((g = " ".repeat(x / 2 + 0.5)), (b = " ".repeat(x / 2 - 0.5)))
            : ((g = " ".repeat(x / 2)), (b = g))
          : (b = " ".repeat(x));
      }
      e.delimiterStart !== !1 && !u && O.push("|"),
        e.padding !== !1 && !(e.alignDelimiters === !1 && v === "") && (e.delimiterStart !== !1 || u) && O.push(" "),
        e.alignDelimiters !== !1 && O.push(g),
        O.push(v),
        e.alignDelimiters !== !1 && O.push(b),
        e.padding !== !1 && O.push(" "),
        (e.delimiterEnd !== !1 || u !== a - 1) && O.push("|");
    }
    f.push(e.delimiterEnd === !1 ? O.join("").replace(/ +$/, "") : O.join(""));
  }
  return f.join(`
`);
}
function Bz(t) {
  return t == null ? "" : String(t);
}
function Vz(t) {
  return t.length;
}
function sC(t) {
  const e = typeof t == "string" ? t.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function jz() {
  return {
    enter: { table: Zz, tableData: lC, tableHeader: lC, tableRow: Wz },
    exit: { codeText: Xz, table: zz, tableData: Vg, tableHeader: Vg, tableRow: Vg },
  };
}
function Zz(t) {
  const e = t._align;
  this.enter(
    {
      type: "table",
      align: e.map(function (n) {
        return n === "none" ? null : n;
      }),
      children: [],
    },
    t
  ),
    (this.data.inTable = !0);
}
function zz(t) {
  this.exit(t), (this.data.inTable = void 0);
}
function Wz(t) {
  this.enter({ type: "tableRow", children: [] }, t);
}
function Vg(t) {
  this.exit(t);
}
function lC(t) {
  this.enter({ type: "tableCell", children: [] }, t);
}
function Xz(t) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, Uz));
  const n = this.stack[this.stack.length - 1];
  n.type, (n.value = e), this.exit(t);
}
function Uz(t, e) {
  return e === "|" ? e : t;
}
function Hz(t) {
  const e = t || {},
    n = e.tableCellPadding,
    r = e.tablePipeAlign,
    i = e.stringLength,
    o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      {
        character: `
`,
        inConstruct: "tableCell",
      },
      { atBreak: !0, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: !0, character: ":", after: "-" },
      { atBreak: !0, character: "-", after: "[:|-]" },
    ],
    handlers: { inlineCode: d, table: s, tableCell: a, tableRow: l },
  };
  function s(f, p, m, O) {
    return c(u(f, m, O), f.align);
  }
  function l(f, p, m, O) {
    const v = h(f, m, O),
      g = c([v]);
    return g.slice(
      0,
      g.indexOf(`
`)
    );
  }
  function a(f, p, m, O) {
    const v = m.enter("tableCell"),
      g = m.enter("phrasing"),
      b = m.containerPhrasing(f, { ...O, before: o, after: o });
    return g(), v(), b;
  }
  function c(f, p) {
    return Fz(f, { align: p, alignDelimiters: r, padding: n, stringLength: i });
  }
  function u(f, p, m) {
    const O = f.children;
    let v = -1;
    const g = [],
      b = p.enter("table");
    for (; ++v < O.length; ) g[v] = h(O[v], p, m);
    return b(), g;
  }
  function h(f, p, m) {
    const O = f.children;
    let v = -1;
    const g = [],
      b = p.enter("tableRow");
    for (; ++v < O.length; ) g[v] = a(O[v], f, p, m);
    return b(), g;
  }
  function d(f, p, m) {
    let O = Zb.inlineCode(f, p, m);
    return m.stack.includes("tableCell") && (O = O.replace(/\|/g, "\\$&")), O;
  }
}
class qz {
  constructor() {
    this.map = [];
  }
  add(e, n, r) {
    Yz(this, e, n, r);
  }
  consume(e) {
    if (
      (this.map.sort(function (o, s) {
        return o[0] - s[0];
      }),
      this.map.length === 0)
    )
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; ) (n -= 1), r.push(e.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), (e.length = this.map[n][0]);
    r.push([...e]), (e.length = 0);
    let i = r.pop();
    for (; i; ) e.push(...i), (i = r.pop());
    this.map.length = 0;
  }
}
function Yz(t, e, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < t.map.length; ) {
      if (t.map[i][0] === e) {
        (t.map[i][1] += n), t.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    t.map.push([e, n, r]);
  }
}
function Gz(t, e) {
  let n = !1;
  const r = [];
  for (; e < t.length; ) {
    const i = t[e];
    if (n) {
      if (i[0] === "enter") i[1].type === "tableContent" && r.push(t[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (t[e - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow") break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    e += 1;
  }
  return r;
}
function Jz() {
  return { flow: { null: { name: "table", tokenize: Kz, resolveAll: eW } } };
}
function Kz(t, e, n) {
  const r = this;
  let i = 0,
    o = 0,
    s;
  return l;
  function l(E) {
    let N = r.events.length - 1;
    for (; N > -1; ) {
      const Q = r.events[N][1].type;
      if (Q === "lineEnding" || Q === "linePrefix") N--;
      else break;
    }
    const L = N > -1 ? r.events[N][1].type : null,
      D = L === "tableHead" || L === "tableRow" ? w : a;
    return D === w && r.parser.lazy[r.now().line] ? n(E) : D(E);
  }
  function a(E) {
    return t.enter("tableHead"), t.enter("tableRow"), c(E);
  }
  function c(E) {
    return E === 124 || ((s = !0), (o += 1)), u(E);
  }
  function u(E) {
    return E === null
      ? n(E)
      : de(E)
      ? o > 1
        ? ((o = 0), (r.interrupt = !0), t.exit("tableRow"), t.enter("lineEnding"), t.consume(E), t.exit("lineEnding"), f)
        : n(E)
      : Pe(E)
      ? Re(t, u, "whitespace")(E)
      : ((o += 1),
        s && ((s = !1), (i += 1)),
        E === 124 ? (t.enter("tableCellDivider"), t.consume(E), t.exit("tableCellDivider"), (s = !0), u) : (t.enter("data"), h(E)));
  }
  function h(E) {
    return E === null || E === 124 || Ke(E) ? (t.exit("data"), u(E)) : (t.consume(E), E === 92 ? d : h);
  }
  function d(E) {
    return E === 92 || E === 124 ? (t.consume(E), h) : h(E);
  }
  function f(E) {
    return (
      (r.interrupt = !1),
      r.parser.lazy[r.now().line]
        ? n(E)
        : (t.enter("tableDelimiterRow"),
          (s = !1),
          Pe(E) ? Re(t, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(E) : p(E))
    );
  }
  function p(E) {
    return E === 45 || E === 58
      ? O(E)
      : E === 124
      ? ((s = !0), t.enter("tableCellDivider"), t.consume(E), t.exit("tableCellDivider"), m)
      : k(E);
  }
  function m(E) {
    return Pe(E) ? Re(t, O, "whitespace")(E) : O(E);
  }
  function O(E) {
    return E === 58
      ? ((o += 1), (s = !0), t.enter("tableDelimiterMarker"), t.consume(E), t.exit("tableDelimiterMarker"), v)
      : E === 45
      ? ((o += 1), v(E))
      : E === null || de(E)
      ? x(E)
      : k(E);
  }
  function v(E) {
    return E === 45 ? (t.enter("tableDelimiterFiller"), g(E)) : k(E);
  }
  function g(E) {
    return E === 45
      ? (t.consume(E), g)
      : E === 58
      ? ((s = !0), t.exit("tableDelimiterFiller"), t.enter("tableDelimiterMarker"), t.consume(E), t.exit("tableDelimiterMarker"), b)
      : (t.exit("tableDelimiterFiller"), b(E));
  }
  function b(E) {
    return Pe(E) ? Re(t, x, "whitespace")(E) : x(E);
  }
  function x(E) {
    return E === 124
      ? p(E)
      : E === null || de(E)
      ? !s || i !== o
        ? k(E)
        : (t.exit("tableDelimiterRow"), t.exit("tableHead"), e(E))
      : k(E);
  }
  function k(E) {
    return n(E);
  }
  function w(E) {
    return t.enter("tableRow"), y(E);
  }
  function y(E) {
    return E === 124
      ? (t.enter("tableCellDivider"), t.consume(E), t.exit("tableCellDivider"), y)
      : E === null || de(E)
      ? (t.exit("tableRow"), e(E))
      : Pe(E)
      ? Re(t, y, "whitespace")(E)
      : (t.enter("data"), C(E));
  }
  function C(E) {
    return E === null || E === 124 || Ke(E) ? (t.exit("data"), y(E)) : (t.consume(E), E === 92 ? P : C);
  }
  function P(E) {
    return E === 92 || E === 124 ? (t.consume(E), C) : C(E);
  }
}
function eW(t, e) {
  let n = -1,
    r = !0,
    i = 0,
    o = [0, 0, 0, 0],
    s = [0, 0, 0, 0],
    l = !1,
    a = 0,
    c,
    u,
    h;
  const d = new qz();
  for (; ++n < t.length; ) {
    const f = t[n],
      p = f[1];
    f[0] === "enter"
      ? p.type === "tableHead"
        ? ((l = !1),
          a !== 0 && (aC(d, e, a, c, u), (u = void 0), (a = 0)),
          (c = { type: "table", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }),
          d.add(n, 0, [["enter", c, e]]))
        : p.type === "tableRow" || p.type === "tableDelimiterRow"
        ? ((r = !0),
          (h = void 0),
          (o = [0, 0, 0, 0]),
          (s = [0, n + 1, 0, 0]),
          l &&
            ((l = !1),
            (u = { type: "tableBody", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }),
            d.add(n, 0, [["enter", u, e]])),
          (i = p.type === "tableDelimiterRow" ? 2 : u ? 3 : 1))
        : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller")
        ? ((r = !1), s[2] === 0 && (o[1] !== 0 && ((s[0] = s[1]), (h = qh(d, e, o, i, void 0, h)), (o = [0, 0, 0, 0])), (s[2] = n)))
        : p.type === "tableCellDivider" &&
          (r ? (r = !1) : (o[1] !== 0 && ((s[0] = s[1]), (h = qh(d, e, o, i, void 0, h))), (o = s), (s = [o[1], n, 0, 0])))
      : p.type === "tableHead"
      ? ((l = !0), (a = n))
      : p.type === "tableRow" || p.type === "tableDelimiterRow"
      ? ((a = n), o[1] !== 0 ? ((s[0] = s[1]), (h = qh(d, e, o, i, n, h))) : s[1] !== 0 && (h = qh(d, e, s, i, n, h)), (i = 0))
      : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (a !== 0 && aC(d, e, a, c, u), d.consume(e.events), n = -1; ++n < e.events.length; ) {
    const f = e.events[n];
    f[0] === "enter" && f[1].type === "table" && (f[1]._align = Gz(e.events, n));
  }
  return t;
}
function qh(t, e, n, r, i, o) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData",
    l = "tableContent";
  n[0] !== 0 && ((o.end = Object.assign({}, cl(e.events, n[0]))), t.add(n[0], 0, [["exit", o, e]]));
  const a = cl(e.events, n[1]);
  if (((o = { type: s, start: Object.assign({}, a), end: Object.assign({}, a) }), t.add(n[1], 0, [["enter", o, e]]), n[2] !== 0)) {
    const c = cl(e.events, n[2]),
      u = cl(e.events, n[3]),
      h = { type: l, start: Object.assign({}, c), end: Object.assign({}, u) };
    if ((t.add(n[2], 0, [["enter", h, e]]), r !== 2)) {
      const d = e.events[n[2]],
        f = e.events[n[3]];
      if (((d[1].end = Object.assign({}, f[1].end)), (d[1].type = "chunkText"), (d[1].contentType = "text"), n[3] > n[2] + 1)) {
        const p = n[2] + 1,
          m = n[3] - n[2] - 1;
        t.add(p, m, []);
      }
    }
    t.add(n[3] + 1, 0, [["exit", h, e]]);
  }
  return i !== void 0 && ((o.end = Object.assign({}, cl(e.events, i))), t.add(i, 0, [["exit", o, e]]), (o = void 0)), o;
}
function aC(t, e, n, r, i) {
  const o = [],
    s = cl(e.events, n);
  i && ((i.end = Object.assign({}, s)), o.push(["exit", i, e])), (r.end = Object.assign({}, s)), o.push(["exit", r, e]), t.add(n + 1, 0, o);
}
function cl(t, e) {
  const n = t[e],
    r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const cC = [
    ["Cat", "rgb(125, 50, 0)"],
    ["Dog", "rgb(100, 0, 0)"],
    ["Rabbit", "rgb(150, 0, 0)"],
    ["Frog", "rgb(200, 0, 0)"],
    ["Fox", "rgb(200, 75, 0)"],
    ["Hedgehog", "rgb(0, 75, 0)"],
    ["Pigeon", "rgb(0, 125, 0)"],
    ["Squirrel", "rgb(75, 100, 0)"],
    ["Bear", "rgb(125, 100, 0)"],
    ["Tiger", "rgb(0, 0, 150)"],
    ["Leopard", "rgb(0, 0, 200)"],
    ["Zebra", "rgb(0, 0, 250)"],
    ["Wolf", "rgb(0, 100, 150)"],
    ["Owl", "rgb(0, 100, 100)"],
    ["Gull", "rgb(100, 0, 100)"],
    ["Squid", "rgb(150, 0, 150)"],
  ],
  uC = cC[Math.floor(Math.random() * cC.length)],
  tW = _.createContext({ clientID: 0, color: uC[1], isCollabActive: !1, name: uC[0], yjsDocMap: new Map() });
function nW(t, e) {
  const n = _.useContext(tW);
  return t != null && (n.name = t), e != null && (n.color = e), n;
}
function rW(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var iW = rW(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function hC(t) {
  const e = t.transform();
  return e !== null ? new Set([e]) : new Set();
}
function $A({ initialEditor: t, children: e, initialNodes: n, initialTheme: r, skipCollabChecks: i }) {
  const o = _.useRef(!1),
    s = _.useContext(gf);
  s == null && iW(9);
  const [l, { getTheme: a }] = s,
    c = _.useMemo(() => {
      const f = r || a() || void 0,
        p = aT(s, f);
      if ((f !== void 0 && (t._config.theme = f), (t._parentEditor = l), n))
        for (let m of n) {
          let O = null,
            v = null;
          if (typeof m != "function") {
            const b = m;
            (m = b.replace), (O = b.with), (v = b.withKlass || null);
          }
          const g = t._nodes.get(m.getType());
          t._nodes.set(m.getType(), { exportDOM: g ? g.exportDOM : void 0, klass: m, replace: O, replaceWithKlass: v, transforms: hC(m) });
        }
      else {
        const m = (t._nodes = new Map(l._nodes));
        for (const [O, v] of m)
          t._nodes.set(O, {
            exportDOM: v.exportDOM,
            klass: v.klass,
            replace: v.replace,
            replaceWithKlass: v.replaceWithKlass,
            transforms: hC(v.klass),
          });
      }
      return (t._config.namespace = l._config.namespace), (t._editable = l._editable), [t, p];
    }, []),
    { isCollabActive: u, yjsDocMap: h } = nW(),
    d = i || o.current || h.has(t.getKey());
  return (
    _.useEffect(() => {
      d && (o.current = !0);
    }, [d]),
    _.useEffect(
      () =>
        l.registerEditableListener((f) => {
          t.setEditable(f);
        }),
      [t, l]
    ),
    T.jsx(gf.Provider, { value: c, children: !u || d ? e : null })
  );
}
function Be(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (i) {
    if ((t == null || t(i), n === !1 || !i.defaultPrevented)) return e == null ? void 0 : e(i);
  };
}
function oW(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function RA(...t) {
  return (e) => t.forEach((n) => oW(n, e));
}
function Pt(...t) {
  return _.useCallback(RA(...t), t);
}
function Jo(t, e = []) {
  let n = [];
  function r(o, s) {
    const l = _.createContext(s),
      a = n.length;
    n = [...n, s];
    function c(h) {
      const { scope: d, children: f, ...p } = h,
        m = (d == null ? void 0 : d[t][a]) || l,
        O = _.useMemo(() => p, Object.values(p));
      return T.jsx(m.Provider, { value: O, children: f });
    }
    function u(h, d) {
      const f = (d == null ? void 0 : d[t][a]) || l,
        p = _.useContext(f);
      if (p) return p;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${o}\``);
    }
    return (c.displayName = o + "Provider"), [c, u];
  }
  const i = () => {
    const o = n.map((s) => _.createContext(s));
    return function (l) {
      const a = (l == null ? void 0 : l[t]) || o;
      return _.useMemo(() => ({ [`__scope${t}`]: { ...l, [t]: a } }), [l, a]);
    };
  };
  return (i.scopeName = t), [r, sW(i, ...e)];
}
function sW(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((i) => ({ useScope: i(), scopeName: i.scopeName }));
    return function (o) {
      const s = r.reduce((l, { useScope: a, scopeName: c }) => {
        const h = a(o)[`__scope${c}`];
        return { ...l, ...h };
      }, {});
      return _.useMemo(() => ({ [`__scope${e.scopeName}`]: s }), [s]);
    };
  };
  return (n.scopeName = e.scopeName), n;
}
var Yl = _.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    i = _.Children.toArray(n),
    o = i.find(lW);
  if (o) {
    const s = o.props.children,
      l = i.map((a) => (a === o ? (_.Children.count(s) > 1 ? _.Children.only(null) : _.isValidElement(s) ? s.props.children : null) : a));
    return T.jsx(K0, { ...r, ref: e, children: _.isValidElement(s) ? _.cloneElement(s, void 0, l) : null });
  }
  return T.jsx(K0, { ...r, ref: e, children: n });
});
Yl.displayName = "Slot";
var K0 = _.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (_.isValidElement(n)) {
    const i = cW(n);
    return _.cloneElement(n, { ...aW(r, n.props), ref: e ? RA(e, i) : i });
  }
  return _.Children.count(n) > 1 ? _.Children.only(null) : null;
});
K0.displayName = "SlotClone";
var IA = ({ children: t }) => T.jsx(T.Fragment, { children: t });
function lW(t) {
  return _.isValidElement(t) && t.type === IA;
}
function aW(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r],
      o = e[r];
    /^on[A-Z]/.test(r)
      ? i && o
        ? (n[r] = (...l) => {
            o(...l), i(...l);
          })
        : i && (n[r] = i)
      : r === "style"
      ? (n[r] = { ...i, ...o })
      : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function cW(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var uW = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  qe = uW.reduce((t, e) => {
    const n = _.forwardRef((r, i) => {
      const { asChild: o, ...s } = r,
        l = o ? Yl : e;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), T.jsx(l, { ...s, ref: i });
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function hW(t, e) {
  t && Ss.flushSync(() => t.dispatchEvent(e));
}
function vi(t) {
  const e = _.useRef(t);
  return (
    _.useEffect(() => {
      e.current = t;
    }),
    _.useMemo(
      () =>
        (...n) => {
          var r;
          return (r = e.current) == null ? void 0 : r.call(e, ...n);
        },
      []
    )
  );
}
function dW(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = vi(t);
  _.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var fW = "DismissableLayer",
  eO = "dismissableLayer.update",
  pW = "dismissableLayer.pointerDownOutside",
  mW = "dismissableLayer.focusOutside",
  dC,
  MA = _.createContext({ layers: new Set(), layersWithOutsidePointerEventsDisabled: new Set(), branches: new Set() }),
  km = _.forwardRef((t, e) => {
    const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: i,
        onFocusOutside: o,
        onInteractOutside: s,
        onDismiss: l,
        ...a
      } = t,
      c = _.useContext(MA),
      [u, h] = _.useState(null),
      d = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document),
      [, f] = _.useState({}),
      p = Pt(e, (y) => h(y)),
      m = Array.from(c.layers),
      [O] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
      v = m.indexOf(O),
      g = u ? m.indexOf(u) : -1,
      b = c.layersWithOutsidePointerEventsDisabled.size > 0,
      x = g >= v,
      k = vW((y) => {
        const C = y.target,
          P = [...c.branches].some((E) => E.contains(C));
        !x || P || (i == null || i(y), s == null || s(y), y.defaultPrevented || l == null || l());
      }, d),
      w = bW((y) => {
        const C = y.target;
        [...c.branches].some((E) => E.contains(C)) || (o == null || o(y), s == null || s(y), y.defaultPrevented || l == null || l());
      }, d);
    return (
      dW((y) => {
        g === c.layers.size - 1 && (r == null || r(y), !y.defaultPrevented && l && (y.preventDefault(), l()));
      }, d),
      _.useEffect(() => {
        if (u)
          return (
            n &&
              (c.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((dC = d.body.style.pointerEvents), (d.body.style.pointerEvents = "none")),
              c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            fC(),
            () => {
              n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = dC);
            }
          );
      }, [u, d, n, c]),
      _.useEffect(
        () => () => {
          u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), fC());
        },
        [u, c]
      ),
      _.useEffect(() => {
        const y = () => f({});
        return document.addEventListener(eO, y), () => document.removeEventListener(eO, y);
      }, []),
      T.jsx(qe.div, {
        ...a,
        ref: p,
        style: { pointerEvents: b ? (x ? "auto" : "none") : void 0, ...t.style },
        onFocusCapture: Be(t.onFocusCapture, w.onFocusCapture),
        onBlurCapture: Be(t.onBlurCapture, w.onBlurCapture),
        onPointerDownCapture: Be(t.onPointerDownCapture, k.onPointerDownCapture),
      })
    );
  });
km.displayName = fW;
var gW = "DismissableLayerBranch",
  OW = _.forwardRef((t, e) => {
    const n = _.useContext(MA),
      r = _.useRef(null),
      i = Pt(e, r);
    return (
      _.useEffect(() => {
        const o = r.current;
        if (o)
          return (
            n.branches.add(o),
            () => {
              n.branches.delete(o);
            }
          );
      }, [n.branches]),
      T.jsx(qe.div, { ...t, ref: i })
    );
  });
OW.displayName = gW;
function vW(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = vi(t),
    r = _.useRef(!1),
    i = _.useRef(() => {});
  return (
    _.useEffect(() => {
      const o = (l) => {
          if (l.target && !r.current) {
            let a = function () {
              LA(pW, n, c, { discrete: !0 });
            };
            const c = { originalEvent: l };
            l.pointerType === "touch"
              ? (e.removeEventListener("click", i.current), (i.current = a), e.addEventListener("click", i.current, { once: !0 }))
              : a();
          } else e.removeEventListener("click", i.current);
          r.current = !1;
        },
        s = window.setTimeout(() => {
          e.addEventListener("pointerdown", o);
        }, 0);
      return () => {
        window.clearTimeout(s), e.removeEventListener("pointerdown", o), e.removeEventListener("click", i.current);
      };
    }, [e, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function bW(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = vi(t),
    r = _.useRef(!1);
  return (
    _.useEffect(() => {
      const i = (o) => {
        o.target && !r.current && LA(mW, n, { originalEvent: o }, { discrete: !1 });
      };
      return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
    }, [e, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  );
}
function fC() {
  const t = new CustomEvent(eO);
  document.dispatchEvent(t);
}
function LA(t, e, n, { discrete: r }) {
  const i = n.originalEvent.target,
    o = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && i.addEventListener(t, e, { once: !0 }), r ? hW(i, o) : i.dispatchEvent(o);
}
var jg = 0;
function NA() {
  _.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement("afterbegin", t[0] ?? pC()),
      document.body.insertAdjacentElement("beforeend", t[1] ?? pC()),
      jg++,
      () => {
        jg === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), jg--;
      }
    );
  }, []);
}
function pC() {
  const t = document.createElement("span");
  return (
    t.setAttribute("data-radix-focus-guard", ""),
    (t.tabIndex = 0),
    (t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none"),
    t
  );
}
var Zg = "focusScope.autoFocusOnMount",
  zg = "focusScope.autoFocusOnUnmount",
  mC = { bubbles: !1, cancelable: !0 },
  xW = "FocusScope",
  bx = _.forwardRef((t, e) => {
    const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...s } = t,
      [l, a] = _.useState(null),
      c = vi(i),
      u = vi(o),
      h = _.useRef(null),
      d = Pt(e, (m) => a(m)),
      f = _.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    _.useEffect(() => {
      if (r) {
        let m = function (b) {
            if (f.paused || !l) return;
            const x = b.target;
            l.contains(x) ? (h.current = x) : co(h.current, { select: !0 });
          },
          O = function (b) {
            if (f.paused || !l) return;
            const x = b.relatedTarget;
            x !== null && (l.contains(x) || co(h.current, { select: !0 }));
          },
          v = function (b) {
            if (document.activeElement === document.body) for (const k of b) k.removedNodes.length > 0 && co(l);
          };
        document.addEventListener("focusin", m), document.addEventListener("focusout", O);
        const g = new MutationObserver(v);
        return (
          l && g.observe(l, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", m), document.removeEventListener("focusout", O), g.disconnect();
          }
        );
      }
    }, [r, l, f.paused]),
      _.useEffect(() => {
        if (l) {
          OC.add(f);
          const m = document.activeElement;
          if (!l.contains(m)) {
            const v = new CustomEvent(Zg, mC);
            l.addEventListener(Zg, c),
              l.dispatchEvent(v),
              v.defaultPrevented || (yW(_W(QA(l)), { select: !0 }), document.activeElement === m && co(l));
          }
          return () => {
            l.removeEventListener(Zg, c),
              setTimeout(() => {
                const v = new CustomEvent(zg, mC);
                l.addEventListener(zg, u),
                  l.dispatchEvent(v),
                  v.defaultPrevented || co(m ?? document.body, { select: !0 }),
                  l.removeEventListener(zg, u),
                  OC.remove(f);
              }, 0);
          };
        }
      }, [l, c, u, f]);
    const p = _.useCallback(
      (m) => {
        if ((!n && !r) || f.paused) return;
        const O = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey,
          v = document.activeElement;
        if (O && v) {
          const g = m.currentTarget,
            [b, x] = wW(g);
          b && x
            ? !m.shiftKey && v === x
              ? (m.preventDefault(), n && co(b, { select: !0 }))
              : m.shiftKey && v === b && (m.preventDefault(), n && co(x, { select: !0 }))
            : v === g && m.preventDefault();
        }
      },
      [n, r, f.paused]
    );
    return T.jsx(qe.div, { tabIndex: -1, ...s, ref: d, onKeyDown: p });
  });
bx.displayName = xW;
function yW(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t) if ((co(r, { select: e }), document.activeElement !== n)) return;
}
function wW(t) {
  const e = QA(t),
    n = gC(e, t),
    r = gC(e.reverse(), t);
  return [n, r];
}
function QA(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      },
    });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function gC(t, e) {
  for (const n of t) if (!SW(n, { upTo: e })) return n;
}
function SW(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function kW(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function co(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && kW(t) && e && t.select();
  }
}
var OC = CW();
function CW() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), (t = vC(t, e)), t.unshift(e);
    },
    remove(e) {
      var n;
      (t = vC(t, e)), (n = t[0]) == null || n.resume();
    },
  };
}
function vC(t, e) {
  const n = [...t],
    r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function _W(t) {
  return t.filter((e) => e.tagName !== "A");
}
var Rn = globalThis != null && globalThis.document ? _.useLayoutEffect : () => {},
  EW = vM["useId".toString()] || (() => {}),
  TW = 0;
function Ta(t) {
  const [e, n] = _.useState(EW());
  return (
    Rn(() => {
      t || n((r) => r ?? String(TW++));
    }, [t]),
    t || (e ? `radix-${e}` : "")
  );
}
const PW = ["top", "right", "bottom", "left"],
  li = Math.min,
  Kn = Math.max,
  zf = Math.round,
  Yh = Math.floor,
  Qo = (t) => ({ x: t, y: t }),
  AW = { left: "right", right: "left", bottom: "top", top: "bottom" },
  $W = { start: "end", end: "start" };
function tO(t, e, n) {
  return Kn(t, li(e, n));
}
function Wi(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Xi(t) {
  return t.split("-")[0];
}
function Pa(t) {
  return t.split("-")[1];
}
function xx(t) {
  return t === "x" ? "y" : "x";
}
function yx(t) {
  return t === "y" ? "height" : "width";
}
function Aa(t) {
  return ["top", "bottom"].includes(Xi(t)) ? "y" : "x";
}
function wx(t) {
  return xx(Aa(t));
}
function RW(t, e, n) {
  n === void 0 && (n = !1);
  const r = Pa(t),
    i = wx(t),
    o = yx(i);
  let s = i === "x" ? (r === (n ? "end" : "start") ? "right" : "left") : r === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (s = Wf(s)), [s, Wf(s)];
}
function IW(t) {
  const e = Wf(t);
  return [nO(t), e, nO(e)];
}
function nO(t) {
  return t.replace(/start|end/g, (e) => $W[e]);
}
function MW(t, e, n) {
  const r = ["left", "right"],
    i = ["right", "left"],
    o = ["top", "bottom"],
    s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? (e ? i : r) : e ? r : i;
    case "left":
    case "right":
      return e ? o : s;
    default:
      return [];
  }
}
function LW(t, e, n, r) {
  const i = Pa(t);
  let o = MW(Xi(t), n === "start", r);
  return i && ((o = o.map((s) => s + "-" + i)), e && (o = o.concat(o.map(nO)))), o;
}
function Wf(t) {
  return t.replace(/left|right|bottom|top/g, (e) => AW[e]);
}
function NW(t) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...t };
}
function DA(t) {
  return typeof t != "number" ? NW(t) : { top: t, right: t, bottom: t, left: t };
}
function Xf(t) {
  const { x: e, y: n, width: r, height: i } = t;
  return { width: r, height: i, top: n, left: e, right: e + r, bottom: n + i, x: e, y: n };
}
function bC(t, e, n) {
  let { reference: r, floating: i } = t;
  const o = Aa(e),
    s = wx(e),
    l = yx(s),
    a = Xi(e),
    c = o === "y",
    u = r.x + r.width / 2 - i.width / 2,
    h = r.y + r.height / 2 - i.height / 2,
    d = r[l] / 2 - i[l] / 2;
  let f;
  switch (a) {
    case "top":
      f = { x: u, y: r.y - i.height };
      break;
    case "bottom":
      f = { x: u, y: r.y + r.height };
      break;
    case "right":
      f = { x: r.x + r.width, y: h };
      break;
    case "left":
      f = { x: r.x - i.width, y: h };
      break;
    default:
      f = { x: r.x, y: r.y };
  }
  switch (Pa(e)) {
    case "start":
      f[s] -= d * (n && c ? -1 : 1);
      break;
    case "end":
      f[s] += d * (n && c ? -1 : 1);
      break;
  }
  return f;
}
const QW = async (t, e, n) => {
  const { placement: r = "bottom", strategy: i = "absolute", middleware: o = [], platform: s } = n,
    l = o.filter(Boolean),
    a = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({ reference: t, floating: e, strategy: i }),
    { x: u, y: h } = bC(c, r, a),
    d = r,
    f = {},
    p = 0;
  for (let m = 0; m < l.length; m++) {
    const { name: O, fn: v } = l[m],
      {
        x: g,
        y: b,
        data: x,
        reset: k,
      } = await v({
        x: u,
        y: h,
        initialPlacement: r,
        placement: d,
        strategy: i,
        middlewareData: f,
        rects: c,
        platform: s,
        elements: { reference: t, floating: e },
      });
    (u = g ?? u),
      (h = b ?? h),
      (f = { ...f, [O]: { ...f[O], ...x } }),
      k &&
        p <= 50 &&
        (p++,
        typeof k == "object" &&
          (k.placement && (d = k.placement),
          k.rects && (c = k.rects === !0 ? await s.getElementRects({ reference: t, floating: e, strategy: i }) : k.rects),
          ({ x: u, y: h } = bC(c, d, a))),
        (m = -1));
  }
  return { x: u, y: h, placement: d, strategy: i, middlewareData: f };
};
async function su(t, e) {
  var n;
  e === void 0 && (e = {});
  const { x: r, y: i, platform: o, rects: s, elements: l, strategy: a } = t,
    {
      boundary: c = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: h = "floating",
      altBoundary: d = !1,
      padding: f = 0,
    } = Wi(e, t),
    p = DA(f),
    O = l[d ? (h === "floating" ? "reference" : "floating") : h],
    v = Xf(
      await o.getClippingRect({
        element:
          (n = await (o.isElement == null ? void 0 : o.isElement(O))) == null || n
            ? O
            : O.contextElement || (await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(l.floating))),
        boundary: c,
        rootBoundary: u,
        strategy: a,
      })
    ),
    g = h === "floating" ? { x: r, y: i, width: s.floating.width, height: s.floating.height } : s.reference,
    b = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(l.floating)),
    x = (await (o.isElement == null ? void 0 : o.isElement(b)))
      ? (await (o.getScale == null ? void 0 : o.getScale(b))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    k = Xf(
      o.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: l, rect: g, offsetParent: b, strategy: a })
        : g
    );
  return {
    top: (v.top - k.top + p.top) / x.y,
    bottom: (k.bottom - v.bottom + p.bottom) / x.y,
    left: (v.left - k.left + p.left) / x.x,
    right: (k.right - v.right + p.right) / x.x,
  };
}
const DW = (t) => ({
    name: "arrow",
    options: t,
    async fn(e) {
      const { x: n, y: r, placement: i, rects: o, platform: s, elements: l, middlewareData: a } = e,
        { element: c, padding: u = 0 } = Wi(t, e) || {};
      if (c == null) return {};
      const h = DA(u),
        d = { x: n, y: r },
        f = wx(i),
        p = yx(f),
        m = await s.getDimensions(c),
        O = f === "y",
        v = O ? "top" : "left",
        g = O ? "bottom" : "right",
        b = O ? "clientHeight" : "clientWidth",
        x = o.reference[p] + o.reference[f] - d[f] - o.floating[p],
        k = d[f] - o.reference[f],
        w = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
      let y = w ? w[b] : 0;
      (!y || !(await (s.isElement == null ? void 0 : s.isElement(w)))) && (y = l.floating[b] || o.floating[p]);
      const C = x / 2 - k / 2,
        P = y / 2 - m[p] / 2 - 1,
        E = li(h[v], P),
        N = li(h[g], P),
        L = E,
        D = y - m[p] - N,
        Q = y / 2 - m[p] / 2 + C,
        R = tO(L, Q, D),
        W = !a.arrow && Pa(i) != null && Q !== R && o.reference[p] / 2 - (Q < L ? E : N) - m[p] / 2 < 0,
        B = W ? (Q < L ? Q - L : Q - D) : 0;
      return { [f]: d[f] + B, data: { [f]: R, centerOffset: Q - R - B, ...(W && { alignmentOffset: B }) }, reset: W };
    },
  }),
  FW = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "flip",
        options: t,
        async fn(e) {
          var n, r;
          const { placement: i, middlewareData: o, rects: s, initialPlacement: l, platform: a, elements: c } = e,
            {
              mainAxis: u = !0,
              crossAxis: h = !0,
              fallbackPlacements: d,
              fallbackStrategy: f = "bestFit",
              fallbackAxisSideDirection: p = "none",
              flipAlignment: m = !0,
              ...O
            } = Wi(t, e);
          if ((n = o.arrow) != null && n.alignmentOffset) return {};
          const v = Xi(i),
            g = Xi(l) === l,
            b = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)),
            x = d || (g || !m ? [Wf(l)] : IW(l));
          !d && p !== "none" && x.push(...LW(l, m, p, b));
          const k = [l, ...x],
            w = await su(e, O),
            y = [];
          let C = ((r = o.flip) == null ? void 0 : r.overflows) || [];
          if ((u && y.push(w[v]), h)) {
            const L = RW(i, s, b);
            y.push(w[L[0]], w[L[1]]);
          }
          if (((C = [...C, { placement: i, overflows: y }]), !y.every((L) => L <= 0))) {
            var P, E;
            const L = (((P = o.flip) == null ? void 0 : P.index) || 0) + 1,
              D = k[L];
            if (D) return { data: { index: L, overflows: C }, reset: { placement: D } };
            let Q =
              (E = C.filter((R) => R.overflows[0] <= 0).sort((R, W) => R.overflows[1] - W.overflows[1])[0]) == null ? void 0 : E.placement;
            if (!Q)
              switch (f) {
                case "bestFit": {
                  var N;
                  const R =
                    (N = C.map((W) => [W.placement, W.overflows.filter((B) => B > 0).reduce((B, K) => B + K, 0)]).sort(
                      (W, B) => W[1] - B[1]
                    )[0]) == null
                      ? void 0
                      : N[0];
                  R && (Q = R);
                  break;
                }
                case "initialPlacement":
                  Q = l;
                  break;
              }
            if (i !== Q) return { reset: { placement: Q } };
          }
          return {};
        },
      }
    );
  };
function xC(t, e) {
  return { top: t.top - e.height, right: t.right - e.width, bottom: t.bottom - e.height, left: t.left - e.width };
}
function yC(t) {
  return PW.some((e) => t[e] >= 0);
}
const BW = function (t) {
  return (
    t === void 0 && (t = {}),
    {
      name: "hide",
      options: t,
      async fn(e) {
        const { rects: n } = e,
          { strategy: r = "referenceHidden", ...i } = Wi(t, e);
        switch (r) {
          case "referenceHidden": {
            const o = await su(e, { ...i, elementContext: "reference" }),
              s = xC(o, n.reference);
            return { data: { referenceHiddenOffsets: s, referenceHidden: yC(s) } };
          }
          case "escaped": {
            const o = await su(e, { ...i, altBoundary: !0 }),
              s = xC(o, n.floating);
            return { data: { escapedOffsets: s, escaped: yC(s) } };
          }
          default:
            return {};
        }
      },
    }
  );
};
async function VW(t, e) {
  const { placement: n, platform: r, elements: i } = t,
    o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
    s = Xi(n),
    l = Pa(n),
    a = Aa(n) === "y",
    c = ["left", "top"].includes(s) ? -1 : 1,
    u = o && a ? -1 : 1,
    h = Wi(e, t);
  let {
    mainAxis: d,
    crossAxis: f,
    alignmentAxis: p,
  } = typeof h == "number" ? { mainAxis: h, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...h };
  return l && typeof p == "number" && (f = l === "end" ? p * -1 : p), a ? { x: f * u, y: d * c } : { x: d * c, y: f * u };
}
const jW = function (t) {
    return (
      t === void 0 && (t = 0),
      {
        name: "offset",
        options: t,
        async fn(e) {
          var n, r;
          const { x: i, y: o, placement: s, middlewareData: l } = e,
            a = await VW(e, t);
          return s === ((n = l.offset) == null ? void 0 : n.placement) && (r = l.arrow) != null && r.alignmentOffset
            ? {}
            : { x: i + a.x, y: o + a.y, data: { ...a, placement: s } };
        },
      }
    );
  },
  ZW = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "shift",
        options: t,
        async fn(e) {
          const { x: n, y: r, placement: i } = e,
            {
              mainAxis: o = !0,
              crossAxis: s = !1,
              limiter: l = {
                fn: (O) => {
                  let { x: v, y: g } = O;
                  return { x: v, y: g };
                },
              },
              ...a
            } = Wi(t, e),
            c = { x: n, y: r },
            u = await su(e, a),
            h = Aa(Xi(i)),
            d = xx(h);
          let f = c[d],
            p = c[h];
          if (o) {
            const O = d === "y" ? "top" : "left",
              v = d === "y" ? "bottom" : "right",
              g = f + u[O],
              b = f - u[v];
            f = tO(g, f, b);
          }
          if (s) {
            const O = h === "y" ? "top" : "left",
              v = h === "y" ? "bottom" : "right",
              g = p + u[O],
              b = p - u[v];
            p = tO(g, p, b);
          }
          const m = l.fn({ ...e, [d]: f, [h]: p });
          return { ...m, data: { x: m.x - n, y: m.y - r } };
        },
      }
    );
  },
  zW = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        options: t,
        fn(e) {
          const { x: n, y: r, placement: i, rects: o, middlewareData: s } = e,
            { offset: l = 0, mainAxis: a = !0, crossAxis: c = !0 } = Wi(t, e),
            u = { x: n, y: r },
            h = Aa(i),
            d = xx(h);
          let f = u[d],
            p = u[h];
          const m = Wi(l, e),
            O = typeof m == "number" ? { mainAxis: m, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...m };
          if (a) {
            const b = d === "y" ? "height" : "width",
              x = o.reference[d] - o.floating[b] + O.mainAxis,
              k = o.reference[d] + o.reference[b] - O.mainAxis;
            f < x ? (f = x) : f > k && (f = k);
          }
          if (c) {
            var v, g;
            const b = d === "y" ? "width" : "height",
              x = ["top", "left"].includes(Xi(i)),
              k = o.reference[h] - o.floating[b] + ((x && ((v = s.offset) == null ? void 0 : v[h])) || 0) + (x ? 0 : O.crossAxis),
              w = o.reference[h] + o.reference[b] + (x ? 0 : ((g = s.offset) == null ? void 0 : g[h]) || 0) - (x ? O.crossAxis : 0);
            p < k ? (p = k) : p > w && (p = w);
          }
          return { [d]: f, [h]: p };
        },
      }
    );
  },
  WW = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "size",
        options: t,
        async fn(e) {
          const { placement: n, rects: r, platform: i, elements: o } = e,
            { apply: s = () => {}, ...l } = Wi(t, e),
            a = await su(e, l),
            c = Xi(n),
            u = Pa(n),
            h = Aa(n) === "y",
            { width: d, height: f } = r.floating;
          let p, m;
          c === "top" || c === "bottom"
            ? ((p = c), (m = u === ((await (i.isRTL == null ? void 0 : i.isRTL(o.floating))) ? "start" : "end") ? "left" : "right"))
            : ((m = c), (p = u === "end" ? "top" : "bottom"));
          const O = f - a.top - a.bottom,
            v = d - a.left - a.right,
            g = li(f - a[p], O),
            b = li(d - a[m], v),
            x = !e.middlewareData.shift;
          let k = g,
            w = b;
          if ((h ? (w = u || x ? li(b, v) : v) : (k = u || x ? li(g, O) : O), x && !u)) {
            const C = Kn(a.left, 0),
              P = Kn(a.right, 0),
              E = Kn(a.top, 0),
              N = Kn(a.bottom, 0);
            h
              ? (w = d - 2 * (C !== 0 || P !== 0 ? C + P : Kn(a.left, a.right)))
              : (k = f - 2 * (E !== 0 || N !== 0 ? E + N : Kn(a.top, a.bottom)));
          }
          await s({ ...e, availableWidth: w, availableHeight: k });
          const y = await i.getDimensions(o.floating);
          return d !== y.width || f !== y.height ? { reset: { rects: !0 } } : {};
        },
      }
    );
  };
function $a(t) {
  return FA(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function sr(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function to(t) {
  var e;
  return (e = (FA(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function FA(t) {
  return t instanceof Node || t instanceof sr(t).Node;
}
function bi(t) {
  return t instanceof Element || t instanceof sr(t).Element;
}
function xi(t) {
  return t instanceof HTMLElement || t instanceof sr(t).HTMLElement;
}
function wC(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof sr(t).ShadowRoot;
}
function uh(t) {
  const { overflow: e, overflowX: n, overflowY: r, display: i } = Mr(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i);
}
function XW(t) {
  return ["table", "td", "th"].includes($a(t));
}
function Sx(t) {
  const e = kx(),
    n = Mr(t);
  return (
    n.transform !== "none" ||
    n.perspective !== "none" ||
    (n.containerType ? n.containerType !== "normal" : !1) ||
    (!e && (n.backdropFilter ? n.backdropFilter !== "none" : !1)) ||
    (!e && (n.filter ? n.filter !== "none" : !1)) ||
    ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) ||
    ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r))
  );
}
function UW(t) {
  let e = Do(t);
  for (; xi(e) && !Gl(e); ) {
    if (Sx(e)) return e;
    e = Do(e);
  }
  return null;
}
function kx() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Gl(t) {
  return ["html", "body", "#document"].includes($a(t));
}
function Mr(t) {
  return sr(t).getComputedStyle(t);
}
function Cm(t) {
  return bi(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function Do(t) {
  if ($a(t) === "html") return t;
  const e = t.assignedSlot || t.parentNode || (wC(t) && t.host) || to(t);
  return wC(e) ? e.host : e;
}
function BA(t) {
  const e = Do(t);
  return Gl(e) ? (t.ownerDocument ? t.ownerDocument.body : t.body) : xi(e) && uh(e) ? e : BA(e);
}
function lu(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const i = BA(t),
    o = i === ((r = t.ownerDocument) == null ? void 0 : r.body),
    s = sr(i);
  return o ? e.concat(s, s.visualViewport || [], uh(i) ? i : [], s.frameElement && n ? lu(s.frameElement) : []) : e.concat(i, lu(i, [], n));
}
function VA(t) {
  const e = Mr(t);
  let n = parseFloat(e.width) || 0,
    r = parseFloat(e.height) || 0;
  const i = xi(t),
    o = i ? t.offsetWidth : n,
    s = i ? t.offsetHeight : r,
    l = zf(n) !== o || zf(r) !== s;
  return l && ((n = o), (r = s)), { width: n, height: r, $: l };
}
function Cx(t) {
  return bi(t) ? t : t.contextElement;
}
function Ml(t) {
  const e = Cx(t);
  if (!xi(e)) return Qo(1);
  const n = e.getBoundingClientRect(),
    { width: r, height: i, $: o } = VA(e);
  let s = (o ? zf(n.width) : n.width) / r,
    l = (o ? zf(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!l || !Number.isFinite(l)) && (l = 1), { x: s, y: l };
}
const HW = Qo(0);
function jA(t) {
  const e = sr(t);
  return !kx() || !e.visualViewport ? HW : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function qW(t, e, n) {
  return e === void 0 && (e = !1), !n || (e && n !== sr(t)) ? !1 : e;
}
function As(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(),
    o = Cx(t);
  let s = Qo(1);
  e && (r ? bi(r) && (s = Ml(r)) : (s = Ml(t)));
  const l = qW(o, n, r) ? jA(o) : Qo(0);
  let a = (i.left + l.x) / s.x,
    c = (i.top + l.y) / s.y,
    u = i.width / s.x,
    h = i.height / s.y;
  if (o) {
    const d = sr(o),
      f = r && bi(r) ? sr(r) : r;
    let p = d,
      m = p.frameElement;
    for (; m && r && f !== p; ) {
      const O = Ml(m),
        v = m.getBoundingClientRect(),
        g = Mr(m),
        b = v.left + (m.clientLeft + parseFloat(g.paddingLeft)) * O.x,
        x = v.top + (m.clientTop + parseFloat(g.paddingTop)) * O.y;
      (a *= O.x), (c *= O.y), (u *= O.x), (h *= O.y), (a += b), (c += x), (p = sr(m)), (m = p.frameElement);
    }
  }
  return Xf({ width: u, height: h, x: a, y: c });
}
const YW = [":popover-open", ":modal"];
function _x(t) {
  return YW.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function GW(t) {
  let { elements: e, rect: n, offsetParent: r, strategy: i } = t;
  const o = i === "fixed",
    s = to(r),
    l = e ? _x(e.floating) : !1;
  if (r === s || (l && o)) return n;
  let a = { scrollLeft: 0, scrollTop: 0 },
    c = Qo(1);
  const u = Qo(0),
    h = xi(r);
  if ((h || (!h && !o)) && (($a(r) !== "body" || uh(s)) && (a = Cm(r)), xi(r))) {
    const d = As(r);
    (c = Ml(r)), (u.x = d.x + r.clientLeft), (u.y = d.y + r.clientTop);
  }
  return { width: n.width * c.x, height: n.height * c.y, x: n.x * c.x - a.scrollLeft * c.x + u.x, y: n.y * c.y - a.scrollTop * c.y + u.y };
}
function JW(t) {
  return Array.from(t.getClientRects());
}
function ZA(t) {
  return As(to(t)).left + Cm(t).scrollLeft;
}
function KW(t) {
  const e = to(t),
    n = Cm(t),
    r = t.ownerDocument.body,
    i = Kn(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth),
    o = Kn(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + ZA(t);
  const l = -n.scrollTop;
  return Mr(r).direction === "rtl" && (s += Kn(e.clientWidth, r.clientWidth) - i), { width: i, height: o, x: s, y: l };
}
function eX(t, e) {
  const n = sr(t),
    r = to(t),
    i = n.visualViewport;
  let o = r.clientWidth,
    s = r.clientHeight,
    l = 0,
    a = 0;
  if (i) {
    (o = i.width), (s = i.height);
    const c = kx();
    (!c || (c && e === "fixed")) && ((l = i.offsetLeft), (a = i.offsetTop));
  }
  return { width: o, height: s, x: l, y: a };
}
function tX(t, e) {
  const n = As(t, !0, e === "fixed"),
    r = n.top + t.clientTop,
    i = n.left + t.clientLeft,
    o = xi(t) ? Ml(t) : Qo(1),
    s = t.clientWidth * o.x,
    l = t.clientHeight * o.y,
    a = i * o.x,
    c = r * o.y;
  return { width: s, height: l, x: a, y: c };
}
function SC(t, e, n) {
  let r;
  if (e === "viewport") r = eX(t, n);
  else if (e === "document") r = KW(to(t));
  else if (bi(e)) r = tX(e, n);
  else {
    const i = jA(t);
    r = { ...e, x: e.x - i.x, y: e.y - i.y };
  }
  return Xf(r);
}
function zA(t, e) {
  const n = Do(t);
  return n === e || !bi(n) || Gl(n) ? !1 : Mr(n).position === "fixed" || zA(n, e);
}
function nX(t, e) {
  const n = e.get(t);
  if (n) return n;
  let r = lu(t, [], !1).filter((l) => bi(l) && $a(l) !== "body"),
    i = null;
  const o = Mr(t).position === "fixed";
  let s = o ? Do(t) : t;
  for (; bi(s) && !Gl(s); ) {
    const l = Mr(s),
      a = Sx(s);
    !a && l.position === "fixed" && (i = null),
      (o ? !a && !i : (!a && l.position === "static" && !!i && ["absolute", "fixed"].includes(i.position)) || (uh(s) && !a && zA(t, s)))
        ? (r = r.filter((u) => u !== s))
        : (i = l),
      (s = Do(s));
  }
  return e.set(t, r), r;
}
function rX(t) {
  let { element: e, boundary: n, rootBoundary: r, strategy: i } = t;
  const s = [...(n === "clippingAncestors" ? (_x(e) ? [] : nX(e, this._c)) : [].concat(n)), r],
    l = s[0],
    a = s.reduce((c, u) => {
      const h = SC(e, u, i);
      return (
        (c.top = Kn(h.top, c.top)), (c.right = li(h.right, c.right)), (c.bottom = li(h.bottom, c.bottom)), (c.left = Kn(h.left, c.left)), c
      );
    }, SC(e, l, i));
  return { width: a.right - a.left, height: a.bottom - a.top, x: a.left, y: a.top };
}
function iX(t) {
  const { width: e, height: n } = VA(t);
  return { width: e, height: n };
}
function oX(t, e, n) {
  const r = xi(e),
    i = to(e),
    o = n === "fixed",
    s = As(t, !0, o, e);
  let l = { scrollLeft: 0, scrollTop: 0 };
  const a = Qo(0);
  if (r || (!r && !o))
    if ((($a(e) !== "body" || uh(i)) && (l = Cm(e)), r)) {
      const h = As(e, !0, o, e);
      (a.x = h.x + e.clientLeft), (a.y = h.y + e.clientTop);
    } else i && (a.x = ZA(i));
  const c = s.left + l.scrollLeft - a.x,
    u = s.top + l.scrollTop - a.y;
  return { x: c, y: u, width: s.width, height: s.height };
}
function Wg(t) {
  return Mr(t).position === "static";
}
function kC(t, e) {
  return !xi(t) || Mr(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function WA(t, e) {
  const n = sr(t);
  if (_x(t)) return n;
  if (!xi(t)) {
    let i = Do(t);
    for (; i && !Gl(i); ) {
      if (bi(i) && !Wg(i)) return i;
      i = Do(i);
    }
    return n;
  }
  let r = kC(t, e);
  for (; r && XW(r) && Wg(r); ) r = kC(r, e);
  return r && Gl(r) && Wg(r) && !Sx(r) ? n : r || UW(t) || n;
}
const sX = async function (t) {
  const e = this.getOffsetParent || WA,
    n = this.getDimensions,
    r = await n(t.floating);
  return { reference: oX(t.reference, await e(t.floating), t.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } };
};
function lX(t) {
  return Mr(t).direction === "rtl";
}
const aX = {
  convertOffsetParentRelativeRectToViewportRelativeRect: GW,
  getDocumentElement: to,
  getClippingRect: rX,
  getOffsetParent: WA,
  getElementRects: sX,
  getClientRects: JW,
  getDimensions: iX,
  getScale: Ml,
  isElement: bi,
  isRTL: lX,
};
function cX(t, e) {
  let n = null,
    r;
  const i = to(t);
  function o() {
    var l;
    clearTimeout(r), (l = n) == null || l.disconnect(), (n = null);
  }
  function s(l, a) {
    l === void 0 && (l = !1), a === void 0 && (a = 1), o();
    const { left: c, top: u, width: h, height: d } = t.getBoundingClientRect();
    if ((l || e(), !h || !d)) return;
    const f = Yh(u),
      p = Yh(i.clientWidth - (c + h)),
      m = Yh(i.clientHeight - (u + d)),
      O = Yh(c),
      g = { rootMargin: -f + "px " + -p + "px " + -m + "px " + -O + "px", threshold: Kn(0, li(1, a)) || 1 };
    let b = !0;
    function x(k) {
      const w = k[0].intersectionRatio;
      if (w !== a) {
        if (!b) return s();
        w
          ? s(!1, w)
          : (r = setTimeout(() => {
              s(!1, 1e-7);
            }, 1e3));
      }
      b = !1;
    }
    try {
      n = new IntersectionObserver(x, { ...g, root: i.ownerDocument });
    } catch {
      n = new IntersectionObserver(x, g);
    }
    n.observe(t);
  }
  return s(!0), o;
}
function uX(t, e, n, r) {
  r === void 0 && (r = {});
  const {
      ancestorScroll: i = !0,
      ancestorResize: o = !0,
      elementResize: s = typeof ResizeObserver == "function",
      layoutShift: l = typeof IntersectionObserver == "function",
      animationFrame: a = !1,
    } = r,
    c = Cx(t),
    u = i || o ? [...(c ? lu(c) : []), ...lu(e)] : [];
  u.forEach((v) => {
    i && v.addEventListener("scroll", n, { passive: !0 }), o && v.addEventListener("resize", n);
  });
  const h = c && l ? cX(c, n) : null;
  let d = -1,
    f = null;
  s &&
    ((f = new ResizeObserver((v) => {
      let [g] = v;
      g &&
        g.target === c &&
        f &&
        (f.unobserve(e),
        cancelAnimationFrame(d),
        (d = requestAnimationFrame(() => {
          var b;
          (b = f) == null || b.observe(e);
        }))),
        n();
    })),
    c && !a && f.observe(c),
    f.observe(e));
  let p,
    m = a ? As(t) : null;
  a && O();
  function O() {
    const v = As(t);
    m && (v.x !== m.x || v.y !== m.y || v.width !== m.width || v.height !== m.height) && n(), (m = v), (p = requestAnimationFrame(O));
  }
  return (
    n(),
    () => {
      var v;
      u.forEach((g) => {
        i && g.removeEventListener("scroll", n), o && g.removeEventListener("resize", n);
      }),
        h == null || h(),
        (v = f) == null || v.disconnect(),
        (f = null),
        a && cancelAnimationFrame(p);
    }
  );
}
const hX = jW,
  dX = ZW,
  fX = FW,
  pX = WW,
  mX = BW,
  CC = DW,
  gX = zW,
  OX = (t, e, n) => {
    const r = new Map(),
      i = { platform: aX, ...n },
      o = { ...i.platform, _c: r };
    return QW(t, e, { ...i, platform: o });
  };
var qd = typeof document < "u" ? _.useLayoutEffect : _.useEffect;
function Uf(t, e) {
  if (t === e) return !0;
  if (typeof t != typeof e) return !1;
  if (typeof t == "function" && t.toString() === e.toString()) return !0;
  let n, r, i;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (((n = t.length), n !== e.length)) return !1;
      for (r = n; r-- !== 0; ) if (!Uf(t[r], e[r])) return !1;
      return !0;
    }
    if (((i = Object.keys(t)), (n = i.length), n !== Object.keys(e).length)) return !1;
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(e, i[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && t.$$typeof) && !Uf(t[o], e[o])) return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function XA(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _C(t, e) {
  const n = XA(t);
  return Math.round(e * n) / n;
}
function EC(t) {
  const e = _.useRef(t);
  return (
    qd(() => {
      e.current = t;
    }),
    e
  );
}
function vX(t) {
  t === void 0 && (t = {});
  const {
      placement: e = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: i,
      elements: { reference: o, floating: s } = {},
      transform: l = !0,
      whileElementsMounted: a,
      open: c,
    } = t,
    [u, h] = _.useState({ x: 0, y: 0, strategy: n, placement: e, middlewareData: {}, isPositioned: !1 }),
    [d, f] = _.useState(r);
  Uf(d, r) || f(r);
  const [p, m] = _.useState(null),
    [O, v] = _.useState(null),
    g = _.useCallback((B) => {
      B !== w.current && ((w.current = B), m(B));
    }, []),
    b = _.useCallback((B) => {
      B !== y.current && ((y.current = B), v(B));
    }, []),
    x = o || p,
    k = s || O,
    w = _.useRef(null),
    y = _.useRef(null),
    C = _.useRef(u),
    P = a != null,
    E = EC(a),
    N = EC(i),
    L = _.useCallback(() => {
      if (!w.current || !y.current) return;
      const B = { placement: e, strategy: n, middleware: d };
      N.current && (B.platform = N.current),
        OX(w.current, y.current, B).then((K) => {
          const ne = { ...K, isPositioned: !0 };
          D.current &&
            !Uf(C.current, ne) &&
            ((C.current = ne),
            Ss.flushSync(() => {
              h(ne);
            }));
        });
    }, [d, e, n, N]);
  qd(() => {
    c === !1 && C.current.isPositioned && ((C.current.isPositioned = !1), h((B) => ({ ...B, isPositioned: !1 })));
  }, [c]);
  const D = _.useRef(!1);
  qd(
    () => (
      (D.current = !0),
      () => {
        D.current = !1;
      }
    ),
    []
  ),
    qd(() => {
      if ((x && (w.current = x), k && (y.current = k), x && k)) {
        if (E.current) return E.current(x, k, L);
        L();
      }
    }, [x, k, L, E, P]);
  const Q = _.useMemo(() => ({ reference: w, floating: y, setReference: g, setFloating: b }), [g, b]),
    R = _.useMemo(() => ({ reference: x, floating: k }), [x, k]),
    W = _.useMemo(() => {
      const B = { position: n, left: 0, top: 0 };
      if (!R.floating) return B;
      const K = _C(R.floating, u.x),
        ne = _C(R.floating, u.y);
      return l
        ? { ...B, transform: "translate(" + K + "px, " + ne + "px)", ...(XA(R.floating) >= 1.5 && { willChange: "transform" }) }
        : { position: n, left: K, top: ne };
    }, [n, l, R.floating, u.x, u.y]);
  return _.useMemo(() => ({ ...u, update: L, refs: Q, elements: R, floatingStyles: W }), [u, L, Q, R, W]);
}
const bX = (t) => {
    function e(n) {
      return {}.hasOwnProperty.call(n, "current");
    }
    return {
      name: "arrow",
      options: t,
      fn(n) {
        const { element: r, padding: i } = typeof t == "function" ? t(n) : t;
        return r && e(r)
          ? r.current != null
            ? CC({ element: r.current, padding: i }).fn(n)
            : {}
          : r
          ? CC({ element: r, padding: i }).fn(n)
          : {};
      },
    };
  },
  xX = (t, e) => ({ ...hX(t), options: [t, e] }),
  yX = (t, e) => ({ ...dX(t), options: [t, e] }),
  wX = (t, e) => ({ ...gX(t), options: [t, e] }),
  SX = (t, e) => ({ ...fX(t), options: [t, e] }),
  kX = (t, e) => ({ ...pX(t), options: [t, e] }),
  CX = (t, e) => ({ ...mX(t), options: [t, e] }),
  _X = (t, e) => ({ ...bX(t), options: [t, e] });
var EX = "Arrow",
  UA = _.forwardRef((t, e) => {
    const { children: n, width: r = 10, height: i = 5, ...o } = t;
    return T.jsx(qe.svg, {
      ...o,
      ref: e,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : T.jsx("polygon", { points: "0,0 30,0 15,10" }),
    });
  });
UA.displayName = EX;
var TX = UA;
function PX(t) {
  const [e, n] = _.useState(void 0);
  return (
    Rn(() => {
      if (t) {
        n({ width: t.offsetWidth, height: t.offsetHeight });
        const r = new ResizeObserver((i) => {
          if (!Array.isArray(i) || !i.length) return;
          const o = i[0];
          let s, l;
          if ("borderBoxSize" in o) {
            const a = o.borderBoxSize,
              c = Array.isArray(a) ? a[0] : a;
            (s = c.inlineSize), (l = c.blockSize);
          } else (s = t.offsetWidth), (l = t.offsetHeight);
          n({ width: s, height: l });
        });
        return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
      } else n(void 0);
    }, [t]),
    e
  );
}
var Ex = "Popper",
  [HA, Ra] = Jo(Ex),
  [AX, qA] = HA(Ex),
  YA = (t) => {
    const { __scopePopper: e, children: n } = t,
      [r, i] = _.useState(null);
    return T.jsx(AX, { scope: e, anchor: r, onAnchorChange: i, children: n });
  };
YA.displayName = Ex;
var GA = "PopperAnchor",
  JA = _.forwardRef((t, e) => {
    const { __scopePopper: n, virtualRef: r, ...i } = t,
      o = qA(GA, n),
      s = _.useRef(null),
      l = Pt(e, s);
    return (
      _.useEffect(() => {
        o.onAnchorChange((r == null ? void 0 : r.current) || s.current);
      }),
      r ? null : T.jsx(qe.div, { ...i, ref: l })
    );
  });
JA.displayName = GA;
var Tx = "PopperContent",
  [$X, RX] = HA(Tx),
  KA = _.forwardRef((t, e) => {
    var Y, q, oe, ce, Oe, _e;
    const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: i = 0,
        align: o = "center",
        alignOffset: s = 0,
        arrowPadding: l = 0,
        avoidCollisions: a = !0,
        collisionBoundary: c = [],
        collisionPadding: u = 0,
        sticky: h = "partial",
        hideWhenDetached: d = !1,
        updatePositionStrategy: f = "optimized",
        onPlaced: p,
        ...m
      } = t,
      O = qA(Tx, n),
      [v, g] = _.useState(null),
      b = Pt(e, (Le) => g(Le)),
      [x, k] = _.useState(null),
      w = PX(x),
      y = (w == null ? void 0 : w.width) ?? 0,
      C = (w == null ? void 0 : w.height) ?? 0,
      P = r + (o !== "center" ? "-" + o : ""),
      E = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u },
      N = Array.isArray(c) ? c : [c],
      L = N.length > 0,
      D = { padding: E, boundary: N.filter(MX), altBoundary: L },
      {
        refs: Q,
        floatingStyles: R,
        placement: W,
        isPositioned: B,
        middlewareData: K,
      } = vX({
        strategy: "fixed",
        placement: P,
        whileElementsMounted: (...Le) => uX(...Le, { animationFrame: f === "always" }),
        elements: { reference: O.anchor },
        middleware: [
          xX({ mainAxis: i + C, alignmentAxis: s }),
          a && yX({ mainAxis: !0, crossAxis: !1, limiter: h === "partial" ? wX() : void 0, ...D }),
          a && SX({ ...D }),
          kX({
            ...D,
            apply: ({ elements: Le, rects: Ge, availableWidth: Ct, availableHeight: $t }) => {
              const { width: Rt, height: We } = Ge.reference,
                Ne = Le.floating.style;
              Ne.setProperty("--radix-popper-available-width", `${Ct}px`),
                Ne.setProperty("--radix-popper-available-height", `${$t}px`),
                Ne.setProperty("--radix-popper-anchor-width", `${Rt}px`),
                Ne.setProperty("--radix-popper-anchor-height", `${We}px`);
            },
          }),
          x && _X({ element: x, padding: l }),
          LX({ arrowWidth: y, arrowHeight: C }),
          d && CX({ strategy: "referenceHidden", ...D }),
        ],
      }),
      [ne, A] = n$(W),
      V = vi(p);
    Rn(() => {
      B && (V == null || V());
    }, [B, V]);
    const ie = (Y = K.arrow) == null ? void 0 : Y.x,
      M = (q = K.arrow) == null ? void 0 : q.y,
      fe = ((oe = K.arrow) == null ? void 0 : oe.centerOffset) !== 0,
      [Se, pe] = _.useState();
    return (
      Rn(() => {
        v && pe(window.getComputedStyle(v).zIndex);
      }, [v]),
      T.jsx("div", {
        ref: Q.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...R,
          transform: B ? R.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: Se,
          "--radix-popper-transform-origin": [
            (ce = K.transformOrigin) == null ? void 0 : ce.x,
            (Oe = K.transformOrigin) == null ? void 0 : Oe.y,
          ].join(" "),
          ...(((_e = K.hide) == null ? void 0 : _e.referenceHidden) && { visibility: "hidden", pointerEvents: "none" }),
        },
        dir: t.dir,
        children: T.jsx($X, {
          scope: n,
          placedSide: ne,
          onArrowChange: k,
          arrowX: ie,
          arrowY: M,
          shouldHideArrow: fe,
          children: T.jsx(qe.div, {
            "data-side": ne,
            "data-align": A,
            ...m,
            ref: b,
            style: { ...m.style, animation: B ? void 0 : "none" },
          }),
        }),
      })
    );
  });
KA.displayName = Tx;
var e$ = "PopperArrow",
  IX = { top: "bottom", right: "left", bottom: "top", left: "right" },
  t$ = _.forwardRef(function (e, n) {
    const { __scopePopper: r, ...i } = e,
      o = RX(e$, r),
      s = IX[o.placedSide];
    return T.jsx("span", {
      ref: o.onArrowChange,
      style: {
        position: "absolute",
        left: o.arrowX,
        top: o.arrowY,
        [s]: 0,
        transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[o.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[o.placedSide],
        visibility: o.shouldHideArrow ? "hidden" : void 0,
      },
      children: T.jsx(TX, { ...i, ref: n, style: { ...i.style, display: "block" } }),
    });
  });
t$.displayName = e$;
function MX(t) {
  return t !== null;
}
var LX = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var O, v, g;
    const { placement: n, rects: r, middlewareData: i } = e,
      s = ((O = i.arrow) == null ? void 0 : O.centerOffset) !== 0,
      l = s ? 0 : t.arrowWidth,
      a = s ? 0 : t.arrowHeight,
      [c, u] = n$(n),
      h = { start: "0%", center: "50%", end: "100%" }[u],
      d = (((v = i.arrow) == null ? void 0 : v.x) ?? 0) + l / 2,
      f = (((g = i.arrow) == null ? void 0 : g.y) ?? 0) + a / 2;
    let p = "",
      m = "";
    return (
      c === "bottom"
        ? ((p = s ? h : `${d}px`), (m = `${-a}px`))
        : c === "top"
        ? ((p = s ? h : `${d}px`), (m = `${r.floating.height + a}px`))
        : c === "right"
        ? ((p = `${-a}px`), (m = s ? h : `${f}px`))
        : c === "left" && ((p = `${r.floating.width + a}px`), (m = s ? h : `${f}px`)),
      { data: { x: p, y: m } }
    );
  },
});
function n$(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var Px = YA,
  _m = JA,
  Ax = KA,
  $x = t$,
  NX = "Portal",
  Em = _.forwardRef((t, e) => {
    var l;
    const { container: n, ...r } = t,
      [i, o] = _.useState(!1);
    Rn(() => o(!0), []);
    const s = n || (i && ((l = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : l.body));
    return s ? AM.createPortal(T.jsx(qe.div, { ...r, ref: e }), s) : null;
  });
Em.displayName = NX;
function QX(t, e) {
  return _.useReducer((n, r) => e[n][r] ?? n, t);
}
var hh = (t) => {
  const { present: e, children: n } = t,
    r = DX(e),
    i = typeof n == "function" ? n({ present: r.isPresent }) : _.Children.only(n),
    o = Pt(r.ref, FX(i));
  return typeof n == "function" || r.isPresent ? _.cloneElement(i, { ref: o }) : null;
};
hh.displayName = "Presence";
function DX(t) {
  const [e, n] = _.useState(),
    r = _.useRef({}),
    i = _.useRef(t),
    o = _.useRef("none"),
    s = t ? "mounted" : "unmounted",
    [l, a] = QX(s, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    _.useEffect(() => {
      const c = Gh(r.current);
      o.current = l === "mounted" ? c : "none";
    }, [l]),
    Rn(() => {
      const c = r.current,
        u = i.current;
      if (u !== t) {
        const d = o.current,
          f = Gh(c);
        t
          ? a("MOUNT")
          : f === "none" || (c == null ? void 0 : c.display) === "none"
          ? a("UNMOUNT")
          : a(u && d !== f ? "ANIMATION_OUT" : "UNMOUNT"),
          (i.current = t);
      }
    }, [t, a]),
    Rn(() => {
      if (e) {
        const c = (h) => {
            const f = Gh(r.current).includes(h.animationName);
            h.target === e && f && Ss.flushSync(() => a("ANIMATION_END"));
          },
          u = (h) => {
            h.target === e && (o.current = Gh(r.current));
          };
        return (
          e.addEventListener("animationstart", u),
          e.addEventListener("animationcancel", c),
          e.addEventListener("animationend", c),
          () => {
            e.removeEventListener("animationstart", u),
              e.removeEventListener("animationcancel", c),
              e.removeEventListener("animationend", c);
          }
        );
      } else a("ANIMATION_END");
    }, [e, a]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(l),
      ref: _.useCallback((c) => {
        c && (r.current = getComputedStyle(c)), n(c);
      }, []),
    }
  );
}
function Gh(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function FX(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
function Fo({ prop: t, defaultProp: e, onChange: n = () => {} }) {
  const [r, i] = BX({ defaultProp: e, onChange: n }),
    o = t !== void 0,
    s = o ? t : r,
    l = vi(n),
    a = _.useCallback(
      (c) => {
        if (o) {
          const h = typeof c == "function" ? c(t) : c;
          h !== t && l(h);
        } else i(c);
      },
      [o, t, i, l]
    );
  return [s, a];
}
function BX({ defaultProp: t, onChange: e }) {
  const n = _.useState(t),
    [r] = n,
    i = _.useRef(r),
    o = vi(e);
  return (
    _.useEffect(() => {
      i.current !== r && (o(r), (i.current = r));
    }, [r, i, o]),
    n
  );
}
var r$ = bM(),
  Xg = function () {},
  Tm = _.forwardRef(function (t, e) {
    var n = _.useRef(null),
      r = _.useState({ onScrollCapture: Xg, onWheelCapture: Xg, onTouchMoveCapture: Xg }),
      i = r[0],
      o = r[1],
      s = t.forwardProps,
      l = t.children,
      a = t.className,
      c = t.removeScrollBar,
      u = t.enabled,
      h = t.shards,
      d = t.sideCar,
      f = t.noIsolation,
      p = t.inert,
      m = t.allowPinchZoom,
      O = t.as,
      v = O === void 0 ? "div" : O,
      g = t.gapMode,
      b = xM(t, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode",
      ]),
      x = d,
      k = yM([n, e]),
      w = po(po({}, b), i);
    return _.createElement(
      _.Fragment,
      null,
      u &&
        _.createElement(x, {
          sideCar: r$,
          removeScrollBar: c,
          shards: h,
          noIsolation: f,
          inert: p,
          setCallbacks: o,
          allowPinchZoom: !!m,
          lockRef: n,
          gapMode: g,
        }),
      s ? _.cloneElement(_.Children.only(l), po(po({}, w), { ref: k })) : _.createElement(v, po({}, w, { className: a, ref: k }), l)
    );
  });
Tm.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
Tm.classNames = { fullWidth: wM, zeroRight: SM };
var rO = !1;
if (typeof window < "u")
  try {
    var Jh = Object.defineProperty({}, "passive", {
      get: function () {
        return (rO = !0), !0;
      },
    });
    window.addEventListener("test", Jh, Jh), window.removeEventListener("test", Jh, Jh);
  } catch {
    rO = !1;
  }
var el = rO ? { passive: !1 } : !1,
  VX = function (t) {
    return t.tagName === "TEXTAREA";
  },
  i$ = function (t, e) {
    var n = window.getComputedStyle(t);
    return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !VX(t) && n[e] === "visible");
  },
  jX = function (t) {
    return i$(t, "overflowY");
  },
  ZX = function (t) {
    return i$(t, "overflowX");
  },
  TC = function (t, e) {
    var n = e.ownerDocument,
      r = e;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var i = o$(t, r);
      if (i) {
        var o = s$(t, r),
          s = o[1],
          l = o[2];
        if (s > l) return !0;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return !1;
  },
  zX = function (t) {
    var e = t.scrollTop,
      n = t.scrollHeight,
      r = t.clientHeight;
    return [e, n, r];
  },
  WX = function (t) {
    var e = t.scrollLeft,
      n = t.scrollWidth,
      r = t.clientWidth;
    return [e, n, r];
  },
  o$ = function (t, e) {
    return t === "v" ? jX(e) : ZX(e);
  },
  s$ = function (t, e) {
    return t === "v" ? zX(e) : WX(e);
  },
  XX = function (t, e) {
    return t === "h" && e === "rtl" ? -1 : 1;
  },
  UX = function (t, e, n, r, i) {
    var o = XX(t, window.getComputedStyle(e).direction),
      s = o * r,
      l = n.target,
      a = e.contains(l),
      c = !1,
      u = s > 0,
      h = 0,
      d = 0;
    do {
      var f = s$(t, l),
        p = f[0],
        m = f[1],
        O = f[2],
        v = m - O - o * p;
      (p || v) && o$(t, l) && ((h += v), (d += p)), l instanceof ShadowRoot ? (l = l.host) : (l = l.parentNode);
    } while ((!a && l !== document.body) || (a && (e.contains(l) || e === l)));
    return ((u && ((i && Math.abs(h) < 1) || (!i && s > h))) || (!u && ((i && Math.abs(d) < 1) || (!i && -s > d)))) && (c = !0), c;
  },
  Kh = function (t) {
    return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
  },
  PC = function (t) {
    return [t.deltaX, t.deltaY];
  },
  AC = function (t) {
    return t && "current" in t ? t.current : t;
  },
  HX = function (t, e) {
    return t[0] === e[0] && t[1] === e[1];
  },
  qX = function (t) {
    return `
  .block-interactivity-`
      .concat(
        t,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        t,
        ` {pointer-events: all;}
`
      );
  },
  YX = 0,
  tl = [];
function GX(t) {
  var e = _.useRef([]),
    n = _.useRef([0, 0]),
    r = _.useRef(),
    i = _.useState(YX++)[0],
    o = _.useState(kM)[0],
    s = _.useRef(t);
  _.useEffect(
    function () {
      s.current = t;
    },
    [t]
  ),
    _.useEffect(
      function () {
        if (t.inert) {
          document.body.classList.add("block-interactivity-".concat(i));
          var m = CM([t.lockRef.current], (t.shards || []).map(AC), !0).filter(Boolean);
          return (
            m.forEach(function (O) {
              return O.classList.add("allow-interactivity-".concat(i));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(i)),
                m.forEach(function (O) {
                  return O.classList.remove("allow-interactivity-".concat(i));
                });
            }
          );
        }
      },
      [t.inert, t.lockRef.current, t.shards]
    );
  var l = _.useCallback(function (m, O) {
      if ("touches" in m && m.touches.length === 2) return !s.current.allowPinchZoom;
      var v = Kh(m),
        g = n.current,
        b = "deltaX" in m ? m.deltaX : g[0] - v[0],
        x = "deltaY" in m ? m.deltaY : g[1] - v[1],
        k,
        w = m.target,
        y = Math.abs(b) > Math.abs(x) ? "h" : "v";
      if ("touches" in m && y === "h" && w.type === "range") return !1;
      var C = TC(y, w);
      if (!C) return !0;
      if ((C ? (k = y) : ((k = y === "v" ? "h" : "v"), (C = TC(y, w))), !C)) return !1;
      if ((!r.current && "changedTouches" in m && (b || x) && (r.current = k), !k)) return !0;
      var P = r.current || k;
      return UX(P, O, m, P === "h" ? b : x, !0);
    }, []),
    a = _.useCallback(function (m) {
      var O = m;
      if (!(!tl.length || tl[tl.length - 1] !== o)) {
        var v = "deltaY" in O ? PC(O) : Kh(O),
          g = e.current.filter(function (k) {
            return k.name === O.type && (k.target === O.target || O.target === k.shadowParent) && HX(k.delta, v);
          })[0];
        if (g && g.should) {
          O.cancelable && O.preventDefault();
          return;
        }
        if (!g) {
          var b = (s.current.shards || [])
              .map(AC)
              .filter(Boolean)
              .filter(function (k) {
                return k.contains(O.target);
              }),
            x = b.length > 0 ? l(O, b[0]) : !s.current.noIsolation;
          x && O.cancelable && O.preventDefault();
        }
      }
    }, []),
    c = _.useCallback(function (m, O, v, g) {
      var b = { name: m, delta: O, target: v, should: g, shadowParent: JX(v) };
      e.current.push(b),
        setTimeout(function () {
          e.current = e.current.filter(function (x) {
            return x !== b;
          });
        }, 1);
    }, []),
    u = _.useCallback(function (m) {
      (n.current = Kh(m)), (r.current = void 0);
    }, []),
    h = _.useCallback(function (m) {
      c(m.type, PC(m), m.target, l(m, t.lockRef.current));
    }, []),
    d = _.useCallback(function (m) {
      c(m.type, Kh(m), m.target, l(m, t.lockRef.current));
    }, []);
  _.useEffect(function () {
    return (
      tl.push(o),
      t.setCallbacks({ onScrollCapture: h, onWheelCapture: h, onTouchMoveCapture: d }),
      document.addEventListener("wheel", a, el),
      document.addEventListener("touchmove", a, el),
      document.addEventListener("touchstart", u, el),
      function () {
        (tl = tl.filter(function (m) {
          return m !== o;
        })),
          document.removeEventListener("wheel", a, el),
          document.removeEventListener("touchmove", a, el),
          document.removeEventListener("touchstart", u, el);
      }
    );
  }, []);
  var f = t.removeScrollBar,
    p = t.inert;
  return _.createElement(
    _.Fragment,
    null,
    p ? _.createElement(o, { styles: qX(i) }) : null,
    f ? _.createElement(_M, { gapMode: t.gapMode }) : null
  );
}
function JX(t) {
  for (var e = null; t !== null; ) t instanceof ShadowRoot && ((e = t.host), (t = t.host)), (t = t.parentNode);
  return e;
}
const KX = EM(r$, GX);
var l$ = _.forwardRef(function (t, e) {
  return _.createElement(Tm, po({}, t, { ref: e, sideCar: KX }));
});
l$.classNames = Tm.classNames;
const a$ = l$;
var Rx = "Popover",
  [c$, Lme] = Jo(Rx, [Ra]),
  dh = Ra(),
  [eU, Ko] = c$(Rx),
  u$ = (t) => {
    const { __scopePopover: e, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: s = !1 } = t,
      l = dh(e),
      a = _.useRef(null),
      [c, u] = _.useState(!1),
      [h = !1, d] = Fo({ prop: r, defaultProp: i, onChange: o });
    return T.jsx(Px, {
      ...l,
      children: T.jsx(eU, {
        scope: e,
        contentId: Ta(),
        triggerRef: a,
        open: h,
        onOpenChange: d,
        onOpenToggle: _.useCallback(() => d((f) => !f), [d]),
        hasCustomAnchor: c,
        onCustomAnchorAdd: _.useCallback(() => u(!0), []),
        onCustomAnchorRemove: _.useCallback(() => u(!1), []),
        modal: s,
        children: n,
      }),
    });
  };
u$.displayName = Rx;
var h$ = "PopoverAnchor",
  d$ = _.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      i = Ko(h$, n),
      o = dh(n),
      { onCustomAnchorAdd: s, onCustomAnchorRemove: l } = i;
    return _.useEffect(() => (s(), () => l()), [s, l]), T.jsx(_m, { ...o, ...r, ref: e });
  });
d$.displayName = h$;
var f$ = "PopoverTrigger",
  Pm = _.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      i = Ko(f$, n),
      o = dh(n),
      s = Pt(e, i.triggerRef),
      l = T.jsx(qe.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": v$(i.open),
        ...r,
        ref: s,
        onClick: Be(t.onClick, i.onOpenToggle),
      });
    return i.hasCustomAnchor ? l : T.jsx(_m, { asChild: !0, ...o, children: l });
  });
Pm.displayName = f$;
var Ix = "PopoverPortal",
  [tU, nU] = c$(Ix, { forceMount: void 0 }),
  p$ = (t) => {
    const { __scopePopover: e, forceMount: n, children: r, container: i } = t,
      o = Ko(Ix, e);
    return T.jsx(tU, {
      scope: e,
      forceMount: n,
      children: T.jsx(hh, { present: n || o.open, children: T.jsx(Em, { asChild: !0, container: i, children: r }) }),
    });
  };
p$.displayName = Ix;
var Jl = "PopoverContent",
  Am = _.forwardRef((t, e) => {
    const n = nU(Jl, t.__scopePopover),
      { forceMount: r = n.forceMount, ...i } = t,
      o = Ko(Jl, t.__scopePopover);
    return T.jsx(hh, { present: r || o.open, children: o.modal ? T.jsx(rU, { ...i, ref: e }) : T.jsx(iU, { ...i, ref: e }) });
  });
Am.displayName = Jl;
var rU = _.forwardRef((t, e) => {
    const n = Ko(Jl, t.__scopePopover),
      r = _.useRef(null),
      i = Pt(e, r),
      o = _.useRef(!1);
    return (
      _.useEffect(() => {
        const s = r.current;
        if (s) return iT(s);
      }, []),
      T.jsx(a$, {
        as: Yl,
        allowPinchZoom: !0,
        children: T.jsx(m$, {
          ...t,
          ref: i,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Be(t.onCloseAutoFocus, (s) => {
            var l;
            s.preventDefault(), o.current || (l = n.triggerRef.current) == null || l.focus();
          }),
          onPointerDownOutside: Be(
            t.onPointerDownOutside,
            (s) => {
              const l = s.detail.originalEvent,
                a = l.button === 0 && l.ctrlKey === !0,
                c = l.button === 2 || a;
              o.current = c;
            },
            { checkForDefaultPrevented: !1 }
          ),
          onFocusOutside: Be(t.onFocusOutside, (s) => s.preventDefault(), { checkForDefaultPrevented: !1 }),
        }),
      })
    );
  }),
  iU = _.forwardRef((t, e) => {
    const n = Ko(Jl, t.__scopePopover),
      r = _.useRef(!1),
      i = _.useRef(!1);
    return T.jsx(m$, {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (o) => {
        var s, l;
        (s = t.onCloseAutoFocus) == null || s.call(t, o),
          o.defaultPrevented || (r.current || (l = n.triggerRef.current) == null || l.focus(), o.preventDefault()),
          (r.current = !1),
          (i.current = !1);
      },
      onInteractOutside: (o) => {
        var a, c;
        (a = t.onInteractOutside) == null || a.call(t, o),
          o.defaultPrevented || ((r.current = !0), o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
        const s = o.target;
        ((c = n.triggerRef.current) == null ? void 0 : c.contains(s)) && o.preventDefault(),
          o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
      },
    });
  }),
  m$ = _.forwardRef((t, e) => {
    const {
        __scopePopover: n,
        trapFocus: r,
        onOpenAutoFocus: i,
        onCloseAutoFocus: o,
        disableOutsidePointerEvents: s,
        onEscapeKeyDown: l,
        onPointerDownOutside: a,
        onFocusOutside: c,
        onInteractOutside: u,
        ...h
      } = t,
      d = Ko(Jl, n),
      f = dh(n);
    return (
      NA(),
      T.jsx(bx, {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: o,
        children: T.jsx(km, {
          asChild: !0,
          disableOutsidePointerEvents: s,
          onInteractOutside: u,
          onEscapeKeyDown: l,
          onPointerDownOutside: a,
          onFocusOutside: c,
          onDismiss: () => d.onOpenChange(!1),
          children: T.jsx(Ax, {
            "data-state": v$(d.open),
            role: "dialog",
            id: d.contentId,
            ...f,
            ...h,
            ref: e,
            style: {
              ...h.style,
              "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
              "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
              "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)",
            },
          }),
        }),
      })
    );
  }),
  g$ = "PopoverClose",
  oU = _.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      i = Ko(g$, n);
    return T.jsx(qe.button, { type: "button", ...r, ref: e, onClick: Be(t.onClick, () => i.onOpenChange(!1)) });
  });
oU.displayName = g$;
var sU = "PopoverArrow",
  O$ = _.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      i = dh(n);
    return T.jsx($x, { ...i, ...r, ref: e });
  });
O$.displayName = sU;
function v$(t) {
  return t ? "open" : "closed";
}
var $m = u$,
  lU = d$,
  aU = Pm,
  Rm = p$,
  b$ = Am,
  Im = O$;
function x$(t) {
  const e = t + "CollectionProvider",
    [n, r] = Jo(e),
    [i, o] = n(e, { collectionRef: { current: null }, itemMap: new Map() }),
    s = (f) => {
      const { scope: p, children: m } = f,
        O = S.useRef(null),
        v = S.useRef(new Map()).current;
      return T.jsx(i, { scope: p, itemMap: v, collectionRef: O, children: m });
    };
  s.displayName = e;
  const l = t + "CollectionSlot",
    a = S.forwardRef((f, p) => {
      const { scope: m, children: O } = f,
        v = o(l, m),
        g = Pt(p, v.collectionRef);
      return T.jsx(Yl, { ref: g, children: O });
    });
  a.displayName = l;
  const c = t + "CollectionItemSlot",
    u = "data-radix-collection-item",
    h = S.forwardRef((f, p) => {
      const { scope: m, children: O, ...v } = f,
        g = S.useRef(null),
        b = Pt(p, g),
        x = o(c, m);
      return (
        S.useEffect(() => (x.itemMap.set(g, { ref: g, ...v }), () => void x.itemMap.delete(g))), T.jsx(Yl, { [u]: "", ref: b, children: O })
      );
    });
  h.displayName = c;
  function d(f) {
    const p = o(t + "CollectionConsumer", f);
    return S.useCallback(() => {
      const O = p.collectionRef.current;
      if (!O) return [];
      const v = Array.from(O.querySelectorAll(`[${u}]`));
      return Array.from(p.itemMap.values()).sort((x, k) => v.indexOf(x.ref.current) - v.indexOf(k.ref.current));
    }, [p.collectionRef, p.itemMap]);
  }
  return [{ Provider: s, Slot: a, ItemSlot: h }, d, r];
}
var cU = _.createContext(void 0);
function Mm(t) {
  const e = _.useContext(cU);
  return t || e || "ltr";
}
var Ug = "rovingFocusGroup.onEntryFocus",
  uU = { bubbles: !1, cancelable: !0 },
  Lm = "RovingFocusGroup",
  [iO, y$, hU] = x$(Lm),
  [dU, Nm] = Jo(Lm, [hU]),
  [fU, pU] = dU(Lm),
  w$ = _.forwardRef((t, e) =>
    T.jsx(iO.Provider, {
      scope: t.__scopeRovingFocusGroup,
      children: T.jsx(iO.Slot, { scope: t.__scopeRovingFocusGroup, children: T.jsx(mU, { ...t, ref: e }) }),
    })
  );
w$.displayName = Lm;
var mU = _.forwardRef((t, e) => {
    const {
        __scopeRovingFocusGroup: n,
        orientation: r,
        loop: i = !1,
        dir: o,
        currentTabStopId: s,
        defaultCurrentTabStopId: l,
        onCurrentTabStopIdChange: a,
        onEntryFocus: c,
        preventScrollOnEntryFocus: u = !1,
        ...h
      } = t,
      d = _.useRef(null),
      f = Pt(e, d),
      p = Mm(o),
      [m = null, O] = Fo({ prop: s, defaultProp: l, onChange: a }),
      [v, g] = _.useState(!1),
      b = vi(c),
      x = y$(n),
      k = _.useRef(!1),
      [w, y] = _.useState(0);
    return (
      _.useEffect(() => {
        const C = d.current;
        if (C) return C.addEventListener(Ug, b), () => C.removeEventListener(Ug, b);
      }, [b]),
      T.jsx(fU, {
        scope: n,
        orientation: r,
        dir: p,
        loop: i,
        currentTabStopId: m,
        onItemFocus: _.useCallback((C) => O(C), [O]),
        onItemShiftTab: _.useCallback(() => g(!0), []),
        onFocusableItemAdd: _.useCallback(() => y((C) => C + 1), []),
        onFocusableItemRemove: _.useCallback(() => y((C) => C - 1), []),
        children: T.jsx(qe.div, {
          tabIndex: v || w === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: f,
          style: { outline: "none", ...t.style },
          onMouseDown: Be(t.onMouseDown, () => {
            k.current = !0;
          }),
          onFocus: Be(t.onFocus, (C) => {
            const P = !k.current;
            if (C.target === C.currentTarget && P && !v) {
              const E = new CustomEvent(Ug, uU);
              if ((C.currentTarget.dispatchEvent(E), !E.defaultPrevented)) {
                const N = x().filter((W) => W.focusable),
                  L = N.find((W) => W.active),
                  D = N.find((W) => W.id === m),
                  R = [L, D, ...N].filter(Boolean).map((W) => W.ref.current);
                C$(R, u);
              }
            }
            k.current = !1;
          }),
          onBlur: Be(t.onBlur, () => g(!1)),
        }),
      })
    );
  }),
  S$ = "RovingFocusGroupItem",
  k$ = _.forwardRef((t, e) => {
    const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: o, ...s } = t,
      l = Ta(),
      a = o || l,
      c = pU(S$, n),
      u = c.currentTabStopId === a,
      h = y$(n),
      { onFocusableItemAdd: d, onFocusableItemRemove: f } = c;
    return (
      _.useEffect(() => {
        if (r) return d(), () => f();
      }, [r, d, f]),
      T.jsx(iO.ItemSlot, {
        scope: n,
        id: a,
        focusable: r,
        active: i,
        children: T.jsx(qe.span, {
          tabIndex: u ? 0 : -1,
          "data-orientation": c.orientation,
          ...s,
          ref: e,
          onMouseDown: Be(t.onMouseDown, (p) => {
            r ? c.onItemFocus(a) : p.preventDefault();
          }),
          onFocus: Be(t.onFocus, () => c.onItemFocus(a)),
          onKeyDown: Be(t.onKeyDown, (p) => {
            if (p.key === "Tab" && p.shiftKey) {
              c.onItemShiftTab();
              return;
            }
            if (p.target !== p.currentTarget) return;
            const m = vU(p, c.orientation, c.dir);
            if (m !== void 0) {
              if (p.metaKey || p.ctrlKey || p.altKey || p.shiftKey) return;
              p.preventDefault();
              let v = h()
                .filter((g) => g.focusable)
                .map((g) => g.ref.current);
              if (m === "last") v.reverse();
              else if (m === "prev" || m === "next") {
                m === "prev" && v.reverse();
                const g = v.indexOf(p.currentTarget);
                v = c.loop ? bU(v, g + 1) : v.slice(g + 1);
              }
              setTimeout(() => C$(v));
            }
          }),
        }),
      })
    );
  });
k$.displayName = S$;
var gU = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last",
};
function OU(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function vU(t, e, n) {
  const r = OU(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return gU[r];
}
function C$(t, e = !1) {
  const n = document.activeElement;
  for (const r of t) if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function bU(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var _$ = w$,
  Mx = k$,
  xU = "Separator",
  $C = "horizontal",
  yU = ["horizontal", "vertical"],
  E$ = _.forwardRef((t, e) => {
    const { decorative: n, orientation: r = $C, ...i } = t,
      o = wU(r) ? r : $C,
      l = n ? { role: "none" } : { "aria-orientation": o === "vertical" ? o : void 0, role: "separator" };
    return T.jsx(qe.div, { "data-orientation": o, ...l, ...i, ref: e });
  });
E$.displayName = xU;
function wU(t) {
  return yU.includes(t);
}
var SU = E$,
  kU = "Toggle",
  T$ = _.forwardRef((t, e) => {
    const { pressed: n, defaultPressed: r = !1, onPressedChange: i, ...o } = t,
      [s = !1, l] = Fo({ prop: n, onChange: i, defaultProp: r });
    return T.jsx(qe.button, {
      type: "button",
      "aria-pressed": s,
      "data-state": s ? "on" : "off",
      "data-disabled": t.disabled ? "" : void 0,
      ...o,
      ref: e,
      onClick: Be(t.onClick, () => {
        t.disabled || l(!s);
      }),
    });
  });
T$.displayName = kU;
var Ia = "ToggleGroup",
  [P$, A$] = Jo(Ia, [Nm]),
  $$ = Nm(),
  Lx = S.forwardRef((t, e) => {
    const { type: n, ...r } = t;
    if (n === "single") {
      const i = r;
      return T.jsx(CU, { ...i, ref: e });
    }
    if (n === "multiple") {
      const i = r;
      return T.jsx(_U, { ...i, ref: e });
    }
    throw new Error(`Missing prop \`type\` expected on \`${Ia}\``);
  });
Lx.displayName = Ia;
var [R$, I$] = P$(Ia),
  CU = S.forwardRef((t, e) => {
    const { value: n, defaultValue: r, onValueChange: i = () => {}, ...o } = t,
      [s, l] = Fo({ prop: n, defaultProp: r, onChange: i });
    return T.jsx(R$, {
      scope: t.__scopeToggleGroup,
      type: "single",
      value: s ? [s] : [],
      onItemActivate: l,
      onItemDeactivate: S.useCallback(() => l(""), [l]),
      children: T.jsx(M$, { ...o, ref: e }),
    });
  }),
  _U = S.forwardRef((t, e) => {
    const { value: n, defaultValue: r, onValueChange: i = () => {}, ...o } = t,
      [s = [], l] = Fo({ prop: n, defaultProp: r, onChange: i }),
      a = S.useCallback((u) => l((h = []) => [...h, u]), [l]),
      c = S.useCallback((u) => l((h = []) => h.filter((d) => d !== u)), [l]);
    return T.jsx(R$, {
      scope: t.__scopeToggleGroup,
      type: "multiple",
      value: s,
      onItemActivate: a,
      onItemDeactivate: c,
      children: T.jsx(M$, { ...o, ref: e }),
    });
  });
Lx.displayName = Ia;
var [EU, TU] = P$(Ia),
  M$ = S.forwardRef((t, e) => {
    const { __scopeToggleGroup: n, disabled: r = !1, rovingFocus: i = !0, orientation: o, dir: s, loop: l = !0, ...a } = t,
      c = $$(n),
      u = Mm(s),
      h = { role: "group", dir: u, ...a };
    return T.jsx(EU, {
      scope: n,
      rovingFocus: i,
      disabled: r,
      children: i
        ? T.jsx(_$, { asChild: !0, ...c, orientation: o, dir: u, loop: l, children: T.jsx(qe.div, { ...h, ref: e }) })
        : T.jsx(qe.div, { ...h, ref: e }),
    });
  }),
  Hf = "ToggleGroupItem",
  L$ = S.forwardRef((t, e) => {
    const n = I$(Hf, t.__scopeToggleGroup),
      r = TU(Hf, t.__scopeToggleGroup),
      i = $$(t.__scopeToggleGroup),
      o = n.value.includes(t.value),
      s = r.disabled || t.disabled,
      l = { ...t, pressed: o, disabled: s },
      a = S.useRef(null);
    return r.rovingFocus
      ? T.jsx(Mx, { asChild: !0, ...i, focusable: !s, active: o, ref: a, children: T.jsx(RC, { ...l, ref: e }) })
      : T.jsx(RC, { ...l, ref: e });
  });
L$.displayName = Hf;
var RC = S.forwardRef((t, e) => {
    const { __scopeToggleGroup: n, value: r, ...i } = t,
      o = I$(Hf, n),
      s = { role: "radio", "aria-checked": t.pressed, "aria-pressed": void 0 },
      l = o.type === "single" ? s : void 0;
    return T.jsx(T$, {
      ...l,
      ...i,
      ref: e,
      onPressedChange: (a) => {
        a ? o.onItemActivate(r) : o.onItemDeactivate(r);
      },
    });
  }),
  PU = Lx,
  AU = L$,
  Nx = "Toolbar",
  [$U, Nme] = Jo(Nx, [Nm, A$]),
  Qx = Nm(),
  N$ = A$(),
  [RU, Q$] = $U(Nx),
  D$ = _.forwardRef((t, e) => {
    const { __scopeToolbar: n, orientation: r = "horizontal", dir: i, loop: o = !0, ...s } = t,
      l = Qx(n),
      a = Mm(i);
    return T.jsx(RU, {
      scope: n,
      orientation: r,
      dir: a,
      children: T.jsx(_$, {
        asChild: !0,
        ...l,
        orientation: r,
        dir: a,
        loop: o,
        children: T.jsx(qe.div, { role: "toolbar", "aria-orientation": r, dir: a, ...s, ref: e }),
      }),
    });
  });
D$.displayName = Nx;
var F$ = "ToolbarSeparator",
  B$ = _.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = Q$(F$, n);
    return T.jsx(SU, { orientation: i.orientation === "horizontal" ? "vertical" : "horizontal", ...r, ref: e });
  });
B$.displayName = F$;
var IU = "ToolbarButton",
  Dx = _.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = Qx(n);
    return T.jsx(Mx, { asChild: !0, ...i, focusable: !t.disabled, children: T.jsx(qe.button, { type: "button", ...r, ref: e }) });
  });
Dx.displayName = IU;
var MU = "ToolbarLink",
  LU = _.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = Qx(n);
    return T.jsx(Mx, {
      asChild: !0,
      ...i,
      focusable: !0,
      children: T.jsx(qe.a, {
        ...r,
        ref: e,
        onKeyDown: Be(t.onKeyDown, (o) => {
          o.key === " " && o.currentTarget.click();
        }),
      }),
    });
  });
LU.displayName = MU;
var V$ = "ToolbarToggleGroup",
  j$ = _.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = Q$(V$, n),
      o = N$(n);
    return T.jsx(PU, { "data-orientation": i.orientation, dir: i.dir, ...o, ...r, ref: e, rovingFocus: !1 });
  });
j$.displayName = V$;
var NU = "ToolbarToggleItem",
  Z$ = _.forwardRef((t, e) => {
    const { __scopeToolbar: n, ...r } = t,
      i = N$(n),
      o = { __scopeToolbar: t.__scopeToolbar };
    return T.jsx(Dx, { asChild: !0, ...o, children: T.jsx(AU, { ...i, ...r, ref: e }) });
  });
Z$.displayName = NU;
var Fx = D$,
  z$ = B$,
  Fi = Dx,
  Qm = j$,
  Yd = Z$;
function Dm(t, e) {
  return t === null || t === e
    ? !1
    : t.dataset.editorDialog !== void 0 || t.dataset.toolbarItem !== void 0 || t.dataset.editorDropdown
    ? !0
    : Dm(t.parentElement, e);
}
function W$() {
  const t = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0")),
    e = crypto.getRandomValues(new Uint8Array(16));
  return (
    (e[6] = (e[6] & 15) | 64),
    (e[8] = (e[8] & 63) | 128),
    [...e.entries()].map(([n, r]) => ([4, 6, 8, 10].includes(n) ? `-${t[r]}` : t[r])).join("")
  );
}
const X$ = (t) => (t === 0 ? "th" : "td"),
  U$ = { center: F.centeredCell, left: F.leftAlignedCell, right: F.rightAlignedCell },
  QU = ({ mdastNode: t, parentEditor: e, lexicalTable: n }) => {
    const [r, i] = S.useState(null),
      [o, s] = Ye(st, Gt),
      l = S.useMemo(() => (m) => (m.__cacheKey || (m.__cacheKey = W$()), m.__cacheKey), []),
      a = S.useCallback(
        (m) => {
          const O = n.getColCount();
          if (m === null) {
            i(null);
            return;
          }
          let [v, g] = m;
          if ((v > O - 1 && ((v = 0), g++), v < 0 && ((v = O - 1), (g -= 1)), g > n.getRowCount() - 1)) {
            i(null),
              e.update(() => {
                if (n.getLatest().getNextSibling()) n.getLatest().selectNext();
                else {
                  const x = tt();
                  n.insertAfter(x), x.select();
                }
              });
            return;
          }
          if (g < 0) {
            i(null),
              e.update(() => {
                n.getLatest().selectPrevious();
              });
            return;
          }
          i([v, g]);
        },
        [n, e]
      );
    S.useEffect(() => {
      n.focusEmitter.subscribe(a);
    }, [n, a]);
    const c = S.useCallback(
        (m) => {
          m.preventDefault(),
            e.update(() => {
              n.addRowToBottom(), i([0, n.getRowCount()]);
            });
        },
        [e, n]
      ),
      u = S.useCallback(
        (m) => {
          m.preventDefault(),
            e.update(() => {
              n.addColumnToRight(), i([n.getColCount(), 0]);
            });
        },
        [e, n]
      ),
      [h, d] = S.useState([-1, -1]),
      f = S.useCallback((m) => {
        let O = m.target;
        for (; O && !["TH", "TD"].includes(O.tagName); ) {
          if (O === m.currentTarget) return;
          O = O.parentElement;
        }
        if (O === null) return;
        const v = O.parentElement,
          b = v.parentElement.tagName === "TFOOT" ? -1 : Array.from(v.children).indexOf(O),
          x = O.tagName === "TH" ? -1 : Array.from(v.parentElement.children).indexOf(v);
        d([b, x]);
      }, []),
      p = nt();
    return S.createElement(
      "table",
      {
        className: F.tableEditor,
        onMouseOver: f,
        onMouseLeave: () => {
          d([-1, -1]);
        },
      },
      S.createElement(
        "colgroup",
        null,
        s ? null : S.createElement("col", null),
        Array.from({ length: t.children[0].children.length }, (m, O) => {
          const g = (t.align ?? [])[O] ?? "left",
            b = U$[g];
          return S.createElement("col", { key: O, className: b });
        }),
        s ? null : S.createElement("col", null)
      ),
      s ||
        S.createElement(
          "thead",
          null,
          S.createElement(
            "tr",
            null,
            S.createElement("th", { className: F.tableToolsColumn }),
            Array.from({ length: t.children[0].children.length }, (m, O) =>
              S.createElement(
                "th",
                { key: O, "data-tool-cell": !0 },
                S.createElement(BU, {
                  setActiveCellWithBoundaries: a,
                  parentEditor: e,
                  colIndex: O,
                  highlightedCoordinates: h,
                  lexicalTable: n,
                  align: (t.align ?? [])[O],
                })
              )
            ),
            S.createElement(
              "th",
              { className: F.tableToolsColumn, "data-tool-cell": !0 },
              S.createElement(
                "button",
                {
                  className: F.iconButton,
                  type: "button",
                  title: p("table.deleteTable", "Delete table"),
                  onClick: (m) => {
                    m.preventDefault(),
                      e.update(() => {
                        n.selectNext(), n.remove();
                      });
                  },
                },
                o("delete_small")
              )
            )
          )
        ),
      S.createElement(
        "tbody",
        null,
        t.children.map((m, O) => {
          const v = X$(O);
          return S.createElement(
            "tr",
            { key: O },
            s ||
              S.createElement(
                v,
                { className: F.toolCell, "data-tool-cell": !0 },
                S.createElement(VU, {
                  setActiveCellWithBoundaries: a,
                  parentEditor: e,
                  rowIndex: O,
                  highlightedCoordinates: h,
                  lexicalTable: n,
                })
              ),
            m.children.map((g, b) => {
              var x;
              return S.createElement(DU, {
                align: (x = t.align) == null ? void 0 : x[b],
                key: l(g),
                contents: g.children,
                setActiveCell: a,
                rowIndex: O,
                colIndex: b,
                lexicalTable: n,
                parentEditor: e,
                activeCell: s ? [-1, -1] : r,
              });
            }),
            s ||
              (O === 0 &&
                S.createElement(
                  "th",
                  { rowSpan: n.getRowCount(), "data-tool-cell": !0 },
                  S.createElement("button", { type: "button", className: F.addColumnButton, onClick: u }, o("add_column"))
                ))
          );
        })
      ),
      s ||
        S.createElement(
          "tfoot",
          null,
          S.createElement(
            "tr",
            null,
            S.createElement("th", null),
            S.createElement(
              "th",
              { colSpan: n.getColCount() },
              S.createElement("button", { type: "button", className: F.addRowButton, onClick: c }, o("add_row"))
            ),
            S.createElement("th", null)
          )
        )
    );
  },
  DU = ({ align: t, ...e }) => {
    const { activeCell: n, setActiveCell: r } = e,
      i = !!(n && n[0] === e.colIndex && n[1] === e.rowIndex),
      o = U$[t ?? "left"],
      s = X$(e.rowIndex);
    return S.createElement(
      s,
      {
        className: o,
        "data-active": i,
        onClick: () => {
          r([e.colIndex, e.rowIndex]);
        },
      },
      S.createElement(FU, { ...e, focus: i })
    );
  },
  FU = ({ focus: t, setActiveCell: e, parentEditor: n, lexicalTable: r, contents: i, colIndex: o, rowIndex: s }) => {
    const [l, a, c, u, h, d, f, p] = Ye(rh, oh, ih, Io, Es, Us, sh, Un),
      [m] = S.useState(() => {
        const v = Lb({ nodes: c, theme: Om });
        return (
          v.update(() => {
            gm({
              root: Qe(),
              mdastRoot: { type: "root", children: [{ type: "paragraph", children: i }] },
              visitors: l,
              jsxComponentDescriptors: u,
              directiveDescriptors: h,
              codeBlockEditorDescriptors: d,
            });
          }),
          v
        );
      }),
      O = S.useCallback(
        (v) => {
          m.getEditorState().read(() => {
            const g = mm({ root: Qe(), jsxComponentDescriptors: u, visitors: a, jsxIsAvailable: f });
            n.update(
              () => {
                r.updateCellContents(o, s, g.children[0].children);
              },
              { discrete: !0 }
            ),
              n.dispatchCommand(Ro, void 0);
          }),
            e(v);
        },
        [o, m, a, u, f, r, n, s, e]
      );
    return (
      S.useEffect(
        () =>
          Xn(
            m.registerCommand(
              sb,
              (v) => {
                v.preventDefault();
                const g = v.shiftKey ? [o - 1, s] : [o + 1, s];
                return O(g), !0;
              },
              Bn
            ),
            m.registerCommand(hb, () => (e([o, s]), !1), ht),
            m.registerCommand(
              Wl,
              (v) => {
                v == null || v.preventDefault();
                const g = v != null && v.shiftKey ? [o, s - 1] : [o, s + 1];
                return O(g), !0;
              },
              Bn
            ),
            m.registerCommand(
              Gp,
              (v) => {
                const g = v.relatedTarget;
                return Dm(g, p.getRootElement()) ? !1 : (O(null), !0);
              },
              Bn
            ),
            m.registerCommand(Ro, () => (O(null), !0), Bn)
          ),
        [o, m, p, s, O, e]
      ),
      S.useEffect(() => {
        t && m.focus();
      }, [t, m]),
      S.createElement(
        $A,
        { initialEditor: m },
        S.createElement(fx, { contentEditable: S.createElement(hx, null), placeholder: S.createElement("div", null), ErrorBoundary: dx }),
        S.createElement(aP, null)
      )
    );
  },
  BU = ({ parentEditor: t, highlightedCoordinates: e, align: n, lexicalTable: r, colIndex: i, setActiveCellWithBoundaries: o }) => {
    const [s, l] = Ye(jr, st),
      a = S.useCallback(
        (d) => {
          t.update(() => {
            r.insertColumnAt(d);
          }),
            o([d, 0]);
        },
        [t, r, o]
      ),
      c = S.useCallback(
        (d) => {
          t.update(() => {
            r.deleteColumnAt(d);
          });
        },
        [t, r]
      ),
      u = S.useCallback(
        (d, f) => {
          t.update(() => {
            r.setColumnAlign(d, f);
          });
        },
        [t, r]
      ),
      h = nt();
    return S.createElement(
      $m,
      null,
      S.createElement(
        Pm,
        { className: F.tableColumnEditorTrigger, "data-active": e[0] === i + 1, title: h("table.columnMenu", "Column menu") },
        l("more_horiz")
      ),
      S.createElement(
        Rm,
        { container: s == null ? void 0 : s.current },
        S.createElement(
          Am,
          {
            className: Fe(F.tableColumnEditorPopoverContent),
            onOpenAutoFocus: (d) => {
              d.preventDefault();
            },
            sideOffset: 5,
            side: "top",
          },
          S.createElement(
            Fx,
            { className: F.tableColumnEditorToolbar },
            S.createElement(
              Qm,
              {
                className: F.toggleGroupRoot,
                onValueChange: (d) => {
                  u(i, d);
                },
                value: n ?? "left",
                type: "single",
                "aria-label": h("table.textAlignment", "Text alignment"),
              },
              S.createElement(Yd, { value: "left", title: h("table.alignLeft", "Align left") }, l("format_align_left")),
              S.createElement(Yd, { value: "center", title: h("table.alignCenter", "Align center") }, l("format_align_center")),
              S.createElement(Yd, { value: "right", title: h("table.alignRight", "Align right") }, l("format_align_right"))
            ),
            S.createElement(z$, null),
            S.createElement(
              Fi,
              { onClick: a.bind(null, i), title: h("table.insertColumnLeft", "Insert a column to the left of this one") },
              l("insert_col_left")
            ),
            S.createElement(
              Fi,
              { onClick: a.bind(null, i + 1), title: h("table.insertColumnRight", "Insert a column to the right of this one") },
              l("insert_col_right")
            ),
            S.createElement(Fi, { onClick: c.bind(null, i), title: h("table.deleteColumn", "Delete this column") }, l("delete_small"))
          ),
          S.createElement(Im, { className: F.popoverArrow })
        )
      )
    );
  },
  VU = ({ parentEditor: t, highlightedCoordinates: e, lexicalTable: n, rowIndex: r, setActiveCellWithBoundaries: i }) => {
    const [o, s] = Ye(jr, st),
      l = S.useCallback(
        (u) => {
          t.update(() => {
            n.insertRowAt(u);
          }),
            i([0, u]);
        },
        [t, n, i]
      ),
      a = S.useCallback(
        (u) => {
          t.update(() => {
            n.deleteRowAt(u);
          });
        },
        [t, n]
      ),
      c = nt();
    return S.createElement(
      $m,
      null,
      S.createElement(
        Pm,
        { className: F.tableColumnEditorTrigger, "data-active": e[1] === r, title: c("table.rowMenu", "Row menu") },
        s("more_horiz")
      ),
      S.createElement(
        Rm,
        { container: o == null ? void 0 : o.current },
        S.createElement(
          Am,
          {
            className: Fe(F.tableColumnEditorPopoverContent),
            onOpenAutoFocus: (u) => {
              u.preventDefault();
            },
            sideOffset: 5,
            side: "bottom",
          },
          S.createElement(
            Fx,
            { className: F.tableColumnEditorToolbar },
            S.createElement(
              Fi,
              { onClick: l.bind(null, r), title: c("table.insertRowAbove", "Insert a row above this one") },
              s("insert_row_above")
            ),
            S.createElement(
              Fi,
              { onClick: l.bind(null, r + 1), title: c("table.insertRowBelow", "Insert a row below this one") },
              s("insert_row_below")
            ),
            S.createElement(Fi, { onClick: a.bind(null, r), title: c("table.deleteRow", "Delete this row") }, s("delete_small"))
          ),
          S.createElement(Im, { className: F.popoverArrow })
        )
      )
    );
  };
var jU = Object.defineProperty,
  ZU = (t, e, n) => (e in t ? jU(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  IC = (t, e, n) => (ZU(t, typeof e != "symbol" ? e + "" : e, n), n);
const MC = { type: "tableCell", children: [] };
function zU() {
  let t = Co;
  return {
    publish: (e) => {
      t(e);
    },
    subscribe: (e) => {
      t = e;
    },
  };
}
class Ma extends wi {
  constructor(e, n) {
    super(n), IC(this, "__mdastNode"), IC(this, "focusEmitter", zU()), (this.__mdastNode = e ?? { type: "table", children: [] });
  }
  static getType() {
    return "table";
  }
  static clone(e) {
    return new Ma(structuredClone(e.__mdastNode), e.__key);
  }
  static importJSON(e) {
    return Fm(e.mdastNode);
  }
  exportJSON() {
    return { mdastNode: structuredClone(this.__mdastNode), type: "table", version: 1 };
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  getRowCount() {
    return this.__mdastNode.children.length;
  }
  getColCount() {
    var e;
    return ((e = this.__mdastNode.children[0]) == null ? void 0 : e.children.length) || 0;
  }
  createDOM() {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  updateCellContents(e, n, r) {
    const o = this.getWritable().__mdastNode,
      s = o.children[n],
      l = s.children,
      a = l[e],
      c = Array.from(l),
      u = { ...a, children: r },
      h = { ...s, children: c };
    (c[e] = u), (o.children[n] = h);
  }
  insertColumnAt(e) {
    const r = this.getWritable().__mdastNode;
    for (let i = 0; i < r.children.length; i++) {
      const o = r.children[i],
        s = o.children,
        l = Array.from(s),
        a = { ...o, children: l };
      l.splice(e, 0, structuredClone(MC)), (r.children[i] = a);
    }
    r.align && r.align.length > 0 && r.align.splice(e, 0, "left");
  }
  deleteColumnAt(e) {
    const r = this.getWritable().__mdastNode;
    for (let i = 0; i < r.children.length; i++) {
      const o = r.children[i],
        s = o.children,
        l = Array.from(s),
        a = { ...o, children: l };
      l.splice(e, 1), (r.children[i] = a);
    }
  }
  insertRowAt(e) {
    const r = this.getWritable().__mdastNode,
      i = { type: "tableRow", children: Array.from({ length: this.getColCount() }, () => structuredClone(MC)) };
    r.children.splice(e, 0, i);
  }
  deleteRowAt(e) {
    this.getRowCount() === 1 ? (this.selectNext(), this.remove()) : this.getWritable().__mdastNode.children.splice(e, 1);
  }
  addRowToBottom() {
    this.insertRowAt(this.getRowCount());
  }
  addColumnToRight() {
    this.insertColumnAt(this.getColCount());
  }
  setColumnAlign(e, n) {
    const i = this.getWritable().__mdastNode;
    i.align == null && (i.align = []), (i.align[e] = n);
  }
  decorate(e) {
    return S.createElement(QU, { lexicalTable: this, mdastNode: this.__mdastNode, parentEditor: e });
  }
  select(e) {
    this.focusEmitter.publish(e ?? [0, 0]);
  }
  isInline() {
    return !1;
  }
}
function H$(t) {
  return t instanceof Ma;
}
function Fm(t) {
  return new Ma(t);
}
const WU = {
    testLexicalNode: H$,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      t.appendToParent(e, n.getMdastNode());
    },
  },
  XU = {
    testNode: "table",
    visitNode({ mdastNode: t, lexicalParent: e }) {
      e.append(Fm(t));
    },
  };
function UU(t = 1, e = 1) {
  const n = { type: "table", children: [] };
  for (let r = 0; r < t; r++) {
    const i = { type: "tableRow", children: [] };
    for (let o = 0; o < e; o++) {
      const s = { type: "tableCell", children: [] };
      i.children.push(s);
    }
    n.children.push(i);
  }
  return n;
}
const Bx = kt((t) => {
    t.link(
      t.pipe(
        Bx,
        mr(
          ({ rows: e, columns: n }) =>
            () =>
              Fm(UU(e, n))
        )
      ),
      _a
    );
  }),
  HU = Ut({
    init(t) {
      t.pubIn({ [Lo]: jz(), [Mo]: Jz(), [Wn]: XU, [ar]: Ma, [cr]: WU, [Hs]: Hz({ tableCellPadding: !0, tablePipeAlign: !0 }) });
    },
  }),
  qU = new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
let La = class q$ extends Vr {
  static getType() {
    return "link";
  }
  static clone(e) {
    return new q$(e.__url, { rel: e.__rel, target: e.__target, title: e.__title }, e.__key);
  }
  constructor(e, n = {}, r) {
    super(r);
    const { target: i = null, rel: o = null, title: s = null } = n;
    (this.__url = e), (this.__target = i), (this.__rel = o), (this.__title = s);
  }
  createDOM(e) {
    const n = document.createElement("a");
    return (
      (n.href = this.sanitizeUrl(this.__url)),
      this.__target !== null && (n.target = this.__target),
      this.__rel !== null && (n.rel = this.__rel),
      this.__title !== null && (n.title = this.__title),
      Rr(n, e.theme.link),
      n
    );
  }
  updateDOM(e, n, r) {
    if (n instanceof HTMLAnchorElement) {
      const i = this.__url,
        o = this.__target,
        s = this.__rel,
        l = this.__title;
      i !== e.__url && (n.href = i),
        o !== e.__target && (o ? (n.target = o) : n.removeAttribute("target")),
        s !== e.__rel && (s ? (n.rel = s) : n.removeAttribute("rel")),
        l !== e.__title && (l ? (n.title = l) : n.removeAttribute("title"));
    }
    return !1;
  }
  static importDOM() {
    return { a: (e) => ({ conversion: YU, priority: 1 }) };
  }
  static importJSON(e) {
    const n = $s(e.url, { rel: e.rel, target: e.target, title: e.title });
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  sanitizeUrl(e) {
    try {
      const n = new URL(e);
      if (!qU.has(n.protocol)) return "about:blank";
    } catch {
      return e;
    }
    return e;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      rel: this.getRel(),
      target: this.getTarget(),
      title: this.getTitle(),
      type: "link",
      url: this.getURL(),
      version: 1,
    };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(e) {
    this.getWritable().__url = e;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(e) {
    this.getWritable().__target = e;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(e) {
    this.getWritable().__rel = e;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(e) {
    this.getWritable().__title = e;
  }
  insertNewAfter(e, n = !0) {
    const r = $s(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!ee(n)) return !1;
    const i = n.anchor.getNode(),
      o = n.focus.getNode();
    return this.isParentOf(i) && this.isParentOf(o) && n.getTextContent().length > 0;
  }
};
function YU(t) {
  let e = null;
  if (BL(t)) {
    const n = t.textContent;
    ((n !== null && n !== "") || t.children.length > 0) &&
      (e = $s(t.getAttribute("href") || "", {
        rel: t.getAttribute("rel"),
        target: t.getAttribute("target"),
        title: t.getAttribute("title"),
      }));
  }
  return { node: e };
}
function $s(t, e) {
  return Mn(new La(t, e));
}
function ni(t) {
  return t instanceof La;
}
let Bm = class Y$ extends La {
  constructor(e, n = {}, r) {
    super(e, n, r), (this.__isUnlinked = n.isUnlinked !== void 0 && n.isUnlinked !== null && n.isUnlinked);
  }
  static getType() {
    return "autolink";
  }
  static clone(e) {
    return new Y$(e.__url, { isUnlinked: e.__isUnlinked, rel: e.__rel, target: e.__target, title: e.__title }, e.__key);
  }
  getIsUnlinked() {
    return this.__isUnlinked;
  }
  setIsUnlinked(e) {
    const n = this.getWritable();
    return (n.__isUnlinked = e), n;
  }
  createDOM(e) {
    return this.__isUnlinked ? document.createElement("span") : super.createDOM(e);
  }
  updateDOM(e, n, r) {
    return super.updateDOM(e, n, r) || e.__isUnlinked !== this.__isUnlinked;
  }
  static importJSON(e) {
    const n = oO(e.url, { isUnlinked: e.isUnlinked, rel: e.rel, target: e.target, title: e.title });
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return { ...super.exportJSON(), isUnlinked: this.__isUnlinked, type: "autolink", version: 1 };
  }
  insertNewAfter(e, n = !0) {
    const r = this.getParentOrThrow().insertNewAfter(e, n);
    if (X(r)) {
      const i = oO(this.__url, { isUnlinked: this.__isUnlinked, rel: this.__rel, target: this.__target, title: this.__title });
      return r.append(i), i;
    }
    return null;
  }
};
function oO(t, e) {
  return Mn(new Bm(t, e));
}
function ul(t) {
  return t instanceof Bm;
}
const Kl = Ji();
function Hg(t, e = {}) {
  const { target: n, title: r } = e,
    i = e.rel === void 0 ? "noreferrer" : e.rel,
    o = ae();
  if (!ee(o)) return;
  const s = o.extract();
  if (t === null)
    s.forEach((l) => {
      const a = l.getParent();
      if (!ul(a) && ni(a)) {
        const c = a.getChildren();
        for (let u = 0; u < c.length; u++) a.insertBefore(c[u]);
        a.remove();
      }
    });
  else {
    if (s.length === 1) {
      const c = (function (u, h) {
        let d = u;
        for (; d !== null && d.getParent() !== null && !h(d); ) d = d.getParentOrThrow();
        return h(d) ? d : null;
      })(s[0], ni);
      if (c !== null) return c.setURL(t), n !== void 0 && c.setTarget(n), i !== null && c.setRel(i), void (r !== void 0 && c.setTitle(r));
    }
    let l = null,
      a = null;
    s.forEach((c) => {
      const u = c.getParent();
      if (u !== a && u !== null && (!X(c) || c.isInline())) {
        if (ni(u))
          return (a = u), u.setURL(t), n !== void 0 && u.setTarget(n), i !== null && a.setRel(i), void (r !== void 0 && a.setTitle(r));
        if (
          (u.is(l) ||
            ((l = u),
            (a = $s(t, { rel: i, target: n, title: r })),
            ni(u) ? (c.getPreviousSibling() === null ? u.insertBefore(a) : u.insertAfter(a)) : c.insertBefore(a)),
          ni(c))
        ) {
          if (c.is(a)) return;
          if (a !== null) {
            const h = c.getChildren();
            for (let d = 0; d < h.length; d++) a.append(h[d]);
          }
          c.remove();
        } else a !== null && a.append(c);
      }
    });
  }
}
const GU = {
    testNode: "link",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto($s(t.url, { title: t.title }));
    },
  },
  JU = {
    testLexicalNode: ni,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      e.addAndStepInto("link", { url: t.getURL(), title: t.getTitle() });
    },
  };
function KU({ validateUrl: t }) {
  const [e] = In();
  return (
    _.useEffect(() => {
      if (!e.hasNodes([La])) throw new Error("LinkPlugin: LinkNode not registered on editor");
      return Xn(
        e.registerCommand(
          Kl,
          (n) => {
            if (n === null) return Hg(n), !0;
            if (typeof n == "string") return !(t !== void 0 && !t(n)) && (Hg(n), !0);
            {
              const { url: r, target: i, rel: o, title: s } = n;
              return Hg(r, { rel: o, target: i, title: s }), !0;
            }
          },
          ht
        ),
        t !== void 0
          ? e.registerCommand(
              Wu,
              (n) => {
                const r = ae();
                if (!ee(r) || r.isCollapsed() || !bo(n, ClipboardEvent)) return !1;
                const i = n;
                if (i.clipboardData === null) return !1;
                const o = i.clipboardData.getData("text");
                return !!t(o) && !r.getNodes().some((s) => X(s)) && (e.dispatchCommand(Kl, o), n.preventDefault(), !0);
              },
              ht
            )
          : () => {}
      );
    }, [e, t]),
    null
  );
}
function eH(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var tH = eH(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function LC(t, e = (n) => n) {
  return (n) => {
    const r = t.exec(n);
    return r === null ? null : { index: r.index, length: r[0].length, text: r[0], url: e(r[0]) };
  };
}
function G$(t, e) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n](t);
    if (r) return r;
  }
  return null;
}
const nH = /[.,;\s]/;
function qf(t) {
  return nH.test(t);
}
function J$(t) {
  return qf(t[t.length - 1]);
}
function sO(t) {
  return qf(t[0]);
}
function K$(t) {
  let e = t.getPreviousSibling();
  return X(e) && (e = e.getLastDescendant()), e === null || Ar(e) || (te(e) && J$(e.getTextContent()));
}
function e3(t) {
  let e = t.getNextSibling();
  return X(e) && (e = e.getFirstDescendant()), e === null || Ar(e) || (te(e) && sO(e.getTextContent()));
}
function rH(t, e, n, r) {
  return (t > 0 ? qf(n[t - 1]) : K$(r[0])) ? (e < n.length ? qf(n[e]) : e3(r[r.length - 1])) : !1;
}
function iH(t, e, n) {
  const r = [],
    i = [],
    o = [];
  let s = 0,
    l = 0;
  const a = [...t];
  for (; a.length > 0; ) {
    const c = a[0],
      u = c.getTextContent().length,
      h = l;
    l + u <= e ? (r.push(c), (s += u)) : h >= n ? o.push(c) : i.push(c), (l += u), a.shift();
  }
  return [s, r, i, o];
}
function oH(t, e, n, r) {
  const i = oO(r.url, r.attributes);
  if (t.length === 1) {
    let o,
      s = t[0];
    e === 0 ? ([o, s] = s.splitText(n)) : ([, o, s] = s.splitText(e, n));
    const l = yt(r.text);
    return l.setFormat(o.getFormat()), l.setDetail(o.getDetail()), l.setStyle(o.getStyle()), i.append(l), o.replace(i), s;
  }
  if (t.length > 1) {
    const o = t[0];
    let s,
      l = o.getTextContent().length;
    e === 0 ? (s = o) : ([, s] = o.splitText(e));
    const a = [];
    let c;
    for (let f = 1; f < t.length; f++) {
      const p = t[f],
        m = p.getTextContent().length,
        O = l;
      if (O < n)
        if (l + m <= n) a.push(p);
        else {
          const [v, g] = p.splitText(n - O);
          a.push(v), (c = g);
        }
      l += m;
    }
    const u = ae(),
      h = u ? u.getNodes().find(te) : void 0,
      d = yt(s.getTextContent());
    return (
      d.setFormat(s.getFormat()),
      d.setDetail(s.getDetail()),
      d.setStyle(s.getStyle()),
      i.append(d, ...a),
      h && h === s && (ee(u) ? d.select(u.anchor.offset, u.focus.offset) : Vt(u) && d.select(0, d.getTextContent().length)),
      s.replace(i),
      c
    );
  }
}
function qg(t, e, n) {
  const r = t.getChildren(),
    i = r.length;
  for (let a = 0; a < i; a++) {
    const c = r[a];
    if (!te(c) || !c.isSimpleText()) return Gd(t), void n(null, t.getURL());
  }
  const o = t.getTextContent(),
    s = G$(o, e);
  if (s === null || s.text !== o || !K$(t) || !e3(t)) return Gd(t), void n(null, t.getURL());
  const l = t.getURL();
  if ((l !== s.url && (t.setURL(s.url), n(s.url, l)), s.attributes)) {
    const a = t.getRel();
    a !== s.attributes.rel && (t.setRel(s.attributes.rel || null), n(s.attributes.rel || null, a));
    const c = t.getTarget();
    c !== s.attributes.target && (t.setTarget(s.attributes.target || null), n(s.attributes.target || null, c));
  }
}
function Gd(t) {
  const e = t.getChildren();
  for (let n = e.length - 1; n >= 0; n--) t.insertAfter(e[n]);
  return t.remove(), e.map((n) => n.getLatest());
}
function sH(t, e, n) {
  _.useEffect(() => {
    t.hasNodes([Bm]) || tH(77);
    const r = (i, o) => {
      n && n(i, o);
    };
    return Xn(
      t.registerNodeTransform(Ki, (i) => {
        const o = i.getParentOrThrow(),
          s = i.getPreviousSibling();
        if (ul(o) && !o.getIsUnlinked()) qg(o, e, r);
        else if (!ni(o)) {
          if (i.isSimpleText() && (sO(i.getTextContent()) || !ul(s))) {
            const l = (function (a) {
              const c = [a];
              let u = a.getNextSibling();
              for (; u !== null && te(u) && u.isSimpleText() && (c.push(u), !/[\s]/.test(u.getTextContent())); ) u = u.getNextSibling();
              return c;
            })(i);
            (function (a, c, u) {
              let h = [...a];
              const d = h.map((O) => O.getTextContent()).join("");
              let f,
                p = d,
                m = 0;
              for (; (f = G$(p, c)) && f !== null; ) {
                const O = f.index,
                  v = O + f.length;
                if (rH(m + O, m + v, d, h)) {
                  const [g, , b, x] = iH(h, m + O, m + v),
                    k = oH(b, m + O - g, m + v - g, f);
                  (h = k ? [k, ...x] : x), u(f.url, null), (m = 0);
                } else m += v;
                p = p.substring(v);
              }
            })(l, e, r);
          }
          (function (l, a, c) {
            const u = l.getPreviousSibling(),
              h = l.getNextSibling(),
              d = l.getTextContent();
            !ul(u) || u.getIsUnlinked() || (sO(d) && !/^\.[a-zA-Z0-9]{1,}/.test(d)) || (u.append(l), qg(u, a, c), c(null, u.getURL())),
              !ul(h) || h.getIsUnlinked() || J$(d) || (Gd(h), qg(h, a, c), c(null, h.getURL()));
          })(i, e, r);
        }
      }),
      t.registerCommand(
        Kl,
        (i) => {
          const o = ae();
          return (
            i !== null ||
              !ee(o) ||
              o.extract().forEach((s) => {
                const l = s.getParent();
                if (ul(l)) return l.setIsUnlinked(!l.getIsUnlinked()), l.markDirty(), !0;
              }),
            !1
          );
        },
        ht
      )
    );
  }, [t, e, n]);
}
function lH({ matchers: t, onChange: e }) {
  const [n] = In();
  return sH(n, t, e), null;
}
const aH = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/,
  cH =
    /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/,
  uH = [LC(aH, (t) => (t.startsWith("http") ? t : `https://${t}`)), LC(cH, (t) => `mailto:${t}`)],
  hH = () => S.createElement(lH, { matchers: uH }),
  t3 = we(!1),
  dH = Ut({
    init(t, e) {
      const n = !!(e != null && e.disableAutoLink),
        r = e != null && e.validateUrl ? { validateUrl: e.validateUrl } : {};
      t.pubIn({
        [Ea]: "link",
        [Wn]: GU,
        [ar]: [La, Bm],
        [cr]: JU,
        [t3]: n,
        [qo]: () => S.createElement(S.Fragment, null, S.createElement(KU, { ...r }), n ? null : S.createElement(hH, null)),
      });
    },
  });
function vc(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r)) {
      if (e.indexOf(r) >= 0) continue;
      n[r] = t[r];
    }
  return n;
}
function _t() {
  return (
    (_t = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    _t.apply(null, arguments)
  );
}
var bt = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Vm = 60103,
  jm = 60106,
  fh = 60107,
  ph = 60108,
  mh = 60114,
  gh = 60109,
  Oh = 60110,
  vh = 60112,
  bh = 60113,
  Vx = 60120,
  xh = 60115,
  yh = 60116,
  n3 = 60121,
  r3 = 60122,
  i3 = 60117,
  o3 = 60129,
  s3 = 60131;
if (typeof Symbol == "function" && Symbol.for) {
  var on = Symbol.for;
  (Vm = on("react.element")),
    (jm = on("react.portal")),
    (fh = on("react.fragment")),
    (ph = on("react.strict_mode")),
    (mh = on("react.profiler")),
    (gh = on("react.provider")),
    (Oh = on("react.context")),
    (vh = on("react.forward_ref")),
    (bh = on("react.suspense")),
    (Vx = on("react.suspense_list")),
    (xh = on("react.memo")),
    (yh = on("react.lazy")),
    (n3 = on("react.block")),
    (r3 = on("react.server.block")),
    (i3 = on("react.fundamental")),
    (o3 = on("react.debug_trace_mode")),
    (s3 = on("react.legacy_hidden"));
}
function Zr(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case Vm:
        switch (((t = t.type), t)) {
          case fh:
          case mh:
          case ph:
          case bh:
          case Vx:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case Oh:
              case vh:
              case yh:
              case xh:
              case gh:
                return t;
              default:
                return e;
            }
        }
      case jm:
        return e;
    }
  }
}
var fH = gh,
  pH = Vm,
  mH = vh,
  gH = fh,
  OH = yh,
  vH = xh,
  bH = jm,
  xH = mh,
  yH = ph,
  wH = bh;
bt.ContextConsumer = Oh;
bt.ContextProvider = fH;
bt.Element = pH;
bt.ForwardRef = mH;
bt.Fragment = gH;
bt.Lazy = OH;
bt.Memo = vH;
bt.Portal = bH;
bt.Profiler = xH;
bt.StrictMode = yH;
bt.Suspense = wH;
bt.isAsyncMode = function () {
  return !1;
};
bt.isConcurrentMode = function () {
  return !1;
};
bt.isContextConsumer = function (t) {
  return Zr(t) === Oh;
};
bt.isContextProvider = function (t) {
  return Zr(t) === gh;
};
bt.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === Vm;
};
bt.isForwardRef = function (t) {
  return Zr(t) === vh;
};
bt.isFragment = function (t) {
  return Zr(t) === fh;
};
bt.isLazy = function (t) {
  return Zr(t) === yh;
};
bt.isMemo = function (t) {
  return Zr(t) === xh;
};
bt.isPortal = function (t) {
  return Zr(t) === jm;
};
bt.isProfiler = function (t) {
  return Zr(t) === mh;
};
bt.isStrictMode = function (t) {
  return Zr(t) === ph;
};
bt.isSuspense = function (t) {
  return Zr(t) === bh;
};
bt.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === fh ||
    t === mh ||
    t === o3 ||
    t === ph ||
    t === bh ||
    t === Vx ||
    t === s3 ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === yh ||
        t.$$typeof === xh ||
        t.$$typeof === gh ||
        t.$$typeof === Oh ||
        t.$$typeof === vh ||
        t.$$typeof === i3 ||
        t.$$typeof === n3 ||
        t[0] === r3))
  );
};
bt.typeOf = Zr;
let NC = (t) => typeof t == "object" && t != null && t.nodeType === 1,
  QC = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip",
  Yg = (t, e) => {
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
      let n = getComputedStyle(t, null);
      return (
        QC(n.overflowY, e) ||
        QC(n.overflowX, e) ||
        ((r) => {
          let i = ((o) => {
            if (!o.ownerDocument || !o.ownerDocument.defaultView) return null;
            try {
              return o.ownerDocument.defaultView.frameElement;
            } catch {
              return null;
            }
          })(r);
          return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth);
        })(t)
      );
    }
    return !1;
  },
  ed = (t, e, n, r, i, o, s, l) =>
    (o < t && s > e) || (o > t && s < e)
      ? 0
      : (o <= t && l <= n) || (s >= e && l >= n)
      ? o - t - r
      : (s > e && l < n) || (o < t && l > n)
      ? s - e + i
      : 0,
  SH = (t) => {
    let e = t.parentElement;
    return e ?? (t.getRootNode().host || null);
  };
var kH = (t, e) => {
    var n, r, i, o, s, l;
    if (typeof document > "u") return [];
    let { scrollMode: a, block: c, inline: u, boundary: h, skipOverflowHiddenElements: d } = e,
      f = typeof h == "function" ? h : (Q) => Q !== h;
    if (!NC(t)) throw new TypeError("Invalid target");
    let p = document.scrollingElement || document.documentElement,
      m = [],
      O = t;
    for (; NC(O) && f(O); ) {
      if (((O = SH(O)), O === p)) {
        m.push(O);
        break;
      }
      (O != null && O === document.body && Yg(O) && !Yg(document.documentElement)) || (O != null && Yg(O, d) && m.push(O));
    }
    let v = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth,
      g = (o = (i = window.visualViewport) == null ? void 0 : i.height) != null ? o : innerHeight,
      b = (s = window.scrollX) != null ? s : pageXOffset,
      x = (l = window.scrollY) != null ? l : pageYOffset,
      { height: k, width: w, top: y, right: C, bottom: P, left: E } = t.getBoundingClientRect(),
      N = c === "start" || c === "nearest" ? y : c === "end" ? P : y + k / 2,
      L = u === "center" ? E + w / 2 : u === "end" ? C : E,
      D = [];
    for (let Q = 0; Q < m.length; Q++) {
      let R = m[Q],
        { height: W, width: B, top: K, right: ne, bottom: A, left: V } = R.getBoundingClientRect();
      if (a === "if-needed" && y >= 0 && E >= 0 && P <= g && C <= v && y >= K && P <= A && E >= V && C <= ne) return D;
      let ie = getComputedStyle(R),
        M = parseInt(ie.borderLeftWidth, 10),
        fe = parseInt(ie.borderTopWidth, 10),
        Se = parseInt(ie.borderRightWidth, 10),
        pe = parseInt(ie.borderBottomWidth, 10),
        Y = 0,
        q = 0,
        oe = "offsetWidth" in R ? R.offsetWidth - R.clientWidth - M - Se : 0,
        ce = "offsetHeight" in R ? R.offsetHeight - R.clientHeight - fe - pe : 0,
        Oe = "offsetWidth" in R ? (R.offsetWidth === 0 ? 0 : B / R.offsetWidth) : 0,
        _e = "offsetHeight" in R ? (R.offsetHeight === 0 ? 0 : W / R.offsetHeight) : 0;
      if (p === R)
        (Y = c === "start" ? N : c === "end" ? N - g : c === "nearest" ? ed(x, x + g, g, fe, pe, x + N, x + N + k, k) : N - g / 2),
          (q = u === "start" ? L : u === "center" ? L - v / 2 : u === "end" ? L - v : ed(b, b + v, v, M, Se, b + L, b + L + w, w)),
          (Y = Math.max(0, Y + x)),
          (q = Math.max(0, q + b));
      else {
        (Y =
          c === "start"
            ? N - K - fe
            : c === "end"
            ? N - A + pe + ce
            : c === "nearest"
            ? ed(K, A, W, fe, pe + ce, N, N + k, k)
            : N - (K + W / 2) + ce / 2),
          (q =
            u === "start"
              ? L - V - M
              : u === "center"
              ? L - (V + B / 2) + oe / 2
              : u === "end"
              ? L - ne + Se + oe
              : ed(V, ne, B, M, Se + oe, L, L + w, w));
        let { scrollLeft: Le, scrollTop: Ge } = R;
        (Y = Math.max(0, Math.min(Ge + Y / _e, R.scrollHeight - W / _e + ce))),
          (q = Math.max(0, Math.min(Le + q / Oe, R.scrollWidth - B / Oe + oe))),
          (N += Ge - Y),
          (L += Le - q);
      }
      D.push({ el: R, top: Y, left: q });
    }
    return D;
  },
  CH = 0;
function jx() {}
function _H(t, e) {
  if (t) {
    var n = kH(t, { boundary: e, block: "nearest", scrollMode: "if-needed" });
    n.forEach(function (r) {
      var i = r.el,
        o = r.top,
        s = r.left;
      (i.scrollTop = o), (i.scrollLeft = s);
    });
  }
}
function DC(t, e, n) {
  var r = t === e || (e instanceof n.Node && t.contains && t.contains(e));
  return r;
}
function l3(t, e) {
  var n;
  function r() {
    n && clearTimeout(n);
  }
  function i() {
    for (var o = arguments.length, s = new Array(o), l = 0; l < o; l++) s[l] = arguments[l];
    r(),
      (n = setTimeout(function () {
        (n = null), t.apply(void 0, s);
      }, e));
  }
  return (i.cancel = r), i;
}
function Pi() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
  return function (r) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) o[s - 1] = arguments[s];
    return e.some(function (l) {
      return (
        l && l.apply(void 0, [r].concat(o)),
        r.preventDownshiftDefault || (r.hasOwnProperty("nativeEvent") && r.nativeEvent.preventDownshiftDefault)
      );
    });
  };
}
function td() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
  return function (r) {
    e.forEach(function (i) {
      typeof i == "function" ? i(r) : i && (i.current = r);
    });
  };
}
function EH() {
  return String(CH++);
}
function TH(t) {
  var e = t.isOpen,
    n = t.resultCount,
    r = t.previousResultCount;
  return e
    ? n
      ? n !== r
        ? n + " result" + (n === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select."
        : ""
      : "No results are available."
    : "";
}
function lO(t, e) {
  return Object.keys(t).reduce(function (n, r) {
    return (n[r] = a3(e, r) ? e[r] : t[r]), n;
  }, {});
}
function a3(t, e) {
  return t[e] !== void 0;
}
function PH(t) {
  var e = t.key,
    n = t.keyCode;
  return n >= 37 && n <= 40 && e.indexOf("Arrow") !== 0 ? "Arrow" + e : e;
}
function nd(t, e, n, r, i) {
  if ((i === void 0 && (i = !0), n === 0)) return -1;
  var o = n - 1;
  (typeof e != "number" || e < 0 || e >= n) && (e = t > 0 ? -1 : o + 1);
  var s = e + t;
  s < 0 ? (s = i ? o : 0) : s > o && (s = i ? 0 : o);
  var l = au(t, s, n, r, i);
  return l === -1 ? (e >= n ? -1 : e) : l;
}
function au(t, e, n, r, i) {
  var o = r(e);
  if (!o || !o.hasAttribute("disabled")) return e;
  if (t > 0) {
    for (var s = e + 1; s < n; s++) if (!r(s).hasAttribute("disabled")) return s;
  } else for (var l = e - 1; l >= 0; l--) if (!r(l).hasAttribute("disabled")) return l;
  return i ? (t > 0 ? au(1, 0, n, r, !1) : au(-1, n - 1, n, r, !1)) : -1;
}
function FC(t, e, n, r) {
  return (
    r === void 0 && (r = !0),
    e.some(function (i) {
      return i && (DC(i, t, n) || (r && DC(i, n.document.activeElement, n)));
    })
  );
}
var AH = l3(function (t) {
  c3(t).textContent = "";
}, 500);
function $H(t, e) {
  var n = c3(e);
  t && ((n.textContent = t), AH(e));
}
function c3(t) {
  t === void 0 && (t = document);
  var e = t.getElementById("a11y-status-message");
  return (
    e ||
    ((e = t.createElement("div")),
    e.setAttribute("id", "a11y-status-message"),
    e.setAttribute("role", "status"),
    e.setAttribute("aria-live", "polite"),
    e.setAttribute("aria-relevant", "additions text"),
    Object.assign(e.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
    }),
    t.body.appendChild(e),
    e)
  );
}
var RH = ["isInitialMount", "highlightedIndex", "items", "environment"],
  u3 = { highlightedIndex: -1, isOpen: !1, selectedItem: null, inputValue: "" };
function IH(t, e, n) {
  var r = t.props,
    i = t.type,
    o = {};
  Object.keys(e).forEach(function (s) {
    MH(s, t, e, n), n[s] !== e[s] && (o[s] = n[s]);
  }),
    r.onStateChange && Object.keys(o).length && r.onStateChange(_t({ type: i }, o));
}
function MH(t, e, n, r) {
  var i = e.props,
    o = e.type,
    s = "on" + Zx(t) + "Change";
  i[s] && r[t] !== void 0 && r[t] !== n[t] && i[s](_t({ type: o }, r));
}
function LH(t, e) {
  return e.changes;
}
function NH(t) {
  var e = t.selectedItem,
    n = t.itemToString;
  return e ? n(e) + " has been selected." : "";
}
var QH = l3(function (t, e) {
    $H(t(), e);
  }, 200),
  DH = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? _.useLayoutEffect : _.useEffect;
function FH(t) {
  var e = t.id,
    n = e === void 0 ? "downshift-" + EH() : e,
    r = t.labelId,
    i = t.menuId,
    o = t.getItemId,
    s = t.toggleButtonId,
    l = t.inputId,
    a = _.useRef({
      labelId: r || n + "-label",
      menuId: i || n + "-menu",
      getItemId:
        o ||
        function (c) {
          return n + "-item-" + c;
        },
      toggleButtonId: s || n + "-toggle-button",
      inputId: l || n + "-input",
    });
  return a.current;
}
function BH(t, e, n, r) {
  var i, o;
  if (t === void 0) {
    if (e === void 0) throw new Error(r);
    (i = n[e]), (o = e);
  } else (o = e === void 0 ? n.indexOf(t) : e), (i = t);
  return [i, o];
}
function VH(t) {
  return t ? String(t) : "";
}
function Zx(t) {
  return "" + t.slice(0, 1).toUpperCase() + t.slice(1);
}
function h3(t) {
  var e = _.useRef(t);
  return (e.current = t), e;
}
function jH(t, e, n) {
  var r = _.useRef(),
    i = _.useRef(),
    o = _.useCallback(
      function (d, f) {
        (i.current = f), (d = lO(d, f.props));
        var p = t(d, f),
          m = f.props.stateReducer(d, _t({}, f, { changes: p }));
        return m;
      },
      [t]
    ),
    s = _.useReducer(o, e),
    l = s[0],
    a = s[1],
    c = h3(n),
    u = _.useCallback(
      function (d) {
        return a(_t({ props: c.current }, d));
      },
      [c]
    ),
    h = i.current;
  return (
    _.useEffect(
      function () {
        h && r.current && r.current !== l && IH(h, lO(r.current, h.props), l), (r.current = l);
      },
      [l, n, h]
    ),
    [l, u]
  );
}
var Qc = {
  itemToString: VH,
  stateReducer: LH,
  getA11ySelectionMessage: NH,
  scrollIntoView: _H,
  environment: typeof window > "u" ? {} : window,
};
function ai(t, e, n) {
  n === void 0 && (n = u3);
  var r = t["default" + Zx(e)];
  return r !== void 0 ? r : n[e];
}
function rd(t, e, n) {
  n === void 0 && (n = u3);
  var r = t[e];
  if (r !== void 0) return r;
  var i = t["initial" + Zx(e)];
  return i !== void 0 ? i : ai(t, e, n);
}
function ZH(t) {
  var e = rd(t, "selectedItem"),
    n = rd(t, "isOpen"),
    r = rd(t, "highlightedIndex"),
    i = rd(t, "inputValue");
  return { highlightedIndex: r < 0 && e && n ? t.items.indexOf(e) : r, isOpen: n, selectedItem: e, inputValue: i };
}
function Dc(t, e, n) {
  var r = t.items,
    i = t.initialHighlightedIndex,
    o = t.defaultHighlightedIndex,
    s = e.selectedItem,
    l = e.highlightedIndex;
  return r.length === 0 ? -1 : i !== void 0 && l === i ? i : o !== void 0 ? o : s ? r.indexOf(s) : n === 0 ? -1 : n < 0 ? r.length - 1 : 0;
}
function zH(t, e, n, r) {
  var i = _.useRef({ isMouseDown: !1, isTouchMove: !1 });
  return (
    _.useEffect(
      function () {
        if ((n == null ? void 0 : n.addEventListener) != null) {
          var o = function () {
              i.current.isMouseDown = !0;
            },
            s = function (h) {
              (i.current.isMouseDown = !1),
                t &&
                  !FC(
                    h.target,
                    e.map(function (d) {
                      return d.current;
                    }),
                    n
                  ) &&
                  r();
            },
            l = function () {
              i.current.isTouchMove = !1;
            },
            a = function () {
              i.current.isTouchMove = !0;
            },
            c = function (h) {
              t &&
                !i.current.isTouchMove &&
                !FC(
                  h.target,
                  e.map(function (d) {
                    return d.current;
                  }),
                  n,
                  !1
                ) &&
                r();
            };
          return (
            n.addEventListener("mousedown", o),
            n.addEventListener("mouseup", s),
            n.addEventListener("touchstart", l),
            n.addEventListener("touchmove", a),
            n.addEventListener("touchend", c),
            function () {
              n.removeEventListener("mousedown", o),
                n.removeEventListener("mouseup", s),
                n.removeEventListener("touchstart", l),
                n.removeEventListener("touchmove", a),
                n.removeEventListener("touchend", c);
            }
          );
        }
      },
      [t, n]
    ),
    i
  );
}
var WH = function () {
  return jx;
};
function BC(t, e, n) {
  var r = n.isInitialMount,
    i = n.highlightedIndex,
    o = n.items,
    s = n.environment,
    l = vc(n, RH);
  _.useEffect(function () {
    r ||
      QH(function () {
        return t(_t({ highlightedIndex: i, highlightedItem: o[i], resultCount: o.length }, l));
      }, s.document);
  }, e);
}
function XH(t) {
  var e = t.highlightedIndex,
    n = t.isOpen,
    r = t.itemRefs,
    i = t.getItemNodeFromIndex,
    o = t.menuElement,
    s = t.scrollIntoView,
    l = _.useRef(!0);
  return (
    DH(
      function () {
        e < 0 || !n || !Object.keys(r.current).length || (l.current === !1 ? (l.current = !0) : s(i(e), o));
      },
      [e]
    ),
    l
  );
}
var UH = jx;
function VC(t, e, n) {
  var r;
  n === void 0 && (n = !0);
  var i = ((r = t.items) == null ? void 0 : r.length) && e >= 0;
  return _t(
    { isOpen: !1, highlightedIndex: -1 },
    i &&
      _t(
        { selectedItem: t.items[e], isOpen: ai(t, "isOpen"), highlightedIndex: ai(t, "highlightedIndex") },
        n && { inputValue: t.itemToString(t.items[e]) }
      )
  );
}
function HH(t, e, n) {
  var r = e.type,
    i = e.props,
    o;
  switch (r) {
    case n.ItemMouseMove:
      o = { highlightedIndex: e.disabled ? -1 : e.index };
      break;
    case n.MenuMouseLeave:
      o = { highlightedIndex: -1 };
      break;
    case n.ToggleButtonClick:
    case n.FunctionToggleMenu:
      o = { isOpen: !t.isOpen, highlightedIndex: t.isOpen ? -1 : Dc(i, t, 0) };
      break;
    case n.FunctionOpenMenu:
      o = { isOpen: !0, highlightedIndex: Dc(i, t, 0) };
      break;
    case n.FunctionCloseMenu:
      o = { isOpen: !1 };
      break;
    case n.FunctionSetHighlightedIndex:
      o = { highlightedIndex: e.highlightedIndex };
      break;
    case n.FunctionSetInputValue:
      o = { inputValue: e.inputValue };
      break;
    case n.FunctionReset:
      o = {
        highlightedIndex: ai(i, "highlightedIndex"),
        isOpen: ai(i, "isOpen"),
        selectedItem: ai(i, "selectedItem"),
        inputValue: ai(i, "inputValue"),
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _t({}, t, o);
}
le.array.isRequired,
  le.func,
  le.func,
  le.func,
  le.number,
  le.number,
  le.number,
  le.bool,
  le.bool,
  le.bool,
  le.any,
  le.any,
  le.any,
  le.string,
  le.string,
  le.string,
  le.func,
  le.string,
  le.func,
  le.func,
  le.func,
  le.func,
  le.func,
  le.shape({
    addEventListener: le.func,
    removeEventListener: le.func,
    document: le.shape({ getElementById: le.func, activeElement: le.any, body: le.any }),
  });
function qH(t) {
  var e = t.isOpen,
    n = t.resultCount,
    r = t.previousResultCount;
  return e
    ? n
      ? n !== r
        ? ""
            .concat(n, " result")
            .concat(
              n === 1 ? " is" : "s are",
              " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select."
            )
        : ""
      : "No results are available."
    : "";
}
po(po({}, Qc), { getA11yStatusMessage: qH });
var zx = 0,
  Wx = 1,
  Xx = 2,
  Ux = 3,
  Hx = 4,
  qx = 5,
  Yx = 6,
  Gx = 7,
  Jx = 8,
  Yf = 9,
  Kx = 10,
  d3 = 11,
  f3 = 12,
  ey = 13,
  p3 = 14,
  m3 = 15,
  g3 = 16,
  O3 = 17,
  v3 = 18,
  ty = 19,
  b3 = 20,
  x3 = 21,
  ny = 22,
  y3 = Object.freeze({
    __proto__: null,
    InputKeyDownArrowDown: zx,
    InputKeyDownArrowUp: Wx,
    InputKeyDownEscape: Xx,
    InputKeyDownHome: Ux,
    InputKeyDownEnd: Hx,
    InputKeyDownPageUp: qx,
    InputKeyDownPageDown: Yx,
    InputKeyDownEnter: Gx,
    InputChange: Jx,
    InputBlur: Yf,
    InputFocus: Kx,
    MenuMouseLeave: d3,
    ItemMouseMove: f3,
    ItemClick: ey,
    ToggleButtonClick: p3,
    FunctionToggleMenu: m3,
    FunctionOpenMenu: g3,
    FunctionCloseMenu: O3,
    FunctionSetHighlightedIndex: v3,
    FunctionSelectItem: ty,
    FunctionSetInputValue: b3,
    FunctionReset: x3,
    ControlledPropUpdatedSelectedItem: ny,
  });
function YH(t) {
  var e = ZH(t),
    n = e.selectedItem,
    r = e.inputValue;
  return (
    r === "" && n && t.defaultInputValue === void 0 && t.initialInputValue === void 0 && t.inputValue === void 0 && (r = t.itemToString(n)),
    _t({}, e, { inputValue: r })
  );
}
le.array.isRequired,
  le.func,
  le.func,
  le.func,
  le.func,
  le.number,
  le.number,
  le.number,
  le.bool,
  le.bool,
  le.bool,
  le.any,
  le.any,
  le.any,
  le.string,
  le.string,
  le.string,
  le.string,
  le.string,
  le.string,
  le.func,
  le.string,
  le.string,
  le.func,
  le.func,
  le.func,
  le.func,
  le.func,
  le.func,
  le.shape({
    addEventListener: le.func,
    removeEventListener: le.func,
    document: le.shape({ getElementById: le.func, activeElement: le.any, body: le.any }),
  });
function GH(t, e, n) {
  var r = _.useRef(),
    i = jH(t, e, n),
    o = i[0],
    s = i[1];
  return (
    _.useEffect(
      function () {
        a3(n, "selectedItem") &&
          (n.selectedItemChanged(r.current, n.selectedItem) && s({ type: ny, inputValue: n.itemToString(n.selectedItem) }),
          (r.current = o.selectedItem === r.current ? n.selectedItem : o.selectedItem));
      },
      [o.selectedItem, n.selectedItem]
    ),
    [lO(o, n), s]
  );
}
var JH = jx,
  KH = _t({}, Qc, {
    selectedItemChanged: function (e, n) {
      return e !== n;
    },
    getA11yStatusMessage: TH,
  });
function eq(t, e) {
  var n,
    r = e.type,
    i = e.props,
    o = e.altKey,
    s;
  switch (r) {
    case ey:
      s = {
        isOpen: ai(i, "isOpen"),
        highlightedIndex: ai(i, "highlightedIndex"),
        selectedItem: i.items[e.index],
        inputValue: i.itemToString(i.items[e.index]),
      };
      break;
    case zx:
      t.isOpen
        ? (s = { highlightedIndex: nd(1, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !0) })
        : (s = { highlightedIndex: o && t.selectedItem == null ? -1 : Dc(i, t, 1, e.getItemNodeFromIndex), isOpen: i.items.length >= 0 });
      break;
    case Wx:
      t.isOpen
        ? o
          ? (s = VC(i, t.highlightedIndex))
          : (s = { highlightedIndex: nd(-1, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !0) })
        : (s = { highlightedIndex: Dc(i, t, -1, e.getItemNodeFromIndex), isOpen: i.items.length >= 0 });
      break;
    case Gx:
      s = VC(i, t.highlightedIndex);
      break;
    case Xx:
      s = _t({ isOpen: !1, highlightedIndex: -1 }, !t.isOpen && { selectedItem: null, inputValue: "" });
      break;
    case qx:
      s = { highlightedIndex: nd(-10, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case Yx:
      s = { highlightedIndex: nd(10, t.highlightedIndex, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case Ux:
      s = { highlightedIndex: au(1, 0, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case Hx:
      s = { highlightedIndex: au(-1, i.items.length - 1, i.items.length, e.getItemNodeFromIndex, !1) };
      break;
    case Yf:
      s = _t(
        { isOpen: !1, highlightedIndex: -1 },
        t.highlightedIndex >= 0 &&
          ((n = i.items) == null ? void 0 : n.length) &&
          e.selectItem && { selectedItem: i.items[t.highlightedIndex], inputValue: i.itemToString(i.items[t.highlightedIndex]) }
      );
      break;
    case Jx:
      s = { isOpen: !0, highlightedIndex: ai(i, "highlightedIndex"), inputValue: e.inputValue };
      break;
    case Kx:
      s = { isOpen: !0, highlightedIndex: Dc(i, t, 0) };
      break;
    case ty:
      s = { selectedItem: e.selectedItem, inputValue: i.itemToString(e.selectedItem) };
      break;
    case ny:
      s = { inputValue: e.inputValue };
      break;
    default:
      return HH(t, e, y3);
  }
  return _t({}, t, s);
}
var tq = ["onMouseLeave", "refKey", "ref"],
  nq = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"],
  rq = ["onClick", "onPress", "refKey", "ref"],
  iq = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
ry.stateChangeTypes = y3;
function ry(t) {
  t === void 0 && (t = {}), JH();
  var e = _t({}, KH, t),
    n = e.initialIsOpen,
    r = e.defaultIsOpen,
    i = e.items,
    o = e.scrollIntoView,
    s = e.environment,
    l = e.getA11yStatusMessage,
    a = e.getA11ySelectionMessage,
    c = e.itemToString,
    u = YH(e),
    h = GH(eq, u, e),
    d = h[0],
    f = h[1],
    p = d.isOpen,
    m = d.highlightedIndex,
    O = d.selectedItem,
    v = d.inputValue,
    g = _.useRef(null),
    b = _.useRef({}),
    x = _.useRef(null),
    k = _.useRef(null),
    w = _.useRef(!0),
    y = FH(e),
    C = _.useRef(),
    P = h3({ state: d, props: e }),
    E = _.useCallback(
      function (Y) {
        return b.current[y.getItemId(Y)];
      },
      [y]
    );
  BC(l, [p, m, v, i], _t({ isInitialMount: w.current, previousResultCount: C.current, items: i, environment: s, itemToString: c }, d)),
    BC(a, [O], _t({ isInitialMount: w.current, previousResultCount: C.current, items: i, environment: s, itemToString: c }, d));
  var N = XH({ menuElement: g.current, highlightedIndex: m, isOpen: p, itemRefs: b, scrollIntoView: o, getItemNodeFromIndex: E });
  UH({ isInitialMount: w.current, props: e, state: d }),
    _.useEffect(function () {
      var Y = n || r || p;
      Y && x.current && x.current.focus();
    }, []),
    _.useEffect(function () {
      w.current || (C.current = i.length);
    });
  var L = zH(p, [x, g, k], s, function () {
      f({ type: Yf, selectItem: !1 });
    }),
    D = WH();
  _.useEffect(function () {
    return (
      (w.current = !1),
      function () {
        w.current = !0;
      }
    );
  }, []),
    _.useEffect(
      function () {
        var Y;
        if (!p) b.current = {};
        else if (((Y = s.document) == null ? void 0 : Y.activeElement) !== x.current) {
          var q;
          x == null || (q = x.current) == null || q.focus();
        }
      },
      [p, s]
    );
  var Q = _.useMemo(
      function () {
        return {
          ArrowDown: function (q) {
            q.preventDefault(), f({ type: zx, altKey: q.altKey, getItemNodeFromIndex: E });
          },
          ArrowUp: function (q) {
            q.preventDefault(), f({ type: Wx, altKey: q.altKey, getItemNodeFromIndex: E });
          },
          Home: function (q) {
            P.current.state.isOpen && (q.preventDefault(), f({ type: Ux, getItemNodeFromIndex: E }));
          },
          End: function (q) {
            P.current.state.isOpen && (q.preventDefault(), f({ type: Hx, getItemNodeFromIndex: E }));
          },
          Escape: function (q) {
            var oe = P.current.state;
            (oe.isOpen || oe.inputValue || oe.selectedItem || oe.highlightedIndex > -1) && (q.preventDefault(), f({ type: Xx }));
          },
          Enter: function (q) {
            var oe = P.current.state;
            !oe.isOpen || q.which === 229 || (q.preventDefault(), f({ type: Gx, getItemNodeFromIndex: E }));
          },
          PageUp: function (q) {
            P.current.state.isOpen && (q.preventDefault(), f({ type: qx, getItemNodeFromIndex: E }));
          },
          PageDown: function (q) {
            P.current.state.isOpen && (q.preventDefault(), f({ type: Yx, getItemNodeFromIndex: E }));
          },
        };
      },
      [f, P, E]
    ),
    R = _.useCallback(
      function (Y) {
        return _t({ id: y.labelId, htmlFor: y.inputId }, Y);
      },
      [y]
    ),
    W = _.useCallback(
      function (Y, q) {
        var oe,
          ce = Y === void 0 ? {} : Y,
          Oe = ce.onMouseLeave,
          _e = ce.refKey,
          Le = _e === void 0 ? "ref" : _e,
          Ge = ce.ref,
          Ct = vc(ce, tq),
          $t = q === void 0 ? {} : q;
        return (
          $t.suppressRefError,
          _t(
            ((oe = {}),
            (oe[Le] = td(Ge, function (Rt) {
              g.current = Rt;
            })),
            (oe.id = y.menuId),
            (oe.role = "listbox"),
            (oe["aria-labelledby"] = Ct && Ct["aria-label"] ? void 0 : "" + y.labelId),
            (oe.onMouseLeave = Pi(Oe, function () {
              f({ type: d3 });
            })),
            oe),
            Ct
          )
        );
      },
      [f, D, y]
    ),
    B = _.useCallback(
      function (Y) {
        var q,
          oe,
          ce = Y === void 0 ? {} : Y,
          Oe = ce.item,
          _e = ce.index,
          Le = ce.refKey,
          Ge = Le === void 0 ? "ref" : Le,
          Ct = ce.ref,
          $t = ce.onMouseMove,
          Rt = ce.onMouseDown,
          We = ce.onClick;
        ce.onPress;
        var Ne = ce.disabled,
          je = vc(ce, nq),
          Ie = P.current,
          Ft = Ie.props,
          Tt = Ie.state,
          Je = BH(Oe, _e, Ft.items, "Pass either item or index to getItemProps!"),
          rn = Je[1],
          U = "onClick",
          J = We,
          I = function () {
            rn !== Tt.highlightedIndex && ((N.current = !1), f({ type: f3, index: rn, disabled: Ne }));
          },
          Te = function () {
            f({ type: ey, index: rn });
          },
          De = function (Ci) {
            return Ci.preventDefault();
          };
        return _t(
          ((q = {}),
          (q[Ge] = td(Ct, function (gt) {
            gt && (b.current[y.getItemId(rn)] = gt);
          })),
          (q.disabled = Ne),
          (q.role = "option"),
          (q["aria-selected"] = "" + (rn === Tt.highlightedIndex)),
          (q.id = y.getItemId(rn)),
          q),
          !Ne && ((oe = {}), (oe[U] = Pi(J, Te)), oe),
          { onMouseMove: Pi($t, I), onMouseDown: Pi(Rt, De) },
          je
        );
      },
      [f, P, N, y]
    ),
    K = _.useCallback(
      function (Y) {
        var q,
          oe = Y === void 0 ? {} : Y,
          ce = oe.onClick;
        oe.onPress;
        var Oe = oe.refKey,
          _e = Oe === void 0 ? "ref" : Oe,
          Le = oe.ref,
          Ge = vc(oe, rq),
          Ct = P.current.state,
          $t = function () {
            f({ type: p3 });
          };
        return _t(
          ((q = {}),
          (q[_e] = td(Le, function (Rt) {
            k.current = Rt;
          })),
          (q["aria-controls"] = y.menuId),
          (q["aria-expanded"] = Ct.isOpen),
          (q.id = y.toggleButtonId),
          (q.tabIndex = -1),
          q),
          !Ge.disabled && _t({}, { onClick: Pi(ce, $t) }),
          Ge
        );
      },
      [f, P, y]
    ),
    ne = _.useCallback(
      function (Y, q) {
        var oe,
          ce = Y === void 0 ? {} : Y,
          Oe = ce.onKeyDown,
          _e = ce.onChange,
          Le = ce.onInput,
          Ge = ce.onFocus,
          Ct = ce.onBlur;
        ce.onChangeText;
        var $t = ce.refKey,
          Rt = $t === void 0 ? "ref" : $t,
          We = ce.ref,
          Ne = vc(ce, iq),
          je = q === void 0 ? {} : q;
        je.suppressRefError;
        var Ie = P.current.state,
          Ft = function (De) {
            var gt = PH(De);
            gt && Q[gt] && Q[gt](De);
          },
          Tt = function (De) {
            f({ type: Jx, inputValue: De.target.value });
          },
          Je = function (De) {
            if (Ie.isOpen && !L.current.isMouseDown) {
              var gt = De.relatedTarget === null && s.document.activeElement !== s.document.body;
              f({ type: Yf, selectItem: !gt });
            }
          },
          rn = function () {
            Ie.isOpen || f({ type: Kx });
          },
          U = "onChange",
          J = {};
        if (!Ne.disabled) {
          var I;
          J = ((I = {}), (I[U] = Pi(_e, Le, Tt)), (I.onKeyDown = Pi(Oe, Ft)), (I.onBlur = Pi(Ct, Je)), (I.onFocus = Pi(Ge, rn)), I);
        }
        return _t(
          ((oe = {}),
          (oe[Rt] = td(We, function (Te) {
            x.current = Te;
          })),
          (oe["aria-activedescendant"] = Ie.isOpen && Ie.highlightedIndex > -1 ? y.getItemId(Ie.highlightedIndex) : ""),
          (oe["aria-autocomplete"] = "list"),
          (oe["aria-controls"] = y.menuId),
          (oe["aria-expanded"] = Ie.isOpen),
          (oe["aria-labelledby"] = Ne && Ne["aria-label"] ? void 0 : "" + y.labelId),
          (oe.autoComplete = "off"),
          (oe.id = y.inputId),
          (oe.role = "combobox"),
          (oe.value = Ie.inputValue),
          oe),
          J,
          Ne
        );
      },
      [D, P, y, Q, f, L, s]
    ),
    A = _.useCallback(
      function () {
        f({ type: m3 });
      },
      [f]
    ),
    V = _.useCallback(
      function () {
        f({ type: O3 });
      },
      [f]
    ),
    ie = _.useCallback(
      function () {
        f({ type: g3 });
      },
      [f]
    ),
    M = _.useCallback(
      function (Y) {
        f({ type: v3, highlightedIndex: Y });
      },
      [f]
    ),
    fe = _.useCallback(
      function (Y) {
        f({ type: ty, selectedItem: Y });
      },
      [f]
    ),
    Se = _.useCallback(
      function (Y) {
        f({ type: b3, inputValue: Y });
      },
      [f]
    ),
    pe = _.useCallback(
      function () {
        f({ type: x3 });
      },
      [f]
    );
  return {
    getItemProps: B,
    getLabelProps: R,
    getMenuProps: W,
    getInputProps: ne,
    getToggleButtonProps: K,
    toggleMenu: A,
    openMenu: ie,
    closeMenu: V,
    setHighlightedIndex: M,
    setInputValue: Se,
    selectItem: fe,
    reset: pe,
    highlightedIndex: m,
    isOpen: p,
    selectedItem: O,
    inputValue: v,
  };
}
function oq(t) {
  var e = t.removedSelectedItem,
    n = t.itemToString;
  return n(e) + " has been removed.";
}
le.array,
  le.array,
  le.array,
  le.func,
  le.func,
  le.func,
  le.number,
  le.number,
  le.number,
  le.func,
  le.func,
  le.string,
  le.string,
  le.shape({
    addEventListener: le.func,
    removeEventListener: le.func,
    document: le.shape({ getElementById: le.func, activeElement: le.any, body: le.any }),
  });
Qc.itemToString, Qc.stateReducer, Qc.environment;
const jC = 20,
  w3 = (t) =>
    t.suggestions.length > 0
      ? S.createElement(sq, { ...t })
      : S.createElement("input", { className: F.textInput, size: 40, autoFocus: !0, ...t.register(t.inputName) }),
  sq = ({ autofocus: t, suggestions: e, control: n, inputName: r, placeholder: i, initialInputValue: o, setValue: s }) => {
    const [l, a] = S.useState(e.slice(0, jC)),
      c = mt(st),
      u = e.length > 0,
      {
        isOpen: h,
        getToggleButtonProps: d,
        getMenuProps: f,
        getInputProps: p,
        highlightedIndex: m,
        getItemProps: O,
        selectedItem: v,
      } = ry({
        initialInputValue: o,
        onInputValueChange({ inputValue: b = "" }) {
          s(r, b), (b = b.toLowerCase() || "");
          const x = [];
          for (const k of e) if (k.toLowerCase().includes(b) && (x.push(k), x.length >= jC)) break;
          a(x);
        },
        items: l,
        itemToString(b) {
          return b ?? "";
        },
      }),
      g = h && l.length > 0;
    return S.createElement(
      "div",
      { className: F.downshiftAutocompleteContainer },
      S.createElement(
        "div",
        { "data-visible-dropdown": g, className: F.downshiftInputWrapper },
        S.createElement($M, {
          name: r,
          control: n,
          render: ({ field: b }) => {
            const x = p();
            return S.createElement("input", {
              ...x,
              name: b.name,
              placeholder: i,
              className: F.downshiftInput,
              size: 30,
              "data-editor-dialog": !0,
              autoFocus: t,
            });
          },
        }),
        u && S.createElement("button", { "aria-label": "toggle menu", type: "button", ...d() }, c("arrow_drop_down"))
      ),
      S.createElement(
        "div",
        { className: F.downshiftAutocompleteContainer },
        S.createElement(
          "ul",
          { ...f(), "data-visible": g },
          l.map((b, x) =>
            S.createElement(
              "li",
              { "data-selected": v === b, "data-highlighted": m === x, key: `${b}${x}`, ...O({ item: b, index: x }) },
              b
            )
          )
        )
      )
    );
  },
  lq = () => {
    const [t, e, n] = Ye(Gf, Eo, jr),
      r = He(cy),
      i = He(ly),
      o = nt(),
      { register: s, handleSubmit: l, control: a, setValue: c, reset: u } = jp({ values: e.type === "editing" ? e.initialValues : {} });
    return S.createElement(
      Xv,
      {
        open: e.type !== "inactive",
        onOpenChange: (h) => {
          h || (i(), u({ src: "", title: "", altText: "" }));
        },
      },
      S.createElement(
        Uv,
        { container: n == null ? void 0 : n.current },
        S.createElement(Hv, { className: F.dialogOverlay }),
        S.createElement(
          qv,
          {
            className: F.dialogContent,
            onOpenAutoFocus: (h) => {
              h.preventDefault();
            },
          },
          S.createElement(
            "form",
            {
              onSubmit: (h) => {
                l(r)(h), u({ src: "", title: "", altText: "" }), h.preventDefault(), h.stopPropagation();
              },
              className: F.multiFieldForm,
            },
            S.createElement(
              "div",
              { className: F.formField },
              S.createElement("label", { htmlFor: "file" }, o("uploadImage.uploadInstructions", "Upload an image from your device:")),
              S.createElement("input", { type: "file", accept: "image/*", ...s("file") })
            ),
            S.createElement(
              "div",
              { className: F.formField },
              S.createElement("label", { htmlFor: "src" }, o("uploadImage.addViaUrlInstructions", "Or add an image from an URL:")),
              S.createElement(w3, {
                register: s,
                initialInputValue: e.type === "editing" ? e.initialValues.src ?? "" : "",
                inputName: "src",
                suggestions: t,
                setValue: c,
                control: a,
                placeholder: o("uploadImage.autoCompletePlaceholder", "Select or paste an image src"),
              })
            ),
            S.createElement(
              "div",
              { className: F.formField },
              S.createElement("label", { htmlFor: "alt" }, o("uploadImage.alt", "Alt:")),
              S.createElement("input", { type: "text", ...s("altText"), className: F.textInput })
            ),
            S.createElement(
              "div",
              { className: F.formField },
              S.createElement("label", { htmlFor: "title" }, o("uploadImage.title", "Title:")),
              S.createElement("input", { type: "text", ...s("title"), className: F.textInput })
            ),
            S.createElement(
              "div",
              { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
              S.createElement(
                "button",
                {
                  type: "submit",
                  title: o("dialogControls.save", "Save"),
                  "aria-label": o("dialogControls.save", "Save"),
                  className: Fe(F.primaryButton),
                },
                o("dialogControls.save", "Save")
              ),
              S.createElement(
                Yv,
                { asChild: !0 },
                S.createElement(
                  "button",
                  {
                    type: "reset",
                    title: o("dialogControls.cancel", "Cancel"),
                    "aria-label": o("dialogControls.cancel", "Cancel"),
                    className: Fe(F.secondaryButton),
                  },
                  o("dialogControls.cancel", "Cancel")
                )
              )
            )
          )
        )
      )
    );
  };
function Gg(t, e, n) {
  return Math.min(Math.max(t, e), n);
}
const ct = { east: 1, north: 8, south: 2, west: 4 };
function aq({ onResizeStart: t, onResizeEnd: e, imageRef: n, maxWidth: r, editor: i }) {
  const o = _.useRef(null),
    s = _.useRef({ priority: "", value: "default" }),
    l = _.useRef({
      currentHeight: 0,
      currentWidth: 0,
      direction: 0,
      isResizing: !1,
      ratio: 0,
      startHeight: 0,
      startWidth: 0,
      startX: 0,
      startY: 0,
    }),
    a = i.getRootElement(),
    c = r || (a !== null ? a.getBoundingClientRect().width - 20 : 100),
    u = a !== null ? a.getBoundingClientRect().height - 20 : 100,
    h = 100,
    d = 100,
    f = (g) => {
      const b = g === ct.east || g === ct.west,
        x = g === ct.north || g === ct.south,
        k = (g & ct.north && g & ct.west) || (g & ct.south && g & ct.east),
        w = b ? "ew" : x ? "ns" : k ? "nwse" : "nesw";
      a !== null && a.style.setProperty("cursor", `${w}-resize`, "important"),
        document.body !== null &&
          (document.body.style.setProperty("cursor", `${w}-resize`, "important"),
          (s.current.value = document.body.style.getPropertyValue("-webkit-user-select")),
          (s.current.priority = document.body.style.getPropertyPriority("-webkit-user-select")),
          document.body.style.setProperty("-webkit-user-select", "none", "important"));
    },
    p = () => {
      a !== null && a.style.setProperty("cursor", "text"),
        document.body !== null &&
          (document.body.style.setProperty("cursor", "default"),
          document.body.style.setProperty("-webkit-user-select", s.current.value, s.current.priority));
    },
    m = (g, b) => {
      if (!i.isEditable()) return;
      const x = n.current,
        k = o.current;
      if (x !== null && k !== null) {
        g.preventDefault();
        const { width: w, height: y } = x.getBoundingClientRect(),
          C = l.current;
        (C.startWidth = w),
          (C.startHeight = y),
          (C.ratio = w / y),
          (C.currentWidth = w),
          (C.currentHeight = y),
          (C.startX = g.clientX),
          (C.startY = g.clientY),
          (C.isResizing = !0),
          (C.direction = b),
          f(b),
          t(),
          k.classList.add(F.imageControlWrapperResizing),
          (x.style.height = `${y}px`),
          (x.style.width = `${w}px`),
          document.addEventListener("pointermove", O),
          document.addEventListener("pointerup", v);
      }
    },
    O = (g) => {
      const b = n.current,
        x = l.current,
        k = x.direction & (ct.east | ct.west),
        w = x.direction & (ct.south | ct.north);
      if (b !== null && x.isResizing)
        if (k && w) {
          let y = Math.floor(x.startX - g.clientX);
          y = x.direction & ct.east ? -y : y;
          const C = Gg(x.startWidth + y, h, c),
            P = C / x.ratio;
          (b.style.width = `${C}px`), (b.style.height = `${P}px`), (x.currentHeight = P), (x.currentWidth = C);
        } else if (w) {
          let y = Math.floor(x.startY - g.clientY);
          y = x.direction & ct.south ? -y : y;
          const C = Gg(x.startHeight + y, d, u);
          (b.style.height = `${C}px`), (x.currentHeight = C);
        } else {
          let y = Math.floor(x.startX - g.clientX);
          y = x.direction & ct.east ? -y : y;
          const C = Gg(x.startWidth + y, h, c);
          (b.style.width = `${C}px`), (x.currentWidth = C);
        }
    },
    v = () => {
      const g = n.current,
        b = l.current,
        x = o.current;
      if (g !== null && x !== null && b.isResizing) {
        const k = b.currentWidth,
          w = b.currentHeight;
        (b.startWidth = 0),
          (b.startHeight = 0),
          (b.ratio = 0),
          (b.startX = 0),
          (b.startY = 0),
          (b.currentWidth = 0),
          (b.currentHeight = 0),
          (b.isResizing = !1),
          x.classList.remove(F.imageControlWrapperResizing),
          p(),
          e(k, w),
          document.removeEventListener("pointermove", O),
          document.removeEventListener("pointerup", v);
      }
    };
  return _.createElement(
    "div",
    { ref: o },
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerN),
      onPointerDown: (g) => {
        m(g, ct.north);
      },
    }),
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerNe),
      onPointerDown: (g) => {
        m(g, ct.north | ct.east);
      },
    }),
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerE),
      onPointerDown: (g) => {
        m(g, ct.east);
      },
    }),
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerSe),
      onPointerDown: (g) => {
        m(g, ct.south | ct.east);
      },
    }),
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerS),
      onPointerDown: (g) => {
        m(g, ct.south);
      },
    }),
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerSw),
      onPointerDown: (g) => {
        m(g, ct.south | ct.west);
      },
    }),
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerW),
      onPointerDown: (g) => {
        m(g, ct.west);
      },
    }),
    _.createElement("div", {
      className: Fe(F.imageResizer, F.imageResizerNw),
      onPointerDown: (g) => {
        m(g, ct.north | ct.west);
      },
    })
  );
}
const ZC = new Set();
function cq(t) {
  if (!ZC.has(t))
    throw new Promise((e) => {
      const n = new Image();
      (n.src = t),
        (n.onerror = n.onload =
          () => {
            ZC.add(t), e(null);
          });
    });
}
function uq({ title: t, alt: e, className: n, imageRef: r, src: i, width: o, height: s }) {
  return (
    cq(i), S.createElement("img", { className: n ?? void 0, alt: e, src: i, title: t, ref: r, draggable: "false", width: o, height: s })
  );
}
function hq({ src: t, title: e, alt: n, nodeKey: r, width: i, height: o }) {
  const [s, l, a, c, u] = Ye(Jf, ay, Kf, st, Gt),
    h = He(sy),
    d = S.useRef(null),
    f = S.useRef(null),
    [p, m, O] = bA(r),
    [v] = In(),
    [g, b] = S.useState(null),
    x = S.useRef(null),
    [k, w] = S.useState(!1),
    [y, C] = S.useState(null),
    [P, E] = S.useState(null),
    N = nt(),
    L = S.useCallback(
      (ne) => {
        if (p && Vt(ae())) {
          ne.preventDefault();
          const V = dt(r);
          cu(V) && V.remove();
        }
        return !1;
      },
      [p, r]
    ),
    D = S.useCallback(
      (ne) => {
        const A = ae(),
          V = f.current;
        return p && Vt(A) && A.getNodes().length === 1 && V !== null && V !== document.activeElement
          ? (ne.preventDefault(), V.focus(), !0)
          : !1;
      },
      [p]
    ),
    Q = S.useCallback(
      (ne) =>
        f.current === ne.target
          ? (pn(null),
            v.update(() => {
              m(!0);
              const A = v.getRootElement();
              A !== null && A.focus();
            }),
            !0)
          : !1,
      [v, m]
    );
  S.useEffect(() => {
    a
      ? (async () => {
          P || E(t);
          const A = await a(t);
          C(A);
        })().catch((A) => {
          console.error(A);
        })
      : C(t);
  }, [t, a, P]),
    S.useEffect(() => {
      let ne = !0;
      const A = Xn(
        v.registerUpdateListener(({ editorState: V }) => {
          ne && b(V.read(() => ae()));
        }),
        v.registerCommand(ba, (V, ie) => ((x.current = ie), !1), ht),
        v.registerCommand(
          Wp,
          (V) => {
            const ie = V;
            return k ? !0 : ie.target === d.current ? (ie.shiftKey ? m(!p) : (O(), m(!0)), !0) : !1;
          },
          ht
        ),
        v.registerCommand(qp, (V) => (V.target === d.current ? (V.preventDefault(), !0) : !1), ht),
        v.registerCommand(Hp, L, ht),
        v.registerCommand(Xu, L, ht),
        v.registerCommand(Wl, D, ht),
        v.registerCommand(Uu, Q, ht)
      );
      return () => {
        (ne = !1), A();
      };
    }, [O, v, k, p, r, L, D, Q, m]);
  const R = (ne, A) => {
      setTimeout(() => {
        w(!1);
      }, 200),
        v.update(() => {
          const V = dt(r);
          cu(V) && V.setWidthAndHeight(ne, A);
        });
    },
    W = () => {
      w(!0);
    },
    B = Vt(g),
    K = p;
  return y !== null
    ? S.createElement(
        S.Suspense,
        { fallback: null },
        S.createElement(
          "div",
          { className: F.imageWrapper, "data-editor-block-type": "image" },
          S.createElement(
            "div",
            { draggable: B },
            S.createElement(uq, {
              width: i,
              height: o,
              className: Fe({ [F.focusedImage]: K }),
              src: y,
              title: e ?? "",
              alt: n ?? "",
              imageRef: d,
            })
          ),
          B && K && !s && S.createElement(aq, { editor: v, imageRef: d, onResizeStart: W, onResizeEnd: R }),
          S.createElement(
            "div",
            { className: F.editImageToolbar },
            S.createElement(
              "button",
              {
                className: F.iconButton,
                type: "button",
                title: N("image.delete", "Delete image"),
                onClick: (ne) => {
                  ne.preventDefault(),
                    v.update(() => {
                      var A;
                      (A = dt(r)) == null || A.remove();
                    });
                },
              },
              c("delete_small")
            ),
            !l &&
              S.createElement(
                "button",
                {
                  type: "button",
                  className: Fe(F.iconButton, F.editImageButton),
                  title: N("imageEditor.editImage", "Edit image"),
                  disabled: u,
                  onClick: () => {
                    h({ nodeKey: r, initialValues: { src: P || y, title: e ?? "", altText: n ?? "" } });
                  },
                },
                c("settings")
              )
          )
        )
      )
    : null;
}
var dq = Object.defineProperty,
  fq = (t, e, n) => (e in t ? dq(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  tc = (t, e, n) => (fq(t, typeof e != "symbol" ? e + "" : e, n), n);
function pq(t) {
  if (t instanceof HTMLImageElement) {
    const { alt: e, src: n, title: r, width: i, height: o } = t;
    return { node: es({ altText: e, src: n, title: r, width: i, height: o }) };
  }
  return null;
}
class Na extends wi {
  constructor(e, n, r, i, o, s) {
    super(s),
      tc(this, "__src"),
      tc(this, "__altText"),
      tc(this, "__title"),
      tc(this, "__width"),
      tc(this, "__height"),
      (this.__src = e),
      (this.__title = r),
      (this.__altText = n),
      (this.__width = i ?? "inherit"),
      (this.__height = o ?? "inherit");
  }
  static getType() {
    return "image";
  }
  static clone(e) {
    return new Na(e.__src, e.__altText, e.__title, e.__width, e.__height, e.__key);
  }
  static importJSON(e) {
    const { altText: n, title: r, src: i, width: o, height: s } = e;
    return es({ altText: n, title: r, src: i, height: s, width: o });
  }
  exportDOM() {
    const e = document.createElement("img");
    return (
      e.setAttribute("src", this.__src),
      e.setAttribute("alt", this.__altText),
      this.__title && e.setAttribute("title", this.__title),
      this.__width && e.setAttribute("width", this.__width.toString()),
      this.__height && e.setAttribute("height", this.__height.toString()),
      { element: e }
    );
  }
  static importDOM() {
    return { img: () => ({ conversion: pq, priority: 0 }) };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      title: this.getTitle(),
      height: this.__height === "inherit" ? 0 : this.__height,
      width: this.__width === "inherit" ? 0 : this.__width,
      src: this.getSrc(),
      type: "image",
      version: 1,
    };
  }
  setWidthAndHeight(e, n) {
    const r = this.getWritable();
    (r.__width = e), (r.__height = n);
  }
  createDOM(e) {
    const n = document.createElement("span"),
      i = e.theme.image;
    return i !== void 0 && (n.className = i), n;
  }
  updateDOM() {
    return !1;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  getTitle() {
    return this.__title;
  }
  getHeight() {
    return this.__height;
  }
  getWidth() {
    return this.__width;
  }
  setTitle(e) {
    this.getWritable().__title = e;
  }
  setSrc(e) {
    this.getWritable().__src = e;
  }
  setAltText(e) {
    this.getWritable().__altText = e ?? "";
  }
  hasExplicitDimensions() {
    return this.__width !== "inherit" || this.__height !== "inherit";
  }
  decorate(e) {
    return S.createElement(hq, {
      src: this.getSrc(),
      title: this.getTitle(),
      nodeKey: this.getKey(),
      width: this.__width,
      height: this.__height,
      alt: this.__altText,
    });
  }
}
function es(t) {
  const { altText: e, title: n, src: r, key: i, width: o, height: s } = t;
  return new Na(r, e, n, o, s, i);
}
function cu(t) {
  return t instanceof Na;
}
const mq = {
    testLexicalNode: cu,
    visitLexicalNode({ mdastParent: t, lexicalNode: e, actions: n }) {
      if (e.hasExplicitDimensions()) {
        const r = new Image();
        e.getHeight() !== "inherit" && (r.height = e.getHeight()),
          e.getWidth() !== "inherit" && (r.width = e.getWidth()),
          e.getAltText() && (r.alt = e.getAltText()),
          e.getTitle() && (r.title = e.getTitle()),
          n.appendToParent(t, { type: "html", value: r.outerHTML.replace(/>$/, ` src="${e.getSrc()}" />`) });
      } else n.appendToParent(t, { type: "image", url: e.getSrc(), alt: e.getAltText(), title: e.getTitle() });
    },
  },
  gq = {
    testNode: "image",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(es({ src: t.url, altText: t.alt ?? "", title: t.title ?? "" }));
    },
  },
  Oq = {
    testNode: (t) => t.type === "html" && t.value.trim().startsWith("<img"),
    visitNode({ mdastNode: t, lexicalParent: e }) {
      const n = document.createElement("div");
      n.innerHTML = t.value;
      const r = n.querySelector("img");
      if (!r) throw new Error("Invalid HTML image");
      const i = r.src,
        o = r.alt,
        s = r.title,
        l = r.width,
        a = r.height,
        c = es({ src: i || "", altText: o, title: s, width: l, height: a });
      if (e.getType() === "root") {
        const u = tt();
        u.append(c), e.append(u);
      } else e.append(c);
    },
  };
function nc(t, e) {
  const n = t.attributes.find((r) => r.type === "mdxJsxAttribute" && r.name === e);
  if (n) return n.value;
}
const vq = {
    testNode: (t) => (t.type === "mdxJsxTextElement" || t.type === "mdxJsxFlowElement") && t.name === "img",
    visitNode({ mdastNode: t, lexicalParent: e }) {
      const n = nc(t, "src");
      if (!n) return;
      const r = nc(t, "alt") ?? "",
        i = nc(t, "title"),
        o = nc(t, "height"),
        s = nc(t, "width"),
        l = es({ src: n, altText: r, title: i, width: s ? parseInt(s, 10) : void 0, height: o ? parseInt(o, 10) : void 0 });
      if (e.getType() === "root") {
        const a = tt();
        a.append(l), e.append(a);
      } else e.append(l);
    },
  },
  iy = kt((t) => {
    t.sub(t.pipe(iy, pt(St)), ([e, n]) => {
      n == null ||
        n.update(() => {
          const r = es({ altText: e.altText ?? "", src: e.src, title: e.title ?? "" });
          ya([r]), Yt(r.getParentOrThrow()) && Db(r, tt).selectEnd();
        });
    });
  }),
  S3 = kt((t) => {
    t.sub(t.pipe(S3, pt(xo)), ([e, n]) => {
      const r = (i) => {
        t.pub(iy, { ...e, src: i });
      };
      "file" in e
        ? n == null ||
          n(e.file)
            .then(r)
            .catch((i) => {
              throw i;
            })
        : r(e.src);
    });
  }),
  Gf = we([]),
  Jf = we(!1),
  xo = we(null),
  Kf = we(null),
  Eo = we({ type: "inactive" }, (t) => {
    t.sub(t.pipe(cy, pt(St, xo, Eo)), ([e, n, r, i]) => {
      const o =
        i.type === "editing"
          ? (s) => {
              n == null ||
                n.update(() => {
                  const { nodeKey: l } = i,
                    a = dt(l);
                  a.setTitle(e.title), a.setAltText(e.altText), a.setSrc(s);
                }),
                t.pub(Eo, { type: "inactive" });
            }
          : (s) => {
              t.pub(iy, { ...e, src: s }), t.pub(Eo, { type: "inactive" });
            };
      e.file.length > 0
        ? r == null ||
          r(e.file.item(0))
            .then(o)
            .catch((s) => {
              throw s;
            })
        : e.src && o(e.src);
    }),
      t.pub(iu, (e) => {
        const n = t.getValue(xo);
        return Xn(
          e.registerCommand(
            uu,
            (r) => {
              const i = es(r);
              return ya([i]), Yt(i.getParentOrThrow()) && Db(i, tt).selectEnd(), !0;
            },
            Ze
          ),
          e.registerCommand(qp, (r) => wq(r), $f),
          e.registerCommand(cb, (r) => Sq(r), ht),
          e.registerCommand(ab, (r) => kq(r, e, t.getValue(xo)), $f),
          ...(n !== null
            ? [
                e.registerCommand(
                  Wu,
                  (r) => {
                    var i;
                    let o = Array.from(((i = r.clipboardData) == null ? void 0 : i.items) ?? []);
                    if (((o = o.filter((l) => l.type.includes("image"))), !o.length || o.length === 0)) return !1;
                    const s = t.getValue(xo);
                    return (
                      Promise.all(o.map((l) => s(l.getAsFile())))
                        .then((l) => {
                          l.forEach((a) => {
                            e.dispatchCommand(uu, { src: a, altText: "" });
                          });
                        })
                        .catch((l) => {
                          throw l;
                        }),
                      !0
                    );
                  },
                  Bn
                ),
              ]
            : [])
        );
      });
  }),
  oy = Fr((t) => {
    t.link(t.pipe(oy, Kv({ type: "new" })), Eo);
  }),
  sy = kt((t) => {
    t.link(
      t.pipe(
        sy,
        mr((e) => ({ type: "editing", ...e }))
      ),
      Eo
    );
  }),
  ly = Fr((t) => {
    t.link(t.pipe(ly, Kv({ type: "inactive" })), Eo);
  }),
  ay = we(!1),
  cy = kt(),
  bq = Ut({
    init(t, e) {
      t.pubIn({
        [Wn]: [gq, Oq, vq],
        [ar]: Na,
        [cr]: mq,
        [qo]: (e == null ? void 0 : e.ImageDialog) ?? lq,
        [xo]: (e == null ? void 0 : e.imageUploadHandler) ?? null,
        [Gf]: (e == null ? void 0 : e.imageAutocompleteSuggestions) ?? [],
        [Jf]: !!(e != null && e.disableImageResize),
        [ay]: !!(e != null && e.disableImageSettingsButton),
        [Kf]: (e == null ? void 0 : e.imagePreviewHandler) ?? null,
      });
    },
    update(t, e) {
      t.pubIn({
        [xo]: (e == null ? void 0 : e.imageUploadHandler) ?? null,
        [Gf]: (e == null ? void 0 : e.imageAutocompleteSuggestions) ?? [],
        [Jf]: !!(e != null && e.disableImageResize),
        [Kf]: (e == null ? void 0 : e.imagePreviewHandler) ?? null,
      });
    },
  }),
  xq = (t) => (Ub ? (t ?? window).getSelection() : null),
  uu = Ji(),
  yq = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
function wq(t) {
  const e = uy();
  if (!e) return !1;
  const n = t.dataTransfer;
  if (!n) return !1;
  n.setData("text/plain", "_");
  const r = document.createElement("img");
  return (
    (r.src = yq),
    n.setDragImage(r, 0, 0),
    n.setData(
      "application/x-lexical-drag",
      JSON.stringify({ data: { altText: e.__altText, title: e.__title, key: e.getKey(), src: e.__src }, type: "image" })
    ),
    !0
  );
}
function Sq(t) {
  var e;
  let n = Array.from(((e = t.dataTransfer) == null ? void 0 : e.items) ?? []);
  return (
    (n = n.filter((i) => i.type.includes("image"))), n.length > 0 ? (t.preventDefault(), !0) : uy() ? (k3(t) || t.preventDefault(), !0) : !1
  );
}
function kq(t, e, n) {
  var r;
  let i = Array.from(((r = t.dataTransfer) == null ? void 0 : r.items) ?? []);
  if (((i = i.filter((l) => l.type.includes("image"))), i.length > 0 && n !== null))
    return (
      t.preventDefault(),
      Promise.all(i.map((l) => n(l.getAsFile())))
        .then((l) => {
          l.forEach((a) => {
            e.dispatchCommand(uu, { src: a, altText: "" });
          });
        })
        .catch((l) => {
          throw l;
        }),
      !0
    );
  const o = uy();
  if (!o) return !1;
  const s = Cq(t);
  if (!s) return !1;
  if ((t.preventDefault(), k3(t))) {
    const l = _q(t);
    o.remove();
    const a = lm();
    l != null && a.applyDOMRange(l), pn(a), e.dispatchCommand(uu, s);
  }
  return !0;
}
function uy() {
  const t = ae();
  if (!Vt(t)) return null;
  const n = t.getNodes()[0];
  return cu(n) ? n : null;
}
function Cq(t) {
  var e;
  const n = (e = t.dataTransfer) == null ? void 0 : e.getData("application/x-lexical-drag");
  if (!n) return null;
  const { type: r, data: i } = JSON.parse(n);
  return r !== "image" ? null : i;
}
function k3(t) {
  const e = t.target;
  return !!(e && e instanceof HTMLElement && e.parentElement);
}
function _q(t) {
  let e;
  const n = t.target,
    r = n == null ? null : n.nodeType === 9 ? n.defaultView : n.ownerDocument.defaultView,
    i = xq(r);
  if (document.caretRangeFromPoint) e = document.caretRangeFromPoint(t.clientX, t.clientY);
  else if (t.rangeParent && i !== null) i.collapse(t.rangeParent, t.rangeOffset ?? 0), (e = i.getRangeAt(0));
  else throw Error("Cannot get the selection when dragging");
  return e;
}
var C3 = { exports: {} };
(function (t) {
  (function () {
    var e;
    (e = t.exports = i), (e.format = i), (e.vsprintf = r), typeof console < "u" && typeof console.log == "function" && (e.printf = n);
    function n() {
      console.log(i.apply(null, arguments));
    }
    function r(o, s) {
      return i.apply(null, [o].concat(s));
    }
    function i(o) {
      for (
        var s = 1,
          l = [].slice.call(arguments),
          a = 0,
          c = o.length,
          u = "",
          h,
          d = !1,
          f,
          p,
          m = !1,
          O,
          v = function () {
            return l[s++];
          },
          g = function () {
            for (var b = ""; /\d/.test(o[a]); ) (b += o[a++]), (h = o[a]);
            return b.length > 0 ? parseInt(b) : null;
          };
        a < c;
        ++a
      )
        if (((h = o[a]), d))
          switch (
            ((d = !1),
            h == "." ? ((m = !1), (h = o[++a])) : h == "0" && o[a + 1] == "." ? ((m = !0), (a += 2), (h = o[a])) : (m = !0),
            (O = g()),
            h)
          ) {
            case "b":
              u += parseInt(v(), 10).toString(2);
              break;
            case "c":
              (f = v()), typeof f == "string" || f instanceof String ? (u += f) : (u += String.fromCharCode(parseInt(f, 10)));
              break;
            case "d":
              u += parseInt(v(), 10);
              break;
            case "f":
              (p = String(parseFloat(v()).toFixed(O || 6))), (u += m ? p : p.replace(/^0/, ""));
              break;
            case "j":
              u += JSON.stringify(v());
              break;
            case "o":
              u += "0" + parseInt(v(), 10).toString(8);
              break;
            case "s":
              u += v();
              break;
            case "x":
              u += "0x" + parseInt(v(), 10).toString(16);
              break;
            case "X":
              u += "0x" + parseInt(v(), 10).toString(16).toUpperCase();
              break;
            default:
              u += h;
              break;
          }
        else h === "%" ? (d = !0) : (u += h);
      return u;
    }
  })();
})(C3);
var Eq = C3.exports;
const Tq = Vp(Eq),
  id = Object.assign(cs(Error), {
    eval: cs(EvalError),
    range: cs(RangeError),
    reference: cs(ReferenceError),
    syntax: cs(SyntaxError),
    type: cs(TypeError),
    uri: cs(URIError),
  });
function cs(t) {
  return (e.displayName = t.displayName || t.name), e;
  function e(n, ...r) {
    const i = n && Tq(n, ...r);
    return new t(i);
  }
}
const od = {}.hasOwnProperty,
  zC = { yaml: "-", toml: "+" };
function hy(t) {
  const e = [];
  let n = -1;
  const r = Array.isArray(t) ? t : t ? [t] : ["yaml"];
  for (; ++n < r.length; ) e[n] = Pq(r[n]);
  return e;
}
function Pq(t) {
  let e = t;
  if (typeof e == "string") {
    if (!od.call(zC, e)) throw id("Missing matter definition for `%s`", e);
    e = { type: e, marker: zC[e] };
  } else if (typeof e != "object") throw id("Expected matter to be an object, not `%j`", e);
  if (!od.call(e, "type")) throw id("Missing `type` in matter `%j`", e);
  if (!od.call(e, "fence") && !od.call(e, "marker")) throw id("Missing `marker` or `fence` in matter `%j`", e);
  return e;
}
function Aq(t) {
  const e = hy(t),
    n = {};
  let r = -1;
  for (; ++r < e.length; ) {
    const i = e[r],
      o = aO(i, "open").charCodeAt(0),
      s = $q(i),
      l = n[o];
    Array.isArray(l) ? l.push(s) : (n[o] = [s]);
  }
  return { flow: n };
}
function $q(t) {
  const e = t.anywhere,
    n = t.type,
    r = n + "Fence",
    i = r + "Sequence",
    o = n + "Value",
    s = { tokenize: u, partial: !0 };
  let l,
    a = 0;
  return { tokenize: c, concrete: !0 };
  function c(h, d, f) {
    const p = this;
    return m;
    function m(y) {
      const C = p.now();
      return C.column === 1 && (C.line === 1 || e) && ((l = aO(t, "open")), (a = 0), y === l.charCodeAt(a))
        ? (h.enter(n), h.enter(r), h.enter(i), O(y))
        : f(y);
    }
    function O(y) {
      return a === l.length
        ? (h.exit(i), Pe(y) ? (h.enter("whitespace"), v(y)) : g(y))
        : y === l.charCodeAt(a++)
        ? (h.consume(y), O)
        : f(y);
    }
    function v(y) {
      return Pe(y) ? (h.consume(y), v) : (h.exit("whitespace"), g(y));
    }
    function g(y) {
      return de(y)
        ? (h.exit(r), h.enter("lineEnding"), h.consume(y), h.exit("lineEnding"), (l = aO(t, "close")), (a = 0), h.attempt(s, w, b))
        : f(y);
    }
    function b(y) {
      return y === null || de(y) ? k(y) : (h.enter(o), x(y));
    }
    function x(y) {
      return y === null || de(y) ? (h.exit(o), k(y)) : (h.consume(y), x);
    }
    function k(y) {
      return y === null ? f(y) : (h.enter("lineEnding"), h.consume(y), h.exit("lineEnding"), h.attempt(s, w, b));
    }
    function w(y) {
      return h.exit(n), d(y);
    }
  }
  function u(h, d, f) {
    let p = 0;
    return m;
    function m(b) {
      return b === l.charCodeAt(p) ? (h.enter(r), h.enter(i), O(b)) : f(b);
    }
    function O(b) {
      return p === l.length
        ? (h.exit(i), Pe(b) ? (h.enter("whitespace"), v(b)) : g(b))
        : b === l.charCodeAt(p++)
        ? (h.consume(b), O)
        : f(b);
    }
    function v(b) {
      return Pe(b) ? (h.consume(b), v) : (h.exit("whitespace"), g(b));
    }
    function g(b) {
      return b === null || de(b) ? (h.exit(r), d(b)) : f(b);
    }
  }
}
function aO(t, e) {
  return t.marker ? WC(t.marker, e).repeat(3) : WC(t.fence, e);
}
function WC(t, e) {
  return typeof t == "string" ? t : t[e];
}
function Rq(t) {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Iq(t) {
  const e = hy(t),
    n = {},
    r = {};
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i];
    (n[o.type] = Mq(o)), (r[o.type] = Lq), (r[o.type + "Value"] = Nq);
  }
  return { enter: n, exit: r };
}
function Mq(t) {
  return e;
  function e(n) {
    this.enter({ type: t.type, value: "" }, n), this.buffer();
  }
}
function Lq(t) {
  const e = this.resume(),
    n = this.stack[this.stack.length - 1];
  this.exit(t), (n.value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""));
}
function Nq(t) {
  this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function Qq(t) {
  const e = [],
    n = {},
    r = hy(t);
  let i = -1;
  for (; ++i < r.length; ) {
    const o = r[i];
    n[o.type] = Dq(o);
    const s = cO(o, "open");
    e.push({ atBreak: !0, character: s.charAt(0), after: Rq(s.charAt(1)) });
  }
  return { unsafe: e, handlers: n };
}
function Dq(t) {
  const e = cO(t, "open"),
    n = cO(t, "close");
  return r;
  function r(i) {
    return (
      e +
      (i.value
        ? `
` + i.value
        : "") +
      `
` +
      n
    );
  }
}
function cO(t, e) {
  return t.marker ? XC(t.marker, e).repeat(3) : XC(t.fence, e);
}
function XC(t, e) {
  return typeof t == "string" ? t : t[e];
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ function _3(t) {
  return typeof t > "u" || t === null;
}
function Fq(t) {
  return typeof t == "object" && t !== null;
}
function Bq(t) {
  return Array.isArray(t) ? t : _3(t) ? [] : [t];
}
function Vq(t, e) {
  var n, r, i, o;
  if (e) for (o = Object.keys(e), n = 0, r = o.length; n < r; n += 1) (i = o[n]), (t[i] = e[i]);
  return t;
}
function jq(t, e) {
  var n = "",
    r;
  for (r = 0; r < e; r += 1) n += t;
  return n;
}
function Zq(t) {
  return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
var zq = _3,
  Wq = Fq,
  Xq = Bq,
  Uq = jq,
  Hq = Zq,
  qq = Vq,
  qt = { isNothing: zq, isObject: Wq, toArray: Xq, repeat: Uq, isNegativeZero: Hq, extend: qq };
function E3(t, e) {
  var n = "",
    r = t.reason || "(unknown reason)";
  return t.mark
    ? (t.mark.name && (n += 'in "' + t.mark.name + '" '),
      (n += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")"),
      !e &&
        t.mark.snippet &&
        (n +=
          `

` + t.mark.snippet),
      r + " " + n)
    : r;
}
function hu(t, e) {
  Error.call(this),
    (this.name = "YAMLException"),
    (this.reason = t),
    (this.mark = e),
    (this.message = E3(this, !1)),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack || "");
}
hu.prototype = Object.create(Error.prototype);
hu.prototype.constructor = hu;
hu.prototype.toString = function (e) {
  return this.name + ": " + E3(this, e);
};
var _n = hu;
function Jg(t, e, n, r, i) {
  var o = "",
    s = "",
    l = Math.floor(i / 2) - 1;
  return (
    r - e > l && ((o = " ... "), (e = r - l + o.length)),
    n - r > l && ((s = " ..."), (n = r + l - s.length)),
    { str: o + t.slice(e, n).replace(/\t/g, "→") + s, pos: r - e + o.length }
  );
}
function Kg(t, e) {
  return qt.repeat(" ", e - t.length) + t;
}
function Yq(t, e) {
  if (((e = Object.create(e || null)), !t.buffer)) return null;
  e.maxLength || (e.maxLength = 79),
    typeof e.indent != "number" && (e.indent = 1),
    typeof e.linesBefore != "number" && (e.linesBefore = 3),
    typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], o, s = -1; (o = n.exec(t.buffer)); )
    i.push(o.index), r.push(o.index + o[0].length), t.position <= o.index && s < 0 && (s = r.length - 2);
  s < 0 && (s = r.length - 1);
  var l = "",
    a,
    c,
    u = Math.min(t.line + e.linesAfter, i.length).toString().length,
    h = e.maxLength - (e.indent + u + 3);
  for (a = 1; a <= e.linesBefore && !(s - a < 0); a++)
    (c = Jg(t.buffer, r[s - a], i[s - a], t.position - (r[s] - r[s - a]), h)),
      (l =
        qt.repeat(" ", e.indent) +
        Kg((t.line - a + 1).toString(), u) +
        " | " +
        c.str +
        `
` +
        l);
  for (
    c = Jg(t.buffer, r[s], i[s], t.position, h),
      l +=
        qt.repeat(" ", e.indent) +
        Kg((t.line + 1).toString(), u) +
        " | " +
        c.str +
        `
`,
      l +=
        qt.repeat("-", e.indent + u + 3 + c.pos) +
        `^
`,
      a = 1;
    a <= e.linesAfter && !(s + a >= i.length);
    a++
  )
    (c = Jg(t.buffer, r[s + a], i[s + a], t.position - (r[s] - r[s + a]), h)),
      (l +=
        qt.repeat(" ", e.indent) +
        Kg((t.line + a + 1).toString(), u) +
        " | " +
        c.str +
        `
`);
  return l.replace(/\n$/, "");
}
var Gq = Yq,
  Jq = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"],
  Kq = ["scalar", "sequence", "mapping"];
function eY(t) {
  var e = {};
  return (
    t !== null &&
      Object.keys(t).forEach(function (n) {
        t[n].forEach(function (r) {
          e[String(r)] = n;
        });
      }),
    e
  );
}
function tY(t, e) {
  if (
    ((e = e || {}),
    Object.keys(e).forEach(function (n) {
      if (Jq.indexOf(n) === -1) throw new _n('Unknown option "' + n + '" is met in definition of "' + t + '" YAML type.');
    }),
    (this.options = e),
    (this.tag = t),
    (this.kind = e.kind || null),
    (this.resolve =
      e.resolve ||
      function () {
        return !0;
      }),
    (this.construct =
      e.construct ||
      function (n) {
        return n;
      }),
    (this.instanceOf = e.instanceOf || null),
    (this.predicate = e.predicate || null),
    (this.represent = e.represent || null),
    (this.representName = e.representName || null),
    (this.defaultStyle = e.defaultStyle || null),
    (this.multi = e.multi || !1),
    (this.styleAliases = eY(e.styleAliases || null)),
    Kq.indexOf(this.kind) === -1)
  )
    throw new _n('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
}
var fn = tY;
function UC(t, e) {
  var n = [];
  return (
    t[e].forEach(function (r) {
      var i = n.length;
      n.forEach(function (o, s) {
        o.tag === r.tag && o.kind === r.kind && o.multi === r.multi && (i = s);
      }),
        (n[i] = r);
    }),
    n
  );
}
function nY() {
  var t = { scalar: {}, sequence: {}, mapping: {}, fallback: {}, multi: { scalar: [], sequence: [], mapping: [], fallback: [] } },
    e,
    n;
  function r(i) {
    i.multi ? (t.multi[i.kind].push(i), t.multi.fallback.push(i)) : (t[i.kind][i.tag] = t.fallback[i.tag] = i);
  }
  for (e = 0, n = arguments.length; e < n; e += 1) arguments[e].forEach(r);
  return t;
}
function uO(t) {
  return this.extend(t);
}
uO.prototype.extend = function (e) {
  var n = [],
    r = [];
  if (e instanceof fn) r.push(e);
  else if (Array.isArray(e)) r = r.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (n = n.concat(e.implicit)), e.explicit && (r = r.concat(e.explicit));
  else throw new _n("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function (o) {
    if (!(o instanceof fn)) throw new _n("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (o.loadKind && o.loadKind !== "scalar")
      throw new _n("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (o.multi) throw new _n("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }),
    r.forEach(function (o) {
      if (!(o instanceof fn)) throw new _n("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
  var i = Object.create(uO.prototype);
  return (
    (i.implicit = (this.implicit || []).concat(n)),
    (i.explicit = (this.explicit || []).concat(r)),
    (i.compiledImplicit = UC(i, "implicit")),
    (i.compiledExplicit = UC(i, "explicit")),
    (i.compiledTypeMap = nY(i.compiledImplicit, i.compiledExplicit)),
    i
  );
};
var T3 = uO,
  P3 = new fn("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function (t) {
      return t !== null ? t : "";
    },
  }),
  A3 = new fn("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function (t) {
      return t !== null ? t : [];
    },
  }),
  $3 = new fn("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function (t) {
      return t !== null ? t : {};
    },
  }),
  R3 = new T3({ explicit: [P3, A3, $3] });
function rY(t) {
  if (t === null) return !0;
  var e = t.length;
  return (e === 1 && t === "~") || (e === 4 && (t === "null" || t === "Null" || t === "NULL"));
}
function iY() {
  return null;
}
function oY(t) {
  return t === null;
}
var I3 = new fn("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: rY,
  construct: iY,
  predicate: oY,
  represent: {
    canonical: function () {
      return "~";
    },
    lowercase: function () {
      return "null";
    },
    uppercase: function () {
      return "NULL";
    },
    camelcase: function () {
      return "Null";
    },
    empty: function () {
      return "";
    },
  },
  defaultStyle: "lowercase",
});
function sY(t) {
  if (t === null) return !1;
  var e = t.length;
  return (e === 4 && (t === "true" || t === "True" || t === "TRUE")) || (e === 5 && (t === "false" || t === "False" || t === "FALSE"));
}
function lY(t) {
  return t === "true" || t === "True" || t === "TRUE";
}
function aY(t) {
  return Object.prototype.toString.call(t) === "[object Boolean]";
}
var M3 = new fn("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: sY,
  construct: lY,
  predicate: aY,
  represent: {
    lowercase: function (t) {
      return t ? "true" : "false";
    },
    uppercase: function (t) {
      return t ? "TRUE" : "FALSE";
    },
    camelcase: function (t) {
      return t ? "True" : "False";
    },
  },
  defaultStyle: "lowercase",
});
function cY(t) {
  return (48 <= t && t <= 57) || (65 <= t && t <= 70) || (97 <= t && t <= 102);
}
function uY(t) {
  return 48 <= t && t <= 55;
}
function hY(t) {
  return 48 <= t && t <= 57;
}
function dY(t) {
  if (t === null) return !1;
  var e = t.length,
    n = 0,
    r = !1,
    i;
  if (!e) return !1;
  if (((i = t[n]), (i === "-" || i === "+") && (i = t[++n]), i === "0")) {
    if (n + 1 === e) return !0;
    if (((i = t[++n]), i === "b")) {
      for (n++; n < e; n++)
        if (((i = t[n]), i !== "_")) {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < e; n++)
        if (((i = t[n]), i !== "_")) {
          if (!cY(t.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < e; n++)
        if (((i = t[n]), i !== "_")) {
          if (!uY(t.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < e; n++)
    if (((i = t[n]), i !== "_")) {
      if (!hY(t.charCodeAt(n))) return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function fY(t) {
  var e = t,
    n = 1,
    r;
  if (
    (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")),
    (r = e[0]),
    (r === "-" || r === "+") && (r === "-" && (n = -1), (e = e.slice(1)), (r = e[0])),
    e === "0")
  )
    return 0;
  if (r === "0") {
    if (e[1] === "b") return n * parseInt(e.slice(2), 2);
    if (e[1] === "x") return n * parseInt(e.slice(2), 16);
    if (e[1] === "o") return n * parseInt(e.slice(2), 8);
  }
  return n * parseInt(e, 10);
}
function pY(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !qt.isNegativeZero(t);
}
var L3 = new fn("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: dY,
    construct: fY,
    predicate: pY,
    represent: {
      binary: function (t) {
        return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
      },
      octal: function (t) {
        return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
      },
      decimal: function (t) {
        return t.toString(10);
      },
      hexadecimal: function (t) {
        return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
      },
    },
    defaultStyle: "decimal",
    styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] },
  }),
  mY = new RegExp(
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
function gY(t) {
  return !(t === null || !mY.test(t) || t[t.length - 1] === "_");
}
function OY(t) {
  var e, n;
  return (
    (e = t.replace(/_/g, "").toLowerCase()),
    (n = e[0] === "-" ? -1 : 1),
    "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)),
    e === ".inf" ? (n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY) : e === ".nan" ? NaN : n * parseFloat(e, 10)
  );
}
var vY = /^[-+]?[0-9]+e/;
function bY(t, e) {
  var n;
  if (isNaN(t))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (qt.isNegativeZero(t)) return "-0.0";
  return (n = t.toString(10)), vY.test(n) ? n.replace("e", ".e") : n;
}
function xY(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || qt.isNegativeZero(t));
}
var N3 = new fn("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: gY,
    construct: OY,
    predicate: xY,
    represent: bY,
    defaultStyle: "lowercase",
  }),
  Q3 = R3.extend({ implicit: [I3, M3, L3, N3] }),
  D3 = Q3,
  F3 = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
  B3 = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
function yY(t) {
  return t === null ? !1 : F3.exec(t) !== null || B3.exec(t) !== null;
}
function wY(t) {
  var e,
    n,
    r,
    i,
    o,
    s,
    l,
    a = 0,
    c = null,
    u,
    h,
    d;
  if (((e = F3.exec(t)), e === null && (e = B3.exec(t)), e === null)) throw new Error("Date resolve error");
  if (((n = +e[1]), (r = +e[2] - 1), (i = +e[3]), !e[4])) return new Date(Date.UTC(n, r, i));
  if (((o = +e[4]), (s = +e[5]), (l = +e[6]), e[7])) {
    for (a = e[7].slice(0, 3); a.length < 3; ) a += "0";
    a = +a;
  }
  return (
    e[9] && ((u = +e[10]), (h = +(e[11] || 0)), (c = (u * 60 + h) * 6e4), e[9] === "-" && (c = -c)),
    (d = new Date(Date.UTC(n, r, i, o, s, l, a))),
    c && d.setTime(d.getTime() - c),
    d
  );
}
function SY(t) {
  return t.toISOString();
}
var V3 = new fn("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: yY, construct: wY, instanceOf: Date, represent: SY });
function kY(t) {
  return t === "<<" || t === null;
}
var j3 = new fn("tag:yaml.org,2002:merge", { kind: "scalar", resolve: kY }),
  dy = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function CY(t) {
  if (t === null) return !1;
  var e,
    n,
    r = 0,
    i = t.length,
    o = dy;
  for (n = 0; n < i; n++)
    if (((e = o.indexOf(t.charAt(n))), !(e > 64))) {
      if (e < 0) return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function _Y(t) {
  var e,
    n,
    r = t.replace(/[\r\n=]/g, ""),
    i = r.length,
    o = dy,
    s = 0,
    l = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (l.push((s >> 16) & 255), l.push((s >> 8) & 255), l.push(s & 255)), (s = (s << 6) | o.indexOf(r.charAt(e)));
  return (
    (n = (i % 4) * 6),
    n === 0
      ? (l.push((s >> 16) & 255), l.push((s >> 8) & 255), l.push(s & 255))
      : n === 18
      ? (l.push((s >> 10) & 255), l.push((s >> 2) & 255))
      : n === 12 && l.push((s >> 4) & 255),
    new Uint8Array(l)
  );
}
function EY(t) {
  var e = "",
    n = 0,
    r,
    i,
    o = t.length,
    s = dy;
  for (r = 0; r < o; r++)
    r % 3 === 0 && r && ((e += s[(n >> 18) & 63]), (e += s[(n >> 12) & 63]), (e += s[(n >> 6) & 63]), (e += s[n & 63])),
      (n = (n << 8) + t[r]);
  return (
    (i = o % 3),
    i === 0
      ? ((e += s[(n >> 18) & 63]), (e += s[(n >> 12) & 63]), (e += s[(n >> 6) & 63]), (e += s[n & 63]))
      : i === 2
      ? ((e += s[(n >> 10) & 63]), (e += s[(n >> 4) & 63]), (e += s[(n << 2) & 63]), (e += s[64]))
      : i === 1 && ((e += s[(n >> 2) & 63]), (e += s[(n << 4) & 63]), (e += s[64]), (e += s[64])),
    e
  );
}
function TY(t) {
  return Object.prototype.toString.call(t) === "[object Uint8Array]";
}
var Z3 = new fn("tag:yaml.org,2002:binary", { kind: "scalar", resolve: CY, construct: _Y, predicate: TY, represent: EY }),
  PY = Object.prototype.hasOwnProperty,
  AY = Object.prototype.toString;
function $Y(t) {
  if (t === null) return !0;
  var e = [],
    n,
    r,
    i,
    o,
    s,
    l = t;
  for (n = 0, r = l.length; n < r; n += 1) {
    if (((i = l[n]), (s = !1), AY.call(i) !== "[object Object]")) return !1;
    for (o in i)
      if (PY.call(i, o))
        if (!s) s = !0;
        else return !1;
    if (!s) return !1;
    if (e.indexOf(o) === -1) e.push(o);
    else return !1;
  }
  return !0;
}
function RY(t) {
  return t !== null ? t : [];
}
var z3 = new fn("tag:yaml.org,2002:omap", { kind: "sequence", resolve: $Y, construct: RY }),
  IY = Object.prototype.toString;
function MY(t) {
  if (t === null) return !0;
  var e,
    n,
    r,
    i,
    o,
    s = t;
  for (o = new Array(s.length), e = 0, n = s.length; e < n; e += 1) {
    if (((r = s[e]), IY.call(r) !== "[object Object]" || ((i = Object.keys(r)), i.length !== 1))) return !1;
    o[e] = [i[0], r[i[0]]];
  }
  return !0;
}
function LY(t) {
  if (t === null) return [];
  var e,
    n,
    r,
    i,
    o,
    s = t;
  for (o = new Array(s.length), e = 0, n = s.length; e < n; e += 1) (r = s[e]), (i = Object.keys(r)), (o[e] = [i[0], r[i[0]]]);
  return o;
}
var W3 = new fn("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: MY, construct: LY }),
  NY = Object.prototype.hasOwnProperty;
function QY(t) {
  if (t === null) return !0;
  var e,
    n = t;
  for (e in n) if (NY.call(n, e) && n[e] !== null) return !1;
  return !0;
}
function DY(t) {
  return t !== null ? t : {};
}
var X3 = new fn("tag:yaml.org,2002:set", { kind: "mapping", resolve: QY, construct: DY }),
  fy = D3.extend({ implicit: [V3, j3], explicit: [Z3, z3, W3, X3] }),
  Bo = Object.prototype.hasOwnProperty,
  ep = 1,
  U3 = 2,
  H3 = 3,
  tp = 4,
  e1 = 1,
  FY = 2,
  HC = 3,
  BY =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  VY = /[\x85\u2028\u2029]/,
  jY = /[,\[\]\{\}]/,
  q3 = /^(?:!|!!|![a-z\-]+!)$/i,
  Y3 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function qC(t) {
  return Object.prototype.toString.call(t);
}
function di(t) {
  return t === 10 || t === 13;
}
function xs(t) {
  return t === 9 || t === 32;
}
function Vn(t) {
  return t === 9 || t === 32 || t === 10 || t === 13;
}
function Ol(t) {
  return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
function ZY(t) {
  var e;
  return 48 <= t && t <= 57 ? t - 48 : ((e = t | 32), 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function zY(t) {
  return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
function WY(t) {
  return 48 <= t && t <= 57 ? t - 48 : -1;
}
function YC(t) {
  return t === 48
    ? "\0"
    : t === 97
    ? "\x07"
    : t === 98
    ? "\b"
    : t === 116 || t === 9
    ? "	"
    : t === 110
    ? `
`
    : t === 118
    ? "\v"
    : t === 102
    ? "\f"
    : t === 114
    ? "\r"
    : t === 101
    ? "\x1B"
    : t === 32
    ? " "
    : t === 34
    ? '"'
    : t === 47
    ? "/"
    : t === 92
    ? "\\"
    : t === 78
    ? ""
    : t === 95
    ? " "
    : t === 76
    ? "\u2028"
    : t === 80
    ? "\u2029"
    : "";
}
function XY(t) {
  return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode(((t - 65536) >> 10) + 55296, ((t - 65536) & 1023) + 56320);
}
var G3 = new Array(256),
  J3 = new Array(256);
for (var nl = 0; nl < 256; nl++) (G3[nl] = YC(nl) ? 1 : 0), (J3[nl] = YC(nl));
function UY(t, e) {
  (this.input = t),
    (this.filename = e.filename || null),
    (this.schema = e.schema || fy),
    (this.onWarning = e.onWarning || null),
    (this.legacy = e.legacy || !1),
    (this.json = e.json || !1),
    (this.listener = e.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = t.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = []);
}
function K3(t, e) {
  var n = { name: t.filename, buffer: t.input.slice(0, -1), position: t.position, line: t.line, column: t.position - t.lineStart };
  return (n.snippet = Gq(n)), new _n(e, n);
}
function Ce(t, e) {
  throw K3(t, e);
}
function np(t, e) {
  t.onWarning && t.onWarning.call(null, K3(t, e));
}
var GC = {
  YAML: function (e, n, r) {
    var i, o, s;
    e.version !== null && Ce(e, "duplication of %YAML directive"),
      r.length !== 1 && Ce(e, "YAML directive accepts exactly one argument"),
      (i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])),
      i === null && Ce(e, "ill-formed argument of the YAML directive"),
      (o = parseInt(i[1], 10)),
      (s = parseInt(i[2], 10)),
      o !== 1 && Ce(e, "unacceptable YAML version of the document"),
      (e.version = r[0]),
      (e.checkLineBreaks = s < 2),
      s !== 1 && s !== 2 && np(e, "unsupported YAML version of the document");
  },
  TAG: function (e, n, r) {
    var i, o;
    r.length !== 2 && Ce(e, "TAG directive accepts exactly two arguments"),
      (i = r[0]),
      (o = r[1]),
      q3.test(i) || Ce(e, "ill-formed tag handle (first argument) of the TAG directive"),
      Bo.call(e.tagMap, i) && Ce(e, 'there is a previously declared suffix for "' + i + '" tag handle'),
      Y3.test(o) || Ce(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      o = decodeURIComponent(o);
    } catch {
      Ce(e, "tag prefix is malformed: " + o);
    }
    e.tagMap[i] = o;
  },
};
function To(t, e, n, r) {
  var i, o, s, l;
  if (e < n) {
    if (((l = t.input.slice(e, n)), r))
      for (i = 0, o = l.length; i < o; i += 1)
        (s = l.charCodeAt(i)), s === 9 || (32 <= s && s <= 1114111) || Ce(t, "expected valid JSON character");
    else BY.test(l) && Ce(t, "the stream contains non-printable characters");
    t.result += l;
  }
}
function JC(t, e, n, r) {
  var i, o, s, l;
  for (
    qt.isObject(n) || Ce(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), s = 0, l = i.length;
    s < l;
    s += 1
  )
    (o = i[s]), Bo.call(e, o) || ((e[o] = n[o]), (r[o] = !0));
}
function vl(t, e, n, r, i, o, s, l, a) {
  var c, u;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, u = i.length; c < u; c += 1)
      Array.isArray(i[c]) && Ce(t, "nested arrays are not supported inside keys"),
        typeof i == "object" && qC(i[c]) === "[object Object]" && (i[c] = "[object Object]");
  if (
    (typeof i == "object" && qC(i) === "[object Object]" && (i = "[object Object]"),
    (i = String(i)),
    e === null && (e = {}),
    r === "tag:yaml.org,2002:merge")
  )
    if (Array.isArray(o)) for (c = 0, u = o.length; c < u; c += 1) JC(t, e, o[c], n);
    else JC(t, e, o, n);
  else
    !t.json &&
      !Bo.call(n, i) &&
      Bo.call(e, i) &&
      ((t.line = s || t.line), (t.lineStart = l || t.lineStart), (t.position = a || t.position), Ce(t, "duplicated mapping key")),
      i === "__proto__" ? Object.defineProperty(e, i, { configurable: !0, enumerable: !0, writable: !0, value: o }) : (e[i] = o),
      delete n[i];
  return e;
}
function py(t) {
  var e;
  (e = t.input.charCodeAt(t.position)),
    e === 10
      ? t.position++
      : e === 13
      ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++)
      : Ce(t, "a line break is expected"),
    (t.line += 1),
    (t.lineStart = t.position),
    (t.firstTabInLine = -1);
}
function Zt(t, e, n) {
  for (var r = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
    for (; xs(i); ) i === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), (i = t.input.charCodeAt(++t.position));
    if (e && i === 35)
      do i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (di(i))
      for (py(t), i = t.input.charCodeAt(t.position), r++, t.lineIndent = 0; i === 32; )
        t.lineIndent++, (i = t.input.charCodeAt(++t.position));
    else break;
  }
  return n !== -1 && r !== 0 && t.lineIndent < n && np(t, "deficient indentation"), r;
}
function Zm(t) {
  var e = t.position,
    n;
  return (
    (n = t.input.charCodeAt(e)),
    !!(
      (n === 45 || n === 46) &&
      n === t.input.charCodeAt(e + 1) &&
      n === t.input.charCodeAt(e + 2) &&
      ((e += 3), (n = t.input.charCodeAt(e)), n === 0 || Vn(n))
    )
  );
}
function my(t, e) {
  e === 1
    ? (t.result += " ")
    : e > 1 &&
      (t.result += qt.repeat(
        `
`,
        e - 1
      ));
}
function HY(t, e, n) {
  var r,
    i,
    o,
    s,
    l,
    a,
    c,
    u,
    h = t.kind,
    d = t.result,
    f;
  if (
    ((f = t.input.charCodeAt(t.position)),
    Vn(f) ||
      Ol(f) ||
      f === 35 ||
      f === 38 ||
      f === 42 ||
      f === 33 ||
      f === 124 ||
      f === 62 ||
      f === 39 ||
      f === 34 ||
      f === 37 ||
      f === 64 ||
      f === 96 ||
      ((f === 63 || f === 45) && ((i = t.input.charCodeAt(t.position + 1)), Vn(i) || (n && Ol(i)))))
  )
    return !1;
  for (t.kind = "scalar", t.result = "", o = s = t.position, l = !1; f !== 0; ) {
    if (f === 58) {
      if (((i = t.input.charCodeAt(t.position + 1)), Vn(i) || (n && Ol(i)))) break;
    } else if (f === 35) {
      if (((r = t.input.charCodeAt(t.position - 1)), Vn(r))) break;
    } else {
      if ((t.position === t.lineStart && Zm(t)) || (n && Ol(f))) break;
      if (di(f))
        if (((a = t.line), (c = t.lineStart), (u = t.lineIndent), Zt(t, !1, -1), t.lineIndent >= e)) {
          (l = !0), (f = t.input.charCodeAt(t.position));
          continue;
        } else {
          (t.position = s), (t.line = a), (t.lineStart = c), (t.lineIndent = u);
          break;
        }
    }
    l && (To(t, o, s, !1), my(t, t.line - a), (o = s = t.position), (l = !1)),
      xs(f) || (s = t.position + 1),
      (f = t.input.charCodeAt(++t.position));
  }
  return To(t, o, s, !1), t.result ? !0 : ((t.kind = h), (t.result = d), !1);
}
function qY(t, e) {
  var n, r, i;
  if (((n = t.input.charCodeAt(t.position)), n !== 39)) return !1;
  for (t.kind = "scalar", t.result = "", t.position++, r = i = t.position; (n = t.input.charCodeAt(t.position)) !== 0; )
    if (n === 39)
      if ((To(t, r, t.position, !0), (n = t.input.charCodeAt(++t.position)), n === 39)) (r = t.position), t.position++, (i = t.position);
      else return !0;
    else
      di(n)
        ? (To(t, r, i, !0), my(t, Zt(t, !1, e)), (r = i = t.position))
        : t.position === t.lineStart && Zm(t)
        ? Ce(t, "unexpected end of the document within a single quoted scalar")
        : (t.position++, (i = t.position));
  Ce(t, "unexpected end of the stream within a single quoted scalar");
}
function YY(t, e) {
  var n, r, i, o, s, l;
  if (((l = t.input.charCodeAt(t.position)), l !== 34)) return !1;
  for (t.kind = "scalar", t.result = "", t.position++, n = r = t.position; (l = t.input.charCodeAt(t.position)) !== 0; ) {
    if (l === 34) return To(t, n, t.position, !0), t.position++, !0;
    if (l === 92) {
      if ((To(t, n, t.position, !0), (l = t.input.charCodeAt(++t.position)), di(l))) Zt(t, !1, e);
      else if (l < 256 && G3[l]) (t.result += J3[l]), t.position++;
      else if ((s = zY(l)) > 0) {
        for (i = s, o = 0; i > 0; i--)
          (l = t.input.charCodeAt(++t.position)), (s = ZY(l)) >= 0 ? (o = (o << 4) + s) : Ce(t, "expected hexadecimal character");
        (t.result += XY(o)), t.position++;
      } else Ce(t, "unknown escape sequence");
      n = r = t.position;
    } else
      di(l)
        ? (To(t, n, r, !0), my(t, Zt(t, !1, e)), (n = r = t.position))
        : t.position === t.lineStart && Zm(t)
        ? Ce(t, "unexpected end of the document within a double quoted scalar")
        : (t.position++, (r = t.position));
  }
  Ce(t, "unexpected end of the stream within a double quoted scalar");
}
function GY(t, e) {
  var n = !0,
    r,
    i,
    o,
    s = t.tag,
    l,
    a = t.anchor,
    c,
    u,
    h,
    d,
    f,
    p = Object.create(null),
    m,
    O,
    v,
    g;
  if (((g = t.input.charCodeAt(t.position)), g === 91)) (u = 93), (f = !1), (l = []);
  else if (g === 123) (u = 125), (f = !0), (l = {});
  else return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = l), g = t.input.charCodeAt(++t.position); g !== 0; ) {
    if ((Zt(t, !0, e), (g = t.input.charCodeAt(t.position)), g === u))
      return t.position++, (t.tag = s), (t.anchor = a), (t.kind = f ? "mapping" : "sequence"), (t.result = l), !0;
    n ? g === 44 && Ce(t, "expected the node content, but found ','") : Ce(t, "missed comma between flow collection entries"),
      (O = m = v = null),
      (h = d = !1),
      g === 63 && ((c = t.input.charCodeAt(t.position + 1)), Vn(c) && ((h = d = !0), t.position++, Zt(t, !0, e))),
      (r = t.line),
      (i = t.lineStart),
      (o = t.position),
      ea(t, e, ep, !1, !0),
      (O = t.tag),
      (m = t.result),
      Zt(t, !0, e),
      (g = t.input.charCodeAt(t.position)),
      (d || t.line === r) &&
        g === 58 &&
        ((h = !0), (g = t.input.charCodeAt(++t.position)), Zt(t, !0, e), ea(t, e, ep, !1, !0), (v = t.result)),
      f ? vl(t, l, p, O, m, v, r, i, o) : h ? l.push(vl(t, null, p, O, m, v, r, i, o)) : l.push(m),
      Zt(t, !0, e),
      (g = t.input.charCodeAt(t.position)),
      g === 44 ? ((n = !0), (g = t.input.charCodeAt(++t.position))) : (n = !1);
  }
  Ce(t, "unexpected end of the stream within a flow collection");
}
function JY(t, e) {
  var n,
    r,
    i = e1,
    o = !1,
    s = !1,
    l = e,
    a = 0,
    c = !1,
    u,
    h;
  if (((h = t.input.charCodeAt(t.position)), h === 124)) r = !1;
  else if (h === 62) r = !0;
  else return !1;
  for (t.kind = "scalar", t.result = ""; h !== 0; )
    if (((h = t.input.charCodeAt(++t.position)), h === 43 || h === 45))
      e1 === i ? (i = h === 43 ? HC : FY) : Ce(t, "repeat of a chomping mode identifier");
    else if ((u = WY(h)) >= 0)
      u === 0
        ? Ce(t, "bad explicit indentation width of a block scalar; it cannot be less than one")
        : s
        ? Ce(t, "repeat of an indentation width identifier")
        : ((l = e + u - 1), (s = !0));
    else break;
  if (xs(h)) {
    do h = t.input.charCodeAt(++t.position);
    while (xs(h));
    if (h === 35)
      do h = t.input.charCodeAt(++t.position);
      while (!di(h) && h !== 0);
  }
  for (; h !== 0; ) {
    for (py(t), t.lineIndent = 0, h = t.input.charCodeAt(t.position); (!s || t.lineIndent < l) && h === 32; )
      t.lineIndent++, (h = t.input.charCodeAt(++t.position));
    if ((!s && t.lineIndent > l && (l = t.lineIndent), di(h))) {
      a++;
      continue;
    }
    if (t.lineIndent < l) {
      i === HC
        ? (t.result += qt.repeat(
            `
`,
            o ? 1 + a : a
          ))
        : i === e1 &&
          o &&
          (t.result += `
`);
      break;
    }
    for (
      r
        ? xs(h)
          ? ((c = !0),
            (t.result += qt.repeat(
              `
`,
              o ? 1 + a : a
            )))
          : c
          ? ((c = !1),
            (t.result += qt.repeat(
              `
`,
              a + 1
            )))
          : a === 0
          ? o && (t.result += " ")
          : (t.result += qt.repeat(
              `
`,
              a
            ))
        : (t.result += qt.repeat(
            `
`,
            o ? 1 + a : a
          )),
        o = !0,
        s = !0,
        a = 0,
        n = t.position;
      !di(h) && h !== 0;

    )
      h = t.input.charCodeAt(++t.position);
    To(t, n, t.position, !1);
  }
  return !0;
}
function KC(t, e) {
  var n,
    r = t.tag,
    i = t.anchor,
    o = [],
    s,
    l = !1,
    a;
  if (t.firstTabInLine !== -1) return !1;
  for (
    t.anchor !== null && (t.anchorMap[t.anchor] = o), a = t.input.charCodeAt(t.position);
    a !== 0 &&
    (t.firstTabInLine !== -1 && ((t.position = t.firstTabInLine), Ce(t, "tab characters must not be used in indentation")),
    !(a !== 45 || ((s = t.input.charCodeAt(t.position + 1)), !Vn(s))));

  ) {
    if (((l = !0), t.position++, Zt(t, !0, -1) && t.lineIndent <= e)) {
      o.push(null), (a = t.input.charCodeAt(t.position));
      continue;
    }
    if (
      ((n = t.line),
      ea(t, e, H3, !1, !0),
      o.push(t.result),
      Zt(t, !0, -1),
      (a = t.input.charCodeAt(t.position)),
      (t.line === n || t.lineIndent > e) && a !== 0)
    )
      Ce(t, "bad indentation of a sequence entry");
    else if (t.lineIndent < e) break;
  }
  return l ? ((t.tag = r), (t.anchor = i), (t.kind = "sequence"), (t.result = o), !0) : !1;
}
function KY(t, e, n) {
  var r,
    i,
    o,
    s,
    l,
    a,
    c = t.tag,
    u = t.anchor,
    h = {},
    d = Object.create(null),
    f = null,
    p = null,
    m = null,
    O = !1,
    v = !1,
    g;
  if (t.firstTabInLine !== -1) return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = h), g = t.input.charCodeAt(t.position); g !== 0; ) {
    if (
      (!O && t.firstTabInLine !== -1 && ((t.position = t.firstTabInLine), Ce(t, "tab characters must not be used in indentation")),
      (r = t.input.charCodeAt(t.position + 1)),
      (o = t.line),
      (g === 63 || g === 58) && Vn(r))
    )
      g === 63
        ? (O && (vl(t, h, d, f, p, null, s, l, a), (f = p = m = null)), (v = !0), (O = !0), (i = !0))
        : O
        ? ((O = !1), (i = !0))
        : Ce(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"),
        (t.position += 1),
        (g = r);
    else {
      if (((s = t.line), (l = t.lineStart), (a = t.position), !ea(t, n, U3, !1, !0))) break;
      if (t.line === o) {
        for (g = t.input.charCodeAt(t.position); xs(g); ) g = t.input.charCodeAt(++t.position);
        if (g === 58)
          (g = t.input.charCodeAt(++t.position)),
            Vn(g) || Ce(t, "a whitespace character is expected after the key-value separator within a block mapping"),
            O && (vl(t, h, d, f, p, null, s, l, a), (f = p = m = null)),
            (v = !0),
            (O = !1),
            (i = !1),
            (f = t.tag),
            (p = t.result);
        else if (v) Ce(t, "can not read an implicit mapping pair; a colon is missed");
        else return (t.tag = c), (t.anchor = u), !0;
      } else if (v) Ce(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else return (t.tag = c), (t.anchor = u), !0;
    }
    if (
      ((t.line === o || t.lineIndent > e) &&
        (O && ((s = t.line), (l = t.lineStart), (a = t.position)),
        ea(t, e, tp, !0, i) && (O ? (p = t.result) : (m = t.result)),
        O || (vl(t, h, d, f, p, m, s, l, a), (f = p = m = null)),
        Zt(t, !0, -1),
        (g = t.input.charCodeAt(t.position))),
      (t.line === o || t.lineIndent > e) && g !== 0)
    )
      Ce(t, "bad indentation of a mapping entry");
    else if (t.lineIndent < e) break;
  }
  return O && vl(t, h, d, f, p, null, s, l, a), v && ((t.tag = c), (t.anchor = u), (t.kind = "mapping"), (t.result = h)), v;
}
function eG(t) {
  var e,
    n = !1,
    r = !1,
    i,
    o,
    s;
  if (((s = t.input.charCodeAt(t.position)), s !== 33)) return !1;
  if (
    (t.tag !== null && Ce(t, "duplication of a tag property"),
    (s = t.input.charCodeAt(++t.position)),
    s === 60
      ? ((n = !0), (s = t.input.charCodeAt(++t.position)))
      : s === 33
      ? ((r = !0), (i = "!!"), (s = t.input.charCodeAt(++t.position)))
      : (i = "!"),
    (e = t.position),
    n)
  ) {
    do s = t.input.charCodeAt(++t.position);
    while (s !== 0 && s !== 62);
    t.position < t.length
      ? ((o = t.input.slice(e, t.position)), (s = t.input.charCodeAt(++t.position)))
      : Ce(t, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !Vn(s); )
      s === 33 &&
        (r
          ? Ce(t, "tag suffix cannot contain exclamation marks")
          : ((i = t.input.slice(e - 1, t.position + 1)),
            q3.test(i) || Ce(t, "named tag handle cannot contain such characters"),
            (r = !0),
            (e = t.position + 1))),
        (s = t.input.charCodeAt(++t.position));
    (o = t.input.slice(e, t.position)), jY.test(o) && Ce(t, "tag suffix cannot contain flow indicator characters");
  }
  o && !Y3.test(o) && Ce(t, "tag name cannot contain such characters: " + o);
  try {
    o = decodeURIComponent(o);
  } catch {
    Ce(t, "tag name is malformed: " + o);
  }
  return (
    n
      ? (t.tag = o)
      : Bo.call(t.tagMap, i)
      ? (t.tag = t.tagMap[i] + o)
      : i === "!"
      ? (t.tag = "!" + o)
      : i === "!!"
      ? (t.tag = "tag:yaml.org,2002:" + o)
      : Ce(t, 'undeclared tag handle "' + i + '"'),
    !0
  );
}
function tG(t) {
  var e, n;
  if (((n = t.input.charCodeAt(t.position)), n !== 38)) return !1;
  for (
    t.anchor !== null && Ce(t, "duplication of an anchor property"), n = t.input.charCodeAt(++t.position), e = t.position;
    n !== 0 && !Vn(n) && !Ol(n);

  )
    n = t.input.charCodeAt(++t.position);
  return (
    t.position === e && Ce(t, "name of an anchor node must contain at least one character"), (t.anchor = t.input.slice(e, t.position)), !0
  );
}
function nG(t) {
  var e, n, r;
  if (((r = t.input.charCodeAt(t.position)), r !== 42)) return !1;
  for (r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !Vn(r) && !Ol(r); ) r = t.input.charCodeAt(++t.position);
  return (
    t.position === e && Ce(t, "name of an alias node must contain at least one character"),
    (n = t.input.slice(e, t.position)),
    Bo.call(t.anchorMap, n) || Ce(t, 'unidentified alias "' + n + '"'),
    (t.result = t.anchorMap[n]),
    Zt(t, !0, -1),
    !0
  );
}
function ea(t, e, n, r, i) {
  var o,
    s,
    l,
    a = 1,
    c = !1,
    u = !1,
    h,
    d,
    f,
    p,
    m,
    O;
  if (
    (t.listener !== null && t.listener("open", t),
    (t.tag = null),
    (t.anchor = null),
    (t.kind = null),
    (t.result = null),
    (o = s = l = tp === n || H3 === n),
    r && Zt(t, !0, -1) && ((c = !0), t.lineIndent > e ? (a = 1) : t.lineIndent === e ? (a = 0) : t.lineIndent < e && (a = -1)),
    a === 1)
  )
    for (; eG(t) || tG(t); )
      Zt(t, !0, -1)
        ? ((c = !0), (l = o), t.lineIndent > e ? (a = 1) : t.lineIndent === e ? (a = 0) : t.lineIndent < e && (a = -1))
        : (l = !1);
  if (
    (l && (l = c || i),
    (a === 1 || tp === n) &&
      (ep === n || U3 === n ? (m = e) : (m = e + 1),
      (O = t.position - t.lineStart),
      a === 1
        ? (l && (KC(t, O) || KY(t, O, m))) || GY(t, m)
          ? (u = !0)
          : ((s && JY(t, m)) || qY(t, m) || YY(t, m)
              ? (u = !0)
              : nG(t)
              ? ((u = !0), (t.tag !== null || t.anchor !== null) && Ce(t, "alias node should not have any properties"))
              : HY(t, m, ep === n) && ((u = !0), t.tag === null && (t.tag = "?")),
            t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
        : a === 0 && (u = l && KC(t, O))),
    t.tag === null)
  )
    t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
  else if (t.tag === "?") {
    for (
      t.result !== null && t.kind !== "scalar" && Ce(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'),
        h = 0,
        d = t.implicitTypes.length;
      h < d;
      h += 1
    )
      if (((p = t.implicitTypes[h]), p.resolve(t.result))) {
        (t.result = p.construct(t.result)), (t.tag = p.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
  } else if (t.tag !== "!") {
    if (Bo.call(t.typeMap[t.kind || "fallback"], t.tag)) p = t.typeMap[t.kind || "fallback"][t.tag];
    else
      for (p = null, f = t.typeMap.multi[t.kind || "fallback"], h = 0, d = f.length; h < d; h += 1)
        if (t.tag.slice(0, f[h].tag.length) === f[h].tag) {
          p = f[h];
          break;
        }
    p || Ce(t, "unknown tag !<" + t.tag + ">"),
      t.result !== null &&
        p.kind !== t.kind &&
        Ce(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + p.kind + '", not "' + t.kind + '"'),
      p.resolve(t.result, t.tag)
        ? ((t.result = p.construct(t.result, t.tag)), t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
        : Ce(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
  }
  return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || u;
}
function rG(t) {
  var e = t.position,
    n,
    r,
    i,
    o = !1,
    s;
  for (
    t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = Object.create(null), t.anchorMap = Object.create(null);
    (s = t.input.charCodeAt(t.position)) !== 0 && (Zt(t, !0, -1), (s = t.input.charCodeAt(t.position)), !(t.lineIndent > 0 || s !== 37));

  ) {
    for (o = !0, s = t.input.charCodeAt(++t.position), n = t.position; s !== 0 && !Vn(s); ) s = t.input.charCodeAt(++t.position);
    for (
      r = t.input.slice(n, t.position), i = [], r.length < 1 && Ce(t, "directive name must not be less than one character in length");
      s !== 0;

    ) {
      for (; xs(s); ) s = t.input.charCodeAt(++t.position);
      if (s === 35) {
        do s = t.input.charCodeAt(++t.position);
        while (s !== 0 && !di(s));
        break;
      }
      if (di(s)) break;
      for (n = t.position; s !== 0 && !Vn(s); ) s = t.input.charCodeAt(++t.position);
      i.push(t.input.slice(n, t.position));
    }
    s !== 0 && py(t), Bo.call(GC, r) ? GC[r](t, r, i) : np(t, 'unknown document directive "' + r + '"');
  }
  if (
    (Zt(t, !0, -1),
    t.lineIndent === 0 &&
    t.input.charCodeAt(t.position) === 45 &&
    t.input.charCodeAt(t.position + 1) === 45 &&
    t.input.charCodeAt(t.position + 2) === 45
      ? ((t.position += 3), Zt(t, !0, -1))
      : o && Ce(t, "directives end mark is expected"),
    ea(t, t.lineIndent - 1, tp, !1, !0),
    Zt(t, !0, -1),
    t.checkLineBreaks && VY.test(t.input.slice(e, t.position)) && np(t, "non-ASCII line breaks are interpreted as content"),
    t.documents.push(t.result),
    t.position === t.lineStart && Zm(t))
  ) {
    t.input.charCodeAt(t.position) === 46 && ((t.position += 3), Zt(t, !0, -1));
    return;
  }
  if (t.position < t.length - 1) Ce(t, "end of the stream or a document separator is expected");
  else return;
}
function e9(t, e) {
  (t = String(t)),
    (e = e || {}),
    t.length !== 0 &&
      (t.charCodeAt(t.length - 1) !== 10 &&
        t.charCodeAt(t.length - 1) !== 13 &&
        (t += `
`),
      t.charCodeAt(0) === 65279 && (t = t.slice(1)));
  var n = new UY(t, e),
    r = t.indexOf("\0");
  for (r !== -1 && ((n.position = r), Ce(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    (n.lineIndent += 1), (n.position += 1);
  for (; n.position < n.length - 1; ) rG(n);
  return n.documents;
}
function iG(t, e, n) {
  e !== null && typeof e == "object" && typeof n > "u" && ((n = e), (e = null));
  var r = e9(t, n);
  if (typeof e != "function") return r;
  for (var i = 0, o = r.length; i < o; i += 1) e(r[i]);
}
function oG(t, e) {
  var n = e9(t, e);
  if (n.length !== 0) {
    if (n.length === 1) return n[0];
    throw new _n("expected a single document in the stream, but found more");
  }
}
var sG = iG,
  lG = oG,
  t9 = { loadAll: sG, load: lG },
  n9 = Object.prototype.toString,
  r9 = Object.prototype.hasOwnProperty,
  gy = 65279,
  aG = 9,
  du = 10,
  cG = 13,
  uG = 32,
  hG = 33,
  dG = 34,
  hO = 35,
  fG = 37,
  pG = 38,
  mG = 39,
  gG = 42,
  i9 = 44,
  OG = 45,
  rp = 58,
  vG = 61,
  bG = 62,
  xG = 63,
  yG = 64,
  o9 = 91,
  s9 = 93,
  wG = 96,
  l9 = 123,
  SG = 124,
  a9 = 125,
  yn = {};
yn[0] = "\\0";
yn[7] = "\\a";
yn[8] = "\\b";
yn[9] = "\\t";
yn[10] = "\\n";
yn[11] = "\\v";
yn[12] = "\\f";
yn[13] = "\\r";
yn[27] = "\\e";
yn[34] = '\\"';
yn[92] = "\\\\";
yn[133] = "\\N";
yn[160] = "\\_";
yn[8232] = "\\L";
yn[8233] = "\\P";
var kG = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
  CG = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function _G(t, e) {
  var n, r, i, o, s, l, a;
  if (e === null) return {};
  for (n = {}, r = Object.keys(e), i = 0, o = r.length; i < o; i += 1)
    (s = r[i]),
      (l = String(e[s])),
      s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)),
      (a = t.compiledTypeMap.fallback[s]),
      a && r9.call(a.styleAliases, l) && (l = a.styleAliases[l]),
      (n[s] = l);
  return n;
}
function EG(t) {
  var e, n, r;
  if (((e = t.toString(16).toUpperCase()), t <= 255)) (n = "x"), (r = 2);
  else if (t <= 65535) (n = "u"), (r = 4);
  else if (t <= 4294967295) (n = "U"), (r = 8);
  else throw new _n("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + qt.repeat("0", r - e.length) + e;
}
var TG = 1,
  fu = 2;
function PG(t) {
  (this.schema = t.schema || fy),
    (this.indent = Math.max(1, t.indent || 2)),
    (this.noArrayIndent = t.noArrayIndent || !1),
    (this.skipInvalid = t.skipInvalid || !1),
    (this.flowLevel = qt.isNothing(t.flowLevel) ? -1 : t.flowLevel),
    (this.styleMap = _G(this.schema, t.styles || null)),
    (this.sortKeys = t.sortKeys || !1),
    (this.lineWidth = t.lineWidth || 80),
    (this.noRefs = t.noRefs || !1),
    (this.noCompatMode = t.noCompatMode || !1),
    (this.condenseFlow = t.condenseFlow || !1),
    (this.quotingType = t.quotingType === '"' ? fu : TG),
    (this.forceQuotes = t.forceQuotes || !1),
    (this.replacer = typeof t.replacer == "function" ? t.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ""),
    (this.duplicates = []),
    (this.usedDuplicates = null);
}
function e2(t, e) {
  for (var n = qt.repeat(" ", e), r = 0, i = -1, o = "", s, l = t.length; r < l; )
    (i = t.indexOf(
      `
`,
      r
    )),
      i === -1 ? ((s = t.slice(r)), (r = l)) : ((s = t.slice(r, i + 1)), (r = i + 1)),
      s.length &&
        s !==
          `
` &&
        (o += n),
      (o += s);
  return o;
}
function dO(t, e) {
  return (
    `
` + qt.repeat(" ", t.indent * e)
  );
}
function AG(t, e) {
  var n, r, i;
  for (n = 0, r = t.implicitTypes.length; n < r; n += 1) if (((i = t.implicitTypes[n]), i.resolve(e))) return !0;
  return !1;
}
function ip(t) {
  return t === uG || t === aG;
}
function pu(t) {
  return (
    (32 <= t && t <= 126) ||
    (161 <= t && t <= 55295 && t !== 8232 && t !== 8233) ||
    (57344 <= t && t <= 65533 && t !== gy) ||
    (65536 <= t && t <= 1114111)
  );
}
function t2(t) {
  return pu(t) && t !== gy && t !== cG && t !== du;
}
function n2(t, e, n) {
  var r = t2(t),
    i = r && !ip(t);
  return (
    ((n ? r : r && t !== i9 && t !== o9 && t !== s9 && t !== l9 && t !== a9) && t !== hO && !(e === rp && !i)) ||
    (t2(e) && !ip(e) && t === hO) ||
    (e === rp && i)
  );
}
function $G(t) {
  return (
    pu(t) &&
    t !== gy &&
    !ip(t) &&
    t !== OG &&
    t !== xG &&
    t !== rp &&
    t !== i9 &&
    t !== o9 &&
    t !== s9 &&
    t !== l9 &&
    t !== a9 &&
    t !== hO &&
    t !== pG &&
    t !== gG &&
    t !== hG &&
    t !== SG &&
    t !== vG &&
    t !== bG &&
    t !== mG &&
    t !== dG &&
    t !== fG &&
    t !== yG &&
    t !== wG
  );
}
function RG(t) {
  return !ip(t) && t !== rp;
}
function bc(t, e) {
  var n = t.charCodeAt(e),
    r;
  return n >= 55296 && n <= 56319 && e + 1 < t.length && ((r = t.charCodeAt(e + 1)), r >= 56320 && r <= 57343)
    ? (n - 55296) * 1024 + r - 56320 + 65536
    : n;
}
function c9(t) {
  var e = /^\n* /;
  return e.test(t);
}
var u9 = 1,
  fO = 2,
  h9 = 3,
  d9 = 4,
  hl = 5;
function IG(t, e, n, r, i, o, s, l) {
  var a,
    c = 0,
    u = null,
    h = !1,
    d = !1,
    f = r !== -1,
    p = -1,
    m = $G(bc(t, 0)) && RG(bc(t, t.length - 1));
  if (e || s)
    for (a = 0; a < t.length; c >= 65536 ? (a += 2) : a++) {
      if (((c = bc(t, a)), !pu(c))) return hl;
      (m = m && n2(c, u, l)), (u = c);
    }
  else {
    for (a = 0; a < t.length; c >= 65536 ? (a += 2) : a++) {
      if (((c = bc(t, a)), c === du)) (h = !0), f && ((d = d || (a - p - 1 > r && t[p + 1] !== " ")), (p = a));
      else if (!pu(c)) return hl;
      (m = m && n2(c, u, l)), (u = c);
    }
    d = d || (f && a - p - 1 > r && t[p + 1] !== " ");
  }
  return !h && !d ? (m && !s && !i(t) ? u9 : o === fu ? hl : fO) : n > 9 && c9(t) ? hl : s ? (o === fu ? hl : fO) : d ? d9 : h9;
}
function MG(t, e, n, r, i) {
  t.dump = (function () {
    if (e.length === 0) return t.quotingType === fu ? '""' : "''";
    if (!t.noCompatMode && (kG.indexOf(e) !== -1 || CG.test(e))) return t.quotingType === fu ? '"' + e + '"' : "'" + e + "'";
    var o = t.indent * Math.max(1, n),
      s = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - o),
      l = r || (t.flowLevel > -1 && n >= t.flowLevel);
    function a(c) {
      return AG(t, c);
    }
    switch (IG(e, l, t.indent, s, a, t.quotingType, t.forceQuotes && !r, i)) {
      case u9:
        return e;
      case fO:
        return "'" + e.replace(/'/g, "''") + "'";
      case h9:
        return "|" + r2(e, t.indent) + i2(e2(e, o));
      case d9:
        return ">" + r2(e, t.indent) + i2(e2(LG(e, s), o));
      case hl:
        return '"' + NG(e) + '"';
      default:
        throw new _n("impossible error: invalid scalar style");
    }
  })();
}
function r2(t, e) {
  var n = c9(t) ? String(e) : "",
    r =
      t[t.length - 1] ===
      `
`,
    i =
      r &&
      (t[t.length - 2] ===
        `
` ||
        t ===
          `
`),
    o = i ? "+" : r ? "" : "-";
  return (
    n +
    o +
    `
`
  );
}
function i2(t) {
  return t[t.length - 1] ===
    `
`
    ? t.slice(0, -1)
    : t;
}
function LG(t, e) {
  for (
    var n = /(\n+)([^\n]*)/g,
      r = (function () {
        var c = t.indexOf(`
`);
        return (c = c !== -1 ? c : t.length), (n.lastIndex = c), o2(t.slice(0, c), e);
      })(),
      i =
        t[0] ===
          `
` || t[0] === " ",
      o,
      s;
    (s = n.exec(t));

  ) {
    var l = s[1],
      a = s[2];
    (o = a[0] === " "),
      (r +=
        l +
        (!i && !o && a !== ""
          ? `
`
          : "") +
        o2(a, e)),
      (i = o);
  }
  return r;
}
function o2(t, e) {
  if (t === "" || t[0] === " ") return t;
  for (var n = / [^ ]/g, r, i = 0, o, s = 0, l = 0, a = ""; (r = n.exec(t)); )
    (l = r.index),
      l - i > e &&
        ((o = s > i ? s : l),
        (a +=
          `
` + t.slice(i, o)),
        (i = o + 1)),
      (s = l);
  return (
    (a += `
`),
    t.length - i > e && s > i
      ? (a +=
          t.slice(i, s) +
          `
` +
          t.slice(s + 1))
      : (a += t.slice(i)),
    a.slice(1)
  );
}
function NG(t) {
  for (var e = "", n = 0, r, i = 0; i < t.length; n >= 65536 ? (i += 2) : i++)
    (n = bc(t, i)), (r = yn[n]), !r && pu(n) ? ((e += t[i]), n >= 65536 && (e += t[i + 1])) : (e += r || EG(n));
  return e;
}
function QG(t, e, n) {
  var r = "",
    i = t.tag,
    o,
    s,
    l;
  for (o = 0, s = n.length; o < s; o += 1)
    (l = n[o]),
      t.replacer && (l = t.replacer.call(n, String(o), l)),
      (Ui(t, e, l, !1, !1) || (typeof l > "u" && Ui(t, e, null, !1, !1))) &&
        (r !== "" && (r += "," + (t.condenseFlow ? "" : " ")), (r += t.dump));
  (t.tag = i), (t.dump = "[" + r + "]");
}
function s2(t, e, n, r) {
  var i = "",
    o = t.tag,
    s,
    l,
    a;
  for (s = 0, l = n.length; s < l; s += 1)
    (a = n[s]),
      t.replacer && (a = t.replacer.call(n, String(s), a)),
      (Ui(t, e + 1, a, !0, !0, !1, !0) || (typeof a > "u" && Ui(t, e + 1, null, !0, !0, !1, !0))) &&
        ((!r || i !== "") && (i += dO(t, e)), t.dump && du === t.dump.charCodeAt(0) ? (i += "-") : (i += "- "), (i += t.dump));
  (t.tag = o), (t.dump = i || "[]");
}
function DG(t, e, n) {
  var r = "",
    i = t.tag,
    o = Object.keys(n),
    s,
    l,
    a,
    c,
    u;
  for (s = 0, l = o.length; s < l; s += 1)
    (u = ""),
      r !== "" && (u += ", "),
      t.condenseFlow && (u += '"'),
      (a = o[s]),
      (c = n[a]),
      t.replacer && (c = t.replacer.call(n, a, c)),
      Ui(t, e, a, !1, !1) &&
        (t.dump.length > 1024 && (u += "? "),
        (u += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " ")),
        Ui(t, e, c, !1, !1) && ((u += t.dump), (r += u)));
  (t.tag = i), (t.dump = "{" + r + "}");
}
function FG(t, e, n, r) {
  var i = "",
    o = t.tag,
    s = Object.keys(n),
    l,
    a,
    c,
    u,
    h,
    d;
  if (t.sortKeys === !0) s.sort();
  else if (typeof t.sortKeys == "function") s.sort(t.sortKeys);
  else if (t.sortKeys) throw new _n("sortKeys must be a boolean or a function");
  for (l = 0, a = s.length; l < a; l += 1)
    (d = ""),
      (!r || i !== "") && (d += dO(t, e)),
      (c = s[l]),
      (u = n[c]),
      t.replacer && (u = t.replacer.call(n, c, u)),
      Ui(t, e + 1, c, !0, !0, !0) &&
        ((h = (t.tag !== null && t.tag !== "?") || (t.dump && t.dump.length > 1024)),
        h && (t.dump && du === t.dump.charCodeAt(0) ? (d += "?") : (d += "? ")),
        (d += t.dump),
        h && (d += dO(t, e)),
        Ui(t, e + 1, u, !0, h) && (t.dump && du === t.dump.charCodeAt(0) ? (d += ":") : (d += ": "), (d += t.dump), (i += d)));
  (t.tag = o), (t.dump = i || "{}");
}
function l2(t, e, n) {
  var r, i, o, s, l, a;
  for (i = n ? t.explicitTypes : t.implicitTypes, o = 0, s = i.length; o < s; o += 1)
    if (
      ((l = i[o]),
      (l.instanceOf || l.predicate) &&
        (!l.instanceOf || (typeof e == "object" && e instanceof l.instanceOf)) &&
        (!l.predicate || l.predicate(e)))
    ) {
      if ((n ? (l.multi && l.representName ? (t.tag = l.representName(e)) : (t.tag = l.tag)) : (t.tag = "?"), l.represent)) {
        if (((a = t.styleMap[l.tag] || l.defaultStyle), n9.call(l.represent) === "[object Function]")) r = l.represent(e, a);
        else if (r9.call(l.represent, a)) r = l.represent[a](e, a);
        else throw new _n("!<" + l.tag + '> tag resolver accepts not "' + a + '" style');
        t.dump = r;
      }
      return !0;
    }
  return !1;
}
function Ui(t, e, n, r, i, o, s) {
  (t.tag = null), (t.dump = n), l2(t, n, !1) || l2(t, n, !0);
  var l = n9.call(t.dump),
    a = r,
    c;
  r && (r = t.flowLevel < 0 || t.flowLevel > e);
  var u = l === "[object Object]" || l === "[object Array]",
    h,
    d;
  if (
    (u && ((h = t.duplicates.indexOf(n)), (d = h !== -1)),
    ((t.tag !== null && t.tag !== "?") || d || (t.indent !== 2 && e > 0)) && (i = !1),
    d && t.usedDuplicates[h])
  )
    t.dump = "*ref_" + h;
  else {
    if ((u && d && !t.usedDuplicates[h] && (t.usedDuplicates[h] = !0), l === "[object Object]"))
      r && Object.keys(t.dump).length !== 0
        ? (FG(t, e, t.dump, i), d && (t.dump = "&ref_" + h + t.dump))
        : (DG(t, e, t.dump), d && (t.dump = "&ref_" + h + " " + t.dump));
    else if (l === "[object Array]")
      r && t.dump.length !== 0
        ? (t.noArrayIndent && !s && e > 0 ? s2(t, e - 1, t.dump, i) : s2(t, e, t.dump, i), d && (t.dump = "&ref_" + h + t.dump))
        : (QG(t, e, t.dump), d && (t.dump = "&ref_" + h + " " + t.dump));
    else if (l === "[object String]") t.tag !== "?" && MG(t, t.dump, e, o, a);
    else {
      if (l === "[object Undefined]") return !1;
      if (t.skipInvalid) return !1;
      throw new _n("unacceptable kind of an object to dump " + l);
    }
    t.tag !== null &&
      t.tag !== "?" &&
      ((c = encodeURI(t.tag[0] === "!" ? t.tag.slice(1) : t.tag).replace(/!/g, "%21")),
      t.tag[0] === "!" ? (c = "!" + c) : c.slice(0, 18) === "tag:yaml.org,2002:" ? (c = "!!" + c.slice(18)) : (c = "!<" + c + ">"),
      (t.dump = c + " " + t.dump));
  }
  return !0;
}
function BG(t, e) {
  var n = [],
    r = [],
    i,
    o;
  for (pO(t, n, r), i = 0, o = r.length; i < o; i += 1) e.duplicates.push(n[r[i]]);
  e.usedDuplicates = new Array(o);
}
function pO(t, e, n) {
  var r, i, o;
  if (t !== null && typeof t == "object")
    if (((i = e.indexOf(t)), i !== -1)) n.indexOf(i) === -1 && n.push(i);
    else if ((e.push(t), Array.isArray(t))) for (i = 0, o = t.length; i < o; i += 1) pO(t[i], e, n);
    else for (r = Object.keys(t), i = 0, o = r.length; i < o; i += 1) pO(t[r[i]], e, n);
}
function VG(t, e) {
  e = e || {};
  var n = new PG(e);
  n.noRefs || BG(t, n);
  var r = t;
  return (
    n.replacer && (r = n.replacer.call({ "": r }, "", r)),
    Ui(n, 0, r, !0, !0)
      ? n.dump +
        `
`
      : ""
  );
}
var jG = VG,
  ZG = { dump: jG };
function Oy(t, e) {
  return function () {
    throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
var zG = fn,
  WG = T3,
  XG = R3,
  UG = Q3,
  HG = D3,
  qG = fy,
  YG = t9.load,
  GG = t9.loadAll,
  JG = ZG.dump,
  KG = _n,
  eJ = {
    binary: Z3,
    float: N3,
    map: $3,
    null: I3,
    pairs: W3,
    set: X3,
    timestamp: V3,
    bool: M3,
    int: L3,
    merge: j3,
    omap: z3,
    seq: A3,
    str: P3,
  },
  tJ = Oy("safeLoad", "load"),
  nJ = Oy("safeLoadAll", "loadAll"),
  rJ = Oy("safeDump", "dump"),
  a2 = {
    Type: zG,
    Schema: WG,
    FAILSAFE_SCHEMA: XG,
    JSON_SCHEMA: UG,
    CORE_SCHEMA: HG,
    DEFAULT_SCHEMA: qG,
    load: YG,
    loadAll: GG,
    dump: JG,
    YAMLException: KG,
    types: eJ,
    safeLoad: tJ,
    safeLoadAll: nJ,
    safeDump: rJ,
  };
const iJ = ({ yaml: t, onChange: e }) => {
    const [n, r, i, o] = Ye(Gt, jr, st, mu),
      s = nt(),
      l = He(mu),
      a = He(xy),
      c = S.useMemo(() => (t ? Object.entries(a2.load(t)).map(([v, g]) => ({ key: v, value: g })) : []), [t]),
      { register: u, control: h, handleSubmit: d } = jp({ defaultValues: { yamlConfig: c } }),
      { fields: f, append: p, remove: m } = RM({ control: h, name: "yamlConfig" }),
      O = S.useCallback(
        ({ yamlConfig: v }) => {
          if (v.length === 0) {
            a(), l(!1);
            return;
          }
          const g = v.reduce((b, { key: x, value: k }) => (x && k && (b[x] = k), b), {});
          e(a2.dump(g).trim()), l(!1);
        },
        [e, l, a]
      );
    return S.createElement(
      S.Fragment,
      null,
      S.createElement(
        Xv,
        {
          open: o,
          onOpenChange: (v) => {
            l(v);
          },
        },
        S.createElement(
          Uv,
          { container: r == null ? void 0 : r.current },
          S.createElement(Hv, { className: F.dialogOverlay }),
          S.createElement(
            qv,
            { className: F.largeDialogContent, "data-editor-type": "frontmatter" },
            S.createElement(TM, { className: F.dialogTitle }, s("frontmatterEditor.title", "Edit document frontmatter")),
            S.createElement(
              "form",
              {
                onSubmit: (v) => {
                  d(O)(v), v.stopPropagation();
                },
                onReset: (v) => {
                  v.stopPropagation(), l(!1);
                },
              },
              S.createElement(
                "table",
                { className: F.propertyEditorTable },
                S.createElement("colgroup", null, S.createElement("col", null), S.createElement("col", null), S.createElement("col", null)),
                S.createElement(
                  "thead",
                  null,
                  S.createElement(
                    "tr",
                    null,
                    S.createElement("th", null, s("frontmatterEditor.key", "Key")),
                    S.createElement("th", null, s("frontmatterEditor.value", "Value")),
                    S.createElement("th", null)
                  )
                ),
                S.createElement(
                  "tbody",
                  null,
                  f.map((v, g) =>
                    S.createElement(
                      "tr",
                      { key: v.id },
                      S.createElement(
                        "td",
                        null,
                        S.createElement(c2, { ...u(`yamlConfig.${g}.key`, { required: !0 }), autofocusIfEmpty: !0, readOnly: n })
                      ),
                      S.createElement("td", null, S.createElement(c2, { ...u(`yamlConfig.${g}.value`, { required: !0 }), readOnly: n })),
                      S.createElement(
                        "td",
                        null,
                        S.createElement(
                          "button",
                          {
                            type: "button",
                            onClick: () => {
                              m(g);
                            },
                            className: F.iconButton,
                            disabled: n,
                          },
                          i("delete_big")
                        )
                      )
                    )
                  )
                ),
                S.createElement(
                  "tfoot",
                  null,
                  S.createElement(
                    "tr",
                    null,
                    S.createElement(
                      "td",
                      null,
                      S.createElement(
                        "button",
                        {
                          disabled: n,
                          className: Fe(F.primaryButton, F.smallButton),
                          type: "button",
                          onClick: () => {
                            p({ key: "", value: "" });
                          },
                        },
                        s("frontmatterEditor.addEntry", "Add entry")
                      )
                    )
                  )
                )
              ),
              S.createElement(
                "div",
                { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
                S.createElement("button", { type: "submit", className: F.primaryButton }, s("dialogControls.save", "Save")),
                S.createElement("button", { type: "reset", className: F.secondaryButton }, s("dialogControls.cancel", "Cancel"))
              )
            ),
            S.createElement(
              Yv,
              { asChild: !0 },
              S.createElement("button", { className: F.dialogCloseButton, "aria-label": s("dialogControls.cancel", "Cancel") }, i("close"))
            )
          )
        )
      )
    );
  },
  c2 = S.forwardRef(({ className: t, autofocusIfEmpty: e, ...n }, r) =>
    S.createElement("input", { className: Fe(F.propertyEditorInput, t), ...n, ref: r })
  );
var oJ = Object.defineProperty,
  sJ = (t, e, n) => (e in t ? oJ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  lJ = (t, e, n) => (sJ(t, typeof e != "symbol" ? e + "" : e, n), n);
class wh extends wi {
  constructor(e, n) {
    super(n), lJ(this, "__yaml"), (this.__yaml = e);
  }
  static getType() {
    return "frontmatter";
  }
  static clone(e) {
    return new wh(e.__yaml, e.__key);
  }
  static importJSON(e) {
    const { yaml: n } = e;
    return vy(n);
  }
  exportJSON() {
    return { yaml: this.getYaml(), type: "frontmatter", version: 1 };
  }
  createDOM(e) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getYaml() {
    return this.getLatest().__yaml;
  }
  setYaml(e) {
    e !== this.__yaml && (this.getWritable().__yaml = e);
  }
  decorate(e) {
    return S.createElement(iJ, {
      yaml: this.getYaml(),
      onChange: (n) => {
        e.update(() => {
          this.setYaml(n);
        });
      },
    });
  }
}
function vy(t) {
  return new wh(t);
}
function zm(t) {
  return t instanceof wh;
}
const aJ = {
    testLexicalNode: zm,
    visitLexicalNode: ({ actions: t, lexicalNode: e }) => {
      t.addAndStepInto("yaml", { value: e.getYaml() });
    },
  },
  cJ = {
    testNode: "yaml",
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(vy(t.value));
    },
  },
  mu = we(!1),
  by = Fr((t) => {
    t.sub(t.pipe(by, pt(Un)), ([, e]) => {
      e == null ||
        e.update(() => {
          const n = Qe().getFirstChild();
          if (!zm(n)) {
            const r = vy('"": ""');
            n ? n.insertBefore(r) : Qe().append(r);
          }
        }),
        t.pub(mu, !0);
    });
  }),
  xy = Fr((t) => {
    t.sub(t.pipe(xy, pt(Un)), ([, e]) => {
      e == null ||
        e.update(() => {
          const n = Qe().getFirstChild();
          zm(n) && n.remove();
        }),
        t.pub(mu, !1);
    });
  }),
  yy = we(!1, (t) => {
    t.pub(lh, (e) =>
      e.registerUpdateListener(({ editorState: n }) => {
        n.read(() => {
          t.pub(yy, zm(Qe().getFirstChild()));
        });
      })
    );
  }),
  uJ = Ut({
    init: (t) => {
      t.pubIn({ [Lo]: Iq("yaml"), [Mo]: Aq(), [ar]: wh, [Wn]: cJ, [cr]: aJ, [Hs]: Qq("yaml") });
    },
  }),
  hJ = {
    testNode: "blockquote",
    visitNode({ actions: t }) {
      t.addAndStepInto(Ku());
    },
  },
  dJ = {
    testLexicalNode: Q0,
    visitLexicalNode: ({ lexicalNode: t, mdastParent: e, actions: n }) => {
      const r = { type: "paragraph", children: [] };
      n.appendToParent(e, { type: "blockquote", children: [r] }), n.visitChildren(t, r);
    },
  },
  fJ = Ut({
    init(t) {
      t.pubIn({ [Ea]: "quote", [Wn]: hJ, [ar]: um, [cr]: dJ });
    },
  }),
  pJ = Ut({
    init: (t, e = 1 / 0) => {
      t.pub(lh, (n) => {
        let r = null;
        return n.registerNodeTransform(wa, (i) => {
          const o = ae();
          if (!ee(o) || !o.isCollapsed()) return;
          const s = n.getEditorState(),
            l = s.read(() => i.getTextContentSize()),
            a = i.getTextContentSize();
          if (l !== a) {
            const c = a - e,
              u = o.anchor;
            c > 0 && (l === e && r !== s ? ((r = s), bN(n, s)) : pN(n, u, c));
          }
        });
      });
    },
  });
function mJ() {
  return {
    enter: { mdxFlowExpression: OJ, mdxTextExpression: vJ },
    exit: { mdxFlowExpression: u2, mdxFlowExpressionChunk: h2, mdxTextExpression: u2, mdxTextExpressionChunk: h2 },
  };
}
function gJ() {
  return {
    handlers: { mdxFlowExpression: d2, mdxTextExpression: d2 },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "{" },
    ],
  };
}
function OJ(t) {
  this.enter({ type: "mdxFlowExpression", value: "" }, t), this.buffer();
}
function vJ(t) {
  this.enter({ type: "mdxTextExpression", value: "" }, t), this.buffer();
}
function u2(t) {
  const e = this.resume(),
    n = t.estree,
    r = this.stack[this.stack.length - 1];
  r.type === "mdxFlowExpression" || r.type, this.exit(t), (r.value = e), n && (r.data = { estree: n });
}
function h2(t) {
  this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function d2(t) {
  return "{" + (t.value || "") + "}";
}
function bJ() {
  return { enter: { mdxjsEsm: yJ }, exit: { mdxjsEsm: wJ, mdxjsEsmData: SJ } };
}
function xJ() {
  return { handlers: { mdxjsEsm: kJ } };
}
function yJ(t) {
  this.enter({ type: "mdxjsEsm", value: "" }, t), this.buffer();
}
function wJ(t) {
  const e = this.resume(),
    n = this.stack[this.stack.length - 1];
  n.type, this.exit(t);
  const r = t.estree;
  (n.value = e), r && (n.data = { estree: r });
}
function SJ(t) {
  this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function kJ(t) {
  return t.value || "";
}
function CJ() {
  return [mJ(), xP(), bJ()];
}
function _J(t) {
  return { extensions: [gJ(), yP(t), xJ()] };
}
var EJ = NM();
function TJ(t) {
  const e = t || {},
    n = e.addResult,
    r = e.acorn,
    i = e.spread;
  let o = e.allowEmpty,
    s;
  if ((o == null && (o = !0), r)) {
    if (!r.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    s = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, e.acornOptions);
  } else if (e.acornOptions || e.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: { 123: { name: "mdxFlowExpression", tokenize: l, concrete: !0 } },
    text: { 123: { name: "mdxTextExpression", tokenize: a } },
  };
  function l(c, u, h) {
    const d = this;
    return f;
    function f(v) {
      return p(v);
    }
    function p(v) {
      return Mf.call(d, c, m, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", r, s, n, i, o)(v);
    }
    function m(v) {
      return Pe(v) ? Re(c, O, "whitespace")(v) : O(v);
    }
    function O(v) {
      const g = d.parser.constructs.flow[60],
        x = (Array.isArray(g) ? g : g ? [g] : []).find(function (k) {
          return k.name === "mdxJsxFlowTag";
        });
      return v === 60 && x ? c.attempt(x, O, h)(v) : v === null || de(v) ? u(v) : h(v);
    }
  }
  function a(c, u) {
    const h = this;
    return d;
    function d(f) {
      return Mf.call(h, c, u, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", r, s, n, i, o, !0)(f);
    }
  }
}
const PJ = { tokenize: RJ, partial: !0 },
  f2 = "https://github.com/micromark/micromark-extension-mdxjs-esm",
  AJ = new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]);
function $J(t) {
  const e = { tokenize: i, concrete: !0 };
  if (!t || !t.acorn || !t.acorn.parse) throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  const n = t.acorn,
    r = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, t.acornOptions, { locations: !0 });
  return { flow: { 101: e, 105: e } };
  function i(o, s, l) {
    const a = this,
      c = a.parser.definedModuleSpecifiers || (a.parser.definedModuleSpecifiers = []),
      u = this.events.length + 1;
    let h = "";
    return a.interrupt ? l : d;
    function d(g) {
      return a.now().column > 1 ? l(g) : (o.enter("mdxjsEsm"), o.enter("mdxjsEsmData"), o.consume(g), (h += String.fromCharCode(g)), f);
    }
    function f(g) {
      return tr(g)
        ? (o.consume(g), (h += String.fromCharCode(g)), f)
        : (h === "import" || h === "export") && g === 32
        ? (o.consume(g), p)
        : l(g);
    }
    function p(g) {
      return g === null || de(g) ? (o.exit("mdxjsEsmData"), m(g)) : (o.consume(g), p);
    }
    function m(g) {
      return g === null ? v(g) : de(g) ? o.check(PJ, v, O)(g) : (o.enter("mdxjsEsmData"), p(g));
    }
    function O(g) {
      return o.enter("lineEnding"), o.consume(g), o.exit("lineEnding"), m;
    }
    function v(g) {
      const b = kP(a.events.slice(u), {
        acorn: n,
        acornOptions: r,
        tokenTypes: ["mdxjsEsmData"],
        prefix:
          c.length > 0
            ? "var " +
              c.join(",") +
              `
`
            : "",
      });
      if (b.error) {
        if (g !== null && b.swallow) return O(g);
        const k = new rt("Could not parse import/exports with acorn", {
          cause: b.error,
          place: { line: b.error.loc.line, column: b.error.loc.column + 1, offset: b.error.pos },
          ruleId: "acorn",
          source: "micromark-extension-mdxjs-esm",
        });
        throw ((k.url = f2 + "#could-not-parse-importexports-with-acorn"), k);
      }
      c.length > 0 && b.estree.body.shift();
      let x = -1;
      for (; ++x < b.estree.body.length; ) {
        const k = b.estree.body[x];
        if (!AJ.has(k.type)) {
          const w = new rt("Unexpected `" + k.type + "` in code: only import/exports are supported", {
            place: Xd(k),
            ruleId: "non-esm",
            source: "micromark-extension-mdxjs-esm",
          });
          throw ((w.url = f2 + "#unexpected-type-in-code-only-importexports-are-supported"), w);
        }
        if (k.type === "ImportDeclaration" && !a.interrupt) {
          let w = -1;
          for (; ++w < k.specifiers.length; ) {
            const y = k.specifiers[w];
            c.push(y.local.name);
          }
        }
      }
      return Object.assign(o.exit("mdxjsEsm"), t.addResult ? { estree: b.estree } : void 0), s(g);
    }
  }
}
function RJ(t, e, n) {
  return r;
  function r(i) {
    return t.enter("lineEndingBlank"), t.consume(i), t.exit("lineEndingBlank"), t.attempt(th, e, n);
  }
}
function IJ(t) {
  const e = Object.assign({ acorn: EJ.Parser.extend(QM()), acornOptions: { ecmaVersion: 2024, sourceType: "module" }, addResult: !0 }, t);
  return YP([$J(e), TJ(e), _P(e), EP()]);
}
const Wm = S.createContext(void 0);
function Sh() {
  const t = S.useContext(Wm);
  if (!t) throw new Error("useNestedEditor must be used within a NestedEditorsProvider");
  return t;
}
function Xm() {
  const { parentEditor: t, mdastNode: e, lexicalNode: n } = Sh();
  return function (i) {
    t.update(
      () => {
        LL("history-push");
        const o = dt(n.getKey());
        o && o.setMdastNode({ ...e, ...i });
      },
      { discrete: !0 }
    ),
      t.dispatchCommand(Ro, void 0);
  };
}
function f9() {
  const { parentEditor: t, lexicalNode: e } = Sh();
  return () => {
    t.update(() => {
      const n = dt(e.getKey());
      n.selectNext(), n.remove();
    });
  };
}
const Um = function (t) {
  const { getContent: e, getUpdatedMdastNode: n, contentEditableProps: r, block: i = !1 } = t,
    { mdastNode: o, lexicalNode: s, focusEmitter: l } = Sh(),
    a = Xm(),
    c = f9(),
    u = e(o),
    [h, d, f, p, m, O, v, g, b] = Ye(Un, rh, oh, ih, Io, Es, Us, sh, lx),
    x = He(Ho),
    [k] = S.useState(() => Lb({ nodes: p, theme: Om }));
  return (
    S.useEffect(() => {
      l.subscribe(() => {
        k.focus();
      });
    }, [k, l]),
    S.useEffect(() => {
      k.update(() => {
        Qe().clear();
        let w = u;
        i ? w.length === 0 && (w = [{ type: "paragraph", children: [] }]) : (w = [{ type: "paragraph", children: u }]),
          gm({
            root: Qe(),
            mdastRoot: { type: "root", children: w },
            visitors: d,
            directiveDescriptors: O,
            codeBlockEditorDescriptors: v,
            jsxComponentDescriptors: m,
          });
      });
    }, [k, i, d]),
    S.useEffect(() => {
      function w() {
        k.getEditorState().read(() => {
          const y = mm({ root: Qe(), visitors: f, jsxComponentDescriptors: m, jsxIsAvailable: g, addImportStatements: !1 }),
            C = i ? y.children : y.children[0].children;
          a(n(structuredClone(o), C));
        });
      }
      return Xn(
        k.registerCommand(
          Gp,
          (y) => {
            const C = y.relatedTarget;
            return Dm(C, h.getRootElement()) ? !1 : (w(), x(null), !0);
          },
          Ze
        ),
        k.registerCommand(Ro, () => (w(), !0), Ze),
        k.registerCommand(ba, () => (x({ editorType: "lexical", rootNode: s }), !1), $f),
        k.registerCommand(
          Xu,
          (y, C) => {
            const P = C.getRootElement();
            return (P == null ? void 0 : P.innerText) ===
              `
`
              ? (c(), !0)
              : !1;
          },
          Bn
        )
      );
    }, [i, k, f, n, m, g, s, o, c, x, a, h]),
    S.createElement(
      $A,
      { initialEditor: k },
      S.createElement(fx, {
        contentEditable: S.createElement(hx, { ...r, className: Fe(F.nestedEditor, r == null ? void 0 : r.className) }),
        placeholder: null,
        ErrorBoundary: dx,
      }),
      S.createElement(uA, null),
      b.map((w, y) => S.createElement(w, { key: y }))
    )
  );
};
function Hm() {
  let t = Co;
  return {
    publish: () => {
      t();
    },
    subscribe: (e) => {
      t = e;
    },
  };
}
var MJ = Object.defineProperty,
  LJ = (t, e, n) => (e in t ? MJ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  t1 = (t, e, n) => (LJ(t, typeof e != "symbol" ? e + "" : e, n), n);
class kh extends wi {
  constructor(e, n) {
    super(n),
      t1(this, "__mdastNode"),
      t1(this, "__focusEmitter", Hm()),
      t1(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__mdastNode = e);
  }
  static getType() {
    return "jsx";
  }
  static clone(e) {
    return new kh(structuredClone(e.__mdastNode));
  }
  static importJSON(e) {
    return op(e.mdastNode);
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  exportJSON() {
    return { mdastNode: this.getMdastNode(), type: "jsx", version: 1 };
  }
  createDOM() {
    return document.createElement(this.__mdastNode.type === "mdxJsxTextElement" ? "span" : "div");
  }
  updateDOM() {
    return !1;
  }
  setMdastNode(e) {
    this.getWritable().__mdastNode = e;
  }
  decorate(e, n) {
    return S.createElement(NJ, {
      lexicalJsxNode: this,
      config: n,
      mdastNode: this.getMdastNode(),
      parentEditor: e,
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return this.__mdastNode.type === "mdxJsxTextElement";
  }
  isKeyboardSelectable() {
    return !0;
  }
}
function NJ(t) {
  const { mdastNode: e } = t,
    r = mt(Io).find((o) => o.name === e.name);
  if (!r) throw new Error(`No JSX descriptor found for ${e.name}`);
  const i = r.Editor;
  return S.createElement(
    Wm.Provider,
    {
      value: { config: t.config, focusEmitter: t.focusEmitter, mdastNode: e, parentEditor: t.parentEditor, lexicalNode: t.lexicalJsxNode },
    },
    S.createElement(i, { descriptor: r, mdastNode: e })
  );
}
function op(t) {
  return new kh(t);
}
function QJ(t) {
  return t instanceof kh;
}
const DJ = {
    testLexicalNode: QJ,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      function r(o) {
        "children" in o &&
          o.children instanceof Array &&
          o.children.forEach((s) => {
            g9(s) && t.registerReferredComponent(s.name), r(s);
          });
      }
      const i = n.getMdastNode();
      t.registerReferredComponent(i.name), r(i), t.appendToParent(e, i);
    },
    priority: -200,
  },
  FJ = { testNode: "mdxjsEsm", visitNode() {} },
  BJ = {
    testNode: (t, { jsxComponentDescriptors: e }) =>
      t.type === "mdxJsxTextElement" || t.type === "mdxJsxFlowElement" ? e.find((r) => r.name === t.name) !== void 0 : !1,
    visitNode({ lexicalParent: t, mdastNode: e }) {
      t.append(op(e));
    },
    priority: -200,
  };
var VJ = Object.defineProperty,
  jJ = (t, e, n) => (e in t ? VJ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  p2 = (t, e, n) => (jJ(t, typeof e != "symbol" ? e + "" : e, n), n);
class Ch extends wi {
  constructor(e, n, r) {
    super(r), p2(this, "__value"), p2(this, "__mdastType"), (this.__value = e), (this.__mdastType = n);
  }
  static getType() {
    return "mdx-expression";
  }
  static clone(e) {
    return new Ch(e.__value, e.__mdastType, e.__key);
  }
  getValue() {
    return this.__value;
  }
  getMdastType() {
    return this.__mdastType;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.classList.add(Jt.mdxExpression), e;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return { element: n };
  }
  static importJSON(e) {
    return p9(e.value, e.mdastType);
  }
  exportJSON() {
    return { ...super.exportJSON(), value: this.getValue(), mdastType: this.getMdastType(), type: "mdx-expression", version: 1 };
  }
  extractWithChild() {
    return !0;
  }
  isInline() {
    return this.__mdastType === "mdxTextExpression";
  }
  decorate(e) {
    return S.createElement(
      S.Fragment,
      null,
      "{",
      S.createElement(
        "span",
        { className: F.inputSizer, "data-value": this.getValue() },
        S.createElement("input", {
          size: 1,
          onKeyDown: (n) => {
            ((n.target.value === "" && n.key === "Backspace") || n.key === "Delete") &&
              (n.stopPropagation(),
              n.nativeEvent.stopImmediatePropagation(),
              n.preventDefault(),
              e.update(() => {
                this.selectPrevious(), this.remove();
              }));
          },
          onChange: (n) => {
            (n.target.parentElement.dataset.value = n.target.value),
              e.update(() => {
                this.getWritable().__value = n.target.value;
              });
          },
          type: "text",
          value: this.getValue(),
        })
      ),
      "}"
    );
  }
}
function p9(t, e) {
  return Mn(new Ch(t, e));
}
function ZJ(t) {
  return t instanceof Ch;
}
const zJ = {
    testNode: (t) => t.type === "mdxTextExpression" || t.type === "mdxFlowExpression",
    visitNode({ lexicalParent: t, mdastNode: e }) {
      t.append(p9(e.value, e.type));
    },
    priority: -200,
  },
  WJ = {
    testLexicalNode: ZJ,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      const r = { type: n.getMdastType(), value: n.getValue() };
      t.appendToParent(e, r);
    },
  },
  XJ = (t) => {
    const e = mt(jr);
    return S.createElement(Rm, { ...t, container: e == null ? void 0 : e.current });
  },
  UJ = S.forwardRef((t, e) =>
    S.createElement(
      b$,
      { ...t, className: F.popoverContent, sideOffset: 5, side: "top", ref: e },
      S.createElement("span", { className: F.popoverArrow }, S.createElement(Im, null)),
      t.children
    )
  ),
  wy = ({ title: t, properties: e, onChange: n }) => {
    const [r, i] = S.useState(!1),
      o = mt(st),
      { register: s, handleSubmit: l, reset: a } = jp({ defaultValues: e });
    return S.createElement(
      $m,
      {
        open: r,
        onOpenChange: (c) => {
          i(c);
        },
      },
      S.createElement(aU, { className: F.iconButton }, S.createElement("div", null, o("settings"))),
      S.createElement(
        XJ,
        null,
        S.createElement(
          UJ,
          null,
          S.createElement(
            "form",
            {
              onSubmit: (c) => {
                l(n)(c), i(!1), c.preventDefault(), c.stopPropagation();
              },
            },
            S.createElement("h3", { className: F.propertyPanelTitle }, t, " Attributes"),
            S.createElement(
              "table",
              { className: F.propertyEditorTable },
              S.createElement(
                "thead",
                null,
                S.createElement(
                  "tr",
                  null,
                  S.createElement("th", { className: F.readOnlyColumnCell }, "Attribute"),
                  S.createElement("th", null, "Value")
                )
              ),
              S.createElement(
                "tbody",
                null,
                Object.keys(e).map((c) =>
                  S.createElement(
                    "tr",
                    { key: c },
                    S.createElement("th", { className: F.readOnlyColumnCell }, " ", c, " "),
                    S.createElement("td", null, S.createElement("input", { ...s(c), className: F.propertyEditorInput }))
                  )
                )
              ),
              S.createElement(
                "tfoot",
                null,
                S.createElement(
                  "tr",
                  null,
                  S.createElement(
                    "td",
                    { colSpan: 2 },
                    S.createElement(
                      "div",
                      { className: F.buttonsFooter },
                      S.createElement("button", { type: "submit", className: F.primaryButton }, "Save"),
                      S.createElement(
                        "button",
                        {
                          type: "reset",
                          className: F.secondaryButton,
                          onClick: (c) => {
                            c.preventDefault(), a(e), i(!1);
                          },
                        },
                        "Cancel"
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
  },
  HJ = (t) => t !== null && typeof t == "object" && "type" in t && "value" in t && typeof t.value == "string",
  qJ = (t) => typeof t == "string",
  YJ = (t) => t.type === "mdxJsxAttribute" && typeof t.name == "string",
  m9 = ({ mdastNode: t, descriptor: e }) => {
    const n = Xm(),
      r = S.useMemo(
        () =>
          e.props.reduce((s, { name: l }) => {
            const a = t.attributes.find((c) => (YJ(c) ? c.name === l : !1));
            if (a) {
              if (HJ(a.value)) return (s[l] = a.value.value), s;
              if (qJ(a.value)) return (s[l] = a.value), s;
            }
            return (s[l] = ""), s;
          }, {}),
        [t, e]
      ),
      i = S.useCallback(
        (s) => {
          const l = Object.entries(s).reduce((a, [c, u]) => {
            if (u === "") return a;
            const h = e.props.find((d) => d.name === c);
            return (h == null ? void 0 : h.type) === "expression"
              ? (a.push({ type: "mdxJsxAttribute", name: c, value: { type: "mdxJsxAttributeValueExpression", value: u } }), a)
              : (a.push({ type: "mdxJsxAttribute", name: c, value: u }), a);
          }, []);
          n({ attributes: l });
        },
        [t, n, e]
      ),
      o = e.props.length == 0 && e.hasChildren && e.kind === "flow";
    return S.createElement(
      "div",
      { className: e.kind === "text" ? F.inlineEditor : F.blockEditor },
      o ? S.createElement("span", { className: F.genericComponentName }, t.name ?? "Fragment") : null,
      e.props.length > 0 ? S.createElement(wy, { properties: r, title: t.name ?? "", onChange: i }) : null,
      e.hasChildren
        ? S.createElement(Um, {
            block: e.kind === "flow",
            getContent: (s) => s.children,
            getUpdatedMdastNode: (s, l) => ({ ...s, children: l }),
          })
        : S.createElement("span", { className: F.genericComponentName }, t.name)
    );
  };
function g9(t) {
  return t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement";
}
const GJ = (t) => t !== null && typeof t == "object" && "type" in t && "value" in t && typeof t.value == "string",
  JJ = (t) =>
    Object.entries(t).map(([e, n]) => ({
      type: "mdxJsxAttribute",
      name: e,
      value: GJ(n) ? { type: "mdxJsxAttributeValueExpression", value: n.value } : n,
    })),
  O9 = kt((t) => {
    t.link(
      t.pipe(
        O9,
        mr(({ kind: e, name: n, children: r, props: i }) => () => {
          const o = JJ(i);
          return op(
            e === "flow"
              ? { type: "mdxJsxFlowElement", name: n, children: r ?? [], attributes: o }
              : { type: "mdxJsxTextElement", name: n, children: r ?? [], attributes: o }
          );
        })
      ),
      _a
    );
  }),
  m2 = { name: null, kind: "flow", props: [], hasChildren: !0, Editor: m9 },
  g2 = (t) => (t ? (t.allowFragment ?? !0 ? [m2, ...t.jsxComponentDescriptors] : t.jsxComponentDescriptors) : [m2]),
  KJ = Ut({
    init: (t, e) => {
      t.pubIn({ [sh]: !0, [Lo]: CJ(), [Mo]: IJ(), [Wn]: [BJ, FJ, zJ], [ar]: [kh, Ch], [cr]: [DJ, WJ], [Hs]: _J(), [Io]: g2(e) });
    },
    update(t, e) {
      t.pub(Io, g2(e));
    },
  });
var eK = Object.defineProperty,
  tK = (t, e, n) => (e in t ? eK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  io = (t, e, n) => (tK(t, typeof e != "symbol" ? e + "" : e, n), n);
class qs extends wi {
  constructor(e, n, r, i) {
    super(i),
      io(this, "__code"),
      io(this, "__meta"),
      io(this, "__language"),
      io(this, "__focusEmitter", Hm()),
      io(this, "setCode", (o) => {
        o !== this.__code && (this.getWritable().__code = o);
      }),
      io(this, "setMeta", (o) => {
        o !== this.__meta && (this.getWritable().__meta = o);
      }),
      io(this, "setLanguage", (o) => {
        o !== this.__language && (this.getWritable().__language = o);
      }),
      io(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__code = e),
      (this.__meta = r),
      (this.__language = n);
  }
  static getType() {
    return "codeblock";
  }
  static clone(e) {
    return new qs(e.__code, e.__language, e.__meta, e.__key);
  }
  static importJSON(e) {
    const { code: n, meta: r, language: i } = e;
    return _h({ code: n, language: i, meta: r });
  }
  exportJSON() {
    return { code: this.getCode(), language: this.getLanguage(), meta: this.getMeta(), type: "codeblock", version: 1 };
  }
  createDOM(e) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getCode() {
    return this.__code;
  }
  getMeta() {
    return this.__meta;
  }
  getLanguage() {
    return this.__language;
  }
  decorate(e) {
    return S.createElement(rK, {
      parentEditor: e,
      code: this.getCode(),
      meta: this.getMeta(),
      language: this.getLanguage(),
      codeBlockNode: this,
      nodeKey: this.getKey(),
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return !1;
  }
}
const v9 = S.createContext(null),
  nK = ({ parentEditor: t, lexicalNode: e, children: n }) => {
    const r = S.useMemo(
      () => ({
        lexicalNode: e,
        parentEditor: t,
        setCode: (i) => {
          t.update(() => {
            e.setCode(i),
              setTimeout(() => {
                t.dispatchCommand(Ro, void 0);
              }, 0);
          });
        },
        setLanguage: (i) => {
          t.update(() => {
            e.setLanguage(i);
          });
        },
        setMeta: (i) => {
          t.update(() => {
            e.setMeta(i);
          });
        },
      }),
      [e, t]
    );
    return S.createElement(v9.Provider, { value: r }, n);
  };
function ta() {
  const t = S.useContext(v9);
  if (!t) throw new Error("useCodeBlockEditor must be used within a CodeBlockEditor");
  return t;
}
const rK = (t) => {
  const e = mt(Us),
    n = mt(qm);
  let r = e.sort((a, c) => c.priority - a.priority).find((a) => a.match(t.language || "", t.meta || ""));
  if ((r || (r = e.find((a) => a.match(n || "", t.meta || ""))), !r))
    throw new Error(`No CodeBlockEditor registered for language=${t.language} meta=${t.meta}`);
  const i = r.Editor,
    { codeBlockNode: o, parentEditor: s, ...l } = t;
  return S.createElement(nK, { parentEditor: t.parentEditor, lexicalNode: t.codeBlockNode }, S.createElement(i, { ...l }));
};
function _h(t) {
  const { code: e = "", language: n = "", meta: r = "" } = t;
  return new qs(e, n, r);
}
function b9(t) {
  return t instanceof qs;
}
const iK = {
    testLexicalNode: b9,
    visitLexicalNode: ({ lexicalNode: t, actions: e }) => {
      e.addAndStepInto("code", { value: t.getCode(), lang: t.getLanguage(), meta: t.getMeta() });
    },
  },
  oK = {
    testNode: (t, { codeBlockEditorDescriptors: e }) => (t.type === "code" ? e.find((r) => r.match(t.lang, t.meta)) !== void 0 : !1),
    visitNode({ mdastNode: t, actions: e }) {
      e.addAndStepInto(_h({ code: t.value, language: t.lang, meta: t.meta }));
    },
  },
  qm = we(""),
  Eh = kt((t) => {
    t.link(
      t.pipe(
        Eh,
        pt(qm),
        mr(
          ([e, n]) =>
            () =>
              _h({ language: n, ...e })
        )
      ),
      _a
    );
  }),
  Sy = Ln(Us),
  sK = Ut({
    update(t, e) {
      t.pub(qm, (e == null ? void 0 : e.defaultCodeBlockLanguage) ?? "");
    },
    init(t, e) {
      t.pubIn({ [Ea]: "codeblock", [Us]: (e == null ? void 0 : e.codeBlockEditorDescriptors) ?? [], [Wn]: oK, [ar]: qs, [cr]: iK });
    },
  });
var lt = "colors",
  Sn = "sizes",
  ye = "space",
  lK = {
    gap: ye,
    gridGap: ye,
    columnGap: ye,
    gridColumnGap: ye,
    rowGap: ye,
    gridRowGap: ye,
    inset: ye,
    insetBlock: ye,
    insetBlockEnd: ye,
    insetBlockStart: ye,
    insetInline: ye,
    insetInlineEnd: ye,
    insetInlineStart: ye,
    margin: ye,
    marginTop: ye,
    marginRight: ye,
    marginBottom: ye,
    marginLeft: ye,
    marginBlock: ye,
    marginBlockEnd: ye,
    marginBlockStart: ye,
    marginInline: ye,
    marginInlineEnd: ye,
    marginInlineStart: ye,
    padding: ye,
    paddingTop: ye,
    paddingRight: ye,
    paddingBottom: ye,
    paddingLeft: ye,
    paddingBlock: ye,
    paddingBlockEnd: ye,
    paddingBlockStart: ye,
    paddingInline: ye,
    paddingInlineEnd: ye,
    paddingInlineStart: ye,
    top: ye,
    right: ye,
    bottom: ye,
    left: ye,
    scrollMargin: ye,
    scrollMarginTop: ye,
    scrollMarginRight: ye,
    scrollMarginBottom: ye,
    scrollMarginLeft: ye,
    scrollMarginX: ye,
    scrollMarginY: ye,
    scrollMarginBlock: ye,
    scrollMarginBlockEnd: ye,
    scrollMarginBlockStart: ye,
    scrollMarginInline: ye,
    scrollMarginInlineEnd: ye,
    scrollMarginInlineStart: ye,
    scrollPadding: ye,
    scrollPaddingTop: ye,
    scrollPaddingRight: ye,
    scrollPaddingBottom: ye,
    scrollPaddingLeft: ye,
    scrollPaddingX: ye,
    scrollPaddingY: ye,
    scrollPaddingBlock: ye,
    scrollPaddingBlockEnd: ye,
    scrollPaddingBlockStart: ye,
    scrollPaddingInline: ye,
    scrollPaddingInlineEnd: ye,
    scrollPaddingInlineStart: ye,
    fontSize: "fontSizes",
    background: lt,
    backgroundColor: lt,
    backgroundImage: lt,
    borderImage: lt,
    border: lt,
    borderBlock: lt,
    borderBlockEnd: lt,
    borderBlockStart: lt,
    borderBottom: lt,
    borderBottomColor: lt,
    borderColor: lt,
    borderInline: lt,
    borderInlineEnd: lt,
    borderInlineStart: lt,
    borderLeft: lt,
    borderLeftColor: lt,
    borderRight: lt,
    borderRightColor: lt,
    borderTop: lt,
    borderTopColor: lt,
    caretColor: lt,
    color: lt,
    columnRuleColor: lt,
    fill: lt,
    outline: lt,
    outlineColor: lt,
    stroke: lt,
    textDecorationColor: lt,
    fontFamily: "fonts",
    fontWeight: "fontWeights",
    lineHeight: "lineHeights",
    letterSpacing: "letterSpacings",
    blockSize: Sn,
    minBlockSize: Sn,
    maxBlockSize: Sn,
    inlineSize: Sn,
    minInlineSize: Sn,
    maxInlineSize: Sn,
    width: Sn,
    minWidth: Sn,
    maxWidth: Sn,
    height: Sn,
    minHeight: Sn,
    maxHeight: Sn,
    flexBasis: Sn,
    gridTemplateColumns: Sn,
    gridTemplateRows: Sn,
    borderWidth: "borderWidths",
    borderTopWidth: "borderWidths",
    borderRightWidth: "borderWidths",
    borderBottomWidth: "borderWidths",
    borderLeftWidth: "borderWidths",
    borderStyle: "borderStyles",
    borderTopStyle: "borderStyles",
    borderRightStyle: "borderStyles",
    borderBottomStyle: "borderStyles",
    borderLeftStyle: "borderStyles",
    borderRadius: "radii",
    borderTopLeftRadius: "radii",
    borderTopRightRadius: "radii",
    borderBottomRightRadius: "radii",
    borderBottomLeftRadius: "radii",
    boxShadow: "shadows",
    textShadow: "shadows",
    transition: "transitions",
    zIndex: "zIndices",
  },
  aK = (t, e) => (typeof e == "function" ? { "()": Function.prototype.toString.call(e) } : e),
  Th = () => {
    const t = Object.create(null);
    return (e, n, ...r) => {
      const i = ((o) => JSON.stringify(o, aK))(e);
      return i in t ? t[i] : (t[i] = n(e, ...r));
    };
  },
  Jd = Symbol.for("sxs.internal"),
  ky = (t, e) => Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)),
  O2 = (t) => {
    for (const e in t) return !0;
    return !1;
  },
  { hasOwnProperty: cK } = Object.prototype,
  mO = (t) => (t.includes("-") ? t : t.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase())),
  uK = /\s+(?![^()]*\))/,
  rl = (t) => (e) => t(...(typeof e == "string" ? String(e).split(uK) : [e])),
  v2 = {
    appearance: (t) => ({ WebkitAppearance: t, appearance: t }),
    backfaceVisibility: (t) => ({ WebkitBackfaceVisibility: t, backfaceVisibility: t }),
    backdropFilter: (t) => ({ WebkitBackdropFilter: t, backdropFilter: t }),
    backgroundClip: (t) => ({ WebkitBackgroundClip: t, backgroundClip: t }),
    boxDecorationBreak: (t) => ({ WebkitBoxDecorationBreak: t, boxDecorationBreak: t }),
    clipPath: (t) => ({ WebkitClipPath: t, clipPath: t }),
    content: (t) => ({
      content:
        t.includes('"') || t.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(t)
          ? t
          : `"${t}"`,
    }),
    hyphens: (t) => ({ WebkitHyphens: t, hyphens: t }),
    maskImage: (t) => ({ WebkitMaskImage: t, maskImage: t }),
    maskSize: (t) => ({ WebkitMaskSize: t, maskSize: t }),
    tabSize: (t) => ({ MozTabSize: t, tabSize: t }),
    textSizeAdjust: (t) => ({ WebkitTextSizeAdjust: t, textSizeAdjust: t }),
    userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }),
    marginBlock: rl((t, e) => ({ marginBlockStart: t, marginBlockEnd: e || t })),
    marginInline: rl((t, e) => ({ marginInlineStart: t, marginInlineEnd: e || t })),
    maxSize: rl((t, e) => ({ maxBlockSize: t, maxInlineSize: e || t })),
    minSize: rl((t, e) => ({ minBlockSize: t, minInlineSize: e || t })),
    paddingBlock: rl((t, e) => ({ paddingBlockStart: t, paddingBlockEnd: e || t })),
    paddingInline: rl((t, e) => ({ paddingInlineStart: t, paddingInlineEnd: e || t })),
  },
  n1 = /([\d.]+)([^]*)/,
  hK = (t, e) =>
    t.length
      ? t.reduce(
          (n, r) => (
            n.push(
              ...e.map((i) => (i.includes("&") ? i.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(i) ? `:is(${r})` : r) : r + " " + i))
            ),
            n
          ),
          []
        )
      : e,
  dK = (t, e) =>
    t in fK && typeof e == "string"
      ? e.replace(
          /^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,
          (n, r, i, o) =>
            r +
            (i === "stretch" ? `-moz-available${o};${mO(t)}:${r}-webkit-fill-available` : `-moz-fit-content${o};${mO(t)}:${r}fit-content`) +
            o
        )
      : String(e),
  fK = {
    blockSize: 1,
    height: 1,
    inlineSize: 1,
    maxBlockSize: 1,
    maxHeight: 1,
    maxInlineSize: 1,
    maxWidth: 1,
    minBlockSize: 1,
    minHeight: 1,
    minInlineSize: 1,
    minWidth: 1,
    width: 1,
  },
  Hi = (t) => (t ? t + "-" : ""),
  x9 = (t, e, n) =>
    t.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, i, o, s, l) =>
      (s == "$") == !!o
        ? r
        : (i || s == "--" ? "calc(" : "") +
          "var(--" +
          (s === "$" ? Hi(e) + (l.includes("$") ? "" : Hi(n)) + l.replace(/\$/g, "-") : l) +
          ")" +
          (i || s == "--" ? "*" + (i || "") + (o || "1") + ")" : "")
    ),
  pK = /\s*,\s*(?![^()]*\))/,
  mK = Object.prototype.toString,
  bl = (t, e, n, r, i) => {
    let o, s, l;
    const a = (c, u, h) => {
      let d, f;
      const p = (m) => {
        for (d in m) {
          const g = d.charCodeAt(0) === 64,
            b = g && Array.isArray(m[d]) ? m[d] : [m[d]];
          for (f of b) {
            const x = /[A-Z]/.test((v = d)) ? v : v.replace(/-[^]/g, (w) => w[1].toUpperCase()),
              k = typeof f == "object" && f && f.toString === mK && (!r.utils[x] || !u.length);
            if (x in r.utils && !k) {
              const w = r.utils[x];
              if (w !== s) {
                (s = w), p(w(f)), (s = null);
                continue;
              }
            } else if (x in v2) {
              const w = v2[x];
              if (w !== l) {
                (l = w), p(w(f)), (l = null);
                continue;
              }
            }
            if (
              (g &&
                ((O = d.slice(1) in r.media ? "@media " + r.media[d.slice(1)] : d),
                (d = O.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (w, y, C, P, E, N) => {
                  const L = n1.test(y),
                    D = 0.0625 * (L ? -1 : 1),
                    [Q, R] = L ? [P, y] : [y, P];
                  return (
                    "(" +
                    (C[0] === "=" ? "" : (C[0] === ">") === L ? "max-" : "min-") +
                    Q +
                    ":" +
                    (C[0] !== "=" && C.length === 1 ? R.replace(n1, (W, B, K) => Number(B) + D * (C === ">" ? 1 : -1) + K) : R) +
                    (E
                      ? ") and (" +
                        (E[0] === ">" ? "min-" : "max-") +
                        Q +
                        ":" +
                        (E.length === 1 ? N.replace(n1, (W, B, K) => Number(B) + D * (E === ">" ? -1 : 1) + K) : N)
                      : "") +
                    ")"
                  );
                }))),
              k)
            ) {
              const w = g ? h.concat(d) : [...h],
                y = g ? [...u] : hK(u, d.split(pK));
              o !== void 0 && i(b2(...o)), (o = void 0), a(f, y, w);
            } else
              o === void 0 && (o = [[], u, h]),
                (d = g || d.charCodeAt(0) !== 36 ? d : `--${Hi(r.prefix)}${d.slice(1).replace(/\$/g, "-")}`),
                (f = k
                  ? f
                  : typeof f == "number"
                  ? f && x in gK
                    ? String(f) + "px"
                    : String(f)
                  : x9(dK(x, f ?? ""), r.prefix, r.themeMap[x])),
                o[0].push(`${g ? `${d} ` : `${mO(d)}:`}${f}`);
          }
        }
        var O, v;
      };
      p(c), o !== void 0 && i(b2(...o)), (o = void 0);
    };
    a(t, e, n);
  },
  b2 = (t, e, n) =>
    `${n.map((r) => `${r}{`).join("")}${e.length ? `${e.join(",")}{` : ""}${t.join(";")}${e.length ? "}" : ""}${Array(
      n.length ? n.length + 1 : 0
    ).join("}")}`,
  gK = {
    animationDelay: 1,
    animationDuration: 1,
    backgroundSize: 1,
    blockSize: 1,
    border: 1,
    borderBlock: 1,
    borderBlockEnd: 1,
    borderBlockEndWidth: 1,
    borderBlockStart: 1,
    borderBlockStartWidth: 1,
    borderBlockWidth: 1,
    borderBottom: 1,
    borderBottomLeftRadius: 1,
    borderBottomRightRadius: 1,
    borderBottomWidth: 1,
    borderEndEndRadius: 1,
    borderEndStartRadius: 1,
    borderInlineEnd: 1,
    borderInlineEndWidth: 1,
    borderInlineStart: 1,
    borderInlineStartWidth: 1,
    borderInlineWidth: 1,
    borderLeft: 1,
    borderLeftWidth: 1,
    borderRadius: 1,
    borderRight: 1,
    borderRightWidth: 1,
    borderSpacing: 1,
    borderStartEndRadius: 1,
    borderStartStartRadius: 1,
    borderTop: 1,
    borderTopLeftRadius: 1,
    borderTopRightRadius: 1,
    borderTopWidth: 1,
    borderWidth: 1,
    bottom: 1,
    columnGap: 1,
    columnRule: 1,
    columnRuleWidth: 1,
    columnWidth: 1,
    containIntrinsicSize: 1,
    flexBasis: 1,
    fontSize: 1,
    gap: 1,
    gridAutoColumns: 1,
    gridAutoRows: 1,
    gridTemplateColumns: 1,
    gridTemplateRows: 1,
    height: 1,
    inlineSize: 1,
    inset: 1,
    insetBlock: 1,
    insetBlockEnd: 1,
    insetBlockStart: 1,
    insetInline: 1,
    insetInlineEnd: 1,
    insetInlineStart: 1,
    left: 1,
    letterSpacing: 1,
    margin: 1,
    marginBlock: 1,
    marginBlockEnd: 1,
    marginBlockStart: 1,
    marginBottom: 1,
    marginInline: 1,
    marginInlineEnd: 1,
    marginInlineStart: 1,
    marginLeft: 1,
    marginRight: 1,
    marginTop: 1,
    maxBlockSize: 1,
    maxHeight: 1,
    maxInlineSize: 1,
    maxWidth: 1,
    minBlockSize: 1,
    minHeight: 1,
    minInlineSize: 1,
    minWidth: 1,
    offsetDistance: 1,
    offsetRotate: 1,
    outline: 1,
    outlineOffset: 1,
    outlineWidth: 1,
    overflowClipMargin: 1,
    padding: 1,
    paddingBlock: 1,
    paddingBlockEnd: 1,
    paddingBlockStart: 1,
    paddingBottom: 1,
    paddingInline: 1,
    paddingInlineEnd: 1,
    paddingInlineStart: 1,
    paddingLeft: 1,
    paddingRight: 1,
    paddingTop: 1,
    perspective: 1,
    right: 1,
    rowGap: 1,
    scrollMargin: 1,
    scrollMarginBlock: 1,
    scrollMarginBlockEnd: 1,
    scrollMarginBlockStart: 1,
    scrollMarginBottom: 1,
    scrollMarginInline: 1,
    scrollMarginInlineEnd: 1,
    scrollMarginInlineStart: 1,
    scrollMarginLeft: 1,
    scrollMarginRight: 1,
    scrollMarginTop: 1,
    scrollPadding: 1,
    scrollPaddingBlock: 1,
    scrollPaddingBlockEnd: 1,
    scrollPaddingBlockStart: 1,
    scrollPaddingBottom: 1,
    scrollPaddingInline: 1,
    scrollPaddingInlineEnd: 1,
    scrollPaddingInlineStart: 1,
    scrollPaddingLeft: 1,
    scrollPaddingRight: 1,
    scrollPaddingTop: 1,
    shapeMargin: 1,
    textDecoration: 1,
    textDecorationThickness: 1,
    textIndent: 1,
    textUnderlineOffset: 1,
    top: 1,
    transitionDelay: 1,
    transitionDuration: 1,
    verticalAlign: 1,
    width: 1,
    wordSpacing: 1,
  },
  x2 = (t) => String.fromCharCode(t + (t > 25 ? 39 : 97)),
  ys = (t) =>
    ((e) => {
      let n,
        r = "";
      for (n = Math.abs(e); n > 52; n = (n / 52) | 0) r = x2(n % 52) + r;
      return x2(n % 52) + r;
    })(
      ((e, n) => {
        let r = n.length;
        for (; r; ) e = (33 * e) ^ n.charCodeAt(--r);
        return e;
      })(5381, JSON.stringify(t)) >>> 0
    ),
  xc = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"],
  OK = (t) => {
    if (t.href && !t.href.startsWith(location.origin)) return !1;
    try {
      return !!t.cssRules;
    } catch {
      return !1;
    }
  },
  vK = (t) => {
    let e;
    const n = () => {
        const { cssRules: i } = e.sheet;
        return [].map
          .call(i, (o, s) => {
            const { cssText: l } = o;
            let a = "";
            if (l.startsWith("--sxs")) return "";
            if (i[s - 1] && (a = i[s - 1].cssText).startsWith("--sxs")) {
              if (!o.cssRules.length) return "";
              for (const c in e.rules) if (e.rules[c].group === o) return `--sxs{--sxs:${[...e.rules[c].cache].join(" ")}}${l}`;
              return o.cssRules.length ? `${a}${l}` : "";
            }
            return l;
          })
          .join("");
      },
      r = () => {
        if (e) {
          const { rules: l, sheet: a } = e;
          if (!a.deleteRule) {
            for (; Object(Object(a.cssRules)[0]).type === 3; ) a.cssRules.splice(0, 1);
            a.cssRules = [];
          }
          for (const c in l) delete l[c];
        }
        const i = Object(t).styleSheets || [];
        for (const l of i)
          if (OK(l)) {
            for (let a = 0, c = l.cssRules; c[a]; ++a) {
              const u = Object(c[a]);
              if (u.type !== 1) continue;
              const h = Object(c[a + 1]);
              if (h.type !== 4) continue;
              ++a;
              const { cssText: d } = u;
              if (!d.startsWith("--sxs")) continue;
              const f = d.slice(14, -3).trim().split(/\s+/),
                p = xc[f[0]];
              p && (e || (e = { sheet: l, reset: r, rules: {}, toString: n }), (e.rules[p] = { group: h, index: a, cache: new Set(f) }));
            }
            if (e) break;
          }
        if (!e) {
          const l = (a, c) => ({
            type: c,
            cssRules: [],
            insertRule(u, h) {
              this.cssRules.splice(h, 0, l(u, { import: 3, undefined: 1 }[(u.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
            },
            get cssText() {
              return a === "@media{}" ? `@media{${[].map.call(this.cssRules, (u) => u.cssText).join("")}}` : a;
            },
          });
          e = {
            sheet: t ? (t.head || t).appendChild(document.createElement("style")).sheet : l("", "text/css"),
            rules: {},
            reset: r,
            toString: n,
          };
        }
        const { sheet: o, rules: s } = e;
        for (let l = xc.length - 1; l >= 0; --l) {
          const a = xc[l];
          if (!s[a]) {
            const c = xc[l + 1],
              u = s[c] ? s[c].index : o.cssRules.length;
            o.insertRule("@media{}", u),
              o.insertRule(`--sxs{--sxs:${l}}`, u),
              (s[a] = { group: o.cssRules[u + 1], index: u, cache: new Set([l]) });
          }
          bK(s[a]);
        }
      };
    return r(), e;
  },
  bK = (t) => {
    const e = t.group;
    let n = e.cssRules.length;
    t.apply = (r) => {
      try {
        e.insertRule(r, n), ++n;
      } catch {}
    };
  },
  rc = Symbol(),
  xK = Th(),
  yK = (t, e) =>
    xK(t, () => (...n) => {
      let r = { type: null, composers: new Set() };
      for (const i of n)
        if (i != null)
          if (i[Jd]) {
            r.type == null && (r.type = i[Jd].type);
            for (const o of i[Jd].composers) r.composers.add(o);
          } else i.constructor !== Object || i.$$typeof ? r.type == null && (r.type = i) : r.composers.add(wK(i, t));
      return r.type == null && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), SK(t, r, e);
    }),
  wK = ({ variants: t, compoundVariants: e, defaultVariants: n, ...r }, i) => {
    const o = `${Hi(i.prefix)}c-${ys(r)}`,
      s = [],
      l = [],
      a = Object.create(null),
      c = [];
    for (const d in n) a[d] = String(n[d]);
    if (typeof t == "object" && t)
      for (const d in t) {
        (u = a), (h = d), cK.call(u, h) || (a[d] = "undefined");
        const f = t[d];
        for (const p in f) {
          const m = { [d]: String(p) };
          String(p) === "undefined" && c.push(d);
          const O = f[p],
            v = [m, O, !O2(O)];
          s.push(v);
        }
      }
    var u, h;
    if (typeof e == "object" && e)
      for (const d of e) {
        let { css: f, ...p } = d;
        f = (typeof f == "object" && f) || {};
        for (const O in p) p[O] = String(p[O]);
        const m = [p, f, !O2(f)];
        l.push(m);
      }
    return [o, r, s, l, a, c];
  },
  SK = (t, e, n) => {
    const [r, i, o, s] = kK(e.composers),
      l =
        typeof e.type == "function" || e.type.$$typeof
          ? ((h) => {
              function d() {
                for (let f = 0; f < d[rc].length; f++) {
                  const [p, m] = d[rc][f];
                  h.rules[p].apply(m);
                }
                return (d[rc] = []), null;
              }
              return (d[rc] = []), (d.rules = {}), xc.forEach((f) => (d.rules[f] = { apply: (p) => d[rc].push([f, p]) })), d;
            })(n)
          : null,
      a = (l || n).rules,
      c = `.${r}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`,
      u = (h) => {
        h = (typeof h == "object" && h) || CK;
        const { css: d, ...f } = h,
          p = {};
        for (const v in o)
          if ((delete f[v], v in h)) {
            let g = h[v];
            typeof g == "object" && g
              ? (p[v] = { "@initial": o[v], ...g })
              : ((g = String(g)), (p[v] = g !== "undefined" || s.has(v) ? g : o[v]));
          } else p[v] = o[v];
        const m = new Set([...i]);
        for (const [v, g, b, x] of e.composers) {
          n.rules.styled.cache.has(v) ||
            (n.rules.styled.cache.add(v),
            bl(g, [`.${v}`], [], t, (y) => {
              a.styled.apply(y);
            }));
          const k = y2(b, p, t.media),
            w = y2(x, p, t.media, !0);
          for (const y of k)
            if (y !== void 0)
              for (const [C, P, E] of y) {
                const N = `${v}-${ys(P)}-${C}`;
                m.add(N);
                const L = (E ? n.rules.resonevar : n.rules.onevar).cache,
                  D = E ? a.resonevar : a.onevar;
                L.has(N) ||
                  (L.add(N),
                  bl(P, [`.${N}`], [], t, (Q) => {
                    D.apply(Q);
                  }));
              }
          for (const y of w)
            if (y !== void 0)
              for (const [C, P] of y) {
                const E = `${v}-${ys(P)}-${C}`;
                m.add(E),
                  n.rules.allvar.cache.has(E) ||
                    (n.rules.allvar.cache.add(E),
                    bl(P, [`.${E}`], [], t, (N) => {
                      a.allvar.apply(N);
                    }));
              }
        }
        if (typeof d == "object" && d) {
          const v = `${r}-i${ys(d)}-css`;
          m.add(v),
            n.rules.inline.cache.has(v) ||
              (n.rules.inline.cache.add(v),
              bl(d, [`.${v}`], [], t, (g) => {
                a.inline.apply(g);
              }));
        }
        for (const v of String(h.className || "")
          .trim()
          .split(/\s+/))
          v && m.add(v);
        const O = (f.className = [...m].join(" "));
        return { type: e.type, className: O, selector: c, props: f, toString: () => O, deferredInjector: l };
      };
    return ky(u, { className: r, selector: c, [Jd]: e, toString: () => (n.rules.styled.cache.has(r) || u(), r) });
  },
  kK = (t) => {
    let e = "";
    const n = [],
      r = {},
      i = [];
    for (const [o, , , , s, l] of t) {
      e === "" && (e = o), n.push(o), i.push(...l);
      for (const a in s) {
        const c = s[a];
        (r[a] === void 0 || c !== "undefined" || l.includes(c)) && (r[a] = c);
      }
    }
    return [e, n, r, new Set(i)];
  },
  y2 = (t, e, n, r) => {
    const i = [];
    e: for (let [o, s, l] of t) {
      if (l) continue;
      let a,
        c = 0,
        u = !1;
      for (a in o) {
        const h = o[a];
        let d = e[a];
        if (d !== h) {
          if (typeof d != "object" || !d) continue e;
          {
            let f,
              p,
              m = 0;
            for (const O in d) {
              if (h === String(d[O])) {
                if (O !== "@initial") {
                  const v = O.slice(1);
                  (p = p || []).push(v in n ? n[v] : O.replace(/^@media ?/, "")), (u = !0);
                }
                (c += m), (f = !0);
              }
              ++m;
            }
            if ((p && p.length && (s = { ["@media " + p.join(", ")]: s }), !f)) continue e;
          }
        }
      }
      (i[c] = i[c] || []).push([r ? "cv" : `${a}-${o[a]}`, s, u]);
    }
    return i;
  },
  CK = {},
  _K = Th(),
  EK = (t, e) =>
    _K(t, () => (...n) => {
      const r = () => {
        for (let i of n) {
          i = (typeof i == "object" && i) || {};
          let o = ys(i);
          if (!e.rules.global.cache.has(o)) {
            if ((e.rules.global.cache.add(o), "@import" in i)) {
              let s = [].indexOf.call(e.sheet.cssRules, e.rules.themed.group) - 1;
              for (let l of [].concat(i["@import"]))
                (l = l.includes('"') || l.includes("'") ? l : `"${l}"`), e.sheet.insertRule(`@import ${l};`, s++);
              delete i["@import"];
            }
            bl(i, [], [], t, (s) => {
              e.rules.global.apply(s);
            });
          }
        }
        return "";
      };
      return ky(r, { toString: r });
    }),
  TK = Th(),
  PK = (t, e) =>
    TK(t, () => (n) => {
      const r = `${Hi(t.prefix)}k-${ys(n)}`,
        i = () => {
          if (!e.rules.global.cache.has(r)) {
            e.rules.global.cache.add(r);
            const o = [];
            bl(n, [], [], t, (l) => o.push(l));
            const s = `@keyframes ${r}{${o.join("")}}`;
            e.rules.global.apply(s);
          }
          return r;
        };
      return ky(i, {
        get name() {
          return i();
        },
        toString: i,
      });
    }),
  AK = class {
    constructor(e, n, r, i) {
      (this.token = e == null ? "" : String(e)),
        (this.value = n == null ? "" : String(n)),
        (this.scale = r == null ? "" : String(r)),
        (this.prefix = i == null ? "" : String(i));
    }
    get computedValue() {
      return "var(" + this.variable + ")";
    }
    get variable() {
      return "--" + Hi(this.prefix) + Hi(this.scale) + this.token;
    }
    toString() {
      return this.computedValue;
    }
  },
  $K = Th(),
  RK = (t, e) =>
    $K(t, () => (n, r) => {
      r = (typeof n == "object" && n) || Object(r);
      const i = `.${(n = (n = typeof n == "string" ? n : "") || `${Hi(t.prefix)}t-${ys(r)}`)}`,
        o = {},
        s = [];
      for (const a in r) {
        o[a] = {};
        for (const c in r[a]) {
          const u = `--${Hi(t.prefix)}${a}-${c}`,
            h = x9(String(r[a][c]), t.prefix, a);
          (o[a][c] = new AK(c, h, a, t.prefix)), s.push(`${u}:${h}`);
        }
      }
      const l = () => {
        if (s.length && !e.rules.themed.cache.has(n)) {
          e.rules.themed.cache.add(n);
          const a = `${r === t.theme ? ":root," : ""}.${n}{${s.join(";")}}`;
          e.rules.themed.apply(a);
        }
        return n;
      };
      return {
        ...o,
        get className() {
          return l();
        },
        selector: i,
        toString: l,
      };
    }),
  IK = Th(),
  MK = (t) => {
    let e = !1;
    const n = IK(t, (r) => {
      e = !0;
      const i = "prefix" in (r = (typeof r == "object" && r) || {}) ? String(r.prefix) : "",
        o = (typeof r.media == "object" && r.media) || {},
        s = typeof r.root == "object" ? r.root || null : globalThis.document || null,
        l = (typeof r.theme == "object" && r.theme) || {},
        a = {
          prefix: i,
          media: o,
          theme: l,
          themeMap: (typeof r.themeMap == "object" && r.themeMap) || { ...lK },
          utils: (typeof r.utils == "object" && r.utils) || {},
        },
        c = vK(s),
        u = {
          css: yK(a, c),
          globalCss: EK(a, c),
          keyframes: PK(a, c),
          createTheme: RK(a, c),
          reset() {
            c.reset(), u.theme.toString();
          },
          theme: {},
          sheet: c,
          config: a,
          prefix: i,
          getCssText: c.toString,
          toString: c.toString,
        };
      return String((u.theme = u.createTheme(l))), u;
    });
    return e || n.reset(), n;
  },
  w2 = Object.prototype.hasOwnProperty;
function S2(t, e, n) {
  for (n of t.keys()) if (Fc(n, e)) return n;
}
function Fc(t, e) {
  var n, r, i;
  if (t === e) return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date) return t.getTime() === e.getTime();
    if (n === RegExp) return t.toString() === e.toString();
    if (n === Array) {
      if ((r = t.length) === e.length) for (; r-- && Fc(t[r], e[r]); );
      return r === -1;
    }
    if (n === Set) {
      if (t.size !== e.size) return !1;
      for (r of t) if (((i = r), (i && typeof i == "object" && ((i = S2(e, i)), !i)) || !e.has(i))) return !1;
      return !0;
    }
    if (n === Map) {
      if (t.size !== e.size) return !1;
      for (r of t) if (((i = r[0]), (i && typeof i == "object" && ((i = S2(e, i)), !i)) || !Fc(r[1], e.get(i)))) return !1;
      return !0;
    }
    if (n === ArrayBuffer) (t = new Uint8Array(t)), (e = new Uint8Array(e));
    else if (n === DataView) {
      if ((r = t.byteLength) === e.byteLength) for (; r-- && t.getInt8(r) === e.getInt8(r); );
      return r === -1;
    }
    if (ArrayBuffer.isView(t)) {
      if ((r = t.byteLength) === e.byteLength) for (; r-- && t[r] === e[r]; );
      return r === -1;
    }
    if (!n || typeof t == "object") {
      r = 0;
      for (n in t) if ((w2.call(t, n) && ++r && !w2.call(e, n)) || !(n in e) || !Fc(t[n], e[n])) return !1;
      return Object.keys(e).length === r;
    }
  }
  return t !== t && e !== e;
}
var LK = /(%?)(%([sdjo]))/g;
function NK(t, e) {
  switch (e) {
    case "s":
      return t;
    case "d":
    case "i":
      return Number(t);
    case "j":
      return JSON.stringify(t);
    case "o": {
      if (typeof t == "string") return t;
      const n = JSON.stringify(t);
      return n === "{}" || n === "[]" || /^\[object .+?\]$/.test(n) ? t : n;
    }
  }
}
function gO(t, ...e) {
  if (e.length === 0) return t;
  let n = 0,
    r = t.replace(LK, (i, o, s, l) => {
      const a = e[n],
        c = NK(a, l);
      return o ? i : (n++, c);
    });
  return n < e.length && (r += ` ${e.slice(n).join(" ")}`), (r = r.replace(/%{2,2}/g, "%")), r;
}
var QK = 2;
function DK(t) {
  if (!t.stack) return;
  const e = t.stack.split(`
`);
  e.splice(1, QK),
    (t.stack = e.join(`
`));
}
var FK = class extends Error {
    constructor(t, ...e) {
      super(t), (this.message = t), (this.name = "Invariant Violation"), (this.message = gO(t, ...e)), DK(this);
    }
  },
  y9 = (t, e, ...n) => {
    if (!t) throw new FK(e, ...n);
  };
y9.as = (t, e, n, ...r) => {
  if (!e) throw t.prototype.name != null ? new t(gO(n, r)) : t(gO(n, r));
};
var OO = function (t, e) {
  return (
    (OO =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r;
        }) ||
      function (n, r) {
        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }),
    OO(t, e)
  );
};
function Dme(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  OO(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n());
}
var xl = function () {
  return (
    (xl =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
        }
        return e;
      }),
    xl.apply(this, arguments)
  );
};
function BK(t, e, n, r) {
  function i(o) {
    return o instanceof n
      ? o
      : new n(function (s) {
          s(o);
        });
  }
  return new (n || (n = Promise))(function (o, s) {
    function l(u) {
      try {
        c(r.next(u));
      } catch (h) {
        s(h);
      }
    }
    function a(u) {
      try {
        c(r.throw(u));
      } catch (h) {
        s(h);
      }
    }
    function c(u) {
      u.done ? o(u.value) : i(u.value).then(l, a);
    }
    c((r = r.apply(t, e || [])).next());
  });
}
function VK(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (o[0] & 1) throw o[1];
        return o[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    o,
    s;
  return (
    (s = { next: l(0), throw: l(1), return: l(2) }),
    typeof Symbol == "function" &&
      (s[Symbol.iterator] = function () {
        return this;
      }),
    s
  );
  function l(c) {
    return function (u) {
      return a([c, u]);
    };
  }
  function a(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (
          ((r = 1),
          i && (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, c[1])).done)
        )
          return o;
        switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
          case 0:
          case 1:
            o = c;
            break;
          case 4:
            return n.label++, { value: c[1], done: !1 };
          case 5:
            n.label++, (i = c[1]), (c = [0]);
            continue;
          case 7:
            (c = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
              n = 0;
              continue;
            }
            if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
              n.label = c[1];
              break;
            }
            if (c[0] === 6 && n.label < o[1]) {
              (n.label = o[1]), (o = c);
              break;
            }
            if (o && n.label < o[2]) {
              (n.label = o[2]), n.ops.push(c);
              break;
            }
            o[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        c = e.call(t, n);
      } catch (u) {
        (c = [6, u]), (i = 0);
      } finally {
        r = o = 0;
      }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function Fme(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, o; r < i; r++) (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), (o[r] = e[r]));
  return t.concat(o || Array.prototype.slice.call(e));
}
var k2;
(function (t) {
  (t[(t.None = 0)] = "None"),
    (t[(t.Error = 10)] = "Error"),
    (t[(t.Warning = 20)] = "Warning"),
    (t[(t.Info = 30)] = "Info"),
    (t[(t.Debug = 40)] = "Debug");
})(k2 || (k2 = {}));
var jK = function (t) {
  return "[sandpack-client]: ".concat(t);
};
function r1(t, e) {
  return e === void 0 && (e = "Value is nullish"), y9(t != null, jK(e)), t;
}
var ZK = '"dependencies" was not specified - provide either a package.json or a "dependencies" value',
  C2 = '"entry" was not specified - provide either a package.json with the "main" field or an "entry" value';
function zK(t, e, n) {
  return (
    t === void 0 && (t = {}),
    e === void 0 && (e = {}),
    n === void 0 && (n = "/index.js"),
    JSON.stringify({ name: "sandpack-project", main: n, dependencies: t, devDependencies: e }, null, 2)
  );
}
function WK(t, e, n, r) {
  var i,
    o,
    s = Rs(t),
    l = s["/package.json"];
  if (!l) return r1(e, ZK), r1(r, C2), (s["/package.json"] = { code: zK(e, n, r) }), s;
  if (l) {
    var a = JSON.parse(l.code);
    r1(!(!e && !a.dependencies), C2),
      e && (a.dependencies = xl(xl({}, (i = a.dependencies) !== null && i !== void 0 ? i : {}), e ?? {})),
      n && (a.devDependencies = xl(xl({}, (o = a.devDependencies) !== null && o !== void 0 ? o : {}), n ?? {})),
      r && (a.main = r),
      (s["/package.json"] = { code: JSON.stringify(a, null, 2) });
  }
  return s;
}
function XK(t) {
  var e;
  if (t.title === "SyntaxError") {
    var n = t.title,
      r = t.path,
      i = t.message,
      o = t.line,
      s = t.column;
    return { title: n, path: r, message: i, line: o, column: s };
  }
  var l = UK((e = t.payload) === null || e === void 0 ? void 0 : e.frames);
  if (!l) return { message: t.message };
  var a = qK(l),
    c = HK(l),
    u = YK(l._originalFileName, t.message, c, a);
  return { message: u, title: t.title, path: l._originalFileName, line: l._originalLineNumber, column: l._originalColumnNumber };
}
function UK(t) {
  if (t)
    return t.find(function (e) {
      return !!e._originalFileName;
    });
}
function HK(t) {
  return t ? " (".concat(t._originalLineNumber, ":").concat(t._originalColumnNumber, ")") : "";
}
function qK(t) {
  var e = t._originalScriptCode[t._originalScriptCode.length - 1],
    n = e.lineNumber.toString().length,
    r = 2,
    i = 3,
    o = r + n + i + t._originalColumnNumber;
  return t._originalScriptCode.reduce(function (s, l) {
    var a = l.highlight ? ">" : " ",
      c = l.lineNumber.toString().length === n ? "".concat(l.lineNumber) : " ".concat(l.lineNumber),
      u = l.highlight
        ? `
` +
          " ".repeat(o) +
          "^"
        : "";
    return (
      s +
      `
` +
      a +
      " " +
      c +
      " | " +
      l.content +
      u
    );
  }, "");
}
function YK(t, e, n, r) {
  return ""
    .concat(t, ": ")
    .concat(e)
    .concat(
      n,
      `
`
    )
    .concat(r);
}
var Rs = function (t) {
  return typeof t == "string"
    ? t.startsWith("/")
      ? t
      : "/".concat(t)
    : Array.isArray(t)
    ? t.map(function (e) {
        return e.startsWith("/") ? e : "/".concat(e);
      })
    : typeof t == "object" && t !== null
    ? Object.entries(t).reduce(function (e, n) {
        var r = n[0],
          i = n[1],
          o = r.startsWith("/") ? r : "/".concat(r);
        return (e[o] = i), e;
      }, {})
    : null;
};
function GK(t, e, n) {
  var r;
  return (
    n === void 0 && (n = {}),
    BK(this, void 0, void 0, function () {
      var i, o, s;
      return VK(this, function (l) {
        switch (l.label) {
          case 0:
            switch (((i = (r = e.template) !== null && r !== void 0 ? r : "parcel"), (s = i), s)) {
              case "node":
                return [3, 1];
              case "static":
                return [3, 3];
            }
            return [3, 5];
          case 1:
            return [
              4,
              z(
                () => import("./index-dba7c534.js"),
                [
                  "./index-dba7c534.js",
                  "./base-80a1f760-2864de52.js",
                  "./consoleHook-59e792cb-f30916d2.js",
                  "./index-c6dae603.js",
                  "./PolarisAutoForm-e187dbdc.js",
                  "./apis-d6201c92.js",
                  "./index-eb008d06.js",
                  "./iframe-5aa777a6.js",
                  "./useAction-e2e8ce4c.js",
                  "./index-0511f421.js",
                  "./extends-98964cd2.js",
                  "./index-baeb160b.js",
                ],
                import.meta.url
              ).then(function (a) {
                return a.SandpackNode;
              }),
            ];
          case 2:
            return (o = l.sent()), [3, 7];
          case 3:
            return [
              4,
              z(
                () => import("./index-585bceb7-02483822.js"),
                [
                  "./index-585bceb7-02483822.js",
                  "./consoleHook-59e792cb-f30916d2.js",
                  "./base-80a1f760-2864de52.js",
                  "./index-c6dae603.js",
                  "./PolarisAutoForm-e187dbdc.js",
                  "./apis-d6201c92.js",
                  "./index-eb008d06.js",
                  "./iframe-5aa777a6.js",
                  "./useAction-e2e8ce4c.js",
                  "./index-0511f421.js",
                  "./extends-98964cd2.js",
                  "./index-baeb160b.js",
                ],
                import.meta.url
              ).then(function (a) {
                return a.SandpackStatic;
              }),
            ];
          case 4:
            return (o = l.sent()), [3, 7];
          case 5:
            return [
              4,
              z(
                () => import("./index-bee537cb.js"),
                [
                  "./index-bee537cb.js",
                  "./base-80a1f760-2864de52.js",
                  "./index-c6dae603.js",
                  "./PolarisAutoForm-e187dbdc.js",
                  "./apis-d6201c92.js",
                  "./index-eb008d06.js",
                  "./iframe-5aa777a6.js",
                  "./useAction-e2e8ce4c.js",
                  "./index-0511f421.js",
                  "./extends-98964cd2.js",
                  "./index-baeb160b.js",
                ],
                import.meta.url
              ).then(function (a) {
                return a.SandpackRuntime;
              }),
            ];
          case 6:
            (o = l.sent()), (l.label = 7);
          case 7:
            return [2, new o(t, e, n)];
        }
      });
    })
  );
}
let et = class w9 {
  lineAt(e) {
    if (e < 0 || e > this.length) throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  line(e) {
    if (e < 1 || e > this.lines) throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  replace(e, n, r) {
    [e, n] = na(this, e, n);
    let i = [];
    return (
      this.decompose(0, e, i, 2),
      r.length && r.decompose(0, r.length, i, 3),
      this.decompose(n, this.length, i, 1),
      ri.from(i, this.length - (n - e) + r.length)
    );
  }
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  slice(e, n = this.length) {
    [e, n] = na(this, e, n);
    let r = [];
    return this.decompose(e, n, r, 0), ri.from(r, n - e);
  }
  eq(e) {
    if (e == this) return !0;
    if (e.length != this.length || e.lines != this.lines) return !1;
    let n = this.scanIdentical(e, 1),
      r = this.length - this.scanIdentical(e, -1),
      i = new Bc(this),
      o = new Bc(e);
    for (let s = n, l = n; ; ) {
      if ((i.next(s), o.next(s), (s = 0), i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)) return !1;
      if (((l += i.value.length), i.done || l >= r)) return !0;
    }
  }
  iter(e = 1) {
    return new Bc(this, e);
  }
  iterRange(e, n = this.length) {
    return new S9(this, e, n);
  }
  iterLines(e, n) {
    let r;
    if (e == null) r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new k9(r);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  constructor() {}
  static of(e) {
    if (e.length == 0) throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? w9.empty : e.length <= 32 ? new Lt(e) : ri.from(Lt.split(e, []));
  }
};
class Lt extends et {
  constructor(e, n = JK(e)) {
    super(), (this.text = e), (this.length = n);
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.text[o],
        l = i + s.length;
      if ((n ? r : l) >= e) return new KK(i, l, r, s);
      (i = l + 1), r++;
    }
  }
  decompose(e, n, r, i) {
    let o = e <= 0 && n >= this.length ? this : new Lt(_2(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (i & 1) {
      let s = r.pop(),
        l = Kd(o.text, s.text.slice(), 0, o.length);
      if (l.length <= 32) r.push(new Lt(l, s.length + o.length));
      else {
        let a = l.length >> 1;
        r.push(new Lt(l.slice(0, a)), new Lt(l.slice(a)));
      }
    } else r.push(o);
  }
  replace(e, n, r) {
    if (!(r instanceof Lt)) return super.replace(e, n, r);
    [e, n] = na(this, e, n);
    let i = Kd(this.text, Kd(r.text, _2(this.text, 0, e)), n),
      o = this.length + r.length - (n - e);
    return i.length <= 32 ? new Lt(i, o) : ri.from(Lt.split(i, []), o);
  }
  sliceString(
    e,
    n = this.length,
    r = `
`
  ) {
    [e, n] = na(this, e, n);
    let i = "";
    for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
      let l = this.text[s],
        a = o + l.length;
      o > e && s && (i += r), e < a && n > o && (i += l.slice(Math.max(0, e - o), n - o)), (o = a + 1);
    }
    return i;
  }
  flatten(e) {
    for (let n of this.text) e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let r = [],
      i = -1;
    for (let o of e) r.push(o), (i += o.length + 1), r.length == 32 && (n.push(new Lt(r, i)), (r = []), (i = -1));
    return i > -1 && n.push(new Lt(r, i)), n;
  }
}
class ri extends et {
  constructor(e, n) {
    super(), (this.children = e), (this.length = n), (this.lines = 0);
    for (let r of e) this.lines += r.lines;
  }
  lineInner(e, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.children[o],
        l = i + s.length,
        a = r + s.lines - 1;
      if ((n ? a : l) >= e) return s.lineInner(e, n, r, i);
      (i = l + 1), (r = a + 1);
    }
  }
  decompose(e, n, r, i) {
    for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
      let l = this.children[o],
        a = s + l.length;
      if (e <= a && n >= s) {
        let c = i & ((s <= e ? 1 : 0) | (a >= n ? 2 : 0));
        s >= e && a <= n && !c ? r.push(l) : l.decompose(e - s, n - s, r, c);
      }
      s = a + 1;
    }
  }
  replace(e, n, r) {
    if ((([e, n] = na(this, e, n)), r.lines < this.lines))
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let s = this.children[i],
          l = o + s.length;
        if (e >= o && n <= l) {
          let a = s.replace(e - o, n - o, r),
            c = this.lines - s.lines + a.lines;
          if (a.lines < c >> (5 - 1) && a.lines > c >> (5 + 1)) {
            let u = this.children.slice();
            return (u[i] = a), new ri(u, this.length - (n - e) + r.length);
          }
          return super.replace(o, l, a);
        }
        o = l + 1;
      }
    return super.replace(e, n, r);
  }
  sliceString(
    e,
    n = this.length,
    r = `
`
  ) {
    [e, n] = na(this, e, n);
    let i = "";
    for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
      let l = this.children[o],
        a = s + l.length;
      s > e && o && (i += r), e < a && n > s && (i += l.sliceString(e - s, n - s, r)), (s = a + 1);
    }
    return i;
  }
  flatten(e) {
    for (let n of this.children) n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof ri)) return 0;
    let r = 0,
      [i, o, s, l] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += n, o += n) {
      if (i == s || o == l) return r;
      let a = this.children[i],
        c = e.children[o];
      if (a != c) return r + a.scanIdentical(c, n);
      r += a.length + 1;
    }
  }
  static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let f of e) r += f.lines;
    if (r < 32) {
      let f = [];
      for (let p of e) p.flatten(f);
      return new Lt(f, n);
    }
    let i = Math.max(32, r >> 5),
      o = i << 1,
      s = i >> 1,
      l = [],
      a = 0,
      c = -1,
      u = [];
    function h(f) {
      let p;
      if (f.lines > o && f instanceof ri) for (let m of f.children) h(m);
      else
        f.lines > s && (a > s || !a)
          ? (d(), l.push(f))
          : f instanceof Lt && a && (p = u[u.length - 1]) instanceof Lt && f.lines + p.lines <= 32
          ? ((a += f.lines), (c += f.length + 1), (u[u.length - 1] = new Lt(p.text.concat(f.text), p.length + 1 + f.length)))
          : (a + f.lines > i && d(), (a += f.lines), (c += f.length + 1), u.push(f));
    }
    function d() {
      a != 0 && (l.push(u.length == 1 ? u[0] : ri.from(u, c)), (c = -1), (a = u.length = 0));
    }
    for (let f of e) h(f);
    return d(), l.length == 1 ? l[0] : new ri(l, n);
  }
}
et.empty = new Lt([""], 0);
function JK(t) {
  let e = -1;
  for (let n of t) e += n.length + 1;
  return e;
}
function Kd(t, e, n = 0, r = 1e9) {
  for (let i = 0, o = 0, s = !0; o < t.length && i <= r; o++) {
    let l = t[o],
      a = i + l.length;
    a >= n && (a > r && (l = l.slice(0, r - i)), i < n && (l = l.slice(n - i)), s ? ((e[e.length - 1] += l), (s = !1)) : e.push(l)),
      (i = a + 1);
  }
  return e;
}
function _2(t, e, n) {
  return Kd(t, [""], e, n);
}
class Bc {
  constructor(e, n = 1) {
    (this.dir = n),
      (this.done = !1),
      (this.lineBreak = !1),
      (this.value = ""),
      (this.nodes = [e]),
      (this.offsets = [n > 0 ? 1 : (e instanceof Lt ? e.text.length : e.children.length) << 1]);
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1,
        i = this.nodes[r],
        o = this.offsets[r],
        s = o >> 1,
        l = i instanceof Lt ? i.text.length : i.children.length;
      if (s == (n > 0 ? l : 0)) {
        if (r == 0) return (this.done = !0), (this.value = ""), this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (n > 0 ? 0 : 1)) {
        if (((this.offsets[r] += n), e == 0))
          return (
            (this.lineBreak = !0),
            (this.value = `
`),
            this
          );
        e--;
      } else if (i instanceof Lt) {
        let a = i.text[s + (n < 0 ? -1 : 0)];
        if (((this.offsets[r] += n), a.length > Math.max(0, e)))
          return (this.value = e == 0 ? a : n > 0 ? a.slice(e) : a.slice(0, a.length - e)), this;
        e -= a.length;
      } else {
        let a = i.children[s + (n < 0 ? -1 : 0)];
        e > a.length
          ? ((e -= a.length), (this.offsets[r] += n))
          : (n < 0 && this.offsets[r]--,
            this.nodes.push(a),
            this.offsets.push(n > 0 ? 1 : (a instanceof Lt ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), (e = this.value.length)), this.nextInner(e, this.dir);
  }
}
class S9 {
  constructor(e, n, r) {
    (this.value = ""),
      (this.done = !1),
      (this.cursor = new Bc(e, n > r ? -1 : 1)),
      (this.pos = n > r ? e.length : 0),
      (this.from = Math.min(n, r)),
      (this.to = Math.max(n, r));
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to) return (this.value = ""), (this.done = !0), this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), (r -= e);
    let { value: i } = this.cursor.next(e);
    return (
      (this.pos += (i.length + e) * n),
      (this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r)),
      (this.done = !this.value),
      this
    );
  }
  next(e = 0) {
    return (
      e < 0 ? (e = Math.max(e, this.from - this.pos)) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir)
    );
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class k9 {
  constructor(e) {
    (this.inner = e), (this.afterBreak = !0), (this.value = ""), (this.done = !1);
  }
  next(e = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(e);
    return (
      n && this.afterBreak
        ? ((this.value = ""), (this.afterBreak = !1))
        : n
        ? ((this.done = !0), (this.value = ""))
        : r
        ? this.afterBreak
          ? (this.value = "")
          : ((this.afterBreak = !0), this.next())
        : ((this.value = i), (this.afterBreak = !1)),
      this
    );
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" &&
  ((et.prototype[Symbol.iterator] = function () {
    return this.iter();
  }),
  (Bc.prototype[Symbol.iterator] =
    S9.prototype[Symbol.iterator] =
    k9.prototype[Symbol.iterator] =
      function () {
        return this;
      }));
let KK = class {
  constructor(e, n, r, i) {
    (this.from = e), (this.to = n), (this.number = r), (this.text = i);
  }
  get length() {
    return this.to - this.from;
  }
};
function na(t, e, n) {
  return (e = Math.max(0, Math.min(t.length, e))), [e, Math.max(e, Math.min(t.length, n))];
}
let Ll =
  "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o"
    .split(",")
    .map((t) => (t ? parseInt(t, 36) : 1));
for (let t = 1; t < Ll.length; t++) Ll[t] += Ll[t - 1];
function eee(t) {
  for (let e = 1; e < Ll.length; e += 2) if (Ll[e] > t) return Ll[e - 1] <= t;
  return !1;
}
function E2(t) {
  return t >= 127462 && t <= 127487;
}
const T2 = 8205;
function dn(t, e, n = !0, r = !0) {
  return (n ? C9 : tee)(t, e, r);
}
function C9(t, e, n) {
  if (e == t.length) return e;
  e && _9(t.charCodeAt(e)) && E9(t.charCodeAt(e - 1)) && e--;
  let r = an(t, e);
  for (e += dr(r); e < t.length; ) {
    let i = an(t, e);
    if (r == T2 || i == T2 || (n && eee(i))) (e += dr(i)), (r = i);
    else if (E2(i)) {
      let o = 0,
        s = e - 2;
      for (; s >= 0 && E2(an(t, s)); ) o++, (s -= 2);
      if (o % 2 == 0) break;
      e += 2;
    } else break;
  }
  return e;
}
function tee(t, e, n) {
  for (; e > 0; ) {
    let r = C9(t, e - 2, n);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function _9(t) {
  return t >= 56320 && t < 57344;
}
function E9(t) {
  return t >= 55296 && t < 56320;
}
function an(t, e) {
  let n = t.charCodeAt(e);
  if (!E9(n) || e + 1 == t.length) return n;
  let r = t.charCodeAt(e + 1);
  return _9(r) ? ((n - 55296) << 10) + (r - 56320) + 65536 : n;
}
function Cy(t) {
  return t <= 65535 ? String.fromCharCode(t) : ((t -= 65536), String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function dr(t) {
  return t < 65536 ? 1 : 2;
}
const vO = /\r\n?|\n/;
var un = (function (t) {
  return (
    (t[(t.Simple = 0)] = "Simple"),
    (t[(t.TrackDel = 1)] = "TrackDel"),
    (t[(t.TrackBefore = 2)] = "TrackBefore"),
    (t[(t.TrackAfter = 3)] = "TrackAfter"),
    t
  );
})(un || (un = {}));
class fi {
  constructor(e) {
    this.sections = e;
  }
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) e += this.sections[n];
    return e;
  }
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      e += r < 0 ? this.sections[n] : r;
    }
    return e;
  }
  get empty() {
    return this.sections.length == 0 || (this.sections.length == 2 && this.sections[1] < 0);
  }
  iterGaps(e) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let o = this.sections[n++],
        s = this.sections[n++];
      s < 0 ? (e(r, i, o), (i += o)) : (i += s), (r += o);
    }
  }
  iterChangedRanges(e, n = !1) {
    bO(this, e, n);
  }
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++],
        i = this.sections[n++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new fi(e);
  }
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : T9(this, e);
  }
  mapDesc(e, n = !1) {
    return e.empty ? this : xO(this, e, n);
  }
  mapPos(e, n = -1, r = un.Simple) {
    let i = 0,
      o = 0;
    for (let s = 0; s < this.sections.length; ) {
      let l = this.sections[s++],
        a = this.sections[s++],
        c = i + l;
      if (a < 0) {
        if (c > e) return o + (e - i);
        o += l;
      } else {
        if (
          r != un.Simple &&
          c >= e &&
          ((r == un.TrackDel && i < e && c > e) || (r == un.TrackBefore && i < e) || (r == un.TrackAfter && c > e))
        )
          return null;
        if (c > e || (c == e && n < 0 && !l)) return e == i || n < 0 ? o : o + a;
        o += a;
      }
      i = c;
    }
    if (e > i) throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return o;
  }
  touchesRange(e, n = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let o = this.sections[r++],
        s = this.sections[r++],
        l = i + o;
      if (s >= 0 && i <= n && l >= e) return i < e && l > n ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++],
        i = this.sections[n++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new fi(e);
  }
  static create(e) {
    return new fi(e);
  }
}
class jt extends fi {
  constructor(e, n) {
    super(e), (this.inserted = n);
  }
  apply(e) {
    if (this.length != e.length) throw new RangeError("Applying change set to a document with the wrong length");
    return bO(this, (n, r, i, o, s) => (e = e.replace(i, i + (r - n), s)), !1), e;
  }
  mapDesc(e, n = !1) {
    return xO(this, e, n, !0);
  }
  invert(e) {
    let n = this.sections.slice(),
      r = [];
    for (let i = 0, o = 0; i < n.length; i += 2) {
      let s = n[i],
        l = n[i + 1];
      if (l >= 0) {
        (n[i] = l), (n[i + 1] = s);
        let a = i >> 1;
        for (; r.length < a; ) r.push(et.empty);
        r.push(s ? e.slice(o, o + s) : et.empty);
      }
      o += s;
    }
    return new jt(n, r);
  }
  compose(e) {
    return this.empty ? e : e.empty ? this : T9(this, e, !0);
  }
  map(e, n = !1) {
    return e.empty ? this : xO(this, e, n, !0);
  }
  iterChanges(e, n = !1) {
    bO(this, e, n);
  }
  get desc() {
    return fi.create(this.sections);
  }
  filter(e) {
    let n = [],
      r = [],
      i = [],
      o = new gu(this);
    e: for (let s = 0, l = 0; ; ) {
      let a = s == e.length ? 1e9 : e[s++];
      for (; l < a || (l == a && o.len == 0); ) {
        if (o.done) break e;
        let u = Math.min(o.len, a - l);
        gn(i, u, -1);
        let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
        gn(n, u, h), h > 0 && yo(r, n, o.text), o.forward(u), (l += u);
      }
      let c = e[s++];
      for (; l < c; ) {
        if (o.done) break e;
        let u = Math.min(o.len, c - l);
        gn(n, u, -1), gn(i, u, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(u), (l += u);
      }
    }
    return { changes: new jt(n, r), filtered: fi.create(i) };
  }
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n],
        i = this.sections[n + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  static of(e, n, r) {
    let i = [],
      o = [],
      s = 0,
      l = null;
    function a(u = !1) {
      if (!u && !i.length) return;
      s < n && gn(i, n - s, -1);
      let h = new jt(i, o);
      (l = l ? l.compose(h.map(l)) : h), (i = []), (o = []), (s = 0);
    }
    function c(u) {
      if (Array.isArray(u)) for (let h of u) c(h);
      else if (u instanceof jt) {
        if (u.length != n) throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
        a(), (l = l ? l.compose(u.map(l)) : u);
      } else {
        let { from: h, to: d = h, insert: f } = u;
        if (h > d || h < 0 || d > n) throw new RangeError(`Invalid change range ${h} to ${d} (in doc of length ${n})`);
        let p = f ? (typeof f == "string" ? et.of(f.split(r || vO)) : f) : et.empty,
          m = p.length;
        if (h == d && m == 0) return;
        h < s && a(), h > s && gn(i, h - s, -1), gn(i, d - h, m), yo(o, i, p), (s = d);
      }
    }
    return c(e), a(!l), l;
  }
  static empty(e) {
    return new jt(e ? [e, -1] : [], []);
  }
  static fromJSON(e) {
    if (!Array.isArray(e)) throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [],
      r = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (typeof o == "number") n.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, l) => l && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1) n.push(o[0], 0);
        else {
          for (; r.length < i; ) r.push(et.empty);
          (r[i] = et.of(o.slice(1))), n.push(o[0], r[i].length);
        }
      }
    }
    return new jt(n, r);
  }
  static createSet(e, n) {
    return new jt(e, n);
  }
}
function gn(t, e, n, r = !1) {
  if (e == 0 && n <= 0) return;
  let i = t.length - 2;
  i >= 0 && n <= 0 && n == t[i + 1]
    ? (t[i] += e)
    : e == 0 && t[i] == 0
    ? (t[i + 1] += n)
    : r
    ? ((t[i] += e), (t[i + 1] += n))
    : t.push(e, n);
}
function yo(t, e, n) {
  if (n.length == 0) return;
  let r = (e.length - 2) >> 1;
  if (r < t.length) t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < r; ) t.push(et.empty);
    t.push(n);
  }
}
function bO(t, e, n) {
  let r = t.inserted;
  for (let i = 0, o = 0, s = 0; s < t.sections.length; ) {
    let l = t.sections[s++],
      a = t.sections[s++];
    if (a < 0) (i += l), (o += l);
    else {
      let c = i,
        u = o,
        h = et.empty;
      for (; (c += l), (u += a), a && r && (h = h.append(r[(s - 2) >> 1])), !(n || s == t.sections.length || t.sections[s + 1] < 0); )
        (l = t.sections[s++]), (a = t.sections[s++]);
      e(i, c, o, u, h), (i = c), (o = u);
    }
  }
}
function xO(t, e, n, r = !1) {
  let i = [],
    o = r ? [] : null,
    s = new gu(t),
    l = new gu(e);
  for (let a = -1; ; )
    if (s.ins == -1 && l.ins == -1) {
      let c = Math.min(s.len, l.len);
      gn(i, c, -1), s.forward(c), l.forward(c);
    } else if (l.ins >= 0 && (s.ins < 0 || a == s.i || (s.off == 0 && (l.len < s.len || (l.len == s.len && !n))))) {
      let c = l.len;
      for (gn(i, l.ins, -1); c; ) {
        let u = Math.min(s.len, c);
        s.ins >= 0 && a < s.i && s.len <= u && (gn(i, 0, s.ins), o && yo(o, i, s.text), (a = s.i)), s.forward(u), (c -= u);
      }
      l.next();
    } else if (s.ins >= 0) {
      let c = 0,
        u = s.len;
      for (; u; )
        if (l.ins == -1) {
          let h = Math.min(u, l.len);
          (c += h), (u -= h), l.forward(h);
        } else if (l.ins == 0 && l.len < u) (u -= l.len), l.next();
        else break;
      gn(i, c, a < s.i ? s.ins : 0), o && a < s.i && yo(o, i, s.text), (a = s.i), s.forward(s.len - u);
    } else {
      if (s.done && l.done) return o ? jt.createSet(i, o) : fi.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function T9(t, e, n = !1) {
  let r = [],
    i = n ? [] : null,
    o = new gu(t),
    s = new gu(e);
  for (let l = !1; ; ) {
    if (o.done && s.done) return i ? jt.createSet(r, i) : fi.create(r);
    if (o.ins == 0) gn(r, o.len, 0, l), o.next();
    else if (s.len == 0 && !s.done) gn(r, 0, s.ins, l), i && yo(i, r, s.text), s.next();
    else {
      if (o.done || s.done) throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(o.len2, s.len),
          c = r.length;
        if (o.ins == -1) {
          let u = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          gn(r, a, u, l), i && u && yo(i, r, s.text);
        } else
          s.ins == -1
            ? (gn(r, o.off ? 0 : o.len, a, l), i && yo(i, r, o.textBit(a)))
            : (gn(r, o.off ? 0 : o.len, s.off ? 0 : s.ins, l), i && !s.off && yo(i, r, s.text));
        (l = (o.ins > a || (s.ins >= 0 && s.len > a)) && (l || r.length > c)), o.forward2(a), s.forward(a);
      }
    }
  }
}
class gu {
  constructor(e) {
    (this.set = e), (this.i = 0), this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? ((this.len = e[this.i++]), (this.ins = e[this.i++])) : ((this.len = 0), (this.ins = -2)), (this.off = 0);
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set,
      n = (this.i - 2) >> 1;
    return n >= e.length ? et.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set,
      r = (this.i - 2) >> 1;
    return r >= n.length && !e ? et.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : ((this.len -= e), (this.off += e));
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : ((this.ins -= e), (this.off += e));
  }
}
class ms {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.flags = r);
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  map(e, n = -1) {
    let r, i;
    return (
      this.empty ? (r = i = e.mapPos(this.from, n)) : ((r = e.mapPos(this.from, 1)), (i = e.mapPos(this.to, -1))),
      r == this.from && i == this.to ? this : new ms(r, i, this.flags)
    );
  }
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor) return H.range(e, n);
    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return H.range(this.anchor, r);
  }
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return H.range(e.anchor, e.head);
  }
  static create(e, n, r) {
    return new ms(e, n, r);
  }
}
class H {
  constructor(e, n) {
    (this.ranges = e), (this.mainIndex = n);
  }
  map(e, n = -1) {
    return e.empty
      ? this
      : H.create(
          this.ranges.map((r) => r.map(e, n)),
          this.mainIndex
        );
  }
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1;
    for (let r = 0; r < this.ranges.length; r++) if (!this.ranges[r].eq(e.ranges[r], n)) return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new H([this.main], 0);
  }
  addRange(e, n = !0) {
    return H.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  replaceRange(e, n = this.mainIndex) {
    let r = this.ranges.slice();
    return (r[n] = e), H.create(r, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new H(
      e.ranges.map((n) => ms.fromJSON(n)),
      e.main
    );
  }
  static single(e, n = e) {
    return new H([H.range(e, n)], 0);
  }
  static create(e, n = 0) {
    if (e.length == 0) throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let o = e[i];
      if (o.empty ? o.from <= r : o.from < r) return H.normalized(e.slice(), n);
      r = o.to;
    }
    return new H(e, n);
  }
  static cursor(e, n = 0, r, i) {
    return ms.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | ((i ?? 16777215) << 6));
  }
  static range(e, n, r, i) {
    let o = ((r ?? 16777215) << 6) | (i == null ? 7 : Math.min(6, i));
    return n < e ? ms.create(n, e, 48 | o) : ms.create(e, n, (n > e ? 8 : 0) | o);
  }
  static normalized(e, n = 0) {
    let r = e[n];
    e.sort((i, o) => i.from - o.from), (n = e.indexOf(r));
    for (let i = 1; i < e.length; i++) {
      let o = e[i],
        s = e[i - 1];
      if (o.empty ? o.from <= s.to : o.from < s.to) {
        let l = s.from,
          a = Math.max(o.to, s.to);
        i <= n && n--, e.splice(--i, 2, o.anchor > o.head ? H.range(a, l) : H.range(l, a));
      }
    }
    return new H(e, n);
  }
}
function P9(t, e) {
  for (let n of t.ranges) if (n.to > e) throw new RangeError("Selection points outside of document");
}
let _y = 0;
class xe {
  constructor(e, n, r, i, o) {
    (this.combine = e),
      (this.compareInput = n),
      (this.compare = r),
      (this.isStatic = i),
      (this.id = _y++),
      (this.default = e([])),
      (this.extensions = typeof o == "function" ? o(this) : o);
  }
  get reader() {
    return this;
  }
  static define(e = {}) {
    return new xe(
      e.combine || ((n) => n),
      e.compareInput || ((n, r) => n === r),
      e.compare || (e.combine ? (n, r) => n === r : Ey),
      !!e.static,
      e.enables
    );
  }
  of(e) {
    return new ef([], this, 0, e);
  }
  compute(e, n) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new ef(e, this, 1, n);
  }
  computeN(e, n) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new ef(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));
  }
}
function Ey(t, e) {
  return t == e || (t.length == e.length && t.every((n, r) => n === e[r]));
}
class ef {
  constructor(e, n, r, i) {
    (this.dependencies = e), (this.facet = n), (this.type = r), (this.value = i), (this.id = _y++);
  }
  dynamicSlot(e) {
    var n;
    let r = this.value,
      i = this.facet.compareInput,
      o = this.id,
      s = e[o] >> 1,
      l = this.type == 2,
      a = !1,
      c = !1,
      u = [];
    for (let h of this.dependencies)
      h == "doc" ? (a = !0) : h == "selection" ? (c = !0) : ((n = e[h.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[h.id]);
    return {
      create(h) {
        return (h.values[s] = r(h)), 1;
      },
      update(h, d) {
        if ((a && d.docChanged) || (c && (d.docChanged || d.selection)) || yO(h, u)) {
          let f = r(h);
          if (l ? !P2(f, h.values[s], i) : !i(f, h.values[s])) return (h.values[s] = f), 1;
        }
        return 0;
      },
      reconfigure: (h, d) => {
        let f,
          p = d.config.address[o];
        if (p != null) {
          let m = lp(d, p);
          if (
            this.dependencies.every((O) =>
              O instanceof xe ? d.facet(O) === h.facet(O) : O instanceof Qt ? d.field(O, !1) == h.field(O, !1) : !0
            ) ||
            (l ? P2((f = r(h)), m, i) : i((f = r(h)), m))
          )
            return (h.values[s] = m), 0;
        } else f = r(h);
        return (h.values[s] = f), 1;
      },
    };
  }
}
function P2(t, e, n) {
  if (t.length != e.length) return !1;
  for (let r = 0; r < t.length; r++) if (!n(t[r], e[r])) return !1;
  return !0;
}
function yO(t, e) {
  let n = !1;
  for (let r of e) Vc(t, r) & 1 && (n = !0);
  return n;
}
function nee(t, e, n) {
  let r = n.map((a) => t[a.id]),
    i = n.map((a) => a.type),
    o = r.filter((a) => !(a & 1)),
    s = t[e.id] >> 1;
  function l(a) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = lp(a, r[u]);
      if (i[u] == 2) for (let d of h) c.push(d);
      else c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of r) Vc(a, c);
      return (a.values[s] = l(a)), 1;
    },
    update(a, c) {
      if (!yO(a, o)) return 0;
      let u = l(a);
      return e.compare(u, a.values[s]) ? 0 : ((a.values[s] = u), 1);
    },
    reconfigure(a, c) {
      let u = yO(a, r),
        h = c.config.facets[e.id],
        d = c.facet(e);
      if (h && !u && Ey(n, h)) return (a.values[s] = d), 0;
      let f = l(a);
      return e.compare(f, d) ? ((a.values[s] = d), 0) : ((a.values[s] = f), 1);
    },
  };
}
const A2 = xe.define({ static: !0 });
class Qt {
  constructor(e, n, r, i, o) {
    (this.id = e), (this.createF = n), (this.updateF = r), (this.compareF = i), (this.spec = o), (this.provides = void 0);
  }
  static define(e) {
    let n = new Qt(_y++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(A2).find((r) => r.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (r) => ((r.values[n] = this.create(r)), 1),
      update: (r, i) => {
        let o = r.values[n],
          s = this.updateF(o, i);
        return this.compareF(o, s) ? 0 : ((r.values[n] = s), 1);
      },
      reconfigure: (r, i) => (i.config.address[this.id] != null ? ((r.values[n] = i.field(this)), 0) : ((r.values[n] = this.create(r)), 1)),
    };
  }
  init(e) {
    return [this, A2.of({ field: this, create: e })];
  }
  get extension() {
    return this;
  }
}
const fs = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ic(t) {
  return (e) => new A9(e, t);
}
const zr = { highest: ic(fs.highest), high: ic(fs.high), default: ic(fs.default), low: ic(fs.low), lowest: ic(fs.lowest) };
class A9 {
  constructor(e, n) {
    (this.inner = e), (this.prec = n);
  }
}
class Qa {
  of(e) {
    return new wO(this, e);
  }
  reconfigure(e) {
    return Qa.reconfigure.of({ compartment: this, extension: e });
  }
  get(e) {
    return e.config.compartments.get(this);
  }
}
class wO {
  constructor(e, n) {
    (this.compartment = e), (this.inner = n);
  }
}
class sp {
  constructor(e, n, r, i, o, s) {
    for (
      this.base = e,
        this.compartments = n,
        this.dynamicSlots = r,
        this.address = i,
        this.staticValues = o,
        this.facets = s,
        this.statusTemplate = [];
      this.statusTemplate.length < r.length;

    )
      this.statusTemplate.push(0);
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, r) {
    let i = [],
      o = Object.create(null),
      s = new Map();
    for (let d of ree(e, n, s)) d instanceof Qt ? i.push(d) : (o[d.facet.id] || (o[d.facet.id] = [])).push(d);
    let l = Object.create(null),
      a = [],
      c = [];
    for (let d of i) (l[d.id] = c.length << 1), c.push((f) => d.slot(f));
    let u = r == null ? void 0 : r.config.facets;
    for (let d in o) {
      let f = o[d],
        p = f[0].facet,
        m = (u && u[d]) || [];
      if (f.every((O) => O.type == 0))
        if (((l[p.id] = (a.length << 1) | 1), Ey(m, f))) a.push(r.facet(p));
        else {
          let O = p.combine(f.map((v) => v.value));
          a.push(r && p.compare(O, r.facet(p)) ? r.facet(p) : O);
        }
      else {
        for (let O of f)
          O.type == 0 ? ((l[O.id] = (a.length << 1) | 1), a.push(O.value)) : ((l[O.id] = c.length << 1), c.push((v) => O.dynamicSlot(v)));
        (l[p.id] = c.length << 1), c.push((O) => nee(O, p, f));
      }
    }
    let h = c.map((d) => d(l));
    return new sp(e, s, h, l, a, o);
  }
}
function ree(t, e, n) {
  let r = [[], [], [], [], []],
    i = new Map();
  function o(s, l) {
    let a = i.get(s);
    if (a != null) {
      if (a <= l) return;
      let c = r[a].indexOf(s);
      c > -1 && r[a].splice(c, 1), s instanceof wO && n.delete(s.compartment);
    }
    if ((i.set(s, l), Array.isArray(s))) for (let c of s) o(c, l);
    else if (s instanceof wO) {
      if (n.has(s.compartment)) throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(s.compartment) || s.inner;
      n.set(s.compartment, c), o(c, l);
    } else if (s instanceof A9) o(s.inner, s.prec);
    else if (s instanceof Qt) r[l].push(s), s.provides && o(s.provides, l);
    else if (s instanceof ef) r[l].push(s), s.facet.extensions && o(s.facet.extensions, fs.default);
    else {
      let c = s.extension;
      if (!c)
        throw new Error(
          `Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`
        );
      o(c, l);
    }
  }
  return o(t, fs.default), r.reduce((s, l) => s.concat(l));
}
function Vc(t, e) {
  if (e & 1) return 2;
  let n = e >> 1,
    r = t.status[n];
  if (r == 4) throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2) return r;
  t.status[n] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[n]);
  return (t.status[n] = 2 | i);
}
function lp(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const $9 = xe.define(),
  SO = xe.define({ combine: (t) => t.some((e) => e), static: !0 }),
  R9 = xe.define({ combine: (t) => (t.length ? t[0] : void 0), static: !0 }),
  I9 = xe.define(),
  M9 = xe.define(),
  L9 = xe.define(),
  N9 = xe.define({ combine: (t) => (t.length ? t[0] : !1) });
class Lr {
  constructor(e, n) {
    (this.type = e), (this.value = n);
  }
  static define() {
    return new iee();
  }
}
class iee {
  of(e) {
    return new Lr(this, e);
  }
}
class oee {
  constructor(e) {
    this.map = e;
  }
  of(e) {
    return new Ee(this, e);
  }
}
class Ee {
  constructor(e, n) {
    (this.type = e), (this.value = n);
  }
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new Ee(this.type, n);
  }
  is(e) {
    return this.type == e;
  }
  static define(e = {}) {
    return new oee(e.map || ((n) => n));
  }
  static mapEffects(e, n) {
    if (!e.length) return e;
    let r = [];
    for (let i of e) {
      let o = i.map(n);
      o && r.push(o);
    }
    return r;
  }
}
Ee.reconfigure = Ee.define();
Ee.appendConfig = Ee.define();
class zt {
  constructor(e, n, r, i, o, s) {
    (this.startState = e),
      (this.changes = n),
      (this.selection = r),
      (this.effects = i),
      (this.annotations = o),
      (this.scrollIntoView = s),
      (this._doc = null),
      (this._state = null),
      r && P9(r, n.newLength),
      o.some((l) => l.type == zt.time) || (this.annotations = o.concat(zt.time.of(Date.now())));
  }
  static create(e, n, r, i, o, s) {
    return new zt(e, n, r, i, o, s);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(e) {
    for (let n of this.annotations) if (n.type == e) return n.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(e) {
    let n = this.annotation(zt.userEvent);
    return !!(n && (n == e || (n.length > e.length && n.slice(0, e.length) == e && n[e.length] == ".")));
  }
}
zt.time = Lr.define();
zt.userEvent = Lr.define();
zt.addToHistory = Lr.define();
zt.remote = Lr.define();
function see(t, e) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let o, s;
    if (r < t.length && (i == e.length || e[i] >= t[r])) (o = t[r++]), (s = t[r++]);
    else if (i < e.length) (o = e[i++]), (s = e[i++]);
    else return n;
    !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
  }
}
function Q9(t, e, n) {
  var r;
  let i, o, s;
  return (
    n
      ? ((i = e.changes), (o = jt.empty(e.changes.length)), (s = t.changes.compose(e.changes)))
      : ((i = e.changes.map(t.changes)), (o = t.changes.mapDesc(e.changes, !0)), (s = t.changes.compose(i))),
    {
      changes: s,
      selection: e.selection ? e.selection.map(o) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
      effects: Ee.mapEffects(t.effects, i).concat(Ee.mapEffects(e.effects, o)),
      annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
      scrollIntoView: t.scrollIntoView || e.scrollIntoView,
    }
  );
}
function kO(t, e, n) {
  let r = e.selection,
    i = Nl(e.annotations);
  return (
    e.userEvent && (i = i.concat(zt.userEvent.of(e.userEvent))),
    {
      changes: e.changes instanceof jt ? e.changes : jt.of(e.changes || [], n, t.facet(R9)),
      selection: r && (r instanceof H ? r : H.single(r.anchor, r.head)),
      effects: Nl(e.effects),
      annotations: i,
      scrollIntoView: !!e.scrollIntoView,
    }
  );
}
function D9(t, e, n) {
  let r = kO(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (n = !1);
    let s = !!e[o].sequential;
    r = Q9(r, kO(t, e[o], s ? r.changes.newLength : t.doc.length), s);
  }
  let i = zt.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return aee(n ? lee(i) : i);
}
function lee(t) {
  let e = t.startState,
    n = !0;
  for (let i of e.facet(I9)) {
    let o = i(t);
    if (o === !1) {
      n = !1;
      break;
    }
    Array.isArray(o) && (n = n === !0 ? o : see(n, o));
  }
  if (n !== !0) {
    let i, o;
    if (n === !1) (o = t.changes.invertedDesc), (i = jt.empty(e.doc.length));
    else {
      let s = t.changes.filter(n);
      (i = s.changes), (o = s.filtered.mapDesc(s.changes).invertedDesc);
    }
    t = zt.create(e, i, t.selection && t.selection.map(o), Ee.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
  }
  let r = e.facet(M9);
  for (let i = r.length - 1; i >= 0; i--) {
    let o = r[i](t);
    o instanceof zt ? (t = o) : Array.isArray(o) && o.length == 1 && o[0] instanceof zt ? (t = o[0]) : (t = D9(e, Nl(o), !1));
  }
  return t;
}
function aee(t) {
  let e = t.startState,
    n = e.facet(L9),
    r = t;
  for (let i = n.length - 1; i >= 0; i--) {
    let o = n[i](t);
    o && Object.keys(o).length && (r = Q9(r, kO(e, o, t.changes.newLength), !0));
  }
  return r == t ? t : zt.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
}
const cee = [];
function Nl(t) {
  return t == null ? cee : Array.isArray(t) ? t : [t];
}
var Et = (function (t) {
  return (t[(t.Word = 0)] = "Word"), (t[(t.Space = 1)] = "Space"), (t[(t.Other = 2)] = "Other"), t;
})(Et || (Et = {}));
const uee = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let CO;
try {
  CO = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {}
function hee(t) {
  if (CO) return CO.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || (n > "" && (n.toUpperCase() != n.toLowerCase() || uee.test(n)))) return !0;
  }
  return !1;
}
function dee(t) {
  return (e) => {
    if (!/\S/.test(e)) return Et.Space;
    if (hee(e)) return Et.Word;
    for (let n = 0; n < t.length; n++) if (e.indexOf(t[n]) > -1) return Et.Word;
    return Et.Other;
  };
}
class Me {
  constructor(e, n, r, i, o, s) {
    (this.config = e),
      (this.doc = n),
      (this.selection = r),
      (this.values = i),
      (this.status = e.statusTemplate.slice()),
      (this.computeSlot = o),
      s && (s._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++) Vc(this, l << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (n) throw new RangeError("Field is not present in this state");
      return;
    }
    return Vc(this, r), lp(this, r);
  }
  update(...e) {
    return D9(this, e, !0);
  }
  applyTransaction(e) {
    let n = this.config,
      { base: r, compartments: i } = n;
    for (let l of e.effects)
      l.is(Qa.reconfigure)
        ? (n && ((i = new Map()), n.compartments.forEach((a, c) => i.set(c, a)), (n = null)), i.set(l.value.compartment, l.value.extension))
        : l.is(Ee.reconfigure)
        ? ((n = null), (r = l.value))
        : l.is(Ee.appendConfig) && ((n = null), (r = Nl(r).concat(l.value)));
    let o;
    n
      ? (o = e.startState.values.slice())
      : ((n = sp.resolve(r, i, this)),
        (o = new Me(
          n,
          this.doc,
          this.selection,
          n.dynamicSlots.map(() => null),
          (a, c) => c.reconfigure(a, this),
          null
        ).values));
    let s = e.startState.facet(SO) ? e.newSelection : e.newSelection.asSingle();
    new Me(n, e.newDoc, s, o, (l, a) => a.update(l, e), e);
  }
  replaceSelection(e) {
    return (
      typeof e == "string" && (e = this.toText(e)),
      this.changeByRange((n) => ({ changes: { from: n.from, to: n.to, insert: e }, range: H.cursor(n.from + e.length) }))
    );
  }
  changeByRange(e) {
    let n = this.selection,
      r = e(n.ranges[0]),
      i = this.changes(r.changes),
      o = [r.range],
      s = Nl(r.effects);
    for (let l = 1; l < n.ranges.length; l++) {
      let a = e(n.ranges[l]),
        c = this.changes(a.changes),
        u = c.map(i);
      for (let d = 0; d < l; d++) o[d] = o[d].map(u);
      let h = i.mapDesc(c, !0);
      o.push(a.range.map(h)), (i = i.compose(u)), (s = Ee.mapEffects(s, u).concat(Ee.mapEffects(Nl(a.effects), h)));
    }
    return { changes: i, selection: H.create(o, n.mainIndex), effects: s };
  }
  changes(e = []) {
    return e instanceof jt ? e : jt.of(e, this.doc.length, this.facet(Me.lineSeparator));
  }
  toText(e) {
    return et.of(e.split(this.facet(Me.lineSeparator) || vO));
  }
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (Vc(this, n), lp(this, n));
  }
  toJSON(e) {
    let n = { doc: this.sliceDoc(), selection: this.selection.toJSON() };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof Qt && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return n;
  }
  static fromJSON(e, n = {}, r) {
    if (!e || typeof e.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let o in r)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let s = r[o],
            l = e[o];
          i.push(s.init((a) => s.spec.fromJSON(l, a)));
        }
    }
    return Me.create({ doc: e.doc, selection: H.fromJSON(e.selection), extensions: n.extensions ? i.concat([n.extensions]) : i });
  }
  static create(e = {}) {
    let n = sp.resolve(e.extensions || [], new Map()),
      r = e.doc instanceof et ? e.doc : et.of((e.doc || "").split(n.staticFacet(Me.lineSeparator) || vO)),
      i = e.selection ? (e.selection instanceof H ? e.selection : H.single(e.selection.anchor, e.selection.head)) : H.single(0);
    return (
      P9(i, r.length),
      n.staticFacet(SO) || (i = i.asSingle()),
      new Me(
        n,
        r,
        i,
        n.dynamicSlots.map(() => null),
        (o, s) => s.create(o),
        null
      )
    );
  }
  get tabSize() {
    return this.facet(Me.tabSize);
  }
  get lineBreak() {
    return (
      this.facet(Me.lineSeparator) ||
      `
`
    );
  }
  get readOnly() {
    return this.facet(N9);
  }
  phrase(e, ...n) {
    for (let r of this.facet(Me.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return (
      n.length &&
        (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
          if (i == "$") return "$";
          let o = +(i || 1);
          return !o || o > n.length ? r : n[o - 1];
        })),
      e
    );
  }
  languageDataAt(e, n, r = -1) {
    let i = [];
    for (let o of this.facet($9)) for (let s of o(this, n, r)) Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
    return i;
  }
  charCategorizer(e) {
    return dee(this.languageDataAt("wordChars", e).join(""));
  }
  wordAt(e) {
    let { text: n, from: r, length: i } = this.doc.lineAt(e),
      o = this.charCategorizer(e),
      s = e - r,
      l = e - r;
    for (; s > 0; ) {
      let a = dn(n, s, !1);
      if (o(n.slice(a, s)) != Et.Word) break;
      s = a;
    }
    for (; l < i; ) {
      let a = dn(n, l);
      if (o(n.slice(l, a)) != Et.Word) break;
      l = a;
    }
    return s == l ? null : H.range(s + r, l + r);
  }
}
Me.allowMultipleSelections = SO;
Me.tabSize = xe.define({ combine: (t) => (t.length ? t[0] : 4) });
Me.lineSeparator = R9;
Me.readOnly = N9;
Me.phrases = xe.define({
  compare(t, e) {
    let n = Object.keys(t),
      r = Object.keys(e);
    return n.length == r.length && n.every((i) => t[i] == e[i]);
  },
});
Me.languageData = $9;
Me.changeFilter = I9;
Me.transactionFilter = M9;
Me.transactionExtender = L9;
Qa.reconfigure = Ee.define();
function Si(t, e, n = {}) {
  let r = {};
  for (let i of t)
    for (let o of Object.keys(i)) {
      let s = i[o],
        l = r[o];
      if (l === void 0) r[o] = s;
      else if (!(l === s || s === void 0))
        if (Object.hasOwnProperty.call(n, o)) r[o] = n[o](l, s);
        else throw new Error("Config merge conflict for field " + o);
    }
  for (let i in e) r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class Is {
  eq(e) {
    return this == e;
  }
  range(e, n = e) {
    return _O.create(e, n, this);
  }
}
Is.prototype.startSide = Is.prototype.endSide = 0;
Is.prototype.point = !1;
Is.prototype.mapMode = un.TrackDel;
let _O = class F9 {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.value = r);
  }
  static create(e, n, r) {
    return new F9(e, n, r);
  }
};
function EO(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
let fee = class B9 {
  constructor(e, n, r, i) {
    (this.from = e), (this.to = n), (this.value = r), (this.maxPoint = i);
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(e, n, r, i = 0) {
    let o = r ? this.to : this.from;
    for (let s = i, l = o.length; ; ) {
      if (s == l) return s;
      let a = (s + l) >> 1,
        c = o[a] - e || (r ? this.value[a].endSide : this.value[a].startSide) - n;
      if (a == s) return c >= 0 ? s : l;
      c >= 0 ? (l = a) : (s = a + 1);
    }
  }
  between(e, n, r, i) {
    for (let o = this.findIndex(n, -1e9, !0), s = this.findIndex(r, 1e9, !1, o); o < s; o++)
      if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === !1) return !1;
  }
  map(e, n) {
    let r = [],
      i = [],
      o = [],
      s = -1,
      l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a],
        u = this.from[a] + e,
        h = this.to[a] + e,
        d,
        f;
      if (u == h) {
        let p = n.mapPos(u, c.startSide, c.mapMode);
        if (p == null || ((d = f = p), c.startSide != c.endSide && ((f = n.mapPos(u, c.endSide)), f < d))) continue;
      } else if (((d = n.mapPos(u, c.startSide)), (f = n.mapPos(h, c.endSide)), d > f || (d == f && c.startSide > 0 && c.endSide <= 0)))
        continue;
      (f - d || c.endSide - c.startSide) < 0 ||
        (s < 0 && (s = d), c.point && (l = Math.max(l, f - d)), r.push(c), i.push(d - s), o.push(f - s));
    }
    return { mapped: r.length ? new B9(i, o, r, l) : null, pos: s };
  }
};
class ze {
  constructor(e, n, r, i) {
    (this.chunkPos = e), (this.chunk = n), (this.nextLayer = r), (this.maxPoint = i);
  }
  static create(e, n, r, i) {
    return new ze(e, n, r, i);
  }
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty) return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk) e += n.value.length;
    return e;
  }
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  update(e) {
    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: o = this.length } = e,
      s = e.filter;
    if (n.length == 0 && !s) return this;
    if ((r && (n = n.slice().sort(EO)), this.isEmpty)) return n.length ? ze.of(n) : this;
    let l = new V9(this, null, -1).goto(0),
      a = 0,
      c = [],
      u = new lr();
    for (; l.value || a < n.length; )
      if (a < n.length && (l.from - n[a].from || l.startSide - n[a].value.startSide) >= 0) {
        let h = n[a++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else
        l.rangeIndex == 1 &&
        l.chunkIndex < this.chunk.length &&
        (a == n.length || this.chunkEnd(l.chunkIndex) < n[a].from) &&
        (!s || i > this.chunkEnd(l.chunkIndex) || o < this.chunkPos[l.chunkIndex]) &&
        u.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex])
          ? l.nextChunk()
          : ((!s || i > l.to || o < l.from || s(l.from, l.to, l.value)) &&
              (u.addInner(l.from, l.to, l.value) || c.push(_O.create(l.from, l.to, l.value))),
            l.next());
    return u.finishInner(
      this.nextLayer.isEmpty && !c.length ? ze.empty : this.nextLayer.update({ add: c, filter: s, filterFrom: i, filterTo: o })
    );
  }
  map(e) {
    if (e.empty || this.isEmpty) return this;
    let n = [],
      r = [],
      i = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let l = this.chunkPos[s],
        a = this.chunk[s],
        c = e.touchesRange(l, l + a.length);
      if (c === !1) (i = Math.max(i, a.maxPoint)), n.push(a), r.push(e.mapPos(l));
      else if (c === !0) {
        let { mapped: u, pos: h } = a.map(l, e);
        u && ((i = Math.max(i, u.maxPoint)), n.push(u), r.push(h));
      }
    }
    let o = this.nextLayer.map(e);
    return n.length == 0 ? o : new ze(r, n, o || ze.empty, i);
  }
  between(e, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i],
          s = this.chunk[i];
        if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, r) === !1) return;
      }
      this.nextLayer.between(e, n, r);
    }
  }
  iter(e = 0) {
    return Ou.from([this]).goto(e);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(e, n = 0) {
    return Ou.from(e).goto(n);
  }
  static compare(e, n, r, i, o = -1) {
    let s = e.filter((h) => h.maxPoint > 0 || (!h.isEmpty && h.maxPoint >= o)),
      l = n.filter((h) => h.maxPoint > 0 || (!h.isEmpty && h.maxPoint >= o)),
      a = $2(s, l, r),
      c = new oc(s, a, o),
      u = new oc(l, a, o);
    r.iterGaps((h, d, f) => R2(c, h, u, d, f, i)), r.empty && r.length == 0 && R2(c, 0, u, 0, 0, i);
  }
  static eq(e, n, r = 0, i) {
    i == null && (i = 1e9 - 1);
    let o = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0),
      s = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (o.length != s.length) return !1;
    if (!o.length) return !0;
    let l = $2(o, s),
      a = new oc(o, l, 0).goto(r),
      c = new oc(s, l, 0).goto(r);
    for (;;) {
      if (a.to != c.to || !TO(a.active, c.active) || (a.point && (!c.point || !a.point.eq(c.point)))) return !1;
      if (a.to > i) return !0;
      a.next(), c.next();
    }
  }
  static spans(e, n, r, i, o = -1) {
    let s = new oc(e, null, o).goto(n),
      l = n,
      a = s.openStart;
    for (;;) {
      let c = Math.min(s.to, r);
      if (s.point) {
        let u = s.activeForPoint(s.to),
          h = s.pointFrom < n ? u.length + 1 : s.point.startSide < 0 ? u.length : Math.min(u.length, a);
        i.point(l, c, s.point, u, h, s.pointRank), (a = Math.min(s.openEnd(c), u.length));
      } else c > l && (i.span(l, c, s.active, a), (a = s.openEnd(c)));
      if (s.to > r) return a + (s.point && s.to > r ? 1 : 0);
      (l = s.to), s.next();
    }
  }
  static of(e, n = !1) {
    let r = new lr();
    for (let i of e instanceof _O ? [e] : n ? pee(e) : e) r.add(i.from, i.to, i.value);
    return r.finish();
  }
  static join(e) {
    if (!e.length) return ze.empty;
    let n = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != ze.empty; i = i.nextLayer) n = new ze(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
    return n;
  }
}
ze.empty = new ze([], [], null, -1);
function pee(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let r = t[n];
      if (EO(e, r) > 0) return t.slice().sort(EO);
      e = r;
    }
  return t;
}
ze.empty.nextLayer = ze.empty;
class lr {
  finishChunk(e) {
    this.chunks.push(new fee(this.from, this.to, this.value, this.maxPoint)),
      this.chunkPos.push(this.chunkStart),
      (this.chunkStart = -1),
      (this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)),
      (this.maxPoint = -1),
      e && ((this.from = []), (this.to = []), (this.value = []));
  }
  constructor() {
    (this.chunks = []),
      (this.chunkPos = []),
      (this.chunkStart = -1),
      (this.last = null),
      (this.lastFrom = -1e9),
      (this.lastTo = -1e9),
      (this.from = []),
      (this.to = []),
      (this.value = []),
      (this.maxPoint = -1),
      (this.setMaxPoint = -1),
      (this.nextLayer = null);
  }
  add(e, n, r) {
    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new lr())).add(e, n, r);
  }
  addInner(e, n, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0
      ? !1
      : (this.from.length == 250 && this.finishChunk(!0),
        this.chunkStart < 0 && (this.chunkStart = e),
        this.from.push(e - this.chunkStart),
        this.to.push(n - this.chunkStart),
        (this.last = r),
        (this.lastFrom = e),
        (this.lastTo = n),
        this.value.push(r),
        r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)),
        !0);
  }
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0) return !1;
    this.from.length && this.finishChunk(!0),
      (this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint)),
      this.chunks.push(n),
      this.chunkPos.push(e);
    let r = n.value.length - 1;
    return (this.last = n.value[r]), (this.lastFrom = n.from[r] + e), (this.lastTo = n.to[r] + e), !0;
  }
  finish() {
    return this.finishInner(ze.empty);
  }
  finishInner(e) {
    if ((this.from.length && this.finishChunk(!1), this.chunks.length == 0)) return e;
    let n = ze.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return (this.from = null), n;
  }
}
function $2(t, e, n) {
  let r = new Map();
  for (let o of t) for (let s = 0; s < o.chunk.length; s++) o.chunk[s].maxPoint <= 0 && r.set(o.chunk[s], o.chunkPos[s]);
  let i = new Set();
  for (let o of e)
    for (let s = 0; s < o.chunk.length; s++) {
      let l = r.get(o.chunk[s]);
      l != null && (n ? n.mapPos(l) : l) == o.chunkPos[s] && !(n != null && n.touchesRange(l, l + o.chunk[s].length)) && i.add(o.chunk[s]);
    }
  return i;
}
class V9 {
  constructor(e, n, r, i = 0) {
    (this.layer = e), (this.skip = n), (this.minPoint = r), (this.rank = i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return (this.chunkIndex = this.rangeIndex = 0), this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!((this.skip && this.skip.has(i)) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint)) break;
      this.chunkIndex++, (r = !1);
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (;;)
      if (this.chunkIndex == this.layer.chunk.length) {
        (this.from = this.to = 1e9), (this.value = null);
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex],
          n = this.layer.chunk[this.chunkIndex],
          r = e + n.from[this.rangeIndex];
        if (
          ((this.from = r),
          (this.to = e + n.to[this.rangeIndex]),
          (this.value = n.value[this.rangeIndex]),
          this.setRangeIndex(this.rangeIndex + 1),
          this.minPoint < 0 || (this.value.point && this.to - this.from >= this.minPoint))
        )
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if ((this.chunkIndex++, this.skip))
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); ) this.chunkIndex++;
      this.rangeIndex = 0;
    } else this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, (this.rangeIndex = 0), this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Ou {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, r = -1) {
    let i = [];
    for (let o = 0; o < e.length; o++) for (let s = e[o]; !s.isEmpty; s = s.nextLayer) s.maxPoint >= r && i.push(new V9(s, n, r, o));
    return i.length == 1 ? i[0] : new Ou(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let r of this.heap) r.goto(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--) i1(this.heap, r);
    return this.next(), this;
  }
  forward(e, n) {
    for (let r of this.heap) r.forward(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--) i1(this.heap, r);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0) (this.from = this.to = 1e9), (this.value = null), (this.rank = -1);
    else {
      let e = this.heap[0];
      (this.from = e.from), (this.to = e.to), (this.value = e.value), (this.rank = e.rank), e.value && e.next(), i1(this.heap, 0);
    }
  }
}
function i1(t, e) {
  for (let n = t[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= t.length) break;
    let i = t[r];
    if ((r + 1 < t.length && i.compare(t[r + 1]) >= 0 && ((i = t[r + 1]), r++), n.compare(i) < 0)) break;
    (t[r] = n), (t[e] = i), (e = r);
  }
}
class oc {
  constructor(e, n, r) {
    (this.minPoint = r),
      (this.active = []),
      (this.activeTo = []),
      (this.activeRank = []),
      (this.minActive = -1),
      (this.point = null),
      (this.pointFrom = 0),
      (this.pointRank = 0),
      (this.to = -1e9),
      (this.endSide = 0),
      (this.openStart = -1),
      (this.cursor = Ou.from(e, n, r));
  }
  goto(e, n = -1e9) {
    return (
      this.cursor.goto(e, n),
      (this.active.length = this.activeTo.length = this.activeRank.length = 0),
      (this.minActive = -1),
      (this.to = e),
      (this.endSide = n),
      (this.openStart = -1),
      this.next(),
      this
    );
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    sd(this.active, e), sd(this.activeTo, e), sd(this.activeRank, e), (this.minActive = I2(this.active, this.activeTo));
  }
  addActive(e) {
    let n = 0,
      { value: r, to: i, rank: o } = this.cursor;
    for (; n < this.activeRank.length && (o - this.activeRank[n] || i - this.activeTo[n]) > 0; ) n++;
    ld(this.active, n, r),
      ld(this.activeTo, n, i),
      ld(this.activeRank, n, o),
      e && ld(e, n, this.cursor.from),
      (this.minActive = I2(this.active, this.activeTo));
  }
  next() {
    let e = this.to,
      n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (;;) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          (this.to = this.activeTo[i]), (this.endSide = this.active[i].endSide);
          break;
        }
        this.removeActive(i), r && sd(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          (this.to = this.cursor.from), (this.endSide = this.cursor.startSide);
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point) this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to) this.cursor.next();
          else {
            (this.point = o),
              (this.pointFrom = this.cursor.from),
              (this.pointRank = this.cursor.rank),
              (this.to = this.cursor.to),
              (this.endSide = o.endSide),
              this.cursor.next(),
              this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--) this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length) return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || (this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide)) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--) n++;
    return n;
  }
}
function R2(t, e, n, r, i, o) {
  t.goto(e), n.goto(r);
  let s = r + i,
    l = r,
    a = r - e;
  for (;;) {
    let c = t.to + a - n.to || t.endSide - n.endSide,
      u = c < 0 ? t.to + a : n.to,
      h = Math.min(u, s);
    if (
      (t.point || n.point
        ? (t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && TO(t.activeForPoint(t.to), n.activeForPoint(n.to))) ||
          o.comparePoint(l, h, t.point, n.point)
        : h > l && !TO(t.active, n.active) && o.compareRange(l, h, t.active, n.active),
      u > s)
    )
      break;
    (l = u), c <= 0 && t.next(), c >= 0 && n.next();
  }
}
function TO(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) if (t[n] != e[n] && !t[n].eq(e[n])) return !1;
  return !0;
}
function sd(t, e) {
  for (let n = e, r = t.length - 1; n < r; n++) t[n] = t[n + 1];
  t.pop();
}
function ld(t, e, n) {
  for (let r = t.length - 1; r >= e; r--) t[r + 1] = t[r];
  t[e] = n;
}
function I2(t, e) {
  let n = -1,
    r = 1e9;
  for (let i = 0; i < e.length; i++) (e[i] - r || t[i].endSide - t[n].endSide) < 0 && ((n = i), (r = e[i]));
  return n;
}
function Nr(t, e, n = t.length) {
  let r = 0;
  for (let i = 0; i < n; ) t.charCodeAt(i) == 9 ? ((r += e - (r % e)), i++) : (r++, (i = dn(t, i)));
  return r;
}
function PO(t, e, n, r) {
  for (let i = 0, o = 0; ; ) {
    if (o >= e) return i;
    if (i == t.length) break;
    (o += t.charCodeAt(i) == 9 ? n - (o % n) : 1), (i = dn(t, i));
  }
  return r === !0 ? -1 : t.length;
}
const AO = "ͼ",
  M2 = typeof Symbol > "u" ? "__" + AO : Symbol.for(AO),
  $O = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"),
  L2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class qi {
  constructor(e, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function o(s, l, a, c) {
      let u = [],
        h = /^@(\w+)\b/.exec(s[0]),
        d = h && h[1] == "keyframes";
      if (h && l == null) return a.push(s[0] + ";");
      for (let f in l) {
        let p = l[f];
        if (/&/.test(f))
          o(
            f
              .split(/,\s*/)
              .map((m) => s.map((O) => m.replace(/&/, O)))
              .reduce((m, O) => m.concat(O)),
            p,
            a
          );
        else if (p && typeof p == "object") {
          if (!h) throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          o(i(f), p, u, d);
        } else p != null && u.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || d) && a.push((r && !h && !c ? s.map(r) : s).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let s in e) o(i(s), e[s], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let e = L2[M2] || 1;
    return (L2[M2] = e + 1), AO + e.toString(36);
  }
  static mount(e, n, r) {
    let i = e[$O],
      o = r && r.nonce;
    i ? o && i.setNonce(o) : (i = new mee(e, o)), i.mount(Array.isArray(n) ? n : [n], e);
  }
}
let N2 = new Map();
class mee {
  constructor(e, n) {
    let r = e.ownerDocument || e,
      i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = N2.get(r);
      if (o) return (e[$O] = o);
      (this.sheet = new i.CSSStyleSheet()), N2.set(r, this);
    } else (this.styleTag = r.createElement("style")), n && this.styleTag.setAttribute("nonce", n);
    (this.modules = []), (e[$O] = this);
  }
  mount(e, n) {
    let r = this.sheet,
      i = 0,
      o = 0;
    for (let s = 0; s < e.length; s++) {
      let l = e[s],
        a = this.modules.indexOf(l);
      if ((a < o && a > -1 && (this.modules.splice(a, 1), o--, (a = -1)), a == -1)) {
        if ((this.modules.splice(o++, 0, l), r)) for (let c = 0; c < l.rules.length; c++) r.insertRule(l.rules[c], i++);
      } else {
        for (; o < a; ) i += this.modules[o++].rules.length;
        (i += l.rules.length), o++;
      }
    }
    if (r) n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let s = "";
      for (let a = 0; a < this.modules.length; a++)
        s +=
          this.modules[a].getRules() +
          `
`;
      this.styleTag.textContent = s;
      let l = n.head || n;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Vo = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
  },
  vu = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
  },
  gee = typeof navigator < "u" && /Mac/.test(navigator.platform),
  Oee = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var cn = 0; cn < 10; cn++) Vo[48 + cn] = Vo[96 + cn] = String(cn);
for (var cn = 1; cn <= 24; cn++) Vo[cn + 111] = "F" + cn;
for (var cn = 65; cn <= 90; cn++) (Vo[cn] = String.fromCharCode(cn + 32)), (vu[cn] = String.fromCharCode(cn));
for (var o1 in Vo) vu.hasOwnProperty(o1) || (vu[o1] = Vo[o1]);
function vee(t) {
  var e =
      (gee && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
      (Oee && t.shiftKey && t.key && t.key.length == 1) ||
      t.key == "Unidentified",
    n = (!e && t.key) || (t.shiftKey ? vu : Vo)[t.keyCode] || t.key || "Unidentified";
  return (
    n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
  );
}
function bu(t) {
  let e;
  return t.nodeType == 11 ? (e = t.getSelection ? t : t.ownerDocument) : (e = t), e.getSelection();
}
function RO(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function bee(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
  return e;
}
function tf(t, e) {
  if (!e.anchorNode) return !1;
  try {
    return RO(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function xu(t) {
  return t.nodeType == 3 ? Ls(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function jc(t, e, n, r) {
  return n ? Q2(t, e, n, r, -1) || Q2(t, e, n, r, 1) : !1;
}
function Ms(t) {
  for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
}
function ap(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function Q2(t, e, n, r, i) {
  for (;;) {
    if (t == n && e == r) return !0;
    if (e == (i < 0 ? 0 : Yi(t))) {
      if (t.nodeName == "DIV") return !1;
      let o = t.parentNode;
      if (!o || o.nodeType != 1) return !1;
      (e = Ms(t) + (i < 0 ? 0 : 1)), (t = o);
    } else if (t.nodeType == 1) {
      if (((t = t.childNodes[e + (i < 0 ? -1 : 0)]), t.nodeType == 1 && t.contentEditable == "false")) return !1;
      e = i < 0 ? Yi(t) : 0;
    } else return !1;
  }
}
function Yi(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Ty(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function xee(t) {
  let e = t.visualViewport;
  return e ? { left: 0, right: e.width, top: 0, bottom: e.height } : { left: 0, right: t.innerWidth, top: 0, bottom: t.innerHeight };
}
function j9(t, e) {
  let n = e.width / t.offsetWidth,
    r = e.height / t.offsetHeight;
  return (
    ((n > 0.995 && n < 1.005) || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1),
    ((r > 0.995 && r < 1.005) || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1),
    { scaleX: n, scaleY: r }
  );
}
function yee(t, e, n, r, i, o, s, l) {
  let a = t.ownerDocument,
    c = a.defaultView || window;
  for (let u = t, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let d,
        f = u == a.body,
        p = 1,
        m = 1;
      if (f) d = xee(c);
      else {
        if (
          (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0),
          u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth)
        ) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let g = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = j9(u, g)),
          (d = { left: g.left, right: g.left + u.clientWidth * p, top: g.top, bottom: g.top + u.clientHeight * m });
      }
      let O = 0,
        v = 0;
      if (i == "nearest")
        e.top < d.top
          ? ((v = -(d.top - e.top + s)), n > 0 && e.bottom > d.bottom + v && (v = e.bottom - d.bottom + v + s))
          : e.bottom > d.bottom && ((v = e.bottom - d.bottom + s), n < 0 && e.top - v < d.top && (v = -(d.top + v - e.top + s)));
      else {
        let g = e.bottom - e.top,
          b = d.bottom - d.top;
        v =
          (i == "center" && g <= b ? e.top + g / 2 - b / 2 : i == "start" || (i == "center" && n < 0) ? e.top - s : e.bottom - b + s) -
          d.top;
      }
      if (
        (r == "nearest"
          ? e.left < d.left
            ? ((O = -(d.left - e.left + o)), n > 0 && e.right > d.right + O && (O = e.right - d.right + O + o))
            : e.right > d.right && ((O = e.right - d.right + o), n < 0 && e.left < d.left + O && (O = -(d.left + O - e.left + o)))
          : (O =
              (r == "center"
                ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2
                : (r == "start") == l
                ? e.left - o
                : e.right - (d.right - d.left) + o) - d.left),
        O || v)
      )
        if (f) c.scrollBy(O, v);
        else {
          let g = 0,
            b = 0;
          if (v) {
            let x = u.scrollTop;
            (u.scrollTop += v / m), (b = (u.scrollTop - x) * m);
          }
          if (O) {
            let x = u.scrollLeft;
            (u.scrollLeft += O / p), (g = (u.scrollLeft - x) * p);
          }
          (e = { left: e.left - g, top: e.top - b, right: e.right - g, bottom: e.bottom - b }),
            g && Math.abs(g - O) < 1 && (r = "nearest"),
            b && Math.abs(b - v) < 1 && (i = "nearest");
        }
      if (f) break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11) u = u.host;
    else break;
}
function wee(t) {
  let e = t.ownerDocument;
  for (let n = t.parentNode; n && n != e.body; )
    if (n.nodeType == 1) {
      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth) return n;
      n = n.assignedSlot || n.parentNode;
    } else if (n.nodeType == 11) n = n.host;
    else break;
  return null;
}
class See {
  constructor() {
    (this.anchorNode = null), (this.anchorOffset = 0), (this.focusNode = null), (this.focusOffset = 0);
  }
  eq(e) {
    return (
      this.anchorNode == e.anchorNode &&
      this.anchorOffset == e.anchorOffset &&
      this.focusNode == e.focusNode &&
      this.focusOffset == e.focusOffset
    );
  }
  setRange(e) {
    let { anchorNode: n, focusNode: r } = e;
    this.set(n, Math.min(e.anchorOffset, n ? Yi(n) : 0), r, Math.min(e.focusOffset, r ? Yi(r) : 0));
  }
  set(e, n, r, i) {
    (this.anchorNode = e), (this.anchorOffset = n), (this.focusNode = r), (this.focusOffset = i);
  }
}
let il = null;
function Z9(t) {
  if (t.setActive) return t.setActive();
  if (il) return t.focus(il);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode);
  if (
    (t.focus(
      il == null
        ? {
            get preventScroll() {
              return (il = { preventScroll: !0 }), !0;
            },
          }
        : void 0
    ),
    !il)
  ) {
    il = !1;
    for (let n = 0; n < e.length; ) {
      let r = e[n++],
        i = e[n++],
        o = e[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
    }
  }
}
let D2;
function Ls(t, e, n = e) {
  let r = D2 || (D2 = document.createRange());
  return r.setEnd(t, n), r.setStart(t, e), r;
}
function Ql(t, e, n, r) {
  let i = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let o = new KeyboardEvent("keydown", i);
  (o.synthetic = !0), t.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", i);
  return (s.synthetic = !0), t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function kee(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || (t.nodeType == 11 && t.host))) return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function z9(t) {
  for (; t.attributes.length; ) t.removeAttributeNode(t.attributes[0]);
}
function Cee(t, e) {
  let n = e.focusNode,
    r = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != r) return !1;
  for (r = Math.min(r, Yi(n)); ; )
    if (r) {
      if (n.nodeType != 1) return !1;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : ((n = i), (r = Yi(n)));
    } else {
      if (n == t) return !0;
      (r = Ms(n)), (n = n.parentNode);
    }
}
function W9(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function X9(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r > 0) return { node: n, offset: r };
    if (n.nodeType == 1 && r > 0) {
      if (n.contentEditable == "false") return null;
      (n = n.childNodes[r - 1]), (r = Yi(n));
    } else if (n.parentNode && !ap(n)) (r = Ms(n)), (n = n.parentNode);
    else return null;
  }
}
function U9(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r < n.nodeValue.length) return { node: n, offset: r };
    if (n.nodeType == 1 && r < n.childNodes.length) {
      if (n.contentEditable == "false") return null;
      (n = n.childNodes[r]), (r = 0);
    } else if (n.parentNode && !ap(n)) (r = Ms(n) + 1), (n = n.parentNode);
    else return null;
  }
}
class On {
  constructor(e, n, r = !0) {
    (this.node = e), (this.offset = n), (this.precise = r);
  }
  static before(e, n) {
    return new On(e.parentNode, Ms(e), n);
  }
  static after(e, n) {
    return new On(e.parentNode, Ms(e) + 1, n);
  }
}
const Py = [];
class ft {
  constructor() {
    (this.parent = null), (this.dom = null), (this.flags = 2);
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == e) return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let r = this.dom,
        i = null,
        o;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (o = i ? i.nextSibling : r.firstChild)) {
            let l = ft.get(o);
            (!l || (!l.parent && l.canReuseDOM(s))) && s.reuseDOM(o);
          }
          s.sync(e, n), (s.flags &= -8);
        }
        if (
          ((o = i ? i.nextSibling : r.firstChild), n && !n.written && n.node == r && o != s.dom && (n.written = !0), s.dom.parentNode == r)
        )
          for (; o && o != s.dom; ) o = F2(o);
        else r.insertBefore(s.dom, o);
        i = s.dom;
      }
      for (o = i ? i.nextSibling : r.firstChild, o && n && n.node == r && (n.written = !0); o; ) o = F2(o);
    } else if (this.flags & 1) for (let r of this.children) r.flags & 7 && (r.sync(e, n), (r.flags &= -8));
  }
  reuseDOM(e) {}
  localPosFromDOM(e, n) {
    let r;
    if (e == this.dom) r = this.dom.childNodes[n];
    else {
      let i = Yi(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (;;) {
        let o = e.parentNode;
        if (o == this.dom) break;
        i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? (i = -1) : (i = 1)), (e = o);
      }
      i < 0 ? (r = e) : (r = e.nextSibling);
    }
    if (r == this.dom.firstChild) return 0;
    for (; r && !ft.get(r); ) r = r.nextSibling;
    if (!r) return this.length;
    for (let i = 0, o = 0; ; i++) {
      let s = this.children[i];
      if (s.dom == r) return o;
      o += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, n, r = 0) {
    let i = -1,
      o = -1,
      s = -1,
      l = -1;
    for (let a = 0, c = r, u = r; a < this.children.length; a++) {
      let h = this.children[a],
        d = c + h.length;
      if (c < e && d > n) return h.domBoundsAround(e, n, c);
      if ((d >= e && i == -1 && ((i = a), (o = c)), c > n && h.dom.parentNode == this.dom)) {
        (s = a), (l = u);
        break;
      }
      (u = d), (c = d + h.breakAfter);
    }
    return {
      from: o,
      to: l < 0 ? r + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null,
    };
  }
  markDirty(e = !1) {
    (this.flags |= 2), this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if ((e && (n.flags |= 2), n.flags & 1)) return;
      (n.flags |= 1), (e = !1);
    }
  }
  setParent(e) {
    this.parent != e && ((this.parent = e), this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), (this.dom = e), (e.cmView = this));
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n) return e;
      e = n;
    }
  }
  replaceChildren(e, n, r = Py) {
    this.markDirty();
    for (let i = e; i < n; i++) {
      let o = this.children[i];
      o.parent == this && r.indexOf(o) < 0 && o.destroy();
    }
    this.children.splice(e, n - e, ...r);
    for (let i = 0; i < r.length; i++) r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new H9(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return (
      e +
      (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") +
      (this.breakAfter ? "#" : "")
    );
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, r, i, o, s) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children) e.parent == this && e.destroy();
    this.parent = null;
  }
}
ft.prototype.breakAfter = 0;
function F2(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class H9 {
  constructor(e, n, r) {
    (this.children = e), (this.pos = n), (this.i = r), (this.off = 0);
  }
  findPos(e, n = 1) {
    for (;;) {
      if (e > this.pos || (e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)))
        return (this.off = e - this.pos), this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function q9(t, e, n, r, i, o, s, l, a) {
  let { children: c } = t,
    u = c.length ? c[e] : null,
    h = o.length ? o[o.length - 1] : null,
    d = h ? h.breakAfter : s;
  if (!(e == r && u && !s && !d && o.length < 2 && u.merge(n, i, o.length ? h : null, n == 0, l, a))) {
    if (r < c.length) {
      let f = c[r];
      f && (i < f.length || (f.breakAfter && h != null && h.breakAfter))
        ? (e == r && ((f = f.split(i)), (i = 0)),
          !d && h && f.merge(0, i, h, !0, 0, a)
            ? (o[o.length - 1] = f)
            : ((i || (f.children.length && !f.children[0].length)) && f.merge(0, i, null, !1, 0, a), o.push(f)))
        : f != null && f.breakAfter && (h ? (h.breakAfter = 1) : (s = 1)),
        r++;
    }
    for (
      u &&
      ((u.breakAfter = s),
      n > 0 &&
        (!s && o.length && u.merge(n, u.length, o[0], !1, l, 0)
          ? (u.breakAfter = o.shift().breakAfter)
          : (n < u.length || (u.children.length && u.children[u.children.length - 1].length == 0)) && u.merge(n, u.length, null, !1, l, 0),
        e++));
      e < r && o.length;

    )
      if (c[r - 1].become(o[o.length - 1])) r--, o.pop(), (a = o.length ? 0 : l);
      else if (c[e].become(o[0])) e++, o.shift(), (l = o.length ? 0 : a);
      else break;
    !o.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, l, a) && e--,
      (e < r || o.length) && t.replaceChildren(e, r, o);
  }
}
function Y9(t, e, n, r, i, o) {
  let s = t.childCursor(),
    { i: l, off: a } = s.findPos(n, 1),
    { i: c, off: u } = s.findPos(e, -1),
    h = e - n;
  for (let d of r) h += d.length;
  (t.length += h), q9(t, c, u, l, a, r, 0, i, o);
}
let Dn = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" },
  IO = typeof document < "u" ? document : { documentElement: { style: {} } };
const MO = /Edge\/(\d+)/.exec(Dn.userAgent),
  G9 = /MSIE \d/.test(Dn.userAgent),
  LO = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Dn.userAgent),
  Ym = !!(G9 || LO || MO),
  B2 = !Ym && /gecko\/(\d+)/i.test(Dn.userAgent),
  s1 = !Ym && /Chrome\/(\d+)/.exec(Dn.userAgent),
  V2 = "webkitFontSmoothing" in IO.documentElement.style,
  J9 = !Ym && /Apple Computer/.test(Dn.vendor),
  j2 = J9 && (/Mobile\/\w+/.test(Dn.userAgent) || Dn.maxTouchPoints > 2);
var be = {
  mac: j2 || /Mac/.test(Dn.platform),
  windows: /Win/.test(Dn.platform),
  linux: /Linux|X11/.test(Dn.platform),
  ie: Ym,
  ie_version: G9 ? IO.documentMode || 6 : LO ? +LO[1] : MO ? +MO[1] : 0,
  gecko: B2,
  gecko_version: B2 ? +(/Firefox\/(\d+)/.exec(Dn.userAgent) || [0, 0])[1] : 0,
  chrome: !!s1,
  chrome_version: s1 ? +s1[1] : 0,
  ios: j2,
  android: /Android\b/.test(Dn.userAgent),
  webkit: V2,
  safari: J9,
  webkit_version: V2 ? +(/\bAppleWebKit\/(\d+)/.exec(Dn.userAgent) || [0, 0])[1] : 0,
  tabSize: IO.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size",
};
const _ee = 256;
class Qr extends ft {
  constructor(e) {
    super(), (this.text = e);
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(),
      this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), (this.dom.nodeValue = this.text));
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, r) {
    return this.flags & 8 || (r && (!(r instanceof Qr) || this.length - (n - e) + r.length > _ee || r.flags & 8))
      ? !1
      : ((this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n)), this.markDirty(), !0);
  }
  split(e) {
    let n = new Qr(this.text.slice(e));
    return (this.text = this.text.slice(0, e)), this.markDirty(), (n.flags |= this.flags & 8), n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new On(this.dom, e);
  }
  domBoundsAround(e, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return Eee(this.dom, e, n);
  }
}
class Gi extends ft {
  constructor(e, n = [], r = 0) {
    super(), (this.mark = e), (this.children = n), (this.length = r);
    for (let i of n) i.setParent(this);
  }
  setAttrs(e) {
    if ((z9(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs))
      for (let n in this.mark.attrs) e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
      super.sync(e, n);
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof Gi && r.mark.eq(this.mark)) || (e && o <= 0) || (n < this.length && s <= 0))
      ? !1
      : (Y9(this, e, n, r ? r.children.slice() : [], o - 1, s - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [],
      r = 0,
      i = -1,
      o = 0;
    for (let l of this.children) {
      let a = r + l.length;
      a > e && n.push(r < e ? l.split(e - r) : l), i < 0 && r >= e && (i = o), (r = a), o++;
    }
    let s = this.length - e;
    return (this.length = e), i > -1 && ((this.children.length = i), this.markDirty()), new Gi(this.mark, n, s);
  }
  domAtPos(e) {
    return K9(this, e);
  }
  coordsAt(e, n) {
    return t7(this, e, n);
  }
}
function Eee(t, e, n) {
  let r = t.nodeValue.length;
  e > r && (e = r);
  let i = e,
    o = e,
    s = 0;
  (e == 0 && n < 0) || (e == r && n >= 0)
    ? be.chrome || be.gecko || (e ? (i--, (s = 1)) : o < r && (o++, (s = -1)))
    : n < 0
    ? i--
    : o < r && o++;
  let l = Ls(t, i, o).getClientRects();
  if (!l.length) return null;
  let a = l[(s ? s < 0 : n >= 0) ? 0 : l.length - 1];
  return be.safari && !s && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), s ? Ty(a, s < 0) : a || null;
}
class wo extends ft {
  static create(e, n, r) {
    return new wo(e, n, r);
  }
  constructor(e, n, r) {
    super(), (this.widget = e), (this.length = n), (this.side = r), (this.prevWidget = null);
  }
  split(e) {
    let n = wo.create(this.widget, this.length - e, this.side);
    return (this.length -= e), n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof wo) || !this.widget.compare(r.widget) || (e > 0 && o <= 0) || (n < this.length && s <= 0))
      ? !1
      : ((this.length = e + (r ? r.length : 0) + (this.length - n)), !0);
  }
  become(e) {
    return e instanceof wo && e.side == this.side && this.widget.constructor == e.widget.constructor
      ? (this.widget.compare(e.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0) return et.empty;
    let e = this;
    for (; e.parent; ) e = e.parent;
    let { view: n } = e,
      r = n && n.state.doc,
      i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : et.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? On.before(this.dom) : On.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    if (r) return r;
    let i = this.dom.getClientRects(),
      o = null;
    if (!i.length) return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let l = s ? i.length - 1 : 0; (o = i[l]), !(e > 0 ? l == 0 : l == i.length - 1 || o.top < o.bottom); l += s ? -1 : 1);
    return Ty(o, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class ra extends ft {
  constructor(e) {
    super(), (this.side = e);
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof ra && e.side == this.side;
  }
  split() {
    return new ra(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      (e.className = "cm-widgetBuffer"), e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? On.before(this.dom) : On.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return et.empty;
  }
  get isHidden() {
    return !0;
  }
}
Qr.prototype.children = wo.prototype.children = ra.prototype.children = Py;
function K9(t, e) {
  let n = t.dom,
    { children: r } = t,
    i = 0;
  for (let o = 0; i < r.length; i++) {
    let s = r[i],
      l = o + s.length;
    if (!(l == o && s.getSide() <= 0)) {
      if (e > o && e < l && s.dom.parentNode == n) return s.domAtPos(e - o);
      if (e <= o) break;
      o = l;
    }
  }
  for (let o = i; o > 0; o--) {
    let s = r[o - 1];
    if (s.dom.parentNode == n) return s.domAtPos(s.length);
  }
  for (let o = i; o < r.length; o++) {
    let s = r[o];
    if (s.dom.parentNode == n) return s.domAtPos(0);
  }
  return new On(n, 0);
}
function e7(t, e, n) {
  let r,
    { children: i } = t;
  n > 0 && e instanceof Gi && i.length && (r = i[i.length - 1]) instanceof Gi && r.mark.eq(e.mark)
    ? e7(r, e.children[0], n - 1)
    : (i.push(e), e.setParent(t)),
    (t.length += e.length);
}
function t7(t, e, n) {
  let r = null,
    i = -1,
    o = null,
    s = -1;
  function l(c, u) {
    for (let h = 0, d = 0; h < c.children.length && d <= u; h++) {
      let f = c.children[h],
        p = d + f.length;
      p >= u &&
        (f.children.length
          ? l(f, u - d)
          : (!o || (o.isHidden && n > 0)) && (p > u || (d == p && f.getSide() > 0))
          ? ((o = f), (s = u - d))
          : (d < u || (d == p && f.getSide() < 0 && !f.isHidden)) && ((r = f), (i = u - d))),
        (d = p);
    }
  }
  l(t, e);
  let a = (n < 0 ? r : o) || r || o;
  return a ? a.coordsAt(Math.max(0, a == r ? i : s), n) : Tee(t);
}
function Tee(t) {
  let e = t.dom.lastChild;
  if (!e) return t.dom.getBoundingClientRect();
  let n = xu(e);
  return n[n.length - 1] || null;
}
function NO(t, e) {
  for (let n in t)
    n == "class" && e.class ? (e.class += " " + t.class) : n == "style" && e.style ? (e.style += ";" + t.style) : (e[n] = t[n]);
  return e;
}
const Z2 = Object.create(null);
function cp(t, e, n) {
  if (t == e) return !0;
  t || (t = Z2), e || (e = Z2);
  let r = Object.keys(t),
    i = Object.keys(e);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0)) return !1;
  for (let o of r) if (o != n && (i.indexOf(o) == -1 || t[o] !== e[o])) return !1;
  return !0;
}
function QO(t, e, n) {
  let r = !1;
  if (e) for (let i in e) (n && i in n) || ((r = !0), i == "style" ? (t.style.cssText = "") : t.removeAttribute(i));
  if (n) for (let i in n) (e && e[i] == n[i]) || ((r = !0), i == "style" ? (t.style.cssText = n[i]) : t.setAttribute(i, n[i]));
  return r;
}
function Pee(t) {
  let e = Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let r = t.attributes[n];
    e[r.name] = r.value;
  }
  return e;
}
class Bt extends ft {
  constructor() {
    super(...arguments), (this.children = []), (this.length = 0), (this.prevAttrs = void 0), (this.attrs = null), (this.breakAfter = 0);
  }
  merge(e, n, r, i, o, s) {
    if (r) {
      if (!(r instanceof Bt)) return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), Y9(this, e, n, r ? r.children.slice() : [], o, s), !0;
  }
  split(e) {
    let n = new Bt();
    if (((n.breakAfter = this.breakAfter), this.length == 0)) return n;
    let { i: r, off: i } = this.childPos(e);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let o = r; o < this.children.length; o++) n.append(this.children[o], 0);
    for (; r > 0 && this.children[r - 1].length == 0; ) this.children[--r].destroy();
    return (this.children.length = r), this.markDirty(), (this.length = e), n;
  }
  transferDOM(e) {
    this.dom &&
      (this.markDirty(),
      e.setDOM(this.dom),
      (e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs),
      (this.prevAttrs = void 0),
      (this.dom = null));
  }
  setDeco(e) {
    cp(this.attrs, e) || (this.dom && ((this.prevAttrs = this.attrs), this.markDirty()), (this.attrs = e));
  }
  append(e, n) {
    e7(this, e, n);
  }
  addLineDeco(e) {
    let n = e.spec.attributes,
      r = e.spec.class;
    n && (this.attrs = NO(n, this.attrs || {})), r && (this.attrs = NO({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return K9(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, n) {
    var r;
    this.dom
      ? this.flags & 4 && (z9(this.dom), (this.dom.className = "cm-line"), (this.prevAttrs = this.attrs ? null : void 0))
      : (this.setDOM(document.createElement("div")), (this.dom.className = "cm-line"), (this.prevAttrs = this.attrs ? null : void 0)),
      this.prevAttrs !== void 0 && (QO(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), (this.prevAttrs = void 0)),
      super.sync(e, n);
    let i = this.dom.lastChild;
    for (; i && ft.get(i) instanceof Gi; ) i = i.lastChild;
    if (
      !i ||
      !this.length ||
      (i.nodeName != "BR" &&
        ((r = ft.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 &&
        (!be.ios || !this.children.some((o) => o instanceof Qr)))
    ) {
      let o = document.createElement("BR");
      (o.cmIgnore = !0), this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null;
    let e = 0,
      n;
    for (let r of this.children) {
      if (!(r instanceof Qr) || /[^ -~]/.test(r.text)) return null;
      let i = xu(r.dom);
      if (i.length != 1) return null;
      (e += i[0].width), (n = i[0].height);
    }
    return e ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: e / this.length, textHeight: n } : null;
  }
  coordsAt(e, n) {
    let r = t7(this, e, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState,
        o = r.bottom - r.top;
      if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
        let s = (o - i.textHeight) / 2;
        return { top: r.top + s, bottom: r.bottom - s, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return (
      e instanceof Bt && this.children.length == 0 && e.children.length == 0 && cp(this.attrs, e.attrs) && this.breakAfter == e.breakAfter
    );
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let o = e.children[r],
        s = i + o.length;
      if (s >= n) {
        if (o instanceof Bt) return o;
        if (s > n) break;
      }
      i = s + o.breakAfter;
    }
    return null;
  }
}
class Bi extends ft {
  constructor(e, n, r) {
    super(), (this.widget = e), (this.length = n), (this.deco = r), (this.breakAfter = 0), (this.prevWidget = null);
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof Bi) || !this.widget.compare(r.widget) || (e > 0 && o <= 0) || (n < this.length && s <= 0))
      ? !1
      : ((this.length = e + (r ? r.length : 0) + (this.length - n)), !0);
  }
  domAtPos(e) {
    return e == 0 ? On.before(this.dom) : On.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let r = new Bi(this.widget, n, this.deco);
    return (r.breakAfter = this.breakAfter), r;
  }
  get children() {
    return Py;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : et.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Bi && e.widget.constructor == this.widget.constructor
      ? (e.widget.compare(this.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        (this.deco = e.deco),
        (this.breakAfter = e.breakAfter),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    return this.widget.coordsAt(this.dom, e, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : e < 0 ? n < 0 : r > 0;
  }
}
class Wr {
  eq(e) {
    return !1;
  }
  updateDOM(e, n) {
    return !1;
  }
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(e) {
    return !0;
  }
  coordsAt(e, n, r) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  get editable() {
    return !1;
  }
  destroy(e) {}
}
var Pn = (function (t) {
  return (
    (t[(t.Text = 0)] = "Text"),
    (t[(t.WidgetBefore = 1)] = "WidgetBefore"),
    (t[(t.WidgetAfter = 2)] = "WidgetAfter"),
    (t[(t.WidgetRange = 3)] = "WidgetRange"),
    t
  );
})(Pn || (Pn = {}));
class me extends Is {
  constructor(e, n, r, i) {
    super(), (this.startSide = e), (this.endSide = n), (this.widget = r), (this.spec = i);
  }
  get heightRelevant() {
    return !1;
  }
  static mark(e) {
    return new Ph(e);
  }
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)),
      r = !!e.block;
    return (n += r && !e.inlineOrder ? (n > 0 ? 3e8 : -4e8) : n > 0 ? 1e8 : -1e8), new jo(e, n, n, r, e.widget || null, !1);
  }
  static replace(e) {
    let n = !!e.block,
      r,
      i;
    if (e.isBlockGap) (r = -5e8), (i = 4e8);
    else {
      let { start: o, end: s } = n7(e, n);
      (r = (o ? (n ? -3e8 : -1) : 5e8) - 1), (i = (s ? (n ? 2e8 : 1) : -6e8) + 1);
    }
    return new jo(e, r, i, n, e.widget || null, !0);
  }
  static line(e) {
    return new Ah(e);
  }
  static set(e, n = !1) {
    return ze.of(e, n);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
me.none = ze.empty;
class Ph extends me {
  constructor(e) {
    let { start: n, end: r } = n7(e);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e),
      (this.tagName = e.tagName || "span"),
      (this.class = e.class || ""),
      (this.attrs = e.attributes || null);
  }
  eq(e) {
    var n, r;
    return (
      this == e ||
      (e instanceof Ph &&
        this.tagName == e.tagName &&
        (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) ==
          (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) &&
        cp(this.attrs, e.attrs, "class"))
    );
  }
  range(e, n = e) {
    if (e >= n) throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
Ph.prototype.point = !1;
class Ah extends me {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ah && this.spec.class == e.spec.class && cp(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e) throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
Ah.prototype.mapMode = un.TrackBefore;
Ah.prototype.point = !0;
class jo extends me {
  constructor(e, n, r, i, o, s) {
    super(n, r, o, e), (this.block = i), (this.isReplace = s), (this.mapMode = i ? (n <= 0 ? un.TrackBefore : un.TrackAfter) : un.TrackDel);
  }
  get type() {
    return this.startSide != this.endSide ? Pn.WidgetRange : this.startSide <= 0 ? Pn.WidgetBefore : Pn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || (!!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0));
  }
  eq(e) {
    return (
      e instanceof jo && Aee(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide
    );
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || (e == n && this.startSide > 0 && this.endSide <= 0)))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e) throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
jo.prototype.point = !0;
function n7(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = t;
  return n == null && (n = t.inclusive), r == null && (r = t.inclusive), { start: n ?? e, end: r ?? e };
}
function Aee(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function DO(t, e, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= t ? (n[i] = Math.max(n[i], e)) : n.push(t, e);
}
class Zc {
  constructor(e, n, r, i) {
    (this.doc = e),
      (this.pos = n),
      (this.end = r),
      (this.disallowBlockEffectsFor = i),
      (this.content = []),
      (this.curLine = null),
      (this.breakAtStart = 0),
      (this.pendingBuffer = 0),
      (this.bufferMarks = []),
      (this.atCursorPos = !0),
      (this.openStart = -1),
      (this.openEnd = -1),
      (this.text = ""),
      (this.textOff = 0),
      (this.cursor = e.iter()),
      (this.skip = n);
  }
  posCovered() {
    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || (e instanceof Bi && e.deco.endSide < 0));
  }
  getLine() {
    return this.curLine || (this.content.push((this.curLine = new Bt())), (this.atCursorPos = !0)), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(ad(new ra(-1), e), e.length), (this.pendingBuffer = 0));
  }
  addBlockWidget(e) {
    this.flushBuffer(), (this.curLine = null), this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : (this.pendingBuffer = 0),
      !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Bi) && this.getLine();
  }
  buildText(e, n, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: s, done: l } = this.cursor.next(this.skip);
        if (((this.skip = 0), l)) throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(),
            this.content.length ? (this.content[this.content.length - 1].breakAfter = 1) : (this.breakAtStart = 1),
            this.flushBuffer(),
            (this.curLine = null),
            (this.atCursorPos = !0),
            e--;
          continue;
        } else (this.text = o), (this.textOff = 0);
      }
      let i = Math.min(this.text.length - this.textOff, e, 512);
      this.flushBuffer(n.slice(n.length - r)),
        this.getLine().append(ad(new Qr(this.text.slice(this.textOff, this.textOff + i)), n), r),
        (this.atCursorPos = !0),
        (this.textOff += i),
        (e -= i),
        (r = 0);
    }
  }
  span(e, n, r, i) {
    this.buildText(n - e, r, i), (this.pos = n), this.openStart < 0 && (this.openStart = i);
  }
  point(e, n, r, i, o, s) {
    if (this.disallowBlockEffectsFor[s] && r instanceof jo) {
      if (r.block) throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = n - e;
    if (r instanceof jo)
      if (r.block) r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Bi(r.widget || ia.block, l, r));
      else {
        let a = wo.create(r.widget || ia.inline, l, l ? 0 : r.startSide),
          c = this.atCursorPos && !a.isEditable && o <= i.length && (e < n || r.startSide > 0),
          u = !a.isEditable && (e < n || o > i.length || r.startSide <= 0),
          h = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0),
          this.flushBuffer(i),
          c && (h.append(ad(new ra(1), i), o), (o = i.length + Math.max(0, o - i.length))),
          h.append(ad(a, i), o),
          (this.atCursorPos = u),
          (this.pendingBuffer = u ? (e < n || o > i.length ? 1 : 2) : 0),
          this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    l &&
      (this.textOff + l <= this.text.length
        ? (this.textOff += l)
        : ((this.skip += l - (this.text.length - this.textOff)), (this.text = ""), (this.textOff = 0)),
      (this.pos = n)),
      this.openStart < 0 && (this.openStart = o);
  }
  static build(e, n, r, i, o) {
    let s = new Zc(e, n, r, o);
    return (s.openEnd = ze.spans(i, n, r, s)), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function ad(t, e) {
  for (let n of e) t = new Gi(n, [t], t.length);
  return t;
}
class ia extends Wr {
  constructor(e) {
    super(), (this.tag = e);
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
ia.inline = new ia("span");
ia.block = new ia("div");
var wt = (function (t) {
  return (t[(t.LTR = 0)] = "LTR"), (t[(t.RTL = 1)] = "RTL"), t;
})(wt || (wt = {}));
const Ns = wt.LTR,
  Ay = wt.RTL;
function r7(t) {
  let e = [];
  for (let n = 0; n < t.length; n++) e.push(1 << +t[n]);
  return e;
}
const $ee = r7(
    "88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"
  ),
  Ree = r7(
    "4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"
  ),
  FO = Object.create(null),
  qr = [];
for (let t of ["()", "[]", "{}"]) {
  let e = t.charCodeAt(0),
    n = t.charCodeAt(1);
  (FO[e] = n), (FO[n] = -e);
}
function i7(t) {
  return t <= 247
    ? $ee[t]
    : 1424 <= t && t <= 1524
    ? 2
    : 1536 <= t && t <= 1785
    ? Ree[t - 1536]
    : 1774 <= t && t <= 2220
    ? 4
    : 8192 <= t && t <= 8204
    ? 256
    : 64336 <= t && t <= 65023
    ? 4
    : 1;
}
const Iee = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class So {
  get dir() {
    return this.level % 2 ? Ay : Ns;
  }
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.level = r);
  }
  side(e, n) {
    return (this.dir == n) == e ? this.to : this.from;
  }
  forward(e, n) {
    return e == (this.dir == n);
  }
  static find(e, n, r, i) {
    let o = -1;
    for (let s = 0; s < e.length; s++) {
      let l = e[s];
      if (l.from <= n && l.to >= n) {
        if (l.level == r) return s;
        (o < 0 || (i != 0 ? (i < 0 ? l.from < n : l.to > n) : e[o].level > l.level)) && (o = s);
      }
    }
    if (o < 0) throw new RangeError("Index out of range");
    return o;
  }
}
function o7(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) {
    let r = t[n],
      i = e[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !o7(r.inner, i.inner)) return !1;
  }
  return !0;
}
const ut = [];
function Mee(t, e, n, r, i) {
  for (let o = 0; o <= r.length; o++) {
    let s = o ? r[o - 1].to : e,
      l = o < r.length ? r[o].from : n,
      a = o ? 256 : i;
    for (let c = s, u = a, h = a; c < l; c++) {
      let d = i7(t.charCodeAt(c));
      d == 512 ? (d = u) : d == 8 && h == 4 && (d = 16), (ut[c] = d == 4 ? 2 : d), d & 7 && (h = d), (u = d);
    }
    for (let c = s, u = a, h = a; c < l; c++) {
      let d = ut[c];
      if (d == 128) c < l - 1 && u == ut[c + 1] && u & 24 ? (d = ut[c] = u) : (ut[c] = 256);
      else if (d == 64) {
        let f = c + 1;
        for (; f < l && ut[f] == 64; ) f++;
        let p = (c && u == 8) || (f < n && ut[f] == 8) ? (h == 1 ? 1 : 8) : 256;
        for (let m = c; m < f; m++) ut[m] = p;
        c = f - 1;
      } else d == 8 && h == 1 && (ut[c] = 1);
      (u = d), d & 7 && (h = d);
    }
  }
}
function Lee(t, e, n, r, i) {
  let o = i == 1 ? 2 : 1;
  for (let s = 0, l = 0, a = 0; s <= r.length; s++) {
    let c = s ? r[s - 1].to : e,
      u = s < r.length ? r[s].from : n;
    for (let h = c, d, f, p; h < u; h++)
      if ((f = FO[(d = t.charCodeAt(h))]))
        if (f < 0) {
          for (let m = l - 3; m >= 0; m -= 3)
            if (qr[m + 1] == -f) {
              let O = qr[m + 2],
                v = O & 2 ? i : O & 4 ? (O & 1 ? o : i) : 0;
              v && (ut[h] = ut[qr[m]] = v), (l = m);
              break;
            }
        } else {
          if (qr.length == 189) break;
          (qr[l++] = h), (qr[l++] = d), (qr[l++] = a);
        }
      else if ((p = ut[h]) == 2 || p == 1) {
        let m = p == i;
        a = m ? 0 : 1;
        for (let O = l - 3; O >= 0; O -= 3) {
          let v = qr[O + 2];
          if (v & 2) break;
          if (m) qr[O + 2] |= 2;
          else {
            if (v & 4) break;
            qr[O + 2] |= 4;
          }
        }
      }
  }
}
function Nee(t, e, n, r) {
  for (let i = 0, o = r; i <= n.length; i++) {
    let s = i ? n[i - 1].to : t,
      l = i < n.length ? n[i].from : e;
    for (let a = s; a < l; ) {
      let c = ut[a];
      if (c == 256) {
        let u = a + 1;
        for (;;)
          if (u == l) {
            if (i == n.length) break;
            (u = n[i++].to), (l = i < n.length ? n[i].from : e);
          } else if (ut[u] == 256) u++;
          else break;
        let h = o == 1,
          d = (u < e ? ut[u] : r) == 1,
          f = h == d ? (h ? 1 : 2) : r;
        for (let p = u, m = i, O = m ? n[m - 1].to : t; p > a; ) p == O && ((p = n[--m].from), (O = m ? n[m - 1].to : t)), (ut[--p] = f);
        a = u;
      } else (o = c), a++;
    }
  }
}
function BO(t, e, n, r, i, o, s) {
  let l = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let a = e, c = 0; a < n; ) {
      let u = !0,
        h = !1;
      if (c == o.length || a < o[c].from) {
        let m = ut[a];
        m != l && ((u = !1), (h = m == 16));
      }
      let d = !u && l == 1 ? [] : null,
        f = u ? r : r + 1,
        p = a;
      e: for (;;)
        if (c < o.length && p == o[c].from) {
          if (h) break e;
          let m = o[c];
          if (!u)
            for (let O = m.to, v = c + 1; ; ) {
              if (O == n) break e;
              if (v < o.length && o[v].from == O) O = o[v++].to;
              else {
                if (ut[O] == l) break e;
                break;
              }
            }
          if ((c++, d)) d.push(m);
          else {
            m.from > a && s.push(new So(a, m.from, f));
            let O = (m.direction == Ns) != !(f % 2);
            VO(t, O ? r + 1 : r, i, m.inner, m.from, m.to, s), (a = m.to);
          }
          p = m.to;
        } else {
          if (p == n || (u ? ut[p] != l : ut[p] == l)) break;
          p++;
        }
      d ? BO(t, a, p, r + 1, i, d, s) : a < p && s.push(new So(a, p, f)), (a = p);
    }
  else
    for (let a = n, c = o.length; a > e; ) {
      let u = !0,
        h = !1;
      if (!c || a > o[c - 1].to) {
        let m = ut[a - 1];
        m != l && ((u = !1), (h = m == 16));
      }
      let d = !u && l == 1 ? [] : null,
        f = u ? r : r + 1,
        p = a;
      e: for (;;)
        if (c && p == o[c - 1].to) {
          if (h) break e;
          let m = o[--c];
          if (!u)
            for (let O = m.from, v = c; ; ) {
              if (O == e) break e;
              if (v && o[v - 1].to == O) O = o[--v].from;
              else {
                if (ut[O - 1] == l) break e;
                break;
              }
            }
          if (d) d.push(m);
          else {
            m.to < a && s.push(new So(m.to, a, f));
            let O = (m.direction == Ns) != !(f % 2);
            VO(t, O ? r + 1 : r, i, m.inner, m.from, m.to, s), (a = m.from);
          }
          p = m.from;
        } else {
          if (p == e || (u ? ut[p - 1] != l : ut[p - 1] == l)) break;
          p--;
        }
      d ? BO(t, p, a, r + 1, i, d, s) : p < a && s.push(new So(p, a, f)), (a = p);
    }
}
function VO(t, e, n, r, i, o, s) {
  let l = e % 2 ? 2 : 1;
  Mee(t, i, o, r, l), Lee(t, i, o, r, l), Nee(i, o, r, l), BO(t, i, o, e, n, r, s);
}
function Qee(t, e, n) {
  if (!t) return [new So(0, 0, e == Ay ? 1 : 0)];
  if (e == Ns && !n.length && !Iee.test(t)) return s7(t.length);
  if (n.length) for (; t.length > ut.length; ) ut[ut.length] = 256;
  let r = [],
    i = e == Ns ? 0 : 1;
  return VO(t, i, i, n, 0, t.length, r), r;
}
function s7(t) {
  return [new So(0, t, 0)];
}
let l7 = "";
function Dee(t, e, n, r, i) {
  var o;
  let s = r.head - t.from,
    l = So.find(e, s, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc),
    a = e[l],
    c = a.side(i, n);
  if (s == c) {
    let d = (l += i ? 1 : -1);
    if (d < 0 || d >= e.length) return null;
    (a = e[(l = d)]), (s = a.side(!i, n)), (c = a.side(i, n));
  }
  let u = dn(t.text, s, a.forward(i, n));
  (u < a.from || u > a.to) && (u = c), (l7 = t.text.slice(Math.min(s, u), Math.max(s, u)));
  let h = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < a.level
    ? H.cursor(h.side(!i, n) + t.from, h.forward(i, n) ? 1 : -1, h.level)
    : H.cursor(u + t.from, a.forward(i, n) ? -1 : 1, a.level);
}
function Fee(t, e, n) {
  for (let r = e; r < n; r++) {
    let i = i7(t.charCodeAt(r));
    if (i == 1) return Ns;
    if (i == 2 || i == 4) return Ay;
  }
  return Ns;
}
const a7 = xe.define(),
  c7 = xe.define(),
  u7 = xe.define(),
  h7 = xe.define(),
  jO = xe.define(),
  d7 = xe.define(),
  f7 = xe.define(),
  p7 = xe.define({ combine: (t) => t.some((e) => e) }),
  m7 = xe.define({ combine: (t) => t.some((e) => e) }),
  g7 = xe.define();
class Dl {
  constructor(e, n = "nearest", r = "nearest", i = 5, o = 5, s = !1) {
    (this.range = e), (this.y = n), (this.x = r), (this.yMargin = i), (this.xMargin = o), (this.isSnapshot = s);
  }
  map(e) {
    return e.empty ? this : new Dl(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length
      ? this
      : new Dl(H.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const cd = Ee.define({ map: (t, e) => t.map(e) }),
  O7 = Ee.define();
function jn(t, e, n) {
  let r = t.facet(h7);
  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
const mo = xe.define({ combine: (t) => (t.length ? t[0] : !0) });
let Bee = 0;
const yc = xe.define();
class At {
  constructor(e, n, r, i, o) {
    (this.id = e), (this.create = n), (this.domEventHandlers = r), (this.domEventObservers = i), (this.extension = o(this));
  }
  static define(e, n) {
    const { eventHandlers: r, eventObservers: i, provide: o, decorations: s } = n || {};
    return new At(Bee++, e, r, i, (l) => {
      let a = [yc.of(l)];
      return (
        s &&
          a.push(
            yu.of((c) => {
              let u = c.plugin(l);
              return u ? s(u) : me.none;
            })
          ),
        o && a.push(o(l)),
        a
      );
    });
  }
  static fromClass(e, n) {
    return At.define((r) => new e(r), n);
  }
}
class l1 {
  constructor(e) {
    (this.spec = e), (this.mustUpdate = null), (this.value = null);
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (((this.mustUpdate = null), this.value.update))
          try {
            this.value.update(n);
          } catch (r) {
            if ((jn(n.state, r, "CodeMirror plugin crashed"), this.value.destroy))
              try {
                this.value.destroy();
              } catch {}
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        jn(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        jn(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const v7 = xe.define(),
  $y = xe.define(),
  yu = xe.define(),
  b7 = xe.define(),
  Ry = xe.define(),
  x7 = xe.define();
function z2(t, e) {
  let n = t.state.facet(x7);
  if (!n.length) return n;
  let r = n.map((o) => (o instanceof Function ? o(t) : o)),
    i = [];
  return (
    ze.spans(r, e.from, e.to, {
      point() {},
      span(o, s, l, a) {
        let c = o - e.from,
          u = s - e.from,
          h = i;
        for (let d = l.length - 1; d >= 0; d--, a--) {
          let f = l[d].spec.bidiIsolate,
            p;
          if ((f == null && (f = Fee(e.text, c, u)), a > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == f))
            (p.to = u), (h = p.inner);
          else {
            let m = { from: c, to: u, direction: f, inner: [] };
            h.push(m), (h = m.inner);
          }
        }
      },
    }),
    i
  );
}
const y7 = xe.define();
function w7(t) {
  let e = 0,
    n = 0,
    r = 0,
    i = 0;
  for (let o of t.state.facet(y7)) {
    let s = o(t);
    s &&
      (s.left != null && (e = Math.max(e, s.left)),
      s.right != null && (n = Math.max(n, s.right)),
      s.top != null && (r = Math.max(r, s.top)),
      s.bottom != null && (i = Math.max(i, s.bottom)));
  }
  return { left: e, right: n, top: r, bottom: i };
}
const wc = xe.define();
class Or {
  constructor(e, n, r, i) {
    (this.fromA = e), (this.toA = n), (this.fromB = r), (this.toB = i);
  }
  join(e) {
    return new Or(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length,
      r = this;
    for (; n > 0; n--) {
      let i = e[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA) break;
        (r = r.join(i)), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, r), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0) return e;
    let r = [];
    for (let i = 0, o = 0, s = 0, l = 0; ; i++) {
      let a = i == e.length ? null : e[i],
        c = s - l,
        u = a ? a.fromB : 1e9;
      for (; o < n.length && n[o] < u; ) {
        let h = n[o],
          d = n[o + 1],
          f = Math.max(l, h),
          p = Math.min(u, d);
        if ((f <= p && new Or(f + c, p + c, f, p).addToSet(r), d > u)) break;
        o += 2;
      }
      if (!a) return r;
      new Or(a.fromA, a.toA, a.fromB, a.toB).addToSet(r), (s = a.toA), (l = a.toB);
    }
  }
}
class up {
  constructor(e, n, r) {
    (this.view = e),
      (this.state = n),
      (this.transactions = r),
      (this.flags = 0),
      (this.startState = e.state),
      (this.changes = jt.empty(this.startState.doc.length));
    for (let o of r) this.changes = this.changes.compose(o.changes);
    let i = [];
    this.changes.iterChangedRanges((o, s, l, a) => i.push(new Or(o, s, l, a))), (this.changedRanges = i);
  }
  static create(e, n, r) {
    return new up(e, n, r);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class W2 extends ft {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(),
      (this.view = e),
      (this.decorations = []),
      (this.dynamicDecorationMap = [!1]),
      (this.domChanged = null),
      (this.hasComposition = null),
      (this.markedForComposition = new Set()),
      (this.editContextFormatting = me.none),
      (this.lastCompositionAfterCursor = !1),
      (this.minWidth = 0),
      (this.minWidthFrom = 0),
      (this.minWidthTo = 0),
      (this.impreciseAnchor = null),
      (this.impreciseHead = null),
      (this.forceSelection = !1),
      (this.lastUpdate = Date.now()),
      this.setDOM(e.contentDOM),
      (this.children = [new Bt()]),
      this.children[0].setParent(this),
      this.updateDeco(),
      this.updateInner([new Or(0, 0, 0, e.state.doc.length)], 0, null);
  }
  update(e) {
    var n;
    let r = e.changedRanges;
    this.minWidth > 0 &&
      r.length &&
      (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo)
        ? ((this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1)), (this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)))
        : (this.minWidth = this.minWidthFrom = this.minWidthTo = 0)),
      this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 &&
      !this.view.observer.editContext &&
      (!((n = this.domChanged) === null || n === void 0) && n.newSel
        ? (i = this.domChanged.newSel.head)
        : !Uee(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let o = i > -1 ? jee(this.view, e.changes, i) : null;
    if (((this.domChanged = null), this.hasComposition)) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new Or(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    (this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null),
      (be.ie || be.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let s = this.decorations,
      l = this.updateDeco(),
      a = Wee(s, l, e.changes);
    return (
      (r = Or.extendWithRanges(r, a)),
      !(this.flags & 7) && r.length == 0
        ? !1
        : (this.updateInner(r, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0)
    );
  }
  updateInner(e, n, r) {
    (this.view.viewState.mustMeasureContent = !0), this.updateChildren(e, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      (this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px"),
        (this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "");
      let s = be.chrome || be.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s),
        (this.flags &= -8),
        s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = !0),
        (this.dom.style.height = "");
    }),
      this.markedForComposition.forEach((s) => (s.flags &= -9));
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children) s instanceof Bi && s.widget instanceof X2 && o.push(s.dom);
    i.updateGaps(o);
  }
  updateChildren(e, n, r) {
    let i = r ? r.range.addToSet(e.slice()) : e,
      o = this.childCursor(n);
    for (let s = i.length - 1; ; s--) {
      let l = s >= 0 ? i[s] : null;
      if (!l) break;
      let { fromA: a, toA: c, fromB: u, toB: h } = l,
        d,
        f,
        p,
        m;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let x = Zc.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap),
          k = Zc.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        (f = x.breakAtStart), (p = x.openStart), (m = k.openEnd);
        let w = this.compositionView(r);
        k.breakAtStart
          ? (w.breakAfter = 1)
          : k.content.length &&
            w.merge(w.length, w.length, k.content[0], !1, k.openStart, 0) &&
            ((w.breakAfter = k.content[0].breakAfter), k.content.shift()),
          x.content.length && w.merge(0, 0, x.content[x.content.length - 1], !0, 0, x.openEnd) && x.content.pop(),
          (d = x.content.concat(w).concat(k.content));
      } else
        ({
          content: d,
          breakAtStart: f,
          openStart: p,
          openEnd: m,
        } = Zc.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: O, off: v } = o.findPos(c, 1),
        { i: g, off: b } = o.findPos(a, -1);
      q9(this, g, b, O, v, d, f, p, m);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions) for (let r of n.effects) r.is(O7) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let n = new Qr(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of e.marks) n = new Gi(i, [n], n.length);
    let r = new Bt();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(e) {
    let n = (o, s) => {
        (s.flags |= 8 | (s.children.some((a) => a.flags & 7) ? 1 : 0)), this.markedForComposition.add(s);
        let l = ft.get(o);
        l && l != s && (l.dom = null), s.setDOM(o);
      },
      r = this.childPos(e.range.fromB, 1),
      i = this.children[r.i];
    n(e.line, i);
    for (let o = e.marks.length - 1; o >= -1; o--)
      (r = i.childPos(r.off, 1)), (i = i.children[r.i]), n(o >= 0 ? e.marks[o].node : e.text, i);
  }
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement,
      i = r == this.dom,
      o = !i && tf(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || o)) return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main,
      a = this.moveToLine(this.domAtPos(l.anchor)),
      c = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (be.gecko && l.empty && !this.hasComposition && Vee(a)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(h, a.node.childNodes[a.offset] || null)), (a = c = new On(h, 0)), (s = !0);
    }
    let u = this.view.observer.selectionRange;
    (s ||
      !u.focusNode ||
      ((!jc(a.node, a.offset, u.anchorNode, u.anchorOffset) || !jc(c.node, c.offset, u.focusNode, u.focusOffset)) &&
        !this.suppressWidgetCursorChange(u, l))) &&
      (this.view.observer.ignore(() => {
        be.android &&
          be.chrome &&
          this.dom.contains(u.focusNode) &&
          Xee(u.focusNode, this.dom) &&
          (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
        let h = bu(this.view.root);
        if (h)
          if (l.empty) {
            if (be.gecko) {
              let d = Zee(a.node, a.offset);
              if (d && d != 3) {
                let f = (d == 1 ? X9 : U9)(a.node, a.offset);
                f && (a = new On(f.node, f.offset));
              }
            }
            h.collapse(a.node, a.offset), l.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = l.bidiLevel);
          } else if (h.extend) {
            h.collapse(a.node, a.offset);
            try {
              h.extend(c.node, c.offset);
            } catch {}
          } else {
            let d = document.createRange();
            l.anchor > l.head && ([a, c] = [c, a]),
              d.setEnd(c.node, c.offset),
              d.setStart(a.node, a.offset),
              h.removeAllRanges(),
              h.addRange(d);
          }
        o && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
      }),
      this.view.observer.setSelectionRange(a, c)),
      (this.impreciseAnchor = a.precise ? null : new On(u.anchorNode, u.anchorOffset)),
      (this.impreciseHead = c.precise ? null : new On(u.focusNode, u.focusOffset));
  }
  suppressWidgetCursorChange(e, n) {
    return (
      this.hasComposition &&
      n.empty &&
      jc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) &&
      this.posFromDOM(e.focusNode, e.focusOffset) == n.head
    );
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: e } = this,
      n = e.state.selection.main,
      r = bu(e.root),
      { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify) return;
    let s = Bt.find(this, n.head);
    if (!s) return;
    let l = s.posAtStart;
    if (n.head == l || n.head == l + s.length) return;
    let a = this.coordsAt(n.head, -1),
      c = this.coordsAt(n.head, 1);
    if (!a || !c || a.bottom > c.top) return;
    let u = this.domAtPos(n.head + n.assoc);
    r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != n.from && r.collapse(i, o);
  }
  moveToLine(e) {
    let n = this.dom,
      r;
    if (e.node != n) return e;
    for (let i = e.offset; !r && i < n.childNodes.length; i++) {
      let o = ft.get(n.childNodes[i]);
      o instanceof Bt && (r = o.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let o = ft.get(n.childNodes[i]);
      o instanceof Bt && (r = o.domAtPos(o.length));
    }
    return r ? new On(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let r = ft.get(n);
      if (r && r.rootView == this) return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let r = this.nearest(e);
    if (!r) throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, n) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: r } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof Bt) break;
      n++, (r = 0);
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(e, n) {
    let r = null,
      i = 0;
    for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
      let l = this.children[s],
        a = o - l.breakAfter,
        c = a - l.length;
      if (a < e) break;
      if (c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!r || (l instanceof Bt && !(r instanceof Bt && n >= 0))))
        (r = l), (i = c);
      else if (r && c == e && a == e && l instanceof Bi && Math.abs(n) < 2) {
        if (l.deco.startSide < 0) break;
        s && (r = null);
      }
      o = c;
    }
    return r ? r.coordsAt(e - i, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: r } = this.childPos(e, 1),
      i = this.children[n];
    if (!(i instanceof Bt)) return null;
    for (; i.children.length; ) {
      let { i: l, off: a } = i.childPos(r, 1);
      for (; ; l++) {
        if (l == i.children.length) return null;
        if ((i = i.children[l]).length) break;
      }
      r = a;
    }
    if (!(i instanceof Qr)) return null;
    let o = dn(i.text, r);
    if (o == r) return null;
    let s = Ls(i.dom, r, o).getClientRects();
    for (let l = 0; l < s.length; l++) {
      let a = s[l];
      if (l == s.length - 1 || (a.top < a.bottom && a.left < a.right)) return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [],
      { from: r, to: i } = e,
      o = this.view.contentDOM.clientWidth,
      s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
      l = -1,
      a = this.view.textDirection == wt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u],
        d = c + h.length;
      if (d > i) break;
      if (c >= r) {
        let f = h.dom.getBoundingClientRect();
        if ((n.push(f.height), s)) {
          let p = h.dom.lastChild,
            m = p ? xu(p) : [];
          if (m.length) {
            let O = m[m.length - 1],
              v = a ? O.right - f.left : f.right - O.left;
            v > l && ((l = v), (this.minWidth = o), (this.minWidthFrom = c), (this.minWidthTo = d));
          }
        }
      }
      c = d + h.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? wt.RTL : wt.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof Bt) {
        let s = o.measureTextSize();
        if (s) return s;
      }
    let e = document.createElement("div"),
      n,
      r,
      i;
    return (
      (e.className = "cm-line"),
      (e.style.width = "99999px"),
      (e.style.position = "absolute"),
      (e.textContent = "abc def ghi jkl mno pqr stu"),
      this.view.observer.ignore(() => {
        this.dom.appendChild(e);
        let o = xu(e.firstChild)[0];
        (n = e.getBoundingClientRect().height), (r = o ? o.width / 27 : 7), (i = o ? o.height : n), e.remove();
      }),
      { lineHeight: n, charWidth: r, textHeight: i }
    );
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new H9(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [],
      n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let o = i == n.viewports.length ? null : n.viewports[i],
        s = o ? o.from - 1 : this.length;
      if (s > r) {
        let l = (n.lineBlockAt(s).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        e.push(me.replace({ widget: new X2(l), block: !0, inclusive: !0, isBlockGap: !0 }).range(r, s));
      }
      if (!o) break;
      r = o.to + 1;
    }
    return me.set(e);
  }
  updateDeco() {
    let e = 1,
      n = this.view.state.facet(yu).map((o) => ((this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o)),
      r = !1,
      i = this.view.state.facet(b7).map((o, s) => {
        let l = typeof o == "function";
        return l && (r = !0), l ? o(this.view) : o;
      });
    for (
      i.length && ((this.dynamicDecorationMap[e++] = r), n.push(ze.join(i))),
        this.decorations = [this.editContextFormatting, ...n, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];
      e < this.decorations.length;

    )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      (this.view.scrollDOM.scrollTop = c.top - e.yMargin), (this.view.scrollDOM.scrollLeft = e.xMargin);
      return;
    }
    for (let c of this.view.state.facet(g7))
      try {
        if (c(this.view, e.range, e)) return !0;
      } catch (u) {
        jn(this.view.state, u, "scroll handler");
      }
    let { range: n } = e,
      r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1),
      i;
    if (!r) return;
    !n.empty &&
      (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) &&
      (r = {
        left: Math.min(r.left, i.left),
        top: Math.min(r.top, i.top),
        right: Math.max(r.right, i.right),
        bottom: Math.max(r.bottom, i.bottom),
      });
    let o = w7(this.view),
      s = { left: r.left - o.left, top: r.top - o.top, right: r.right + o.right, bottom: r.bottom + o.bottom },
      { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    yee(
      this.view.scrollDOM,
      s,
      n.head < n.anchor ? -1 : 1,
      e.x,
      e.y,
      Math.max(Math.min(e.xMargin, l), -l),
      Math.max(Math.min(e.yMargin, a), -a),
      this.view.textDirection == wt.LTR
    );
  }
}
function Vee(t) {
  return (
    t.node.nodeType == 1 &&
    t.node.firstChild &&
    (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") &&
    (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false")
  );
}
class X2 extends Wr {
  constructor(e) {
    super(), (this.height = e);
  }
  toDOM() {
    let e = document.createElement("div");
    return (e.className = "cm-gap"), this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return (e.style.height = this.height + "px"), !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function S7(t, e) {
  let n = t.observer.selectionRange;
  if (!n.focusNode) return null;
  let r = X9(n.focusNode, n.focusOffset),
    i = U9(n.focusNode, n.focusOffset),
    o = r || i;
  if (i && r && i.node != r.node) {
    let l = ft.get(i.node);
    if (!l || (l instanceof Qr && l.text != i.node.nodeValue)) o = i;
    else if (t.docView.lastCompositionAfterCursor) {
      let a = ft.get(r.node);
      !a || (a instanceof Qr && a.text != r.node.nodeValue) || (o = i);
    }
  }
  if (((t.docView.lastCompositionAfterCursor = o != r), !o)) return null;
  let s = e - o.offset;
  return { from: s, to: s + o.node.nodeValue.length, node: o.node };
}
function jee(t, e, n) {
  let r = S7(t, n);
  if (!r) return null;
  let { node: i, from: o, to: s } = r,
    l = i.nodeValue;
  if (/[\n\r]/.test(l) || t.state.doc.sliceString(r.from, r.to) != l) return null;
  let a = e.invertedDesc,
    c = new Or(a.mapPos(o), a.mapPos(s), o, s),
    u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let d = ft.get(h);
    if (d instanceof Gi) u.push({ node: h, deco: d.mark });
    else {
      if (d instanceof Bt || (h.nodeName == "DIV" && h.parentNode == t.contentDOM)) return { range: c, text: i, marks: u, line: h };
      if (h != t.contentDOM) u.push({ node: h, deco: new Ph({ inclusive: !0, attributes: Pee(h), tagName: h.tagName.toLowerCase() }) });
      else return null;
    }
  }
}
function Zee(t, e) {
  return t.nodeType != 1
    ? 0
    : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) |
        (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let zee = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    DO(e, n, this.changes);
  }
  comparePoint(e, n) {
    DO(e, n, this.changes);
  }
};
function Wee(t, e, n) {
  let r = new zee();
  return ze.compare(t, e, n, r), r.changes;
}
function Xee(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode) if (n.nodeType == 1 && n.contentEditable == "false") return !0;
  return !1;
}
function Uee(t, e) {
  let n = !1;
  return (
    e &&
      t.iterChangedRanges((r, i) => {
        r < e.to && i > e.from && (n = !0);
      }),
    n
  );
}
function Hee(t, e, n = 1) {
  let r = t.charCategorizer(e),
    i = t.doc.lineAt(e),
    o = e - i.from;
  if (i.length == 0) return H.cursor(e);
  o == 0 ? (n = 1) : o == i.length && (n = -1);
  let s = o,
    l = o;
  n < 0 ? (s = dn(i.text, o, !1)) : (l = dn(i.text, o));
  let a = r(i.text.slice(s, l));
  for (; s > 0; ) {
    let c = dn(i.text, s, !1);
    if (r(i.text.slice(c, s)) != a) break;
    s = c;
  }
  for (; l < i.length; ) {
    let c = dn(i.text, l);
    if (r(i.text.slice(l, c)) != a) break;
    l = c;
  }
  return H.range(s + i.from, l + i.from);
}
function qee(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function Yee(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function a1(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function U2(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function H2(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function ZO(t, e, n) {
  let r,
    i,
    o,
    s,
    l = !1,
    a,
    c,
    u,
    h;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let m = xu(p);
    for (let O = 0; O < m.length; O++) {
      let v = m[O];
      i && a1(i, v) && (v = U2(H2(v, i.bottom), i.top));
      let g = qee(e, v),
        b = Yee(n, v);
      if (g == 0 && b == 0) return p.nodeType == 3 ? q2(p, e, n) : ZO(p, e, n);
      if (!r || s > b || (s == b && o > g)) {
        (r = p), (i = v), (o = g), (s = b);
        let x = b ? (n < v.top ? -1 : 1) : g ? (e < v.left ? -1 : 1) : 0;
        l = !x || (x > 0 ? O < m.length - 1 : O > 0);
      }
      g == 0
        ? n > v.bottom && (!u || u.bottom < v.bottom)
          ? ((a = p), (u = v))
          : n < v.top && (!h || h.top > v.top) && ((c = p), (h = v))
        : u && a1(u, v)
        ? (u = H2(u, v.bottom))
        : h && a1(h, v) && (h = U2(h, v.top));
    }
  }
  if ((u && u.bottom >= n ? ((r = a), (i = u)) : h && h.top <= n && ((r = c), (i = h)), !r)) return { node: t, offset: 0 };
  let d = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3) return q2(r, d, n);
  if (l && r.contentEditable != "false") return ZO(r, d, n);
  let f = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: f };
}
function q2(t, e, n) {
  let r = t.nodeValue.length,
    i = -1,
    o = 1e9,
    s = 0;
  for (let l = 0; l < r; l++) {
    let a = Ls(t, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let u = a[c];
      if (u.top == u.bottom) continue;
      s || (s = e - u.left);
      let h = (u.top > n ? u.top - n : n - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < o) {
        let d = e >= (u.left + u.right) / 2,
          f = d;
        if (((be.chrome || be.gecko) && Ls(t, l).getBoundingClientRect().left == u.right && (f = !d), h <= 0))
          return { node: t, offset: l + (f ? 1 : 0) };
        (i = l + (f ? 1 : 0)), (o = h);
      }
    }
  }
  return { node: t, offset: i > -1 ? i : s > 0 ? t.nodeValue.length : 0 };
}
function k7(t, e, n, r = -1) {
  var i, o;
  let s = t.contentDOM.getBoundingClientRect(),
    l = s.top + t.viewState.paddingTop,
    a,
    { docHeight: c } = t.viewState,
    { x: u, y: h } = e,
    d = h - l;
  if (d < 0) return 0;
  if (d > c) return t.state.doc.length;
  for (let x = t.viewState.heightOracle.textHeight / 2, k = !1; (a = t.elementAtHeight(d)), a.type != Pn.Text; )
    for (; (d = r > 0 ? a.bottom + x : a.top - x), !(d >= 0 && d <= c); ) {
      if (k) return n ? null : 0;
      (k = !0), (r = -r);
    }
  h = l + d;
  let f = a.from;
  if (f < t.viewport.from) return t.viewport.from == 0 ? 0 : n ? null : Y2(t, s, a, u, h);
  if (f > t.viewport.to) return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : Y2(t, s, a, u, h);
  let p = t.dom.ownerDocument,
    m = t.root.elementFromPoint ? t.root : p,
    O = m.elementFromPoint(u, h);
  O && !t.contentDOM.contains(O) && (O = null),
    O ||
      ((u = Math.max(s.left + 1, Math.min(s.right - 1, u))), (O = m.elementFromPoint(u, h)), O && !t.contentDOM.contains(O) && (O = null));
  let v,
    g = -1;
  if (O && ((i = t.docView.nearest(O)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let x = p.caretPositionFromPoint(u, h);
      x && ({ offsetNode: v, offset: g } = x);
    } else if (p.caretRangeFromPoint) {
      let x = p.caretRangeFromPoint(u, h);
      x &&
        (({ startContainer: v, startOffset: g } = x),
        (!t.contentDOM.contains(v) || (be.safari && Gee(v, g, u)) || (be.chrome && Jee(v, g, u))) && (v = void 0));
    }
  }
  if (!v || !t.docView.dom.contains(v)) {
    let x = Bt.find(t.docView, f);
    if (!x) return d > a.top + a.height / 2 ? a.to : a.from;
    ({ node: v, offset: g } = ZO(x.dom, u, h));
  }
  let b = t.docView.nearest(v);
  if (!b) return null;
  if (b.isWidget && ((o = b.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let x = b.dom.getBoundingClientRect();
    return e.y < x.top || (e.y <= x.bottom && e.x <= (x.left + x.right) / 2) ? b.posAtStart : b.posAtEnd;
  } else return b.localPosFromDOM(v, g) + b.posAtStart;
}
function Y2(t, e, n, r, i) {
  let o = Math.round((r - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let l = t.viewState.heightOracle.textHeight,
      a = Math.floor((i - n.top - (t.defaultLineHeight - l) * 0.5) / l);
    o += a * t.viewState.heightOracle.lineLength;
  }
  let s = t.state.sliceDoc(n.from, n.to);
  return n.from + PO(s, o, t.state.tabSize);
}
function Gee(t, e, n) {
  let r;
  if (t.nodeType != 3 || e != (r = t.nodeValue.length)) return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling) if (i.nodeType != 1 || i.nodeName != "BR") return !1;
  return Ls(t, r - 1, r).getBoundingClientRect().left > n;
}
function Jee(t, e, n) {
  if (e != 0) return !1;
  for (let i = t; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i) return !1;
    if (o.classList.contains("cm-line")) break;
    i = o;
  }
  let r = t.nodeType == 1 ? t.getBoundingClientRect() : Ls(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function zO(t, e) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let r of n.type) if (r.to > e || (r.to == e && (r.to == n.to || r.type == Pn.Text))) return r;
  }
  return n;
}
function Kee(t, e, n, r) {
  let i = zO(t, e.head),
    o =
      !r || i.type != Pn.Text || !(t.lineWrapping || i.widgetLineBreaks)
        ? null
        : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (o) {
    let s = t.dom.getBoundingClientRect(),
      l = t.textDirectionAt(i.from),
      a = t.posAtCoords({ x: n == (l == wt.LTR) ? s.right - 1 : s.left + 1, y: (o.top + o.bottom) / 2 });
    if (a != null) return H.cursor(a, n ? -1 : 1);
  }
  return H.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function G2(t, e, n, r) {
  let i = t.state.doc.lineAt(e.head),
    o = t.bidiSpans(i),
    s = t.textDirectionAt(i.from);
  for (let l = e, a = null; ; ) {
    let c = Dee(i, o, s, l, n),
      u = l7;
    if (!c) {
      if (i.number == (n ? t.state.doc.lines : 1)) return l;
      (u = `
`),
        (i = t.state.doc.line(i.number + (n ? 1 : -1))),
        (o = t.bidiSpans(i)),
        (c = t.visualLineSide(i, !n));
    }
    if (a) {
      if (!a(u)) return l;
    } else {
      if (!r) return c;
      a = r(u);
    }
    l = c;
  }
}
function ete(t, e, n) {
  let r = t.state.charCategorizer(e),
    i = r(n);
  return (o) => {
    let s = r(o);
    return i == Et.Space && (i = s), i == s;
  };
}
function tte(t, e, n, r) {
  let i = e.head,
    o = n ? 1 : -1;
  if (i == (n ? t.state.doc.length : 0)) return H.cursor(i, e.assoc);
  let s = e.goalColumn,
    l,
    a = t.contentDOM.getBoundingClientRect(),
    c = t.coordsAtPos(i, e.assoc || -1),
    u = t.documentTop;
  if (c) s == null && (s = c.left - a.left), (l = o < 0 ? c.top : c.bottom);
  else {
    let f = t.viewState.lineBlockAt(i);
    s == null && (s = Math.min(a.right - a.left, t.defaultCharacterWidth * (i - f.from))), (l = (o < 0 ? f.top : f.bottom) + u);
  }
  let h = a.left + s,
    d = r ?? t.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let p = l + (d + f) * o,
      m = k7(t, { x: h, y: p }, !1, o);
    if (p < a.top || p > a.bottom || (o < 0 ? m < i : m > i)) {
      let O = t.docView.coordsForChar(m),
        v = !O || p < O.top ? -1 : 1;
      return H.cursor(m, v, void 0, s);
    }
  }
}
function nf(t, e, n) {
  for (;;) {
    let r = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (o, s, l) => {
        if (e > o && e < s) {
          let a = r || n || (e - o < s - e ? -1 : 1);
          (e = a < 0 ? o : s), (r = a);
        }
      });
    if (!r) return e;
  }
}
function c1(t, e, n) {
  let r = nf(
    t.state.facet(Ry).map((i) => i(t)),
    n.from,
    e.head > n.from ? -1 : 1
  );
  return r == n.from ? n : H.cursor(r, r < n.from ? 1 : -1);
}
class nte {
  setSelectionOrigin(e) {
    (this.lastSelectionOrigin = e), (this.lastSelectionTime = Date.now());
  }
  constructor(e) {
    (this.view = e),
      (this.lastKeyCode = 0),
      (this.lastKeyTime = 0),
      (this.lastTouchTime = 0),
      (this.lastFocusTime = 0),
      (this.lastScrollTop = 0),
      (this.lastScrollLeft = 0),
      (this.pendingIOSKey = void 0),
      (this.tabFocusMode = -1),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastContextMenu = 0),
      (this.scrollHandlers = []),
      (this.handlers = Object.create(null)),
      (this.composing = -1),
      (this.compositionFirstChange = null),
      (this.compositionEndedAt = 0),
      (this.compositionPendingKey = !1),
      (this.compositionPendingChange = !1),
      (this.mouseSelection = null),
      (this.draggedContent = null),
      (this.handleEvent = this.handleEvent.bind(this)),
      (this.notifiedFocused = e.hasFocus),
      be.safari && e.contentDOM.addEventListener("input", () => null),
      be.gecko && vte(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !ute(this.view, e) || this.ignoreDuringComposition(e) || (e.type == "keydown" && this.keydown(e)) || this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers) i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented) break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = rte(e),
      r = this.handlers,
      i = this.view.contentDOM;
    for (let o in n)
      if (o != "scroll") {
        let s = !n[o].handlers.length,
          l = r[o];
        l && s != !l.handlers.length && (i.removeEventListener(o, this.handleEvent), (l = null)),
          l || i.addEventListener(o, this.handleEvent, { passive: s });
      }
    for (let o in r) o != "scroll" && !n[o] && i.removeEventListener(o, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (
      ((this.lastKeyCode = e.keyCode),
      (this.lastKeyTime = Date.now()),
      e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
    )
      return !0;
    if (
      (this.tabFocusMode > 0 && e.keyCode != 27 && _7.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1),
      be.android && be.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
    )
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return be.ios &&
      !e.synthetic &&
      !e.altKey &&
      !e.metaKey &&
      (((n = C7.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey) || (ite.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey))
      ? ((this.pendingIOSKey = n || e), setTimeout(() => this.flushIOSKey(), 250), !0)
      : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || (n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()))
      ? !1
      : ((this.pendingIOSKey = void 0), Ql(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type)
      ? this.composing > 0
        ? !0
        : be.safari && !be.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100
        ? ((this.compositionPendingKey = !1), !0)
        : !1
      : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), (this.mouseSelection = e);
  }
  update(e) {
    this.view.observer.update(e),
      this.mouseSelection && this.mouseSelection.update(e),
      this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)),
      e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function J2(t, e) {
  return (n, r) => {
    try {
      return e.call(t, r, n);
    } catch (i) {
      jn(n.state, i);
    }
  };
}
function rte(t) {
  let e = Object.create(null);
  function n(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of t) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let o in i.domEventHandlers) {
        let s = i.domEventHandlers[o];
        s && n(o).handlers.push(J2(r.value, s));
      }
    if (i && i.domEventObservers)
      for (let o in i.domEventObservers) {
        let s = i.domEventObservers[o];
        s && n(o).observers.push(J2(r.value, s));
      }
  }
  for (let r in Dr) n(r).handlers.push(Dr[r]);
  for (let r in br) n(r).observers.push(br[r]);
  return e;
}
const C7 = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" },
  ],
  ite = "dthko",
  _7 = [16, 17, 18, 20, 91, 92, 224, 225],
  ud = 6;
function hd(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function ote(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class ste {
  constructor(e, n, r, i) {
    (this.view = e),
      (this.startEvent = n),
      (this.style = r),
      (this.mustSelect = i),
      (this.scrollSpeed = { x: 0, y: 0 }),
      (this.scrolling = -1),
      (this.lastEvent = n),
      (this.scrollParent = wee(e.contentDOM)),
      (this.atoms = e.state.facet(Ry).map((s) => s(e)));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", (this.move = this.move.bind(this))),
      o.addEventListener("mouseup", (this.up = this.up.bind(this))),
      (this.extend = n.shiftKey),
      (this.multiple = e.state.facet(Me.allowMultipleSelections) && lte(e, n)),
      (this.dragging = cte(e, n) && A7(n) == 1 ? null : !1);
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var n;
    if (e.buttons == 0) return this.destroy();
    if (this.dragging || (this.dragging == null && ote(this.startEvent, e) < 10)) return;
    this.select((this.lastEvent = e));
    let r = 0,
      i = 0,
      o = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || {
        left: 0,
        top: 0,
        right: this.view.win.innerWidth,
        bottom: this.view.win.innerHeight,
      },
      s = w7(this.view);
    e.clientX - s.left <= o.left + ud
      ? (r = -hd(o.left - e.clientX))
      : e.clientX + s.right >= o.right - ud && (r = hd(e.clientX - o.right)),
      e.clientY - s.top <= o.top + ud
        ? (i = -hd(o.top - e.clientY))
        : e.clientY + s.bottom >= o.bottom - ud && (i = hd(e.clientY - o.bottom)),
      this.setScrollSpeed(r, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move),
      e.removeEventListener("mouseup", this.up),
      (this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null);
  }
  setScrollSpeed(e, n) {
    (this.scrollSpeed = { x: e, y: n }),
      e || n
        ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50))
        : this.scrolling > -1 && (clearInterval(this.scrolling), (this.scrolling = -1));
  }
  scroll() {
    this.scrollParent
      ? ((this.scrollParent.scrollLeft += this.scrollSpeed.x), (this.scrollParent.scrollTop += this.scrollSpeed.y))
      : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
      this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r],
        o = null;
      if (i.empty) {
        let s = nf(this.atoms, i.from, 0);
        s != i.from && (o = H.cursor(s, -1));
      } else {
        let s = nf(this.atoms, i.from, -1),
          l = nf(this.atoms, i.to, 1);
        (s != i.from || l != i.to) && (o = H.range(i.from == i.anchor ? s : l, i.from == i.head ? s : l));
      }
      o && (n || (n = e.ranges.slice()), (n[r] = o));
    }
    return n ? H.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this,
      r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) &&
      this.view.dispatch({ selection: r, userEvent: "select.pointer" }),
      (this.mustSelect = !1);
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type"))
      ? this.destroy()
      : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function lte(t, e) {
  let n = t.state.facet(a7);
  return n.length ? n[0](e) : be.mac ? e.metaKey : e.ctrlKey;
}
function ate(t, e) {
  let n = t.state.facet(c7);
  return n.length ? n[0](e) : be.mac ? !e.altKey : !e.ctrlKey;
}
function cte(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty) return !1;
  let r = bu(t.root);
  if (!r || r.rangeCount == 0) return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let s = i[o];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY) return !0;
  }
  return !1;
}
function ute(t, e) {
  if (!e.bubbles) return !0;
  if (e.defaultPrevented) return !1;
  for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || ((r = ft.get(n)) && r.ignoreEvent(e))) return !1;
  return !0;
}
const Dr = Object.create(null),
  br = Object.create(null),
  E7 = (be.ie && be.ie_version < 15) || (be.ios && be.webkit_version < 604);
function hte(t) {
  let e = t.dom.parentNode;
  if (!e) return;
  let n = e.appendChild(document.createElement("textarea"));
  (n.style.cssText = "position: fixed; left: -10000px; top: 10px"),
    n.focus(),
    setTimeout(() => {
      t.focus(), n.remove(), T7(t, n.value);
    }, 50);
}
function T7(t, e) {
  let { state: n } = t,
    r,
    i = 1,
    o = n.toText(e),
    s = o.lines == n.selection.ranges.length;
  if (WO != null && n.selection.ranges.every((a) => a.empty) && WO == o.toString()) {
    let a = -1;
    r = n.changeByRange((c) => {
      let u = n.doc.lineAt(c.from);
      if (u.from == a) return { range: c };
      a = u.from;
      let h = n.toText((s ? o.line(i++).text : e) + n.lineBreak);
      return { changes: { from: u.from, insert: h }, range: H.cursor(c.from + h.length) };
    });
  } else
    s
      ? (r = n.changeByRange((a) => {
          let c = o.line(i++);
          return { changes: { from: a.from, to: a.to, insert: c.text }, range: H.cursor(a.from + c.length) };
        }))
      : (r = n.replaceSelection(o));
  t.dispatch(r, { userEvent: "input.paste", scrollIntoView: !0 });
}
br.scroll = (t) => {
  (t.inputState.lastScrollTop = t.scrollDOM.scrollTop), (t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft);
};
Dr.keydown = (t, e) => (
  t.inputState.setSelectionOrigin("select"),
  e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3),
  !1
);
br.touchstart = (t, e) => {
  (t.inputState.lastTouchTime = Date.now()), t.inputState.setSelectionOrigin("select.pointer");
};
br.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Dr.mousedown = (t, e) => {
  if ((t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)) return !1;
  let n = null;
  for (let r of t.state.facet(u7)) if (((n = r(t, e)), n)) break;
  if ((!n && e.button == 0 && (n = pte(t, e)), n)) {
    let r = !t.hasFocus;
    t.inputState.startMouseSelection(new ste(t, e, n, r)),
      r &&
        t.observer.ignore(() => {
          Z9(t.contentDOM);
          let o = t.root.activeElement;
          o && !o.contains(t.contentDOM) && o.blur();
        });
    let i = t.inputState.mouseSelection;
    if (i) return i.start(e), i.dragging === !1;
  }
  return !1;
};
function K2(t, e, n, r) {
  if (r == 1) return H.cursor(e, n);
  if (r == 2) return Hee(t.state, e, n);
  {
    let i = Bt.find(t.docView, e),
      o = t.state.doc.lineAt(i ? i.posAtEnd : e),
      s = i ? i.posAtStart : o.from,
      l = i ? i.posAtEnd : o.to;
    return l < t.state.doc.length && l == o.to && l++, H.range(s, l);
  }
}
let P7 = (t, e) => t >= e.top && t <= e.bottom,
  e5 = (t, e, n) => P7(e, n) && t >= n.left && t <= n.right;
function dte(t, e, n, r) {
  let i = Bt.find(t.docView, e);
  if (!i) return 1;
  let o = e - i.posAtStart;
  if (o == 0) return 1;
  if (o == i.length) return -1;
  let s = i.coordsAt(o, -1);
  if (s && e5(n, r, s)) return -1;
  let l = i.coordsAt(o, 1);
  return l && e5(n, r, l) ? 1 : s && P7(r, s) ? -1 : 1;
}
function t5(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: dte(t, n, e.clientX, e.clientY) };
}
const fte = be.ie && be.ie_version <= 11;
let n5 = null,
  r5 = 0,
  i5 = 0;
function A7(t) {
  if (!fte) return t.detail;
  let e = n5,
    n = i5;
  return (
    (n5 = t),
    (i5 = Date.now()),
    (r5 = !e || (n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2) ? (r5 + 1) % 3 : 1)
  );
}
function pte(t, e) {
  let n = t5(t, e),
    r = A7(e),
    i = t.state.selection;
  return {
    update(o) {
      o.docChanged && ((n.pos = o.changes.mapPos(n.pos)), (i = i.map(o.changes)));
    },
    get(o, s, l) {
      let a = t5(t, o),
        c,
        u = K2(t, a.pos, a.bias, r);
      if (n.pos != a.pos && !s) {
        let h = K2(t, n.pos, n.bias, r),
          d = Math.min(h.from, u.from),
          f = Math.max(h.to, u.to);
        u = d < u.from ? H.range(d, f) : H.range(f, d);
      }
      return s
        ? i.replaceRange(i.main.extend(u.from, u.to))
        : l && r == 1 && i.ranges.length > 1 && (c = mte(i, a.pos))
        ? c
        : l
        ? i.addRange(u)
        : H.create([u]);
    },
  };
}
function mte(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: r, to: i } = t.ranges[n];
    if (r <= e && i >= e)
      return H.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
Dr.dragstart = (t, e) => {
  let {
    selection: { main: n },
  } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let o = i.posAtStart,
        s = o + i.length;
      (o >= n.to || s <= n.from) && (n = H.range(o, s));
    }
  }
  let { inputState: r } = t;
  return (
    r.mouseSelection && (r.mouseSelection.dragging = !0),
    (r.draggedContent = n),
    e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(n.from, n.to)), (e.dataTransfer.effectAllowed = "copyMove")),
    !1
  );
};
Dr.dragend = (t) => ((t.inputState.draggedContent = null), !1);
function o5(t, e, n, r) {
  if (!n) return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    { draggedContent: o } = t.inputState,
    s = r && o && ate(t, e) ? { from: o.from, to: o.to } : null,
    l = { from: i, insert: n },
    a = t.state.changes(s ? [s, l] : l);
  t.focus(),
    t.dispatch({ changes: a, selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) }, userEvent: s ? "move.drop" : "input.drop" }),
    (t.inputState.draggedContent = null);
}
Dr.drop = (t, e) => {
  if (!e.dataTransfer) return !1;
  if (t.state.readOnly) return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length),
      i = 0,
      o = () => {
        ++i == n.length && o5(t, e, r.filter((s) => s != null).join(t.state.lineBreak), !1);
      };
    for (let s = 0; s < n.length; s++) {
      let l = new FileReader();
      (l.onerror = o),
        (l.onload = () => {
          /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (r[s] = l.result), o();
        }),
        l.readAsText(n[s]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r) return o5(t, e, r, !0), !0;
  }
  return !1;
};
Dr.paste = (t, e) => {
  if (t.state.readOnly) return !0;
  t.observer.flush();
  let n = E7 ? null : e.clipboardData;
  return n ? (T7(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (hte(t), !1);
};
function gte(t, e) {
  let n = t.dom.parentNode;
  if (!n) return;
  let r = n.appendChild(document.createElement("textarea"));
  (r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
    (r.value = e),
    r.focus(),
    (r.selectionEnd = e.length),
    (r.selectionStart = 0),
    setTimeout(() => {
      r.remove(), t.focus();
    }, 50);
}
function Ote(t) {
  let e = [],
    n = [],
    r = !1;
  for (let i of t.selection.ranges) i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: o } of t.selection.ranges) {
      let s = t.doc.lineAt(o);
      s.number > i && (e.push(s.text), n.push({ from: s.from, to: Math.min(t.doc.length, s.to + 1) })), (i = s.number);
    }
    r = !0;
  }
  return { text: e.join(t.lineBreak), ranges: n, linewise: r };
}
let WO = null;
Dr.copy = Dr.cut = (t, e) => {
  let { text: n, ranges: r, linewise: i } = Ote(t.state);
  if (!n && !i) return !1;
  (WO = i ? n : null), e.type == "cut" && !t.state.readOnly && t.dispatch({ changes: r, scrollIntoView: !0, userEvent: "delete.cut" });
  let o = E7 ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", n), !0) : (gte(t, n), !1);
};
const $7 = Lr.define();
function R7(t, e) {
  let n = [];
  for (let r of t.facet(f7)) {
    let i = r(t, e);
    i && n.push(i);
  }
  return n ? t.update({ effects: n, annotations: $7.of(!0) }) : null;
}
function I7(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = R7(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
br.focus = (t) => {
  (t.inputState.lastFocusTime = Date.now()),
    !t.scrollDOM.scrollTop &&
      (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) &&
      ((t.scrollDOM.scrollTop = t.inputState.lastScrollTop), (t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft)),
    I7(t);
};
br.blur = (t) => {
  t.observer.clearSelectionRange(), I7(t);
};
br.compositionstart = br.compositionupdate = (t) => {
  t.observer.editContext ||
    (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0),
    t.inputState.composing < 0 && (t.inputState.composing = 0));
};
br.compositionend = (t) => {
  t.observer.editContext ||
    ((t.inputState.composing = -1),
    (t.inputState.compositionEndedAt = Date.now()),
    (t.inputState.compositionPendingKey = !0),
    (t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0),
    (t.inputState.compositionFirstChange = null),
    be.chrome && be.android
      ? t.observer.flushSoon()
      : t.inputState.compositionPendingChange
      ? Promise.resolve().then(() => t.observer.flush())
      : setTimeout(() => {
          t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
        }, 50));
};
br.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Dr.beforeinput = (t, e) => {
  var n;
  let r;
  if (
    be.chrome &&
    be.android &&
    (r = C7.find((i) => i.inputType == e.inputType)) &&
    (t.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")
  ) {
    let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > i + 10 &&
        t.hasFocus &&
        (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return (
    be.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(),
    be.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => br.compositionend(t, e), 20),
    !1
  );
};
const s5 = new Set();
function vte(t) {
  s5.has(t) || (s5.add(t), t.addEventListener("copy", () => {}), t.addEventListener("cut", () => {}));
}
const l5 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class bte {
  constructor(e) {
    (this.lineWrapping = e),
      (this.doc = et.empty),
      (this.heightSamples = {}),
      (this.lineHeight = 14),
      (this.charWidth = 7),
      (this.textHeight = 14),
      (this.lineLength = 30),
      (this.heightChanged = !1);
  }
  heightForGap(e, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping
      ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight
      : this.lineHeight;
  }
  setDoc(e) {
    return (this.doc = e), this;
  }
  mustRefreshForWrapping(e) {
    return l5.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || ((n = !0), (this.heightSamples[Math.floor(i * 10)] = !0));
    }
    return n;
  }
  refresh(e, n, r, i, o, s) {
    let l = l5.indexOf(e) > -1,
      a = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (((this.lineWrapping = l), (this.lineHeight = n), (this.charWidth = r), (this.textHeight = i), (this.lineLength = o), a)) {
      this.heightSamples = {};
      for (let c = 0; c < s.length; c++) {
        let u = s[c];
        u < 0 ? c++ : (this.heightSamples[Math.floor(u * 10)] = !0);
      }
    }
    return a;
  }
}
class xte {
  constructor(e, n) {
    (this.from = e), (this.heights = n), (this.index = 0);
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class ii {
  constructor(e, n, r, i, o) {
    (this.from = e), (this.length = n), (this.top = r), (this.height = i), (this._content = o);
  }
  get type() {
    return typeof this._content == "number" ? Pn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof jo ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new ii(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var xt = (function (t) {
  return (t[(t.ByPos = 0)] = "ByPos"), (t[(t.ByHeight = 1)] = "ByHeight"), (t[(t.ByPosNoHeight = 2)] = "ByPosNoHeight"), t;
})(xt || (xt = {}));
const rf = 0.001;
class An {
  constructor(e, n, r = 2) {
    (this.length = e), (this.height = n), (this.flags = r);
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | (this.flags & -3);
  }
  setHeight(e, n) {
    this.height != n && (Math.abs(this.height - n) > rf && (e.heightChanged = !0), (this.height = n));
  }
  replace(e, n, r) {
    return An.of(r);
  }
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, r, i) {
    let o = this,
      s = r.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: u, toB: h } = i[l],
        d = o.lineAt(a, xt.ByPosNoHeight, r.setDoc(n), 0, 0),
        f = d.to >= c ? d : o.lineAt(c, xt.ByPosNoHeight, r, 0, 0);
      for (h += f.to - c, c = f.to; l > 0 && d.from <= i[l - 1].toA; )
        (a = i[l - 1].fromA), (u = i[l - 1].fromB), l--, a < d.from && (d = o.lineAt(a, xt.ByPosNoHeight, r, 0, 0));
      (u += d.from - a), (a = d.from);
      let p = Iy.build(r.setDoc(s), e, u, h);
      o = o.replace(a, c, p);
    }
    return o.updateHeight(r, 0);
  }
  static empty() {
    return new Jn(0, 0);
  }
  static of(e) {
    if (e.length == 1) return e[0];
    let n = 0,
      r = e.length,
      i = 0,
      o = 0;
    for (;;)
      if (n == r)
        if (i > o * 2) {
          let l = e[n - 1];
          l.break ? e.splice(--n, 1, l.left, null, l.right) : e.splice(--n, 1, l.left, l.right), (r += 1 + l.break), (i -= l.size);
        } else if (o > i * 2) {
          let l = e[r];
          l.break ? e.splice(r, 1, l.left, null, l.right) : e.splice(r, 1, l.left, l.right), (r += 2 + l.break), (o -= l.size);
        } else break;
      else if (i < o) {
        let l = e[n++];
        l && (i += l.size);
      } else {
        let l = e[--r];
        l && (o += l.size);
      }
    let s = 0;
    return e[n - 1] == null ? ((s = 1), n--) : e[n] == null && ((s = 1), r++), new yte(An.of(e.slice(0, n)), s, An.of(e.slice(r)));
  }
}
An.prototype.size = 1;
class M7 extends An {
  constructor(e, n, r) {
    super(e, n), (this.deco = r);
  }
  blockAt(e, n, r, i) {
    return new ii(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, n, r, i, o) {
    return this.blockAt(0, r, i, o);
  }
  forEachLine(e, n, r, i, o, s) {
    e <= o + this.length && n >= o && s(this.blockAt(0, r, i, o));
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(e, i.heights[i.index++]), (this.outdated = !1), this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Jn extends M7 {
  constructor(e, n) {
    super(e, n, null), (this.collapsed = 0), (this.widgetHeight = 0), (this.breaks = 0);
  }
  blockAt(e, n, r, i) {
    return new ii(i, this.length, r, this.height, this.breaks);
  }
  replace(e, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof Jn || (i instanceof sn && i.flags & 4)) && Math.abs(this.length - i.length) < 10
      ? (i instanceof sn ? (i = new Jn(i.length, this.height)) : (i.height = this.height), this.outdated || (i.outdated = !1), i)
      : An.of(r);
  }
  updateHeight(e, n = 0, r = !1, i) {
    return (
      i && i.from <= n && i.more
        ? this.setHeight(e, i.heights[i.index++])
        : (r || this.outdated) &&
          this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight),
      (this.outdated = !1),
      this
    );
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class sn extends An {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let r = e.doc.lineAt(n).number,
      i = e.doc.lineAt(n + this.length).number,
      o = i - r + 1,
      s,
      l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * o);
      (s = a / o), this.length > o + 1 && (l = (this.height - a) / (this.length - o - 1));
    } else s = this.height / o;
    return { firstLine: r, lastLine: i, perLine: s, perChar: l };
  }
  blockAt(e, n, r, i) {
    let { firstLine: o, lastLine: s, perLine: l, perChar: a } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let c = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)),
        u = n.doc.lineAt(c),
        h = l + u.length * a,
        d = Math.max(r, e - h / 2);
      return new ii(u.from, u.length, d, h, 0);
    } else {
      let c = Math.max(0, Math.min(s - o, Math.floor((e - r) / l))),
        { from: u, length: h } = n.doc.line(o + c);
      return new ii(u, h, r + l * c, l, 0);
    }
  }
  lineAt(e, n, r, i, o) {
    if (n == xt.ByHeight) return this.blockAt(e, r, i, o);
    if (n == xt.ByPosNoHeight) {
      let { from: f, to: p } = r.doc.lineAt(e);
      return new ii(f, p - f, 0, 0, 0);
    }
    let { firstLine: s, perLine: l, perChar: a } = this.heightMetrics(r, o),
      c = r.doc.lineAt(e),
      u = l + c.length * a,
      h = c.number - s,
      d = i + l * h + a * (c.from - o - h);
    return new ii(c.from, c.length, Math.max(i, Math.min(d, i + this.height - u)), u, 0);
  }
  forEachLine(e, n, r, i, o, s) {
    (e = Math.max(e, o)), (n = Math.min(n, o + this.length));
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(r, o);
    for (let u = e, h = i; u <= n; ) {
      let d = r.doc.lineAt(u);
      if (u == e) {
        let p = d.number - l;
        h += a * p + c * (e - o - p);
      }
      let f = a + c * d.length;
      s(new ii(d.from, d.length, h, f, 0)), (h += f), (u = d.to + 1);
    }
  }
  replace(e, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let o = r[r.length - 1];
      o instanceof sn ? (r[r.length - 1] = new sn(o.length + i)) : r.push(null, new sn(i - 1));
    }
    if (e > 0) {
      let o = r[0];
      o instanceof sn ? (r[0] = new sn(e + o.length)) : r.unshift(new sn(e - 1), null);
    }
    return An.of(r);
  }
  decomposeLeft(e, n) {
    n.push(new sn(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new sn(this.length - e - 1));
  }
  updateHeight(e, n = 0, r = !1, i) {
    let o = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let s = [],
        l = Math.max(n, i.from),
        a = -1;
      for (i.from > n && s.push(new sn(i.from - n - 1).updateHeight(e, n)); l <= o && i.more; ) {
        let u = e.doc.lineAt(l).length;
        s.length && s.push(null);
        let h = i.heights[i.index++];
        a == -1 ? (a = h) : Math.abs(h - a) >= rf && (a = -2);
        let d = new Jn(u, h);
        (d.outdated = !1), s.push(d), (l += u + 1);
      }
      l <= o && s.push(null, new sn(o - l).updateHeight(e, l));
      let c = An.of(s);
      return (
        (a < 0 || Math.abs(c.height - this.height) >= rf || Math.abs(a - this.heightMetrics(e, n).perLine) >= rf) && (e.heightChanged = !0),
        c
      );
    } else (r || this.outdated) && (this.setHeight(e, e.heightForGap(n, n + this.length)), (this.outdated = !1));
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class yte extends An {
  constructor(e, n, r) {
    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)),
      (this.left = e),
      (this.right = r),
      (this.size = e.size + r.size);
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, r, i) {
    let o = r + this.left.height;
    return e < o ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, o, i + this.left.length + this.break);
  }
  lineAt(e, n, r, i, o) {
    let s = i + this.left.height,
      l = o + this.left.length + this.break,
      a = n == xt.ByHeight ? e < s : e < l,
      c = a ? this.left.lineAt(e, n, r, i, o) : this.right.lineAt(e, n, r, s, l);
    if (this.break || (a ? c.to < l : c.from > l)) return c;
    let u = n == xt.ByPosNoHeight ? xt.ByPosNoHeight : xt.ByPos;
    return a ? c.join(this.right.lineAt(l, u, r, s, l)) : this.left.lineAt(l, u, r, i, o).join(c);
  }
  forEachLine(e, n, r, i, o, s) {
    let l = i + this.left.height,
      a = o + this.left.length + this.break;
    if (this.break) e < a && this.left.forEachLine(e, n, r, i, o, s), n >= a && this.right.forEachLine(e, n, r, l, a, s);
    else {
      let c = this.lineAt(a, xt.ByPos, r, i, o);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, o, s),
        c.to >= e && c.from <= n && s(c),
        n > c.to && this.right.forEachLine(c.to + 1, n, r, l, a, s);
    }
  }
  replace(e, n, r) {
    let i = this.left.length + this.break;
    if (n < i) return this.balanced(this.left.replace(e, n, r), this.right);
    if (e > this.left.length) return this.balanced(this.left, this.right.replace(e - i, n - i, r));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let s = o.length;
    for (let l of r) o.push(l);
    if ((e > 0 && a5(o, s - 1), n < this.length)) {
      let l = o.length;
      this.decomposeRight(n, o), a5(o, l);
    }
    return An.of(o);
  }
  decomposeLeft(e, n) {
    let r = this.left.length;
    if (e <= r) return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
  }
  decomposeRight(e, n) {
    let r = this.left.length,
      i = r + this.break;
    if (e >= i) return this.right.decomposeRight(e - i, n);
    e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size
      ? An.of(this.break ? [e, null, n] : [e, n])
      : ((this.left = e),
        (this.right = n),
        (this.height = e.height + n.height),
        (this.outdated = e.outdated || n.outdated),
        (this.size = e.size + n.size),
        (this.length = e.length + this.break + n.length),
        this);
  }
  updateHeight(e, n = 0, r = !1, i) {
    let { left: o, right: s } = this,
      l = n + o.length + this.break,
      a = null;
    return (
      i && i.from <= n + o.length && i.more ? (a = o = o.updateHeight(e, n, r, i)) : o.updateHeight(e, n, r),
      i && i.from <= l + s.length && i.more ? (a = s = s.updateHeight(e, l, r, i)) : s.updateHeight(e, l, r),
      a ? this.balanced(o, s) : ((this.height = this.left.height + this.right.height), (this.outdated = !1), this)
    );
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function a5(t, e) {
  let n, r;
  t[e] == null && (n = t[e - 1]) instanceof sn && (r = t[e + 1]) instanceof sn && t.splice(e - 1, 3, new sn(n.length + 1 + r.length));
}
const wte = 5;
class Iy {
  constructor(e, n) {
    (this.pos = e),
      (this.oracle = n),
      (this.nodes = []),
      (this.lineStart = -1),
      (this.lineEnd = -1),
      (this.covering = null),
      (this.writtenTo = e);
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd),
        i = this.nodes[this.nodes.length - 1];
      i instanceof Jn ? (i.length += r - this.pos) : (r > this.pos || !this.isCovered) && this.nodes.push(new Jn(r - this.pos, -1)),
        (this.writtenTo = r),
        n > r && (this.nodes.push(null), this.writtenTo++, (this.lineStart = -1));
    }
    this.pos = n;
  }
  point(e, n, r) {
    if (e < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0,
        o = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let s = n - e;
      r.block ? this.addBlock(new M7(s, i, r)) : (s || o || i >= wte) && this.addLineDeco(i, o, s);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    (this.lineStart = e),
      (this.lineEnd = n),
      this.writtenTo < e &&
        ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
        this.nodes.push(null)),
      this.pos > e && this.nodes.push(new Jn(this.pos - e, -1)),
      (this.writtenTo = this.pos);
  }
  blankContent(e, n) {
    let r = new sn(n - e);
    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Jn) return e;
    let n = new Jn(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(),
      this.nodes.push(e),
      (this.writtenTo = this.pos = this.pos + e.length),
      n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, r) {
    let i = this.ensureLine();
    (i.length += r),
      (i.collapsed += r),
      (i.widgetHeight = Math.max(i.widgetHeight, e)),
      (i.breaks += n),
      (this.writtenTo = this.pos = this.pos + r);
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Jn) && !this.isCovered
      ? this.nodes.push(new Jn(0, -1))
      : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes) i instanceof Jn && i.updateHeight(this.oracle, r), (r += i ? i.length : 1);
    return this.nodes;
  }
  static build(e, n, r, i) {
    let o = new Iy(r, e);
    return ze.spans(n, r, i, o, 0), o.finish(r);
  }
}
function Ste(t, e, n) {
  let r = new kte();
  return ze.compare(t, e, n, r, 0), r.changes;
}
class kte {
  constructor() {
    this.changes = [];
  }
  compareRange() {}
  comparePoint(e, n, r, i) {
    (e < n || (r && r.heightRelevant) || (i && i.heightRelevant)) && DO(e, n, this.changes, 5);
  }
}
function Cte(t, e) {
  let n = t.getBoundingClientRect(),
    r = t.ownerDocument,
    i = r.defaultView || window,
    o = Math.max(0, n.left),
    s = Math.min(i.innerWidth, n.right),
    l = Math.max(0, n.top),
    a = Math.min(i.innerHeight, n.bottom);
  for (let c = t.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c,
        h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let d = u.getBoundingClientRect();
        (o = Math.max(o, d.left)),
          (s = Math.min(s, d.right)),
          (l = Math.max(l, d.top)),
          (a = c == t.parentNode ? d.bottom : Math.min(a, d.bottom));
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11) c = c.host;
    else break;
  return { left: o - n.left, right: Math.max(o, s) - n.left, top: l - (n.top + e), bottom: Math.max(l, a) - (n.top + e) };
}
function _te(t, e) {
  let n = t.getBoundingClientRect();
  return { left: 0, right: n.right - n.left, top: e, bottom: n.bottom - (n.top + e) };
}
class u1 {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.size = r);
  }
  static same(e, n) {
    if (e.length != n.length) return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r],
        o = n[r];
      if (i.from != o.from || i.to != o.to || i.size != o.size) return !1;
    }
    return !0;
  }
  draw(e, n) {
    return me.replace({ widget: new Ete(this.size * (n ? e.scaleY : e.scaleX), n) }).range(this.from, this.to);
  }
}
class Ete extends Wr {
  constructor(e, n) {
    super(), (this.size = e), (this.vertical = n);
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return (
      this.vertical
        ? (e.style.height = this.size + "px")
        : ((e.style.width = this.size + "px"), (e.style.height = "2px"), (e.style.display = "inline-block")),
      e
    );
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class c5 {
  constructor(e) {
    (this.state = e),
      (this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }),
      (this.inView = !0),
      (this.paddingTop = 0),
      (this.paddingBottom = 0),
      (this.contentDOMWidth = 0),
      (this.contentDOMHeight = 0),
      (this.editorHeight = 0),
      (this.editorWidth = 0),
      (this.scrollTop = 0),
      (this.scrolledToBottom = !1),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.scrollAnchorPos = 0),
      (this.scrollAnchorHeight = -1),
      (this.scaler = u5),
      (this.scrollTarget = null),
      (this.printing = !1),
      (this.mustMeasureContent = !0),
      (this.defaultTextDirection = wt.LTR),
      (this.visibleRanges = []),
      (this.mustEnforceCursorAssoc = !1);
    let n = e.facet($y).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    (this.heightOracle = new bte(n)),
      (this.stateDeco = e.facet(yu).filter((r) => typeof r != "function")),
      (this.heightMap = An.empty().applyChanges(this.stateDeco, et.empty, this.heightOracle.setDoc(e.doc), [
        new Or(0, 0, 0, e.doc.length),
      ]));
    for (let r = 0; r < 2 && ((this.viewport = this.getViewport(0, null)), !!this.updateForViewport()); r++);
    this.updateViewportLines(),
      (this.lineGaps = this.ensureLineGaps([])),
      (this.lineGapDeco = me.set(this.lineGaps.map((r) => r.draw(this, !1)))),
      this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport],
      { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
        let { from: o, to: s } = this.lineBlockAt(i);
        e.push(new dd(o, s));
      }
    }
    return (this.viewports = e.sort((r, i) => r.from - i.from)), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return (
      (this.scaler = this.heightMap.height <= 7e6 ? u5 : new My(this.heightOracle, this.heightMap, this.viewports)),
      e.eq(this.scaler) ? 0 : 2
    );
  }
  updateViewportLines() {
    (this.viewportLines = []),
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
        this.viewportLines.push(Sc(e, this.scaler));
      });
  }
  update(e, n = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(yu).filter((u) => typeof u != "function");
    let i = e.changedRanges,
      o = Or.extendWithRanges(i, Ste(r, this.stateDeco, e ? e.changes : jt.empty(this.state.doc.length))),
      s = this.heightMap.height,
      l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    (this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o)),
      this.heightMap.height != s && (e.flags |= 2),
      l
        ? ((this.scrollAnchorPos = e.changes.mapPos(l.from, -1)), (this.scrollAnchorHeight = l.top))
        : ((this.scrollAnchorPos = -1), (this.scrollAnchorHeight = this.heightMap.height));
    let a = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    ((n && (n.range.head < a.from || n.range.head > a.to)) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, n));
    let c = a.from != this.viewport.from || a.to != this.viewport.to;
    (this.viewport = a),
      (e.flags |= this.updateForViewport()),
      (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))),
      (e.flags |= this.computeVisibleRanges()),
      n && (this.scrollTarget = n),
      !this.mustEnforceCursorAssoc &&
        e.selectionSet &&
        e.view.lineWrapping &&
        e.state.selection.main.empty &&
        e.state.selection.main.assoc &&
        !e.state.facet(m7) &&
        (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM,
      r = window.getComputedStyle(n),
      i = this.heightOracle,
      o = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? wt.RTL : wt.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(o),
      l = n.getBoundingClientRect(),
      a = s || this.mustMeasureContent || this.contentDOMHeight != l.height;
    (this.contentDOMHeight = l.height), (this.mustMeasureContent = !1);
    let c = 0,
      u = 0;
    if (l.width && l.height) {
      let { scaleX: x, scaleY: k } = j9(n, l);
      ((x > 0.005 && Math.abs(this.scaleX - x) > 0.005) || (k > 0.005 && Math.abs(this.scaleY - k) > 0.005)) &&
        ((this.scaleX = x), (this.scaleY = k), (c |= 8), (s = a = !0));
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY,
      d = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != d) && ((this.paddingTop = h), (this.paddingBottom = d), (c |= 10)),
      this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (a = !0), (this.editorWidth = e.scrollDOM.clientWidth), (c |= 8));
    let f = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f && ((this.scrollAnchorHeight = -1), (this.scrollTop = f)), (this.scrolledToBottom = W9(e.scrollDOM));
    let p = (this.printing ? _te : Cte)(n, this.paddingTop),
      m = p.top - this.pixelViewport.top,
      O = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if ((v != this.inView && ((this.inView = v), v && (a = !0)), !this.inView && !this.scrollTarget)) return 0;
    let g = l.width;
    if (
      ((this.contentDOMWidth != g || this.editorHeight != e.scrollDOM.clientHeight) &&
        ((this.contentDOMWidth = l.width), (this.editorHeight = e.scrollDOM.clientHeight), (c |= 8)),
      a)
    ) {
      let x = e.docView.measureVisibleLineHeights(this.viewport);
      if ((i.mustRefreshForHeights(x) && (s = !0), s || (i.lineWrapping && Math.abs(g - this.contentDOMWidth) > i.charWidth))) {
        let { lineHeight: k, charWidth: w, textHeight: y } = e.docView.measureTextSize();
        (s = k > 0 && i.refresh(o, k, w, y, g / w, x)), s && ((e.docView.minWidth = 0), (c |= 8));
      }
      m > 0 && O > 0 ? (u = Math.max(m, O)) : m < 0 && O < 0 && (u = Math.min(m, O)), (i.heightChanged = !1);
      for (let k of this.viewports) {
        let w = k.from == this.viewport.from ? x : e.docView.measureVisibleLineHeights(k);
        this.heightMap = (
          s ? An.empty().applyChanges(this.stateDeco, et.empty, this.heightOracle, [new Or(0, 0, 0, e.state.doc.length)]) : this.heightMap
        ).updateHeight(i, 0, s, new xte(k.from, w));
      }
      i.heightChanged && (c |= 2);
    }
    let b =
      !this.viewportIsAppropriate(this.viewport, u) ||
      (this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to));
    return (
      b && (c & 2 && (c |= this.updateScaler()), (this.viewport = this.getViewport(u, this.scrollTarget)), (c |= this.updateForViewport())),
      (c & 2 || b) && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)),
      (c |= this.computeVisibleRanges()),
      this.mustEnforceCursorAssoc && ((this.mustEnforceCursorAssoc = !1), e.docView.enforceCursorAssoc()),
      c
    );
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)),
      i = this.heightMap,
      o = this.heightOracle,
      { visibleTop: s, visibleBottom: l } = this,
      a = new dd(i.lineAt(s - r * 1e3, xt.ByHeight, o, 0, 0).from, i.lineAt(l + (1 - r) * 1e3, xt.ByHeight, o, 0, 0).to);
    if (n) {
      let { head: c } = n.range;
      if (c < a.from || c > a.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top),
          h = i.lineAt(c, xt.ByPos, o, 0, 0),
          d;
        n.y == "center"
          ? (d = (h.top + h.bottom) / 2 - u / 2)
          : n.y == "start" || (n.y == "nearest" && c < a.from)
          ? (d = h.top)
          : (d = h.bottom - u),
          (a = new dd(i.lineAt(d - 1e3 / 2, xt.ByHeight, o, 0, 0).from, i.lineAt(d + u + 1e3 / 2, xt.ByHeight, o, 0, 0).to));
      }
    }
    return a;
  }
  mapViewport(e, n) {
    let r = n.mapPos(e.from, -1),
      i = n.mapPos(e.to, 1);
    return new dd(
      this.heightMap.lineAt(r, xt.ByPos, this.heightOracle, 0, 0).from,
      this.heightMap.lineAt(i, xt.ByPos, this.heightOracle, 0, 0).to
    );
  }
  viewportIsAppropriate({ from: e, to: n }, r = 0) {
    if (!this.inView) return !0;
    let { top: i } = this.heightMap.lineAt(e, xt.ByPos, this.heightOracle, 0, 0),
      { bottom: o } = this.heightMap.lineAt(n, xt.ByPos, this.heightOracle, 0, 0),
      { visibleTop: s, visibleBottom: l } = this;
    return (
      (e == 0 || i <= s - Math.max(10, Math.min(-r, 250))) &&
      (n == this.state.doc.length || o >= l + Math.max(10, Math.min(r, 250))) &&
      i > s - 2 * 1e3 &&
      o < l + 2 * 1e3
    );
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty) return e;
    let r = [];
    for (let i of e) n.touchesRange(i.from, i.to) || r.push(new u1(n.mapPos(i.from), n.mapPos(i.to), i.size));
    return r;
  }
  ensureLineGaps(e, n) {
    let r = this.heightOracle.lineWrapping,
      i = r ? 1e4 : 2e3,
      o = i >> 1,
      s = i << 1;
    if (this.defaultTextDirection != wt.LTR && !r) return [];
    let l = [],
      a = (u, h, d, f) => {
        if (h - u < o) return;
        let p = this.state.selection.main,
          m = [p.from];
        p.empty || m.push(p.to);
        for (let v of m)
          if (v > u && v < h) {
            a(u, v - 10, d, f), a(v + 10, h, d, f);
            return;
          }
        let O = Pte(
          e,
          (v) =>
            v.from >= d.from && v.to <= d.to && Math.abs(v.from - u) < o && Math.abs(v.to - h) < o && !m.some((g) => v.from < g && v.to > g)
        );
        if (!O) {
          if (h < d.to && n && r && n.visibleRanges.some((v) => v.from <= h && v.to >= h)) {
            let v = n.moveToLineBoundary(H.cursor(h), !1, !0).head;
            v > u && (h = v);
          }
          O = new u1(u, h, this.gapSize(d, u, h, f));
        }
        l.push(O);
      },
      c = (u) => {
        if (u.length < s || u.type != Pn.Text) return;
        let h = Tte(u.from, u.to, this.stateDeco);
        if (h.total < s) return;
        let d = this.scrollTarget ? this.scrollTarget.range.head : null,
          f,
          p;
        if (r) {
          let m = (i / this.heightOracle.lineLength) * this.heightOracle.lineHeight,
            O,
            v;
          if (d != null) {
            let g = pd(h, d),
              b = ((this.visibleBottom - this.visibleTop) / 2 + m) / u.height;
            (O = g - b), (v = g + b);
          } else (O = (this.visibleTop - u.top - m) / u.height), (v = (this.visibleBottom - u.top + m) / u.height);
          (f = fd(h, O)), (p = fd(h, v));
        } else {
          let m = h.total * this.heightOracle.charWidth,
            O = i * this.heightOracle.charWidth,
            v,
            g;
          if (d != null) {
            let b = pd(h, d),
              x = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + O) / m;
            (v = b - x), (g = b + x);
          } else (v = (this.pixelViewport.left - O) / m), (g = (this.pixelViewport.right + O) / m);
          (f = fd(h, v)), (p = fd(h, g));
        }
        f > u.from && a(u.from, f, u, h), p < u.to && a(p, u.to, u, h);
      };
    for (let u of this.viewportLines) Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return l;
  }
  gapSize(e, n, r, i) {
    let o = pd(i, r) - pd(i, n);
    return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    u1.same(e, this.lineGaps) ||
      ((this.lineGaps = e), (this.lineGapDeco = me.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping)))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let n = [];
    ze.spans(
      e,
      this.viewport.from,
      this.viewport.to,
      {
        span(i, o) {
          n.push({ from: i, to: o });
        },
        point() {},
      },
      20
    );
    let r = n.length != this.visibleRanges.length || this.visibleRanges.some((i, o) => i.from != n[o].from || i.to != n[o].to);
    return (this.visibleRanges = n), r ? 4 : 0;
  }
  lineBlockAt(e) {
    return (
      (e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e)) ||
      Sc(this.heightMap.lineAt(e, xt.ByPos, this.heightOracle, 0, 0), this.scaler)
    );
  }
  lineBlockAtHeight(e) {
    return (
      (e >= this.viewportLines[0].top &&
        e <= this.viewportLines[this.viewportLines.length - 1].bottom &&
        this.viewportLines.find((n) => n.top <= e && n.bottom >= e)) ||
      Sc(this.heightMap.lineAt(this.scaler.fromDOM(e), xt.ByHeight, this.heightOracle, 0, 0), this.scaler)
    );
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Sc(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
let dd = class {
  constructor(e, n) {
    (this.from = e), (this.to = n);
  }
};
function Tte(t, e, n) {
  let r = [],
    i = t,
    o = 0;
  return (
    ze.spans(
      n,
      t,
      e,
      {
        span() {},
        point(s, l) {
          s > i && (r.push({ from: i, to: s }), (o += s - i)), (i = l);
        },
      },
      20
    ),
    i < e && (r.push({ from: i, to: e }), (o += e - i)),
    { total: o, ranges: r }
  );
}
function fd({ total: t, ranges: e }, n) {
  if (n <= 0) return e[0].from;
  if (n >= 1) return e[e.length - 1].to;
  let r = Math.floor(t * n);
  for (let i = 0; ; i++) {
    let { from: o, to: s } = e[i],
      l = s - o;
    if (r <= l) return o + r;
    r -= l;
  }
}
function pd(t, e) {
  let n = 0;
  for (let { from: r, to: i } of t.ranges) {
    if (e <= i) {
      n += e - r;
      break;
    }
    n += i - r;
  }
  return n / t.total;
}
function Pte(t, e) {
  for (let n of t) if (e(n)) return n;
}
const u5 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  },
};
class My {
  constructor(e, n, r) {
    let i = 0,
      o = 0,
      s = 0;
    (this.viewports = r.map(({ from: l, to: a }) => {
      let c = n.lineAt(l, xt.ByPos, e, 0, 0).top,
        u = n.lineAt(a, xt.ByPos, e, 0, 0).bottom;
      return (i += u - c), { from: l, to: a, top: c, bottom: u, domTop: 0, domBottom: 0 };
    })),
      (this.scale = (7e6 - i) / (n.height - i));
    for (let l of this.viewports)
      (l.domTop = s + (l.top - o) * this.scale), (s = l.domBottom = l.domTop + (l.bottom - l.top)), (o = l.bottom);
  }
  toDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.top) return i + (e - r) * this.scale;
      if (e <= o.bottom) return o.domTop + (e - o.top);
      (r = o.bottom), (i = o.domBottom);
    }
  }
  fromDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.domTop) return r + (e - i) / this.scale;
      if (e <= o.domBottom) return o.top + (e - o.domTop);
      (r = o.bottom), (i = o.domBottom);
    }
  }
  eq(e) {
    return e instanceof My
      ? this.scale == e.scale &&
          this.viewports.length == e.viewports.length &&
          this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to)
      : !1;
  }
}
function Sc(t, e) {
  if (e.scale == 1) return t;
  let n = e.toDOM(t.top),
    r = e.toDOM(t.bottom);
  return new ii(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => Sc(i, e)) : t._content);
}
const md = xe.define({ combine: (t) => t.join(" ") }),
  XO = xe.define({ combine: (t) => t.indexOf(!0) > -1 }),
  UO = qi.newName(),
  L7 = qi.newName(),
  N7 = qi.newName(),
  Q7 = { "&light": "." + L7, "&dark": "." + N7 };
function HO(t, e, n) {
  return new qi(e, {
    finish(r) {
      return /&/.test(r)
        ? r.replace(/&\w*/, (i) => {
            if (i == "&") return t;
            if (!n || !n[i]) throw new RangeError(`Unsupported selector: ${i}`);
            return n[i];
          })
        : t + " " + r;
    },
  });
}
const Ate = HO(
    "." + UO,
    {
      "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": { outline: "1px dotted #212121" },
        display: "flex !important",
        flexDirection: "column",
      },
      ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
      },
      ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" },
      },
      ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        overflowWrap: "anywhere",
        flexShrink: 1,
      },
      "&light .cm-content": { caretColor: "black" },
      "&dark .cm-content": { caretColor: "white" },
      ".cm-line": { display: "block", padding: "0 2px 0 6px" },
      ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } },
      "&light .cm-selectionBackground": { background: "#d9d9d9" },
      "&dark .cm-selectionBackground": { background: "#222" },
      "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" },
      "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" },
      ".cm-cursorLayer": { pointerEvents: "none" },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" },
      "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" },
      ".cm-cursor": { display: "none" },
      "&dark .cm-cursor": { borderLeftColor: "#444" },
      ".cm-dropCursor": { position: "absolute" },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" },
      ".cm-iso": { unicodeBidi: "isolate" },
      ".cm-announced": { position: "fixed", top: "-10000px" },
      "@media print": { ".cm-announced": { display: "none" } },
      "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
      "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
      "&light .cm-specialChar": { color: "red" },
      "&dark .cm-specialChar": { color: "#f78" },
      ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 },
      "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" },
      "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" },
      ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden",
      },
      ".cm-gutterElement": { boxSizing: "border-box" },
      ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" },
      "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" },
      "&dark .cm-activeLineGutter": { backgroundColor: "#222227" },
      ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 },
      "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" },
      "&light .cm-panels-top": { borderBottom: "1px solid #ddd" },
      "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" },
      "&dark .cm-panels": { backgroundColor: "#333338", color: "white" },
      ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" },
      ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" },
      ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" },
      ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" },
      ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat",
      },
      ".cm-trailingSpace": { backgroundColor: "#ff332255" },
      ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" },
      "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" },
      },
      "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": { backgroundImage: "linear-gradient(#111, #333)" },
      },
      ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" },
      "&light .cm-textfield": { backgroundColor: "white" },
      "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" },
    },
    Q7
  ),
  kc = "￿";
class $te {
  constructor(e, n) {
    (this.points = e), (this.text = ""), (this.lineSeparator = n.facet(Me.lineSeparator));
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += kc;
  }
  readRange(e, n) {
    if (!e) return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let o = this.text.length;
      this.readNode(i);
      let s = i.nextSibling;
      if (s == n) break;
      let l = ft.get(i),
        a = ft.get(s);
      (l && a ? l.breakAfter : (l ? l.breakAfter : ap(i)) || (ap(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o)) &&
        this.lineBreak(),
        (i = s);
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let r of this.points) r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1,
        s = 1,
        l;
      if (
        (this.lineSeparator
          ? ((o = n.indexOf(this.lineSeparator, r)), (s = this.lineSeparator.length))
          : (l = i.exec(n)) && ((o = l.index), (s = l[0].length)),
        this.append(n.slice(r, o < 0 ? n.length : o)),
        o < 0)
      )
        break;
      if ((this.lineBreak(), s > 1)) for (let a of this.points) a.node == e && a.pos > this.text.length && (a.pos -= s - 1);
      r = o + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore) return;
    let n = ft.get(e),
      r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; ) i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3
        ? this.readTextNode(e)
        : e.nodeName == "BR"
        ? e.nextSibling && this.lineBreak()
        : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let r of this.points) r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (Rte(e, r.node, r.offset) ? n : 0));
  }
}
function Rte(t, e, n) {
  for (;;) {
    if (!e || n < Yi(e)) return !1;
    if (e == t) return !0;
    (n = Ms(e) + 1), (e = e.parentNode);
  }
}
class h5 {
  constructor(e, n) {
    (this.node = e), (this.offset = n), (this.pos = -1);
  }
}
class Ite {
  constructor(e, n, r, i) {
    (this.typeOver = i), (this.bounds = null), (this.text = ""), (this.domChanged = n > -1);
    let { impreciseHead: o, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && n > -1) this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
      let l = o || s ? [] : Nte(e),
        a = new $te(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), (this.text = a.text), (this.newSel = Qte(l, this.bounds.from));
    } else {
      let l = e.observer.selectionRange,
        a =
          (o && o.node == l.focusNode && o.offset == l.focusOffset) || !RO(e.contentDOM, l.focusNode)
            ? e.state.selection.main.head
            : e.docView.posFromDOM(l.focusNode, l.focusOffset),
        c =
          (s && s.node == l.anchorNode && s.offset == l.anchorOffset) || !RO(e.contentDOM, l.anchorNode)
            ? e.state.selection.main.anchor
            : e.docView.posFromDOM(l.anchorNode, l.anchorOffset),
        u = e.viewport;
      if ((be.ios || be.chrome) && e.state.selection.main.empty && a != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(a, c),
          d = Math.max(a, c),
          f = u.from - h,
          p = u.to - d;
        (f == 0 || f == 1 || h == 0) && (p == 0 || p == -1 || d == e.state.doc.length) && ((a = 0), (c = e.state.doc.length));
      }
      this.newSel = H.single(c, a);
    }
  }
}
function D7(t, e) {
  let n,
    { newSel: r } = e,
    i = t.state.selection.main,
    o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: l } = e.bounds,
      a = i.from,
      c = null;
    (o === 8 || (be.android && e.text.length < l - s)) && ((a = i.to), (c = "end"));
    let u = Lte(t.state.doc.sliceString(s, l, kc), e.text, a - s, c);
    u &&
      (be.chrome && o == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == kc + kc && u.toB--,
      (n = { from: s + u.from, to: s + u.toA, insert: et.of(e.text.slice(u.from, u.toB).split(kc)) }));
  } else r && ((!t.hasFocus && t.state.facet(mo)) || r.main.eq(i)) && (r = null);
  if (!n && !r) return !1;
  if (
    (!n && e.typeOver && !i.empty && r && r.main.empty
      ? (n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) })
      : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4
      ? (n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to)) })
      : (be.mac || be.android) &&
        n &&
        n.from == n.to &&
        n.from == i.head - 1 &&
        /^\. ?$/.test(n.insert.toString()) &&
        t.contentDOM.getAttribute("autocorrect") == "off"
      ? (r && n.insert.length == 2 && (r = H.single(r.main.anchor - 1, r.main.head - 1)),
        (n = { from: i.from, to: i.to, insert: et.of([" "]) }))
      : be.chrome &&
        n &&
        n.from == n.to &&
        n.from == i.head &&
        n.insert.toString() ==
          `
 ` &&
        t.lineWrapping &&
        (r && (r = H.single(r.main.anchor - 1, r.main.head - 1)), (n = { from: i.from, to: i.to, insert: et.of([" "]) })),
    n)
  )
    return F7(t, n, r, o);
  if (r && !r.main.eq(i)) {
    let s = !1,
      l = "select";
    return (
      t.inputState.lastSelectionTime > Date.now() - 50 &&
        (t.inputState.lastSelectionOrigin == "select" && (s = !0), (l = t.inputState.lastSelectionOrigin)),
      t.dispatch({ selection: r, scrollIntoView: s, userEvent: l }),
      !0
    );
  } else return !1;
}
function F7(t, e, n, r = -1) {
  if (be.ios && t.inputState.flushIOSKey(e)) return !0;
  let i = t.state.selection.main;
  if (
    be.android &&
    ((e.to == i.to &&
      (e.from == i.from || (e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ")) &&
      e.insert.length == 1 &&
      e.insert.lines == 2 &&
      Ql(t.contentDOM, "Enter", 13)) ||
      (((e.from == i.from - 1 && e.to == i.to && e.insert.length == 0) || (r == 8 && e.insert.length < e.to - e.from && e.to > i.head)) &&
        Ql(t.contentDOM, "Backspace", 8)) ||
      (e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Ql(t.contentDOM, "Delete", 46)))
  )
    return !0;
  let o = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let s,
    l = () => s || (s = Mte(t, e, n));
  return t.state.facet(d7).some((a) => a(t, e.from, e.to, o, l)) || t.dispatch(l()), !0;
}
function Mte(t, e, n) {
  let r,
    i = t.state,
    o = i.selection.main;
  if (
    e.from >= o.from &&
    e.to <= o.to &&
    e.to - e.from >= (o.to - o.from) / 3 &&
    (!n || (n.main.empty && n.main.from == e.from + e.insert.length)) &&
    t.inputState.composing < 0
  ) {
    let l = o.from < e.from ? i.sliceDoc(o.from, e.from) : "",
      a = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
    r = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + a));
  } else {
    let l = i.changes(e),
      a = n && n.main.to <= l.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to),
        u,
        h = n && S7(t, n.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - p };
      } else u = t.state.doc.lineAt(o.head);
      let d = o.to - e.to,
        f = o.to - o.from;
      r = i.changeByRange((p) => {
        if (p.from == o.from && p.to == o.to) return { changes: l, range: a || p.map(l) };
        let m = p.to - d,
          O = m - c.length;
        if (p.to - p.from != f || t.state.sliceDoc(O, m) != c || (p.to >= u.from && p.from <= u.to)) return { range: p };
        let v = i.changes({ from: O, to: m, insert: e.insert }),
          g = p.to - o.to;
        return { changes: v, range: a ? H.range(Math.max(0, a.anchor + g), Math.max(0, a.head + g)) : p.map(v) };
      });
    } else r = { changes: l, selection: a && i.selection.replaceRange(a) };
  }
  let s = "input.type";
  return (
    (t.composing || (t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50)) &&
      ((t.inputState.compositionPendingChange = !1),
      (s += ".compose"),
      t.inputState.compositionFirstChange && ((s += ".start"), (t.inputState.compositionFirstChange = !1))),
    i.update(r, { userEvent: s, scrollIntoView: !0 })
  );
}
function Lte(t, e, n, r) {
  let i = Math.min(t.length, e.length),
    o = 0;
  for (; o < i && t.charCodeAt(o) == e.charCodeAt(o); ) o++;
  if (o == i && t.length == e.length) return null;
  let s = t.length,
    l = e.length;
  for (; s > 0 && l > 0 && t.charCodeAt(s - 1) == e.charCodeAt(l - 1); ) s--, l--;
  if (r == "end") {
    let a = Math.max(0, o - Math.min(s, l));
    n -= s + a - o;
  }
  if (s < o && t.length < e.length) {
    let a = n <= o && n >= s ? o - n : 0;
    (o -= a), (l = o + (l - s)), (s = o);
  } else if (l < o) {
    let a = n <= o && n >= l ? o - n : 0;
    (o -= a), (s = o + (s - l)), (l = o);
  }
  return { from: o, toA: s, toB: l };
}
function Nte(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM) return e;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o } = t.observer.selectionRange;
  return n && (e.push(new h5(n, r)), (i != n || o != r) && e.push(new h5(i, o))), e;
}
function Qte(t, e) {
  if (t.length == 0) return null;
  let n = t[0].pos,
    r = t.length == 2 ? t[1].pos : n;
  return n > -1 && r > -1 ? H.single(n + e, r + e) : null;
}
const Dte = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 },
  h1 = be.ie && be.ie_version <= 11;
class Fte {
  constructor(e) {
    (this.view = e),
      (this.active = !1),
      (this.editContext = null),
      (this.selectionRange = new See()),
      (this.selectionChanged = !1),
      (this.delayedFlush = -1),
      (this.resizeTimeout = -1),
      (this.queue = []),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1),
      (this.lastChange = 0),
      (this.scrollTargets = []),
      (this.intersection = null),
      (this.resizeScroll = null),
      (this.intersecting = !1),
      (this.gapIntersection = null),
      (this.gaps = []),
      (this.printQuery = null),
      (this.parentCheck = -1),
      (this.dom = e.contentDOM),
      (this.observer = new MutationObserver((n) => {
        for (let r of n) this.queue.push(r);
        ((be.ie && be.ie_version <= 11) || (be.ios && e.composing)) &&
        n.some(
          (r) =>
            (r.type == "childList" && r.removedNodes.length) || (r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length)
        )
          ? this.flushSoon()
          : this.flush();
      })),
      window.EditContext &&
        e.constructor.EDIT_CONTEXT !== !1 &&
        !(be.chrome && be.chrome_version < 126) &&
        ((this.editContext = new Vte(e)), e.state.facet(mo) && (e.contentDOM.editContext = this.editContext.editContext)),
      h1 &&
        (this.onCharData = (n) => {
          this.queue.push({ target: n.target, type: "characterData", oldValue: n.prevValue }), this.flushSoon();
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this)),
      (this.onResize = this.onResize.bind(this)),
      (this.onPrint = this.onPrint.bind(this)),
      (this.onScroll = this.onScroll.bind(this)),
      window.matchMedia && (this.printQuery = window.matchMedia("print")),
      typeof ResizeObserver == "function" &&
        ((this.resizeScroll = new ResizeObserver(() => {
          var n;
          ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
        })),
        this.resizeScroll.observe(e.scrollDOM)),
      this.addWindowListeners((this.win = e.win)),
      this.start(),
      typeof IntersectionObserver == "function" &&
        ((this.intersection = new IntersectionObserver(
          (n) => {
            this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)),
              n.length > 0 &&
                n[n.length - 1].intersectionRatio > 0 != this.intersecting &&
                ((this.intersecting = !this.intersecting),
                this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
          },
          { threshold: [0, 0.001] }
        )),
        this.intersection.observe(this.dom),
        (this.gapIntersection = new IntersectionObserver((n) => {
          n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
        }, {}))),
      this.listenForScroll(),
      this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 &&
      (this.resizeTimeout = setTimeout(() => {
        (this.resizeTimeout = -1), this.view.requestMeasure();
      }, 50));
  }
  onPrint(e) {
    (e.type == "change" && !e.matches) ||
      ((this.view.viewState.printing = !0),
      this.view.measure(),
      setTimeout(() => {
        (this.view.viewState.printing = !1), this.view.requestMeasure();
      }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
      this.gapIntersection.disconnect();
      for (let n of e) this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: r } = this,
      i = this.selectionRange;
    if (r.state.facet(mo) ? r.root.activeElement != this.dom : !tf(r.dom, i)) return;
    let o = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    ((be.ie && be.ie_version <= 11) || (be.android && be.chrome)) &&
    !r.state.selection.main.empty &&
    i.focusNode &&
    jc(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset)
      ? this.flushSoon()
      : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this,
      n = bu(e.root);
    if (!n) return !1;
    let r = (be.safari && e.root.nodeType == 11 && bee(this.dom.ownerDocument) == this.dom && Bte(this.view, n)) || n;
    if (!r || this.selectionRange.eq(r)) return !1;
    let i = tf(this.dom, r);
    return i &&
      !this.selectionChanged &&
      e.inputState.lastFocusTime > Date.now() - 200 &&
      e.inputState.lastTouchTime < Date.now() - 300 &&
      Cee(this.dom, r)
      ? ((this.view.inputState.lastFocusTime = 0), e.docView.updateSelection(), !1)
      : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), (this.selectionChanged = !1);
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0,
      n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)),
          n && n.push(r),
          (r = r.assignedSlot || r.parentNode);
      else if (r.nodeType == 11) r = r.host;
      else break;
    if ((e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n)) {
      for (let r of this.scrollTargets) r.removeEventListener("scroll", this.onScroll);
      for (let r of (this.scrollTargets = n)) r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active) return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active ||
      (this.observer.observe(this.dom, Dte),
      h1 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
      (this.active = !0));
  }
  stop() {
    this.active &&
      ((this.active = !1), this.observer.disconnect(), h1 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), (this.queue.length = 0), (this.selectionChanged = !1);
  }
  delayAndroidKey(e, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o &&
          (this.clearDelayedAndroidKey(),
          (this.view.inputState.lastKeyCode = o.keyCode),
          (this.view.inputState.lastKeyTime = Date.now()),
          !this.flush() && o.force && Ql(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") &&
      (this.delayedAndroidKey = {
        key: e,
        keyCode: n,
        force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force),
      });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), (this.delayedAndroidKey = null), (this.flushingAndroidKey = -1);
  }
  flushSoon() {
    this.delayedFlush < 0 &&
      (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        (this.delayedFlush = -1), this.flush();
      }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), (this.delayedFlush = -1)), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords()) this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1,
      r = -1,
      i = !1;
    for (let o of e) {
      let s = this.readMutation(o);
      s && (s.typeOver && (i = !0), n == -1 ? ({ from: n, to: r } = s) : ((n = Math.min(s.from, n)), (r = Math.max(s.to, r))));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: n, typeOver: r } = this.processRecords(),
      i = this.selectionChanged && tf(this.dom, this.selectionRange);
    if (e < 0 && !i) return null;
    e > -1 && (this.lastChange = Date.now()), (this.view.inputState.lastFocusTime = 0), (this.selectionChanged = !1);
    let o = new Ite(this.view, e, n, r);
    return (this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }), o;
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n) return this.view.requestMeasure(), !1;
    let r = this.view.state,
      i = D7(this.view, n);
    return (
      this.view.state == r && (n.domChanged || (n.newSel && !n.newSel.main.eq(this.view.state.selection.main))) && this.view.update([]), i
    );
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e)) return null;
    if ((n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList")) {
      let r = d5(n, e.previousSibling || e.target.previousSibling, -1),
        i = d5(n, e.nextSibling || e.target.nextSibling, 1);
      return { from: r ? n.posAfter(r) : n.posAtStart, to: i ? n.posBefore(i) : n.posAtEnd, typeOver: !1 };
    } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), (this.win = e), this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize),
      this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : e.addEventListener("beforeprint", this.onPrint),
      e.addEventListener("scroll", this.onScroll),
      e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll),
      e.removeEventListener("resize", this.onResize),
      this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : e.removeEventListener("beforeprint", this.onPrint),
      e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext &&
      (this.editContext.update(e),
      e.startState.facet(mo) != e.state.facet(mo) &&
        (e.view.contentDOM.editContext = e.state.facet(mo) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, r;
    this.stop(),
      (e = this.intersection) === null || e === void 0 || e.disconnect(),
      (n = this.gapIntersection) === null || n === void 0 || n.disconnect(),
      (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets) i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win),
      clearTimeout(this.parentCheck),
      clearTimeout(this.resizeTimeout),
      this.win.cancelAnimationFrame(this.delayedFlush),
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function d5(t, e, n) {
  for (; e; ) {
    let r = ft.get(e);
    if (r && r.parent == t) return r;
    let i = e.parentNode;
    e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function f5(t, e) {
  let n = e.startContainer,
    r = e.startOffset,
    i = e.endContainer,
    o = e.endOffset,
    s = t.docView.domAtPos(t.state.selection.main.anchor);
  return jc(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function Bte(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i) return f5(t, i);
  }
  let n = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), (n = i.getTargetRanges()[0]);
  }
  return (
    t.contentDOM.addEventListener("beforeinput", r, !0),
    t.dom.ownerDocument.execCommand("indent"),
    t.contentDOM.removeEventListener("beforeinput", r, !0),
    n ? f5(t, n) : null
  );
}
class Vte {
  constructor(e) {
    (this.from = 0), (this.to = 0), (this.pendingContextChange = null), this.resetRange(e.state);
    let n = (this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head),
    }));
    n.addEventListener("textupdate", (r) => {
      let { anchor: i } = e.state.selection.main,
        o = {
          from: this.toEditorPos(r.updateRangeStart),
          to: this.toEditorPos(r.updateRangeEnd),
          insert: et.of(
            r.text.split(`
`)
          ),
        };
      o.from == this.from && i < this.from ? (o.from = i) : o.to == this.to && i > this.to && (o.to = i),
        !(o.from == o.to && !o.insert.length) &&
          ((this.pendingContextChange = o),
          F7(e, o, H.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd))),
          this.pendingContextChange && this.revertPending(e.state));
    }),
      n.addEventListener("characterboundsupdate", (r) => {
        let i = [],
          o = null;
        for (let s = this.toEditorPos(r.rangeStart), l = this.toEditorPos(r.rangeEnd); s < l; s++) {
          let a = e.coordsForChar(s);
          (o = (a && new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top)) || o || new DOMRect()), i.push(o);
        }
        n.updateCharacterBounds(r.rangeStart, i);
      }),
      n.addEventListener("textformatupdate", (r) => {
        let i = [];
        for (let o of r.getTextFormats()) {
          let s = o.underlineStyle,
            l = o.underlineThickness;
          if (s != "None" && l != "None") {
            let a = `text-decoration: underline ${s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${l == "Thin" ? 1 : 2}px`;
            i.push(me.mark({ attributes: { style: a } }).range(this.toEditorPos(o.rangeStart), this.toEditorPos(o.rangeEnd)));
          }
        }
        e.dispatch({ effects: O7.of(me.set(i)) });
      }),
      n.addEventListener("compositionstart", () => {
        e.inputState.composing < 0 && ((e.inputState.composing = 0), (e.inputState.compositionFirstChange = !0));
      }),
      n.addEventListener("compositionend", () => {
        (e.inputState.composing = -1), (e.inputState.compositionFirstChange = null);
      }),
      (this.measureReq = {
        read: (r) => {
          this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
          let i = bu(r.root);
          i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
        },
      });
  }
  applyEdits(e) {
    let n = 0,
      r = !1,
      i = this.pendingContextChange;
    return (
      e.changes.iterChanges((o, s, l, a, c) => {
        if (r) return;
        let u = c.length - (s - o);
        if (i && s >= i.to)
          if (i.from == o && i.to == s && i.insert.eq(c)) {
            (i = this.pendingContextChange = null), (n += u), (this.to += u);
            return;
          } else (i = null), this.revertPending(e.state);
        if (((o += n), (s += n), s <= this.from)) (this.from += u), (this.to += u);
        else if (o < this.to) {
          if (o < this.from || s > this.to || this.to - this.from + c.length > 3e4) {
            r = !0;
            return;
          }
          this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), c.toString()), (this.to += u);
        }
        n += u;
      }),
      i && !r && this.revertPending(e.state),
      !r
    );
  }
  update(e) {
    !this.applyEdits(e) || !this.rangeIsValid(e.state)
      ? ((this.pendingContextChange = null),
        this.resetRange(e.state),
        this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)),
        this.setSelection(e.state))
      : (e.docChanged || e.selectionSet) && this.setSelection(e.state),
      (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    (this.from = Math.max(0, n - 1e4)), (this.to = Math.min(e.doc.length, n + 1e4));
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    (this.pendingContextChange = null),
      this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.to + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection,
      r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))),
      i = this.toContextPos(n.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !((this.from > 0 && n - this.from < 500) || (this.to < e.doc.length && this.to - n < 500) || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e) {
    return e + this.from;
  }
  toContextPos(e) {
    return e - this.from;
  }
}
class re {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(e = {}) {
    (this.plugins = []),
      (this.pluginMap = new Map()),
      (this.editorAttrs = {}),
      (this.contentAttrs = {}),
      (this.bidiCache = []),
      (this.destroyed = !1),
      (this.updateState = 2),
      (this.measureScheduled = -1),
      (this.measureRequests = []),
      (this.contentDOM = document.createElement("div")),
      (this.scrollDOM = document.createElement("div")),
      (this.scrollDOM.tabIndex = -1),
      (this.scrollDOM.className = "cm-scroller"),
      this.scrollDOM.appendChild(this.contentDOM),
      (this.announceDOM = document.createElement("div")),
      (this.announceDOM.className = "cm-announced"),
      this.announceDOM.setAttribute("aria-live", "polite"),
      (this.dom = document.createElement("div")),
      this.dom.appendChild(this.announceDOM),
      this.dom.appendChild(this.scrollDOM),
      e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    (this.dispatchTransactions = e.dispatchTransactions || (n && ((r) => r.forEach((i) => n(i, this)))) || ((r) => this.update(r))),
      (this.dispatch = this.dispatch.bind(this)),
      (this._root = e.root || kee(e.parent) || document),
      (this.viewState = new c5(e.state || Me.create(e))),
      e.scrollTo && e.scrollTo.is(cd) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)),
      (this.plugins = this.state.facet(yc).map((r) => new l1(r)));
    for (let r of this.plugins) r.update(this);
    (this.observer = new Fte(this)),
      (this.inputState = new nte(this)),
      this.inputState.ensureHandlers(this.plugins),
      (this.docView = new W2(this)),
      this.mountStyles(),
      this.updateAttrs(),
      (this.updateState = 0),
      this.requestMeasure();
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof zt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  update(e) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1,
      r = !1,
      i,
      o = this.state;
    for (let d of e) {
      if (d.startState != o) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let s = this.hasFocus,
      l = 0,
      a = null;
    e.some((d) => d.annotation($7))
      ? ((this.inputState.notifiedFocused = s), (l = 1))
      : s != this.inputState.notifiedFocused && ((this.inputState.notifiedFocused = s), (a = R7(o, s)), a || (l = 1));
    let c = this.observer.delayedAndroidKey,
      u = null;
    if (
      (c
        ? (this.observer.clearDelayedAndroidKey(),
          (u = this.observer.readChange()),
          ((u && !this.state.doc.eq(o.doc)) || !this.state.selection.eq(o.selection)) && (u = null))
        : this.observer.clear(),
      o.facet(Me.phrases) != this.state.facet(Me.phrases))
    )
      return this.setState(o);
    (i = up.create(this, o, e)), (i.flags |= l);
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if ((h && (h = h.map(d.changes)), d.scrollIntoView)) {
          let { main: f } = d.state.selection;
          h = new Dl(f.empty ? f : H.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of d.effects) f.is(cd) && (h = f.value.clip(this.state));
      }
      this.viewState.update(i, h),
        (this.bidiCache = hp.update(this.bidiCache, i.changes)),
        i.empty || (this.updatePlugins(i), this.inputState.update(i)),
        (n = this.docView.update(i)),
        this.state.facet(wc) != this.styleModules && this.mountStyles(),
        (r = this.updateAttrs()),
        this.showAnnouncements(e),
        this.docView.updateSelection(
          n,
          e.some((d) => d.isUserEvent("select.pointer"))
        );
    } finally {
      this.updateState = 0;
    }
    if (
      (i.startState.facet(md) != i.state.facet(md) && (this.viewState.mustMeasureContent = !0),
      (n || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(),
      n && this.docViewUpdate(),
      !i.empty)
    )
      for (let d of this.state.facet(jO))
        try {
          d(i);
        } catch (f) {
          jn(this.state, f, "update listener");
        }
    (a || u) &&
      Promise.resolve().then(() => {
        a && this.state == a.startState && this.dispatch(a), u && !D7(this, u) && c.force && Ql(this.contentDOM, c.key, c.keyCode);
      });
  }
  setState(e) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins) r.destroy(this);
      (this.viewState = new c5(e)), (this.plugins = e.facet(yc).map((r) => new l1(r))), this.pluginMap.clear();
      for (let r of this.plugins) r.update(this);
      this.docView.destroy(),
        (this.docView = new W2(this)),
        this.inputState.ensureHandlers(this.plugins),
        this.mountStyles(),
        this.updateAttrs(),
        (this.bidiCache = []);
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(yc),
      r = e.state.facet(yc);
    if (n != r) {
      let i = [];
      for (let o of r) {
        let s = n.indexOf(o);
        if (s < 0) i.push(new l1(o));
        else {
          let l = this.plugins[s];
          (l.mustUpdate = e), i.push(l);
        }
      }
      for (let o of this.plugins) o.mustUpdate != e && o.destroy(this);
      (this.plugins = i), this.pluginMap.clear();
    } else for (let i of this.plugins) i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (r) {
          jn(this.state, r, "doc view update listener");
        }
    }
  }
  measure(e = !0) {
    if (this.destroyed) return;
    if ((this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey)) {
      (this.measureScheduled = -1), this.requestMeasure();
      return;
    }
    (this.measureScheduled = 0), e && this.observer.forceFlush();
    let n = null,
      r = this.scrollDOM,
      i = r.scrollTop * this.scaleY,
      { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), (this.viewState.scrollAnchorHeight = -1);
    try {
      for (let l = 0; ; l++) {
        if (s < 0)
          if (W9(r)) (o = -1), (s = this.viewState.heightMap.height);
          else {
            let f = this.viewState.scrollAnchorAt(i);
            (o = f.from), (s = f.top);
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((f) => {
            try {
              return f.read(this);
            } catch (p) {
              return jn(this.state, p), p5;
            }
          }),
          h = up.create(this, this.state, []),
          d = !1;
        (h.flags |= a),
          n ? (n.flags |= a) : (n = h),
          (this.updateState = 2),
          h.empty ||
            (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), (d = this.docView.update(h)), d && this.docViewUpdate());
        for (let f = 0; f < c.length; f++)
          if (u[f] != p5)
            try {
              let p = c[f];
              p.write && p.write(u[f], this);
            } catch (p) {
              jn(this.state, p);
            }
        if ((d && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0)) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), (this.viewState.scrollTarget = null), (s = -1);
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
              if (p > 1 || p < -1) {
                (i = i + p), (r.scrollTop = i / this.scaleY), (s = -1);
                continue;
              }
            }
          break;
        }
      }
    } finally {
      (this.updateState = 0), (this.measureScheduled = -1);
    }
    if (n && !n.empty) for (let l of this.state.facet(jO)) l(n);
  }
  get themeClasses() {
    return UO + " " + (this.state.facet(XO) ? N7 : L7) + " " + this.state.facet(md);
  }
  updateAttrs() {
    let e = m5(this, v7, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }),
      n = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: this.state.facet(mo) ? "true" : "false",
        class: "cm-content",
        style: `${be.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true",
      };
    this.state.readOnly && (n["aria-readonly"] = "true"), m5(this, $y, n);
    let r = this.observer.ignore(() => {
      let i = QO(this.contentDOM, this.contentAttrs, n),
        o = QO(this.dom, this.editorAttrs, e);
      return i || o;
    });
    return (this.editorAttrs = e), (this.contentAttrs = n), r;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(re.announce)) {
          n && (this.announceDOM.textContent = ""), (n = !1);
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(wc);
    let e = this.state.facet(re.cspNonce);
    qi.mount(this.root, this.styleModules.concat(Ate).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(e) {
    if ((this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e)) {
      if (this.measureRequests.indexOf(e) > -1) return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (
      (n === void 0 || (n && n.spec != e)) && this.pluginMap.set(e, (n = this.plugins.find((r) => r.spec == e) || null)),
      n && n.update(this).value
    );
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(e, n, r) {
    return c1(this, e, G2(this, e, n, r));
  }
  moveByGroup(e, n) {
    return c1(
      this,
      e,
      G2(this, e, n, (r) => ete(this, e.head, r))
    );
  }
  visualLineSide(e, n) {
    let r = this.bidiSpans(e),
      i = this.textDirectionAt(e.from),
      o = r[n ? r.length - 1 : 0];
    return H.cursor(o.side(n, i) + e.from, o.forward(!n, i) ? 1 : -1);
  }
  moveToLineBoundary(e, n, r = !0) {
    return Kee(this, e, n, r);
  }
  moveVertically(e, n, r) {
    return c1(this, e, tte(this, e, n, r));
  }
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), k7(this, e, n);
  }
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, n);
    if (!r || r.left == r.right) return r;
    let i = this.state.doc.lineAt(e),
      o = this.bidiSpans(i),
      s = o[So.find(o, e - i.from, -1, n)];
    return Ty(r, (s.dir == wt.LTR) == n > 0);
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(e) {
    return !this.state.facet(p7) || e < this.viewport.from || e > this.viewport.to
      ? this.textDirection
      : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(e) {
    if (e.length > jte) return s7(e.length);
    let n = this.textDirectionAt(e.from),
      r;
    for (let o of this.bidiCache) if (o.from == e.from && o.dir == n && (o.fresh || o7(o.isolates, (r = z2(this, e))))) return o.order;
    r || (r = z2(this, e));
    let i = Qee(e.text, n, r);
    return this.bidiCache.push(new hp(e.from, e.to, n, r, !0, i)), i;
  }
  get hasFocus() {
    var e;
    return (
      (this.dom.ownerDocument.hasFocus() ||
        (be.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4)) &&
      this.root.activeElement == this.contentDOM
    );
  }
  focus() {
    this.observer.ignore(() => {
      Z9(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(e) {
    this._root != e &&
      ((this._root = e), this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins) e.destroy(this);
    (this.plugins = []),
      this.inputState.destroy(),
      this.docView.destroy(),
      this.dom.remove(),
      this.observer.destroy(),
      this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
      (this.destroyed = !0);
  }
  static scrollIntoView(e, n = {}) {
    return cd.of(new Dl(typeof e == "number" ? H.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM,
      r = this.viewState.scrollAnchorAt(e);
    return cd.of(new Dl(H.cursor(r.from), "start", "start", r.top - e, n, !0));
  }
  setTabFocusMode(e) {
    e == null
      ? (this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1)
      : typeof e == "boolean"
      ? (this.inputState.tabFocusMode = e ? 0 : -1)
      : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  static domEventHandlers(e) {
    return At.define(() => ({}), { eventHandlers: e });
  }
  static domEventObservers(e) {
    return At.define(() => ({}), { eventObservers: e });
  }
  static theme(e, n) {
    let r = qi.newName(),
      i = [md.of(r), wc.of(HO(`.${r}`, e))];
    return n && n.dark && i.push(XO.of(!0)), i;
  }
  static baseTheme(e) {
    return zr.lowest(wc.of(HO("." + UO, e, Q7)));
  }
  static findFromDOM(e) {
    var n;
    let r = e.querySelector(".cm-content"),
      i = (r && ft.get(r)) || ft.get(e);
    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
re.styleModule = wc;
re.inputHandler = d7;
re.scrollHandler = g7;
re.focusChangeEffect = f7;
re.perLineTextDirection = p7;
re.exceptionSink = h7;
re.updateListener = jO;
re.editable = mo;
re.mouseSelectionStyle = u7;
re.dragMovesSelection = c7;
re.clickAddsSelectionRange = a7;
re.decorations = yu;
re.outerDecorations = b7;
re.atomicRanges = Ry;
re.bidiIsolatedRanges = x7;
re.scrollMargins = y7;
re.darkTheme = XO;
re.cspNonce = xe.define({ combine: (t) => (t.length ? t[0] : "") });
re.contentAttributes = $y;
re.editorAttributes = v7;
re.lineWrapping = re.contentAttributes.of({ class: "cm-lineWrapping" });
re.announce = Ee.define();
const jte = 4096,
  p5 = {};
class hp {
  constructor(e, n, r, i, o, s) {
    (this.from = e), (this.to = n), (this.dir = r), (this.isolates = i), (this.fresh = o), (this.order = s);
  }
  static update(e, n) {
    if (n.empty && !e.some((o) => o.fresh)) return e;
    let r = [],
      i = e.length ? e[e.length - 1].dir : wt.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let s = e[o];
      s.dir == i &&
        !n.touchesRange(s.from, s.to) &&
        r.push(new hp(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order));
    }
    return r;
  }
}
function m5(t, e, n) {
  for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let o = r[i],
      s = typeof o == "function" ? o(t) : o;
    s && NO(s, n);
  }
  return n;
}
const Zte = be.mac ? "mac" : be.windows ? "win" : be.linux ? "linux" : "key";
function zte(t, e) {
  const n = t.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, o, s, l;
  for (let a = 0; a < n.length - 1; ++a) {
    const c = n[a];
    if (/^(cmd|meta|m)$/i.test(c)) l = !0;
    else if (/^a(lt)?$/i.test(c)) i = !0;
    else if (/^(c|ctrl|control)$/i.test(c)) o = !0;
    else if (/^s(hift)?$/i.test(c)) s = !0;
    else if (/^mod$/i.test(c)) e == "mac" ? (l = !0) : (o = !0);
    else throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), l && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
}
function gd(t, e, n) {
  return (
    e.altKey && (t = "Alt-" + t),
    e.ctrlKey && (t = "Ctrl-" + t),
    e.metaKey && (t = "Meta-" + t),
    n !== !1 && e.shiftKey && (t = "Shift-" + t),
    t
  );
}
const Wte = zr.default(
    re.domEventHandlers({
      keydown(t, e) {
        return V7(B7(e.state), t, e, "editor");
      },
    })
  ),
  Qs = xe.define({ enables: Wte }),
  g5 = new WeakMap();
function B7(t) {
  let e = t.facet(Qs),
    n = g5.get(e);
  return n || g5.set(e, (n = Hte(e.reduce((r, i) => r.concat(i), [])))), n;
}
function Xte(t, e, n) {
  return V7(B7(t.state), e, t, n);
}
let go = null;
const Ute = 4e3;
function Hte(t, e = Zte) {
  let n = Object.create(null),
    r = Object.create(null),
    i = (s, l) => {
      let a = r[s];
      if (a == null) r[s] = l;
      else if (a != l) throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
    },
    o = (s, l, a, c, u) => {
      var h, d;
      let f = n[s] || (n[s] = Object.create(null)),
        p = l.split(/ (?!$)/).map((v) => zte(v, e));
      for (let v = 1; v < p.length; v++) {
        let g = p.slice(0, v).join(" ");
        i(g, !0),
          f[g] ||
            (f[g] = {
              preventDefault: !0,
              stopPropagation: !1,
              run: [
                (b) => {
                  let x = (go = { view: b, prefix: g, scope: s });
                  return (
                    setTimeout(() => {
                      go == x && (go = null);
                    }, Ute),
                    !0
                  );
                },
              ],
            });
      }
      let m = p.join(" ");
      i(m, !1);
      let O =
        f[m] ||
        (f[m] = {
          preventDefault: !1,
          stopPropagation: !1,
          run: ((d = (h = f._any) === null || h === void 0 ? void 0 : h.run) === null || d === void 0 ? void 0 : d.slice()) || [],
        });
      a && O.run.push(a), c && (O.preventDefault = !0), u && (O.stopPropagation = !0);
    };
  for (let s of t) {
    let l = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let c of l) {
        let u = n[c] || (n[c] = Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = s;
        for (let d in u) u[d].run.push((f) => h(f, qO));
      }
    let a = s[e] || s.key;
    if (a)
      for (let c of l)
        o(c, a, s.run, s.preventDefault, s.stopPropagation), s.shift && o(c, "Shift-" + a, s.shift, s.preventDefault, s.stopPropagation);
  }
  return n;
}
let qO = null;
function V7(t, e, n, r) {
  qO = e;
  let i = vee(e),
    o = an(i, 0),
    s = dr(o) == i.length && i != " ",
    l = "",
    a = !1,
    c = !1,
    u = !1;
  go && go.view == n && go.scope == r && ((l = go.prefix + " "), _7.indexOf(e.keyCode) < 0 && ((c = !0), (go = null)));
  let h = new Set(),
    d = (O) => {
      if (O) {
        for (let v of O.run) if (!h.has(v) && (h.add(v), v(n))) return O.stopPropagation && (u = !0), !0;
        O.preventDefault && (O.stopPropagation && (u = !0), (c = !0));
      }
      return !1;
    },
    f = t[r],
    p,
    m;
  return (
    f &&
      (d(f[l + gd(i, e, !s)])
        ? (a = !0)
        : s && (e.altKey || e.metaKey || e.ctrlKey) && !(be.windows && e.ctrlKey && e.altKey) && (p = Vo[e.keyCode]) && p != i
        ? (d(f[l + gd(p, e, !0)]) || (e.shiftKey && (m = vu[e.keyCode]) != i && m != p && d(f[l + gd(m, e, !1)]))) && (a = !0)
        : s && e.shiftKey && d(f[l + gd(i, e, !0)]) && (a = !0),
      !a && d(f._any) && (a = !0)),
    c && (a = !0),
    a && u && e.stopPropagation(),
    (qO = null),
    a
  );
}
class $h {
  constructor(e, n, r, i, o) {
    (this.className = e), (this.left = n), (this.top = r), (this.width = i), (this.height = o);
  }
  draw() {
    let e = document.createElement("div");
    return (e.className = this.className), this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    (e.style.left = this.left + "px"),
      (e.style.top = this.top + "px"),
      this.width != null && (e.style.width = this.width + "px"),
      (e.style.height = this.height + "px");
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  static forRange(e, n, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i) return [];
      let o = j7(e);
      return [new $h(n, i.left - o.left, i.top - o.top, null, i.bottom - i.top)];
    } else return qte(e, n, r);
  }
}
function j7(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return {
    left: (t.textDirection == wt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX,
    top: e.top - t.scrollDOM.scrollTop * t.scaleY,
  };
}
function O5(t, e, n, r) {
  let i = t.coordsAtPos(e, n * 2);
  if (!i) return r;
  let o = t.dom.getBoundingClientRect(),
    s = (i.top + i.bottom) / 2,
    l = t.posAtCoords({ x: o.left + 1, y: s }),
    a = t.posAtCoords({ x: o.right - 1, y: s });
  return l == null || a == null ? r : { from: Math.max(r.from, Math.min(l, a)), to: Math.min(r.to, Math.max(l, a)) };
}
function qte(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to) return [];
  let r = Math.max(n.from, t.viewport.from),
    i = Math.min(n.to, t.viewport.to),
    o = t.textDirection == wt.LTR,
    s = t.contentDOM,
    l = s.getBoundingClientRect(),
    a = j7(t),
    c = s.querySelector(".cm-line"),
    u = c && window.getComputedStyle(c),
    h = l.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0),
    d = l.right - (u ? parseInt(u.paddingRight) : 0),
    f = zO(t, r),
    p = zO(t, i),
    m = f.type == Pn.Text ? f : null,
    O = p.type == Pn.Text ? p : null;
  if (
    (m && (t.lineWrapping || f.widgetLineBreaks) && (m = O5(t, r, 1, m)),
    O && (t.lineWrapping || p.widgetLineBreaks) && (O = O5(t, i, -1, O)),
    m && O && m.from == O.from && m.to == O.to)
  )
    return g(b(n.from, n.to, m));
  {
    let k = m ? b(n.from, null, m) : x(f, !1),
      w = O ? b(null, n.to, O) : x(p, !0),
      y = [];
    return (
      (m || f).to < (O || p).from - (m && O ? 1 : 0) || (f.widgetLineBreaks > 1 && k.bottom + t.defaultLineHeight / 2 < w.top)
        ? y.push(v(h, k.bottom, d, w.top))
        : k.bottom < w.top && t.elementAtHeight((k.bottom + w.top) / 2).type == Pn.Text && (k.bottom = w.top = (k.bottom + w.top) / 2),
      g(k).concat(y).concat(g(w))
    );
  }
  function v(k, w, y, C) {
    return new $h(e, k - a.left, w - a.top - 0.01, y - k, C - w + 0.01);
  }
  function g({ top: k, bottom: w, horizontal: y }) {
    let C = [];
    for (let P = 0; P < y.length; P += 2) C.push(v(y[P], k, y[P + 1], w));
    return C;
  }
  function b(k, w, y) {
    let C = 1e9,
      P = -1e9,
      E = [];
    function N(Q, R, W, B, K) {
      let ne = t.coordsAtPos(Q, Q == y.to ? -2 : 2),
        A = t.coordsAtPos(W, W == y.from ? 2 : -2);
      !ne ||
        !A ||
        ((C = Math.min(ne.top, A.top, C)),
        (P = Math.max(ne.bottom, A.bottom, P)),
        K == wt.LTR ? E.push(o && R ? h : ne.left, o && B ? d : A.right) : E.push(!o && B ? h : A.left, !o && R ? d : ne.right));
    }
    let L = k ?? y.from,
      D = w ?? y.to;
    for (let Q of t.visibleRanges)
      if (Q.to > L && Q.from < D)
        for (let R = Math.max(Q.from, L), W = Math.min(Q.to, D); ; ) {
          let B = t.state.doc.lineAt(R);
          for (let K of t.bidiSpans(B)) {
            let ne = K.from + B.from,
              A = K.to + B.from;
            if (ne >= W) break;
            A > R && N(Math.max(ne, R), k == null && ne <= L, Math.min(A, W), w == null && A >= D, K.dir);
          }
          if (((R = B.to + 1), R >= W)) break;
        }
    return E.length == 0 && N(L, k == null, D, w == null, t.textDirection), { top: C, bottom: P, horizontal: E };
  }
  function x(k, w) {
    let y = l.top + (w ? k.top : k.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function Yte(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class Gte {
  constructor(e, n) {
    (this.view = e),
      (this.layer = n),
      (this.drawn = []),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }),
      (this.dom = e.scrollDOM.appendChild(document.createElement("div"))),
      this.dom.classList.add("cm-layer"),
      n.above && this.dom.classList.add("cm-layer-above"),
      n.class && this.dom.classList.add(n.class),
      this.scale(),
      this.dom.setAttribute("aria-hidden", "true"),
      this.setOrder(e.state),
      e.requestMeasure(this.measureReq),
      n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(of) != e.state.facet(of) && this.setOrder(e.state),
      (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0,
      r = e.facet(of);
    for (; n < r.length && r[n] != this.layer; ) n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) &&
      ((this.scaleX = e), (this.scaleY = n), (this.dom.style.transform = `scale(${1 / e}, ${1 / n})`));
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, r) => !Yte(n, this.drawn[r]))) {
      let n = this.dom.firstChild,
        r = 0;
      for (let i of e)
        i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r])
          ? ((n = n.nextSibling), r++)
          : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), (n = i);
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const of = xe.define();
function Z7(t) {
  return [At.define((e) => new Gte(e, t)), of.of(t)];
}
const z7 = !be.ios,
  wu = xe.define({
    combine(t) {
      return Si(
        t,
        { cursorBlinkRate: 1200, drawRangeCursor: !0 },
        { cursorBlinkRate: (e, n) => Math.min(e, n), drawRangeCursor: (e, n) => e || n }
      );
    },
  });
function Jte(t = {}) {
  return [wu.of(t), Kte, ene, tne, m7.of(!0)];
}
function W7(t) {
  return t.startState.facet(wu) != t.state.facet(wu);
}
const Kte = Z7({
  above: !0,
  markers(t) {
    let { state: e } = t,
      n = e.facet(wu),
      r = [];
    for (let i of e.selection.ranges) {
      let o = i == e.selection.main;
      if (i.empty ? !o || z7 : n.drawRangeCursor) {
        let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary",
          l = i.empty ? i : H.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of $h.forRange(t, s, l)) r.push(a);
      }
    }
    return r;
  },
  update(t, e) {
    t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = W7(t);
    return n && v5(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    v5(e.state, t);
  },
  class: "cm-cursorLayer",
});
function v5(t, e) {
  e.style.animationDuration = t.facet(wu).cursorBlinkRate + "ms";
}
const ene = Z7({
    above: !1,
    markers(t) {
      return t.state.selection.ranges
        .map((e) => (e.empty ? [] : $h.forRange(t, "cm-selectionBackground", e)))
        .reduce((e, n) => e.concat(n));
    },
    update(t, e) {
      return t.docChanged || t.selectionSet || t.viewportChanged || W7(t);
    },
    class: "cm-selectionLayer",
  }),
  YO = {
    ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } },
    ".cm-content": {
      "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } },
    },
  };
z7 && (YO[".cm-line"].caretColor = YO[".cm-content"].caretColor = "transparent !important");
const tne = zr.highest(re.theme(YO)),
  X7 = Ee.define({
    map(t, e) {
      return t == null ? null : e.mapPos(t);
    },
  }),
  Cc = Qt.define({
    create() {
      return null;
    },
    update(t, e) {
      return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => (r.is(X7) ? r.value : n), t);
    },
  }),
  nne = At.fromClass(
    class {
      constructor(t) {
        (this.view = t), (this.cursor = null), (this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) });
      }
      update(t) {
        var e;
        let n = t.state.field(Cc);
        n == null
          ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), (this.cursor = null))
          : (this.cursor ||
              ((this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"))), (this.cursor.className = "cm-dropCursor")),
            (t.startState.field(Cc) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
      }
      readPos() {
        let { view: t } = this,
          e = t.state.field(Cc),
          n = e != null && t.coordsAtPos(e);
        if (!n) return null;
        let r = t.scrollDOM.getBoundingClientRect();
        return {
          left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
          top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
          height: n.bottom - n.top,
        };
      }
      drawCursor(t) {
        if (this.cursor) {
          let { scaleX: e, scaleY: n } = this.view;
          t
            ? ((this.cursor.style.left = t.left / e + "px"),
              (this.cursor.style.top = t.top / n + "px"),
              (this.cursor.style.height = t.height / n + "px"))
            : (this.cursor.style.left = "-100000px");
        }
      }
      destroy() {
        this.cursor && this.cursor.remove();
      }
      setDropPos(t) {
        this.view.state.field(Cc) != t && this.view.dispatch({ effects: X7.of(t) });
      }
    },
    {
      eventObservers: {
        dragover(t) {
          this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
        },
        dragleave(t) {
          (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
        },
        dragend() {
          this.setDropPos(null);
        },
        drop() {
          this.setDropPos(null);
        },
      },
    }
  );
function rne() {
  return [Cc, nne];
}
function b5(t, e, n, r, i) {
  e.lastIndex = 0;
  for (let o = t.iterRange(n, r), s = n, l; !o.next().done; s += o.value.length)
    if (!o.lineBreak) for (; (l = e.exec(o.value)); ) i(s + l.index, l);
}
function ine(t, e) {
  let n = t.visibleRanges;
  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to) return n;
  let r = [];
  for (let { from: i, to: o } of n)
    (i = Math.max(t.state.doc.lineAt(i).from, i - e)),
      (o = Math.min(t.state.doc.lineAt(o).to, o + e)),
      r.length && r[r.length - 1].to >= i ? (r[r.length - 1].to = o) : r.push({ from: i, to: o });
  return r;
}
class one {
  constructor(e) {
    const { regexp: n, decoration: r, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
    if (!n.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (((this.regexp = n), i)) this.addMatch = (l, a, c, u) => i(u, c, c + l[0].length, l, a);
    else if (typeof r == "function")
      this.addMatch = (l, a, c, u) => {
        let h = r(l, a, c);
        h && u(c, c + l[0].length, h);
      };
    else if (r) this.addMatch = (l, a, c, u) => u(c, c + l[0].length, r);
    else throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    (this.boundary = o), (this.maxLength = s);
  }
  createDeco(e) {
    let n = new lr(),
      r = n.add.bind(n);
    for (let { from: i, to: o } of ine(e, this.maxLength)) b5(e.state.doc, this.regexp, i, o, (s, l) => this.addMatch(l, e, s, r));
    return n.finish();
  }
  updateDeco(e, n) {
    let r = 1e9,
      i = -1;
    return (
      e.docChanged &&
        e.changes.iterChanges((o, s, l, a) => {
          a > e.view.viewport.from && l < e.view.viewport.to && ((r = Math.min(l, r)), (i = Math.max(a, i)));
        }),
      e.viewportChanged || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n
    );
  }
  updateRange(e, n, r, i) {
    for (let o of e.visibleRanges) {
      let s = Math.max(o.from, r),
        l = Math.min(o.to, i);
      if (l > s) {
        let a = e.state.doc.lineAt(s),
          c = a.to < l ? e.state.doc.lineAt(l) : a,
          u = Math.max(o.from, a.from),
          h = Math.min(o.to, c.to);
        if (this.boundary) {
          for (; s > a.from; s--)
            if (this.boundary.test(a.text[s - 1 - a.from])) {
              u = s;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              h = l;
              break;
            }
        }
        let d = [],
          f,
          p = (m, O, v) => d.push(v.range(m, O));
        if (a == c)
          for (this.regexp.lastIndex = u - a.from; (f = this.regexp.exec(a.text)) && f.index < h - a.from; )
            this.addMatch(f, e, f.index + a.from, p);
        else b5(e.state.doc, this.regexp, u, h, (m, O) => this.addMatch(O, e, m, p));
        n = n.update({ filterFrom: u, filterTo: h, filter: (m, O) => m < u || O > h, add: d });
      }
    }
    return n;
  }
}
const GO = /x/.unicode != null ? "gu" : "g",
  sne = new RegExp(
    `[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`,
    GO
  ),
  lne = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement",
  };
let d1 = null;
function ane() {
  var t;
  if (d1 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    d1 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return d1 || !1;
}
const sf = xe.define({
  combine(t) {
    let e = Si(t, { render: null, specialChars: sne, addSpecialChars: null });
    return (
      (e.replaceTabs = !ane()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, GO)),
      e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, GO)),
      e
    );
  },
});
function U7(t = {}) {
  return [sf.of(t), cne()];
}
let x5 = null;
function cne() {
  return (
    x5 ||
    (x5 = At.fromClass(
      class {
        constructor(t) {
          (this.view = t),
            (this.decorations = me.none),
            (this.decorationCache = Object.create(null)),
            (this.decorator = this.makeDecorator(t.state.facet(sf))),
            (this.decorations = this.decorator.createDeco(t));
        }
        makeDecorator(t) {
          return new one({
            regexp: t.specialChars,
            decoration: (e, n, r) => {
              let { doc: i } = n.state,
                o = an(e[0], 0);
              if (o == 9) {
                let s = i.lineAt(r),
                  l = n.state.tabSize,
                  a = Nr(s.text, l, r - s.from);
                return me.replace({ widget: new fne(((l - (a % l)) * this.view.defaultCharacterWidth) / this.view.scaleX) });
              }
              return this.decorationCache[o] || (this.decorationCache[o] = me.replace({ widget: new dne(t, o) }));
            },
            boundary: t.replaceTabs ? void 0 : /[^]/,
          });
        }
        update(t) {
          let e = t.state.facet(sf);
          t.startState.facet(sf) != e
            ? ((this.decorator = this.makeDecorator(e)), (this.decorations = this.decorator.createDeco(t.view)))
            : (this.decorations = this.decorator.updateDeco(t, this.decorations));
        }
      },
      { decorations: (t) => t.decorations }
    ))
  );
}
const une = "•";
function hne(t) {
  return t >= 32 ? une : t == 10 ? "␤" : String.fromCharCode(9216 + t);
}
class dne extends Wr {
  constructor(e, n) {
    super(), (this.options = e), (this.code = n);
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = hne(this.code),
      r = e.state.phrase("Control character") + " " + (lne[this.code] || "0x" + this.code.toString(16)),
      i = this.options.render && this.options.render(this.code, r, n);
    if (i) return i;
    let o = document.createElement("span");
    return (o.textContent = n), (o.title = r), o.setAttribute("aria-label", r), (o.className = "cm-specialChar"), o;
  }
  ignoreEvent() {
    return !1;
  }
}
class fne extends Wr {
  constructor(e) {
    super(), (this.width = e);
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return (e.textContent = "	"), (e.className = "cm-tab"), (e.style.width = this.width + "px"), e;
  }
  ignoreEvent() {
    return !1;
  }
}
function H7() {
  return mne;
}
const pne = me.line({ class: "cm-activeLine" }),
  mne = At.fromClass(
    class {
      constructor(t) {
        this.decorations = this.getDeco(t);
      }
      update(t) {
        (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
      }
      getDeco(t) {
        let e = -1,
          n = [];
        for (let r of t.state.selection.ranges) {
          let i = t.lineBlockAt(r.head);
          i.from > e && (n.push(pne.range(i.from)), (e = i.from));
        }
        return me.set(n);
      }
    },
    { decorations: (t) => t.decorations }
  ),
  JO = 2e3;
function gne(t, e, n) {
  let r = Math.min(e.line, n.line),
    i = Math.max(e.line, n.line),
    o = [];
  if (e.off > JO || n.off > JO || e.col < 0 || n.col < 0) {
    let s = Math.min(e.off, n.off),
      l = Math.max(e.off, n.off);
    for (let a = r; a <= i; a++) {
      let c = t.doc.line(a);
      c.length <= l && o.push(H.range(c.from + s, c.to + l));
    }
  } else {
    let s = Math.min(e.col, n.col),
      l = Math.max(e.col, n.col);
    for (let a = r; a <= i; a++) {
      let c = t.doc.line(a),
        u = PO(c.text, s, t.tabSize, !0);
      if (u < 0) o.push(H.cursor(c.to));
      else {
        let h = PO(c.text, l, t.tabSize);
        o.push(H.range(c.from + u, c.from + h));
      }
    }
  }
  return o;
}
function One(t, e) {
  let n = t.coordsAtPos(t.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
}
function y5(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    r = t.state.doc.lineAt(n),
    i = n - r.from,
    o = i > JO ? -1 : i == r.length ? One(t, e.clientX) : Nr(r.text, t.state.tabSize, n - r.from);
  return { line: r.number, col: o, off: i };
}
function vne(t, e) {
  let n = y5(t, e),
    r = t.state.selection;
  return n
    ? {
        update(i) {
          if (i.docChanged) {
            let o = i.changes.mapPos(i.startState.doc.line(n.line).from),
              s = i.state.doc.lineAt(o);
            (n = { line: s.number, col: n.col, off: Math.min(n.off, s.length) }), (r = r.map(i.changes));
          }
        },
        get(i, o, s) {
          let l = y5(t, i);
          if (!l) return r;
          let a = gne(t.state, n, l);
          return a.length ? (s ? H.create(a.concat(r.ranges)) : H.create(a)) : r;
        },
      }
    : null;
}
function bne(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((n) => n.altKey && n.button == 0);
  return re.mouseSelectionStyle.of((n, r) => (e(r) ? vne(n, r) : null));
}
const xne = {
    Alt: [18, (t) => !!t.altKey],
    Control: [17, (t) => !!t.ctrlKey],
    Shift: [16, (t) => !!t.shiftKey],
    Meta: [91, (t) => !!t.metaKey],
  },
  yne = { style: "cursor: crosshair" };
function wne(t = {}) {
  let [e, n] = xne[t.key || "Alt"],
    r = At.fromClass(
      class {
        constructor(i) {
          (this.view = i), (this.isDown = !1);
        }
        set(i) {
          this.isDown != i && ((this.isDown = i), this.view.update([]));
        }
      },
      {
        eventObservers: {
          keydown(i) {
            this.set(i.keyCode == e || n(i));
          },
          keyup(i) {
            (i.keyCode == e || !n(i)) && this.set(!1);
          },
          mousemove(i) {
            this.set(n(i));
          },
        },
      }
    );
  return [
    r,
    re.contentAttributes.of((i) => {
      var o;
      return !((o = i.plugin(r)) === null || o === void 0) && o.isDown ? yne : null;
    }),
  ];
}
const sc = "-10000px";
class q7 {
  constructor(e, n, r, i) {
    (this.facet = n),
      (this.createTooltipView = r),
      (this.removeTooltipView = i),
      (this.input = e.state.facet(n)),
      (this.tooltips = this.input.filter((s) => s));
    let o = null;
    this.tooltipViews = this.tooltips.map((s) => (o = r(s, o)));
  }
  update(e, n) {
    var r;
    let i = e.state.facet(this.facet),
      o = i.filter((a) => a);
    if (i === this.input) {
      for (let a of this.tooltipViews) a.update && a.update(e);
      return !1;
    }
    let s = [],
      l = n ? [] : null;
    for (let a = 0; a < o.length; a++) {
      let c = o[a],
        u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let d = this.tooltips[h];
          d && d.create == c.create && (u = h);
        }
        if (u < 0) (s[a] = this.createTooltipView(c, a ? s[a - 1] : null)), l && (l[a] = !!c.above);
        else {
          let h = (s[a] = this.tooltipViews[u]);
          l && (l[a] = n[u]), h.update && h.update(e);
        }
      }
    }
    for (let a of this.tooltipViews) s.indexOf(a) < 0 && (this.removeTooltipView(a), (r = a.destroy) === null || r === void 0 || r.call(a));
    return (
      n && (l.forEach((a, c) => (n[c] = a)), (n.length = l.length)), (this.input = i), (this.tooltips = o), (this.tooltipViews = s), !0
    );
  }
}
function Sne(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const f1 = xe.define({
    combine: (t) => {
      var e, n, r;
      return {
        position: be.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
        parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
        tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || Sne,
      };
    },
  }),
  w5 = new WeakMap(),
  Ly = At.fromClass(
    class {
      constructor(t) {
        (this.view = t),
          (this.above = []),
          (this.inView = !0),
          (this.madeAbsolute = !1),
          (this.lastTransaction = 0),
          (this.measureTimeout = -1);
        let e = t.state.facet(f1);
        (this.position = e.position),
          (this.parent = e.parent),
          (this.classes = t.themeClasses),
          this.createContainer(),
          (this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }),
          (this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null),
          (this.manager = new q7(
            t,
            Ny,
            (n, r) => this.createTooltip(n, r),
            (n) => {
              this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
            }
          )),
          (this.above = this.manager.tooltips.map((n) => !!n.above)),
          (this.intersectionObserver =
            typeof IntersectionObserver == "function"
              ? new IntersectionObserver(
                  (n) => {
                    Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
                  },
                  { threshold: [1] }
                )
              : null),
          this.observeIntersection(),
          t.win.addEventListener("resize", (this.measureSoon = this.measureSoon.bind(this))),
          this.maybeMeasure();
      }
      createContainer() {
        this.parent
          ? ((this.container = document.createElement("div")),
            (this.container.style.position = "relative"),
            (this.container.className = this.view.themeClasses),
            this.parent.appendChild(this.container))
          : (this.container = this.view.dom);
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          for (let t of this.manager.tooltipViews) this.intersectionObserver.observe(t.dom);
        }
      }
      measureSoon() {
        this.measureTimeout < 0 &&
          (this.measureTimeout = setTimeout(() => {
            (this.measureTimeout = -1), this.maybeMeasure();
          }, 50));
      }
      update(t) {
        t.transactions.length && (this.lastTransaction = Date.now());
        let e = this.manager.update(t, this.above);
        e && this.observeIntersection();
        let n = e || t.geometryChanged,
          r = t.state.facet(f1);
        if (r.position != this.position && !this.madeAbsolute) {
          this.position = r.position;
          for (let i of this.manager.tooltipViews) i.dom.style.position = this.position;
          n = !0;
        }
        if (r.parent != this.parent) {
          this.parent && this.container.remove(), (this.parent = r.parent), this.createContainer();
          for (let i of this.manager.tooltipViews) this.container.appendChild(i.dom);
          n = !0;
        } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
        n && this.maybeMeasure();
      }
      createTooltip(t, e) {
        let n = t.create(this.view),
          r = e ? e.dom : null;
        if ((n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow"))) {
          let i = document.createElement("div");
          (i.className = "cm-tooltip-arrow"), n.dom.appendChild(i);
        }
        return (
          (n.dom.style.position = this.position),
          (n.dom.style.top = sc),
          (n.dom.style.left = "0px"),
          this.container.insertBefore(n.dom, r),
          n.mount && n.mount(this.view),
          this.resizeObserver && this.resizeObserver.observe(n.dom),
          n
        );
      }
      destroy() {
        var t, e, n;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let r of this.manager.tooltipViews) r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
        this.parent && this.container.remove(),
          (e = this.resizeObserver) === null || e === void 0 || e.disconnect(),
          (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(),
          clearTimeout(this.measureTimeout);
      }
      readMeasure() {
        let t = this.view.dom.getBoundingClientRect(),
          e = 1,
          n = 1,
          r = !1;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
          let { dom: i } = this.manager.tooltipViews[0];
          if (be.gecko) r = i.offsetParent != this.container.ownerDocument.body;
          else if (i.style.top == sc && i.style.left == "0px") {
            let o = i.getBoundingClientRect();
            r = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
          }
        }
        if (r || this.position == "absolute")
          if (this.parent) {
            let i = this.parent.getBoundingClientRect();
            i.width && i.height && ((e = i.width / this.parent.offsetWidth), (n = i.height / this.parent.offsetHeight));
          } else ({ scaleX: e, scaleY: n } = this.view.viewState);
        return {
          editor: t,
          parent: this.parent ? this.container.getBoundingClientRect() : t,
          pos: this.manager.tooltips.map((i, o) => {
            let s = this.manager.tooltipViews[o];
            return s.getCoords ? s.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
          }),
          size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
          space: this.view.state.facet(f1).tooltipSpace(this.view),
          scaleX: e,
          scaleY: n,
          makeAbsolute: r,
        };
      }
      writeMeasure(t) {
        var e;
        if (t.makeAbsolute) {
          (this.madeAbsolute = !0), (this.position = "absolute");
          for (let l of this.manager.tooltipViews) l.dom.style.position = "absolute";
        }
        let { editor: n, space: r, scaleX: i, scaleY: o } = t,
          s = [];
        for (let l = 0; l < this.manager.tooltips.length; l++) {
          let a = this.manager.tooltips[l],
            c = this.manager.tooltipViews[l],
            { dom: u } = c,
            h = t.pos[l],
            d = t.size[l];
          if (
            !h ||
            h.bottom <= Math.max(n.top, r.top) ||
            h.top >= Math.min(n.bottom, r.bottom) ||
            h.right < Math.max(n.left, r.left) - 0.1 ||
            h.left > Math.min(n.right, r.right) + 0.1
          ) {
            u.style.top = sc;
            continue;
          }
          let f = a.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null,
            p = f ? 7 : 0,
            m = d.right - d.left,
            O = (e = w5.get(c)) !== null && e !== void 0 ? e : d.bottom - d.top,
            v = c.offset || Cne,
            g = this.view.textDirection == wt.LTR,
            b =
              d.width > r.right - r.left
                ? g
                  ? r.left
                  : r.right - d.width
                : g
                ? Math.min(h.left - (f ? 14 : 0) + v.x, r.right - m)
                : Math.max(r.left, h.left - m + (f ? 14 : 0) - v.x),
            x = this.above[l];
          !a.strictSide &&
            (x ? h.top - (d.bottom - d.top) - v.y < r.top : h.bottom + (d.bottom - d.top) + v.y > r.bottom) &&
            x == r.bottom - h.bottom > h.top - r.top &&
            (x = this.above[l] = !x);
          let k = (x ? h.top - r.top : r.bottom - h.bottom) - p;
          if (k < O && c.resize !== !1) {
            if (k < this.view.defaultLineHeight) {
              u.style.top = sc;
              continue;
            }
            w5.set(c, O), (u.style.height = (O = k) / o + "px");
          } else u.style.height && (u.style.height = "");
          let w = x ? h.top - O - p - v.y : h.bottom + p + v.y,
            y = b + m;
          if (c.overlap !== !0)
            for (let C of s) C.left < y && C.right > b && C.top < w + O && C.bottom > w && (w = x ? C.top - O - 2 - p : C.bottom + p + 2);
          if (
            (this.position == "absolute"
              ? ((u.style.top = (w - t.parent.top) / o + "px"), (u.style.left = (b - t.parent.left) / i + "px"))
              : ((u.style.top = w / o + "px"), (u.style.left = b / i + "px")),
            f)
          ) {
            let C = h.left + (g ? v.x : -v.x) - (b + 14 - 7);
            f.style.left = C / i + "px";
          }
          c.overlap !== !0 && s.push({ left: b, top: w, right: y, bottom: w + O }),
            u.classList.toggle("cm-tooltip-above", x),
            u.classList.toggle("cm-tooltip-below", !x),
            c.positioned && c.positioned(t.space);
        }
      }
      maybeMeasure() {
        if (
          this.manager.tooltips.length &&
          (this.view.inView && this.view.requestMeasure(this.measureReq),
          this.inView != this.view.inView && ((this.inView = this.view.inView), !this.inView))
        )
          for (let t of this.manager.tooltipViews) t.dom.style.top = sc;
      }
    },
    {
      eventObservers: {
        scroll() {
          this.maybeMeasure();
        },
      },
    }
  ),
  kne = re.baseTheme({
    ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" },
    "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" },
    "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" },
    "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" },
    ".cm-tooltip-arrow": {
      height: "7px",
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: "7px solid transparent",
        borderRight: "7px solid transparent",
      },
      ".cm-tooltip-above &": {
        bottom: "-7px",
        "&:before": { borderTop: "7px solid #bbb" },
        "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" },
      },
      ".cm-tooltip-below &": {
        top: "-7px",
        "&:before": { borderBottom: "7px solid #bbb" },
        "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" },
      },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" },
      "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" },
    },
  }),
  Cne = { x: 0, y: 0 },
  Ny = xe.define({ enables: [Ly, kne] }),
  dp = xe.define({ combine: (t) => t.reduce((e, n) => e.concat(n), []) });
class Gm {
  static create(e) {
    return new Gm(e);
  }
  constructor(e) {
    (this.view = e),
      (this.mounted = !1),
      (this.dom = document.createElement("div")),
      this.dom.classList.add("cm-tooltip-hover"),
      (this.manager = new q7(
        e,
        dp,
        (n, r) => this.createHostedView(n, r),
        (n) => n.dom.remove()
      ));
  }
  createHostedView(e, n) {
    let r = e.create(this.view);
    return (
      r.dom.classList.add("cm-tooltip-section"),
      this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild),
      this.mounted && r.mount && r.mount(this.view),
      r
    );
  }
  mount(e) {
    for (let n of this.manager.tooltipViews) n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews) n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews) (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (n === void 0) n = i;
        else if (n !== i) return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const _ne = Ny.compute([dp], (t) => {
  let e = t.facet(dp);
  return e.length === 0
    ? null
    : {
        pos: Math.min(...e.map((n) => n.pos)),
        end: Math.max(
          ...e.map((n) => {
            var r;
            return (r = n.end) !== null && r !== void 0 ? r : n.pos;
          })
        ),
        create: Gm.create,
        above: e[0].above,
        arrow: e.some((n) => n.arrow),
      };
});
class Ene {
  constructor(e, n, r, i, o) {
    (this.view = e),
      (this.source = n),
      (this.field = r),
      (this.setHover = i),
      (this.hoverTime = o),
      (this.hoverTimeout = -1),
      (this.restartTimeout = -1),
      (this.pending = null),
      (this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }),
      (this.checkHover = this.checkHover.bind(this)),
      e.dom.addEventListener("mouseleave", (this.mouseleave = this.mouseleave.bind(this))),
      e.dom.addEventListener("mousemove", (this.mousemove = this.mousemove.bind(this)));
  }
  update() {
    this.pending &&
      ((this.pending = null), clearTimeout(this.restartTimeout), (this.restartTimeout = setTimeout(() => this.startHover(), 20)));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (((this.hoverTimeout = -1), this.active.length)) return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e)) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this,
      r = e.docView.nearest(n.target);
    if (!r) return;
    let i,
      o = 1;
    if (r instanceof wo) i = r.posAtStart;
    else {
      if (((i = e.posAtCoords(n)), i == null)) return;
      let l = e.coordsAtPos(i);
      if (!l || n.y < l.top || n.y > l.bottom || n.x < l.left - e.defaultCharacterWidth || n.x > l.right + e.defaultCharacterWidth) return;
      let a = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i),
        c = a && a.dir == wt.RTL ? -1 : 1;
      o = n.x < l.left ? -c : c;
    }
    let s = this.source(e, i, o);
    if (s != null && s.then) {
      let l = (this.pending = { pos: i });
      s.then(
        (a) => {
          this.pending == l &&
            ((this.pending = null),
            a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) }));
        },
        (a) => jn(e.state, a, "hover tooltip")
      );
    } else s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let e = this.view.plugin(Ly),
      n = e ? e.manager.tooltips.findIndex((r) => r.create == Gm.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, r;
    (this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }),
      this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: o } = this;
    if ((i.length && o && !Tne(o.dom, e)) || this.pending) {
      let { pos: s } = i[0] || this.pending,
        l = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : s;
      (s == l ? this.view.posAtCoords(this.lastMove) != s : !Pne(this.view, s, l, e.clientX, e.clientY)) &&
        (this.view.dispatch({ effects: this.setHover.of([]) }), (this.pending = null));
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), (this.hoverTimeout = -1);
    let { active: n } = this;
    if (n.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (r) => {
      e.removeEventListener("mouseleave", n),
        this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout),
      this.view.dom.removeEventListener("mouseleave", this.mouseleave),
      this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Od = 4;
function Tne(t, e) {
  let n = t.getBoundingClientRect();
  return e.clientX >= n.left - Od && e.clientX <= n.right + Od && e.clientY >= n.top - Od && e.clientY <= n.bottom + Od;
}
function Pne(t, e, n, r, i, o) {
  let s = t.scrollDOM.getBoundingClientRect(),
    l = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (s.left > r || s.right < r || s.top > i || Math.min(s.bottom, l) < i) return !1;
  let a = t.posAtCoords({ x: r, y: i }, !1);
  return a >= e && a <= n;
}
function Ane(t, e = {}) {
  let n = Ee.define(),
    r = Qt.define({
      create() {
        return [];
      },
      update(i, o) {
        if (
          i.length &&
          (e.hideOnChange && (o.docChanged || o.selection) ? (i = []) : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)
        ) {
          let s = [];
          for (let l of i) {
            let a = o.changes.mapPos(l.pos, -1, un.TrackDel);
            if (a != null) {
              let c = Object.assign(Object.create(null), l);
              (c.pos = a), c.end != null && (c.end = o.changes.mapPos(c.end)), s.push(c);
            }
          }
          i = s;
        }
        for (let s of o.effects) s.is(n) && (i = s.value), s.is($ne) && (i = []);
        return i;
      },
      provide: (i) => dp.from(i),
    });
  return [r, At.define((i) => new Ene(i, t, r, n, e.hoverTime || 300)), _ne];
}
function Y7(t, e) {
  let n = t.plugin(Ly);
  if (!n) return null;
  let r = n.manager.tooltips.indexOf(e);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const $ne = Ee.define(),
  S5 = xe.define({
    combine(t) {
      let e, n;
      for (let r of t) (e = e || r.topContainer), (n = n || r.bottomContainer);
      return { topContainer: e, bottomContainer: n };
    },
  });
function Su(t, e) {
  let n = t.plugin(G7),
    r = n ? n.specs.indexOf(e) : -1;
  return r > -1 ? n.panels[r] : null;
}
const G7 = At.fromClass(
  class {
    constructor(t) {
      (this.input = t.state.facet(ku)), (this.specs = this.input.filter((n) => n)), (this.panels = this.specs.map((n) => n(t)));
      let e = t.state.facet(S5);
      (this.top = new vd(t, !0, e.topContainer)),
        (this.bottom = new vd(t, !1, e.bottomContainer)),
        this.top.sync(this.panels.filter((n) => n.top)),
        this.bottom.sync(this.panels.filter((n) => !n.top));
      for (let n of this.panels) n.dom.classList.add("cm-panel"), n.mount && n.mount();
    }
    update(t) {
      let e = t.state.facet(S5);
      this.top.container != e.topContainer && (this.top.sync([]), (this.top = new vd(t.view, !0, e.topContainer))),
        this.bottom.container != e.bottomContainer && (this.bottom.sync([]), (this.bottom = new vd(t.view, !1, e.bottomContainer))),
        this.top.syncClasses(),
        this.bottom.syncClasses();
      let n = t.state.facet(ku);
      if (n != this.input) {
        let r = n.filter((a) => a),
          i = [],
          o = [],
          s = [],
          l = [];
        for (let a of r) {
          let c = this.specs.indexOf(a),
            u;
          c < 0 ? ((u = a(t.view)), l.push(u)) : ((u = this.panels[c]), u.update && u.update(t)), i.push(u), (u.top ? o : s).push(u);
        }
        (this.specs = r), (this.panels = i), this.top.sync(o), this.bottom.sync(s);
        for (let a of l) a.dom.classList.add("cm-panel"), a.mount && a.mount();
      } else for (let r of this.panels) r.update && r.update(t);
    }
    destroy() {
      this.top.sync([]), this.bottom.sync([]);
    }
  },
  {
    provide: (t) =>
      re.scrollMargins.of((e) => {
        let n = e.plugin(t);
        return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
      }),
  }
);
class vd {
  constructor(e, n, r) {
    (this.view = e), (this.top = n), (this.container = r), (this.dom = void 0), (this.classes = ""), (this.panels = []), this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels) n.destroy && e.indexOf(n) < 0 && n.destroy();
    (this.panels = e), this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), (this.dom = void 0));
      return;
    }
    if (!this.dom) {
      (this.dom = document.createElement("div")),
        (this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom"),
        (this.dom.style[this.top ? "top" : "bottom"] = "0");
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; ) e = k5(e);
        e = e.nextSibling;
      } else this.dom.insertBefore(n.dom, e);
    for (; e; ) e = k5(e);
  }
  scrollMargin() {
    return !this.dom || this.container
      ? 0
      : Math.max(
          0,
          this.top
            ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
            : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top
        );
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" ")) e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" ")) e && this.container.classList.add(e);
    }
  }
}
function k5(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const ku = xe.define({ enables: G7 });
class yi extends Is {
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  eq(e) {
    return !1;
  }
  destroy(e) {}
}
yi.prototype.elementClass = "";
yi.prototype.toDOM = void 0;
yi.prototype.mapMode = un.TrackBefore;
yi.prototype.startSide = yi.prototype.endSide = -1;
yi.prototype.point = !0;
const lf = xe.define(),
  Rne = {
    class: "",
    renderEmptyElements: !1,
    elementStyle: "",
    markers: () => ze.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {},
  },
  zc = xe.define();
function J7(t) {
  return [K7(), zc.of(Object.assign(Object.assign({}, Rne), t))];
}
const KO = xe.define({ combine: (t) => t.some((e) => e) });
function K7(t) {
  let e = [Ine];
  return t && t.fixed === !1 && e.push(KO.of(!0)), e;
}
const Ine = At.fromClass(
  class {
    constructor(t) {
      (this.view = t),
        (this.prevViewport = t.viewport),
        (this.dom = document.createElement("div")),
        (this.dom.className = "cm-gutters"),
        this.dom.setAttribute("aria-hidden", "true"),
        (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
        (this.gutters = t.state.facet(zc).map((e) => new _5(t, e)));
      for (let e of this.gutters) this.dom.appendChild(e.dom);
      (this.fixed = !t.state.facet(KO)),
        this.fixed && (this.dom.style.position = "sticky"),
        this.syncGutters(!1),
        t.scrollDOM.insertBefore(this.dom, t.contentDOM);
    }
    update(t) {
      if (this.updateGutters(t)) {
        let e = this.prevViewport,
          n = t.view.viewport,
          r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
        this.syncGutters(r < (n.to - n.from) * 0.8);
      }
      t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
        this.view.state.facet(KO) != !this.fixed && ((this.fixed = !this.fixed), (this.dom.style.position = this.fixed ? "sticky" : "")),
        (this.prevViewport = t.view.viewport);
    }
    syncGutters(t) {
      let e = this.dom.nextSibling;
      t && this.dom.remove();
      let n = ze.iter(this.view.state.facet(lf), this.view.viewport.from),
        r = [],
        i = this.gutters.map((o) => new Mne(o, this.view.viewport, -this.view.documentPadding.top));
      for (let o of this.view.viewportLineBlocks)
        if ((r.length && (r = []), Array.isArray(o.type))) {
          let s = !0;
          for (let l of o.type)
            if (l.type == Pn.Text && s) {
              ev(n, r, l.from);
              for (let a of i) a.line(this.view, l, r);
              s = !1;
            } else if (l.widget) for (let a of i) a.widget(this.view, l);
        } else if (o.type == Pn.Text) {
          ev(n, r, o.from);
          for (let s of i) s.line(this.view, o, r);
        } else if (o.widget) for (let s of i) s.widget(this.view, o);
      for (let o of i) o.finish();
      t && this.view.scrollDOM.insertBefore(this.dom, e);
    }
    updateGutters(t) {
      let e = t.startState.facet(zc),
        n = t.state.facet(zc),
        r =
          t.docChanged ||
          t.heightChanged ||
          t.viewportChanged ||
          !ze.eq(t.startState.facet(lf), t.state.facet(lf), t.view.viewport.from, t.view.viewport.to);
      if (e == n) for (let i of this.gutters) i.update(t) && (r = !0);
      else {
        r = !0;
        let i = [];
        for (let o of n) {
          let s = e.indexOf(o);
          s < 0 ? i.push(new _5(this.view, o)) : (this.gutters[s].update(t), i.push(this.gutters[s]));
        }
        for (let o of this.gutters) o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
        for (let o of i) this.dom.appendChild(o.dom);
        this.gutters = i;
      }
      return r;
    }
    destroy() {
      for (let t of this.gutters) t.destroy();
      this.dom.remove();
    }
  },
  {
    provide: (t) =>
      re.scrollMargins.of((e) => {
        let n = e.plugin(t);
        return !n || n.gutters.length == 0 || !n.fixed
          ? null
          : e.textDirection == wt.LTR
          ? { left: n.dom.offsetWidth * e.scaleX }
          : { right: n.dom.offsetWidth * e.scaleX };
      }),
  }
);
function C5(t) {
  return Array.isArray(t) ? t : [t];
}
function ev(t, e, n) {
  for (; t.value && t.from <= n; ) t.from == n && e.push(t.value), t.next();
}
class Mne {
  constructor(e, n, r) {
    (this.gutter = e), (this.height = r), (this.i = 0), (this.cursor = ze.iter(e.markers, n.from));
  }
  addElement(e, n, r) {
    let { gutter: i } = this,
      o = (n.top - this.height) / e.scaleY,
      s = n.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new e4(e, s, o, r);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else i.elements[this.i].update(e, s, o, r);
    (this.height = n.bottom), this.i++;
  }
  line(e, n, r) {
    let i = [];
    ev(this.cursor, i, n.from), r.length && (i = i.concat(r));
    let o = this.gutter.config.lineMarker(e, n, i);
    o && i.unshift(o);
    let s = this.gutter;
    (i.length == 0 && !s.config.renderEmptyElements) || this.addElement(e, n, i);
  }
  widget(e, n) {
    let r = this.gutter.config.widgetMarker(e, n.widget, n);
    r && this.addElement(e, n, [r]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class _5 {
  constructor(e, n) {
    (this.view = e),
      (this.config = n),
      (this.elements = []),
      (this.spacer = null),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""));
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let o = i.target,
          s;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; ) o = o.parentNode;
          let a = o.getBoundingClientRect();
          s = (a.top + a.bottom) / 2;
        } else s = i.clientY;
        let l = e.lineBlockAtHeight(s - e.documentTop);
        n.domEventHandlers[r](e, l, i) && i.preventDefault();
      });
    (this.markers = C5(n.markers(e))),
      n.initialSpacer &&
        ((this.spacer = new e4(e, 0, 0, [n.initialSpacer(e)])),
        this.dom.appendChild(this.spacer.dom),
        (this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none"));
  }
  update(e) {
    let n = this.markers;
    if (((this.markers = C5(this.config.markers(e.view))), this.spacer && this.config.updateSpacer)) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !ze.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements) e.destroy();
  }
}
class e4 {
  constructor(e, n, r, i) {
    (this.height = -1),
      (this.above = 0),
      (this.markers = []),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-gutterElement"),
      this.update(e, n, r, i);
  }
  update(e, n, r, i) {
    this.height != n && ((this.height = n), (this.dom.style.height = n + "px")),
      this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""),
      Lne(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, n) {
    let r = "cm-gutterElement",
      i = this.dom.firstChild;
    for (let o = 0, s = 0; ; ) {
      let l = s,
        a = o < n.length ? n[o++] : null,
        c = !1;
      if (a) {
        let u = a.elementClass;
        u && (r += " " + u);
        for (let h = s; h < this.markers.length; h++)
          if (this.markers[h].compare(a)) {
            (l = h), (c = !0);
            break;
          }
      } else l = this.markers.length;
      for (; s < l; ) {
        let u = this.markers[s++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), (i = h);
        }
      }
      if (!a) break;
      a.toDOM && (c ? (i = i.nextSibling) : this.dom.insertBefore(a.toDOM(e), i)), c && s++;
    }
    (this.dom.className = r), (this.markers = n);
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Lne(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) if (!t[n].compare(e[n])) return !1;
  return !0;
}
const Nne = xe.define(),
  yl = xe.define({
    combine(t) {
      return Si(
        t,
        { formatNumber: String, domEventHandlers: {} },
        {
          domEventHandlers(e, n) {
            let r = Object.assign({}, e);
            for (let i in n) {
              let o = r[i],
                s = n[i];
              r[i] = o ? (l, a, c) => o(l, a, c) || s(l, a, c) : s;
            }
            return r;
          },
        }
      );
    },
  });
class p1 extends yi {
  constructor(e) {
    super(), (this.number = e);
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function m1(t, e) {
  return t.state.facet(yl).formatNumber(e, t.state);
}
const Qne = zc.compute([yl], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Nne);
  },
  lineMarker(e, n, r) {
    return r.some((i) => i.toDOM) ? null : new p1(m1(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(yl) != e.state.facet(yl),
  initialSpacer(e) {
    return new p1(m1(e, E5(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let r = m1(n.view, E5(n.view.state.doc.lines));
    return r == e.number ? e : new p1(r);
  },
  domEventHandlers: t.facet(yl).domEventHandlers,
}));
function Jm(t = {}) {
  return [yl.of(t), K7(), Qne];
}
function E5(t) {
  let e = 9;
  for (; e < t; ) e = e * 10 + 9;
  return e;
}
const Dne = new (class extends yi {
    constructor() {
      super(...arguments), (this.elementClass = "cm-activeLineGutter");
    }
  })(),
  Fne = lf.compute(["selection"], (t) => {
    let e = [],
      n = -1;
    for (let r of t.selection.ranges) {
      let i = t.doc.lineAt(r.head).from;
      i > n && ((n = i), e.push(Dne.range(i)));
    }
    return ze.of(e);
  });
function Bne() {
  return Fne;
}
const t4 = 1024;
let Vne = 0,
  fr = class {
    constructor(e, n) {
      (this.from = e), (this.to = n);
    }
  };
class Ae {
  constructor(e = {}) {
    (this.id = Vne++),
      (this.perNode = !!e.perNode),
      (this.deserialize =
        e.deserialize ||
        (() => {
          throw new Error("This node type doesn't define a deserialize function");
        }));
  }
  add(e) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types");
    return (
      typeof e != "function" && (e = Xt.match(e)),
      (n) => {
        let r = e(n);
        return r === void 0 ? null : [this, r];
      }
    );
  }
}
Ae.closedBy = new Ae({ deserialize: (t) => t.split(" ") });
Ae.openedBy = new Ae({ deserialize: (t) => t.split(" ") });
Ae.group = new Ae({ deserialize: (t) => t.split(" ") });
Ae.isolate = new Ae({
  deserialize: (t) => {
    if (t && t != "rtl" && t != "ltr" && t != "auto") throw new RangeError("Invalid value for isolate: " + t);
    return t || "auto";
  },
});
Ae.contextHash = new Ae({ perNode: !0 });
Ae.lookAhead = new Ae({ perNode: !0 });
Ae.mounted = new Ae({ perNode: !0 });
class Cu {
  constructor(e, n, r) {
    (this.tree = e), (this.overlay = n), (this.parser = r);
  }
  static get(e) {
    return e && e.props && e.props[Ae.mounted.id];
  }
}
const jne = Object.create(null);
class Xt {
  constructor(e, n, r, i = 0) {
    (this.name = e), (this.props = n), (this.id = r), (this.flags = i);
  }
  static define(e) {
    let n = e.props && e.props.length ? Object.create(null) : jne,
      r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0),
      i = new Xt(e.name || "", n, e.id, r);
    if (e.props) {
      for (let o of e.props)
        if ((Array.isArray(o) || (o = o(i)), o)) {
          if (o[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
          n[o[0].id] = o[1];
        }
    }
    return i;
  }
  prop(e) {
    return this.props[e.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(e) {
    if (typeof e == "string") {
      if (this.name == e) return !0;
      let n = this.prop(Ae.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  static match(e) {
    let n = Object.create(null);
    for (let r in e) for (let i of r.split(" ")) n[i] = e[r];
    return (r) => {
      for (let i = r.prop(Ae.group), o = -1; o < (i ? i.length : 0); o++) {
        let s = n[o < 0 ? r.name : i[o]];
        if (s) return s;
      }
    };
  }
}
Xt.none = new Xt("", Object.create(null), 0, 8);
class Da {
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...e) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let o of e) {
        let s = o(r);
        s && (i || (i = Object.assign({}, r.props)), (i[s[0].id] = s[1]));
      }
      n.push(i ? new Xt(r.name, i, r.id, r.flags) : r);
    }
    return new Da(n);
  }
}
const bd = new WeakMap(),
  T5 = new WeakMap();
var vt;
(function (t) {
  (t[(t.ExcludeBuffers = 1)] = "ExcludeBuffers"),
    (t[(t.IncludeAnonymous = 2)] = "IncludeAnonymous"),
    (t[(t.IgnoreMounts = 4)] = "IgnoreMounts"),
    (t[(t.IgnoreOverlays = 8)] = "IgnoreOverlays");
})(vt || (vt = {}));
class Ve {
  constructor(e, n, r, i, o) {
    if (((this.type = e), (this.children = n), (this.positions = r), (this.length = i), (this.props = null), o && o.length)) {
      this.props = Object.create(null);
      for (let [s, l] of o) this.props[typeof s == "number" ? s : s.id] = l;
    }
  }
  toString() {
    let e = Cu.get(this);
    if (e && !e.overlay) return e.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), (n += i));
    }
    return this.type.name
      ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
          (n.length ? "(" + n + ")" : "")
      : n;
  }
  cursor(e = 0) {
    return new fp(this.topNode, e);
  }
  cursorAt(e, n = 0, r = 0) {
    let i = bd.get(this) || this.topNode,
      o = new fp(i);
    return o.moveTo(e, n), bd.set(this, o._tree), o;
  }
  get topNode() {
    return new bn(this, 0, 0, null);
  }
  resolve(e, n = 0) {
    let r = _u(bd.get(this) || this.topNode, e, n, !1);
    return bd.set(this, r), r;
  }
  resolveInner(e, n = 0) {
    let r = _u(T5.get(this) || this.topNode, e, n, !0);
    return T5.set(this, r), r;
  }
  resolveStack(e, n = 0) {
    return Wne(this, e, n);
  }
  iterate(e) {
    let { enter: n, leave: r, from: i = 0, to: o = this.length } = e,
      s = e.mode || 0,
      l = (s & vt.IncludeAnonymous) > 0;
    for (let a = this.cursor(s | vt.IncludeAnonymous); ; ) {
      let c = !1;
      if (a.from <= o && a.to >= i && ((!l && a.type.isAnonymous) || n(a) !== !1)) {
        if (a.firstChild()) continue;
        c = !0;
      }
      for (; c && r && (l || !a.type.isAnonymous) && r(a), !a.nextSibling(); ) {
        if (!a.parent()) return;
        c = !0;
      }
    }
  }
  prop(e) {
    return e.perNode ? (this.props ? this.props[e.id] : void 0) : this.type.prop(e);
  }
  get propValues() {
    let e = [];
    if (this.props) for (let n in this.props) e.push([+n, this.props[n]]);
    return e;
  }
  balance(e = {}) {
    return this.children.length <= 8
      ? this
      : Fy(
          Xt.none,
          this.children,
          this.positions,
          0,
          this.children.length,
          0,
          this.length,
          (n, r, i) => new Ve(this.type, n, r, i, this.propValues),
          e.makeTree || ((n, r, i) => new Ve(Xt.none, n, r, i))
        );
  }
  static build(e) {
    return Xne(e);
  }
}
Ve.empty = new Ve(Xt.none, [], [], 0);
class Qy {
  constructor(e, n) {
    (this.buffer = e), (this.index = n);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Qy(this.buffer, this.index);
  }
}
class Zo {
  constructor(e, n, r) {
    (this.buffer = e), (this.length = n), (this.set = r);
  }
  get type() {
    return Xt.none;
  }
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; ) e.push(this.childString(n)), (n = this.buffer[n + 3]);
    return e.join(",");
  }
  childString(e) {
    let n = this.buffer[e],
      r = this.buffer[e + 3],
      i = this.set.types[n],
      o = i.name;
    if ((/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), (e += 4), r == e)) return o;
    let s = [];
    for (; e < r; ) s.push(this.childString(e)), (e = this.buffer[e + 3]);
    return o + "(" + s.join(",") + ")";
  }
  findChild(e, n, r, i, o) {
    let { buffer: s } = this,
      l = -1;
    for (let a = e; a != n && !(n4(o, i, s[a + 1], s[a + 2]) && ((l = a), r > 0)); a = s[a + 3]);
    return l;
  }
  slice(e, n, r) {
    let i = this.buffer,
      o = new Uint16Array(n - e),
      s = 0;
    for (let l = e, a = 0; l < n; ) {
      (o[a++] = i[l++]), (o[a++] = i[l++] - r);
      let c = (o[a++] = i[l++] - r);
      (o[a++] = i[l++] - e), (s = Math.max(s, c));
    }
    return new Zo(o, s, this.set);
  }
}
function n4(t, e, n, r) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return r >= e && n < e;
    case 0:
      return n < e && r > e;
    case 1:
      return n <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function _u(t, e, n, r) {
  for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let s = !r && t instanceof bn && t.index < 0 ? null : t.parent;
    if (!s) return t;
    t = s;
  }
  let o = r ? 0 : vt.IgnoreOverlays;
  if (r)
    for (let s = t, l = s.parent; l; s = l, l = s.parent)
      s instanceof bn && s.index < 0 && ((i = l.enter(e, n, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t = l);
  for (;;) {
    let s = t.enter(e, n, o);
    if (!s) return t;
    t = s;
  }
}
class r4 {
  cursor(e = 0) {
    return new fp(this, e);
  }
  getChild(e, n = null, r = null) {
    let i = P5(this, e, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, n = null, r = null) {
    return P5(this, e, n, r);
  }
  resolve(e, n = 0) {
    return _u(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return _u(this, e, n, !0);
  }
  matchContext(e) {
    return tv(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e),
      r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to) break;
      i.type.isError && i.from == i.to ? ((r = n), (n = i.prevSibling)) : (n = i);
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class bn extends r4 {
  constructor(e, n, r, i) {
    super(), (this._tree = e), (this.from = n), (this.index = r), (this._parent = i);
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, r, i, o = 0) {
    for (let s = this; ; ) {
      for (let { children: l, positions: a } = s._tree, c = n > 0 ? l.length : -1; e != c; e += n) {
        let u = l[e],
          h = a[e] + s.from;
        if (n4(i, r, h, h + u.length)) {
          if (u instanceof Zo) {
            if (o & vt.ExcludeBuffers) continue;
            let d = u.findChild(0, u.buffer.length, n, r - h, i);
            if (d > -1) return new ci(new Zne(s, u, e, h), null, d);
          } else if (o & vt.IncludeAnonymous || !u.type.isAnonymous || Dy(u)) {
            let d;
            if (!(o & vt.IgnoreMounts) && (d = Cu.get(u)) && !d.overlay) return new bn(d.tree, h, e, s);
            let f = new bn(u, h, e, s);
            return o & vt.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (
        o & vt.IncludeAnonymous ||
        !s.type.isAnonymous ||
        (s.index >= 0 ? (e = s.index + n) : (e = n < 0 ? -1 : s._parent._tree.children.length), (s = s._parent), !s)
      )
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(e) {
    return this.nextChild(0, 1, e, 2);
  }
  childBefore(e) {
    return this.nextChild(this._tree.children.length - 1, -1, e, -2);
  }
  enter(e, n, r = 0) {
    let i;
    if (!(r & vt.IgnoreOverlays) && (i = Cu.get(this._tree)) && i.overlay) {
      let o = e - this.from;
      for (let { from: s, to: l } of i.overlay)
        if ((n > 0 ? s <= o : s < o) && (n < 0 ? l >= o : l > o)) return new bn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; ) e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function P5(t, e, n, r) {
  let i = t.cursor(),
    o = [];
  if (!i.firstChild()) return o;
  if (n != null) {
    for (let s = !1; !s; ) if (((s = i.type.is(n)), !i.nextSibling())) return o;
  }
  for (;;) {
    if (r != null && i.type.is(r)) return o;
    if ((i.type.is(e) && o.push(i.node), !i.nextSibling())) return r == null ? o : [];
  }
}
function tv(t, e, n = e.length - 1) {
  for (let r = t.parent; n >= 0; r = r.parent) {
    if (!r) return !1;
    if (!r.type.isAnonymous) {
      if (e[n] && e[n] != r.name) return !1;
      n--;
    }
  }
  return !0;
}
class Zne {
  constructor(e, n, r, i) {
    (this.parent = e), (this.buffer = n), (this.index = r), (this.start = i);
  }
}
class ci extends r4 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, r) {
    super(), (this.context = e), (this._parent = n), (this.index = r), (this.type = e.buffer.set.types[e.buffer.buffer[r]]);
  }
  child(e, n, r) {
    let { buffer: i } = this.context,
      o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
    return o < 0 ? null : new ci(this.context, this, o);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(e) {
    return this.child(1, e, 2);
  }
  childBefore(e) {
    return this.child(-1, e, -2);
  }
  enter(e, n, r = 0) {
    if (r & vt.ExcludeBuffers) return null;
    let { buffer: i } = this.context,
      o = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return o < 0 ? null : new ci(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
  }
  get nextSibling() {
    let { buffer: e } = this.context,
      n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length)
      ? new ci(this.context, this._parent, n)
      : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context,
      n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new ci(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [],
      n = [],
      { buffer: r } = this.context,
      i = this.index + 4,
      o = r.buffer[this.index + 3];
    if (o > i) {
      let s = r.buffer[this.index + 1];
      e.push(r.slice(i, o, s)), n.push(0);
    }
    return new Ve(this.type, e, n, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function i4(t) {
  if (!t.length) return null;
  let e = 0,
    n = t[0];
  for (let o = 1; o < t.length; o++) {
    let s = t[o];
    (s.from > n.from || s.to < n.to) && ((n = s), (e = o));
  }
  let r = n instanceof bn && n.index < 0 ? null : n.parent,
    i = t.slice();
  return r ? (i[e] = r) : i.splice(e, 1), new zne(i, n);
}
class zne {
  constructor(e, n) {
    (this.heads = e), (this.node = n);
  }
  get next() {
    return i4(this.heads);
  }
}
function Wne(t, e, n) {
  let r = t.resolveInner(e, n),
    i = null;
  for (let o = r instanceof bn ? r : r.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let s = o.parent;
      (i || (i = [r])).push(s.resolve(e, n)), (o = s);
    } else {
      let s = Cu.get(o.tree);
      if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
        let l = new bn(s.tree, s.overlay[0].from + o.from, -1, o);
        (i || (i = [r])).push(_u(l, e, n, !1));
      }
    }
  return i ? i4(i) : r;
}
class fp {
  get name() {
    return this.type.name;
  }
  constructor(e, n = 0) {
    if (((this.mode = n), (this.buffer = null), (this.stack = []), (this.index = 0), (this.bufferNode = null), e instanceof bn))
      this.yieldNode(e);
    else {
      (this._tree = e.context.parent), (this.buffer = e.context);
      for (let r = e._parent; r; r = r._parent) this.stack.unshift(r.index);
      (this.bufferNode = e), this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? ((this._tree = e), (this.type = e.type), (this.from = e.from), (this.to = e.to), !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return (this.type = n || i.set.types[i.buffer[e]]), (this.from = r + i.buffer[e + 1]), (this.to = r + i.buffer[e + 2]), !0;
  }
  yield(e) {
    return e
      ? e instanceof bn
        ? ((this.buffer = null), this.yieldNode(e))
        : ((this.buffer = e.context), this.yieldBuf(e.index, e.type))
      : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(e, n, r) {
    if (!this.buffer) return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
    let { buffer: i } = this.buffer,
      o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(e) {
    return this.enterChild(1, e, 2);
  }
  childBefore(e) {
    return this.enterChild(-1, e, -2);
  }
  enter(e, n, r = this.mode) {
    return this.buffer ? (r & vt.ExcludeBuffers ? !1 : this.enterChild(1, e, n)) : this.yield(this._tree.enter(e, n, r));
  }
  parent() {
    if (!this.buffer) return this.yieldNode(this.mode & vt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let e = this.mode & vt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return (this.buffer = null), this.yieldNode(e);
  }
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent
        ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode))
        : !1;
    let { buffer: n } = this.buffer,
      r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i) return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3])) return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n,
      r,
      { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length) return !1;
      } else for (let o = 0; o < this.index; o++) if (i.buffer.buffer[o + 3] < this.index) return !1;
      ({ index: n, parent: r } = i);
    } else ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let o = n + e, s = e < 0 ? -1 : r._tree.children.length; o != s; o += e) {
          let l = r._tree.children[o];
          if (this.mode & vt.IncludeAnonymous || l instanceof Zo || !l.type.isAnonymous || Dy(l)) return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(e, 0, 4)) return !0;
    for (;;) {
      if (this.sibling(e)) return !0;
      if (this.atLastNode(e) || !this.parent()) return !1;
    }
  }
  next(e = !0) {
    return this.move(1, e);
  }
  prev(e = !0) {
    return this.move(-1, e);
  }
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); );
    for (; this.enterChild(1, e, n); );
    return this;
  }
  get node() {
    if (!this.buffer) return this._tree;
    let e = this.bufferNode,
      n = null,
      r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, o = this.stack.length; o >= 0; ) {
        for (let s = e; s; s = s._parent)
          if (s.index == i) {
            if (i == this.index) return s;
            (n = s), (r = o + 1);
            break e;
          }
        i = this.stack[--o];
      }
    for (let i = r; i < this.stack.length; i++) n = new ci(this.buffer, n, this.stack[i]);
    return (this.bufferNode = new ci(this.buffer, n, this.index));
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(e, n) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && n && n(this), (i = this.type.isAnonymous), !this.nextSibling(); ) {
        if (!r) return;
        this.parent(), r--, (i = !0);
      }
    }
  }
  matchContext(e) {
    if (!this.buffer) return tv(this.node, e);
    let { buffer: n } = this.buffer,
      { types: r } = n.set;
    for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0) return tv(this.node, e, i);
      let s = r[n.buffer[this.stack[o]]];
      if (!s.isAnonymous) {
        if (e[i] && e[i] != s.name) return !1;
        i--;
      }
    }
    return !0;
  }
}
function Dy(t) {
  return t.children.some((e) => e instanceof Zo || !e.type.isAnonymous || Dy(e));
}
function Xne(t) {
  var e;
  let { buffer: n, nodeSet: r, maxBufferLength: i = t4, reused: o = [], minRepeatType: s = r.types.length } = t,
    l = Array.isArray(n) ? new Qy(n, n.length) : n,
    a = r.types,
    c = 0,
    u = 0;
  function h(k, w, y, C, P, E) {
    let { id: N, start: L, end: D, size: Q } = l,
      R = u;
    for (; Q < 0; )
      if ((l.next(), Q == -1)) {
        let A = o[N];
        y.push(A), C.push(L - k);
        return;
      } else if (Q == -3) {
        c = N;
        return;
      } else if (Q == -4) {
        u = N;
        return;
      } else throw new RangeError(`Unrecognized record size: ${Q}`);
    let W = a[N],
      B,
      K,
      ne = L - k;
    if (D - L <= i && (K = O(l.pos - w, P))) {
      let A = new Uint16Array(K.size - K.skip),
        V = l.pos - K.size,
        ie = A.length;
      for (; l.pos > V; ) ie = v(K.start, A, ie);
      (B = new Zo(A, D - K.start, r)), (ne = K.start - k);
    } else {
      let A = l.pos - Q;
      l.next();
      let V = [],
        ie = [],
        M = N >= s ? N : -1,
        fe = 0,
        Se = D;
      for (; l.pos > A; )
        M >= 0 && l.id == M && l.size >= 0
          ? (l.end <= Se - i && (p(V, ie, L, fe, l.end, Se, M, R), (fe = V.length), (Se = l.end)), l.next())
          : E > 2500
          ? d(L, A, V, ie)
          : h(L, A, V, ie, M, E + 1);
      if ((M >= 0 && fe > 0 && fe < V.length && p(V, ie, L, fe, L, Se, M, R), V.reverse(), ie.reverse(), M > -1 && fe > 0)) {
        let pe = f(W);
        B = Fy(W, V, ie, 0, V.length, 0, D - L, pe, pe);
      } else B = m(W, V, ie, D - L, R - D);
    }
    y.push(B), C.push(ne);
  }
  function d(k, w, y, C) {
    let P = [],
      E = 0,
      N = -1;
    for (; l.pos > w; ) {
      let { id: L, start: D, end: Q, size: R } = l;
      if (R > 4) l.next();
      else {
        if (N > -1 && D < N) break;
        N < 0 && (N = Q - i), P.push(L, D, Q), E++, l.next();
      }
    }
    if (E) {
      let L = new Uint16Array(E * 4),
        D = P[P.length - 2];
      for (let Q = P.length - 3, R = 0; Q >= 0; Q -= 3) (L[R++] = P[Q]), (L[R++] = P[Q + 1] - D), (L[R++] = P[Q + 2] - D), (L[R++] = R);
      y.push(new Zo(L, P[2] - D, r)), C.push(D - k);
    }
  }
  function f(k) {
    return (w, y, C) => {
      let P = 0,
        E = w.length - 1,
        N,
        L;
      if (E >= 0 && (N = w[E]) instanceof Ve) {
        if (!E && N.type == k && N.length == C) return N;
        (L = N.prop(Ae.lookAhead)) && (P = y[E] + N.length + L);
      }
      return m(k, w, y, C, P);
    };
  }
  function p(k, w, y, C, P, E, N, L) {
    let D = [],
      Q = [];
    for (; k.length > C; ) D.push(k.pop()), Q.push(w.pop() + y - P);
    k.push(m(r.types[N], D, Q, E - P, L - E)), w.push(P - y);
  }
  function m(k, w, y, C, P = 0, E) {
    if (c) {
      let N = [Ae.contextHash, c];
      E = E ? [N].concat(E) : [N];
    }
    if (P > 25) {
      let N = [Ae.lookAhead, P];
      E = E ? [N].concat(E) : [N];
    }
    return new Ve(k, w, y, C, E);
  }
  function O(k, w) {
    let y = l.fork(),
      C = 0,
      P = 0,
      E = 0,
      N = y.end - i,
      L = { size: 0, start: 0, skip: 0 };
    e: for (let D = y.pos - k; y.pos > D; ) {
      let Q = y.size;
      if (y.id == w && Q >= 0) {
        (L.size = C), (L.start = P), (L.skip = E), (E += 4), (C += 4), y.next();
        continue;
      }
      let R = y.pos - Q;
      if (Q < 0 || R < D || y.start < N) break;
      let W = y.id >= s ? 4 : 0,
        B = y.start;
      for (y.next(); y.pos > R; ) {
        if (y.size < 0)
          if (y.size == -3) W += 4;
          else break e;
        else y.id >= s && (W += 4);
        y.next();
      }
      (P = B), (C += Q), (E += W);
    }
    return (w < 0 || C == k) && ((L.size = C), (L.start = P), (L.skip = E)), L.size > 4 ? L : void 0;
  }
  function v(k, w, y) {
    let { id: C, start: P, end: E, size: N } = l;
    if ((l.next(), N >= 0 && C < s)) {
      let L = y;
      if (N > 4) {
        let D = l.pos - (N - 4);
        for (; l.pos > D; ) y = v(k, w, y);
      }
      (w[--y] = L), (w[--y] = E - k), (w[--y] = P - k), (w[--y] = C);
    } else N == -3 ? (c = C) : N == -4 && (u = C);
    return y;
  }
  let g = [],
    b = [];
  for (; l.pos > 0; ) h(t.start || 0, t.bufferStart || 0, g, b, -1, 0);
  let x = (e = t.length) !== null && e !== void 0 ? e : g.length ? b[0] + g[0].length : 0;
  return new Ve(a[t.topID], g.reverse(), b.reverse(), x);
}
const A5 = new WeakMap();
function af(t, e) {
  if (!t.isAnonymous || e instanceof Zo || e.type != t) return 1;
  let n = A5.get(e);
  if (n == null) {
    n = 1;
    for (let r of e.children) {
      if (r.type != t || !(r instanceof Ve)) {
        n = 1;
        break;
      }
      n += af(t, r);
    }
    A5.set(e, n);
  }
  return n;
}
function Fy(t, e, n, r, i, o, s, l, a) {
  let c = 0;
  for (let p = r; p < i; p++) c += af(t, e[p]);
  let u = Math.ceil((c * 1.5) / 8),
    h = [],
    d = [];
  function f(p, m, O, v, g) {
    for (let b = O; b < v; ) {
      let x = b,
        k = m[b],
        w = af(t, p[b]);
      for (b++; b < v; b++) {
        let y = af(t, p[b]);
        if (w + y >= u) break;
        w += y;
      }
      if (b == x + 1) {
        if (w > u) {
          let y = p[x];
          f(y.children, y.positions, 0, y.children.length, m[x] + g);
          continue;
        }
        h.push(p[x]);
      } else {
        let y = m[b - 1] + p[b - 1].length - k;
        h.push(Fy(t, p, m, x, b, k, y, null, a));
      }
      d.push(k + g - o);
    }
  }
  return f(e, n, r, i, 0), (l || a)(h, d, s);
}
class o4 {
  constructor() {
    this.map = new WeakMap();
  }
  setBuffer(e, n, r) {
    let i = this.map.get(e);
    i || this.map.set(e, (i = new Map())), i.set(n, r);
  }
  getBuffer(e, n) {
    let r = this.map.get(e);
    return r && r.get(n);
  }
  set(e, n) {
    e instanceof ci ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof bn && this.map.set(e.tree, n);
  }
  get(e) {
    return e instanceof ci ? this.getBuffer(e.context.buffer, e.index) : e instanceof bn ? this.map.get(e.tree) : void 0;
  }
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Vi {
  constructor(e, n, r, i, o = !1, s = !1) {
    (this.from = e), (this.to = n), (this.tree = r), (this.offset = i), (this.open = (o ? 1 : 0) | (s ? 2 : 0));
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(e, n = [], r = !1) {
    let i = [new Vi(0, e.length, e, 0, !1, r)];
    for (let o of n) o.to > e.length && i.push(o);
    return i;
  }
  static applyChanges(e, n, r = 128) {
    if (!n.length) return e;
    let i = [],
      o = 1,
      s = e.length ? e[0] : null;
    for (let l = 0, a = 0, c = 0; ; l++) {
      let u = l < n.length ? n[l] : null,
        h = u ? u.fromA : 1e9;
      if (h - a >= r)
        for (; s && s.from < h; ) {
          let d = s;
          if (a >= d.from || h <= d.to || c) {
            let f = Math.max(d.from, a) - c,
              p = Math.min(d.to, h) - c;
            d = f >= p ? null : new Vi(f, p, d.tree, d.offset + c, l > 0, !!u);
          }
          if ((d && i.push(d), s.to > h)) break;
          s = o < e.length ? e[o++] : null;
        }
      if (!u) break;
      (a = u.toA), (c = u.toA - u.toB);
    }
    return i;
  }
}
class Km {
  startParse(e, n, r) {
    return (
      typeof e == "string" && (e = new Une(e)),
      (r = r ? (r.length ? r.map((i) => new fr(i.from, i.to)) : [new fr(0, 0)]) : [new fr(0, e.length)]),
      this.createParse(e, n || [], r)
    );
  }
  parse(e, n, r) {
    let i = this.startParse(e, n, r);
    for (;;) {
      let o = i.advance();
      if (o) return o;
    }
  }
}
class Une {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
function s4(t) {
  return (e, n, r, i) => new qne(e, t, n, r, i);
}
class $5 {
  constructor(e, n, r, i, o) {
    (this.parser = e), (this.parse = n), (this.overlay = r), (this.target = i), (this.from = o);
  }
}
function R5(t) {
  if (!t.length || t.some((e) => e.from >= e.to)) throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class Hne {
  constructor(e, n, r, i, o, s, l) {
    (this.parser = e),
      (this.predicate = n),
      (this.mounts = r),
      (this.index = i),
      (this.start = o),
      (this.target = s),
      (this.prev = l),
      (this.depth = 0),
      (this.ranges = []);
  }
}
const nv = new Ae({ perNode: !0 });
class qne {
  constructor(e, n, r, i, o) {
    (this.nest = n),
      (this.input = r),
      (this.fragments = i),
      (this.ranges = o),
      (this.inner = []),
      (this.innerDone = 0),
      (this.baseTree = null),
      (this.stoppedAt = null),
      (this.baseParse = e);
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r) return null;
      if (((this.baseParse = null), (this.baseTree = r), this.startInner(), this.stoppedAt != null))
        for (let i of this.inner) i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return (
        this.stoppedAt != null && (r = new Ve(r.type, r.children, r.positions, r.length, r.propValues.concat([[nv, this.stoppedAt]]))), r
      );
    }
    let e = this.inner[this.innerDone],
      n = e.parse.advance();
    if (n) {
      this.innerDone++;
      let r = Object.assign(Object.create(null), e.target.props);
      (r[Ae.mounted.id] = new Cu(n, e.overlay, e.parser)), (e.target.props = r);
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse) return 0;
    let e = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++) this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (((this.stoppedAt = e), this.baseParse)) this.baseParse.stopAt(e);
    else for (let n = this.innerDone; n < this.inner.length; n++) this.inner[n].parse.stopAt(e);
  }
  startInner() {
    let e = new Jne(this.fragments),
      n = null,
      r = null,
      i = new fp(new bn(this.baseTree, this.ranges[0].from, 0, null), vt.IncludeAnonymous | vt.IgnoreMounts);
    e: for (let o, s; ; ) {
      let l = !0,
        a;
      if (this.stoppedAt != null && i.from >= this.stoppedAt) l = !1;
      else if (e.hasNode(i)) {
        if (n) {
          let c = n.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos,
                d = u.to + c.pos;
              h >= i.from && d <= i.to && !n.ranges.some((f) => f.from < d && f.to > h) && n.ranges.push({ from: h, to: d });
            }
        }
        l = !1;
      } else if (r && (s = Yne(r.ranges, i.from, i.to))) l = s != 2;
      else if (!i.type.isAnonymous && (o = this.nest(i, this.input)) && (i.from < i.to || !o.overlay)) {
        i.tree || Gne(i);
        let c = e.findMounts(i.from, o.parser);
        if (typeof o.overlay == "function") n = new Hne(o.parser, o.overlay, c, this.inner.length, i.from, i.tree, n);
        else {
          let u = L5(this.ranges, o.overlay || (i.from < i.to ? [new fr(i.from, i.to)] : []));
          u.length && R5(u),
            (u.length || !o.overlay) &&
              this.inner.push(
                new $5(
                  o.parser,
                  u.length ? o.parser.startParse(this.input, N5(c, u), u) : o.parser.startParse(""),
                  o.overlay ? o.overlay.map((h) => new fr(h.from - i.from, h.to - i.from)) : null,
                  i.tree,
                  u.length ? u[0].from : i.from
                )
              ),
            o.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : (l = !1);
        }
      } else n && (a = n.predicate(i)) && (a === !0 && (a = new fr(i.from, i.to)), a.from < a.to && n.ranges.push(a));
      if (l && i.firstChild()) n && n.depth++, r && r.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent()) break e;
          if (n && !--n.depth) {
            let c = L5(this.ranges, n.ranges);
            c.length &&
              (R5(c),
              this.inner.splice(
                n.index,
                0,
                new $5(
                  n.parser,
                  n.parser.startParse(this.input, N5(n.mounts, c), c),
                  n.ranges.map((u) => new fr(u.from - n.start, u.to - n.start)),
                  n.target,
                  c[0].from
                )
              )),
              (n = n.prev);
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function Yne(t, e, n) {
  for (let r of t) {
    if (r.from >= n) break;
    if (r.to > e) return r.from <= e && r.to >= n ? 2 : 1;
  }
  return 0;
}
function I5(t, e, n, r, i, o) {
  if (e < n) {
    let s = t.buffer[e + 1];
    r.push(t.slice(e, n, s)), i.push(s - o);
  }
}
function Gne(t) {
  let { node: e } = t,
    n = [],
    r = e.context.buffer;
  do n.push(t.index), t.parent();
  while (!t.tree);
  let i = t.tree,
    o = i.children.indexOf(r),
    s = i.children[o],
    l = s.buffer,
    a = [o];
  function c(u, h, d, f, p, m) {
    let O = n[m],
      v = [],
      g = [];
    I5(s, u, O, v, g, f);
    let b = l[O + 1],
      x = l[O + 2];
    a.push(v.length);
    let k = m ? c(O + 4, l[O + 3], s.set.types[l[O]], b, x - b, m - 1) : e.toTree();
    return v.push(k), g.push(b - f), I5(s, l[O + 3], h, v, g, f), new Ve(d, v, g, p);
  }
  i.children[o] = c(0, l.length, Xt.none, 0, s.length, n.length - 1);
  for (let u of a) {
    let h = t.tree.children[u],
      d = t.tree.positions[u];
    t.yield(new bn(h, d + t.from, u, t._tree));
  }
}
class M5 {
  constructor(e, n) {
    (this.offset = n), (this.done = !1), (this.cursor = e.cursor(vt.IncludeAnonymous | vt.IgnoreMounts));
  }
  moveTo(e) {
    let { cursor: n } = this,
      r = e - this.offset;
    for (; !this.done && n.from < r; )
      (n.to >= e && n.enter(r, 1, vt.IgnoreOverlays | vt.ExcludeBuffers)) || n.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if ((this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree))
      for (let n = this.cursor.tree; ; ) {
        if (n == e.tree) return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof Ve) n = n.children[0];
        else break;
      }
    return !1;
  }
}
let Jne = class {
  constructor(e) {
    var n;
    if (((this.fragments = e), (this.curTo = 0), (this.fragI = 0), e.length)) {
      let r = (this.curFrag = e[0]);
      (this.curTo = (n = r.tree.prop(nv)) !== null && n !== void 0 ? n : r.to), (this.inner = new M5(r.tree, -r.offset));
    } else this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; ) this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if ((this.fragI++, this.fragI == this.fragments.length)) this.curFrag = this.inner = null;
    else {
      let n = (this.curFrag = this.fragments[this.fragI]);
      (this.curTo = (e = n.tree.prop(nv)) !== null && e !== void 0 ? e : n.to), (this.inner = new M5(n.tree, -n.offset));
    }
  }
  findMounts(e, n) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let o = this.inner.cursor.node; o; o = o.parent) {
        let s = (r = o.tree) === null || r === void 0 ? void 0 : r.prop(Ae.mounted);
        if (s && s.parser == n)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let a = this.fragments[l];
            if (a.from >= o.to) break;
            a.tree == this.curFrag.tree && i.push({ frag: a, pos: o.from - a.offset, mount: s });
          }
      }
    }
    return i;
  }
};
function L5(t, e) {
  let n = null,
    r = e;
  for (let i = 1, o = 0; i < t.length; i++) {
    let s = t[i - 1].to,
      l = t[i].from;
    for (; o < r.length; o++) {
      let a = r[o];
      if (a.from >= l) break;
      a.to <= s ||
        (n || (r = n = e.slice()),
        a.from < s
          ? ((n[o] = new fr(a.from, s)), a.to > l && n.splice(o + 1, 0, new fr(l, a.to)))
          : a.to > l
          ? (n[o--] = new fr(l, a.to))
          : n.splice(o--, 1));
    }
  }
  return r;
}
function Kne(t, e, n, r) {
  let i = 0,
    o = 0,
    s = !1,
    l = !1,
    a = -1e9,
    c = [];
  for (;;) {
    let u = i == t.length ? 1e9 : s ? t[i].to : t[i].from,
      h = o == e.length ? 1e9 : l ? e[o].to : e[o].from;
    if (s != l) {
      let d = Math.max(a, n),
        f = Math.min(u, h, r);
      d < f && c.push(new fr(d, f));
    }
    if (((a = Math.min(u, h)), a == 1e9)) break;
    u == a && (s ? ((s = !1), i++) : (s = !0)), h == a && (l ? ((l = !1), o++) : (l = !0));
  }
  return c;
}
function N5(t, e) {
  let n = [];
  for (let { pos: r, mount: i, frag: o } of t) {
    let s = r + (i.overlay ? i.overlay[0].from : 0),
      l = s + i.tree.length,
      a = Math.max(o.from, s),
      c = Math.min(o.to, l);
    if (i.overlay) {
      let u = i.overlay.map((d) => new fr(d.from + r, d.to + r)),
        h = Kne(e, u, a, c);
      for (let d = 0, f = a; ; d++) {
        let p = d == h.length,
          m = p ? c : h[d].from;
        if ((m > f && n.push(new Vi(f, m, i.tree, -s, o.from >= f || o.openStart, o.to <= m || o.openEnd)), p)) break;
        f = h[d].to;
      }
    } else n.push(new Vi(a, c, i.tree, -s, o.from >= s || o.openStart, o.to <= l || o.openEnd));
  }
  return n;
}
let ere = 0;
class Tr {
  constructor(e, n, r) {
    (this.set = e), (this.base = n), (this.modified = r), (this.id = ere++);
  }
  static define(e) {
    if (e != null && e.base) throw new Error("Can not derive from a modified tag");
    let n = new Tr([], null, []);
    if ((n.set.push(n), e)) for (let r of e.set) n.set.push(r);
    return n;
  }
  static defineModifier() {
    let e = new pp();
    return (n) =>
      n.modified.indexOf(e) > -1
        ? n
        : pp.get(
            n.base || n,
            n.modified.concat(e).sort((r, i) => r.id - i.id)
          );
  }
}
let tre = 0;
class pp {
  constructor() {
    (this.instances = []), (this.id = tre++);
  }
  static get(e, n) {
    if (!n.length) return e;
    let r = n[0].instances.find((l) => l.base == e && nre(n, l.modified));
    if (r) return r;
    let i = [],
      o = new Tr(i, e, n);
    for (let l of n) l.instances.push(o);
    let s = rre(n);
    for (let l of e.set) if (!l.modified.length) for (let a of s) i.push(pp.get(l, a));
    return o;
  }
}
function nre(t, e) {
  return t.length == e.length && t.every((n, r) => n == e[r]);
}
function rre(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++) for (let r = 0, i = e.length; r < i; r++) e.push(e[r].concat(t[n]));
  return e.sort((n, r) => r.length - n.length);
}
function Fa(t) {
  let e = Object.create(null);
  for (let n in t) {
    let r = t[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let o = [],
          s = 2,
          l = i;
        for (let h = 0; ; ) {
          if (l == "..." && h > 0 && h + 3 == i.length) {
            s = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!d) throw new RangeError("Invalid path: " + i);
          if ((o.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), (h += d[0].length), h == i.length)) break;
          let f = i[h++];
          if (h == i.length && f == "!") {
            s = 0;
            break;
          }
          if (f != "/") throw new RangeError("Invalid path: " + i);
          l = i.slice(h);
        }
        let a = o.length - 1,
          c = o[a];
        if (!c) throw new RangeError("Invalid path: " + i);
        let u = new mp(r, s, a > 0 ? o.slice(0, a) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return l4.add(e);
}
const l4 = new Ae();
class mp {
  constructor(e, n, r, i) {
    (this.tags = e), (this.mode = n), (this.context = r), (this.next = i);
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? ((this.next = e), this) : ((e.next = this.sort(e.next)), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
mp.empty = new mp([], 2, null);
function a4(t, e) {
  let n = Object.create(null);
  for (let o of t)
    if (!Array.isArray(o.tag)) n[o.tag.id] = o.class;
    else for (let s of o.tag) n[s.id] = o.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (o) => {
      let s = i;
      for (let l of o)
        for (let a of l.set) {
          let c = n[a.id];
          if (c) {
            s = s ? s + " " + c : c;
            break;
          }
        }
      return s;
    },
    scope: r,
  };
}
function ire(t, e) {
  let n = null;
  for (let r of t) {
    let i = r.style(e);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function c4(t, e, n, r = 0, i = t.length) {
  let o = new ore(r, Array.isArray(e) ? e : [e], n);
  o.highlightRange(t.cursor(), r, i, "", o.highlighters), o.flush(i);
}
class ore {
  constructor(e, n, r) {
    (this.at = e), (this.highlighters = n), (this.span = r), (this.class = "");
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), (this.class = n));
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, r, i, o) {
    let { type: s, from: l, to: a } = e;
    if (l >= r || a <= n) return;
    s.isTop && (o = this.highlighters.filter((f) => !f.scope || f.scope(s)));
    let c = i,
      u = sre(e) || mp.empty,
      h = ire(o, u.tags);
    if ((h && (c && (c += " "), (c += h), u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(n, l), c), u.opaque)) return;
    let d = e.tree && e.tree.prop(Ae.mounted);
    if (d && d.overlay) {
      let f = e.node.enter(d.overlay[0].from + l, 1),
        p = this.highlighters.filter((O) => !O.scope || O.scope(d.tree.type)),
        m = e.firstChild();
      for (let O = 0, v = l; ; O++) {
        let g = O < d.overlay.length ? d.overlay[O] : null,
          b = g ? g.from + l : a,
          x = Math.max(n, v),
          k = Math.min(r, b);
        if (x < k && m)
          for (
            ;
            e.from < k && (this.highlightRange(e, x, k, i, o), this.startSpan(Math.min(k, e.to), c), !(e.to >= b || !e.nextSibling()));

          );
        if (!g || b > r) break;
        (v = g.to + l),
          v > n && (this.highlightRange(f.cursor(), Math.max(n, g.from + l), Math.min(r, v), "", p), this.startSpan(Math.min(r, v), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      d && (i = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= r) break;
          this.highlightRange(e, n, r, i, o), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function sre(t) {
  let e = t.type.prop(l4);
  for (; e && e.context && !t.matchContext(e.context); ) e = e.next;
  return e || null;
}
const ue = Tr.define,
  xd = ue(),
  ho = ue(),
  Q5 = ue(ho),
  D5 = ue(ho),
  fo = ue(),
  yd = ue(fo),
  g1 = ue(fo),
  Jr = ue(),
  us = ue(Jr),
  Yr = ue(),
  Gr = ue(),
  rv = ue(),
  lc = ue(rv),
  wd = ue(),
  $ = {
    comment: xd,
    lineComment: ue(xd),
    blockComment: ue(xd),
    docComment: ue(xd),
    name: ho,
    variableName: ue(ho),
    typeName: Q5,
    tagName: ue(Q5),
    propertyName: D5,
    attributeName: ue(D5),
    className: ue(ho),
    labelName: ue(ho),
    namespace: ue(ho),
    macroName: ue(ho),
    literal: fo,
    string: yd,
    docString: ue(yd),
    character: ue(yd),
    attributeValue: ue(yd),
    number: g1,
    integer: ue(g1),
    float: ue(g1),
    bool: ue(fo),
    regexp: ue(fo),
    escape: ue(fo),
    color: ue(fo),
    url: ue(fo),
    keyword: Yr,
    self: ue(Yr),
    null: ue(Yr),
    atom: ue(Yr),
    unit: ue(Yr),
    modifier: ue(Yr),
    operatorKeyword: ue(Yr),
    controlKeyword: ue(Yr),
    definitionKeyword: ue(Yr),
    moduleKeyword: ue(Yr),
    operator: Gr,
    derefOperator: ue(Gr),
    arithmeticOperator: ue(Gr),
    logicOperator: ue(Gr),
    bitwiseOperator: ue(Gr),
    compareOperator: ue(Gr),
    updateOperator: ue(Gr),
    definitionOperator: ue(Gr),
    typeOperator: ue(Gr),
    controlOperator: ue(Gr),
    punctuation: rv,
    separator: ue(rv),
    bracket: lc,
    angleBracket: ue(lc),
    squareBracket: ue(lc),
    paren: ue(lc),
    brace: ue(lc),
    content: Jr,
    heading: us,
    heading1: ue(us),
    heading2: ue(us),
    heading3: ue(us),
    heading4: ue(us),
    heading5: ue(us),
    heading6: ue(us),
    contentSeparator: ue(Jr),
    list: ue(Jr),
    quote: ue(Jr),
    emphasis: ue(Jr),
    strong: ue(Jr),
    link: ue(Jr),
    monospace: ue(Jr),
    strikethrough: ue(Jr),
    inserted: ue(),
    deleted: ue(),
    changed: ue(),
    invalid: ue(),
    meta: wd,
    documentMeta: ue(wd),
    annotation: ue(wd),
    processingInstruction: ue(wd),
    definition: Tr.defineModifier(),
    constant: Tr.defineModifier(),
    function: Tr.defineModifier(),
    standard: Tr.defineModifier(),
    local: Tr.defineModifier(),
    special: Tr.defineModifier(),
  };
a4([
  { tag: $.link, class: "tok-link" },
  { tag: $.heading, class: "tok-heading" },
  { tag: $.emphasis, class: "tok-emphasis" },
  { tag: $.strong, class: "tok-strong" },
  { tag: $.keyword, class: "tok-keyword" },
  { tag: $.atom, class: "tok-atom" },
  { tag: $.bool, class: "tok-bool" },
  { tag: $.url, class: "tok-url" },
  { tag: $.labelName, class: "tok-labelName" },
  { tag: $.inserted, class: "tok-inserted" },
  { tag: $.deleted, class: "tok-deleted" },
  { tag: $.literal, class: "tok-literal" },
  { tag: $.string, class: "tok-string" },
  { tag: $.number, class: "tok-number" },
  { tag: [$.regexp, $.escape, $.special($.string)], class: "tok-string2" },
  { tag: $.variableName, class: "tok-variableName" },
  { tag: $.local($.variableName), class: "tok-variableName tok-local" },
  { tag: $.definition($.variableName), class: "tok-variableName tok-definition" },
  { tag: $.special($.variableName), class: "tok-variableName2" },
  { tag: $.definition($.propertyName), class: "tok-propertyName tok-definition" },
  { tag: $.typeName, class: "tok-typeName" },
  { tag: $.namespace, class: "tok-namespace" },
  { tag: $.className, class: "tok-className" },
  { tag: $.macroName, class: "tok-macroName" },
  { tag: $.propertyName, class: "tok-propertyName" },
  { tag: $.operator, class: "tok-operator" },
  { tag: $.comment, class: "tok-comment" },
  { tag: $.meta, class: "tok-meta" },
  { tag: $.invalid, class: "tok-invalid" },
  { tag: $.punctuation, class: "tok-punctuation" },
]);
var O1;
const ko = new Ae();
function eg(t) {
  return xe.define({ combine: t ? (e) => e.concat(t) : void 0 });
}
const By = new Ae();
class ir {
  constructor(e, n, r = [], i = "") {
    (this.data = e),
      (this.name = i),
      Me.prototype.hasOwnProperty("tree") ||
        Object.defineProperty(Me.prototype, "tree", {
          get() {
            return at(this);
          },
        }),
      (this.parser = n),
      (this.extension = [
        zo.of(this),
        Me.languageData.of((o, s, l) => {
          let a = F5(o, s, l),
            c = a.type.prop(ko);
          if (!c) return [];
          let u = o.facet(c),
            h = a.type.prop(By);
          if (h) {
            let d = a.resolve(s - a.from, l);
            for (let f of h)
              if (f.test(d, o)) {
                let p = o.facet(f.facet);
                return f.type == "replace" ? p : p.concat(u);
              }
          }
          return u;
        }),
      ].concat(r));
  }
  isActiveAt(e, n, r = -1) {
    return F5(e, n, r).type.prop(ko) == this.data;
  }
  findRegions(e) {
    let n = e.facet(zo);
    if ((n == null ? void 0 : n.data) == this.data) return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting) return [];
    let r = [],
      i = (o, s) => {
        if (o.prop(ko) == this.data) {
          r.push({ from: s, to: s + o.length });
          return;
        }
        let l = o.prop(Ae.mounted);
        if (l) {
          if (l.tree.prop(ko) == this.data) {
            if (l.overlay) for (let a of l.overlay) r.push({ from: a.from + s, to: a.to + s });
            else r.push({ from: s, to: s + o.length });
            return;
          } else if (l.overlay) {
            let a = r.length;
            if ((i(l.tree, l.overlay[0].from + s), r.length > a)) return;
          }
        }
        for (let a = 0; a < o.children.length; a++) {
          let c = o.children[a];
          c instanceof Ve && i(c, o.positions[a] + s);
        }
      };
    return i(at(e), 0), r;
  }
  get allowsNesting() {
    return !0;
  }
}
ir.setState = Ee.define();
function F5(t, e, n) {
  let r = t.facet(zo),
    i = at(t).topNode;
  if (!r || r.allowsNesting) for (let o = i; o; o = o.enter(e, n, vt.ExcludeBuffers)) o.type.isTop && (i = o);
  return i;
}
class oa extends ir {
  constructor(e, n, r) {
    super(e, n, [], r), (this.parser = n);
  }
  static define(e) {
    let n = eg(e.languageData);
    return new oa(n, e.parser.configure({ props: [ko.add((r) => (r.isTop ? n : void 0))] }), e.name);
  }
  configure(e, n) {
    return new oa(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function at(t) {
  let e = t.field(ir.state, !1);
  return e ? e.tree : Ve.empty;
}
class lre {
  constructor(e) {
    (this.doc = e), (this.cursorPos = 0), (this.string = ""), (this.cursor = e.iter());
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return (
      (this.string = this.cursor.next(e - this.cursorPos).value),
      (this.cursorPos = e + this.string.length),
      this.cursorPos - this.string.length
    );
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let r = this.cursorPos - this.string.length;
    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
  }
}
let ac = null;
class Ds {
  constructor(e, n, r = [], i, o, s, l, a) {
    (this.parser = e),
      (this.state = n),
      (this.fragments = r),
      (this.tree = i),
      (this.treeLen = o),
      (this.viewport = s),
      (this.skipped = l),
      (this.scheduleOn = a),
      (this.parse = null),
      (this.tempSkipped = []);
  }
  static create(e, n, r) {
    return new Ds(e, n, [], Ve.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new lre(this.state.doc), this.fragments);
  }
  work(e, n) {
    return (
      n != null && n >= this.state.doc.length && (n = void 0),
      this.tree != Ve.empty && this.isDone(n ?? this.state.doc.length)
        ? (this.takeTree(), !0)
        : this.withContext(() => {
            var r;
            if (typeof e == "number") {
              let i = Date.now() + e;
              e = () => Date.now() > i;
            }
            for (
              this.parse || (this.parse = this.startParse()),
                n != null &&
                  (this.parse.stoppedAt == null || this.parse.stoppedAt > n) &&
                  n < this.state.doc.length &&
                  this.parse.stopAt(n);
              ;

            ) {
              let i = this.parse.advance();
              if (i)
                if (
                  ((this.fragments = this.withoutTempSkipped(Vi.addTree(i, this.fragments, this.parse.stoppedAt != null))),
                  (this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length),
                  (this.tree = i),
                  (this.parse = null),
                  this.treeLen < (n ?? this.state.doc.length))
                )
                  this.parse = this.startParse();
                else return !0;
              if (e()) return !1;
            }
          })
    );
  }
  takeTree() {
    let e, n;
    this.parse &&
      (e = this.parse.parsedPos) >= this.treeLen &&
      ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e),
      this.withContext(() => {
        for (; !(n = this.parse.advance()); );
      }),
      (this.treeLen = e),
      (this.tree = n),
      (this.fragments = this.withoutTempSkipped(Vi.addTree(this.tree, this.fragments, !0))),
      (this.parse = null));
  }
  withContext(e) {
    let n = ac;
    ac = this;
    try {
      return e();
    } finally {
      ac = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; (n = this.tempSkipped.pop()); ) e = B5(e, n.from, n.to);
    return e;
  }
  changes(e, n) {
    let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: l } = this;
    if ((this.takeTree(), !e.empty)) {
      let a = [];
      if (
        (e.iterChangedRanges((c, u, h, d) => a.push({ fromA: c, toA: u, fromB: h, toB: d })),
        (r = Vi.applyChanges(r, a)),
        (i = Ve.empty),
        (o = 0),
        (s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }),
        this.skipped.length)
      ) {
        l = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1),
            h = e.mapPos(c.to, -1);
          u < h && l.push({ from: u, to: h });
        }
      }
    }
    return new Ds(this.parser, n, r, i, o, s, l, this.scheduleOn);
  }
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to) return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: o } = this.skipped[r];
      i < e.to && o > e.from && ((this.fragments = B5(this.fragments, i, o)), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), (this.parse = null));
  }
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  static getSkippingParser(e) {
    return new (class extends Km {
      createParse(n, r, i) {
        let o = i[0].from,
          s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let a = ac;
            if (a) {
              for (let c of i) a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return (this.parsedPos = s), new Ve(Xt.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {},
        };
      }
    })();
  }
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  static get() {
    return ac;
  }
}
function B5(t, e, n) {
  return Vi.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class sa {
  constructor(e) {
    (this.context = e), (this.tree = e.tree);
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree) return this;
    let n = this.context.changes(e.changes, e.state),
      r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new sa(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length),
      r = Ds.create(e.facet(zo).parser, e, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new sa(r);
  }
}
ir.state = Qt.define({
  create: sa.init,
  update(t, e) {
    for (let n of e.effects) if (n.is(ir.setState)) return n.value;
    return e.startState.facet(zo) != e.state.facet(zo) ? sa.init(e.state) : t.apply(e);
  },
});
let u4 = (t) => {
  let e = setTimeout(() => t(), 500);
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" &&
  (u4 = (t) => {
    let e = -1,
      n = setTimeout(() => {
        e = requestIdleCallback(t, { timeout: 500 - 100 });
      }, 100);
    return () => (e < 0 ? clearTimeout(n) : cancelIdleCallback(e));
  });
const v1 =
    typeof navigator < "u" && !((O1 = navigator.scheduling) === null || O1 === void 0) && O1.isInputPending
      ? () => navigator.scheduling.isInputPending()
      : null,
  are = At.fromClass(
    class {
      constructor(e) {
        (this.view = e),
          (this.working = null),
          (this.workScheduled = 0),
          (this.chunkEnd = -1),
          (this.chunkBudget = -1),
          (this.work = this.work.bind(this)),
          this.scheduleWork();
      }
      update(e) {
        let n = this.view.state.field(ir.state).context;
        (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(),
          (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()),
          this.checkAsyncSchedule(n);
      }
      scheduleWork() {
        if (this.working) return;
        let { state: e } = this.view,
          n = e.field(ir.state);
        (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = u4(this.work));
      }
      work(e) {
        this.working = null;
        let n = Date.now();
        if (
          (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && ((this.chunkEnd = n + 3e4), (this.chunkBudget = 3e3)),
          this.chunkBudget <= 0)
        )
          return;
        let {
            state: r,
            viewport: { to: i },
          } = this.view,
          o = r.field(ir.state);
        if (o.tree == o.context.tree && o.context.isDone(i + 1e5)) return;
        let s = Date.now() + Math.min(this.chunkBudget, 100, e && !v1 ? Math.max(25, e.timeRemaining() - 5) : 1e9),
          l = o.context.treeLen < i && r.doc.length > i + 1e3,
          a = o.context.work(() => (v1 && v1()) || Date.now() > s, i + (l ? 0 : 1e5));
        (this.chunkBudget -= Date.now() - n),
          (a || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: ir.setState.of(new sa(o.context)) })),
          this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(),
          this.checkAsyncSchedule(o.context);
      }
      checkAsyncSchedule(e) {
        e.scheduleOn &&
          (this.workScheduled++,
          e.scheduleOn
            .then(() => this.scheduleWork())
            .catch((n) => jn(this.view.state, n))
            .then(() => this.workScheduled--),
          (e.scheduleOn = null));
      }
      destroy() {
        this.working && this.working();
      }
      isWorking() {
        return !!(this.working || this.workScheduled > 0);
      }
    },
    {
      eventHandlers: {
        focus() {
          this.scheduleWork();
        },
      },
    }
  ),
  zo = xe.define({
    combine(t) {
      return t.length ? t[0] : null;
    },
    enables: (t) => [
      ir.state,
      are,
      re.contentAttributes.compute([t], (e) => {
        let n = e.facet(t);
        return n && n.name ? { "data-language": n.name } : {};
      }),
    ],
  });
class la {
  constructor(e, n = []) {
    (this.language = e), (this.support = n), (this.extension = [e, n]);
  }
}
class j {
  constructor(e, n, r, i, o, s = void 0) {
    (this.name = e),
      (this.alias = n),
      (this.extensions = r),
      (this.filename = i),
      (this.loadFunc = o),
      (this.support = s),
      (this.loading = null);
  }
  load() {
    return (
      this.loading ||
      (this.loading = this.loadFunc().then(
        (e) => (this.support = e),
        (e) => {
          throw ((this.loading = null), e);
        }
      ))
    );
  }
  static of(e) {
    let { load: n, support: r } = e;
    if (!n) {
      if (!r) throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      n = () => Promise.resolve(r);
    }
    return new j(
      e.name,
      (e.alias || []).concat(e.name).map((i) => i.toLowerCase()),
      e.extensions || [],
      e.filename,
      n,
      r
    );
  }
  static matchFilename(e, n) {
    for (let i of e) if (i.filename && i.filename.test(n)) return i;
    let r = /\.([^.]+)$/.exec(n);
    if (r) {
      for (let i of e) if (i.extensions.indexOf(r[1]) > -1) return i;
    }
    return null;
  }
  static matchLanguageName(e, n, r = !0) {
    n = n.toLowerCase();
    for (let i of e) if (i.alias.some((o) => o == n)) return i;
    if (r)
      for (let i of e)
        for (let o of i.alias) {
          let s = n.indexOf(o);
          if (s > -1 && (o.length > 2 || (!/\w/.test(n[s - 1]) && !/\w/.test(n[s + o.length])))) return i;
        }
    return null;
  }
}
const h4 = xe.define(),
  Rh = xe.define({
    combine: (t) => {
      if (!t.length) return "  ";
      let e = t[0];
      if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0])) throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
      return e;
    },
  });
function Fs(t) {
  let e = t.facet(Rh);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function Eu(t, e) {
  let n = "",
    r = t.tabSize,
    i = t.facet(Rh)[0];
  if (i == "	") {
    for (; e >= r; ) (n += "	"), (e -= r);
    i = " ";
  }
  for (let o = 0; o < e; o++) n += i;
  return n;
}
function Vy(t, e) {
  t instanceof Me && (t = new tg(t));
  for (let r of t.state.facet(h4)) {
    let i = r(t, e);
    if (i !== void 0) return i;
  }
  let n = at(t.state);
  return n.length >= e ? cre(t, n, e) : null;
}
class tg {
  constructor(e, n = {}) {
    (this.state = e), (this.options = n), (this.unit = Fs(e));
  }
  lineAt(e, n = 1) {
    let r = this.state.doc.lineAt(e),
      { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= r.from && i <= r.to
      ? o && i == e
        ? { text: "", from: e }
        : (n < 0 ? i < e : i <= e)
        ? { text: r.text.slice(i - r.from), from: i }
        : { text: r.text.slice(0, i - r.from), from: r.from }
      : r;
  }
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak) return "";
    let { text: r, from: i } = this.lineAt(e, n);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  column(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n),
      o = this.countColumn(r, e - i),
      s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
  }
  countColumn(e, n = e.length) {
    return Nr(e, this.state.tabSize, n);
  }
  lineIndent(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n),
      o = this.options.overrideIndentation;
    if (o) {
      let s = o(i);
      if (s > -1) return s;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Ih = new Ae();
function cre(t, e, n) {
  let r = e.resolveStack(n),
    i = r.node.enterUnfinishedNodesBefore(n);
  if (i != r.node) {
    let o = [];
    for (let s = i; s != r.node; s = s.parent) o.push(s);
    for (let s = o.length - 1; s >= 0; s--) r = { node: o[s], next: r };
  }
  return d4(r, t, n);
}
function d4(t, e, n) {
  for (let r = t; r; r = r.next) {
    let i = hre(r.node);
    if (i) return i(jy.create(e, n, r));
  }
  return 0;
}
function ure(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function hre(t) {
  let e = t.type.prop(Ih);
  if (e) return e;
  let n = t.firstChild,
    r;
  if (n && (r = n.type.prop(Ae.closedBy))) {
    let i = t.lastChild,
      o = i && r.indexOf(i.name) > -1;
    return (s) => f4(s, !0, 1, void 0, o && !ure(s) ? i.from : void 0);
  }
  return t.parent == null ? dre : null;
}
function dre() {
  return 0;
}
class jy extends tg {
  constructor(e, n, r) {
    super(e.state, e.options), (this.base = e), (this.pos = n), (this.context = r);
  }
  get node() {
    return this.context.node;
  }
  static create(e, n, r) {
    return new jy(e, n, r);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (;;) {
      let r = e.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; ) r = r.parent;
      if (fre(r, e)) break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  continue() {
    return d4(this.context.next, this.base, this.pos);
  }
}
function fre(t, e) {
  for (let n = e; n; n = n.parent) if (t == n) return !0;
  return !1;
}
function pre(t) {
  let e = t.node,
    n = e.childAfter(e.from),
    r = e.lastChild;
  if (!n) return null;
  let i = t.options.simulateBreak,
    o = t.state.doc.lineAt(n.from),
    s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let l = n.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == r) return null;
    if (!a.type.isSkipped) return a.from < s ? n : null;
    l = a.to;
  }
}
function mre({ closing: t, align: e = !0, units: n = 1 }) {
  return (r) => f4(r, e, n, t);
}
function f4(t, e, n, r, i) {
  let o = t.textAfter,
    s = o.match(/^\s*/)[0].length,
    l = (r && o.slice(s, s + r.length) == r) || i == t.pos + s,
    a = e ? pre(t) : null;
  return a ? (l ? t.column(a.from) : t.column(a.to)) : t.baseIndent + (l ? 0 : t.unit * n);
}
const gre = (t) => t.baseIndent;
function cf({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let r = t && t.test(n.textAfter);
    return n.baseIndent + (r ? 0 : e * n.unit);
  };
}
const Ore = 200;
function vre() {
  return Me.transactionFilter.of((t) => {
    if (!t.docChanged || (!t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))) return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length) return t;
    let n = t.newDoc,
      { head: r } = t.newSelection.main,
      i = n.lineAt(r);
    if (r > i.from + Ore) return t;
    let o = n.sliceString(i.from, r);
    if (!e.some((c) => c.test(o))) return t;
    let { state: s } = t,
      l = -1,
      a = [];
    for (let { head: c } of s.selection.ranges) {
      let u = s.doc.lineAt(c);
      if (u.from == l) continue;
      l = u.from;
      let h = Vy(s, u.from);
      if (h == null) continue;
      let d = /^\s*/.exec(u.text)[0],
        f = Eu(s, h);
      d != f && a.push({ from: u.from, to: u.from + d.length, insert: f });
    }
    return a.length ? [t, { changes: a, sequential: !0 }] : t;
  });
}
const p4 = xe.define(),
  Ba = new Ae();
function m4(t) {
  let e = t.firstChild,
    n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
function bre(t, e, n) {
  let r = at(t);
  if (r.length < n) return null;
  let i = r.resolveStack(n, 1),
    o = null;
  for (let s = i; s; s = s.next) {
    let l = s.node;
    if (l.to <= n || l.from > n) continue;
    if (o && l.from < e) break;
    let a = l.type.prop(Ba);
    if (a && (l.to < r.length - 50 || r.length == t.doc.length || !xre(l))) {
      let c = a(l, t);
      c && c.from <= n && c.from >= e && c.to > n && (o = c);
    }
  }
  return o;
}
function xre(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function gp(t, e, n) {
  for (let r of t.facet(p4)) {
    let i = r(t, e, n);
    if (i) return i;
  }
  return bre(t, e, n);
}
function g4(t, e) {
  let n = e.mapPos(t.from, 1),
    r = e.mapPos(t.to, -1);
  return n >= r ? void 0 : { from: n, to: r };
}
const ng = Ee.define({ map: g4 }),
  Mh = Ee.define({ map: g4 });
function O4(t) {
  let e = [];
  for (let { head: n } of t.state.selection.ranges) e.some((r) => r.from <= n && r.to >= n) || e.push(t.lineBlockAt(n));
  return e;
}
const Bs = Qt.define({
  create() {
    return me.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      if (n.is(ng) && !yre(t, n.value.from, n.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(Zy),
          i = r ? me.replace({ widget: new Tre(r(e.state, n.value)) }) : V5;
        t = t.update({ add: [i.range(n.value.from, n.value.to)] });
      } else
        n.is(Mh) &&
          (t = t.update({ filter: (r, i) => n.value.from != r || n.value.to != i, filterFrom: n.value.from, filterTo: n.value.to }));
    if (e.selection) {
      let n = !1,
        { head: r } = e.selection.main;
      t.between(r, r, (i, o) => {
        i < r && o > r && (n = !0);
      }),
        n && (t = t.update({ filterFrom: r, filterTo: r, filter: (i, o) => o <= r || i >= r }));
    }
    return t;
  },
  provide: (t) => re.decorations.from(t),
  toJSON(t, e) {
    let n = [];
    return (
      t.between(0, e.doc.length, (r, i) => {
        n.push(r, i);
      }),
      n
    );
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2) throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t.length; ) {
      let r = t[n++],
        i = t[n++];
      if (typeof r != "number" || typeof i != "number") throw new RangeError("Invalid JSON for fold state");
      e.push(V5.range(r, i));
    }
    return me.set(e, !0);
  },
});
function Op(t, e, n) {
  var r;
  let i = null;
  return (
    (r = t.field(Bs, !1)) === null ||
      r === void 0 ||
      r.between(e, n, (o, s) => {
        (!i || i.from > o) && (i = { from: o, to: s });
      }),
    i
  );
}
function yre(t, e, n) {
  let r = !1;
  return (
    t.between(e, e, (i, o) => {
      i == e && o == n && (r = !0);
    }),
    r
  );
}
function v4(t, e) {
  return t.field(Bs, !1) ? e : e.concat(Ee.appendConfig.of(x4()));
}
const wre = (t) => {
    for (let e of O4(t)) {
      let n = gp(t.state, e.from, e.to);
      if (n) return t.dispatch({ effects: v4(t.state, [ng.of(n), b4(t, n)]) }), !0;
    }
    return !1;
  },
  Sre = (t) => {
    if (!t.state.field(Bs, !1)) return !1;
    let e = [];
    for (let n of O4(t)) {
      let r = Op(t.state, n.from, n.to);
      r && e.push(Mh.of(r), b4(t, r, !1));
    }
    return e.length && t.dispatch({ effects: e }), e.length > 0;
  };
function b4(t, e, n = !0) {
  let r = t.state.doc.lineAt(e.from).number,
    i = t.state.doc.lineAt(e.to).number;
  return re.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${i}.`);
}
const kre = (t) => {
    let { state: e } = t,
      n = [];
    for (let r = 0; r < e.doc.length; ) {
      let i = t.lineBlockAt(r),
        o = gp(e, i.from, i.to);
      o && n.push(ng.of(o)), (r = (o ? t.lineBlockAt(o.to) : i).to + 1);
    }
    return n.length && t.dispatch({ effects: v4(t.state, n) }), !!n.length;
  },
  Cre = (t) => {
    let e = t.state.field(Bs, !1);
    if (!e || !e.size) return !1;
    let n = [];
    return (
      e.between(0, t.state.doc.length, (r, i) => {
        n.push(Mh.of({ from: r, to: i }));
      }),
      t.dispatch({ effects: n }),
      !0
    );
  },
  _re = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: wre },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Sre },
    { key: "Ctrl-Alt-[", run: kre },
    { key: "Ctrl-Alt-]", run: Cre },
  ],
  Ere = { placeholderDOM: null, preparePlaceholder: null, placeholderText: "…" },
  Zy = xe.define({
    combine(t) {
      return Si(t, Ere);
    },
  });
function x4(t) {
  let e = [Bs, $re];
  return t && e.push(Zy.of(t)), e;
}
function y4(t, e) {
  let { state: n } = t,
    r = n.facet(Zy),
    i = (s) => {
      let l = t.lineBlockAt(t.posAtDOM(s.target)),
        a = Op(t.state, l.from, l.to);
      a && t.dispatch({ effects: Mh.of(a) }), s.preventDefault();
    };
  if (r.placeholderDOM) return r.placeholderDOM(t, i, e);
  let o = document.createElement("span");
  return (
    (o.textContent = r.placeholderText),
    o.setAttribute("aria-label", n.phrase("folded code")),
    (o.title = n.phrase("unfold")),
    (o.className = "cm-foldPlaceholder"),
    (o.onclick = i),
    o
  );
}
const V5 = me.replace({
  widget: new (class extends Wr {
    toDOM(t) {
      return y4(t, null);
    }
  })(),
});
class Tre extends Wr {
  constructor(e) {
    super(), (this.value = e);
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return y4(e, this.value);
  }
}
const Pre = { openText: "⌄", closedText: "›", markerDOM: null, domEventHandlers: {}, foldingChanged: () => !1 };
class b1 extends yi {
  constructor(e, n) {
    super(), (this.config = e), (this.open = n);
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return (
      (n.textContent = this.open ? this.config.openText : this.config.closedText),
      (n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line")),
      n
    );
  }
}
function Are(t = {}) {
  let e = Object.assign(Object.assign({}, Pre), t),
    n = new b1(e, !0),
    r = new b1(e, !1),
    i = At.fromClass(
      class {
        constructor(s) {
          (this.from = s.viewport.from), (this.markers = this.buildMarkers(s));
        }
        update(s) {
          (s.docChanged ||
            s.viewportChanged ||
            s.startState.facet(zo) != s.state.facet(zo) ||
            s.startState.field(Bs, !1) != s.state.field(Bs, !1) ||
            at(s.startState) != at(s.state) ||
            e.foldingChanged(s)) &&
            (this.markers = this.buildMarkers(s.view));
        }
        buildMarkers(s) {
          let l = new lr();
          for (let a of s.viewportLineBlocks) {
            let c = Op(s.state, a.from, a.to) ? r : gp(s.state, a.from, a.to) ? n : null;
            c && l.add(a.from, a.from, c);
          }
          return l.finish();
        }
      }
    ),
    { domEventHandlers: o } = e;
  return [
    i,
    J7({
      class: "cm-foldGutter",
      markers(s) {
        var l;
        return ((l = s.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || ze.empty;
      },
      initialSpacer() {
        return new b1(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, o), {
        click: (s, l, a) => {
          if (o.click && o.click(s, l, a)) return !0;
          let c = Op(s.state, l.from, l.to);
          if (c) return s.dispatch({ effects: Mh.of(c) }), !0;
          let u = gp(s.state, l.from, l.to);
          return u ? (s.dispatch({ effects: ng.of(u) }), !0) : !1;
        },
      }),
    }),
    x4(),
  ];
}
const $re = re.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer",
  },
  ".cm-foldGutter span": { padding: "0 1px", cursor: "pointer" },
});
class Va {
  constructor(e, n) {
    this.specs = e;
    let r;
    function i(l) {
      let a = qi.newName();
      return ((r || (r = Object.create(null)))["." + a] = l), a;
    }
    const o = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0,
      s = n.scope;
    (this.scope = s instanceof ir ? (l) => l.prop(ko) == s.data : s ? (l) => l == s : void 0),
      (this.style = a4(
        e.map((l) => ({ tag: l.tag, class: l.class || i(Object.assign({}, l, { tag: null })) })),
        { all: o }
      ).style),
      (this.module = r ? new qi(r) : null),
      (this.themeType = n.themeType);
  }
  static define(e, n) {
    return new Va(e, n || {});
  }
}
const iv = xe.define(),
  w4 = xe.define({
    combine(t) {
      return t.length ? [t[0]] : null;
    },
  });
function x1(t) {
  let e = t.facet(iv);
  return e.length ? e : t.facet(w4);
}
function zy(t, e) {
  let n = [Ire],
    r;
  return (
    t instanceof Va && (t.module && n.push(re.styleModule.of(t.module)), (r = t.themeType)),
    e != null && e.fallback
      ? n.push(w4.of(t))
      : r
      ? n.push(iv.computeN([re.darkTheme], (i) => (i.facet(re.darkTheme) == (r == "dark") ? [t] : [])))
      : n.push(iv.of(t)),
    n
  );
}
class Rre {
  constructor(e) {
    (this.markCache = Object.create(null)),
      (this.tree = at(e.state)),
      (this.decorations = this.buildDeco(e, x1(e.state))),
      (this.decoratedTo = e.viewport.to);
  }
  update(e) {
    let n = at(e.state),
      r = x1(e.state),
      i = r != x1(e.startState),
      { viewport: o } = e.view,
      s = e.changes.mapPos(this.decoratedTo, 1);
    n.length < o.to && !i && n.type == this.tree.type && s >= o.to
      ? ((this.decorations = this.decorations.map(e.changes)), (this.decoratedTo = s))
      : (n != this.tree || e.viewportChanged || i) &&
        ((this.tree = n), (this.decorations = this.buildDeco(e.view, r)), (this.decoratedTo = o.to));
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length) return me.none;
    let r = new lr();
    for (let { from: i, to: o } of e.visibleRanges)
      c4(
        this.tree,
        n,
        (s, l, a) => {
          r.add(s, l, this.markCache[a] || (this.markCache[a] = me.mark({ class: a })));
        },
        i,
        o
      );
    return r.finish();
  }
}
const Ire = zr.high(At.fromClass(Rre, { decorations: (t) => t.decorations })),
  Mre = Va.define([
    { tag: $.meta, color: "#404740" },
    { tag: $.link, textDecoration: "underline" },
    { tag: $.heading, textDecoration: "underline", fontWeight: "bold" },
    { tag: $.emphasis, fontStyle: "italic" },
    { tag: $.strong, fontWeight: "bold" },
    { tag: $.strikethrough, textDecoration: "line-through" },
    { tag: $.keyword, color: "#708" },
    { tag: [$.atom, $.bool, $.url, $.contentSeparator, $.labelName], color: "#219" },
    { tag: [$.literal, $.inserted], color: "#164" },
    { tag: [$.string, $.deleted], color: "#a11" },
    { tag: [$.regexp, $.escape, $.special($.string)], color: "#e40" },
    { tag: $.definition($.variableName), color: "#00f" },
    { tag: $.local($.variableName), color: "#30a" },
    { tag: [$.typeName, $.namespace], color: "#085" },
    { tag: $.className, color: "#167" },
    { tag: [$.special($.variableName), $.macroName], color: "#256" },
    { tag: $.definition($.propertyName), color: "#00c" },
    { tag: $.comment, color: "#940" },
    { tag: $.invalid, color: "#f00" },
  ]),
  Lre = re.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" },
  }),
  S4 = 1e4,
  k4 = "()[]{}",
  C4 = xe.define({
    combine(t) {
      return Si(t, { afterCursor: !0, brackets: k4, maxScanDistance: S4, renderMatch: Dre });
    },
  }),
  Nre = me.mark({ class: "cm-matchingBracket" }),
  Qre = me.mark({ class: "cm-nonmatchingBracket" });
function Dre(t) {
  let e = [],
    n = t.matched ? Nre : Qre;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const Fre = Qt.define({
    create() {
      return me.none;
    },
    update(t, e) {
      if (!e.docChanged && !e.selection) return t;
      let n = [],
        r = e.state.facet(C4);
      for (let i of e.state.selection.ranges) {
        if (!i.empty) continue;
        let o =
          ui(e.state, i.head, -1, r) ||
          (i.head > 0 && ui(e.state, i.head - 1, 1, r)) ||
          (r.afterCursor && (ui(e.state, i.head, 1, r) || (i.head < e.state.doc.length && ui(e.state, i.head + 1, -1, r))));
        o && (n = n.concat(r.renderMatch(o, e.state)));
      }
      return me.set(n, !0);
    },
    provide: (t) => re.decorations.from(t),
  }),
  Bre = [Fre, Lre];
function _4(t = {}) {
  return [C4.of(t), Bre];
}
const E4 = new Ae();
function ov(t, e, n) {
  let r = t.prop(e < 0 ? Ae.openedBy : Ae.closedBy);
  if (r) return r;
  if (t.name.length == 1) {
    let i = n.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0)) return [n[i + e]];
  }
  return null;
}
function sv(t) {
  let e = t.type.prop(E4);
  return e ? e(t.node) : t;
}
function ui(t, e, n, r = {}) {
  let i = r.maxScanDistance || S4,
    o = r.brackets || k4,
    s = at(t),
    l = s.resolveInner(e, n);
  for (let a = l; a; a = a.parent) {
    let c = ov(a.type, n, o);
    if (c && a.from < a.to) {
      let u = sv(a);
      if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to)) return Vre(t, e, n, a, u, c, o);
    }
  }
  return jre(t, e, n, s, l.type, i, o);
}
function Vre(t, e, n, r, i, o, s) {
  let l = r.parent,
    a = { from: i.from, to: i.to },
    c = 0,
    u = l == null ? void 0 : l.cursor();
  if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (n < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && o.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = sv(u);
          return { start: a, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (ov(u.type, n, s)) c++;
        else if (ov(u.type, -n, s)) {
          if (c == 0) {
            let h = sv(u);
            return { start: a, end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0, matched: !1 };
          }
          c--;
        }
      }
    while (n < 0 ? u.prevSibling() : u.nextSibling());
  return { start: a, matched: !1 };
}
function jre(t, e, n, r, i, o, s) {
  let l = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1),
    a = s.indexOf(l);
  if (a < 0 || (a % 2 == 0) != n > 0) return null;
  let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e },
    u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0),
    h = 0;
  for (let d = 0; !u.next().done && d <= o; ) {
    let f = u.value;
    n < 0 && (d += f.length);
    let p = e + d * n;
    for (let m = n > 0 ? 0 : f.length - 1, O = n > 0 ? f.length : -1; m != O; m += n) {
      let v = s.indexOf(f[m]);
      if (!(v < 0 || r.resolveInner(p + m, 1).type != i))
        if ((v % 2 == 0) == n > 0) h++;
        else {
          if (h == 1) return { start: c, end: { from: p + m, to: p + m + 1 }, matched: v >> 1 == a >> 1 };
          h--;
        }
    }
    n > 0 && (d += f.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function j5(t, e, n, r = 0, i = 0) {
  e == null && ((e = t.search(/[^\s\u00a0]/)), e == -1 && (e = t.length));
  let o = i;
  for (let s = r; s < e; s++) t.charCodeAt(s) == 9 ? (o += n - (o % n)) : o++;
  return o;
}
class T4 {
  constructor(e, n, r, i) {
    (this.string = e),
      (this.tabSize = n),
      (this.indentUnit = r),
      (this.overrideIndent = i),
      (this.pos = 0),
      (this.start = 0),
      (this.lastColumnPos = 0),
      (this.lastColumnValue = 0);
  }
  eol() {
    return this.pos >= this.string.length;
  }
  sol() {
    return this.pos == 0;
  }
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  next() {
    if (this.pos < this.string.length) return this.string.charAt(this.pos++);
  }
  eat(e) {
    let n = this.string.charAt(this.pos),
      r;
    if ((typeof e == "string" ? (r = n == e) : (r = n && (e instanceof RegExp ? e.test(n) : e(n))), r)) return ++this.pos, n;
  }
  eatWhile(e) {
    let n = this.pos;
    for (; this.eat(e); );
    return this.pos > n;
  }
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); ) ++this.pos;
    return this.pos > e;
  }
  skipToEnd() {
    this.pos = this.string.length;
  }
  skipTo(e) {
    let n = this.string.indexOf(e, this.pos);
    if (n > -1) return (this.pos = n), !0;
  }
  backUp(e) {
    this.pos -= e;
  }
  column() {
    return (
      this.lastColumnPos < this.start &&
        ((this.lastColumnValue = j5(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)),
        (this.lastColumnPos = this.start)),
      this.lastColumnValue
    );
  }
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : j5(this.string, null, this.tabSize);
  }
  match(e, n, r) {
    if (typeof e == "string") {
      let i = (s) => (r ? s.toLowerCase() : s),
        o = this.string.substr(this.pos, e.length);
      return i(o) == i(e) ? (n !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let i = this.string.slice(this.pos).match(e);
      return i && i.index > 0 ? null : (i && n !== !1 && (this.pos += i[0].length), i);
    }
  }
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function Zre(t) {
  return {
    name: t.name || "",
    token: t.token,
    blankLine: t.blankLine || (() => {}),
    startState: t.startState || (() => !0),
    copyState: t.copyState || zre,
    indent: t.indent || (() => null),
    languageData: t.languageData || {},
    tokenTable: t.tokenTable || Uy,
  };
}
function zre(t) {
  if (typeof t != "object") return t;
  let e = {};
  for (let n in t) {
    let r = t[n];
    e[n] = r instanceof Array ? r.slice() : r;
  }
  return e;
}
const Z5 = new WeakMap();
class Wy extends ir {
  constructor(e) {
    let n = eg(e.languageData),
      r = Zre(e),
      i,
      o = new (class extends Km {
        createParse(s, l, a) {
          return new Xre(i, s, l, a);
        }
      })();
    super(n, o, [h4.of((s, l) => this.getIndent(s, l))], e.name),
      (this.topNode = qre(n)),
      (i = this),
      (this.streamParser = r),
      (this.stateAfter = new Ae({ perNode: !0 })),
      (this.tokenTable = e.tokenTable ? new R4(r.tokenTable) : Hre);
  }
  static define(e) {
    return new Wy(e);
  }
  getIndent(e, n) {
    let r = at(e.state),
      i = r.resolve(n);
    for (; i && i.type != this.topNode; ) i = i.parent;
    if (!i) return null;
    let o,
      { overrideIndentation: s } = e.options;
    s && ((o = Z5.get(e.state)), o != null && o < n - 1e4 && (o = void 0));
    let l = Xy(this, r, 0, i.from, o ?? n),
      a,
      c;
    if ((l ? ((c = l.state), (a = l.pos + 1)) : ((c = this.streamParser.startState(e.unit)), (a = 0)), n - a > 1e4)) return null;
    for (; a < n; ) {
      let h = e.state.doc.lineAt(a),
        d = Math.min(n, h.to);
      if (h.length) {
        let f = s ? s(h.from) : -1,
          p = new T4(h.text, e.state.tabSize, e.unit, f < 0 ? void 0 : f);
        for (; p.pos < d - h.from; ) A4(this.streamParser.token, p, c);
      } else this.streamParser.blankLine(c, e.unit);
      if (d == n) break;
      a = h.to + 1;
    }
    let u = e.lineAt(n);
    return s && o == null && Z5.set(e.state, u.from), this.streamParser.indent(c, /^\s*(.*)/.exec(u.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function Xy(t, e, n, r, i) {
  let o = n >= r && n + e.length <= i && e.prop(t.stateAfter);
  if (o) return { state: t.streamParser.copyState(o), pos: n + e.length };
  for (let s = e.children.length - 1; s >= 0; s--) {
    let l = e.children[s],
      a = n + e.positions[s],
      c = l instanceof Ve && a < i && Xy(t, l, a, r, i);
    if (c) return c;
  }
  return null;
}
function P4(t, e, n, r, i) {
  if (i && n <= 0 && r >= e.length) return e;
  !i && e.type == t.topNode && (i = !0);
  for (let o = e.children.length - 1; o >= 0; o--) {
    let s = e.positions[o],
      l = e.children[o],
      a;
    if (s < r && l instanceof Ve) {
      if (!(a = P4(t, l, n - s, r - s, i))) break;
      return i ? new Ve(e.type, e.children.slice(0, o).concat(a), e.positions.slice(0, o + 1), s + a.length) : a;
    }
  }
  return null;
}
function Wre(t, e, n, r) {
  for (let i of e) {
    let o = i.from + (i.openStart ? 25 : 0),
      s = i.to - (i.openEnd ? 25 : 0),
      l = o <= n && s > n && Xy(t, i.tree, 0 - i.offset, n, s),
      a;
    if (l && (a = P4(t, i.tree, n + i.offset, l.pos + i.offset, !1))) return { state: l.state, tree: a };
  }
  return { state: t.streamParser.startState(r ? Fs(r) : 4), tree: Ve.empty };
}
let Xre = class {
  constructor(e, n, r, i) {
    (this.lang = e),
      (this.input = n),
      (this.fragments = r),
      (this.ranges = i),
      (this.stoppedAt = null),
      (this.chunks = []),
      (this.chunkPos = []),
      (this.chunk = []),
      (this.chunkReused = void 0),
      (this.rangeIndex = 0),
      (this.to = i[i.length - 1].to);
    let o = Ds.get(),
      s = i[0].from,
      { state: l, tree: a } = Wre(e, r, s, o == null ? void 0 : o.state);
    (this.state = l), (this.parsedPos = this.chunkStart = s + a.length);
    for (let c = 0; c < a.children.length; c++) this.chunks.push(a.children[c]), this.chunkPos.push(a.positions[c]);
    o &&
      this.parsedPos < o.viewport.from - 1e5 &&
      ((this.state = this.lang.streamParser.startState(Fs(o.state))),
      o.skipUntilInView(this.parsedPos, o.viewport.from),
      (this.parsedPos = o.viewport.from)),
      this.moveRangeIndex();
  }
  advance() {
    let e = Ds.get(),
      n = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt),
      r = Math.min(n, this.chunkStart + 2048);
    for (e && (r = Math.min(r, e.viewport.to)); this.parsedPos < r; ) this.parseLine(e);
    return (
      this.chunkStart < this.parsedPos && this.finishChunk(),
      this.parsedPos >= n
        ? this.finish()
        : e && this.parsedPos >= e.viewport.to
        ? (e.skipUntilInView(this.parsedPos, n), this.finish())
        : null
    );
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let n = this.input.chunk(e);
    if (this.input.lineChunks)
      n ==
        `
` && (n = "");
    else {
      let r = n.indexOf(`
`);
      r > -1 && (n = n.slice(0, r));
    }
    return e + n.length <= this.to ? n : n.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos,
      n = this.lineAfter(e),
      r = e + n.length;
    for (let i = this.rangeIndex; ; ) {
      let o = this.ranges[i].to;
      if (o >= r || ((n = n.slice(0, o - (r - n.length))), i++, i == this.ranges.length)) break;
      let s = this.ranges[i].from,
        l = this.lineAfter(s);
      (n += l), (r = s + l.length);
    }
    return { line: n, end: r };
  }
  skipGapsTo(e, n, r) {
    for (;;) {
      let i = this.ranges[this.rangeIndex].to,
        o = e + n;
      if (r > 0 ? i > o : i >= o) break;
      let s = this.ranges[++this.rangeIndex].from;
      n += s - i;
    }
    return n;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; ) this.rangeIndex++;
  }
  emitToken(e, n, r, i, o) {
    if (this.ranges.length > 1) {
      (o = this.skipGapsTo(n, o, 1)), (n += o);
      let s = this.chunk.length;
      (o = this.skipGapsTo(r, o, -1)), (r += o), (i += this.chunk.length - s);
    }
    return this.chunk.push(e, n, r, i), o;
  }
  parseLine(e) {
    let { line: n, end: r } = this.nextLine(),
      i = 0,
      { streamParser: o } = this.lang,
      s = new T4(n, e ? e.state.tabSize : 4, e ? Fs(e.state) : 2);
    if (s.eol()) o.blankLine(this.state, s.indentUnit);
    else
      for (; !s.eol(); ) {
        let l = A4(o.token, s, this.state);
        if (
          (l && (i = this.emitToken(this.lang.tokenTable.resolve(l), this.parsedPos + s.start, this.parsedPos + s.pos, 4, i)),
          s.start > 1e4)
        )
          break;
      }
    (this.parsedPos = r), this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = Ve.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: Ure,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused,
    });
    (e = new Ve(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]])),
      this.chunks.push(e),
      this.chunkPos.push(this.chunkStart - this.ranges[0].from),
      (this.chunk = []),
      (this.chunkReused = void 0),
      (this.chunkStart = this.parsedPos);
  }
  finish() {
    return new Ve(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
};
function A4(t, e, n) {
  e.start = e.pos;
  for (let r = 0; r < 10; r++) {
    let i = t(e, n);
    if (e.pos > e.start) return i;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const Uy = Object.create(null),
  Tu = [Xt.none],
  Ure = new Da(Tu),
  z5 = [],
  W5 = Object.create(null),
  $4 = Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"],
])
  $4[t] = I4(Uy, e);
class R4 {
  constructor(e) {
    (this.extra = e), (this.table = Object.assign(Object.create(null), $4));
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = I4(this.extra, e)) : 0;
  }
}
const Hre = new R4(Uy);
function y1(t, e) {
  z5.indexOf(t) > -1 || (z5.push(t), console.warn(e));
}
function I4(t, e) {
  let n = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let c of l.split(".")) {
      let u = t[c] || $[c];
      u
        ? typeof u == "function"
          ? a.length
            ? (a = a.map(u))
            : y1(c, `Modifier ${c} used at start of tag`)
          : a.length
          ? y1(c, `Tag ${c} used as modifier`)
          : (a = Array.isArray(u) ? u : [u])
        : y1(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of a) n.push(c);
  }
  if (!n.length) return 0;
  let r = e.replace(/ /g, "_"),
    i = r + " " + n.map((l) => l.id),
    o = W5[i];
  if (o) return o.id;
  let s = (W5[i] = Xt.define({ id: Tu.length, name: r, props: [Fa({ [r]: n })] }));
  return Tu.push(s), s.id;
}
function qre(t) {
  let e = Xt.define({ id: Tu.length, name: "Document", props: [ko.add(() => t)], top: !0 });
  return Tu.push(e), e;
}
wt.RTL, wt.LTR;
class Hy {
  constructor(e, n, r, i) {
    (this.state = e), (this.pos = n), (this.explicit = r), (this.view = i), (this.abortListeners = []);
  }
  tokenBefore(e) {
    let n = at(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; ) n = n.parent;
    return n ? { from: n.from, to: this.pos, text: this.state.sliceDoc(n.from, this.pos), type: n.type } : null;
  }
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos),
      r = Math.max(n.from, this.pos - 250),
      i = n.text.slice(r - n.from, this.pos - n.from),
      o = i.search(L4(e, !1));
    return o < 0 ? null : { from: r + o, to: this.pos, text: i.slice(o) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(e, n) {
    e == "abort" && this.abortListeners && this.abortListeners.push(n);
  }
}
function X5(t) {
  let e = Object.keys(t).join(""),
    n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function Yre(t) {
  let e = Object.create(null),
    n = Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let o = 1; o < i.length; o++) n[i[o]] = !0;
  }
  let r = X5(e) + X5(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function M4(t) {
  let e = t.map((i) => (typeof i == "string" ? { label: i } : i)),
    [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : Yre(e);
  return (i) => {
    let o = i.matchBefore(r);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: e, validFor: n } : null;
  };
}
function Gre(t, e) {
  return (n) => {
    for (let r = at(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
      if (t.indexOf(r.name) > -1) return null;
      if (r.type.isTop) break;
    }
    return e(n);
  };
}
class U5 {
  constructor(e, n, r, i) {
    (this.completion = e), (this.source = n), (this.match = r), (this.score = i);
  }
}
function Po(t) {
  return t.selection.main.from;
}
function L4(t, e) {
  var n;
  let { source: r } = t,
    i = e && r[0] != "^",
    o = r[r.length - 1] != "$";
  return !i && !o
    ? t
    : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const qy = Lr.define();
function Jre(t, e, n, r) {
  let { main: i } = t.selection,
    o = n - i.from,
    s = r - i.from;
  return Object.assign(
    Object.assign(
      {},
      t.changeByRange((l) =>
        l != i && n != r && t.sliceDoc(l.from + o, l.from + s) != t.sliceDoc(n, r)
          ? { range: l }
          : { changes: { from: l.from + o, to: r == i.from ? l.to : l.from + s, insert: e }, range: H.cursor(l.from + o + e.length) }
      )
    ),
    { scrollIntoView: !0, userEvent: "input.complete" }
  );
}
const H5 = new WeakMap();
function Kre(t) {
  if (!Array.isArray(t)) return t;
  let e = H5.get(t);
  return e || H5.set(t, (e = M4(t))), e;
}
const vp = Ee.define(),
  Pu = Ee.define();
class eie {
  constructor(e) {
    (this.pattern = e),
      (this.chars = []),
      (this.folded = []),
      (this.any = []),
      (this.precise = []),
      (this.byWord = []),
      (this.score = 0),
      (this.matched = []);
    for (let n = 0; n < e.length; ) {
      let r = an(e, n),
        i = dr(r);
      this.chars.push(r);
      let o = e.slice(n, n + i),
        s = o.toUpperCase();
      this.folded.push(an(s == o ? o.toLowerCase() : s, 0)), (n += i);
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return (this.score = e), (this.matched = n), this;
  }
  match(e) {
    if (this.pattern.length == 0) return this.ret(-100, []);
    if (e.length < this.pattern.length) return null;
    let { chars: n, folded: r, any: i, precise: o, byWord: s } = this;
    if (n.length == 1) {
      let g = an(e, 0),
        b = dr(g),
        x = b == e.length ? 0 : -100;
      if (g != n[0])
        if (g == r[0]) x += -200;
        else return null;
      return this.ret(x, [0, b]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0) return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = n.length,
      c = 0;
    if (l < 0) {
      for (let g = 0, b = Math.min(e.length, 200); g < b && c < a; ) {
        let x = an(e, g);
        (x == n[c] || x == r[c]) && (i[c++] = g), (g += dr(x));
      }
      if (c < a) return null;
    }
    let u = 0,
      h = 0,
      d = !1,
      f = 0,
      p = -1,
      m = -1,
      O = /[a-z]/.test(e),
      v = !0;
    for (let g = 0, b = Math.min(e.length, 200), x = 0; g < b && h < a; ) {
      let k = an(e, g);
      l < 0 && (u < a && k == n[u] && (o[u++] = g), f < a && (k == n[f] || k == r[f] ? (f == 0 && (p = g), (m = g + 1), f++) : (f = 0)));
      let w,
        y =
          k < 255
            ? (k >= 48 && k <= 57) || (k >= 97 && k <= 122)
              ? 2
              : k >= 65 && k <= 90
              ? 1
              : 0
            : (w = Cy(k)) != w.toLowerCase()
            ? 1
            : w != w.toUpperCase()
            ? 2
            : 0;
      (!g || (y == 1 && O) || (x == 0 && y != 0)) && (n[h] == k || (r[h] == k && (d = !0)) ? (s[h++] = g) : s.length && (v = !1)),
        (x = y),
        (g += dr(k));
    }
    return h == a && s[0] == 0 && v
      ? this.result(-100 + (d ? -200 : 0), s, e)
      : f == a && p == 0
      ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m])
      : l > -1
      ? this.ret(-700 - e.length, [l, l + this.pattern.length])
      : f == a
      ? this.ret(-200 + -700 - e.length, [p, m])
      : h == a
      ? this.result(-100 + (d ? -200 : 0) + -700 + (v ? 0 : -1100), s, e)
      : n.length == 2
      ? null
      : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, n, r) {
    let i = [],
      o = 0;
    for (let s of n) {
      let l = s + (this.astral ? dr(an(r, s)) : 1);
      o && i[o - 1] == s ? (i[o - 1] = l) : ((i[o++] = s), (i[o++] = l));
    }
    return this.ret(e - r.length, i);
  }
}
class tie {
  constructor(e) {
    (this.pattern = e), (this.matched = []), (this.score = 0), (this.folded = e.toLowerCase());
  }
  match(e) {
    if (e.length < this.pattern.length) return null;
    let n = e.slice(0, this.pattern.length),
      r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : ((this.matched = [0, n.length]), (this.score = r + (e.length == this.pattern.length ? 0 : -100)), this);
  }
}
const hn = xe.define({
  combine(t) {
    return Si(
      t,
      {
        activateOnTyping: !0,
        activateOnCompletion: () => !1,
        activateOnTypingDelay: 100,
        selectOnOpen: !0,
        override: null,
        closeOnBlur: !0,
        maxRenderedOptions: 100,
        defaultKeymap: !0,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: !1,
        icons: !0,
        addToOptions: [],
        positionInfo: nie,
        filterStrict: !1,
        compareCompletions: (e, n) => e.label.localeCompare(n.label),
        interactionDelay: 75,
        updateSyncTime: 100,
      },
      {
        defaultKeymap: (e, n) => e && n,
        closeOnBlur: (e, n) => e && n,
        icons: (e, n) => e && n,
        tooltipClass: (e, n) => (r) => q5(e(r), n(r)),
        optionClass: (e, n) => (r) => q5(e(r), n(r)),
        addToOptions: (e, n) => e.concat(n),
        filterStrict: (e, n) => e || n,
      }
    );
  },
});
function q5(t, e) {
  return t ? (e ? t + " " + e : t) : e;
}
function nie(t, e, n, r, i, o) {
  let s = t.textDirection == wt.RTL,
    l = s,
    a = !1,
    c = "top",
    u,
    h,
    d = e.left - i.left,
    f = i.right - e.right,
    p = r.right - r.left,
    m = r.bottom - r.top;
  if ((l && d < Math.min(p, f) ? (l = !1) : !l && f < Math.min(p, d) && (l = !0), p <= (l ? d : f)))
    (u = Math.max(i.top, Math.min(n.top, i.bottom - m)) - e.top), (h = Math.min(400, l ? d : f));
  else {
    (a = !0), (h = Math.min(400, (s ? e.right : i.right - e.left) - 30));
    let g = i.bottom - e.bottom;
    g >= m || g > e.top ? (u = n.bottom - e.top) : ((c = "bottom"), (u = e.bottom - n.top));
  }
  let O = (e.bottom - e.top) / o.offsetHeight,
    v = (e.right - e.left) / o.offsetWidth;
  return {
    style: `${c}: ${u / O}px; max-width: ${h / v}px`,
    class: "cm-completionInfo-" + (a ? (s ? "left-narrow" : "right-narrow") : l ? "left" : "right"),
  };
}
function rie(t) {
  let e = t.addToOptions.slice();
  return (
    t.icons &&
      e.push({
        render(n) {
          let r = document.createElement("div");
          return (
            r.classList.add("cm-completionIcon"),
            n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)),
            r.setAttribute("aria-hidden", "true"),
            r
          );
        },
        position: 20,
      }),
    e.push(
      {
        render(n, r, i, o) {
          let s = document.createElement("span");
          s.className = "cm-completionLabel";
          let l = n.displayLabel || n.label,
            a = 0;
          for (let c = 0; c < o.length; ) {
            let u = o[c++],
              h = o[c++];
            u > a && s.appendChild(document.createTextNode(l.slice(a, u)));
            let d = s.appendChild(document.createElement("span"));
            d.appendChild(document.createTextNode(l.slice(u, h))), (d.className = "cm-completionMatchedText"), (a = h);
          }
          return a < l.length && s.appendChild(document.createTextNode(l.slice(a))), s;
        },
        position: 50,
      },
      {
        render(n) {
          if (!n.detail) return null;
          let r = document.createElement("span");
          return (r.className = "cm-completionDetail"), (r.textContent = n.detail), r;
        },
        position: 80,
      }
    ),
    e.sort((n, r) => n.position - r.position).map((n) => n.render)
  );
}
function w1(t, e, n) {
  if (t <= n) return { from: 0, to: t };
  if ((e < 0 && (e = 0), e <= t >> 1)) {
    let i = Math.floor(e / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((t - e) / n);
  return { from: t - (r + 1) * n, to: t - r * n };
}
class iie {
  constructor(e, n, r) {
    (this.view = e),
      (this.stateField = n),
      (this.applyCompletion = r),
      (this.info = null),
      (this.infoDestroy = null),
      (this.placeInfoReq = { read: () => this.measureInfo(), write: (a) => this.placeInfo(a), key: this }),
      (this.space = null),
      (this.currentClass = "");
    let i = e.state.field(n),
      { options: o, selected: s } = i.open,
      l = e.state.facet(hn);
    (this.optionContent = rie(l)),
      (this.optionClass = l.optionClass),
      (this.tooltipClass = l.tooltipClass),
      (this.range = w1(o.length, s, l.maxRenderedOptions)),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-tooltip-autocomplete"),
      this.updateTooltipClass(e.state),
      this.dom.addEventListener("mousedown", (a) => {
        let { options: c } = e.state.field(n).open;
        for (let u = a.target, h; u && u != this.dom; u = u.parentNode)
          if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
            this.applyCompletion(e, c[+h[1]]), a.preventDefault();
            return;
          }
      }),
      this.dom.addEventListener("focusout", (a) => {
        let c = e.state.field(this.stateField, !1);
        c && c.tooltip && e.state.facet(hn).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: Pu.of(null) });
      }),
      this.showOptions(o, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(),
      (this.list = this.dom.appendChild(this.createListBox(e, n, this.range))),
      this.list.addEventListener("scroll", () => {
        this.info && this.view.requestMeasure(this.placeInfoReq);
      });
  }
  update(e) {
    var n;
    let r = e.state.field(this.stateField),
      i = e.startState.field(this.stateField);
    if ((this.updateTooltipClass(e.state), r != i)) {
      let { options: o, selected: s, disabled: l } = r.open;
      (!i.open || i.open.options != o) && ((this.range = w1(o.length, s, e.state.facet(hn).maxRenderedOptions)), this.showOptions(o, r.id)),
        this.updateSel(),
        l != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) &&
          this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" ")) r && this.dom.classList.remove(r);
      for (let r of n.split(" ")) r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(e) {
    (this.space = e), this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField),
      n = e.open;
    if (
      (((n.selected > -1 && n.selected < this.range.from) || n.selected >= this.range.to) &&
        ((this.range = w1(n.options.length, n.selected, this.view.state.facet(hn).maxRenderedOptions)), this.showOptions(n.options, e.id)),
      this.updateSelectedOption(n.selected))
    ) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected],
        { info: i } = r;
      if (!i) return;
      let o = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!o) return;
      "then" in o
        ? o
            .then((s) => {
              s && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(s, r);
            })
            .catch((s) => jn(this.view.state, s, "completion info"))
        : this.addInfoPane(o, r);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let r = (this.info = document.createElement("div"));
    if (((r.className = "cm-tooltip cm-completionInfo"), e.nodeType != null)) r.appendChild(e), (this.infoDestroy = null);
    else {
      let { dom: i, destroy: o } = e;
      r.appendChild(i), (this.infoDestroy = o || null);
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id
        ? i--
        : i == e
        ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), (n = r))
        : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && sie(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info) return null;
    let n = this.dom.getBoundingClientRect(),
      r = this.info.getBoundingClientRect(),
      i = e.getBoundingClientRect(),
      o = this.space;
    if (!o) {
      let s = this.dom.ownerDocument.defaultView || window;
      o = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight };
    }
    return i.top > Math.min(o.bottom, n.bottom) - 10 || i.bottom < Math.max(o.top, n.top) + 10
      ? null
      : this.view.state.facet(hn).positionInfo(this.view, n, i, r, o, this.dom);
  }
  placeInfo(e) {
    this.info &&
      (e
        ? (e.style && (this.info.style.cssText = e.style), (this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")))
        : (this.info.style.cssText = "top: -1e6px"));
  }
  createListBox(e, n, r) {
    const i = document.createElement("ul");
    (i.id = n),
      i.setAttribute("role", "listbox"),
      i.setAttribute("aria-expanded", "true"),
      i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let o = null;
    for (let s = r.from; s < r.to; s++) {
      let { completion: l, match: a } = e[s],
        { section: c } = l;
      if (c) {
        let d = typeof c == "string" ? c : c.name;
        if (d != o && (s > r.from || r.from == 0))
          if (((o = d), typeof c != "string" && c.header)) i.appendChild(c.header(c));
          else {
            let f = i.appendChild(document.createElement("completion-section"));
            f.textContent = d;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      (u.id = n + "-" + s), u.setAttribute("role", "option");
      let h = this.optionClass(l);
      h && (u.className = h);
      for (let d of this.optionContent) {
        let f = d(l, this.view.state, this.view, a);
        f && u.appendChild(f);
      }
    }
    return (
      r.from && i.classList.add("cm-completionListIncompleteTop"),
      r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"),
      i
    );
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), (this.info = null));
  }
  destroy() {
    this.destroyInfo();
  }
}
function oie(t, e) {
  return (n) => new iie(n, t, e);
}
function sie(t, e) {
  let n = t.getBoundingClientRect(),
    r = e.getBoundingClientRect(),
    i = n.height / t.offsetHeight;
  r.top < n.top ? (t.scrollTop -= (n.top - r.top) / i) : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
}
function Y5(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function lie(t, e) {
  let n = [],
    r = null,
    i = (c) => {
      n.push(c);
      let { section: u } = c.completion;
      if (u) {
        r || (r = []);
        let h = typeof u == "string" ? u : u.name;
        r.some((d) => d.name == h) || r.push(typeof u == "string" ? { name: h } : u);
      }
    },
    o = e.facet(hn);
  for (let c of t)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === !1) for (let h of c.result.options) i(new U5(h, c.source, u ? u(h) : [], 1e9 - n.length));
      else {
        let h = e.sliceDoc(c.from, c.to),
          d,
          f = o.filterStrict ? new tie(h) : new eie(h);
        for (let p of c.result.options)
          if ((d = f.match(p.label))) {
            let m = p.displayLabel ? (u ? u(p, d.matched) : []) : d.matched;
            i(new U5(p, c.source, m, d.score + (p.boost || 0)));
          }
      }
    }
  if (r) {
    let c = Object.create(null),
      u = 0,
      h = (d, f) => {
        var p, m;
        return (
          ((p = d.rank) !== null && p !== void 0 ? p : 1e9) - ((m = f.rank) !== null && m !== void 0 ? m : 1e9) ||
          (d.name < f.name ? -1 : 1)
        );
      };
    for (let d of r.sort(h)) (u -= 1e5), (c[d.name] = u);
    for (let d of n) {
      let { section: f } = d.completion;
      f && (d.score += c[typeof f == "string" ? f : f.name]);
    }
  }
  let s = [],
    l = null,
    a = o.compareCompletions;
  for (let c of n.sort((u, h) => h.score - u.score || a(u.completion, h.completion))) {
    let u = c.completion;
    !l ||
    l.label != u.label ||
    l.detail != u.detail ||
    (l.type != null && u.type != null && l.type != u.type) ||
    l.apply != u.apply ||
    l.boost != u.boost
      ? s.push(c)
      : Y5(c.completion) > Y5(l) && (s[s.length - 1] = c),
      (l = c.completion);
  }
  return s;
}
class wl {
  constructor(e, n, r, i, o, s) {
    (this.options = e), (this.attrs = n), (this.tooltip = r), (this.timestamp = i), (this.selected = o), (this.disabled = s);
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length
      ? this
      : new wl(this.options, G5(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, r, i, o) {
    let s = lie(e, n);
    if (!s.length) return i && e.some((a) => a.state == 1) ? new wl(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let l = n.facet(hn).selectOnOpen ? 0 : -1;
    if (i && i.selected != l && i.selected != -1) {
      let a = i.options[i.selected].completion;
      for (let c = 0; c < s.length; c++)
        if (s[c].completion == a) {
          l = c;
          break;
        }
    }
    return new wl(
      s,
      G5(r, l),
      { pos: e.reduce((a, c) => (c.hasResult() ? Math.min(a, c.from) : a), 1e8), create: fie, above: o.aboveCursor },
      i ? i.timestamp : Date.now(),
      l,
      !1
    );
  }
  map(e) {
    return new wl(
      this.options,
      this.attrs,
      Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }),
      this.timestamp,
      this.selected,
      this.disabled
    );
  }
}
class bp {
  constructor(e, n, r) {
    (this.active = e), (this.id = n), (this.open = r);
  }
  static start() {
    return new bp(hie, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e,
      r = n.facet(hn),
      o = (r.override || n.languageDataAt("autocomplete", Po(n)).map(Kre)).map((l) =>
        (this.active.find((c) => c.source == l) || new nr(l, this.active.some((c) => c.state != 0) ? 1 : 0)).update(e, r)
      );
    o.length == this.active.length && o.every((l, a) => l == this.active[a]) && (o = this.active);
    let s = this.open;
    s && e.docChanged && (s = s.map(e.changes)),
      e.selection || o.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !aie(o, this.active)
        ? (s = wl.build(o, n, this.id, s, r))
        : s && s.disabled && !o.some((l) => l.state == 1) && (s = null),
      !s && o.every((l) => l.state != 1) && o.some((l) => l.hasResult()) && (o = o.map((l) => (l.hasResult() ? new nr(l.source, 0) : l)));
    for (let l of e.effects) l.is(D4) && (s = s && s.setSelected(l.value, this.id));
    return o == this.active && s == this.open ? this : new bp(o, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? cie : uie;
  }
}
function aie(t, e) {
  if (t == e) return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < t.length && !t[n].hasResult; ) n++;
    for (; r < e.length && !e[r].hasResult; ) r++;
    let i = n == t.length,
      o = r == e.length;
    if (i || o) return i == o;
    if (t[n++].result != e[r++].result) return !1;
  }
}
const cie = { "aria-autocomplete": "list" },
  uie = {};
function G5(t, e) {
  let n = { "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-controls": t };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const hie = [];
function N4(t, e) {
  if (t.isUserEvent("input.complete")) {
    let r = t.annotation(qy);
    if (r && e.activateOnCompletion(r)) return 12;
  }
  let n = t.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class nr {
  constructor(e, n, r = -1) {
    (this.source = e), (this.state = n), (this.explicitPos = r);
  }
  hasResult() {
    return !1;
  }
  update(e, n) {
    let r = N4(e, n),
      i = this;
    (r & 8 || (r & 16 && this.touches(e))) && (i = new nr(i.source, 0)),
      r & 4 && i.state == 0 && (i = new nr(this.source, 1)),
      (i = i.updateFor(e, r));
    for (let o of e.effects)
      if (o.is(vp)) i = new nr(i.source, 1, o.value ? Po(e.state) : -1);
      else if (o.is(Pu)) i = new nr(i.source, 0);
      else if (o.is(Q4)) for (let s of o.value) s.source == i.source && (i = s);
    return i;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new nr(this.source, this.state, e.mapPos(this.explicitPos));
  }
  touches(e) {
    return e.changes.touchesRange(Po(e.state));
  }
}
class Fl extends nr {
  constructor(e, n, r, i, o) {
    super(e, 2, n), (this.result = r), (this.from = i), (this.to = o);
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var r;
    if (!(n & 3)) return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let o = e.changes.mapPos(this.from),
      s = e.changes.mapPos(this.to, 1),
      l = Po(e.state);
    if ((this.explicitPos < 0 ? l <= o : l < this.from) || l > s || !i || (n & 2 && Po(e.startState) == this.from))
      return new nr(this.source, n & 4 ? 1 : 0);
    let a = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
    return die(i.validFor, e.state, o, s)
      ? new Fl(this.source, a, i, o, s)
      : i.update && (i = i.update(i, o, s, new Hy(e.state, l, a >= 0)))
      ? new Fl(this.source, a, i, i.from, (r = i.to) !== null && r !== void 0 ? r : Po(e.state))
      : new nr(this.source, 1, a);
  }
  map(e) {
    return e.empty
      ? this
      : (this.result.map ? this.result.map(this.result, e) : this.result)
      ? new Fl(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1))
      : new nr(this.source, 0);
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function die(t, e, n, r) {
  if (!t) return !1;
  let i = e.sliceDoc(n, r);
  return typeof t == "function" ? t(i, n, r, e) : L4(t, !0).test(i);
}
const Q4 = Ee.define({
    map(t, e) {
      return t.map((n) => n.map(e));
    },
  }),
  D4 = Ee.define(),
  Fn = Qt.define({
    create() {
      return bp.start();
    },
    update(t, e) {
      return t.update(e);
    },
    provide: (t) => [Ny.from(t, (e) => e.tooltip), re.contentAttributes.from(t, (e) => e.attrs)],
  });
function Yy(t, e) {
  const n = e.completion.apply || e.completion.label;
  let r = t.state.field(Fn).active.find((i) => i.source == e.source);
  return r instanceof Fl
    ? (typeof n == "string"
        ? t.dispatch(Object.assign(Object.assign({}, Jre(t.state, n, r.from, r.to)), { annotations: qy.of(e.completion) }))
        : n(t, e.completion, r.from, r.to),
      !0)
    : !1;
}
const fie = oie(Fn, Yy);
function Sd(t, e = "option") {
  return (n) => {
    let r = n.state.field(Fn, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(hn).interactionDelay) return !1;
    let i = 1,
      o;
    e == "page" &&
      (o = Y7(n, r.open.tooltip)) &&
      (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = r.open.options,
      l = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : s - 1;
    return l < 0 ? (l = e == "page" ? 0 : s - 1) : l >= s && (l = e == "page" ? s - 1 : 0), n.dispatch({ effects: D4.of(l) }), !0;
  };
}
const pie = (t) => {
    let e = t.state.field(Fn, !1);
    return t.state.readOnly ||
      !e ||
      !e.open ||
      e.open.selected < 0 ||
      e.open.disabled ||
      Date.now() - e.open.timestamp < t.state.facet(hn).interactionDelay
      ? !1
      : Yy(t, e.open.options[e.open.selected]);
  },
  mie = (t) => (t.state.field(Fn, !1) ? (t.dispatch({ effects: vp.of(!0) }), !0) : !1),
  gie = (t) => {
    let e = t.state.field(Fn, !1);
    return !e || !e.active.some((n) => n.state != 0) ? !1 : (t.dispatch({ effects: Pu.of(null) }), !0);
  };
class Oie {
  constructor(e, n) {
    (this.active = e), (this.context = n), (this.time = Date.now()), (this.updates = []), (this.done = void 0);
  }
}
const vie = 50,
  bie = 1e3,
  xie = At.fromClass(
    class {
      constructor(t) {
        (this.view = t),
          (this.debounceUpdate = -1),
          (this.running = []),
          (this.debounceAccept = -1),
          (this.pendingStart = !1),
          (this.composing = 0);
        for (let e of t.state.field(Fn).active) e.state == 1 && this.startQuery(e);
      }
      update(t) {
        let e = t.state.field(Fn),
          n = t.state.facet(hn);
        if (!t.selectionSet && !t.docChanged && t.startState.field(Fn) == e) return;
        let r = t.transactions.some((o) => {
          let s = N4(o, n);
          return s & 8 || ((o.selection || o.docChanged) && !(s & 3));
        });
        for (let o = 0; o < this.running.length; o++) {
          let s = this.running[o];
          if (r || (s.updates.length + t.transactions.length > vie && Date.now() - s.time > bie)) {
            for (let l of s.context.abortListeners)
              try {
                l();
              } catch (a) {
                jn(this.view.state, a);
              }
            (s.context.abortListeners = null), this.running.splice(o--, 1);
          } else s.updates.push(...t.transactions);
        }
        this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
          t.transactions.some((o) => o.effects.some((s) => s.is(vp))) && (this.pendingStart = !0);
        let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
        if (
          ((this.debounceUpdate = e.active.some((o) => o.state == 1 && !this.running.some((s) => s.active.source == o.source))
            ? setTimeout(() => this.startUpdate(), i)
            : -1),
          this.composing != 0)
        )
          for (let o of t.transactions)
            o.isUserEvent("input.type") ? (this.composing = 2) : this.composing == 2 && o.selection && (this.composing = 3);
      }
      startUpdate() {
        (this.debounceUpdate = -1), (this.pendingStart = !1);
        let { state: t } = this.view,
          e = t.field(Fn);
        for (let n of e.active) n.state == 1 && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
      }
      startQuery(t) {
        let { state: e } = this.view,
          n = Po(e),
          r = new Hy(e, n, t.explicitPos == n, this.view),
          i = new Oie(t, r);
        this.running.push(i),
          Promise.resolve(t.source(r)).then(
            (o) => {
              i.context.aborted || ((i.done = o || null), this.scheduleAccept());
            },
            (o) => {
              this.view.dispatch({ effects: Pu.of(null) }), jn(this.view.state, o);
            }
          );
      }
      scheduleAccept() {
        this.running.every((t) => t.done !== void 0)
          ? this.accept()
          : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(hn).updateSyncTime));
      }
      accept() {
        var t;
        this.debounceAccept > -1 && clearTimeout(this.debounceAccept), (this.debounceAccept = -1);
        let e = [],
          n = this.view.state.facet(hn);
        for (let r = 0; r < this.running.length; r++) {
          let i = this.running[r];
          if (i.done === void 0) continue;
          if ((this.running.splice(r--, 1), i.done)) {
            let s = new Fl(
              i.active.source,
              i.active.explicitPos,
              i.done,
              i.done.from,
              (t = i.done.to) !== null && t !== void 0 ? t : Po(i.updates.length ? i.updates[0].startState : this.view.state)
            );
            for (let l of i.updates) s = s.update(l, n);
            if (s.hasResult()) {
              e.push(s);
              continue;
            }
          }
          let o = this.view.state.field(Fn).active.find((s) => s.source == i.active.source);
          if (o && o.state == 1)
            if (i.done == null) {
              let s = new nr(i.active.source, 0);
              for (let l of i.updates) s = s.update(l, n);
              s.state != 1 && e.push(s);
            } else this.startQuery(o);
        }
        e.length && this.view.dispatch({ effects: Q4.of(e) });
      }
    },
    {
      eventHandlers: {
        blur(t) {
          let e = this.view.state.field(Fn, !1);
          if (e && e.tooltip && this.view.state.facet(hn).closeOnBlur) {
            let n = e.open && Y7(this.view, e.open.tooltip);
            (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Pu.of(null) }), 10);
          }
        },
        compositionstart() {
          this.composing = 1;
        },
        compositionend() {
          this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: vp.of(!1) }), 20), (this.composing = 0);
        },
      },
    }
  ),
  yie = typeof navigator == "object" && /Win/.test(navigator.platform),
  wie = zr.highest(
    re.domEventHandlers({
      keydown(t, e) {
        let n = e.state.field(Fn, !1);
        if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || (t.ctrlKey && !(yie && t.altKey)) || t.metaKey)
          return !1;
        let r = n.open.options[n.open.selected],
          i = n.active.find((s) => s.source == r.source),
          o = r.completion.commitCharacters || i.result.commitCharacters;
        return o && o.indexOf(t.key) > -1 && Yy(e, r), !1;
      },
    })
  ),
  F4 = re.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": { padding: "1px 3px", lineHeight: 1.2 },
        "& > li": { overflowX: "hidden", textOverflow: "ellipsis", cursor: "pointer" },
        "& > completion-section": { display: "list-item", borderBottom: "1px solid silver", paddingLeft: "0.5em", opacity: 0.7 },
      },
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#17c", color: "white" },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#347", color: "white" },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"···"',
      opacity: 0.5,
      display: "block",
      textAlign: "center",
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: "400px",
      boxSizing: "border-box",
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888",
    },
    ".cm-completionMatchedText": { textDecoration: "underline" },
    ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box",
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "'ƒ'" } },
    ".cm-completionIcon-class": { "&:after": { content: "'○'" } },
    ".cm-completionIcon-interface": { "&:after": { content: "'◌'" } },
    ".cm-completionIcon-variable": { "&:after": { content: "'𝑥'" } },
    ".cm-completionIcon-constant": { "&:after": { content: "'𝐶'" } },
    ".cm-completionIcon-type": { "&:after": { content: "'𝑡'" } },
    ".cm-completionIcon-enum": { "&:after": { content: "'∪'" } },
    ".cm-completionIcon-property": { "&:after": { content: "'□'" } },
    ".cm-completionIcon-keyword": { "&:after": { content: "'🔑︎'" } },
    ".cm-completionIcon-namespace": { "&:after": { content: "'▢'" } },
    ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } },
  });
class Sie {
  constructor(e, n, r, i) {
    (this.field = e), (this.line = n), (this.from = r), (this.to = i);
  }
}
class Gy {
  constructor(e, n, r) {
    (this.field = e), (this.from = n), (this.to = r);
  }
  map(e) {
    let n = e.mapPos(this.from, -1, un.TrackDel),
      r = e.mapPos(this.to, 1, un.TrackDel);
    return n == null || r == null ? null : new Gy(this.field, n, r);
  }
}
class Jy {
  constructor(e, n) {
    (this.lines = e), (this.fieldPositions = n);
  }
  instantiate(e, n) {
    let r = [],
      i = [n],
      o = e.doc.lineAt(n),
      s = /^\s*/.exec(o.text)[0];
    for (let a of this.lines) {
      if (r.length) {
        let c = s,
          u = /^\t*/.exec(a)[0].length;
        for (let h = 0; h < u; h++) c += e.facet(Rh);
        i.push(n + c.length - u), (a = c + a.slice(u));
      }
      r.push(a), (n += a.length + 1);
    }
    let l = this.fieldPositions.map((a) => new Gy(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: r, ranges: l };
  }
  static parse(e) {
    let n = [],
      r = [],
      i = [],
      o;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; (o = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(s)); ) {
        let l = o[1] ? +o[1] : null,
          a = o[2] || o[3] || "",
          c = -1,
          u = a.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < n.length; h++) (l != null ? n[h].seq == l : u && n[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < n.length && (l == null || (n[h].seq != null && n[h].seq < l)); ) h++;
          n.splice(h, 0, { seq: l, name: u }), (c = h);
          for (let d of i) d.field >= c && d.field++;
        }
        i.push(new Sie(c, r.length, o.index, o.index + u.length)), (s = s.slice(0, o.index) + a + s.slice(o.index + o[0].length));
      }
      (s = s.replace(/\\([{}])/g, (l, a, c) => {
        for (let u of i) u.line == r.length && u.from > c && (u.from--, u.to--);
        return a;
      })),
        r.push(s);
    }
    return new Jy(r, i);
  }
}
let kie = me.widget({
    widget: new (class extends Wr {
      toDOM() {
        let t = document.createElement("span");
        return (t.className = "cm-snippetFieldPosition"), t;
      }
      ignoreEvent() {
        return !1;
      }
    })(),
  }),
  Cie = me.mark({ class: "cm-snippetField" });
class ja {
  constructor(e, n) {
    (this.ranges = e), (this.active = n), (this.deco = me.set(e.map((r) => (r.from == r.to ? kie : Cie).range(r.from, r.to))));
  }
  map(e) {
    let n = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i) return null;
      n.push(i);
    }
    return new ja(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));
  }
}
const Lh = Ee.define({
    map(t, e) {
      return t && t.map(e);
    },
  }),
  _ie = Ee.define(),
  Au = Qt.define({
    create() {
      return null;
    },
    update(t, e) {
      for (let n of e.effects) {
        if (n.is(Lh)) return n.value;
        if (n.is(_ie) && t) return new ja(t.ranges, n.value);
      }
      return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
    },
    provide: (t) => re.decorations.from(t, (e) => (e ? e.deco : me.none)),
  });
function Ky(t, e) {
  return H.create(t.filter((n) => n.field == e).map((n) => H.range(n.from, n.to)));
}
function Eie(t) {
  let e = Jy.parse(t);
  return (n, r, i, o) => {
    let { text: s, ranges: l } = e.instantiate(n.state, i),
      a = {
        changes: { from: i, to: o, insert: et.of(s) },
        scrollIntoView: !0,
        annotations: r ? [qy.of(r), zt.userEvent.of("input.complete")] : void 0,
      };
    if ((l.length && (a.selection = Ky(l, 0)), l.some((c) => c.field > 0))) {
      let c = new ja(l, 0),
        u = (a.effects = [Lh.of(c)]);
      n.state.field(Au, !1) === void 0 && u.push(Ee.appendConfig.of([Au, Rie, Iie, F4]));
    }
    n.dispatch(n.state.update(a));
  };
}
function B4(t) {
  return ({ state: e, dispatch: n }) => {
    let r = e.field(Au, !1);
    if (!r || (t < 0 && r.active == 0)) return !1;
    let i = r.active + t,
      o = t > 0 && !r.ranges.some((s) => s.field == i + t);
    return n(e.update({ selection: Ky(r.ranges, i), effects: Lh.of(o ? null : new ja(r.ranges, i)), scrollIntoView: !0 })), !0;
  };
}
const Tie = ({ state: t, dispatch: e }) => (t.field(Au, !1) ? (e(t.update({ effects: Lh.of(null) })), !0) : !1),
  Pie = B4(1),
  Aie = B4(-1),
  $ie = [
    { key: "Tab", run: Pie, shift: Aie },
    { key: "Escape", run: Tie },
  ],
  J5 = xe.define({
    combine(t) {
      return t.length ? t[0] : $ie;
    },
  }),
  Rie = zr.highest(Qs.compute([J5], (t) => t.facet(J5)));
function Qn(t, e) {
  return Object.assign(Object.assign({}, e), { apply: Eie(t) });
}
const Iie = re.domEventHandlers({
    mousedown(t, e) {
      let n = e.state.field(Au, !1),
        r;
      if (!n || (r = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null) return !1;
      let i = n.ranges.find((o) => o.from <= r && o.to >= r);
      return !i || i.field == n.active
        ? !1
        : (e.dispatch({
            selection: Ky(n.ranges, i.field),
            effects: Lh.of(n.ranges.some((o) => o.field > i.field) ? new ja(n.ranges, i.field) : null),
            scrollIntoView: !0,
          }),
          !0);
    },
  }),
  $u = { brackets: ["(", "[", "{", "'", '"'], before: ")]}:;>", stringPrefixes: [] },
  gs = Ee.define({
    map(t, e) {
      let n = e.mapPos(t, -1, un.TrackAfter);
      return n ?? void 0;
    },
  }),
  ew = new (class extends Is {})();
ew.startSide = 1;
ew.endSide = -1;
const V4 = Qt.define({
  create() {
    return ze.empty;
  },
  update(t, e) {
    if (((t = t.map(e.changes)), e.selection)) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of e.effects) n.is(gs) && (t = t.update({ add: [ew.range(n.value, n.value + 1)] }));
    return t;
  },
});
function j4() {
  return [Lie, V4];
}
const S1 = "()[]{}<>";
function Z4(t) {
  for (let e = 0; e < S1.length; e += 2) if (S1.charCodeAt(e) == t) return S1.charAt(e + 1);
  return Cy(t < 128 ? t : t + 1);
}
function z4(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || $u;
}
const Mie = typeof navigator == "object" && /Android\b/.test(navigator.userAgent),
  Lie = re.inputHandler.of((t, e, n, r) => {
    if ((Mie ? t.composing : t.compositionStarted) || t.state.readOnly) return !1;
    let i = t.state.selection.main;
    if (r.length > 2 || (r.length == 2 && dr(an(r, 0)) == 1) || e != i.from || n != i.to) return !1;
    let o = Qie(t.state, r);
    return o ? (t.dispatch(o), !0) : !1;
  }),
  Nie = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let r = z4(t, t.selection.main.head).brackets || $u.brackets,
      i = null,
      o = t.changeByRange((s) => {
        if (s.empty) {
          let l = Die(t.doc, s.head);
          for (let a of r)
            if (a == l && rg(t.doc, s.head) == Z4(an(a, 0)))
              return { changes: { from: s.head - a.length, to: s.head + a.length }, range: H.cursor(s.head - a.length) };
        }
        return { range: (i = s) };
      });
    return i || e(t.update(o, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
  },
  W4 = [{ key: "Backspace", run: Nie }];
function Qie(t, e) {
  let n = z4(t, t.selection.main.head),
    r = n.brackets || $u.brackets;
  for (let i of r) {
    let o = Z4(an(i, 0));
    if (e == i) return o == i ? Vie(t, i, r.indexOf(i + i + i) > -1, n) : Fie(t, i, o, n.before || $u.before);
    if (e == o && X4(t, t.selection.main.from)) return Bie(t, i, o);
  }
  return null;
}
function X4(t, e) {
  let n = !1;
  return (
    t.field(V4).between(0, t.doc.length, (r) => {
      r == e && (n = !0);
    }),
    n
  );
}
function rg(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, dr(an(n, 0)));
}
function Die(t, e) {
  let n = t.sliceString(e - 2, e);
  return dr(an(n, 0)) == n.length ? n : n.slice(1);
}
function Fie(t, e, n, r) {
  let i = null,
    o = t.changeByRange((s) => {
      if (!s.empty)
        return {
          changes: [
            { insert: e, from: s.from },
            { insert: n, from: s.to },
          ],
          effects: gs.of(s.to + e.length),
          range: H.range(s.anchor + e.length, s.head + e.length),
        };
      let l = rg(t.doc, s.head);
      return !l || /\s/.test(l) || r.indexOf(l) > -1
        ? { changes: { insert: e + n, from: s.head }, effects: gs.of(s.head + e.length), range: H.cursor(s.head + e.length) }
        : { range: (i = s) };
    });
  return i ? null : t.update(o, { scrollIntoView: !0, userEvent: "input.type" });
}
function Bie(t, e, n) {
  let r = null,
    i = t.changeByRange((o) =>
      o.empty && rg(t.doc, o.head) == n
        ? { changes: { from: o.head, to: o.head + n.length, insert: n }, range: H.cursor(o.head + n.length) }
        : (r = { range: o })
    );
  return r ? null : t.update(i, { scrollIntoView: !0, userEvent: "input.type" });
}
function Vie(t, e, n, r) {
  let i = r.stringPrefixes || $u.stringPrefixes,
    o = null,
    s = t.changeByRange((l) => {
      if (!l.empty)
        return {
          changes: [
            { insert: e, from: l.from },
            { insert: e, from: l.to },
          ],
          effects: gs.of(l.to + e.length),
          range: H.range(l.anchor + e.length, l.head + e.length),
        };
      let a = l.head,
        c = rg(t.doc, a),
        u;
      if (c == e) {
        if (K5(t, a)) return { changes: { insert: e + e, from: a }, effects: gs.of(a + e.length), range: H.cursor(a + e.length) };
        if (X4(t, a)) {
          let d = n && t.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
          return { changes: { from: a, to: a + d.length, insert: d }, range: H.cursor(a + d.length) };
        }
      } else {
        if (n && t.sliceDoc(a - 2 * e.length, a) == e + e && (u = e_(t, a - 2 * e.length, i)) > -1 && K5(t, u))
          return { changes: { insert: e + e + e + e, from: a }, effects: gs.of(a + e.length), range: H.cursor(a + e.length) };
        if (t.charCategorizer(a)(c) != Et.Word && e_(t, a, i) > -1 && !jie(t, a, e, i))
          return { changes: { insert: e + e, from: a }, effects: gs.of(a + e.length), range: H.cursor(a + e.length) };
      }
      return { range: (o = l) };
    });
  return o ? null : t.update(s, { scrollIntoView: !0, userEvent: "input.type" });
}
function K5(t, e) {
  let n = at(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function jie(t, e, n, r) {
  let i = at(t).resolveInner(e, -1),
    o = r.reduce((s, l) => Math.max(s, l.length), 0);
  for (let s = 0; s < 5; s++) {
    let l = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + o)),
      a = l.indexOf(n);
    if (!a || (a > -1 && r.indexOf(l.slice(0, a)) > -1)) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > n.length + a; ) {
        if (t.sliceDoc(u.to - n.length, u.to) == n) return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c) break;
    i = c;
  }
  return !1;
}
function e_(t, e, n) {
  let r = t.charCategorizer(e);
  if (r(t.sliceDoc(e - 1, e)) != Et.Word) return e;
  for (let i of n) {
    let o = e - i.length;
    if (t.sliceDoc(o, e) == i && r(t.sliceDoc(o - 1, o)) != Et.Word) return o;
  }
  return -1;
}
function Zie(t = {}) {
  return [wie, Fn, hn.of(t), xie, zie, F4];
}
const U4 = [
    { key: "Ctrl-Space", run: mie },
    { key: "Escape", run: gie },
    { key: "ArrowDown", run: Sd(!0) },
    { key: "ArrowUp", run: Sd(!1) },
    { key: "PageDown", run: Sd(!0, "page") },
    { key: "PageUp", run: Sd(!1, "page") },
    { key: "Enter", run: pie },
  ],
  zie = zr.highest(Qs.computeN([hn], (t) => (t.facet(hn).defaultKeymap ? [U4] : []))),
  Wie = (t) => {
    let { state: e } = t,
      n = e.doc.lineAt(e.selection.main.from),
      r = nw(t.state, n.from);
    return r.line ? Xie(t) : r.block ? Hie(t) : !1;
  };
function tw(t, e) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly) return !1;
    let i = t(e, n);
    return i ? (r(n.update(i)), !0) : !1;
  };
}
const Xie = tw(Gie, 0),
  Uie = tw(H4, 0),
  Hie = tw((t, e) => H4(t, e, Yie(e)), 0);
function nw(t, e) {
  let n = t.languageDataAt("commentTokens", e);
  return n.length ? n[0] : {};
}
const cc = 50;
function qie(t, { open: e, close: n }, r, i) {
  let o = t.sliceDoc(r - cc, r),
    s = t.sliceDoc(i, i + cc),
    l = /\s*$/.exec(o)[0].length,
    a = /^\s*/.exec(s)[0].length,
    c = o.length - l;
  if (o.slice(c - e.length, c) == e && s.slice(a, a + n.length) == n)
    return { open: { pos: r - l, margin: l && 1 }, close: { pos: i + a, margin: a && 1 } };
  let u, h;
  i - r <= 2 * cc ? (u = h = t.sliceDoc(r, i)) : ((u = t.sliceDoc(r, r + cc)), (h = t.sliceDoc(i - cc, i)));
  let d = /^\s*/.exec(u)[0].length,
    f = /\s*$/.exec(h)[0].length,
    p = h.length - f - n.length;
  return u.slice(d, d + e.length) == e && h.slice(p, p + n.length) == n
    ? {
        open: { pos: r + d + e.length, margin: /\s/.test(u.charAt(d + e.length)) ? 1 : 0 },
        close: { pos: i - f - n.length, margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0 },
      }
    : null;
}
function Yie(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let r = t.doc.lineAt(n.from),
      i = n.to <= r.to ? r : t.doc.lineAt(n.to),
      o = e.length - 1;
    o >= 0 && e[o].to > r.from ? (e[o].to = i.to) : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function H4(t, e, n = e.selection.ranges) {
  let r = n.map((o) => nw(e, o.from).block);
  if (!r.every((o) => o)) return null;
  let i = n.map((o, s) => qie(e, r[s], o.from, o.to));
  if (t != 2 && !i.every((o) => o))
    return {
      changes: e.changes(
        n.map((o, s) =>
          i[s]
            ? []
            : [
                { from: o.from, insert: r[s].open + " " },
                { from: o.to, insert: " " + r[s].close },
              ]
        )
      ),
    };
  if (t != 1 && i.some((o) => o)) {
    let o = [];
    for (let s = 0, l; s < i.length; s++)
      if ((l = i[s])) {
        let a = r[s],
          { open: c, close: u } = l;
        o.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + a.close.length });
      }
    return { changes: o };
  }
  return null;
}
function Gie(t, e, n = e.selection.ranges) {
  let r = [],
    i = -1;
  for (let { from: o, to: s } of n) {
    let l = r.length,
      a = 1e9,
      c = nw(e, o).line;
    if (c) {
      for (let u = o; u <= s; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (o == s || s > h.from)) {
          i = h.from;
          let d = /^\s*/.exec(h.text)[0].length,
            f = d == h.length,
            p = h.text.slice(d, d + c.length) == c ? d : -1;
          d < h.text.length && d < a && (a = d), r.push({ line: h, comment: p, token: c, indent: d, empty: f, single: !1 });
        }
        u = h.to + 1;
      }
      if (a < 1e9) for (let u = l; u < r.length; u++) r[u].indent < r[u].line.text.length && (r[u].indent = a);
      r.length == l + 1 && (r[l].single = !0);
    }
  }
  if (t != 2 && r.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: l, token: a, indent: c, empty: u, single: h } of r) (h || !u) && o.push({ from: l.from + c, insert: a + " " });
    let s = e.changes(o);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (t != 1 && r.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: s, comment: l, token: a } of r)
      if (l >= 0) {
        let c = s.from + l,
          u = c + a.length;
        s.text[u - s.from] == " " && u++, o.push({ from: c, to: u });
      }
    return { changes: o };
  }
  return null;
}
const lv = Lr.define(),
  Jie = Lr.define(),
  Kie = xe.define(),
  q4 = xe.define({
    combine(t) {
      return Si(
        t,
        { minDepth: 100, newGroupDelay: 500, joinToEvent: (e, n) => n },
        { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i) }
      );
    },
  }),
  Y4 = Qt.define({
    create() {
      return hi.empty;
    },
    update(t, e) {
      let n = e.state.facet(q4),
        r = e.annotation(lv);
      if (r) {
        let a = Zn.fromTransaction(e, r.selection),
          c = r.side,
          u = c == 0 ? t.undone : t.done;
        return (
          a ? (u = xp(u, u.length, n.minDepth, a)) : (u = eR(u, e.startState.selection)), new hi(c == 0 ? r.rest : u, c == 0 ? u : r.rest)
        );
      }
      let i = e.annotation(Jie);
      if (((i == "full" || i == "before") && (t = t.isolate()), e.annotation(zt.addToHistory) === !1))
        return e.changes.empty ? t : t.addMapping(e.changes.desc);
      let o = Zn.fromTransaction(e),
        s = e.annotation(zt.time),
        l = e.annotation(zt.userEvent);
      return (
        o ? (t = t.addChanges(o, s, l, n, e)) : e.selection && (t = t.addSelection(e.startState.selection, s, l, n.newGroupDelay)),
        (i == "full" || i == "after") && (t = t.isolate()),
        t
      );
    },
    toJSON(t) {
      return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
    },
    fromJSON(t) {
      return new hi(t.done.map(Zn.fromJSON), t.undone.map(Zn.fromJSON));
    },
  });
function G4(t = {}) {
  return [
    Y4,
    q4.of(t),
    re.domEventHandlers({
      beforeinput(e, n) {
        let r = e.inputType == "historyUndo" ? J4 : e.inputType == "historyRedo" ? av : null;
        return r ? (e.preventDefault(), r(n)) : !1;
      },
    }),
  ];
}
function ig(t, e) {
  return function ({ state: n, dispatch: r }) {
    if (!e && n.readOnly) return !1;
    let i = n.field(Y4, !1);
    if (!i) return !1;
    let o = i.pop(t, n, e);
    return o ? (r(o), !0) : !1;
  };
}
const J4 = ig(0, !1),
  av = ig(1, !1),
  eoe = ig(0, !0),
  toe = ig(1, !0);
class Zn {
  constructor(e, n, r, i, o) {
    (this.changes = e), (this.effects = n), (this.mapped = r), (this.startSelection = i), (this.selectionsAfter = o);
  }
  setSelAfter(e) {
    return new Zn(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON()),
    };
  }
  static fromJSON(e) {
    return new Zn(
      e.changes && jt.fromJSON(e.changes),
      [],
      e.mapped && fi.fromJSON(e.mapped),
      e.startSelection && H.fromJSON(e.startSelection),
      e.selectionsAfter.map(H.fromJSON)
    );
  }
  static fromTransaction(e, n) {
    let r = pr;
    for (let i of e.startState.facet(Kie)) {
      let o = i(e);
      o.length && (r = r.concat(o));
    }
    return !r.length && e.changes.empty ? null : new Zn(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, pr);
  }
  static selection(e) {
    return new Zn(void 0, pr, void 0, void 0, e);
  }
}
function xp(t, e, n, r) {
  let i = e + 1 > n + 20 ? e - n - 1 : 0,
    o = t.slice(i, e);
  return o.push(r), o;
}
function noe(t, e) {
  let n = [],
    r = !1;
  return (
    t.iterChangedRanges((i, o) => n.push(i, o)),
    e.iterChangedRanges((i, o, s, l) => {
      for (let a = 0; a < n.length; ) {
        let c = n[a++],
          u = n[a++];
        l >= c && s <= u && (r = !0);
      }
    }),
    r
  );
}
function roe(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
}
function K4(t, e) {
  return t.length ? (e.length ? t.concat(e) : t) : e;
}
const pr = [],
  ioe = 200;
function eR(t, e) {
  if (t.length) {
    let n = t[t.length - 1],
      r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - ioe));
    return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), xp(t, t.length - 1, 1e9, n.setSelAfter(r)));
  } else return [Zn.selection([e])];
}
function ooe(t) {
  let e = t[t.length - 1],
    n = t.slice();
  return (n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1))), n;
}
function k1(t, e) {
  if (!t.length) return t;
  let n = t.length,
    r = pr;
  for (; n; ) {
    let i = soe(t[n - 1], e, r);
    if ((i.changes && !i.changes.empty) || i.effects.length) {
      let o = t.slice(0, n);
      return (o[n - 1] = i), o;
    } else (e = i.mapped), n--, (r = i.selectionsAfter);
  }
  return r.length ? [Zn.selection(r)] : pr;
}
function soe(t, e, n) {
  let r = K4(t.selectionsAfter.length ? t.selectionsAfter.map((l) => l.map(e)) : pr, n);
  if (!t.changes) return Zn.selection(r);
  let i = t.changes.map(e),
    o = e.mapDesc(t.changes, !0),
    s = t.mapped ? t.mapped.composeDesc(o) : o;
  return new Zn(i, Ee.mapEffects(t.effects, e), s, t.startSelection.map(o), r);
}
const loe = /^(input\.type|delete)($|\.)/;
class hi {
  constructor(e, n, r = 0, i = void 0) {
    (this.done = e), (this.undone = n), (this.prevTime = r), (this.prevUserEvent = i);
  }
  isolate() {
    return this.prevTime ? new hi(this.done, this.undone) : this;
  }
  addChanges(e, n, r, i, o) {
    let s = this.done,
      l = s[s.length - 1];
    return (
      l &&
      l.changes &&
      !l.changes.empty &&
      e.changes &&
      (!r || loe.test(r)) &&
      ((!l.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(o, noe(l.changes, e.changes))) ||
        r == "input.type.compose")
        ? (s = xp(
            s,
            s.length - 1,
            i.minDepth,
            new Zn(e.changes.compose(l.changes), K4(e.effects, l.effects), l.mapped, l.startSelection, pr)
          ))
        : (s = xp(s, s.length, i.minDepth, e)),
      new hi(s, pr, n, r)
    );
  }
  addSelection(e, n, r, i) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : pr;
    return o.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && roe(o[o.length - 1], e)
      ? this
      : new hi(eR(this.done, e), this.undone, n, r);
  }
  addMapping(e) {
    return new hi(k1(this.done, e), k1(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0) return null;
    let o = i[i.length - 1],
      s = o.selectionsAfter[0] || n.selection;
    if (r && o.selectionsAfter.length)
      return n.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: lv.of({ side: e, rest: ooe(i), selection: s }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0,
      });
    if (o.changes) {
      let l = i.length == 1 ? pr : i.slice(0, i.length - 1);
      return (
        o.mapped && (l = k1(l, o.mapped)),
        n.update({
          changes: o.changes,
          selection: o.startSelection,
          effects: o.effects,
          annotations: lv.of({ side: e, rest: l, selection: s }),
          filter: !1,
          userEvent: e == 0 ? "undo" : "redo",
          scrollIntoView: !0,
        })
      );
    } else return null;
  }
}
hi.empty = new hi(pr, pr);
const tR = [
  { key: "Mod-z", run: J4, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: av, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: av, preventDefault: !0 },
  { key: "Mod-u", run: eoe, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: toe, preventDefault: !0 },
];
function Za(t, e) {
  return H.create(t.ranges.map(e), t.mainIndex);
}
function ki(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Xr({ state: t, dispatch: e }, n) {
  let r = Za(t.selection, n);
  return r.eq(t.selection, !0) ? !1 : (e(ki(t, r)), !0);
}
function og(t, e) {
  return H.cursor(e ? t.to : t.from);
}
function nR(t, e) {
  return Xr(t, (n) => (n.empty ? t.moveByChar(n, e) : og(n, e)));
}
function wn(t) {
  return t.textDirectionAt(t.state.selection.main.head) == wt.LTR;
}
const rR = (t) => nR(t, !wn(t)),
  iR = (t) => nR(t, wn(t));
function oR(t, e) {
  return Xr(t, (n) => (n.empty ? t.moveByGroup(n, e) : og(n, e)));
}
const aoe = (t) => oR(t, !wn(t)),
  coe = (t) => oR(t, wn(t));
function uoe(t, e, n) {
  if (e.type.prop(n)) return !0;
  let r = e.to - e.from;
  return (r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to)))) || e.firstChild;
}
function sg(t, e, n) {
  let r = at(t).resolveInner(e.head),
    i = n ? Ae.closedBy : Ae.openedBy;
  for (let a = e.head; ; ) {
    let c = n ? r.childAfter(a) : r.childBefore(a);
    if (!c) break;
    uoe(t, c, i) ? (r = c) : (a = n ? c.to : c.from);
  }
  let o = r.type.prop(i),
    s,
    l;
  return (
    o && (s = n ? ui(t, r.from, 1) : ui(t, r.to, -1)) && s.matched ? (l = n ? s.end.to : s.end.from) : (l = n ? r.to : r.from),
    H.cursor(l, n ? -1 : 1)
  );
}
const hoe = (t) => Xr(t, (e) => sg(t.state, e, !wn(t))),
  doe = (t) => Xr(t, (e) => sg(t.state, e, wn(t)));
function sR(t, e) {
  return Xr(t, (n) => {
    if (!n.empty) return og(n, e);
    let r = t.moveVertically(n, e);
    return r.head != n.head ? r : t.moveToLineBoundary(n, e);
  });
}
const lR = (t) => sR(t, !1),
  aR = (t) => sR(t, !0);
function cR(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2,
    n = 0,
    r = 0,
    i;
  if (e) {
    for (let o of t.state.facet(re.scrollMargins)) {
      let s = o(t);
      s != null && s.top && (n = Math.max(s == null ? void 0 : s.top, n)),
        s != null && s.bottom && (r = Math.max(s == null ? void 0 : s.bottom, r));
    }
    i = t.scrollDOM.clientHeight - n - r;
  } else i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return { marginTop: n, marginBottom: r, selfScroll: e, height: Math.max(t.defaultLineHeight, i - 5) };
}
function uR(t, e) {
  let n = cR(t),
    { state: r } = t,
    i = Za(r.selection, (s) => (s.empty ? t.moveVertically(s, e, n.height) : og(s, e)));
  if (i.eq(r.selection)) return !1;
  let o;
  if (n.selfScroll) {
    let s = t.coordsAtPos(r.selection.main.head),
      l = t.scrollDOM.getBoundingClientRect(),
      a = l.top + n.marginTop,
      c = l.bottom - n.marginBottom;
    s && s.top > a && s.bottom < c && (o = re.scrollIntoView(i.main.head, { y: "start", yMargin: s.top - a }));
  }
  return t.dispatch(ki(r, i), { effects: o }), !0;
}
const t_ = (t) => uR(t, !1),
  cv = (t) => uR(t, !0);
function ts(t, e, n) {
  let r = t.lineBlockAt(e.head),
    i = t.moveToLineBoundary(e, n);
  if ((i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, !1)), !n && i.head == r.from && r.length)) {
    let o = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    o && e.head != r.from + o && (i = H.cursor(r.from + o));
  }
  return i;
}
const foe = (t) => Xr(t, (e) => ts(t, e, !0)),
  poe = (t) => Xr(t, (e) => ts(t, e, !1)),
  moe = (t) => Xr(t, (e) => ts(t, e, !wn(t))),
  goe = (t) => Xr(t, (e) => ts(t, e, wn(t))),
  Ooe = (t) => Xr(t, (e) => H.cursor(t.lineBlockAt(e.head).from, 1)),
  voe = (t) => Xr(t, (e) => H.cursor(t.lineBlockAt(e.head).to, -1));
function boe(t, e, n) {
  let r = !1,
    i = Za(t.selection, (o) => {
      let s =
        ui(t, o.head, -1) || ui(t, o.head, 1) || (o.head > 0 && ui(t, o.head - 1, 1)) || (o.head < t.doc.length && ui(t, o.head + 1, -1));
      if (!s || !s.end) return o;
      r = !0;
      let l = s.start.from == o.head ? s.end.to : s.end.from;
      return n ? H.range(o.anchor, l) : H.cursor(l);
    });
  return r ? (e(ki(t, i)), !0) : !1;
}
const xoe = ({ state: t, dispatch: e }) => boe(t, e, !1);
function xr(t, e) {
  let n = Za(t.state.selection, (r) => {
    let i = e(r);
    return H.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(ki(t.state, n)), !0);
}
function hR(t, e) {
  return xr(t, (n) => t.moveByChar(n, e));
}
const dR = (t) => hR(t, !wn(t)),
  fR = (t) => hR(t, wn(t));
function pR(t, e) {
  return xr(t, (n) => t.moveByGroup(n, e));
}
const yoe = (t) => pR(t, !wn(t)),
  woe = (t) => pR(t, wn(t)),
  Soe = (t) => xr(t, (e) => sg(t.state, e, !wn(t))),
  koe = (t) => xr(t, (e) => sg(t.state, e, wn(t)));
function mR(t, e) {
  return xr(t, (n) => t.moveVertically(n, e));
}
const gR = (t) => mR(t, !1),
  OR = (t) => mR(t, !0);
function vR(t, e) {
  return xr(t, (n) => t.moveVertically(n, e, cR(t).height));
}
const n_ = (t) => vR(t, !1),
  r_ = (t) => vR(t, !0),
  Coe = (t) => xr(t, (e) => ts(t, e, !0)),
  _oe = (t) => xr(t, (e) => ts(t, e, !1)),
  Eoe = (t) => xr(t, (e) => ts(t, e, !wn(t))),
  Toe = (t) => xr(t, (e) => ts(t, e, wn(t))),
  Poe = (t) => xr(t, (e) => H.cursor(t.lineBlockAt(e.head).from)),
  Aoe = (t) => xr(t, (e) => H.cursor(t.lineBlockAt(e.head).to)),
  i_ = ({ state: t, dispatch: e }) => (e(ki(t, { anchor: 0 })), !0),
  o_ = ({ state: t, dispatch: e }) => (e(ki(t, { anchor: t.doc.length })), !0),
  s_ = ({ state: t, dispatch: e }) => (e(ki(t, { anchor: t.selection.main.anchor, head: 0 })), !0),
  l_ = ({ state: t, dispatch: e }) => (e(ki(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0),
  $oe = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0),
  Roe = ({ state: t, dispatch: e }) => {
    let n = lg(t).map(({ from: r, to: i }) => H.range(r, Math.min(i + 1, t.doc.length)));
    return e(t.update({ selection: H.create(n), userEvent: "select" })), !0;
  },
  Ioe = ({ state: t, dispatch: e }) => {
    let n = Za(t.selection, (r) => {
      var i;
      let o = at(t).resolveStack(r.from, 1);
      for (let s = o; s; s = s.next) {
        let { node: l } = s;
        if (
          ((l.from < r.from && l.to >= r.to) || (l.to > r.to && l.from <= r.from)) &&
          !((i = l.parent) === null || i === void 0) &&
          i.parent
        )
          return H.range(l.to, l.from);
      }
      return r;
    });
    return e(ki(t, n)), !0;
  },
  Moe = ({ state: t, dispatch: e }) => {
    let n = t.selection,
      r = null;
    return (
      n.ranges.length > 1 ? (r = H.create([n.main])) : n.main.empty || (r = H.create([H.cursor(n.main.head)])), r ? (e(ki(t, r)), !0) : !1
    );
  };
function Nh(t, e) {
  if (t.state.readOnly) return !1;
  let n = "delete.selection",
    { state: r } = t,
    i = r.changeByRange((o) => {
      let { from: s, to: l } = o;
      if (s == l) {
        let a = e(o);
        a < s ? ((n = "delete.backward"), (a = kd(t, a, !1))) : a > s && ((n = "delete.forward"), (a = kd(t, a, !0))),
          (s = Math.min(s, a)),
          (l = Math.max(l, a));
      } else (s = kd(t, s, !1)), (l = kd(t, l, !0));
      return s == l ? { range: o } : { changes: { from: s, to: l }, range: H.cursor(s, s < o.head ? -1 : 1) };
    });
  return i.changes.empty
    ? !1
    : (t.dispatch(
        r.update(i, {
          scrollIntoView: !0,
          userEvent: n,
          effects: n == "delete.selection" ? re.announce.of(r.phrase("Selection deleted")) : void 0,
        })
      ),
      !0);
}
function kd(t, e, n) {
  if (t instanceof re)
    for (let r of t.state.facet(re.atomicRanges).map((i) => i(t)))
      r.between(e, e, (i, o) => {
        i < e && o > e && (e = n ? o : i);
      });
  return e;
}
const bR = (t, e, n) =>
    Nh(t, (r) => {
      let i = r.from,
        { state: o } = t,
        s = o.doc.lineAt(i),
        l,
        a;
      if (n && !e && i > s.from && i < s.from + 200 && !/[^ \t]/.test((l = s.text.slice(0, i - s.from)))) {
        if (l[l.length - 1] == "	") return i - 1;
        let c = Nr(l, o.tabSize),
          u = c % Fs(o) || Fs(o);
        for (let h = 0; h < u && l[l.length - 1 - h] == " "; h++) i--;
        a = i;
      } else
        (a = dn(s.text, i - s.from, e, e) + s.from),
          a == i && s.number != (e ? o.doc.lines : 1)
            ? (a += e ? 1 : -1)
            : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(a - s.from, i - s.from)) && (a = dn(s.text, a - s.from, !1, !1) + s.from);
      return a;
    }),
  uv = (t) => bR(t, !1, !0),
  xR = (t) => bR(t, !0, !1),
  yR = (t, e) =>
    Nh(t, (n) => {
      let r = n.head,
        { state: i } = t,
        o = i.doc.lineAt(r),
        s = i.charCategorizer(r);
      for (let l = null; ; ) {
        if (r == (e ? o.to : o.from)) {
          r == n.head && o.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
          break;
        }
        let a = dn(o.text, r - o.from, e) + o.from,
          c = o.text.slice(Math.min(r, a) - o.from, Math.max(r, a) - o.from),
          u = s(c);
        if (l != null && u != l) break;
        (c != " " || r != n.head) && (l = u), (r = a);
      }
      return r;
    }),
  rw = (t) => yR(t, !1),
  Loe = (t) => yR(t, !0),
  Noe = (t) =>
    Nh(t, (e) => {
      let n = t.lineBlockAt(e.head).to;
      return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
    }),
  Qoe = (t) =>
    Nh(t, (e) => {
      let n = t.moveToLineBoundary(e, !1).head;
      return e.head > n ? n : Math.max(0, e.head - 1);
    }),
  Doe = (t) =>
    Nh(t, (e) => {
      let n = t.moveToLineBoundary(e, !0).head;
      return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
    }),
  Foe = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let n = t.changeByRange((r) => ({ changes: { from: r.from, to: r.to, insert: et.of(["", ""]) }, range: H.cursor(r.from) }));
    return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  },
  Boe = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let n = t.changeByRange((r) => {
      if (!r.empty || r.from == 0 || r.from == t.doc.length) return { range: r };
      let i = r.from,
        o = t.doc.lineAt(i),
        s = i == o.from ? i - 1 : dn(o.text, i - o.from, !1) + o.from,
        l = i == o.to ? i + 1 : dn(o.text, i - o.from, !0) + o.from;
      return { changes: { from: s, to: l, insert: t.doc.slice(i, l).append(t.doc.slice(s, i)) }, range: H.cursor(l) };
    });
    return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
  };
function lg(t) {
  let e = [],
    n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.from),
      o = t.doc.lineAt(r.to);
    if ((!r.empty && r.to == o.from && (o = t.doc.lineAt(r.to - 1)), n >= i.number)) {
      let s = e[e.length - 1];
      (s.to = o.to), s.ranges.push(r);
    } else e.push({ from: i.from, to: o.to, ranges: [r] });
    n = o.number + 1;
  }
  return e;
}
function wR(t, e, n) {
  if (t.readOnly) return !1;
  let r = [],
    i = [];
  for (let o of lg(t)) {
    if (n ? o.to == t.doc.length : o.from == 0) continue;
    let s = t.doc.lineAt(n ? o.to + 1 : o.from - 1),
      l = s.length + 1;
    if (n) {
      r.push({ from: o.to, to: s.to }, { from: o.from, insert: s.text + t.lineBreak });
      for (let a of o.ranges) i.push(H.range(Math.min(t.doc.length, a.anchor + l), Math.min(t.doc.length, a.head + l)));
    } else {
      r.push({ from: s.from, to: o.from }, { from: o.to, insert: t.lineBreak + s.text });
      for (let a of o.ranges) i.push(H.range(a.anchor - l, a.head - l));
    }
  }
  return r.length
    ? (e(t.update({ changes: r, scrollIntoView: !0, selection: H.create(i, t.selection.mainIndex), userEvent: "move.line" })), !0)
    : !1;
}
const Voe = ({ state: t, dispatch: e }) => wR(t, e, !1),
  joe = ({ state: t, dispatch: e }) => wR(t, e, !0);
function SR(t, e, n) {
  if (t.readOnly) return !1;
  let r = [];
  for (let i of lg(t))
    n
      ? r.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak })
      : r.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Zoe = ({ state: t, dispatch: e }) => SR(t, e, !1),
  zoe = ({ state: t, dispatch: e }) => SR(t, e, !0),
  Woe = (t) => {
    if (t.state.readOnly) return !1;
    let { state: e } = t,
      n = e.changes(lg(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, { from: i, to: o }))),
      r = Za(e.selection, (i) => {
        let o;
        if (t.lineWrapping) {
          let s = t.lineBlockAt(i.head),
            l = t.coordsAtPos(i.head, i.assoc || 1);
          l && (o = s.bottom + t.documentTop - l.bottom + t.defaultLineHeight / 2);
        }
        return t.moveVertically(i, !0, o);
      }).map(n);
    return t.dispatch({ changes: n, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
  };
function Xoe(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1))) return { from: e, to: e };
  let n = at(t).resolveInner(e),
    r = n.childBefore(e),
    i = n.childAfter(e),
    o;
  return r &&
    i &&
    r.to <= e &&
    i.from >= e &&
    (o = r.type.prop(Ae.closedBy)) &&
    o.indexOf(i.name) > -1 &&
    t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from &&
    !/\S/.test(t.sliceDoc(r.to, i.from))
    ? { from: r.to, to: i.from }
    : null;
}
const Uoe = kR(!1),
  Hoe = kR(!0);
function kR(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly) return !1;
    let r = e.changeByRange((i) => {
      let { from: o, to: s } = i,
        l = e.doc.lineAt(o),
        a = !t && o == s && Xoe(e, o);
      t && (o = s = (s <= l.to ? l : e.doc.lineAt(s)).to);
      let c = new tg(e, { simulateBreak: o, simulateDoubleBreak: !!a }),
        u = Vy(c, o);
      for (u == null && (u = Nr(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < l.to && /\s/.test(l.text[s - l.from]); ) s++;
      a ? ({ from: o, to: s } = a) : o > l.from && o < l.from + 100 && !/\S/.test(l.text.slice(0, o)) && (o = l.from);
      let h = ["", Eu(e, u)];
      return (
        a && h.push(Eu(e, c.lineIndent(l.from, -1))),
        { changes: { from: o, to: s, insert: et.of(h) }, range: H.cursor(o + 1 + h[1].length) }
      );
    });
    return n(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function iw(t, e) {
  let n = -1;
  return t.changeByRange((r) => {
    let i = [];
    for (let s = r.from; s <= r.to; ) {
      let l = t.doc.lineAt(s);
      l.number > n && (r.empty || r.to > l.from) && (e(l, i, r), (n = l.number)), (s = l.to + 1);
    }
    let o = t.changes(i);
    return { changes: i, range: H.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1)) };
  });
}
const qoe = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let n = Object.create(null),
      r = new tg(t, {
        overrideIndentation: (o) => {
          let s = n[o];
          return s ?? -1;
        },
      }),
      i = iw(t, (o, s, l) => {
        let a = Vy(r, o.from);
        if (a == null) return;
        /\S/.test(o.text) || (a = 0);
        let c = /^\s*/.exec(o.text)[0],
          u = Eu(t, a);
        (c != u || l.from < o.from + c.length) && ((n[o.from] = a), s.push({ from: o.from, to: o.from + c.length, insert: u }));
      });
    return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
  },
  CR = ({ state: t, dispatch: e }) =>
    t.readOnly
      ? !1
      : (e(
          t.update(
            iw(t, (n, r) => {
              r.push({ from: n.from, insert: t.facet(Rh) });
            }),
            { userEvent: "input.indent" }
          )
        ),
        !0),
  _R = ({ state: t, dispatch: e }) =>
    t.readOnly
      ? !1
      : (e(
          t.update(
            iw(t, (n, r) => {
              let i = /^\s*/.exec(n.text)[0];
              if (!i) return;
              let o = Nr(i, t.tabSize),
                s = 0,
                l = Eu(t, Math.max(0, o - Fs(t)));
              for (; s < i.length && s < l.length && i.charCodeAt(s) == l.charCodeAt(s); ) s++;
              r.push({ from: n.from + s, to: n.from + i.length, insert: l.slice(s) });
            }),
            { userEvent: "delete.dedent" }
          )
        ),
        !0),
  Yoe = (t) => (t.setTabFocusMode(), !0),
  Goe = [
    { key: "Ctrl-b", run: rR, shift: dR, preventDefault: !0 },
    { key: "Ctrl-f", run: iR, shift: fR },
    { key: "Ctrl-p", run: lR, shift: gR },
    { key: "Ctrl-n", run: aR, shift: OR },
    { key: "Ctrl-a", run: Ooe, shift: Poe },
    { key: "Ctrl-e", run: voe, shift: Aoe },
    { key: "Ctrl-d", run: xR },
    { key: "Ctrl-h", run: uv },
    { key: "Ctrl-k", run: Noe },
    { key: "Ctrl-Alt-h", run: rw },
    { key: "Ctrl-o", run: Foe },
    { key: "Ctrl-t", run: Boe },
    { key: "Ctrl-v", run: cv },
  ],
  Joe = [
    { key: "ArrowLeft", run: rR, shift: dR, preventDefault: !0 },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: aoe, shift: yoe, preventDefault: !0 },
    { mac: "Cmd-ArrowLeft", run: moe, shift: Eoe, preventDefault: !0 },
    { key: "ArrowRight", run: iR, shift: fR, preventDefault: !0 },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: coe, shift: woe, preventDefault: !0 },
    { mac: "Cmd-ArrowRight", run: goe, shift: Toe, preventDefault: !0 },
    { key: "ArrowUp", run: lR, shift: gR, preventDefault: !0 },
    { mac: "Cmd-ArrowUp", run: i_, shift: s_ },
    { mac: "Ctrl-ArrowUp", run: t_, shift: n_ },
    { key: "ArrowDown", run: aR, shift: OR, preventDefault: !0 },
    { mac: "Cmd-ArrowDown", run: o_, shift: l_ },
    { mac: "Ctrl-ArrowDown", run: cv, shift: r_ },
    { key: "PageUp", run: t_, shift: n_ },
    { key: "PageDown", run: cv, shift: r_ },
    { key: "Home", run: poe, shift: _oe, preventDefault: !0 },
    { key: "Mod-Home", run: i_, shift: s_ },
    { key: "End", run: foe, shift: Coe, preventDefault: !0 },
    { key: "Mod-End", run: o_, shift: l_ },
    { key: "Enter", run: Uoe },
    { key: "Mod-a", run: $oe },
    { key: "Backspace", run: uv, shift: uv },
    { key: "Delete", run: xR },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: rw },
    { key: "Mod-Delete", mac: "Alt-Delete", run: Loe },
    { mac: "Mod-Backspace", run: Qoe },
    { mac: "Mod-Delete", run: Doe },
  ].concat(Goe.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))),
  ER = [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: hoe, shift: Soe },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: doe, shift: koe },
    { key: "Alt-ArrowUp", run: Voe },
    { key: "Shift-Alt-ArrowUp", run: Zoe },
    { key: "Alt-ArrowDown", run: joe },
    { key: "Shift-Alt-ArrowDown", run: zoe },
    { key: "Escape", run: Moe },
    { key: "Mod-Enter", run: Hoe },
    { key: "Alt-l", mac: "Ctrl-l", run: Roe },
    { key: "Mod-i", run: Ioe, preventDefault: !0 },
    { key: "Mod-[", run: _R },
    { key: "Mod-]", run: CR },
    { key: "Mod-Alt-\\", run: qoe },
    { key: "Shift-Mod-k", run: Woe },
    { key: "Shift-Mod-\\", run: xoe },
    { key: "Mod-/", run: Wie },
    { key: "Alt-A", run: Uie },
    { key: "Ctrl-m", mac: "Shift-Alt-m", run: Yoe },
  ].concat(Joe);
(function () {
  if (typeof window != "object") return;
  if (
    "IntersectionObserver" in window &&
    "IntersectionObserverEntry" in window &&
    "intersectionRatio" in window.IntersectionObserverEntry.prototype
  ) {
    "isIntersecting" in window.IntersectionObserverEntry.prototype ||
      Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get: function () {
          return this.intersectionRatio > 0;
        },
      });
    return;
  }
  var t = window.document,
    e = [],
    n = null,
    r = null;
  function i(g) {
    (this.time = g.time),
      (this.target = g.target),
      (this.rootBounds = f(g.rootBounds)),
      (this.boundingClientRect = f(g.boundingClientRect)),
      (this.intersectionRect = f(g.intersectionRect || d())),
      (this.isIntersecting = !!g.intersectionRect);
    var b = this.boundingClientRect,
      x = b.width * b.height,
      k = this.intersectionRect,
      w = k.width * k.height;
    x ? (this.intersectionRatio = Number((w / x).toFixed(4))) : (this.intersectionRatio = this.isIntersecting ? 1 : 0);
  }
  function o(g, b) {
    var x = b || {};
    if (typeof g != "function") throw new Error("callback must be a function");
    if (x.root && x.root.nodeType != 1) throw new Error("root must be an Element");
    (this._checkForIntersections = l(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT)),
      (this._callback = g),
      (this._observationTargets = []),
      (this._queuedEntries = []),
      (this._rootMarginValues = this._parseRootMargin(x.rootMargin)),
      (this.thresholds = this._initThresholds(x.threshold)),
      (this.root = x.root || null),
      (this.rootMargin = this._rootMarginValues
        .map(function (k) {
          return k.value + k.unit;
        })
        .join(" ")),
      (this._monitoringDocuments = []),
      (this._monitoringUnsubscribes = []);
  }
  (o.prototype.THROTTLE_TIMEOUT = 100),
    (o.prototype.POLL_INTERVAL = null),
    (o.prototype.USE_MUTATION_OBSERVER = !0),
    (o._setupCrossOriginUpdater = function () {
      return (
        n ||
          (n = function (g, b) {
            !g || !b ? (r = d()) : (r = p(g, b)),
              e.forEach(function (x) {
                x._checkForIntersections();
              });
          }),
        n
      );
    }),
    (o._resetCrossOriginUpdater = function () {
      (n = null), (r = null);
    }),
    (o.prototype.observe = function (g) {
      var b = this._observationTargets.some(function (x) {
        return x.element == g;
      });
      if (!b) {
        if (!(g && g.nodeType == 1)) throw new Error("target must be an Element");
        this._registerInstance(),
          this._observationTargets.push({ element: g, entry: null }),
          this._monitorIntersections(g.ownerDocument),
          this._checkForIntersections();
      }
    }),
    (o.prototype.unobserve = function (g) {
      (this._observationTargets = this._observationTargets.filter(function (b) {
        return b.element != g;
      })),
        this._unmonitorIntersections(g.ownerDocument),
        this._observationTargets.length == 0 && this._unregisterInstance();
    }),
    (o.prototype.disconnect = function () {
      (this._observationTargets = []), this._unmonitorAllIntersections(), this._unregisterInstance();
    }),
    (o.prototype.takeRecords = function () {
      var g = this._queuedEntries.slice();
      return (this._queuedEntries = []), g;
    }),
    (o.prototype._initThresholds = function (g) {
      var b = g || [0];
      return (
        Array.isArray(b) || (b = [b]),
        b.sort().filter(function (x, k, w) {
          if (typeof x != "number" || isNaN(x) || x < 0 || x > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
          return x !== w[k - 1];
        })
      );
    }),
    (o.prototype._parseRootMargin = function (g) {
      var b = g || "0px",
        x = b.split(/\s+/).map(function (k) {
          var w = /^(-?\d*\.?\d+)(px|%)$/.exec(k);
          if (!w) throw new Error("rootMargin must be specified in pixels or percent");
          return { value: parseFloat(w[1]), unit: w[2] };
        });
      return (x[1] = x[1] || x[0]), (x[2] = x[2] || x[0]), (x[3] = x[3] || x[1]), x;
    }),
    (o.prototype._monitorIntersections = function (g) {
      var b = g.defaultView;
      if (b && this._monitoringDocuments.indexOf(g) == -1) {
        var x = this._checkForIntersections,
          k = null,
          w = null;
        if (
          (this.POLL_INTERVAL
            ? (k = b.setInterval(x, this.POLL_INTERVAL))
            : (a(b, "resize", x, !0),
              a(g, "scroll", x, !0),
              this.USE_MUTATION_OBSERVER &&
                "MutationObserver" in b &&
                ((w = new b.MutationObserver(x)), w.observe(g, { attributes: !0, childList: !0, characterData: !0, subtree: !0 }))),
          this._monitoringDocuments.push(g),
          this._monitoringUnsubscribes.push(function () {
            var C = g.defaultView;
            C && (k && C.clearInterval(k), c(C, "resize", x, !0)), c(g, "scroll", x, !0), w && w.disconnect();
          }),
          g != ((this.root && this.root.ownerDocument) || t))
        ) {
          var y = v(g);
          y && this._monitorIntersections(y.ownerDocument);
        }
      }
    }),
    (o.prototype._unmonitorIntersections = function (g) {
      var b = this._monitoringDocuments.indexOf(g);
      if (b != -1) {
        var x = (this.root && this.root.ownerDocument) || t,
          k = this._observationTargets.some(function (C) {
            var P = C.element.ownerDocument;
            if (P == g) return !0;
            for (; P && P != x; ) {
              var E = v(P);
              if (((P = E && E.ownerDocument), P == g)) return !0;
            }
            return !1;
          });
        if (!k) {
          var w = this._monitoringUnsubscribes[b];
          if ((this._monitoringDocuments.splice(b, 1), this._monitoringUnsubscribes.splice(b, 1), w(), g != x)) {
            var y = v(g);
            y && this._unmonitorIntersections(y.ownerDocument);
          }
        }
      }
    }),
    (o.prototype._unmonitorAllIntersections = function () {
      var g = this._monitoringUnsubscribes.slice(0);
      (this._monitoringDocuments.length = 0), (this._monitoringUnsubscribes.length = 0);
      for (var b = 0; b < g.length; b++) g[b]();
    }),
    (o.prototype._checkForIntersections = function () {
      if (!(!this.root && n && !r)) {
        var g = this._rootIsInDom(),
          b = g ? this._getRootRect() : d();
        this._observationTargets.forEach(function (x) {
          var k = x.element,
            w = h(k),
            y = this._rootContainsTarget(k),
            C = x.entry,
            P = g && y && this._computeTargetAndRootIntersection(k, w, b),
            E = (x.entry = new i({
              time: s(),
              target: k,
              boundingClientRect: w,
              rootBounds: n && !this.root ? null : b,
              intersectionRect: P,
            }));
          C
            ? g && y
              ? this._hasCrossedThreshold(C, E) && this._queuedEntries.push(E)
              : C && C.isIntersecting && this._queuedEntries.push(E)
            : this._queuedEntries.push(E);
        }, this),
          this._queuedEntries.length && this._callback(this.takeRecords(), this);
      }
    }),
    (o.prototype._computeTargetAndRootIntersection = function (g, b, x) {
      if (window.getComputedStyle(g).display != "none") {
        for (var k = b, w = O(g), y = !1; !y && w; ) {
          var C = null,
            P = w.nodeType == 1 ? window.getComputedStyle(w) : {};
          if (P.display == "none") return null;
          if (w == this.root || w.nodeType == 9)
            if (((y = !0), w == this.root || w == t))
              n && !this.root ? (!r || (r.width == 0 && r.height == 0) ? ((w = null), (C = null), (k = null)) : (C = r)) : (C = x);
            else {
              var E = O(w),
                N = E && h(E),
                L = E && this._computeTargetAndRootIntersection(E, N, x);
              N && L ? ((w = E), (C = p(N, L))) : ((w = null), (k = null));
            }
          else {
            var D = w.ownerDocument;
            w != D.body && w != D.documentElement && P.overflow != "visible" && (C = h(w));
          }
          if ((C && (k = u(C, k)), !k)) break;
          w = w && O(w);
        }
        return k;
      }
    }),
    (o.prototype._getRootRect = function () {
      var g;
      if (this.root) g = h(this.root);
      else {
        var b = t.documentElement,
          x = t.body;
        g = {
          top: 0,
          left: 0,
          right: b.clientWidth || x.clientWidth,
          width: b.clientWidth || x.clientWidth,
          bottom: b.clientHeight || x.clientHeight,
          height: b.clientHeight || x.clientHeight,
        };
      }
      return this._expandRectByRootMargin(g);
    }),
    (o.prototype._expandRectByRootMargin = function (g) {
      var b = this._rootMarginValues.map(function (k, w) {
          return k.unit == "px" ? k.value : (k.value * (w % 2 ? g.width : g.height)) / 100;
        }),
        x = { top: g.top - b[0], right: g.right + b[1], bottom: g.bottom + b[2], left: g.left - b[3] };
      return (x.width = x.right - x.left), (x.height = x.bottom - x.top), x;
    }),
    (o.prototype._hasCrossedThreshold = function (g, b) {
      var x = g && g.isIntersecting ? g.intersectionRatio || 0 : -1,
        k = b.isIntersecting ? b.intersectionRatio || 0 : -1;
      if (x !== k)
        for (var w = 0; w < this.thresholds.length; w++) {
          var y = this.thresholds[w];
          if (y == x || y == k || y < x != y < k) return !0;
        }
    }),
    (o.prototype._rootIsInDom = function () {
      return !this.root || m(t, this.root);
    }),
    (o.prototype._rootContainsTarget = function (g) {
      return m(this.root || t, g) && (!this.root || this.root.ownerDocument == g.ownerDocument);
    }),
    (o.prototype._registerInstance = function () {
      e.indexOf(this) < 0 && e.push(this);
    }),
    (o.prototype._unregisterInstance = function () {
      var g = e.indexOf(this);
      g != -1 && e.splice(g, 1);
    });
  function s() {
    return window.performance && performance.now && performance.now();
  }
  function l(g, b) {
    var x = null;
    return function () {
      x ||
        (x = setTimeout(function () {
          g(), (x = null);
        }, b));
    };
  }
  function a(g, b, x, k) {
    typeof g.addEventListener == "function"
      ? g.addEventListener(b, x, k || !1)
      : typeof g.attachEvent == "function" && g.attachEvent("on" + b, x);
  }
  function c(g, b, x, k) {
    typeof g.removeEventListener == "function"
      ? g.removeEventListener(b, x, k || !1)
      : typeof g.detatchEvent == "function" && g.detatchEvent("on" + b, x);
  }
  function u(g, b) {
    var x = Math.max(g.top, b.top),
      k = Math.min(g.bottom, b.bottom),
      w = Math.max(g.left, b.left),
      y = Math.min(g.right, b.right),
      C = y - w,
      P = k - x;
    return (C >= 0 && P >= 0 && { top: x, bottom: k, left: w, right: y, width: C, height: P }) || null;
  }
  function h(g) {
    var b;
    try {
      b = g.getBoundingClientRect();
    } catch {}
    return b
      ? ((b.width && b.height) ||
          (b = { top: b.top, right: b.right, bottom: b.bottom, left: b.left, width: b.right - b.left, height: b.bottom - b.top }),
        b)
      : d();
  }
  function d() {
    return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
  }
  function f(g) {
    return !g || "x" in g
      ? g
      : { top: g.top, y: g.top, bottom: g.bottom, left: g.left, x: g.left, right: g.right, width: g.width, height: g.height };
  }
  function p(g, b) {
    var x = b.top - g.top,
      k = b.left - g.left;
    return { top: x, left: k, height: b.height, width: b.width, bottom: x + b.height, right: k + b.width };
  }
  function m(g, b) {
    for (var x = b; x; ) {
      if (x == g) return !0;
      x = O(x);
    }
    return !1;
  }
  function O(g) {
    var b = g.parentNode;
    return g.nodeType == 9 && g != t
      ? v(g)
      : b && b.nodeType == 11 && b.host
      ? b.host
      : b && b.assignedSlot
      ? b.assignedSlot.parentNode
      : b;
  }
  function v(g) {
    try {
      return (g.defaultView && g.defaultView.frameElement) || null;
    } catch {
      return null;
    }
  }
  (window.IntersectionObserver = o), (window.IntersectionObserverEntry = i);
})();
const Koe = S[typeof document < "u" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"],
  ese = Koe;
function tse(t, e = {}) {
  const {
      root: n = null,
      pollInterval: r = null,
      useMutationObserver: i = !1,
      rootMargin: o = "0px 0px 0px 0px",
      threshold: s = 0,
      initialIsIntersecting: l = !1,
    } = e,
    [a, c] = _.useState(() => ({
      boundingClientRect: null,
      intersectionRatio: 0,
      intersectionRect: null,
      isIntersecting: l,
      rootBounds: null,
      target: null,
      time: 0,
    })),
    [u, h] = _.useState(() => c_({ root: n, pollInterval: r, useMutationObserver: i, rootMargin: o, threshold: s }));
  return (
    _.useEffect(() => {
      const d = c_({ root: n, pollInterval: r, useMutationObserver: i, rootMargin: o, threshold: s });
      h(d);
    }, [n, o, r, i, JSON.stringify(s)]),
    ese(() => {
      const d = t && "current" in t ? t.current : t;
      if (!u || !d) return;
      let f = !1;
      u.observer.observe(d);
      const p = (m) => {
        if (!f)
          for (let O = 0; O < m.length; O++) {
            const v = m[O];
            v.target === d && c(v);
          }
      };
      return (
        u.subscribe(p),
        () => {
          (f = !0), u.observer.unobserve(d), u.unsubscribe(p);
        }
      );
    }, [t, u]),
    a
  );
}
function nse({ root: t = null, pollInterval: e = null, useMutationObserver: n = !1, rootMargin: r = "0px 0px 0px 0px", threshold: i = 0 }) {
  const o = new Set();
  if (typeof IntersectionObserver > "u") return null;
  const s = new IntersectionObserver(
    (l) => {
      for (const a of o) a(l, s);
    },
    { root: t, rootMargin: r, threshold: i }
  );
  return (
    (s.POLL_INTERVAL = e),
    (s.USE_MUTATION_OBSERVER = n),
    {
      observer: s,
      getListeners() {
        return o;
      },
      subscribe: (l) => o.add(l),
      unsubscribe: (l) => o.delete(l),
    }
  );
}
const a_ = new Map();
function c_(t) {
  const { root: e, ...n } = t,
    r = JSON.stringify(n);
  let i = a_.get(e);
  return i || ((i = {}), a_.set(e, i)), i[r] ? i[r] : (i[r] = nse(t));
}
class yp {
  constructor(e, n, r, i, o, s, l, a, c, u = 0, h) {
    (this.p = e),
      (this.stack = n),
      (this.state = r),
      (this.reducePos = i),
      (this.pos = o),
      (this.score = s),
      (this.buffer = l),
      (this.bufferBase = a),
      (this.curContext = c),
      (this.lookAhead = u),
      (this.parent = h);
  }
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(e, n, r = 0) {
    let i = e.parser.context;
    return new yp(e, [], n, r, r, 0, [], 0, i ? new u_(i, i.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), (this.state = e);
  }
  reduce(e) {
    var n;
    let r = e >> 19,
      i = e & 65535,
      { parser: o } = this.p;
    this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
    let s = o.dynamicPrecedence(i);
    if ((s && (this.score += s), r == 0)) {
      this.pushState(o.getGoto(this.state, i, !0), this.reducePos),
        i < o.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0),
        this.reduceContext(i, this.reducePos);
      return;
    }
    let l = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0),
      a = l ? this.stack[l - 2] : this.p.ranges[0].from,
      c = this.reducePos - a;
    c >= 2e3 &&
      !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) &&
      (a == this.p.lastBigReductionStart
        ? (this.p.bigReductionCount++, (this.p.lastBigReductionSize = c))
        : this.p.lastBigReductionSize < c &&
          ((this.p.bigReductionCount = 1), (this.p.lastBigReductionStart = a), (this.p.lastBigReductionSize = c)));
    let u = l ? this.stack[l - 1] : 0,
      h = this.bufferBase + this.buffer.length - u;
    if (i < o.minRepeatTerm || e & 131072) {
      let d = o.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(i, a, d, h + 4, !0);
    }
    if (e & 262144) this.state = this.stack[l];
    else {
      let d = this.stack[l - 3];
      this.state = o.getGoto(d, i, !0);
    }
    for (; this.stack.length > l; ) this.stack.pop();
    this.reduceContext(i, a);
  }
  storeNode(e, n, r, i = 4, o = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this,
        l = this.buffer.length;
      if (
        (l == 0 && s.parent && ((l = s.bufferBase - s.parent.bufferBase), (s = s.parent)),
        l > 0 && s.buffer[l - 4] == 0 && s.buffer[l - 1] > -1)
      ) {
        if (n == r) return;
        if (s.buffer[l - 2] >= n) {
          s.buffer[l - 2] = r;
          return;
        }
      }
    }
    if (!o || this.pos == r) this.buffer.push(e, n, r, i);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0)
        for (; s > 0 && this.buffer[s - 2] > r; )
          (this.buffer[s] = this.buffer[s - 4]),
            (this.buffer[s + 1] = this.buffer[s - 3]),
            (this.buffer[s + 2] = this.buffer[s - 2]),
            (this.buffer[s + 3] = this.buffer[s - 1]),
            (s -= 4),
            i > 4 && (i -= 4);
      (this.buffer[s] = e), (this.buffer[s + 1] = n), (this.buffer[s + 2] = r), (this.buffer[s + 3] = i);
    }
  }
  shift(e, n, r, i) {
    if (e & 131072) this.pushState(e & 65535, this.pos);
    else if (e & 262144) (this.pos = i), this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
    else {
      let o = e,
        { parser: s } = this.p;
      (i > this.pos || n <= s.maxNode) && ((this.pos = i), s.stateFlag(o, 1) || (this.reducePos = i)),
        this.pushState(o, r),
        this.shiftContext(n, r),
        n <= s.maxNode && this.buffer.push(n, r, i, 4);
    }
  }
  apply(e, n, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, r, i);
  }
  useNode(e, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let i = this.pos;
    (this.reducePos = this.pos = i + e.length),
      this.pushState(n, i),
      this.buffer.push(r, i, this.reducePos, -1),
      this.curContext &&
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  split() {
    let e = this,
      n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; ) n -= 4;
    let r = e.buffer.slice(n),
      i = e.bufferBase + n;
    for (; e && i == e.bufferBase; ) e = e.parent;
    return new yp(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);
  }
  recoverByDelete(e, n) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), (this.pos = this.reducePos = n), (this.score -= 190);
  }
  canShift(e) {
    for (let n = new rse(this); ; ) {
      let r = this.p.parser.stateSlot(n.state, 4) || this.p.parser.hasAction(n.state, e);
      if (r == 0) return !1;
      if (!(r & 65536)) return !0;
      n.reduce(r);
    }
  }
  recoverByInsert(e) {
    if (this.stack.length >= 300) return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, s; o < n.length; o += 2) (s = n[o + 1]) != this.state && this.p.parser.hasAction(s, e) && i.push(n[o], s);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 8 && o < n.length; o += 2) {
          let s = n[o + 1];
          i.some((l, a) => a & 1 && l == s) || i.push(n[o], s);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let o = n[i + 1];
      if (o == this.state) continue;
      let s = this.split();
      s.pushState(o, this.pos),
        s.storeNode(0, s.pos, s.pos, 4, !0),
        s.shiftContext(n[i], this.pos),
        (s.reducePos = this.pos),
        (s.score -= 200),
        r.push(s);
    }
    return r;
  }
  forceReduce() {
    let { parser: e } = this.p,
      n = e.stateSlot(this.state, 5);
    if (!(n & 65536)) return !1;
    if (!e.validAction(this.state, n)) {
      let r = n >> 19,
        i = n & 65535,
        o = this.stack.length - r * 3;
      if (o < 0 || e.getGoto(this.stack[o], i, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null) return !1;
        n = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), (this.score -= 100);
    }
    return (this.reducePos = this.pos), this.reduce(n), !0;
  }
  findForcedReduction() {
    let { parser: e } = this.p,
      n = [],
      r = (i, o) => {
        if (!n.includes(i))
          return (
            n.push(i),
            e.allActions(i, (s) => {
              if (!(s & 393216))
                if (s & 65536) {
                  let l = (s >> 19) - o;
                  if (l > 1) {
                    let a = s & 65535,
                      c = this.stack.length - l * 3;
                    if (c >= 0 && e.getGoto(this.stack[c], a, !1) >= 0) return (l << 19) | 65536 | a;
                  }
                } else {
                  let l = r(s, o + 1);
                  if (l != null) return l;
                }
            })
          );
      };
    return r(this.state, 0);
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3) return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(this.state, 1)] == 65535 && !e.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), (this.state = this.stack[0]), (this.stack.length = 0);
  }
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length) return !1;
    for (let n = 0; n < this.stack.length; n += 3) if (this.stack[n] != e.stack[n]) return !1;
    return !0;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new u_(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), (this.curContext = n);
    }
  }
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), (this.lookAhead = e));
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class u_ {
  constructor(e, n) {
    (this.tracker = e), (this.context = n), (this.hash = e.strict ? e.hash(n) : 0);
  }
}
class rse {
  constructor(e) {
    (this.start = e), (this.state = e.state), (this.stack = e.stack), (this.base = this.stack.length);
  }
  reduce(e) {
    let n = e & 65535,
      r = e >> 19;
    r == 0
      ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), (this.base += 3))
      : (this.base -= (r - 1) * 3);
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class wp {
  constructor(e, n, r) {
    (this.stack = e), (this.pos = n), (this.index = r), (this.buffer = e.buffer), this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new wp(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && ((this.index = this.stack.bufferBase - e.bufferBase), (this.stack = e), (this.buffer = e.buffer));
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    (this.index -= 4), (this.pos -= 4), this.index == 0 && this.maybeNext();
  }
  fork() {
    return new wp(this.stack, this.pos, this.index);
  }
}
function _c(t, e = Uint16Array) {
  if (typeof t != "string") return t;
  let n = null;
  for (let r = 0, i = 0; r < t.length; ) {
    let o = 0;
    for (;;) {
      let s = t.charCodeAt(r++),
        l = !1;
      if (s == 126) {
        o = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let a = s - 32;
      if ((a >= 46 && ((a -= 46), (l = !0)), (o += a), l)) break;
      o *= 46;
    }
    n ? (n[i++] = o) : (n = new e(o));
  }
  return n;
}
class uf {
  constructor() {
    (this.start = -1), (this.value = -1), (this.end = -1), (this.extended = -1), (this.lookAhead = 0), (this.mask = 0), (this.context = 0);
  }
}
const h_ = new uf();
class ise {
  constructor(e, n) {
    (this.input = e),
      (this.ranges = n),
      (this.chunk = ""),
      (this.chunkOff = 0),
      (this.chunk2 = ""),
      (this.chunk2Pos = 0),
      (this.next = -1),
      (this.token = h_),
      (this.rangeIndex = 0),
      (this.pos = this.chunkPos = n[0].from),
      (this.range = n[0]),
      (this.end = n[n.length - 1].to),
      this.readNext();
  }
  resolveOffset(e, n) {
    let r = this.range,
      i = this.rangeIndex,
      o = this.pos + e;
    for (; o < r.from; ) {
      if (!i) return null;
      let s = this.ranges[--i];
      (o -= r.from - s.to), (r = s);
    }
    for (; n < 0 ? o > r.to : o >= r.to; ) {
      if (i == this.ranges.length - 1) return null;
      let s = this.ranges[++i];
      (o += s.from - r.to), (r = s);
    }
    return o;
  }
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to) return e;
    for (let n of this.ranges) if (n.to > e) return Math.max(e, n.from);
    return this.end;
  }
  peek(e) {
    let n = this.chunkOff + e,
      r,
      i;
    if (n >= 0 && n < this.chunk.length) (r = this.pos + e), (i = this.chunk.charCodeAt(n));
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null) return -1;
      if (((r = o), r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)) i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let s = this.rangeIndex,
          l = this.range;
        for (; l.to <= r; ) l = this.ranges[++s];
        (this.chunk2 = this.input.chunk((this.chunk2Pos = r))),
          r + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - r)),
          (i = this.chunk2.charCodeAt(0));
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  acceptToken(e, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start) throw new RangeError("Token end out of bounds");
    (this.token.value = e), (this.token.end = r);
  }
  acceptTokenTo(e, n) {
    (this.token.value = e), (this.token.end = n);
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      (this.chunk = this.chunk2),
        (this.chunkPos = this.chunk2Pos),
        (this.chunk2 = e),
        (this.chunk2Pos = n),
        (this.chunkOff = this.pos - this.chunkPos);
    } else {
      (this.chunk2 = this.chunk), (this.chunk2Pos = this.chunkPos);
      let e = this.input.chunk(this.pos),
        n = this.pos + e.length;
      (this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e), (this.chunkPos = this.pos), (this.chunkOff = 0);
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length)
      ? (this.next = -1)
      : (this.next = this.chunk.charCodeAt(this.chunkOff));
  }
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
      (e -= this.range.to - this.pos), (this.range = this.ranges[++this.rangeIndex]), (this.pos = this.range.from);
    }
    return (this.pos += e), this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return (
      (this.pos = this.chunkPos = this.end),
      (this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]),
      (this.chunk = ""),
      (this.next = -1)
    );
  }
  reset(e, n) {
    if ((n ? ((this.token = n), (n.start = e), (n.lookAhead = e + 1), (n.value = n.extended = -1)) : (this.token = h_), this.pos != e)) {
      if (((this.pos = e), e == this.end)) return this.setDone(), this;
      for (; e < this.range.from; ) this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; ) this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length
        ? (this.chunkOff = e - this.chunkPos)
        : ((this.chunk = ""), (this.chunkOff = 0)),
        this.readNext();
    }
    return this;
  }
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length) return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to) return this.input.read(e, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n) break;
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, n)));
    }
    return r;
  }
}
class Bl {
  constructor(e, n) {
    (this.data = e), (this.id = n);
  }
  token(e, n) {
    let { parser: r } = n.p;
    TR(this.data, e, n, this.id, r.data, r.tokenPrecTable);
  }
}
Bl.prototype.contextual = Bl.prototype.fallback = Bl.prototype.extend = !1;
class Sp {
  constructor(e, n, r) {
    (this.precTable = n), (this.elseToken = r), (this.data = typeof e == "string" ? _c(e) : e);
  }
  token(e, n) {
    let r = e.pos,
      i = 0;
    for (;;) {
      let o = e.next < 0,
        s = e.resolveOffset(1, 1);
      if ((TR(this.data, e, n, 0, this.data, this.precTable), e.token.value > -1)) break;
      if (this.elseToken == null) return;
      if ((o || i++, s == null)) break;
      e.reset(s, e.token);
    }
    i && (e.reset(r, e.token), e.acceptToken(this.elseToken, i));
  }
}
Sp.prototype.contextual = Bl.prototype.fallback = Bl.prototype.extend = !1;
class Ur {
  constructor(e, n = {}) {
    (this.token = e), (this.contextual = !!n.contextual), (this.fallback = !!n.fallback), (this.extend = !!n.extend);
  }
}
function TR(t, e, n, r, i, o) {
  let s = 0,
    l = 1 << r,
    { dialect: a } = n.p.parser;
  e: for (; l & t[s]; ) {
    let c = t[s + 1];
    for (let f = s + 3; f < c; f += 2)
      if ((t[f + 1] & l) > 0) {
        let p = t[f];
        if (a.allows(p) && (e.token.value == -1 || e.token.value == p || ose(p, e.token.value, i, o))) {
          e.acceptToken(p);
          break;
        }
      }
    let u = e.next,
      h = 0,
      d = t[s + 2];
    if (e.next < 0 && d > h && t[c + d * 3 - 3] == 65535) {
      s = t[c + d * 3 - 1];
      continue e;
    }
    for (; h < d; ) {
      let f = (h + d) >> 1,
        p = c + f + (f << 1),
        m = t[p],
        O = t[p + 1] || 65536;
      if (u < m) d = f;
      else if (u >= O) h = f + 1;
      else {
        (s = t[p + 2]), e.advance();
        continue e;
      }
    }
    break;
  }
}
function d_(t, e, n) {
  for (let r = e, i; (i = t[r]) != 65535; r++) if (i == n) return r - e;
  return -1;
}
function ose(t, e, n, r) {
  let i = d_(n, r, e);
  return i < 0 || d_(n, r, t) < i;
}
const qn = typeof process < "u" && process.env && /\bparse\b/.test({}.LOG);
let C1 = null;
function f_(t, e, n) {
  let r = t.cursor(vt.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(n < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (;;) {
        if ((n < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(r.to - 1, e - 25)) : Math.min(t.length, Math.max(r.from + 1, e + 25));
        if (n < 0 ? r.prevSibling() : r.nextSibling()) break;
        if (!r.parent()) return n < 0 ? 0 : t.length;
      }
}
let sse = class {
  constructor(e, n) {
    (this.fragments = e),
      (this.nodeSet = n),
      (this.i = 0),
      (this.fragment = null),
      (this.safeFrom = -1),
      (this.safeTo = -1),
      (this.trees = []),
      (this.start = []),
      (this.index = []),
      this.nextFragment();
  }
  nextFragment() {
    let e = (this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]);
    if (e) {
      for (
        this.safeFrom = e.openStart ? f_(e.tree, e.from + e.offset, 1) - e.offset : e.from,
          this.safeTo = e.openEnd ? f_(e.tree, e.to + e.offset, -1) - e.offset : e.to;
        this.trees.length;

      )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), (this.nextStart = this.safeFrom);
    } else this.nextStart = 1e9;
  }
  nodeAt(e) {
    if (e < this.nextStart) return null;
    for (; this.fragment && this.safeTo <= e; ) this.nextFragment();
    if (!this.fragment) return null;
    for (;;) {
      let n = this.trees.length - 1;
      if (n < 0) return this.nextFragment(), null;
      let r = this.trees[n],
        i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = r.children[i],
        s = this.start[n] + r.positions[i];
      if (s > e) return (this.nextStart = s), null;
      if (o instanceof Ve) {
        if (s == e) {
          if (s < this.safeFrom) return null;
          let l = s + o.length;
          if (l <= this.safeTo) {
            let a = o.prop(Ae.lookAhead);
            if (!a || l + a < this.fragment.to) return o;
          }
        }
        this.index[n]++, s + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(s), this.index.push(0));
      } else this.index[n]++, (this.nextStart = s + o.length);
    }
  }
};
class lse {
  constructor(e, n) {
    (this.stream = n), (this.tokens = []), (this.mainToken = null), (this.actions = []), (this.tokens = e.tokenizers.map((r) => new uf()));
  }
  getActions(e) {
    let n = 0,
      r = null,
      { parser: i } = e.p,
      { tokenizers: o } = i,
      s = i.stateSlot(e.state, 3),
      l = e.curContext ? e.curContext.hash : 0,
      a = 0;
    for (let c = 0; c < o.length; c++) {
      if (!((1 << c) & s)) continue;
      let u = o[c],
        h = this.tokens[c];
      if (
        !(r && !u.fallback) &&
        ((u.contextual || h.start != e.pos || h.mask != s || h.context != l) &&
          (this.updateCachedToken(h, u, e), (h.mask = s), (h.context = l)),
        h.lookAhead > h.end + 25 && (a = Math.max(h.lookAhead, a)),
        h.value != 0)
      ) {
        let d = n;
        if (
          (h.extended > -1 && (n = this.addActions(e, h.extended, h.end, n)),
          (n = this.addActions(e, h.value, h.end, n)),
          !u.extend && ((r = h), n > d))
        )
          break;
      }
    }
    for (; this.actions.length > n; ) this.actions.pop();
    return (
      a && e.setLookAhead(a),
      !r &&
        e.pos == this.stream.end &&
        ((r = new uf()), (r.value = e.p.parser.eofTerm), (r.start = r.end = e.pos), (n = this.addActions(e, r.value, r.end, n))),
      (this.mainToken = r),
      this.actions
    );
  }
  getMainToken(e) {
    if (this.mainToken) return this.mainToken;
    let n = new uf(),
      { pos: r, p: i } = e;
    return (n.start = r), (n.end = Math.min(r + 1, i.stream.end)), (n.value = r == i.stream.end ? i.parser.eofTerm : 0), n;
  }
  updateCachedToken(e, n, r) {
    let i = this.stream.clipPos(r.pos);
    if ((n.token(this.stream.reset(i, e), r), e.value > -1)) {
      let { parser: o } = r.p;
      for (let s = 0; s < o.specialized.length; s++)
        if (o.specialized[s] == e.value) {
          let l = o.specializers[s](this.stream.read(e.start, e.end), r);
          if (l >= 0 && r.p.parser.dialect.allows(l >> 1)) {
            l & 1 ? (e.extended = l >> 1) : (e.value = l >> 1);
            break;
          }
        }
    } else (e.value = 0), (e.end = this.stream.clipPos(i + 1));
  }
  putAction(e, n, r, i) {
    for (let o = 0; o < i; o += 3) if (this.actions[o] == e) return i;
    return (this.actions[i++] = e), (this.actions[i++] = n), (this.actions[i++] = r), i;
  }
  addActions(e, n, r, i) {
    let { state: o } = e,
      { parser: s } = e.p,
      { data: l } = s;
    for (let a = 0; a < 2; a++)
      for (let c = s.stateSlot(o, a ? 2 : 1); ; c += 3) {
        if (l[c] == 65535)
          if (l[c + 1] == 1) c = Ii(l, c + 2);
          else {
            i == 0 && l[c + 1] == 2 && (i = this.putAction(Ii(l, c + 2), n, r, i));
            break;
          }
        l[c] == n && (i = this.putAction(Ii(l, c + 1), n, r, i));
      }
    return i;
  }
}
class ase {
  constructor(e, n, r, i) {
    (this.parser = e),
      (this.input = n),
      (this.ranges = i),
      (this.recovering = 0),
      (this.nextStackID = 9812),
      (this.minStackPos = 0),
      (this.reused = []),
      (this.stoppedAt = null),
      (this.lastBigReductionStart = -1),
      (this.lastBigReductionSize = 0),
      (this.bigReductionCount = 0),
      (this.stream = new ise(n, i)),
      (this.tokens = new lse(e, this.stream)),
      (this.topTerm = e.top[1]);
    let { from: o } = i[0];
    (this.stacks = [yp.start(this, e.top[0], o)]),
      (this.fragments = r.length && this.stream.end - o > e.bufferLength * 4 ? new sse(r, e.nodeSet) : null);
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let e = this.stacks,
      n = this.minStackPos,
      r = (this.stacks = []),
      i,
      o;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; );
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let l = e[s];
      for (;;) {
        if (((this.tokens.mainToken = null), l.pos > n)) r.push(l);
        else {
          if (this.advanceStack(l, r, e)) continue;
          {
            i || ((i = []), (o = [])), i.push(l);
            let a = this.tokens.getMainToken(l);
            o.push(a.value, a.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let s = i && use(i);
      if (s) return qn && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw (
          (qn &&
            i &&
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")),
          new SyntaxError("No parse at " + n))
        );
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let s = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, r);
      if (s) return qn && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > s) for (r.sort((l, a) => a.score - l.score); r.length > s; ) r.pop();
      r.some((l) => l.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      e: for (let s = 0; s < r.length - 1; s++) {
        let l = r[s];
        for (let a = s + 1; a < r.length; a++) {
          let c = r[a];
          if (l.sameState(c) || (l.buffer.length > 500 && c.buffer.length > 500))
            if ((l.score - c.score || l.buffer.length - c.buffer.length) > 0) r.splice(a--, 1);
            else {
              r.splice(s--, 1);
              continue e;
            }
        }
      }
      r.length > 12 && r.splice(12, r.length - 12);
    }
    this.minStackPos = r[0].pos;
    for (let s = 1; s < r.length; s++) r[s].pos < this.minStackPos && (this.minStackPos = r[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  advanceStack(e, n, r) {
    let i = e.pos,
      { parser: o } = this,
      s = qn ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt) return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict,
        u = c ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(i); h; ) {
        let d = this.parser.nodeSet.types[h.type.id] == h.type ? o.getGoto(e.state, h.type.id) : -1;
        if (d > -1 && h.length && (!c || (h.prop(Ae.contextHash) || 0) == u))
          return e.useNode(h, d), qn && console.log(s + this.stackID(e) + ` (via reuse of ${o.getName(h.type.id)})`), !0;
        if (!(h instanceof Ve) || h.children.length == 0 || h.positions[0] > 0) break;
        let f = h.children[0];
        if (f instanceof Ve && h.positions[0] == 0) h = f;
        else break;
      }
    }
    let l = o.stateSlot(e.state, 4);
    if (l > 0) return e.reduce(l), qn && console.log(s + this.stackID(e) + ` (via always-reduce ${o.getName(l & 65535)})`), !0;
    if (e.stack.length >= 8400) for (; e.stack.length > 6e3 && e.forceReduce(); );
    let a = this.tokens.getActions(e);
    for (let c = 0; c < a.length; ) {
      let u = a[c++],
        h = a[c++],
        d = a[c++],
        f = c == a.length || !r,
        p = f ? e : e.split(),
        m = this.tokens.mainToken;
      if (
        (p.apply(u, h, m ? m.start : p.pos, d),
        qn &&
          console.log(
            s +
              this.stackID(p) +
              ` (via ${u & 65536 ? `reduce of ${o.getName(u & 65535)}` : "shift"} for ${o.getName(h)} @ ${i}${p == e ? "" : ", split"})`
          ),
        f)
      )
        return !0;
      p.pos > i ? n.push(p) : r.push(p);
    }
    return !1;
  }
  advanceFully(e, n) {
    let r = e.pos;
    for (;;) {
      if (!this.advanceStack(e, null, null)) return !1;
      if (e.pos > r) return p_(e, n), !0;
    }
  }
  runRecovery(e, n, r) {
    let i = null,
      o = !1;
    for (let s = 0; s < e.length; s++) {
      let l = e[s],
        a = n[s << 1],
        c = n[(s << 1) + 1],
        u = qn ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (o || ((o = !0), l.restart(), qn && console.log(u + this.stackID(l) + " (restarted)"), this.advanceFully(l, r))))
        continue;
      let h = l.split(),
        d = u;
      for (
        let f = 0;
        h.forceReduce() && f < 10 && (qn && console.log(d + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, r));
        f++
      )
        qn && (d = this.stackID(h) + " -> ");
      for (let f of l.recoverByInsert(a)) qn && console.log(u + this.stackID(f) + " (via recover-insert)"), this.advanceFully(f, r);
      this.stream.end > l.pos
        ? (c == l.pos && (c++, (a = 0)),
          l.recoverByDelete(a, c),
          qn && console.log(u + this.stackID(l) + ` (via recover-delete ${this.parser.getName(a)})`),
          p_(l, r))
        : (!i || i.score < l.score) && (i = l);
    }
    return i;
  }
  stackToTree(e) {
    return (
      e.close(),
      Ve.build({
        buffer: wp.create(e),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: e.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm,
      })
    );
  }
  stackID(e) {
    let n = (C1 || (C1 = new WeakMap())).get(e);
    return n || C1.set(e, (n = String.fromCodePoint(this.nextStackID++))), n + e;
  }
}
function p_(t, e) {
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    if (r.pos == t.pos && r.sameState(t)) {
      e[n].score < t.score && (e[n] = t);
      return;
    }
  }
  e.push(t);
}
class cse {
  constructor(e, n, r) {
    (this.source = e), (this.flags = n), (this.disabled = r);
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const _1 = (t) => t;
class PR {
  constructor(e) {
    (this.start = e.start),
      (this.shift = e.shift || _1),
      (this.reduce = e.reduce || _1),
      (this.reuse = e.reuse || _1),
      (this.hash = e.hash || (() => 0)),
      (this.strict = e.strict !== !1);
  }
}
class aa extends Km {
  constructor(e) {
    if ((super(), (this.wrappers = []), e.version != 14))
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let l = 0; l < e.repeatNodeCount; l++) n.push("");
    let r = Object.keys(e.topRules).map((l) => e.topRules[l][1]),
      i = [];
    for (let l = 0; l < n.length; l++) i.push([]);
    function o(l, a, c) {
      i[l].push([a, a.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let a = l[0];
        typeof a == "string" && (a = Ae[a]);
        for (let c = 1; c < l.length; ) {
          let u = l[c++];
          if (u >= 0) o(u, a, l[c++]);
          else {
            let h = l[c + -u];
            for (let d = -u; d > 0; d--) o(l[c++], a, h);
            c++;
          }
        }
      }
    (this.nodeSet = new Da(
      n.map((l, a) =>
        Xt.define({
          name: a >= this.minRepeatTerm ? void 0 : l,
          id: a,
          props: i[a],
          top: r.indexOf(a) > -1,
          error: a == 0,
          skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1,
        })
      )
    )),
      e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)),
      (this.strict = !1),
      (this.bufferLength = t4);
    let s = _c(e.tokenData);
    (this.context = e.context),
      (this.specializerSpecs = e.specialized || []),
      (this.specialized = new Uint16Array(this.specializerSpecs.length));
    for (let l = 0; l < this.specializerSpecs.length; l++) this.specialized[l] = this.specializerSpecs[l].term;
    (this.specializers = this.specializerSpecs.map(m_)),
      (this.states = _c(e.states, Uint32Array)),
      (this.data = _c(e.stateData)),
      (this.goto = _c(e.goto)),
      (this.maxTerm = e.maxTerm),
      (this.tokenizers = e.tokenizers.map((l) => (typeof l == "number" ? new Bl(s, l) : l))),
      (this.topRules = e.topRules),
      (this.dialects = e.dialects || {}),
      (this.dynamicPrecedences = e.dynamicPrecedences || null),
      (this.tokenPrecTable = e.tokenPrec),
      (this.termNames = e.termNames || null),
      (this.maxNode = this.nodeSet.types.length - 1),
      (this.dialect = this.parseDialect()),
      (this.top = this.topRules[Object.keys(this.topRules)[0]]);
  }
  createParse(e, n, r) {
    let i = new ase(this, e, n, r);
    for (let o of this.wrappers) i = o(i, e, n, r);
    return i;
  }
  getGoto(e, n, r = !1) {
    let i = this.goto;
    if (n >= i[0]) return -1;
    for (let o = i[n + 1]; ; ) {
      let s = i[o++],
        l = s & 1,
        a = i[o++];
      if (l && r) return a;
      for (let c = o + (s >> 1); o < c; o++) if (i[o] == e) return a;
      if (l) return -1;
    }
  }
  hasAction(e, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(e, i ? 2 : 1), s; ; o += 3) {
        if ((s = r[o]) == 65535)
          if (r[o + 1] == 1) s = r[(o = Ii(r, o + 2))];
          else {
            if (r[o + 1] == 2) return Ii(r, o + 2);
            break;
          }
        if (s == n || s == 0) return Ii(r, o + 1);
      }
    return 0;
  }
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  stateFlag(e, n) {
    return (this.stateSlot(e, 0) & n) > 0;
  }
  validAction(e, n) {
    return !!this.allActions(e, (r) => (r == n ? !0 : null));
  }
  allActions(e, n) {
    let r = this.stateSlot(e, 4),
      i = r ? n(r) : void 0;
    for (let o = this.stateSlot(e, 1); i == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1) o = Ii(this.data, o + 2);
        else break;
      i = n(Ii(this.data, o + 1));
    }
    return i;
  }
  nextStates(e) {
    let n = [];
    for (let r = this.stateSlot(e, 1); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1) r = Ii(this.data, r + 2);
        else break;
      if (!(this.data[r + 2] & 1)) {
        let i = this.data[r + 1];
        n.some((o, s) => s & 1 && o == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  configure(e) {
    let n = Object.assign(Object.create(aa.prototype), this);
    if ((e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top)) {
      let r = this.topRules[e.top];
      if (!r) throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = r;
    }
    return (
      e.tokenizers &&
        (n.tokenizers = this.tokenizers.map((r) => {
          let i = e.tokenizers.find((o) => o.from == r);
          return i ? i.to : r;
        })),
      e.specializers &&
        ((n.specializers = this.specializers.slice()),
        (n.specializerSpecs = this.specializerSpecs.map((r, i) => {
          let o = e.specializers.find((l) => l.from == r.external);
          if (!o) return r;
          let s = Object.assign(Object.assign({}, r), { external: o.to });
          return (n.specializers[i] = m_(s)), s;
        }))),
      e.contextTracker && (n.context = e.contextTracker),
      e.dialect && (n.dialect = this.parseDialect(e.dialect)),
      e.strict != null && (n.strict = e.strict),
      e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)),
      e.bufferLength != null && (n.bufferLength = e.bufferLength),
      n
    );
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(e) {
    return this.termNames ? this.termNames[e] : String((e <= this.maxNode && this.nodeSet.types[e].name) || e);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  parseDialect(e) {
    let n = Object.keys(this.dialects),
      r = n.map(() => !1);
    if (e)
      for (let o of e.split(" ")) {
        let s = n.indexOf(o);
        s >= 0 && (r[s] = !0);
      }
    let i = null;
    for (let o = 0; o < n.length; o++)
      if (!r[o]) for (let s = this.dialects[n[o]], l; (l = this.data[s++]) != 65535; ) (i || (i = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new cse(e, r, i);
  }
  static deserialize(e) {
    return new aa(e);
  }
}
function Ii(t, e) {
  return t[e] | (t[e + 1] << 16);
}
function use(t) {
  let e = null;
  for (let n of t) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || (r != null && n.pos > r)) && n.p.parser.stateFlag(n.state, 2) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function m_(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (n, r) => (t.external(n, r) << 1) | e;
  }
  return t.get;
}
const hse = 99,
  g_ = 1,
  dse = 100,
  fse = 101,
  O_ = 2,
  AR = [
    9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288,
  ],
  pse = 58,
  mse = 40,
  $R = 95,
  gse = 91,
  hf = 45,
  Ose = 46,
  vse = 35,
  bse = 37,
  xse = 38,
  yse = 92,
  wse = 10;
function Ru(t) {
  return (t >= 65 && t <= 90) || (t >= 97 && t <= 122) || t >= 161;
}
function RR(t) {
  return t >= 48 && t <= 57;
}
const Sse = new Ur((t, e) => {
    for (let n = !1, r = 0, i = 0; ; i++) {
      let { next: o } = t;
      if (Ru(o) || o == hf || o == $R || (n && RR(o))) !n && (o != hf || i > 0) && (n = !0), r === i && o == hf && r++, t.advance();
      else if (o == yse && t.peek(1) != wse) t.advance(), t.next > -1 && t.advance(), (n = !0);
      else {
        n && t.acceptToken(o == mse ? dse : r == 2 && e.canShift(O_) ? O_ : fse);
        break;
      }
    }
  }),
  kse = new Ur((t) => {
    if (AR.includes(t.peek(-1))) {
      let { next: e } = t;
      (Ru(e) || e == $R || e == vse || e == Ose || e == gse || (e == pse && Ru(t.peek(1))) || e == hf || e == xse) && t.acceptToken(hse);
    }
  }),
  Cse = new Ur((t) => {
    if (!AR.includes(t.peek(-1))) {
      let { next: e } = t;
      if ((e == bse && (t.advance(), t.acceptToken(g_)), Ru(e))) {
        do t.advance();
        while (Ru(t.next) || RR(t.next));
        t.acceptToken(g_);
      }
    }
  }),
  _se = Fa({
    "AtKeyword import charset namespace keyframes media supports": $.definitionKeyword,
    "from to selector": $.keyword,
    NamespaceName: $.namespace,
    KeyframeName: $.labelName,
    KeyframeRangeName: $.operatorKeyword,
    TagName: $.tagName,
    ClassName: $.className,
    PseudoClassName: $.constant($.className),
    IdName: $.labelName,
    "FeatureName PropertyName": $.propertyName,
    AttributeName: $.attributeName,
    NumberLiteral: $.number,
    KeywordQuery: $.keyword,
    UnaryQueryOp: $.operatorKeyword,
    "CallTag ValueName": $.atom,
    VariableName: $.variableName,
    Callee: $.operatorKeyword,
    Unit: $.unit,
    "UniversalSelector NestingSelector": $.definitionOperator,
    MatchOp: $.compareOperator,
    "ChildOp SiblingOp, LogicOp": $.logicOperator,
    BinOp: $.arithmeticOperator,
    Important: $.modifier,
    Comment: $.blockComment,
    ColorLiteral: $.color,
    "ParenthesizedContent StringLiteral": $.string,
    ":": $.punctuation,
    "PseudoOp #": $.derefOperator,
    "; ,": $.separator,
    "( )": $.paren,
    "[ ]": $.squareBracket,
    "{ }": $.brace,
  }),
  Ese = {
    __proto__: null,
    lang: 32,
    "nth-child": 32,
    "nth-last-child": 32,
    "nth-of-type": 32,
    "nth-last-of-type": 32,
    dir: 32,
    "host-context": 32,
    url: 60,
    "url-prefix": 60,
    domain: 60,
    regexp: 60,
    selector: 138,
  },
  Tse = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 },
  Pse = { __proto__: null, not: 132, only: 132 },
  Ase = aa.deserialize({
    version: 14,
    states:
      ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
    stateData:
      ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
    goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
    nodeNames:
      "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
    maxTerm: 117,
    nodeProps: [
      ["isolate", -2, 3, 24, ""],
      ["openedBy", 17, "(", 32, "[", 50, "{"],
      ["closedBy", 18, ")", 33, "]", 51, "}"],
    ],
    propSources: [_se],
    skippedNodes: [0, 3, 87],
    repeatNodeCount: 11,
    tokenData:
      "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
    tokenizers: [kse, Cse, Sse, 1, 2, 3, 4, new Sp("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
    topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
    specialized: [
      { term: 100, get: (t) => Ese[t] || -1 },
      { term: 58, get: (t) => Tse[t] || -1 },
      { term: 101, get: (t) => Pse[t] || -1 },
    ],
    tokenPrec: 1200,
  });
let E1 = null;
function T1() {
  if (!E1 && typeof document == "object" && document.body) {
    let { style: t } = document.body,
      e = [],
      n = new Set();
    for (let r in t)
      r != "cssText" &&
        r != "cssFloat" &&
        typeof t[r] == "string" &&
        (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), n.has(r) || (e.push(r), n.add(r)));
    E1 = e.sort().map((r) => ({ type: "property", label: r }));
  }
  return E1 || [];
}
const v_ = [
    "active",
    "after",
    "any-link",
    "autofill",
    "backdrop",
    "before",
    "checked",
    "cue",
    "default",
    "defined",
    "disabled",
    "empty",
    "enabled",
    "file-selector-button",
    "first",
    "first-child",
    "first-letter",
    "first-line",
    "first-of-type",
    "focus",
    "focus-visible",
    "focus-within",
    "fullscreen",
    "has",
    "host",
    "host-context",
    "hover",
    "in-range",
    "indeterminate",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "marker",
    "modal",
    "not",
    "nth-child",
    "nth-last-child",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "part",
    "placeholder",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "selection",
    "slotted",
    "target",
    "target-text",
    "valid",
    "visited",
    "where",
  ].map((t) => ({ type: "class", label: t })),
  b_ = [
    "above",
    "absolute",
    "activeborder",
    "additive",
    "activecaption",
    "after-white-space",
    "ahead",
    "alias",
    "all",
    "all-scroll",
    "alphabetic",
    "alternate",
    "always",
    "antialiased",
    "appworkspace",
    "asterisks",
    "attr",
    "auto",
    "auto-flow",
    "avoid",
    "avoid-column",
    "avoid-page",
    "avoid-region",
    "axis-pan",
    "background",
    "backwards",
    "baseline",
    "below",
    "bidi-override",
    "blink",
    "block",
    "block-axis",
    "bold",
    "bolder",
    "border",
    "border-box",
    "both",
    "bottom",
    "break",
    "break-all",
    "break-word",
    "bullets",
    "button",
    "button-bevel",
    "buttonface",
    "buttonhighlight",
    "buttonshadow",
    "buttontext",
    "calc",
    "capitalize",
    "caps-lock-indicator",
    "caption",
    "captiontext",
    "caret",
    "cell",
    "center",
    "checkbox",
    "circle",
    "cjk-decimal",
    "clear",
    "clip",
    "close-quote",
    "col-resize",
    "collapse",
    "color",
    "color-burn",
    "color-dodge",
    "column",
    "column-reverse",
    "compact",
    "condensed",
    "contain",
    "content",
    "contents",
    "content-box",
    "context-menu",
    "continuous",
    "copy",
    "counter",
    "counters",
    "cover",
    "crop",
    "cross",
    "crosshair",
    "currentcolor",
    "cursive",
    "cyclic",
    "darken",
    "dashed",
    "decimal",
    "decimal-leading-zero",
    "default",
    "default-button",
    "dense",
    "destination-atop",
    "destination-in",
    "destination-out",
    "destination-over",
    "difference",
    "disc",
    "discard",
    "disclosure-closed",
    "disclosure-open",
    "document",
    "dot-dash",
    "dot-dot-dash",
    "dotted",
    "double",
    "down",
    "e-resize",
    "ease",
    "ease-in",
    "ease-in-out",
    "ease-out",
    "element",
    "ellipse",
    "ellipsis",
    "embed",
    "end",
    "ethiopic-abegede-gez",
    "ethiopic-halehame-aa-er",
    "ethiopic-halehame-gez",
    "ew-resize",
    "exclusion",
    "expanded",
    "extends",
    "extra-condensed",
    "extra-expanded",
    "fantasy",
    "fast",
    "fill",
    "fill-box",
    "fixed",
    "flat",
    "flex",
    "flex-end",
    "flex-start",
    "footnotes",
    "forwards",
    "from",
    "geometricPrecision",
    "graytext",
    "grid",
    "groove",
    "hand",
    "hard-light",
    "help",
    "hidden",
    "hide",
    "higher",
    "highlight",
    "highlighttext",
    "horizontal",
    "hsl",
    "hsla",
    "hue",
    "icon",
    "ignore",
    "inactiveborder",
    "inactivecaption",
    "inactivecaptiontext",
    "infinite",
    "infobackground",
    "infotext",
    "inherit",
    "initial",
    "inline",
    "inline-axis",
    "inline-block",
    "inline-flex",
    "inline-grid",
    "inline-table",
    "inset",
    "inside",
    "intrinsic",
    "invert",
    "italic",
    "justify",
    "keep-all",
    "landscape",
    "large",
    "larger",
    "left",
    "level",
    "lighter",
    "lighten",
    "line-through",
    "linear",
    "linear-gradient",
    "lines",
    "list-item",
    "listbox",
    "listitem",
    "local",
    "logical",
    "loud",
    "lower",
    "lower-hexadecimal",
    "lower-latin",
    "lower-norwegian",
    "lowercase",
    "ltr",
    "luminosity",
    "manipulation",
    "match",
    "matrix",
    "matrix3d",
    "medium",
    "menu",
    "menutext",
    "message-box",
    "middle",
    "min-intrinsic",
    "mix",
    "monospace",
    "move",
    "multiple",
    "multiple_mask_images",
    "multiply",
    "n-resize",
    "narrower",
    "ne-resize",
    "nesw-resize",
    "no-close-quote",
    "no-drop",
    "no-open-quote",
    "no-repeat",
    "none",
    "normal",
    "not-allowed",
    "nowrap",
    "ns-resize",
    "numbers",
    "numeric",
    "nw-resize",
    "nwse-resize",
    "oblique",
    "opacity",
    "open-quote",
    "optimizeLegibility",
    "optimizeSpeed",
    "outset",
    "outside",
    "outside-shape",
    "overlay",
    "overline",
    "padding",
    "padding-box",
    "painted",
    "page",
    "paused",
    "perspective",
    "pinch-zoom",
    "plus-darker",
    "plus-lighter",
    "pointer",
    "polygon",
    "portrait",
    "pre",
    "pre-line",
    "pre-wrap",
    "preserve-3d",
    "progress",
    "push-button",
    "radial-gradient",
    "radio",
    "read-only",
    "read-write",
    "read-write-plaintext-only",
    "rectangle",
    "region",
    "relative",
    "repeat",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "repeat-x",
    "repeat-y",
    "reset",
    "reverse",
    "rgb",
    "rgba",
    "ridge",
    "right",
    "rotate",
    "rotate3d",
    "rotateX",
    "rotateY",
    "rotateZ",
    "round",
    "row",
    "row-resize",
    "row-reverse",
    "rtl",
    "run-in",
    "running",
    "s-resize",
    "sans-serif",
    "saturation",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
    "scaleZ",
    "screen",
    "scroll",
    "scrollbar",
    "scroll-position",
    "se-resize",
    "self-start",
    "self-end",
    "semi-condensed",
    "semi-expanded",
    "separate",
    "serif",
    "show",
    "single",
    "skew",
    "skewX",
    "skewY",
    "skip-white-space",
    "slide",
    "slider-horizontal",
    "slider-vertical",
    "sliderthumb-horizontal",
    "sliderthumb-vertical",
    "slow",
    "small",
    "small-caps",
    "small-caption",
    "smaller",
    "soft-light",
    "solid",
    "source-atop",
    "source-in",
    "source-out",
    "source-over",
    "space",
    "space-around",
    "space-between",
    "space-evenly",
    "spell-out",
    "square",
    "start",
    "static",
    "status-bar",
    "stretch",
    "stroke",
    "stroke-box",
    "sub",
    "subpixel-antialiased",
    "svg_masks",
    "super",
    "sw-resize",
    "symbolic",
    "symbols",
    "system-ui",
    "table",
    "table-caption",
    "table-cell",
    "table-column",
    "table-column-group",
    "table-footer-group",
    "table-header-group",
    "table-row",
    "table-row-group",
    "text",
    "text-bottom",
    "text-top",
    "textarea",
    "textfield",
    "thick",
    "thin",
    "threeddarkshadow",
    "threedface",
    "threedhighlight",
    "threedlightshadow",
    "threedshadow",
    "to",
    "top",
    "transform",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "translateZ",
    "transparent",
    "ultra-condensed",
    "ultra-expanded",
    "underline",
    "unidirectional-pan",
    "unset",
    "up",
    "upper-latin",
    "uppercase",
    "url",
    "var",
    "vertical",
    "vertical-text",
    "view-box",
    "visible",
    "visibleFill",
    "visiblePainted",
    "visibleStroke",
    "visual",
    "w-resize",
    "wait",
    "wave",
    "wider",
    "window",
    "windowframe",
    "windowtext",
    "words",
    "wrap",
    "wrap-reverse",
    "x-large",
    "x-small",
    "xor",
    "xx-large",
    "xx-small",
  ]
    .map((t) => ({ type: "keyword", label: t }))
    .concat(
      [
        "aliceblue",
        "antiquewhite",
        "aqua",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "black",
        "blanchedalmond",
        "blue",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "fuchsia",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "gray",
        "grey",
        "green",
        "greenyellow",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightsteelblue",
        "lightyellow",
        "lime",
        "limegreen",
        "linen",
        "magenta",
        "maroon",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "navy",
        "oldlace",
        "olive",
        "olivedrab",
        "orange",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "purple",
        "rebeccapurple",
        "red",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "silver",
        "skyblue",
        "slateblue",
        "slategray",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "teal",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "white",
        "whitesmoke",
        "yellow",
        "yellowgreen",
      ].map((t) => ({ type: "constant", label: t }))
    ),
  $se = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "b",
    "bdi",
    "bdo",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "figcaption",
    "figure",
    "footer",
    "form",
    "header",
    "hgroup",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "meter",
    "nav",
    "ol",
    "output",
    "p",
    "pre",
    "ruby",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "tr",
    "u",
    "ul",
  ].map((t) => ({ type: "type", label: t })),
  oo = /^(\w[\w-]*|-\w[\w-]*|)$/,
  Rse = /^-(-[\w-]*)?$/;
function Ise(t, e) {
  var n;
  if (((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")) return !1;
  let r = (n = t.parent) === null || n === void 0 ? void 0 : n.firstChild;
  return (r == null ? void 0 : r.name) != "Callee" ? !1 : e.sliceString(r.from, r.to) == "var";
}
const x_ = new o4(),
  Mse = ["Declaration"];
function Lse(t) {
  for (let e = t; ; ) {
    if (e.type.isTop) return e;
    if (!(e = e.parent)) return t;
  }
}
function IR(t, e, n) {
  if (e.to - e.from > 4096) {
    let r = x_.get(e);
    if (r) return r;
    let i = [],
      o = new Set(),
      s = e.cursor(vt.IncludeAnonymous);
    if (s.firstChild())
      do for (let l of IR(t, s.node, n)) o.has(l.label) || (o.add(l.label), i.push(l));
      while (s.nextSibling());
    return x_.set(e, i), i;
  } else {
    let r = [],
      i = new Set();
    return (
      e.cursor().iterate((o) => {
        var s;
        if (n(o) && o.matchContext(Mse) && ((s = o.node.nextSibling) === null || s === void 0 ? void 0 : s.name) == ":") {
          let l = t.sliceString(o.from, o.to);
          i.has(l) || (i.add(l), r.push({ label: l, type: "variable" }));
        }
      }),
      r
    );
  }
}
const MR = (t) => (e) => {
    let { state: n, pos: r } = e,
      i = at(n).resolveInner(r, -1),
      o = i.type.isError && i.from == i.to - 1 && n.doc.sliceString(i.from, i.to) == "-";
    if (i.name == "PropertyName" || ((o || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name)))
      return { from: i.from, options: T1(), validFor: oo };
    if (i.name == "ValueName") return { from: i.from, options: b_, validFor: oo };
    if (i.name == "PseudoClassName") return { from: i.from, options: v_, validFor: oo };
    if (t(i) || ((e.explicit || o) && Ise(i, n.doc))) return { from: t(i) || o ? i.from : r, options: IR(n.doc, Lse(i), t), validFor: Rse };
    if (i.name == "TagName") {
      for (let { parent: a } = i; a; a = a.parent) if (a.name == "Block") return { from: i.from, options: T1(), validFor: oo };
      return { from: i.from, options: $se, validFor: oo };
    }
    if (!e.explicit) return null;
    let s = i.resolve(r),
      l = s.childBefore(r);
    return l && l.name == ":" && s.name == "PseudoClassSelector"
      ? { from: r, options: v_, validFor: oo }
      : (l && l.name == ":" && s.name == "Declaration") || s.name == "ArgList"
      ? { from: r, options: b_, validFor: oo }
      : s.name == "Block" || s.name == "Styles"
      ? { from: r, options: T1(), validFor: oo }
      : null;
  },
  LR = MR((t) => t.name == "VariableName"),
  Iu = oa.define({
    name: "css",
    parser: Ase.configure({ props: [Ih.add({ Declaration: cf() }), Ba.add({ "Block KeyframeList": m4 })] }),
    languageData: { commentTokens: { block: { open: "/*", close: "*/" } }, indentOnInput: /^\s*\}$/, wordChars: "-" },
  });
function ow() {
  return new la(Iu, Iu.data.of({ autocomplete: LR }));
}
const Nse = Object.freeze(
    Object.defineProperty(
      { __proto__: null, css: ow, cssCompletionSource: LR, cssLanguage: Iu, defineCSSCompletionSource: MR },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Qse = 54,
  Dse = 1,
  Fse = 55,
  Bse = 2,
  Vse = 56,
  jse = 3,
  y_ = 4,
  Zse = 5,
  kp = 6,
  NR = 7,
  QR = 8,
  DR = 9,
  FR = 10,
  zse = 11,
  Wse = 12,
  Xse = 13,
  P1 = 57,
  Use = 14,
  w_ = 58,
  BR = 20,
  Hse = 22,
  VR = 23,
  qse = 24,
  hv = 26,
  jR = 27,
  Yse = 28,
  Gse = 31,
  Jse = 34,
  Kse = 36,
  ele = 37,
  tle = 0,
  nle = 1,
  rle = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    command: !0,
    embed: !0,
    frame: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
    menuitem: !0,
  },
  ile = { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 },
  S_ = {
    dd: { dd: !0, dt: !0 },
    dt: { dd: !0, dt: !0 },
    li: { li: !0 },
    option: { option: !0, optgroup: !0 },
    optgroup: { optgroup: !0 },
    p: {
      address: !0,
      article: !0,
      aside: !0,
      blockquote: !0,
      dir: !0,
      div: !0,
      dl: !0,
      fieldset: !0,
      footer: !0,
      form: !0,
      h1: !0,
      h2: !0,
      h3: !0,
      h4: !0,
      h5: !0,
      h6: !0,
      header: !0,
      hgroup: !0,
      hr: !0,
      menu: !0,
      nav: !0,
      ol: !0,
      p: !0,
      pre: !0,
      section: !0,
      table: !0,
      ul: !0,
    },
    rp: { rp: !0, rt: !0 },
    rt: { rp: !0, rt: !0 },
    tbody: { tbody: !0, tfoot: !0 },
    td: { td: !0, th: !0 },
    tfoot: { tbody: !0 },
    th: { td: !0, th: !0 },
    thead: { tbody: !0, tfoot: !0 },
    tr: { tr: !0 },
  };
function ole(t) {
  return t == 45 || t == 46 || t == 58 || (t >= 65 && t <= 90) || t == 95 || (t >= 97 && t <= 122) || t >= 161;
}
function ZR(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let k_ = null,
  C_ = null,
  __ = 0;
function dv(t, e) {
  let n = t.pos + e;
  if (__ == n && C_ == t) return k_;
  let r = t.peek(e);
  for (; ZR(r); ) r = t.peek(++e);
  let i = "";
  for (; ole(r); ) (i += String.fromCharCode(r)), (r = t.peek(++e));
  return (C_ = t), (__ = n), (k_ = i ? i.toLowerCase() : r == sle || r == lle ? void 0 : null);
}
const zR = 60,
  Cp = 62,
  sw = 47,
  sle = 63,
  lle = 33,
  ale = 45;
function E_(t, e) {
  (this.name = t), (this.parent = e);
}
const cle = [kp, FR, NR, QR, DR],
  ule = new PR({
    start: null,
    shift(t, e, n, r) {
      return cle.indexOf(e) > -1 ? new E_(dv(r, 1) || "", t) : t;
    },
    reduce(t, e) {
      return e == BR && t ? t.parent : t;
    },
    reuse(t, e, n, r) {
      let i = e.type.id;
      return i == kp || i == Kse ? new E_(dv(r, 1) || "", t) : t;
    },
    strict: !1,
  }),
  hle = new Ur(
    (t, e) => {
      if (t.next != zR) {
        t.next < 0 && e.context && t.acceptToken(P1);
        return;
      }
      t.advance();
      let n = t.next == sw;
      n && t.advance();
      let r = dv(t, 0);
      if (r === void 0) return;
      if (!r) return t.acceptToken(n ? Use : kp);
      let i = e.context ? e.context.name : null;
      if (n) {
        if (r == i) return t.acceptToken(zse);
        if (i && ile[i]) return t.acceptToken(P1, -2);
        if (e.dialectEnabled(tle)) return t.acceptToken(Wse);
        for (let o = e.context; o; o = o.parent) if (o.name == r) return;
        t.acceptToken(Xse);
      } else {
        if (r == "script") return t.acceptToken(NR);
        if (r == "style") return t.acceptToken(QR);
        if (r == "textarea") return t.acceptToken(DR);
        if (rle.hasOwnProperty(r)) return t.acceptToken(FR);
        i && S_[i] && S_[i][r] ? t.acceptToken(P1, -1) : t.acceptToken(kp);
      }
    },
    { contextual: !0 }
  ),
  dle = new Ur((t) => {
    for (let e = 0, n = 0; ; n++) {
      if (t.next < 0) {
        n && t.acceptToken(w_);
        break;
      }
      if (t.next == ale) e++;
      else if (t.next == Cp && e >= 2) {
        n >= 3 && t.acceptToken(w_, -2);
        break;
      } else e = 0;
      t.advance();
    }
  });
function fle(t) {
  for (; t; t = t.parent) if (t.name == "svg" || t.name == "math") return !0;
  return !1;
}
const ple = new Ur((t, e) => {
  if (t.next == sw && t.peek(1) == Cp) {
    let n = e.dialectEnabled(nle) || fle(e.context);
    t.acceptToken(n ? Zse : y_, 2);
  } else t.next == Cp && t.acceptToken(y_, 1);
});
function lw(t, e, n) {
  let r = 2 + t.length;
  return new Ur((i) => {
    for (let o = 0, s = 0, l = 0; ; l++) {
      if (i.next < 0) {
        l && i.acceptToken(e);
        break;
      }
      if ((o == 0 && i.next == zR) || (o == 1 && i.next == sw) || (o >= 2 && o < r && i.next == t.charCodeAt(o - 2))) o++, s++;
      else if ((o == 2 || o == r) && ZR(i.next)) s++;
      else if (o == r && i.next == Cp) {
        l > s ? i.acceptToken(e, -s) : i.acceptToken(n, -(s - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && l) {
        i.acceptToken(e, 1);
        break;
      } else o = s = 0;
      i.advance();
    }
  });
}
const mle = lw("script", Qse, Dse),
  gle = lw("style", Fse, Bse),
  Ole = lw("textarea", Vse, jse),
  vle = Fa({
    "Text RawText": $.content,
    "StartTag StartCloseTag SelfClosingEndTag EndTag": $.angleBracket,
    TagName: $.tagName,
    "MismatchedCloseTag/TagName": [$.tagName, $.invalid],
    AttributeName: $.attributeName,
    "AttributeValue UnquotedAttributeValue": $.attributeValue,
    Is: $.definitionOperator,
    "EntityReference CharacterReference": $.character,
    Comment: $.blockComment,
    ProcessingInst: $.processingInstruction,
    DoctypeDecl: $.documentMeta,
  }),
  ble = aa.deserialize({
    version: 14,
    states:
      ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
    stateData:
      ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
    goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
    nodeNames:
      "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
    maxTerm: 67,
    context: ule,
    nodeProps: [
      ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
      ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
      ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
      ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""],
    ],
    propSources: [vle],
    skippedNodes: [0],
    repeatNodeCount: 9,
    tokenData:
      "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
    tokenizers: [mle, gle, Ole, ple, hle, dle, 0, 1, 2, 3, 4, 5],
    topRules: { Document: [0, 15] },
    dialects: { noMatch: 0, selfClosing: 509 },
    tokenPrec: 511,
  });
function WR(t, e) {
  let n = Object.create(null);
  for (let r of t.getChildren(VR)) {
    let i = r.getChild(qse),
      o = r.getChild(hv) || r.getChild(jR);
    i && (n[e.read(i.from, i.to)] = o ? (o.type.id == hv ? e.read(o.from + 1, o.to - 1) : e.read(o.from, o.to)) : "");
  }
  return n;
}
function T_(t, e) {
  let n = t.getChild(Hse);
  return n ? e.read(n.from, n.to) : " ";
}
function A1(t, e, n) {
  let r;
  for (let i of n) if (!i.attrs || i.attrs(r || (r = WR(t.node.parent.firstChild, e)))) return { parser: i.parser };
  return null;
}
function XR(t = [], e = []) {
  let n = [],
    r = [],
    i = [],
    o = [];
  for (let l of t) (l.tag == "script" ? n : l.tag == "style" ? r : l.tag == "textarea" ? i : o).push(l);
  let s = e.length ? Object.create(null) : null;
  for (let l of e) (s[l.name] || (s[l.name] = [])).push(l);
  return s4((l, a) => {
    let c = l.type.id;
    if (c == Yse) return A1(l, a, n);
    if (c == Gse) return A1(l, a, r);
    if (c == Jse) return A1(l, a, i);
    if (c == BR && o.length) {
      let u = l.node,
        h = u.firstChild,
        d = h && T_(h, a),
        f;
      if (d) {
        for (let p of o)
          if (p.tag == d && (!p.attrs || p.attrs(f || (f = WR(h, a))))) {
            let m = u.lastChild,
              O = m.type.id == ele ? m.from : u.to;
            if (O > h.to) return { parser: p.parser, overlay: [{ from: h.to, to: O }] };
          }
      }
    }
    if (s && c == VR) {
      let u = l.node,
        h;
      if ((h = u.firstChild)) {
        let d = s[a.read(h.from, h.to)];
        if (d)
          for (let f of d) {
            if (f.tagName && f.tagName != T_(u.parent, a)) continue;
            let p = u.lastChild;
            if (p.type.id == hv) {
              let m = p.from + 1,
                O = p.lastChild,
                v = p.to - (O && O.isError ? 0 : 1);
              if (v > m) return { parser: f.parser, overlay: [{ from: m, to: v }] };
            } else if (p.type.id == jR) return { parser: f.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const xle = 312,
  P_ = 1,
  yle = 2,
  wle = 3,
  Sle = 4,
  kle = 313,
  Cle = 315,
  _le = 316,
  Ele = 5,
  Tle = 6,
  Ple = 0,
  fv = [
    9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288,
  ],
  UR = 125,
  Ale = 59,
  pv = 47,
  $le = 42,
  Rle = 43,
  Ile = 45,
  Mle = 60,
  Lle = 44,
  Nle = 63,
  Qle = 46,
  Dle = new PR({
    start: !1,
    shift(t, e) {
      return e == Ele || e == Tle || e == Cle ? t : e == _le;
    },
    strict: !1,
  }),
  Fle = new Ur(
    (t, e) => {
      let { next: n } = t;
      (n == UR || n == -1 || e.context) && t.acceptToken(kle);
    },
    { contextual: !0, fallback: !0 }
  ),
  Ble = new Ur(
    (t, e) => {
      let { next: n } = t,
        r;
      fv.indexOf(n) > -1 ||
        (n == pv && ((r = t.peek(1)) == pv || r == $le)) ||
        (n != UR && n != Ale && n != -1 && !e.context && t.acceptToken(xle));
    },
    { contextual: !0 }
  ),
  Vle = new Ur(
    (t, e) => {
      let { next: n } = t;
      if (n == Rle || n == Ile) {
        if ((t.advance(), n == t.next)) {
          t.advance();
          let r = !e.context && e.canShift(P_);
          t.acceptToken(r ? P_ : yle);
        }
      } else n == Nle && t.peek(1) == Qle && (t.advance(), t.advance(), (t.next < 48 || t.next > 57) && t.acceptToken(wle));
    },
    { contextual: !0 }
  );
function $1(t, e) {
  return (t >= 65 && t <= 90) || (t >= 97 && t <= 122) || t == 95 || t >= 192 || (!e && t >= 48 && t <= 57);
}
const jle = new Ur((t, e) => {
    if (t.next != Mle || !e.dialectEnabled(Ple) || (t.advance(), t.next == pv)) return;
    let n = 0;
    for (; fv.indexOf(t.next) > -1; ) t.advance(), n++;
    if ($1(t.next, !0)) {
      for (t.advance(), n++; $1(t.next, !1); ) t.advance(), n++;
      for (; fv.indexOf(t.next) > -1; ) t.advance(), n++;
      if (t.next == Lle) return;
      for (let r = 0; ; r++) {
        if (r == 7) {
          if (!$1(t.next, !0)) return;
          break;
        }
        if (t.next != "extends".charCodeAt(r)) break;
        t.advance(), n++;
      }
    }
    t.acceptToken(Sle, -n);
  }),
  Zle = Fa({
    "get set async static": $.modifier,
    "for while do if else switch try catch finally return throw break continue default case": $.controlKeyword,
    "in of await yield void typeof delete instanceof": $.operatorKeyword,
    "let var const using function class extends": $.definitionKeyword,
    "import export from": $.moduleKeyword,
    "with debugger as new": $.keyword,
    TemplateString: $.special($.string),
    super: $.atom,
    BooleanLiteral: $.bool,
    this: $.self,
    null: $.null,
    Star: $.modifier,
    VariableName: $.variableName,
    "CallExpression/VariableName TaggedTemplateExpression/VariableName": $.function($.variableName),
    VariableDefinition: $.definition($.variableName),
    Label: $.labelName,
    PropertyName: $.propertyName,
    PrivatePropertyName: $.special($.propertyName),
    "CallExpression/MemberExpression/PropertyName": $.function($.propertyName),
    "FunctionDeclaration/VariableDefinition": $.function($.definition($.variableName)),
    "ClassDeclaration/VariableDefinition": $.definition($.className),
    PropertyDefinition: $.definition($.propertyName),
    PrivatePropertyDefinition: $.definition($.special($.propertyName)),
    UpdateOp: $.updateOperator,
    "LineComment Hashbang": $.lineComment,
    BlockComment: $.blockComment,
    Number: $.number,
    String: $.string,
    Escape: $.escape,
    ArithOp: $.arithmeticOperator,
    LogicOp: $.logicOperator,
    BitOp: $.bitwiseOperator,
    CompareOp: $.compareOperator,
    RegExp: $.regexp,
    Equals: $.definitionOperator,
    Arrow: $.function($.punctuation),
    ": Spread": $.punctuation,
    "( )": $.paren,
    "[ ]": $.squareBracket,
    "{ }": $.brace,
    "InterpolationStart InterpolationEnd": $.special($.brace),
    ".": $.derefOperator,
    ", ;": $.separator,
    "@": $.meta,
    TypeName: $.typeName,
    TypeDefinition: $.definition($.typeName),
    "type enum interface implements namespace module declare": $.definitionKeyword,
    "abstract global Privacy readonly override": $.modifier,
    "is keyof unique infer": $.operatorKeyword,
    JSXAttributeValue: $.attributeValue,
    JSXText: $.content,
    "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": $.angleBracket,
    "JSXIdentifier JSXNameSpacedName": $.tagName,
    "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": $.attributeName,
    "JSXBuiltin/JSXIdentifier": $.standard($.tagName),
  }),
  zle = {
    __proto__: null,
    export: 20,
    as: 25,
    from: 33,
    default: 36,
    async: 41,
    function: 42,
    extends: 54,
    this: 58,
    true: 66,
    false: 66,
    null: 78,
    void: 82,
    typeof: 86,
    super: 102,
    new: 136,
    delete: 148,
    yield: 157,
    await: 161,
    class: 166,
    public: 229,
    private: 229,
    protected: 229,
    readonly: 231,
    instanceof: 250,
    satisfies: 253,
    in: 254,
    const: 256,
    import: 290,
    keyof: 345,
    unique: 349,
    infer: 355,
    is: 391,
    abstract: 411,
    implements: 413,
    type: 415,
    let: 418,
    var: 420,
    using: 423,
    interface: 429,
    enum: 433,
    namespace: 439,
    module: 441,
    declare: 445,
    global: 449,
    for: 468,
    of: 477,
    while: 480,
    with: 484,
    do: 488,
    if: 492,
    else: 494,
    switch: 498,
    case: 504,
    try: 510,
    catch: 514,
    finally: 518,
    return: 522,
    throw: 526,
    break: 530,
    continue: 534,
    debugger: 538,
  },
  Wle = {
    __proto__: null,
    async: 123,
    get: 125,
    set: 127,
    declare: 189,
    public: 191,
    private: 191,
    protected: 191,
    static: 193,
    abstract: 195,
    override: 197,
    readonly: 203,
    accessor: 205,
    new: 395,
  },
  Xle = { __proto__: null, "<": 187 },
  Ule = aa.deserialize({
    version: 14,
    states:
      "$@QO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#CiO+RO!bO'#CjO+aO#tO'#CjO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DwO0fQ^O'#EPOOQ?Mr'#EX'#EXO1PQWO'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQWO'#GpO1dQWO'#ElO1iQWO'#ElO3hQ?NdO'#JmO6[Q?NdO'#JnO6uQWO'#F[O6zQ&jO'#FsOOQ?Mr'#Fe'#FeO7VO,YO'#FeO7eQ7[O'#FzO9RQWO'#FyOOQ?Mr'#Jn'#JnOOQ?Mp'#Jm'#JmO9WQWO'#GtOOQU'#KZ'#KZO9cQWO'#IUO9hQ?MxO'#IVOOQU'#JZ'#JZOOQU'#IZ'#IZQ`Q^OOO`Q^OOO9pQMnO'#DsO9wQ^O'#D{O:OQ^O'#D}O9^QWO'#GpO:VQ7[O'#CoO:eQWO'#EkO:pQWO'#EvO:uQ7[O'#FdO;dQWO'#GpOOQO'#K['#K[O;iQWO'#K[O;wQWO'#GxO;wQWO'#GyO;wQWO'#G{O9^QWO'#HOO<nQWO'#HRO>VQWO'#CeO>gQWO'#H_O>oQWO'#HeO>oQWO'#HgO`Q^O'#HiO>oQWO'#HkO>oQWO'#HnO>tQWO'#HtO>yQ?MyO'#HzO%[Q^O'#H|O?UQ?MyO'#IOO?aQ?MyO'#IQO9hQ?MxO'#ISO?lQ?NdO'#CiO@nQ`O'#DiQOQWOOO%[Q^O'#D}OAUQWO'#EQO:VQ7[O'#EkOAaQWO'#EkOAlQpO'#FdOOQU'#Cg'#CgOOQ?Mp'#Dn'#DnOOQ?Mp'#Jq'#JqO%[Q^O'#JqOOQO'#Jt'#JtOOQO'#Id'#IdOBlQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Jx'#JxOChQ?NQO'#EdOCrQ`O'#ETOOQO'#Js'#JsODWQ`O'#JtOEeQ`O'#ETOCrQ`O'#EdPErO#@ItO'#CbPOOO)CDx)CDxOOOO'#I['#I[OE}O!bO,59UOOQ?Mr,59U,59UOOOO'#I]'#I]OF]O#tO,59UO%[Q^O'#D`OOOO'#I_'#I_OFkO!0LbO,59xOOQ?Mr,59x,59xOFyQ^O'#I`OG^QWO'#JoOI]QrO'#JoO+}Q^O'#JoOIdQWO,5:OOIzQWO'#EmOJXQWO'#KOOJdQWO'#J}OJdQWO'#J}OJlQWO,5;ZOJqQWO'#J|OOQ?Mv,5:Z,5:ZOJxQ^O,5:ZOLvQ?NdO,5:cOMgQWO,5:kONQQ?MxO'#J{ONXQWO'#JzO9WQWO'#JzONmQWO'#JzONuQWO,5;YONzQWO'#JzO!#PQrO'#JnOOQ?Mr'#Ci'#CiO%[Q^O'#EPO!#oQrO,5:pOOQQ'#Ju'#JuOOQO-E<f-E<fO9^QWO,5=[O!$VQWO,5=[O!$[Q^O,5;WO!&_Q7[O'#EhO!'xQWO,5;WO!'}Q^O'#DvO!(XQ`O,5;aO!(aQ`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!(oQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yOOQ?Mr,5;{,5;{O%[Q^O'#IlO!*rQ?MxO,5<gO%[Q^O,5;bO!&_Q7[O,5;bO!+aQ7[O,5;bO!-RQ7[O'#EZO%[Q^O,5;vOOQ?Mr,5;z,5;zO!-YQ&jO'#FiO!.VQ&jO'#KSO!-qQ&jO'#KSO!.^Q&jO'#KSOOQO'#KS'#KSO!.rQ&jO,5<ROOOS,5<_,5<_O!/TQ^O'#FuOOOS'#Ik'#IkO7VO,YO,5<PO!/[Q&jO'#FwOOQ?Mr,5<P,5<PO!/{Q!LQO'#CvOOQ?Mr'#Cz'#CzO!0`O!0LbO'#DOO!0|Q7[O,5<dO!1TQWO,5<fO!2pQ$ISO'#GVO!2}QWO'#GWO!3SQWO'#GWO!4rQ$ISO'#G[O!5nQ`O'#G`OOQO'#Gk'#GkO!+hQ7[O'#GjOOQO'#Gm'#GmO!+hQ7[O'#GlO!6aQ!LQO'#JgOOQ?Mr'#Jg'#JgO!6kQWO'#JfO!6yQWO'#JeO!7RQWO'#CuOOQ?Mr'#Cx'#CxO!7ZQWO'#CzOOQ?Mr'#DS'#DSOOQ?Mr'#DU'#DUO1SQWO'#DWO!+hQ7[O'#F}O!+hQ7[O'#GPO!7`QWO'#GRO!7eQWO'#GSO!3SQWO'#GYO!+hQ7[O'#G_O!7jQWO'#EnO!8XQWO,5<eOOQ?Mp'#Cr'#CrO!8aQWO'#EoO!9ZQ`O'#EpOOQ?Mp'#J|'#J|O!9bQ?MxO'#K]O9hQ?MxO,5=`O`Q^O,5>pOOQU'#Jc'#JcOOQU,5>q,5>qOOQU-E<X-E<XO!;aQ?NdO,5:_O!9UQ`O,5:]O!=zQ?NdO,5:gO%[Q^O,5:gO!@bQ?NdO,5:iOOQO,5@v,5@vO!ARQ7[O,5=[O!AaQ?MxO'#JdO9RQWO'#JdO!ArQ?MxO,59ZO!A}Q`O,59ZO!BVQ7[O,59ZO:VQ7[O,59ZO!BbQWO,5;WO!BjQWO'#H^O!COQWO'#K`O%[Q^O,5;|O!9UQ`O,5<OO!CWQWO,5=wO!C]QWO,5=wO!CbQWO,5=wO9hQ?MxO,5=wO;wQWO,5=gOOQO'#Cv'#CvO!CpQ`O,5=dO!CxQ7[O,5=eO!DTQWO,5=gO!DYQpO,5=jO!DbQWO'#K[O>tQWO'#HTO9^QWO'#HVO!DgQWO'#HVO:VQ7[O'#HXO!DlQWO'#HXOOQU,5=m,5=mO!DqQWO'#HYO!ESQWO'#CoO!EXQWO,59PO!EcQWO,59PO!GhQ^O,59POOQU,59P,59PO!GxQ?MxO,59PO%[Q^O,59PO!JTQ^O'#HaOOQU'#Hb'#HbOOQU'#Hc'#HcO`Q^O,5=yO!JkQWO,5=yO`Q^O,5>PO`Q^O,5>RO!JpQWO,5>TO`Q^O,5>VO!JuQWO,5>YO!JzQ^O,5>`OOQU,5>f,5>fO%[Q^O,5>fO9hQ?MxO,5>hOOQU,5>j,5>jO# UQWO,5>jOOQU,5>l,5>lO# UQWO,5>lOOQU,5>n,5>nO# rQ`O'#D[O%[Q^O'#JqO# |Q`O'#JqO#!kQ`O'#DjO#!|Q`O'#DjO#%_Q^O'#DjO#%fQWO'#JpO#%nQWO,5:TO#%sQWO'#EqO#&RQWO'#KPO#&ZQWO,5;[O#&`Q`O'#DjO#&mQ`O'#ESOOQ?Mr,5:l,5:lO%[Q^O,5:lO#&tQWO,5:lO>tQWO,5;VO!A}Q`O,5;VO!BVQ7[O,5;VO:VQ7[O,5;VO#&|QWO,5@]O#'RQ(CYO,5:pOOQO-E<b-E<bO#(XQ?NQO,5;OOCrQ`O,5:oO#(cQ`O,5:oOCrQ`O,5;OO!ArQ?MxO,5:oOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#(pQ?MxO,5;OO#({Q?MxO,5;OO!A}Q`O,5:oOOQO,5;U,5;UO#)ZQ?MxO,5;OPOOO'#IY'#IYP#)oO#@ItO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ?Mr1G.p1G.pOOOO-E<Z-E<ZO#)zQpO,59zOOOO-E<]-E<]OOQ?Mr1G/d1G/dO#*PQrO,5>zO+}Q^O,5>zOOQO,5?Q,5?QO#*ZQ^O'#I`OOQO-E<^-E<^O#*hQWO,5@ZO#*pQrO,5@ZO#*wQWO,5@iOOQ?Mr1G/j1G/jO%[Q^O,5@jO#+PQWO'#IfOOQO-E<d-E<dO#*wQWO,5@iOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0V1G0VO%[Q^O,5@gO#+eQ?MxO,5@gO#+vQ?MxO,5@gO#+}QWO,5@fO9WQWO,5@fO#,VQWO,5@fO#,eQWO'#IiO#+}QWO,5@fOOQ?Mp1G0t1G0tO!(XQ`O,5:rO!(dQ`O,5:rOOQQ,5:t,5:tO#-VQYO,5:tO#-_Q7[O1G2vO9^QWO1G2vOOQ?Mr1G0r1G0rO#-mQ?NdO1G0rO#.rQ?NbO,5;SOOQ?Mr'#GU'#GUO#/`Q?NdO'#JgO!$[Q^O1G0rO#1hQrO'#JrO%[Q^O'#JrO#1rQWO,5:bOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#1wQWO1G0{O#4]Q?NdO1G0|O#4dQ?NdO1G0|O#6zQ?NdO1G0|O#7RQ?NdO1G0|O#9iQ?NdO1G0|O#<PQ?NdO1G0|O#<WQ?NdO1G0|O#<_Q?NdO1G0|O#>uQ?NdO1G0|O#>|Q?NdO1G0|O#AZQ07bO'#CiO#CUQ07bO1G1_O#C]Q07bO'#JnO#CpQ?NdO,5?WOOQ?Mp-E<j-E<jO#E}Q?NdO1G0|O#FzQ?NdO1G0|OOQ?Mr1G0|1G0|O#GzQ7[O'#JwO#HUQWO,5:uO#HZQ?NdO1G1bO#H}Q&jO,5<VO#IVQ&jO,5<WO#I_Q&jO'#FnO#IvQWO'#FmOOQO'#KT'#KTOOQO'#Ij'#IjO#I{Q&jO1G1mOOQ?Mr1G1m1G1mOOOS1G1x1G1xO#J^Q07bO'#JmO#JhQWO,5<aO!(oQ^O,5<aOOOS-E<i-E<iOOQ?Mr1G1k1G1kO#JmQ`O'#KSOOQ?Mr,5<c,5<cO#JuQ`O,5<cO!&_Q7[O'#DQOOOO'#I^'#I^O#JzO!0LbO,59jOOQ?Mr,59j,59jO%[Q^O1G2OO!7eQWO'#InO#KVQ7[O,5<xOOQ?Mr,5<u,5<uO!+hQ7[O'#IqO#KuQ7[O,5=UO!+hQ7[O'#IsO#LhQ7[O,5=WO!&_Q7[O,5=YOOQO1G2Q1G2QO#LrQpO'#CrO#MVQ$ISO'#EoO#NUQ`O'#G`O#NrQpO,5<qO#NyQWO'#KWO9WQWO'#KWO$ XQWO,5<sO!+hQ7[O,5<rO$ ^QWO'#GXO$ oQWO,5<rO$ tQpO'#GUO$!RQpO'#KXO$!]QWO'#KXO!&_Q7[O'#KXO$!bQWO,5<vO$!gQ`O'#GaO!5iQ`O'#GaO$!xQWO'#GcO$!}QWO'#GeO!3SQWO'#GhO$#SQ?MxO'#IpO$#_Q`O,5<zOOQ?Mv,5<z,5<zO$#fQ`O'#GaO$#tQ`O'#GbO$#|Q`O'#GbO$$RQ7[O,5=UO$$cQ7[O,5=WOOQ?Mr,5=Z,5=ZO!+hQ7[O,5@QO!+hQ7[O,5@QO$$sQWO'#IuO$%OQWO,5@PO$%WQWO,59aOOQ?Mr,59f,59fO$%zQ!LSO,59rOOQ?Mr'#Jk'#JkO$&mQ7[O,5<iO$'`Q7[O,5<kO@fQWO,5<mOOQ?Mr,5<n,5<nO$'jQWO,5<tO$'oQ7[O,5<yO$(PQWO'#JzO!$[Q^O1G2PO$(UQWO1G2PO9WQWO'#J}O9WQWO'#EqO%[Q^O'#EqO9WQWO'#IwO$(ZQ?MxO,5@wOOQU1G2z1G2zOOQU1G4[1G4[OOQ?Mr1G/y1G/yOOQ?Mr1G/w1G/wO$*]Q?NdO1G0ROOQU1G2v1G2vO!&_Q7[O1G2vO%[Q^O1G2vO#-bQWO1G2vO$,aQ7[O'#EhOOQ?Mp,5@O,5@OO$,kQ?MxO,5@OOOQU1G.u1G.uO!ArQ?MxO1G.uO!A}Q`O1G.uO!BVQ7[O1G.uO$,|QWO1G0rO$-RQWO'#CiO$-^QWO'#KaO$-fQWO,5=xO$-kQWO'#KaO$-pQWO'#KaO$.OQWO'#I}O$.^QWO,5@zO$.fQrO1G1hOOQ?Mr1G1j1G1jO9^QWO1G3cO@fQWO1G3cO$.mQWO1G3cO$.rQWO1G3cOOQU1G3c1G3cO!DTQWO1G3RO!&_Q7[O1G3OO$.wQWO1G3OOOQU1G3P1G3PO!&_Q7[O1G3PO$.|QWO1G3PO$/UQ`O'#G}OOQU1G3R1G3RO!5iQ`O'#IyO!DYQpO1G3UOOQU1G3U1G3UOOQU,5=o,5=oO$/^Q7[O,5=qO9^QWO,5=qO$!}QWO,5=sO9RQWO,5=sO!A}Q`O,5=sO!BVQ7[O,5=sO:VQ7[O,5=sO$/lQWO'#K_O$/wQWO,5=tOOQU1G.k1G.kO$/|Q?MxO1G.kO@fQWO1G.kO$0XQWO1G.kO9hQ?MxO1G.kO$2aQrO,5@|O$2nQWO,5@|O9WQWO,5@|O$2yQ^O,5={O$3QQWO,5={OOQU1G3e1G3eO`Q^O1G3eOOQU1G3k1G3kOOQU1G3m1G3mO>oQWO1G3oO$3VQ^O1G3qO$7ZQ^O'#HpOOQU1G3t1G3tO$7hQWO'#HvO>tQWO'#HxOOQU1G3z1G3zO$7pQ^O1G3zO9hQ?MxO1G4QOOQU1G4S1G4SOOQ?Mp'#G]'#G]O9hQ?MxO1G4UO9hQ?MxO1G4WO$;wQWO,5@]O!(oQ^O,5;]O9WQWO,5;]O>tQWO,5:UO!(oQ^O,5:UO!A}Q`O,5:UO$;|Q07bO,5:UOOQO,5;],5;]O$<WQ`O'#IaO$<nQWO,5@[OOQ?Mr1G/o1G/oO$<vQ`O'#IgO$=QQWO,5@kOOQ?Mp1G0v1G0vO#!|Q`O,5:UOOQO'#Ic'#IcO$=YQ`O,5:nOOQ?Mv,5:n,5:nO#&wQWO1G0WOOQ?Mr1G0W1G0WO%[Q^O1G0WOOQ?Mr1G0q1G0qO>tQWO1G0qO!A}Q`O1G0qO!BVQ7[O1G0qOOQ?Mp1G5w1G5wO!ArQ?MxO1G0ZOOQO1G0j1G0jO%[Q^O1G0jO$=aQ?MxO1G0jO$=lQ?MxO1G0jO!A}Q`O1G0ZOCrQ`O1G0ZO$=zQ?MxO1G0jOOQO1G0Z1G0ZO$>`Q?NdO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$>jQpO,5<gO$>rQrO1G4fOOQO1G4l1G4lO%[Q^O,5>zO$>|QWO1G5uO$?UQWO1G6TO$?^QrO1G6UO9WQWO,5?QO$?hQ?NdO1G6RO%[Q^O1G6RO$?xQ?MxO1G6RO$@ZQWO1G6QO$@ZQWO1G6QO9WQWO1G6QO$@cQWO,5?TO9WQWO,5?TOOQO,5?T,5?TO$@wQWO,5?TO$(PQWO,5?TOOQO-E<g-E<gOOQQ1G0^1G0^OOQQ1G0`1G0`O#-YQWO1G0`OOQU7+(b7+(bO!&_Q7[O7+(bO%[Q^O7+(bO$AVQWO7+(bO$AbQ7[O7+(bO$ApQ?NdO,5=UO$CxQ?NdO,5=WO$FQQ?NdO,5=UO$H`Q?NdO,5=WO$JnQ?NdO,59rO$LsQ?NdO,5<iO$N{Q?NdO,5<kO%#TQ?NdO,5<yOOQ?Mr7+&^7+&^O%%cQ?NdO7+&^O%&VQ^O'#IbO%&dQWO,5@^O%&lQrO,5@^OOQ?Mr1G/|1G/|O%&vQWO7+&gOOQ?Mr7+&g7+&gO%&{Q07bO,5:cO%[Q^O7+&yO%'VQ07bO,5:_O%'dQ07bO,5:gO%'nQ07bO,5:iO%'xQ7[O'#IeO%(SQWO,5@cOOQ?Mr1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%([QtO,5<YO!(oQ^O,5<XOOQO-E<h-E<hOOQ?Mr7+'X7+'XOOOS7+'d7+'dOOOS1G1{1G1{O%(gQWO1G1{OOQ?Mr1G1}1G1}O%(lQpO,59lOOOO-E<[-E<[OOQ?Mr1G/U1G/UO%(sQ?NdO7+'jOOQ?Mr,5?Y,5?YO%)gQpO,5?YOOQ?Mr1G2d1G2dP!&_Q7[O'#InPOQ?Mr-E<l-E<lO%*VQ7[O,5?]OOQ?Mr-E<o-E<oO%*xQ7[O,5?_OOQ?Mr-E<q-E<qO%+SQpO1G2tO%+ZQpO'#CrO%+qQ7[O'#J}O%+xQ^O'#EqOOQ?Mr1G2]1G2]O%,SQWO'#ImO%,hQWO,5@rO%,hQWO,5@rO%,pQWO,5@rO%,{QWO,5@rOOQO1G2_1G2_O%-ZQ7[O1G2^O!+hQ7[O1G2^O%-kQ$ISO'#IoO%-xQWO,5@sO!&_Q7[O,5@sO%.QQpO,5@sOOQ?Mr1G2b1G2bOOQ?Mp,5<{,5<{OOQ?Mp,5<|,5<|O$(PQWO,5<|OCcQWO,5<|O!A}Q`O,5<{OOQO'#Gd'#GdO%.[QWO,5<}OOQ?Mp,5=P,5=PO$(PQWO,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ?Mv1G2f1G2fO!5iQ`O,5<{O%.dQWO,5<|O$!xQWO,5<}O%.oQ`O,5<|O!+hQ7[O'#IqO%/`Q7[O1G2pO!+hQ7[O'#IsO%0RQ7[O1G2rO%0]Q7[O1G5lO%0gQ7[O1G5lOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9UQ`O,59tO%[Q^O,59tOOQ?Mr,5<h,5<hO%0tQWO1G2XO!+hQ7[O1G2`O%0yQ?NdO7+'kOOQ?Mr7+'k7+'kO!$[Q^O7+'kO%1mQWO,5;]OOQ?Mp,5?c,5?cOOQ?Mp-E<u-E<uO%1rQpO'#KYO#&wQWO7+(bO4UQrO7+(bO$AYQWO7+(bO%1|Q?NbO'#CiO%2aQ?NbO,5=QO%3RQWO,5=QOOQ?Mp1G5j1G5jOOQU7+$a7+$aO!ArQ?MxO7+$aO!A}Q`O7+$aO!$[Q^O7+&^O%3WQWO'#I|O%3oQWO,5@{OOQO1G3d1G3dO9^QWO,5@{O%3oQWO,5@{O%3wQWO,5@{OOQO,5?i,5?iOOQO-E<{-E<{OOQ?Mr7+'S7+'SO%3|QWO7+(}O9hQ?MxO7+(}O9^QWO7+(}O@fQWO7+(}OOQU7+(m7+(mO%4RQ?NbO7+(jO!&_Q7[O7+(jO%4]QpO7+(kOOQU7+(k7+(kO!&_Q7[O7+(kO%4dQWO'#K^O%4oQWO,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQU7+(p7+(pO%6RQ`O'#HWOOQU1G3]1G3]O!&_Q7[O1G3]O%[Q^O1G3]O%6YQWO1G3]O%6eQ7[O1G3]O9hQ?MxO1G3_O$!}QWO1G3_O9RQWO1G3_O!A}Q`O1G3_O!BVQ7[O1G3_O%6sQWO'#I{O%7XQWO,5@yO%7aQ`O,5@yOOQ?Mp1G3`1G3`OOQU7+$V7+$VO@fQWO7+$VO9hQ?MxO7+$VO%7lQWO7+$VO%[Q^O1G6hO%[Q^O1G6iO%7qQ?MxO1G6hO%7{Q^O1G3gO%8SQWO1G3gO%8XQ^O1G3gOOQU7+)P7+)PO9hQ?MxO7+)ZO`Q^O7+)]OOQU'#Kd'#KdOOQU'#JO'#JOO%8`Q^O,5>[OOQU,5>[,5>[O%[Q^O'#HqO%8mQWO'#HsOOQU,5>b,5>bO9WQWO,5>bOOQU,5>d,5>dOOQU7+)f7+)fOOQU7+)l7+)lOOQU7+)p7+)pOOQU7+)r7+)rO%8rQ`O1G5wO%9WQ07bO1G0wO%9bQWO1G0wOOQO1G/p1G/pO%9mQ07bO1G/pO>tQWO1G/pO!(oQ^O'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!A}Q`O1G/pOOQO-E<a-E<aOOQ?Mv1G0Y1G0YOOQ?Mr7+%r7+%rO#&wQWO7+%rOOQ?Mr7+&]7+&]O>tQWO7+&]O!A}Q`O7+&]OOQO7+%u7+%uO$>`Q?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%9wQ?MxO7+&UO!ArQ?MxO7+%uO!A}Q`O7+%uO%:SQ?MxO7+&UO%:bQ?NdO7++mO%[Q^O7++mO%:rQWO7++lO%:rQWO7++lOOQO1G4o1G4oO9WQWO1G4oO%:zQWO1G4oOOQQ7+%z7+%zO#&wQWO<<K|O4UQrO<<K|O%;YQWO<<K|OOQU<<K|<<K|O!&_Q7[O<<K|O%[Q^O<<K|O%;bQWO<<K|O%;mQ?NdO,5?]O%=uQ?NdO,5?_O%?}Q?NdO1G2^O%B]Q?NdO1G2pO%DeQ?NdO1G2rO%FmQrO,5>|O%[Q^O,5>|OOQO-E<`-E<`O%FwQWO1G5xOOQ?Mr<<JR<<JRO%GPQ07bO1G0rO%IWQ07bO1G0|O%I_Q07bO1G0|O%K`Q07bO1G0|O%KgQ07bO1G0|O%MhQ07bO1G0|O& iQ07bO1G0|O& pQ07bO1G0|O& wQ07bO1G0|O&#xQ07bO1G0|O&$PQ07bO1G0|O&$WQ?NdO<<JeO&&OQ07bO1G0|O&&{Q07bO1G0|O&'{Q07bO'#JgO&*OQ07bO1G1bO&*]Q07bO1G0RO&*gQ7[O,5?POOQO-E<c-E<cO!(oQ^O'#FpOOQO'#KU'#KUOOQO1G1t1G1tO&*qQWO1G1sO&*vQ07bO,5?WOOOS7+'g7+'gOOOO1G/W1G/WOOQ?Mr1G4t1G4tO!+hQ7[O7+(`O&-WQrO'#CiO&-bQWO,5?XO9WQWO,5?XOOQO-E<k-E<kO&-pQWO1G6^O&-pQWO1G6^O&-xQWO1G6^O&.TQ7[O7+'xO&.eQpO,5?ZO&.oQWO,5?ZO!&_Q7[O,5?ZOOQO-E<m-E<mO&.tQpO1G6_O&/OQWO1G6_OOQ?Mp1G2h1G2hO$(PQWO1G2hOOQ?Mp1G2g1G2gO&/WQWO1G2iO!&_Q7[O1G2iOOQ?Mp1G2n1G2nO!A}Q`O1G2gOCcQWO1G2hO&/]QWO1G2iO&/eQWO1G2hO$!xQWO1G2iO&0XQ7[O,5?]OOQ?Mr-E<p-E<pO&0zQ7[O,5?_OOQ?Mr-E<r-E<rO!+hQ7[O7++WOOQ?Mr1G/`1G/`O&1UQWO1G/`OOQ?Mr7+'s7+'sO&1ZQ7[O7+'zO&1kQ?NdO<<KVOOQ?Mr<<KV<<KVO&2_QWO1G0wO!&_Q7[O'#IvO&2dQWO,5@tO&4fQrO<<K|O!&_Q7[O1G2lOOQU<<G{<<G{O!ArQ?MxO<<G{O&4mQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?h,5?hO&5aQWO,5?hO&5fQWO,5?hOOQO-E<z-E<zO&5tQWO1G6gO&5tQWO1G6gO9^QWO1G6gO@fQWO<<LiOOQU<<Li<<LiO&5|QWO<<LiO9hQ?MxO<<LiOOQU<<LU<<LUO%4RQ?NbO<<LUOOQU<<LV<<LVO%4]QpO<<LVO&6RQ`O'#IxO&6^QWO,5@xO!(oQ^O,5@xOOQU1G3T1G3TO%+xQ^O'#JqOOQO'#Iz'#IzO9hQ?MxO'#IzO&6fQ`O,5=rOOQU,5=r,5=rO&6mQ`O'#EdO&7RQ`O'#GcO&7WQWO7+(wO&7]QWO7+(wOOQU7+(w7+(wO!&_Q7[O7+(wO%[Q^O7+(wO&7eQWO7+(wOOQU7+(y7+(yO9hQ?MxO7+(yO$!}QWO7+(yO9RQWO7+(yO!A}Q`O7+(yO&7pQWO,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&7{QWO1G6eO9hQ?MxO<<GqOOQU<<Gq<<GqO@fQWO<<GqO&8TQWO7+,SO&8YQWO7+,TO%[Q^O7+,SO%[Q^O7+,TOOQU7+)R7+)RO&8_QWO7+)RO&8dQ^O7+)RO&8kQWO7+)ROOQU<<Lu<<LuOOQU<<Lw<<LwOOQU-E<|-E<|OOQU1G3v1G3vO&8pQWO,5>]OOQU,5>_,5>_O&8uQWO1G3|O9WQWO7+&cO!(oQ^O7+&cOOQO7+%[7+%[O&8zQ07bO1G6UO>tQWO7+%[OOQ?Mr<<I^<<I^OOQ?Mr<<Iw<<IwO>tQWO<<IwOOQO<<Ip<<IpO$>`Q?NdO<<IpO%[Q^O<<IpOOQO<<Ia<<IaO!ArQ?MxO<<IaO&9UQ?MxO<<IpO&9aQ?NdO<= XO&9qQWO<= WOOQO7+*Z7+*ZO9WQWO7+*ZOOQUANAhANAhO&9yQrOANAhO!&_Q7[OANAhO#&wQWOANAhO4UQrOANAhO&:QQWOANAhO%[Q^OANAhO&:YQ?NdO7+'xO&<hQ?NdO,5?]O&>pQ?NdO,5?_O&@xQ?NdO7+'zO&CWQrO1G4hO&CbQ07bO7+&^O&EcQ07bO,5=UO&GgQ07bO,5=WO&GwQ07bO,5=UO&HXQ07bO,5=WO&HiQ07bO,59rO&JlQ07bO,5<iO&LlQ07bO,5<kO&N}Q07bO,5<yO'!pQ07bO7+'jO'!}Q07bO7+'kO'#[QWO,5<[OOQO7+'_7+'_O'#aQ7[O<<KzOOQO1G4s1G4sO'#hQWO1G4sO'#sQWO1G4sO'$RQWO7++xO'$RQWO7++xO!&_Q7[O1G4uO'$ZQpO1G4uO'$eQWO7++yOOQ?Mp7+(S7+(SO'$mQWO7+(TO'$xQpO7+(TOOQ?Mp7+(R7+(RO$(PQWO7+(SO'%PQWO7+(TO!&_Q7[O7+(TOCcQWO7+(SO'%UQWO7+(TO'%^Q7[O<<NrOOQ?Mr7+$z7+$zO'%hQpO,5?bOOQO-E<t-E<tO'%rQ?NbO7+(WOOQUAN=gAN=gO9^QWO1G5SOOQO1G5S1G5SO'&SQWO1G5SO'&XQWO7+,RO'&XQWO7+,RO9hQ?MxOANBTO@fQWOANBTOOQUANBTANBTOOQUANApANApOOQUANAqANAqO'&aQWO,5?dOOQO-E<v-E<vO'&lQ07bO1G6dOOQO,5?f,5?fOOQO-E<x-E<xOOQU1G3^1G3^O%+xQ^O,5<}O'&vQWO,5<}OOQU<<Lc<<LcO!&_Q7[O<<LcO&7WQWO<<LcO'&{QWO<<LcO%[Q^O<<LcOOQU<<Le<<LeO9hQ?MxO<<LeO$!}QWO<<LeO9RQWO<<LeO''TQ`O1G5RO''`QWO7+,POOQUAN=]AN=]O9hQ?MxOAN=]OOQU<= n<= nOOQU<= o<= oO''hQWO<= nO''mQWO<= oOOQU<<Lm<<LmO''rQWO<<LmO''wQ^O<<LmOOQU1G3w1G3wO>tQWO7+)hO'(OQWO<<I}O'(ZQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$>`Q?NdOAN?[OOQOAN>{AN>{O%[Q^OAN?[OOQO<<Mu<<MuOOQUG27SG27SO!&_Q7[OG27SO#&wQWOG27SO'(eQrOG27SO4UQrOG27SO'(lQWOG27SO'(tQ07bO<<JeO')RQ07bO1G2^O'*tQ07bO,5?]O',tQ07bO,5?_O'.tQ07bO1G2pO'0tQ07bO1G2rO'2tQ07bO<<KVO'3RQ07bO<<IxOOQO1G1v1G1vO!+hQ7[OANAfOOQO7+*_7+*_O'3`QWO7+*_O'3kQWO<= dO'3sQpO7+*aOOQ?Mp<<Ko<<KoO$(PQWO<<KoOCcQWO<<KoO'3}QWO<<KoOOQ?Mp<<Kn<<KnO'4YQpO<<KoO$(PQWO<<KnO'4aQWO<<KoO!&_Q7[O<<KoOOQO7+*n7+*nO9^QWO7+*nO'4fQWO<= mOOQUG27oG27oO9hQ?MxOG27oO!(oQ^O1G5OO'4nQWO7+,OO&7WQWOANA}OOQUANA}ANA}O!&_Q7[OANA}O'4vQWOANA}OOQUANBPANBPO9hQ?MxOANBPO$!}QWOANBPOOQO'#H['#H[OOQO7+*m7+*mOOQUG22wG22wOOQUANEYANEYOOQUANEZANEZOOQUANBXANBXO'5OQWOANBXOOQU<<MS<<MSO!(oQ^OAN?iOOQOG24vG24vO$>`Q?NdOG24vO#&wQWOLD,nOOQULD,nLD,nO!&_Q7[OLD,nO'5TQrOLD,nO'5[Q07bO7+'xO'6}Q07bO,5?]O'8}Q07bO,5?_O':}Q07bO7+'zO'<pQ7[OG27QOOQO<<My<<MyOOQ?MpANAZANAZO$(PQWOANAZOCcQWOANAZO'=QQWOANAZOOQ?MpANAYANAYO'=]QpOANAZOOQO<<NY<<NYOOQULD-ZLD-ZO'=dQ07bO7+*jOOQUG27iG27iO&7WQWOG27iO!&_Q7[OG27iOOQUG27kG27kO9hQ?MxOG27kOOQUG27sG27sO'=nQ07bOG25TOOQOLD*bLD*bOOQU!$(!Y!$(!YO#&wQWO!$(!YO!&_Q7[O!$(!YO'=xQ?NdOG27QOOQ?MpG26uG26uO$(PQWOG26uOCcQWOG26uO'@WQWOG26uOOQULD-TLD-TO&7WQWOLD-TOOQULD-VLD-VOOQU!)9Et!)9EtO#&wQWO!)9EtOOQ?MpLD,aLD,aO$(PQWOLD,aOCcQWOLD,aOOQU!$(!o!$(!oOOQU!.K;`!.K;`O'@cQ07bOG27QOOQ?Mp!$( {!$( {O$(PQWO!$( {OOQ?Mp!)9Eg!)9EgO!(oQ^O'#DwO1PQWO'#EUO'BUQrO'#JmO'B]QMnO'#DsO'BdQ^O'#D{O'BkQrO'#CiO'ERQrO'#CiO!(oQ^O'#D}O'EcQ^O,5;WO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O'#IlO'GfQWO,5<gO!(oQ^O,5;bO'GnQ7[O,5;bO'IXQ7[O,5;bO!(oQ^O,5;vO!&_Q7[O'#GjO'GnQ7[O'#GjO!&_Q7[O'#GlO'GnQ7[O'#GlO1SQWO'#DWO1SQWO'#DWO!&_Q7[O'#F}O'GnQ7[O'#F}O!&_Q7[O'#GPO'GnQ7[O'#GPO!&_Q7[O'#G_O'GnQ7[O'#G_O!(oQ^O,5:gO'I`Q`O'#D[O!(oQ^O,5@jO'EcQ^O1G0rO'IjQ07bO'#CiO!(oQ^O1G2OO!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO'ItQpO'#CrO!&_Q7[O,5<rO'GnQ7[O,5<rO'EcQ^O1G2PO!(oQ^O7+&yO!&_Q7[O1G2^O'GnQ7[O1G2^O!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO!&_Q7[O1G2`O'GnQ7[O1G2`O'EcQ^O7+'kO'EcQ^O7+&^O!&_Q7[OANAfO'GnQ7[OANAfO'JXQWO'#ElO'J^QWO'#ElO'JfQWO'#F[O'JkQWO'#EvO'JpQWO'#KOO'J{QWO'#J|O'KWQWO,5;WO'K]Q7[O,5<dO'KdQWO'#GWO'KiQWO'#GWO'KnQWO,5<eO'KvQWO,5;WO'LOQ07bO1G1_O'LVQWO,5<rO'L[QWO,5<rO'LaQWO,5<tO'LfQWO,5<tO'LkQWO1G2PO'LpQWO1G0rO'LuQ7[O<<KzO'L|Q7[O<<KzO7eQ7[O'#FzO9RQWO'#FyOAaQWO'#EkO!(oQ^O,5;sO!3SQWO'#GWO!3SQWO'#GWO!3SQWO'#GYO!3SQWO'#GYO!+hQ7[O7+(`O!+hQ7[O7+(`O%+SQpO1G2tO%+SQpO1G2tO!&_Q7[O,5=YO!&_Q7[O,5=Y",
    stateData:
      "'NQ~O'wOS'xOSTOS'yRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(OSO(QTO(TUO([VO(j[O(yiO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O'y!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'u]X([]X(m]X(t]X(u]X~O!d%PX~P(qO_!}O(Q#PO(R!}O(S#PO~O_#QO(S#PO(T#PO(U#QO~Ou#SO!R#TO(]#TO(^#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O;UO(QTO(TUO([VO(j[O(yiO~O!X#ZO!Y#WO!V(cP!V(qP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(QTO(TUO([VO(j[O(yiO~Om#mO!X#iO!y]O#f#lO#g#iO(O;VO!h(nP~P.iO!i#oO(O#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa(aX'u(aX's(aX!h(aX!V(aX![(aX%f(aX!d(aX~P1qO#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX![(bX%f(bX~Oa(bX'u(bX's(bX!V(bX!h(bXs(bX!d(bX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O$sO(QTO(TUO([$uO(t$}O(u%POg(XP~O!i%cO~O!P%fO![%gO(O%eO~O!d%kO~Oa%lO'u%lO~O}%pO~P%[O(P!lO~P%[O%k%tO~P%[Oh%VO!i%cO(O%eO(P!lO~Oe%{O!i%cO(O%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(O%eO(P!lO(QTO(TUO`)SP~O!u#sO~O%p&VO!P)OX![)OX(O)OX~O(O&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(P!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'u%lO~Oa%lO't&{O'u%lO~Oa%lO't&}O'u%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(P!lO(QTO(TUO~Op'RO!P'QO!X'UO(`'PO!Z(dP!Z(sP~P@YOk'_O![']O(O%eO~Oe'dO!i%cO(O%eO~O}&QO!i&PO~Op!nO!P!oO!y;QO#Q!pO#R!pO#T!pO#U!pO(P!lO(QTO(TUO(`!mO(j!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'u%lO(m'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(QTO(TUO(`!mO(j!sO~O![XOp(hX!P(hX!_(hX!`(hX!a(hX!y(hX#Q(hX#R(hX#S(hX#T(hX#U(hX#X(hX#Y(hX(P(hX(Q(hX(T(hX(`(hX(j(hX~O!`'iO!a'iO(P!lO~PCrO'z'uO'{'uO'|'wO~O_!}O(Q'yO(R!}O(S'yO~O_#QO(S'yO(T'yO(U#QO~Ou#SO!R#TO(]#TO(^'}O~O!X(PO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(RO!V(cX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(RO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~O!V(cX~PGfO!V(WO~O!V(pX!Y(pX!d(pX!h(pX(m(pX~O#](pX#h#aX!Z(pX~PIiO#](XO!V(rX!Y(rX~O!Y(YO!V(qX~O!V(]O~O#]$eO~PIiO!Z(^O~P`OR#zO}#yO!P#{O!i#xO([VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(m!ka(t!ka(u!ka~Oa!ka'u!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKPO!h(_O~O!d#vO#](`O(m'mO!Y(oXa(oX'u(oX~O!h(oX~PMlO!P%fO![%gO!y]O#f(eO#g(dO(O%eO~O!Y(fO!h(nX~O!h(hO~O!P%fO![%gO#g(dO(O%eO~OP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O!d#vO!h(bX~P! YOR(jO}(iO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(O!xa~P!#ZO!u(nO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#h(tO~O!X(vO!h(fP~P%[O(`(xO(j[O~O!P(zO!i#xO(`(xO(j[O~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y$_Oa$oa'u$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)`O~P!&_Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~Og(kP~P!+hO})eO!d)dO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)dO![(vX$Y(vX$[(vX$^(vX$e(vX~O})eO~P!-qO})eO![(vX$Y(vX$[(vX$^(vX$e(vX~O![)gO$Y)kO$[)fO$^)fO$e)lO~O!X)oO~P!(oO$[$hO$^$gO$e)sO~Ok$xX}$xX!P$xX#P$xX(t$xX(u$xX~OgjXg$xXkjX!YjX#]jX~P!/gOu)uO(])vO(^)xO~Ok*RO})zO!P){O(t$}O(u%PO~Og)yO~P!0kOg*SO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P*UO![*VO!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~O!X*YO(O*TO!h(zP~P!1YO#h*[O~O!i*]O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O*_O(QTO(TUO([$uO(t$}O(u%PO~O!X*bO!V({P~P!3XOo*nO!P*fO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO(`!mO~O!Z*kO~P!4|O#P$dOk(ZX}(ZX!P(ZX(t(ZX(u(ZX!Y(ZX#](ZX~Og(ZX#}(ZX~P!5uOk*sO#]*rOg(YX!Y(YX~O!Y*tOg(XX~O(O&WOg(XP~Op*wO~O!i*|O~O(O(rO~Om+QO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(O%eO!h(nP~O!d#vO#h+RO~O!P%fO!X+TO!Y(YO![%gO(O%eO!V(qP~Op'XO!P+VO!X+UO(QTO(TUO(`(xO~O!Z(sP~P!8uO!Y+WOa)PX'u)PX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa!ga!Y!ga'u!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9mOR#zO}#yO!P#{O!i#xO([VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(m!oa(t!oa(u!oa~Oa!oa'u!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<TOR#zO}#yO!P#{O!i#xO([VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(m!qa(t!qa(u!qa~Oa!qa'u!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>kOh%VOk+aO![']O%f+`O~O!d+cOa(WX![(WX'u(WX!Y(WX~Oa%lO![XO'u%lO~Oh%VO!i%cO~Oh%VO!i%cO(O%eO~O!d#vO#h(tO~Ob+nO%g+oO(O+kO(QTO(TUO!Z)TP~O!Y+pO`)SX~O[+tO~O`+uO~O![%}O(O%eO(P!lO`)SP~Oh%VO#]+zO~Oh%VOk+}O![$|O~O![,PO~O},RO![XO~O%k%tO~O!u,WO~Oe,]O~Ob,^O(O#nO(QTO(TUO!Z)RP~Oe%{O~O%g!QO(O&WO~P=RO[,cO`,bO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(QTO(TUO([VO(j[O(yiO~O![!eO!r!gO$V!kO(O!dO~P!EkO`,bOa%lO'u%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa,hO!rwO#t!OO%i!OO%j!OO%k!OO~P!HTO!i&lO~O&Y,nO~O![,pO~O&k,rO&m,sOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(O&ha(Q&ha(T&ha([&ha(j&ha(y&ha!Z&ha&a&hab&ha&f&ha~O(O,xO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# ZO!d,}O#],|Oh(eX!Y#eX!Y(eX!Z#eX!Z(eX!d(eX!i(eX~Oh%VO!d-PO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(QTO(TUO(`!mO~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(QTO(TUO([VO(j[O(y<xO~O(O;zO~P##_O!Y-TO!Z(dX~O!Z-VO~O!d,}O#],|O!Y#eX!Z#eX~O!Y-WO!Z(sX~O!Z-YO~O!`-ZO!a-ZO(P!lO~P#!|O!Z-^O~P'_Ok-aO![']O~O!V-fO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(P!xa(Q!xa(T!xa(`!xa(j!xa~P!#ZO!m-kO#]-iO~PCSO!`-mO!a-mO(P!lO~PCrOa%lO#]-iO'u%lO~Oa%lO!d#vO#]-iO'u%lO~Oa%lO!d#vO!m-kO#]-iO'u%lO(m'mO~O'z'uO'{'uO'|-rO~Os-sO~O!V'Sa!Y'Sa~P!9mO!X-wO!V'SX!Y'SX~P%[O!Y(RO!V(ca~O!V(ca~PGfO!Y(YO!V(qa~O!P%fO!X-{O![%gO(O%eO!V'YX!Y'YX~O#]-}O!Y(oa!h(oaa(oa'u(oa~O!d#vO~P#+eO!Y(fO!h(na~O!P%fO![%gO#g.RO(O%eO~Om.WO!P%fO!X.TO![%gO!y]O#f.VO#g.TO(O%eO!Y']X!h']X~OR.[O!i#xO~Oh%VOk._O![']O%f.^O~Oa#`i!Y#`i'u#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9mOk=UO})zO!P){O(t$}O(u%PO~O#h#[aa#[a#]#[a'u#[a!Y#[a!h#[a![#[a!V#[a~P#.aO#h(ZXP(ZXR(ZX[(ZXa(ZXo(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX'u(ZX([(ZX(m(ZX!h(ZX!V(ZX's(ZXs(ZX![(ZX%f(ZX!d(ZX~P!5uO!Y.lO!h(fX~P!9mO!h.oO~O!V.qO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#1|O#k$OO~P#1|OP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#4kO#o$QO~P#4kOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO([VOa#ji!Y#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO([VO(u#}Oa#ji!Y#ji#y#ji#z#ji'u#ji(m#ji(t#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#9pO#w#ji~P#9pO#u$SO~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO([VO(t#|O(u#}Oa#ji!Y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<fO#y$WO~P#<fOP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X!Y]X!Z]X~O#}]X~P#?TOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O#y;bO#z;cO([VO(m$YO(t#|O(u#}O~O#}.sO~P#AbO#P$dO#];iO$P;iO#}(bX!Z(bX~P! YOa'`a!Y'`a'u'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9mO[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO(t#ji(u#ji~P#DdOk=UO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P#DdO!Y.wOg(kX~P!0kOg.yO~Oa$Oi!Y$Oi'u$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9mO$[.zO$^.zO~O$[.{O$^.{O~O!d)dO#].|O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X.}O~O![)gO$Y/PO$[)fO$^)fO$e/QO~O!Y;dO!Z(aX~P#AbO!Z/RO~O!d)dO$e(vX~O$e/TO~Ou)uO(])vO(^/WO~O!V/[O~P!&_O(t$}Ok%^a}%^a!P%^a(u%^a!Y%^a#]%^a~Og%^a#}%^a~P#K^O(u%POk%`a}%`a!P%`a(t%`a!Y%`a#]%`a~Og%`a#}%`a~P#LPO!YfX!dfX!hfX!h$xX(mfX~P!/gO!X/eO!Y(YO(O/dO!V(qP!V({P~P!1YOo*nO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO~Op'XO!P/fO!X+UO!Z*kO(QTO(TUO(`;wO!Z(sP~P#MjO!h/gO~P#.aO!Y/hO!d#vO(m'mO!h(zX~O!h/mO~O!P%fO!X*YO![%gO(O%eO!h(zP~O#h/oO~O!V$xX!Y$xX!d%PX~P!/gO!Y/pO!V({X~P#.aO!d/rO~O!V/tO~Oh%VOo/xO!d#vO!i%cO(m'mO~O(O/zO~O!d+cO~Oa%lO!Y0OO'u%lO~O!Z0QO~P!4|O!`0RO!a0RO(P!lO(`!mO~O!P0TO(`!mO~O#X0UO~Og%^a!Y%^a#]%^a#}%^a~P!0kOg%`a!Y%`a#]%`a#}%`a~P!0kO(O&WOg'iX!Y'iX~O!Y*tOg(Xa~Og0_O~OR0`O}0`O!P0aO#P$dOkza(tza(uza!Yza#]za~Ogza#}za~P$%]O})zO!P){Ok$qa(t$qa(u$qa!Y$qa#]$qa~Og$qa#}$qa~P$&UO})zO!P){Ok$sa(t$sa(u$sa!Y$sa#]$sa~Og$sa#}$sa~P$&wO#h0dO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0kO!d#vO~O#h0gO~O!Y+WOa)Pa'u)Pa~OR#zO}#yO!P#{O!i#xO([VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(m!oi(t!oi(u!oi~Oa!oi'u!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$(fOh%VOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~Om0pO(O0oO~P$*|O!d+cOa(Wa![(Wa'u(Wa!Y(Wa~O#h0vO~O[]X!YfX!ZfX~O!Y0wO!Z)TX~O!Z0yO~O[0zO~Ob0|O(O+kO(QTO(TUO~O![%}O(O%eO`'qX!Y'qX~O!Y+pO`)Sa~O!h1PO~P!9mO[1SO~O`1TO~O#]1WO~Ok1ZO![$|O~O(`(xO!Z)QP~Oh%VOk1dO![1aO%f1cO~O[1nO!Y1lO!Z)RX~O!Z1oO~O`1qOa%lO'u%lO~O(O#nO(QTO(TUO~O#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O#s1tO&W1uOa(bX~P$0dO#]$eO#s1tO&W1uO~Oa1wO~P%[Oa1yO~O&a1|OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(O&_i(Q&_i(T&_i([&_i(j&_i(y&_i!Z&_ib&_i&f&_i~Ob2SO!Z2QO&f2RO~P`O![XO!i2UO~O&m,sOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(O&hi(Q&hi(T&hi([&hi(j&hi(y&hi!Z&hi&a&hib&hi&f&hi~O!V2[O~O!Y!^a!Z!^a~P#AbOp!nO!P!oO!X2bO(`!mO!Y'TX!Z'TX~P@YO!Y-TO!Z(da~O!Y'ZX!Z'ZX~P!8uO!Y-WO!Z(sa~O!Z2iO~P'_Oa%lO#]2rO'u%lO~Oa%lO!d#vO#]2rO'u%lO~Oa%lO!d#vO!m2vO#]2rO'u%lO(m'mO~Oa%lO'u%lO~P!9mO!Y$_Os$oa~O!V'Si!Y'Si~P!9mO!Y(RO!V(ci~O!Y(YO!V(qi~O!V(ri!Y(ri~P!9mO!Y(oi!h(oia(oi'u(oi~P!9mO#]2xO!Y(oi!h(oia(oi'u(oi~O!Y(fO!h(ni~O!P%fO![%gO!y]O#f2}O#g2|O(O%eO~O!P%fO![%gO#g2|O(O%eO~Ok3UO![']O%f3TO~Oh%VOk3UO![']O%f3TO~O#h%^aP%^aR%^a[%^aa%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K^O#h%`aP%`aR%`a[%`aa%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LPO#h%^aP%^aR%^a[%^aa%^ao%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.aO#h%`aP%`aR%`a[%`aa%`ao%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.aO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'uza([za(mza!hza!Vza'szasza![za%fza!dza~P$%]O#h$qaP$qaR$qa[$qaa$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'u$qa([$qa(m$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$&UO#h$saP$saR$sa[$saa$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'u$sa([$sa(m$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$&wO#h%RaP%RaR%Ra[%Raa%Rao%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'u%Ra([%Ra(m%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.aOa#`q!Y#`q'u#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9mO!X3^O!Y'UX!h'UX~P%[O!Y.lO!h(fa~O!Y.lO!h(fa~P!9mO!V3aO~O#}!ka!Z!ka~PKPO#}!ga!Y!ga!Z!ga~P#AbO#}!oa!Z!oa~P!<TO#}!qa!Z!qa~P!>kOg'XX!Y'XX~P!+hO!Y.wOg(ka~OSfO![3uO$c3vO~O!Z3zO~Os3{O~P#.aOa$lq!Y$lq'u$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9mO!V3|O~P#.aO})zO!P){O(u%POk'ea(t'ea!Y'ea#]'ea~Og'ea#}'ea~P%)nO})zO!P){Ok'ga(t'ga(u'ga!Y'ga#]'ga~Og'ga#}'ga~P%*aO(m$YO~P#.aO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/gO(O<QO~P!1YOmkO(O4OO~P.iO!P%fO!X4QO![%gO(O%eO!Y'aX!h'aX~O!Y/hO!h(za~O!Y/hO!d#vO!h(za~O!Y/hO!d#vO(m'mO!h(za~Og$zi!Y$zi#]$zi#}$zi~P!0kO!X4YO!V'cX!Y'cX~P!3XO!Y/pO!V({a~O!Y/pO!V({a~P#.aO!d#vO#s4bO~Oo4eO!d#vO(m'mO~O!P4hO(`!mO~O(t$}Ok%^i}%^i!P%^i(u%^i!Y%^i#]%^i~Og%^i#}%^i~P%.wO(u%POk%`i}%`i!P%`i(t%`i!Y%`i#]%`i~Og%`i#}%`i~P%/jOg(Yi!Y(Yi~P!0kO#]4mOg(Yi!Y(Yi~P!0kO!h4pO~Oa$mq!Y$mq'u$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9mO!V4tO~O!Y4uO![(|X~P#.aOa$xX![$xX%Z]X'u$xX!Y$xX~P!/gO%Z4xOalXklX}lX!PlX![lX'ulX(tlX(ulX!YlX~O%Z4xO~Ob5OO%g5PO(O+kO(QTO(TUO!Y'pX!Z'pX~O!Y0wO!Z)Ta~O[5TO~O`5UO~Oa%lO'u%lO~P#.aO![$|O~P#.aO!Y5^O#]5`O!Z)QX~O!Z5aO~Oo5hOp!nO!P5bO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5gO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O!Z5fO~P%4tOk5mO![1aO%f5lO~Oh%VOk5mO![1aO%f5lO~Ob5tO(O#nO(QTO(TUO!Y'oX!Z'oX~O!Y1lO!Z)Ra~O(QTO(TUO(`5vO~O`5zO~O#s5}O&W6OO~PMlO!h6PO~P%[Oa6RO~Oa6RO~P%[Ob2SO!Z6WO&f2RO~P`O!d6YO~O!d6[Oh(ei!Y(ei!Z(ei!d(ei!i(ei~O!Y#ei!Z#ei~P#AbO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AbOa%lO#]6fO'u%lO~Oa%lO!d#vO#]6fO'u%lO~O!Y(oq!h(oqa(oq'u(oq~P!9mO!Y(fO!h(nq~O!P%fO![%gO#g6mO(O%eO~O![']O%f6pO~Ok6tO![']O%f6pO~O#h'eaP'eaR'ea['eaa'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'u'ea(['ea(m'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%)nO#h'gaP'gaR'ga['gaa'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'u'ga(['ga(m'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%*aO#h$ziP$ziR$zi[$zia$zio$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'u$zi([$zi(m$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.aO#h%^iP%^iR%^i[%^ia%^io%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'u%^i([%^i(m%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%.wO#h%`iP%`iR%`i[%`ia%`io%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'u%`i([%`i(m%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%/jO!Y'Ua!h'Ua~P!9mO!Y.lO!h(fi~O#}#`i!Y#`i!Z#`i~P#AbOP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#k#ji~P%G^O#k;YO~P%G^OP$[OR#zOo;fO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#o#ji~P%IfO#o;[O~P%IfOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O([VO#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#u#ji~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O([VO(u#}O#y#ji#z#ji#}#ji(m#ji(t#ji!Y#ji!Z#ji~O#w;`O~P%MoO#w#ji~P%MoO#u;^O~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O([VO(t#|O(u#}O#z#ji#}#ji(m#ji!Y#ji!Z#ji~O#y#ji~P&!OO#y;bO~P&!OOa#{y!Y#{y'u#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9mO[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO(t#ji(u#ji~P&$zOk=VO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P&$zO#P$dOP(ZXR(ZX[(ZXk(ZXo(ZX}(ZX!P(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX#}(ZX([(ZX(m(ZX(t(ZX(u(ZX!Y(ZX!Z(ZX~O#}$Oi!Y$Oi!Z$Oi~P#AbO#}!oi!Z!oi~P$(fOg'Xa!Y'Xa~P!0kO!Z7WO~O!Y'`a!Z'`a~P#AbOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!d%WX#s%WX~P&+QO!d#vO(m'mO!Y'aa!h'aa~O!Y/hO!h(zi~O!Y/hO!d#vO!h(zi~Og$zq!Y$zq#]$zq#}$zq~P!0kO!V'ca!Y'ca~P#.aO!d7_O~O!Y/pO!V({i~P#.aO!Y/pO!V({i~O!V7cO~O!d#vO#s7hO~Oo7iO!d#vO(m'mO~O})zO!P){O(u%POk'fa(t'fa!Y'fa#]'fa~Og'fa#}'fa~P&/pO})zO!P){Ok'ha(t'ha(u'ha!Y'ha#]'ha~Og'ha#}'ha~P&0cO!V7lO~Og$|q!Y$|q#]$|q#}$|q~P!0kOa$my!Y$my'u$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9mO!d6[O~O!Y4uO![(|a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa([$Sa(m$Sa(t$Sa(u$Sa~O%f6pO~P&2lOa#`y!Y#`y'u#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9mO[7qO~Ob7sO(O+kO(QTO(TUO~O!Y0wO!Z)Ti~O`7wO~O(`(xO!Y'lX!Z'lX~O!Y5^O!Z)Qa~O!Z8QO~P%4tOp!nO!P8RO(QTO(TUO(`!mO(j!sO~O#X8SO~O![1aO~O![1aO%f8UO~Ok8XO![1aO%f8UO~O[8^O!Y'oa!Z'oa~O!Y1lO!Z)Ri~O!h8bO~O!h8cO~O!h8fO~O!h8fO~P%[Oa8hO~O!d8iO~O!h8jO~O!Y(ri!Z(ri~P#AbOa%lO#]8rO'u%lO~O!Y(oy!h(oya(oy'u(oy~P!9mO!Y(fO!h(ny~O%f8uO~P&2lO![']O%f8uO~O#h$zqP$zqR$zq[$zqa$zqo$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'u$zq([$zq(m$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.aO#h'faP'faR'fa['faa'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'u'fa(['fa(m'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&/pO#h'haP'haR'ha['haa'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'u'ha(['ha(m'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&0cO#h$|qP$|qR$|q[$|qa$|qo$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'u$|q([$|q(m$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.aO!Y'Ui!h'Ui~P!9mO#}#`q!Y#`q!Z#`q~P#AbO(t$}OP%^aR%^a[%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a([%^a(m%^a!Y%^a!Z%^a~Ok%^a}%^a!P%^a(u%^a~P&CoO(u%POP%`aR%`a[%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a([%`a(m%`a!Y%`a!Z%`a~Ok%`a}%`a!P%`a(t%`a~P&EsOk=VO})zO!P){O(u%PO~P&CoOk=VO})zO!P){O(t$}O~P&EsOR0`O}0`O!P0aO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za([za(mza(tza(uza!Yza!Zza~O})zO!P){OP$qaR$qa[$qak$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa([$qa(m$qa(t$qa(u$qa!Y$qa!Z$qa~O})zO!P){OP$saR$sa[$sak$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa([$sa(m$sa(t$sa(u$sa!Y$sa!Z$sa~Ok=VO})zO!P){O(t$}O(u%PO~OP%RaR%Ra[%Rao%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra([%Ra(m%Ra!Y%Ra!Z%Ra~P&NlO#}$lq!Y$lq!Z$lq~P#AbO#}$mq!Y$mq!Z$mq~P#AbO!Z9SO~O#}9TO~P!0kO!d#vO!Y'ai!h'ai~O!d#vO(m'mO!Y'ai!h'ai~O!Y/hO!h(zq~O!V'ci!Y'ci~P#.aO!Y/pO!V({q~Oo9[O!d#vO(m'mO~O!V9]O~P#.aO!V9]O~O!d#vO#s9bO~Og(Yy!Y(Yy~P!0kO!Y'ja!['ja~P#.aOa%Yq![%Yq'u%Yq!Y%Yq~P#.aO[9dO~O!Y0wO!Z)Tq~O#]9hO!Y'la!Z'la~O!Y5^O!Z)Qi~P#AbO!P4hO~O![1aO%f9lO~O(QTO(TUO(`9qO~O!Y1lO!Z)Rq~O!h9tO~O!h9uO~O!h9vO~O!h9vO~P%[O#]9yO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AbO%f:OO~P&2lO![']O%f:OO~O#}#{y!Y#{y!Z#{y~P#AbOP$ziR$zi[$zio$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi([$zi(m$zi!Y$zi!Z$zi~P&NlO})zO!P){O(u%POP'eaR'ea['eak'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(['ea(m'ea(t'ea!Y'ea!Z'ea~O})zO!P){OP'gaR'ga['gak'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(['ga(m'ga(t'ga(u'ga!Y'ga!Z'ga~O(t$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i([%^i(m%^i(u%^i!Y%^i!Z%^i~O(u%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i([%`i(m%`i(t%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AbO#}#`y!Y#`y!Z#`y~P#AbO!d#vO!Y'aq!h'aq~O!Y/hO!h(zy~O!V'cq!Y'cq~P#.aOo:YO!d#vO(m'mO~O!V:ZO~P#.aO!V:ZO~O!Y0wO!Z)Ty~O!Y5^O!Z)Qq~O![1aO%f:cO~O!h:fO~O%f:kO~P&2lOP$zqR$zq[$zqo$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq([$zq(m$zq!Y$zq!Z$zq~P&NlO})zO!P){O(u%POP'faR'fa['fak'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(['fa(m'fa(t'fa!Y'fa!Z'fa~O})zO!P){OP'haR'ha['hak'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(['ha(m'ha(t'ha(u'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q([$|q(m$|q!Y$|q!Z$|q~P&NlOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0kOo:oO!d#vO(m'mO~O!V:pO~P#.aO!Y'lq!Z'lq~P#AbO!Y#e!Z!Z#e!Z~P#AbO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'u%b!Z([%b!Z(m%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.aOo:xO!d#vO(m'mO~OP%b!ZR%b!Z[%b!Zo%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z([%b!Z(m%b!Z!Y%b!Z!Z%b!Z~P&NlOs(aX~P1qO}%pO~P!(oO(P!lO~P!(oO!VfX!YfX#]fX~P&+QOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!dfX!h]X!hfX(mfX~P'BxOP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![XO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y;dO!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;oO!P${O![$|O!f=PO!i$xO#g;uO$V%_O$r;qO$t;sO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#t)`O~P'GnOo!bX(m!bX~P# ZO!Z]X!ZfX~P'BxO!VfX!V$xX!YfX!Y$xX#]fX~P!/gO#h;XO~O!d#vO#h;XO~O#];iO~O#s;]O~O#];xO!Y(rX!Z(rX~O#];iO!Y(pX!Z(pX~O#h;yO~Og;{O~P!0kO#h<RO~O#h<SO~O!d#vO#h<TO~O!d#vO#h;yO~O#}<UO~P#AbO#h<VO~O#h<WO~O#h<]O~O#h<^O~O#h<_O~O#h<`O~O#}<aO~P!0kO#}<bO~P!0kO#P#Q#R#T#U#X#f#g#r(y$r$t$w%Z%e%f%g%n%p%s%t%v%x~'yT#l!U'w(P#mp#k#no}'x$['x(O$^(`~",
    goto: "$4Q)XPPPPPP)YPP)]P)nP+O/PPPPP5xPP6`PP<V?mP@QP@QPPP@QPBRP@QP@QP@QPBVPB[PByPGrPPPGvPPPPGvJxPPPKOKzPGvPGvPPNYGvPPPGvPGvP!!aGvP!%v!&{!'UP!'x!'|!'x!+YPPPPPPP!+y!&{PP!,Z!-gP!0jGvGv!0o!3z!8b!8b!<`PPP!<hGvPPPPPPPPPPP!?vP!ATPPGv!BfPGvPGvGvGvGvGvPGv!CxP!GRP!JWP!J[!Jf!Jj!JjP!GOP!Jn!JnP!MsP!MwGvGv!M}##RBV@QP@QP@Q@QP#$_@Q@Q#&j@Q#)Z@Q#+`@Q@Q#,O#.]#.]#.b#.k#.]#.wP#.]P@Q#/a@Q#3S@Q@Q5xPPP#6{PPP#7f#7fP#7fP#7|#7fPP#8SP#7yP#7y#8g#7y#9R#9X5u)]#9[)]P#9c#9c#9cP)]P)]P)]P)]PP)]P#9i#9lP#9l)]P#9pP#9sP)]P)]P)]P)]P)]P)])]PP#9y#:P#:[#:b#:h#:n#:t#;S#;Y#;d#;j#;t#;z#<[#<b#=S#=f#=l#=r#>Q#>g#@V#@e#@l#BR#Ba#C|#D[#Db#Dh#Dn#Dx#EO#EU#E`#Er#ExPPPPPPPPPP#FOPPPPPPP#Fs#Iz#KZ#Kb#KjPPP$!sP$!|$%t$,^$,a$,d$-P$-S$-Z$-cP$-i$-lP$.Y$.^$/U$0d$0i$1PPP$1U$1[$1`P$1c$1g$1k$2a$2x$3a$3e$3h$3k$3q$3t$3x$3|R!|RoqOXst!Z#d%k&o&q&r&t,k,p1|2PY!vQ']-]1a5eQ%rvQ%zyQ&R|Q&g!VS'T!e-TQ'c!iS'i!r!yU*e$|*V*jQ+i%{Q+v&TQ,[&aQ-Z'[Q-e'dQ-m'jQ0R*lQ1k,]R;v;T%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8rS#q];Q!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U*y%[;n;oQ+n%}Q,^&dQ,e&lQ0m+aQ0q+cQ0|+oQ1s,cQ3Q._Q5O0wQ5t1lQ6r3UQ7s5PR8x6t'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{t!nQ!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5g$|$ti#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ&U|Q'R!eU'X%g*V-WQ+n%}Q,^&dQ0c*|Q0|+oQ1R+uQ1r,bQ1s,cQ5O0wQ5X1TQ5t1lQ5w1nQ5x1qQ7s5PQ7v5UQ8a5zQ9g7wR9r8^rnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR,`&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<z<{[#]WZ#W#Z'U(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+h%z%{Q+l%}Q,V&_Q,Z&aS-d'c'dQ.a(nQ0u+iQ0{+oQ0}+pQ1Q+tQ1f,WS1j,[,]Q2n-eQ4}0wQ5R0zQ5W1SQ5s1kQ7r5PQ7u5TQ9c7qR:^9d!O$zi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R!S%wy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dQ+b%uQ+{&XQ,O&YQ,Y&aQ.`(mQ1e,VU1i,Z,[,]Q3V.aQ5n1fS5r1j1kQ8]5s#^<|#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo<};g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bW%Ti%V*t<xS&X!Q&fQ&Y!RQ&Z!SR+y&V$}%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VT)v$u)wV*y%[;n;oW'X!e%g*V-WS(y#y#zQ+]%pQ+s&QS.Y(i(jQ1[,PQ4n0`R7{5^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{$i$^c#Y#e%o%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.t.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q'V!eR2c-Tv!nQ!e!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5gU*d$|*V*jS/y*e*lQ0S*mQ1^,RQ4d0RR4g0UnqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&v!^Q's!xS(o#u;XQ+f%xQ,T&[Q,U&^Q-b'aQ-o'lS.j(t;yS0f+R<TQ0s+gQ1`,SQ2T,rQ2V,sQ2_-OQ2l-cQ2o-gS4s0g<_Q4y0tS4|0v<`Q6^2aQ6b2mQ6g2tQ7p4zQ8m6`Q8n6cQ8q6hR9x8j$d$]c#Y#e%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oS(k#p'fQ({#zS+[%o.tS.Z(j(lR3O.['OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S#q];QQ&q!XQ&r!YQ&t![Q&u!]R1{,nQ'^!hQ+_%uQ-`'`S.](m+bQ2j-_W3S.`.a0l0nQ6a2kW6n3P3R3V4wU8t6o6q6sU9}8v8w8yS:i9|:PQ:t:jR:z:uU!wQ']-]T5c1a5e!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,k,p.S1|2P]!pQ!r']-]1a5eT#q];Q%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS(y#y#zS.Y(i(j!s<f$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U$fd)Z,eS(l#p'fU*q%R(s3pU0b*x.f7PQ4w0mQ6o3QQ8w6rR:P8xm!tQ!r!v!y!z']'i'j'k-]-m1a5e5gQ'q!uS(b#g1vS-k'h'tQ/k*XQ/w*dQ2v-nQ4U/lS4_/x0SQ7Z4PS7f4e4gQ9V7[Q9Z7cQ9`7iS:X9[9]S:n:Y:ZS:w:o:pR:}:xQ#wbQ'p!uS(a#g1vS(c#m+QQ+S%dQ+d%vQ+j%|U-j'h'q'tQ.O(bQ/j*XQ/v*dQ/|*gQ0r+eQ1g,XS2s-k-nQ2{.WS4T/k/lS4^/w0SQ4a/{Q4c/}Q5p1hQ6i2vQ7Y4PQ7^4US7b4_4gQ7g4fQ8Z5qS9U7Z7[Q9Y7cQ9^7fQ9a7jQ9o8[Q:V9VS:W9Z9]Q:[9`Q:e9pS:m:X:ZS:v:n:pQ:|:wQ;O:}Q<i<dQ<t<mR<u<nV!wQ']-]%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS#wz!j!r<c$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<i<z%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dS%|z!jQ+e%wQ,X&aW1h,Y,Z,[,]U5q1i1j1kS8[5r5sQ9p8]!r<d$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q<m<yR<n<z%OeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rY#bWZ#W#Z(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ,f&l!p<e$Z$n)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<h'UU'Y!e%g*VR2e-W%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8r!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q,e&lQ0m+aQ3Q._Q6r3UR8x6t!b$Tc#Y%o(O(U(p(u)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!P;_)Y)m-R.t2]2`3b3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!f$Vc#Y%o(O(U(p(u)S)T)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!T;a)Y)m-R.t2]2`3b3h3i3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!^$Zc#Y%o(O(U(p(u)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;RQ3}/cz<{)Y)m-R.t2]2`3b3q3y6_6z7T7U7}8l8z9Q9R:`:g<oQ=Q=SR=R=T'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S$oh$pR3v.|'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$kf$qQ$ifS)f$l)jR)r$qT$jf$qT)h$l)j'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$oh$pQ$rhR)q$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8r!s<y$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{#elOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_(z)o+V+a,h,k,p-a._.}/f0a1d1t1u1w1y1|2P2R3U3u5b5m5}6O6R6t8R8X8h!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=VQ*}%`Q/Y)zo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!O$yi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=RQ*^$zU*g$|*V*jQ+O%aQ/}*h#^<k#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn<l;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bQ<p<|Q<q<}Q<r=OR<s=P!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bnoOXst!Z#d%k&o&q&r&t,k,p1|2PS*a${*UQ,y&{Q,z&}R4X/p$|%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ+|&YQ1Y,OQ5[1XR7z5]V*i$|*V*jU*i$|*V*jT5d1a5eU/{*f/f5bS4f0T8RR7j4hQ+d%vQ/|*gQ0r+eQ1g,XQ5p1hQ8Z5qQ9o8[R:e9p!O%Oi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rr)}$v)a*O*p+P/n0Z0[3s4V4q7X7k:U<j<v<wS0V*o0W#^;j#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;k;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!`;|(q)_*W*`.b.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=T`;}3o6{7O7S8{:Q:T:{S<X.d3ZT<Y6}9O!O%Qi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rv*P$v)a*Q*o+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<wS0X*p0Y#^;l#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;m;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!d<O(q)_*W*`.c.d.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=Td<P3o6|6}7S8{8|:Q:R:T:{S<Z.e3[T<[7O9PrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ&c!UR,h&lrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR&c!UQ,Q&ZR1U+ysnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ1b,VS5k1e1fU8T5i5j5nS9k8V8WS:a9j9mQ:q:bR:y:rQ&j!VR,a&fR5w1nS&O|&TR0}+pQ&o!WR,k&pR,q&uT1},p2PR,u&vQ,t&vR2W,uQ'v!{R-q'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)w$uR/V)wQ#UVR'|#UQ#XWU(S#X(T-xQ(T#YR-x(UQ-U'VR2d-UQ.m(uS3_.m3`R3`.nQ-]']R2h-]Y!rQ']-]1a5eR'g!rQ.x)aR3t.xU#_W%f*UU(Z#_([-yQ([#`R-y(VQ-X'YR2f-Xt`OXst!V!Z#d%k&f&h&o&q&r&t,k,p1|2PS#hZ%cU#r`#h.SR.S(fQ(g#jQ.P(cW.X(g.P2y6kQ2y.QR6k2zQ)j$lR/O)jQ$phR)p$pQ$`cU)]$`-t;eQ-t;RR;e)mQ/i*XW4R/i4S7]9WU4S/j/k/lS7]4T4UR9W7^$Z)|$v(q)_)a*W*`*o*p*z*{+P.d.e.g.h.i/U/Z/_/a/c/n/s0Z0[0k1V1X3W3X3Y3o3s4V4W4[4i4k4q5Z5]6u6v6w6x6}7O7Q7R7S7X7`7d7k7m7o8{8|8}9X9_:Q:R:S:T:U:]:l:{<j<v<w=S=TQ/q*`U4Z/q4]7aQ4]/sR7a4[S*j$|*VR0P*jr*O$v)a*o*p+P/n0Z0[3s4V4q7X7k:U<j<v<w!`.b(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=TU/`*O.b6{a6{3o6}7O7S8{:Q:T:{Q0W*oQ3Z.dU4j0W3Z9OR9O6}v*Q$v)a*o*p+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<w!d.c(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=TU/b*Q.c6|e6|3o6}7O7S8{8|:Q:R:T:{Q0Y*pQ3[.eU4l0Y3[9PR9P7OQ*u%UR0^*uQ4v0kR7n4vQ+X%iR0j+XQ5_1[S7|5_9iR9i7}Q,S&[R1_,SQ5e1aR8P5eQ1m,^S5u1m8_R8_5wQ0x+lW5Q0x5S7t9eQ5S0{Q7t5RR9e7uQ+q&OR1O+qQ2P,pR6V2PYrOXst#dQ&s!ZQ+Z%kQ,j&oQ,l&qQ,m&rQ,o&tQ1z,kS1},p2PR6U1|Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Y%jQ+f%xQ+x&UQ,`&jQ,w&yW-h'h'p'q'tQ-o'lQ0O*iQ0s+gS1p,a,dQ2X,vQ2Y,yQ2Z,zQ2o-gW2q-j-k-n-pQ4y0tQ5V1RQ5Y1VQ5o1gQ5y1rQ6T1{U6d2p2s2vQ6g2tQ7p4zQ7x5XQ7y5ZQ8O5dQ8Y5pQ8`5xS8o6e6iQ8q6hQ9f7vQ9n8ZQ9s8aQ9z8pQ:_9gQ:d9oQ:h9{R:s:eQ%xyQ'a!iQ'l!uU+g%y%z%{Q-O'SU-c'b'c'dS-g'h'rQ/u*dS0t+h+iQ2a-QS2m-d-eQ2t-lQ4`/yQ4z0uQ6`2gQ6c2nQ6h2uR7e4dS$wi<xR*v%VU%Ui%V<xR0]*tQ$viS(q#v+cS)_$b$cQ)a$dQ*W$xS*`${*UQ*o%OQ*p%QQ*z%]Q*{%^Q+P%bQ.d;jQ.e;lQ.g;pQ.h;rQ.i;tQ/U)uS/Z){/]Q/_)}Q/a*PQ/c*RQ/n*[S/s*b/eQ0Z*rQ0[*sh0k+`.^1c3T5l6p8U8u9l:O:c:kQ1V+zQ1X+}Q3W;|Q3X<OQ3Y<RS3o;g;hQ3s.wQ4V/oQ4W/pQ4[/rQ4i0VQ4k0XQ4q0dQ5Z1WQ5]1ZQ6u<VQ6v<XQ6w<ZQ6x<]Q6};kQ7O;mQ7Q;qQ7R;sQ7S;uQ7X3}Q7`4YQ7d4bQ7k4mQ7m4uQ7o4xQ8{<SQ8|;}Q8}<PQ9X7_Q9_7hQ:Q<WQ:R<YQ:S<[Q:T<^Q:U9TQ:]9bQ:l<aQ:{<bQ<j<xQ<v=QQ<w=RQ=S=UR=T=VQ*x%[Q.f;nR7P;onpOXst!Z#d%k&o&q&r&t,k,p1|2PQ!fPS#fZ#oQ&y!`U'e!o5b8RQ'{#SQ(|#{Q)n$nS,d&h&kQ,i&lQ,v&xQ,{'QQ-_'_Q.p(zQ/S)oS0h+V/fQ0n+aQ1x,hQ2k-aQ3R._Q3x.}Q4o0aQ5j1dQ5{1tQ5|1uQ6Q1wQ6S1yQ6X2RQ6s3UQ7V3uQ8W5mQ8d5}Q8e6OQ8g6RQ8y6tQ9m8XR9w8h#YcOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_(z+V+a,h,k,p-a._/f0a1d1t1u1w1y1|2P2R3U5b5m5}6O6R6t8R8X8hQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)Y$ZQ)[$_Q)^$aQ)c$eW)m$n)o.}3uQ+^%rQ+r&PS-R'U2bQ-p'oS-u(P-wQ-z(XQ-|(`Q.k(tQ.n(vQ.r;PQ.t;SQ.u;TQ.v;WQ/X)yQ0e+RQ2],|Q2`-PQ2p-iQ2w-}Q3].lQ3b;XQ3c;YQ3d;ZQ3e;[Q3f;]Q3g;^Q3h;_Q3i;`Q3j;aQ3k;bQ3l;cQ3m.sQ3n;fQ3q;iQ3r;vQ3y;dQ4r0gQ4{0vQ6_;xQ6e2rQ6j2xQ6y3^Q6z;yQ7T;{Q7U<TQ7}5`Q8l6]Q8p6fQ8z<UQ9Q<_Q9R<`Q9{8rQ:`9hQ:g9yQ;R#SR<o<{R#[WR'W!el!tQ!r!v!y!z']'i'j'k-]-m1a5e5gS'S!e-TS-Q'T'[R2g-ZR(w#xQ!fQT-[']-]]!qQ!r']-]1a5eQ#p]R'f;QR)b$dY!uQ']-]1a5eQ'h!rS'r!v!yS't!z5gS-l'i'jQ-n'kR2u-mT#kZ%cS#jZ%cS%im,gU(c#h#i#lS.Q(d(eQ.U(fQ0i+WQ2z.RU2{.S.T.VS6l2|2}R8s6md#^W#W#Z%f(P(Y*U+T-{/er#gZm#h#i#l%c(d(e(f+W.R.S.T.V2|2}6mS*X$x*]Q/l*YQ1v,gQ2^,}Q4P/hQ6Z2UQ7[4QQ8k6[T<g'U+UV#aW%f*UU#`W%f*US(Q#W(YU(V#Z+T/eS-S'U+UT-v(P-{V'Z!e%g*VQ$lfR)t$qT)i$l)jR3w.|T*Z$x*]T*c${*UQ0l+`Q3P.^Q5i1cQ6q3TQ8V5lQ8v6pQ9j8UQ9|8uQ:b9lQ:j:OQ:r:cR:u:knqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&i!VR,`&ftmOXst!U!V!Z#d%k&f&o&q&r&t,k,p1|2PR,g&lT%jm,gR1],PR,_&dQ&S|R+w&TR+m%}T&m!W&pT&n!W&pT2O,p2P",
    nodeNames:
      "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
    maxTerm: 376,
    context: Dle,
    nodeProps: [
      ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
      [
        "group",
        -26,
        9,
        17,
        19,
        65,
        204,
        208,
        212,
        213,
        215,
        218,
        221,
        231,
        233,
        239,
        241,
        243,
        245,
        248,
        254,
        260,
        262,
        264,
        266,
        268,
        270,
        271,
        "Statement",
        -34,
        13,
        14,
        29,
        32,
        33,
        39,
        48,
        51,
        52,
        54,
        59,
        67,
        69,
        73,
        77,
        79,
        81,
        82,
        107,
        108,
        117,
        118,
        135,
        138,
        140,
        141,
        142,
        143,
        144,
        146,
        147,
        166,
        167,
        169,
        "Expression",
        -23,
        28,
        30,
        34,
        38,
        40,
        42,
        171,
        173,
        175,
        176,
        178,
        179,
        180,
        182,
        183,
        184,
        186,
        187,
        188,
        198,
        200,
        202,
        203,
        "Type",
        -3,
        85,
        100,
        106,
        "ClassItem",
      ],
      ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
      ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"],
    ],
    propSources: [Zle],
    skippedNodes: [0, 5, 6, 274],
    repeatNodeCount: 37,
    tokenData:
      "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Rp(U!b'w0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(S#S$h&j'x0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Rp(U!b'x0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(Q':f$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(U!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Rp(U!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Rp(U!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(U!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(U!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(RpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(RpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Rp(U!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(j%1l(Rp(U!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Rp(U!b$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Rp(U!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Rp(U!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(u+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(T';W$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(RpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Rp(U!b(P%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Rp(U!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Rp(U!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Rp(U!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Rp(U!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(U!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(U!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(U!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(U!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(U!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(U!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Rp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Rp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Rp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Rp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(RpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(RpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Rp(U!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Rp(U!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Rp(U!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Rp(U!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Rp(U!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Rp(U!b'y0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Rp(U!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(U!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(U!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(RpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(RpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Rp(U!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Rp(U!b(y7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(m(Ct$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Rp(U!b([+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Rp(U!b(O,2j$^#t(`$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Rp(U!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(t+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z(Kd$?V_!Z(Cds`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Rp(U!b'w0/l$[#t(O,2j(`$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Rp(U!b'x0/l$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
    tokenizers: [
      Ble,
      Vle,
      jle,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      Fle,
      new Sp(
        "$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(^~~",
        141,
        335
      ),
      new Sp("j~RQYZXz{^~^O'{~~aP!P!Qd~iO'|~~", 25, 318),
    ],
    topRules: { Script: [0, 7], SingleExpression: [1, 272], SingleClassItem: [2, 273] },
    dialects: { jsx: 0, ts: 14725 },
    dynamicPrecedences: { 77: 1, 79: 1, 91: 1, 167: 1, 196: 1 },
    specialized: [
      { term: 322, get: (t) => zle[t] || -1 },
      { term: 338, get: (t) => Wle[t] || -1 },
      { term: 92, get: (t) => Xle[t] || -1 },
    ],
    tokenPrec: 14749,
  }),
  aw = [
    Qn("function ${name}(${params}) {\n	${}\n}", { label: "function", detail: "definition", type: "keyword" }),
    Qn("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", { label: "for", detail: "loop", type: "keyword" }),
    Qn("for (let ${name} of ${collection}) {\n	${}\n}", { label: "for", detail: "of loop", type: "keyword" }),
    Qn("do {\n	${}\n} while (${})", { label: "do", detail: "loop", type: "keyword" }),
    Qn("while (${}) {\n	${}\n}", { label: "while", detail: "loop", type: "keyword" }),
    Qn(
      `try {
	\${}
} catch (\${error}) {
	\${}
}`,
      { label: "try", detail: "/ catch block", type: "keyword" }
    ),
    Qn("if (${}) {\n	${}\n}", { label: "if", detail: "block", type: "keyword" }),
    Qn(
      `if (\${}) {
	\${}
} else {
	\${}
}`,
      { label: "if", detail: "/ else block", type: "keyword" }
    ),
    Qn(
      `class \${name} {
	constructor(\${params}) {
		\${}
	}
}`,
      { label: "class", detail: "definition", type: "keyword" }
    ),
    Qn('import {${names}} from "${module}"\n${}', { label: "import", detail: "named", type: "keyword" }),
    Qn('import ${name} from "${module}"\n${}', { label: "import", detail: "default", type: "keyword" }),
  ],
  HR = aw.concat([
    Qn("interface ${name} {\n	${}\n}", { label: "interface", detail: "definition", type: "keyword" }),
    Qn("type ${name} = ${type}", { label: "type", detail: "definition", type: "keyword" }),
    Qn("enum ${name} {\n	${}\n}", { label: "enum", detail: "definition", type: "keyword" }),
  ]),
  A_ = new o4(),
  qR = new Set(["Script", "Block", "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration", "ForStatement"]);
function uc(t) {
  return (e, n) => {
    let r = e.node.getChild("VariableDefinition");
    return r && n(r, t), !0;
  };
}
const Hle = ["FunctionDeclaration"],
  qle = {
    FunctionDeclaration: uc("function"),
    ClassDeclaration: uc("class"),
    ClassExpression: () => !0,
    EnumDeclaration: uc("constant"),
    TypeAliasDeclaration: uc("type"),
    NamespaceDeclaration: uc("namespace"),
    VariableDefinition(t, e) {
      t.matchContext(Hle) || e(t, "variable");
    },
    TypeDefinition(t, e) {
      e(t, "type");
    },
    __proto__: null,
  };
function YR(t, e) {
  let n = A_.get(e);
  if (n) return n;
  let r = [],
    i = !0;
  function o(s, l) {
    let a = t.sliceString(s.from, s.to);
    r.push({ label: a, type: l });
  }
  return (
    e.cursor(vt.IncludeAnonymous).iterate((s) => {
      if (i) i = !1;
      else if (s.name) {
        let l = qle[s.name];
        if ((l && l(s, o)) || qR.has(s.name)) return !1;
      } else if (s.to - s.from > 8192) {
        for (let l of YR(t, s.node)) r.push(l);
        return !1;
      }
    }),
    A_.set(e, r),
    r
  );
}
const _p = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,
  cw = [
    "TemplateString",
    "String",
    "RegExp",
    "LineComment",
    "BlockComment",
    "VariableDefinition",
    "TypeDefinition",
    "Label",
    "PropertyDefinition",
    "PropertyName",
    "PrivatePropertyDefinition",
    "PrivatePropertyName",
    ".",
    "?.",
  ];
function GR(t) {
  let e = at(t.state).resolveInner(t.pos, -1);
  if (cw.indexOf(e.name) > -1) return null;
  let n = e.name == "VariableName" || (e.to - e.from < 20 && _p.test(t.state.sliceDoc(e.from, e.to)));
  if (!n && !t.explicit) return null;
  let r = [];
  for (let i = e; i; i = i.parent) qR.has(i.name) && (r = r.concat(YR(t.state.doc, i)));
  return { options: r, from: n ? e.from : t.pos, validFor: _p };
}
function R1(t, e, n) {
  var r;
  let i = [];
  for (;;) {
    let o = e.firstChild,
      s;
    if ((o == null ? void 0 : o.name) == "VariableName") return i.push(t(o)), { path: i.reverse(), name: n };
    if (
      (o == null ? void 0 : o.name) == "MemberExpression" &&
      ((r = s = o.lastChild) === null || r === void 0 ? void 0 : r.name) == "PropertyName"
    )
      i.push(t(s)), (e = o);
    else return null;
  }
}
function JR(t) {
  let e = (r) => t.state.doc.sliceString(r.from, r.to),
    n = at(t.state).resolveInner(t.pos, -1);
  return n.name == "PropertyName"
    ? R1(e, n.parent, e(n))
    : (n.name == "." || n.name == "?.") && n.parent.name == "MemberExpression"
    ? R1(e, n.parent, "")
    : cw.indexOf(n.name) > -1
    ? null
    : n.name == "VariableName" || (n.to - n.from < 20 && _p.test(e(n)))
    ? { path: [], name: e(n) }
    : n.name == "MemberExpression"
    ? R1(e, n, "")
    : t.explicit
    ? { path: [], name: "" }
    : null;
}
function Yle(t, e) {
  let n = [],
    r = new Set();
  for (let i = 0; ; i++) {
    for (let s of (Object.getOwnPropertyNames || Object.keys)(t)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(s) || r.has(s)) continue;
      r.add(s);
      let l;
      try {
        l = t[s];
      } catch {
        continue;
      }
      n.push({
        label: s,
        type: typeof l == "function" ? (/^[A-Z]/.test(s) ? "class" : e ? "function" : "method") : e ? "variable" : "property",
        boost: -i,
      });
    }
    let o = Object.getPrototypeOf(t);
    if (!o) return n;
    t = o;
  }
}
function Gle(t) {
  let e = new Map();
  return (n) => {
    let r = JR(n);
    if (!r) return null;
    let i = t;
    for (let s of r.path) if (((i = i[s]), !i)) return null;
    let o = e.get(i);
    return o || e.set(i, (o = Yle(i, !r.path.length))), { from: n.pos - r.name.length, options: o, validFor: _p };
  };
}
const vr = oa.define({
    name: "javascript",
    parser: Ule.configure({
      props: [
        Ih.add({
          IfStatement: cf({ except: /^\s*({|else\b)/ }),
          TryStatement: cf({ except: /^\s*({|catch\b|finally\b)/ }),
          LabeledStatement: gre,
          SwitchBody: (t) => {
            let e = t.textAfter,
              n = /^\s*\}/.test(e),
              r = /^\s*(case|default)\b/.test(e);
            return t.baseIndent + (n ? 0 : r ? 1 : 2) * t.unit;
          },
          Block: mre({ closing: "}" }),
          ArrowFunction: (t) => t.baseIndent + t.unit,
          "TemplateString BlockComment": () => null,
          "Statement Property": cf({ except: /^{/ }),
          JSXElement(t) {
            let e = /^\s*<\//.test(t.textAfter);
            return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
          },
          JSXEscape(t) {
            let e = /\s*\}/.test(t.textAfter);
            return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
          },
          "JSXOpenTag JSXSelfClosingTag"(t) {
            return t.column(t.node.from) + t.unit;
          },
        }),
        Ba.add({
          "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": m4,
          BlockComment(t) {
            return { from: t.from + 2, to: t.to - 2 };
          },
        }),
      ],
    }),
    languageData: {
      closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
      wordChars: "$",
    },
  }),
  KR = { test: (t) => /^JSX/.test(t.name), facet: eg({ commentTokens: { block: { open: "{/*", close: "*/}" } } }) },
  uw = vr.configure({ dialect: "ts" }, "typescript"),
  hw = vr.configure({ dialect: "jsx", props: [By.add((t) => (t.isTop ? [KR] : void 0))] }),
  dw = vr.configure({ dialect: "jsx ts", props: [By.add((t) => (t.isTop ? [KR] : void 0))] }, "typescript");
let e6 = (t) => ({ label: t, type: "keyword" });
const t6 =
    "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield"
      .split(" ")
      .map(e6),
  Jle = t6.concat(["declare", "implements", "private", "protected", "public"].map(e6));
function Ep(t = {}) {
  let e = t.jsx ? (t.typescript ? dw : hw) : t.typescript ? uw : vr,
    n = t.typescript ? HR.concat(Jle) : aw.concat(t6);
  return new la(e, [vr.data.of({ autocomplete: Gre(cw, M4(n)) }), vr.data.of({ autocomplete: GR }), t.jsx ? n6 : []]);
}
function Kle(t) {
  for (;;) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag") return t;
    if (t.name == "JSXEscape" || !t.parent) return null;
    t = t.parent;
  }
}
function $_(t, e, n = t.length) {
  for (let r = e == null ? void 0 : e.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return t.sliceString(r.from, Math.min(r.to, n));
  return "";
}
const eae = typeof navigator == "object" && /Android\b/.test(navigator.userAgent),
  n6 = re.inputHandler.of((t, e, n, r, i) => {
    if (
      (eae ? t.composing : t.compositionStarted) ||
      t.state.readOnly ||
      e != n ||
      (r != ">" && r != "/") ||
      !vr.isActiveAt(t.state, e, -1)
    )
      return !1;
    let o = i(),
      { state: s } = o,
      l = s.changeByRange((a) => {
        var c;
        let { head: u } = a,
          h = at(s).resolveInner(u - 1, -1),
          d;
        if (
          (h.name == "JSXStartTag" && (h = h.parent), !(s.doc.sliceString(u - 1, u) != r || (h.name == "JSXAttributeValue" && h.to > u)))
        ) {
          if (r == ">" && h.name == "JSXFragmentTag") return { range: a, changes: { from: u, insert: "</>" } };
          if (r == "/" && h.name == "JSXStartCloseTag") {
            let f = h.parent,
              p = f.parent;
            if (
              p &&
              f.from == u - 2 &&
              ((d = $_(s.doc, p.firstChild, u)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")
            ) {
              let m = `${d}>`;
              return { range: H.cursor(u + m.length, -1), changes: { from: u, insert: m } };
            }
          } else if (r == ">") {
            let f = Kle(h);
            if (f && f.name == "JSXOpenTag" && !/^\/?>|^<\//.test(s.doc.sliceString(u, u + 2)) && (d = $_(s.doc, f, u)))
              return { range: a, changes: { from: u, insert: `</${d}>` } };
          }
        }
        return { range: a };
      });
    return l.changes.empty ? !1 : (t.dispatch([o, s.update(l, { userEvent: "input.complete", scrollIntoView: !0 })]), !0);
  });
function tae(t, e) {
  return (
    e ||
      ((e = {
        parserOptions: { ecmaVersion: 2019, sourceType: "module" },
        env: { browser: !0, node: !0, es6: !0, es2015: !0, es2017: !0, es2020: !0 },
        rules: {},
      }),
      t.getRules().forEach((n, r) => {
        n.meta.docs.recommended && (e.rules[r] = 2);
      })),
    (n) => {
      let { state: r } = n,
        i = [];
      for (let { from: o, to: s } of vr.findRegions(r)) {
        let l = r.doc.lineAt(o),
          a = { line: l.number - 1, col: o - l.from, pos: o };
        for (let c of t.verify(r.sliceDoc(o, s), e)) i.push(nae(c, r.doc, a));
      }
      return i;
    }
  );
}
function R_(t, e, n, r) {
  return n.line(t + r.line).from + e + (t == 1 ? r.col - 1 : -1);
}
function nae(t, e, n) {
  let r = R_(t.line, t.column, e, n),
    i = {
      from: r,
      to: t.endLine != null && t.endColumn != 1 ? R_(t.endLine, t.endColumn, e, n) : r,
      message: t.message,
      source: t.ruleId ? "eslint:" + t.ruleId : "eslint",
      severity: t.severity == 1 ? "warning" : "error",
    };
  if (t.fix) {
    let { range: o, text: s } = t.fix,
      l = o[0] + n.pos - r,
      a = o[1] + n.pos - r;
    i.actions = [
      {
        name: "fix",
        apply(c, u) {
          c.dispatch({ changes: { from: u + l, to: u + a, insert: s }, scrollIntoView: !0 });
        },
      },
    ];
  }
  return i;
}
const Cd = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        autoCloseTags: n6,
        completionPath: JR,
        esLint: tae,
        javascript: Ep,
        javascriptLanguage: vr,
        jsxLanguage: hw,
        localCompletionSource: GR,
        scopeCompletionSource: Gle,
        snippets: aw,
        tsxLanguage: dw,
        typescriptLanguage: uw,
        typescriptSnippets: HR,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  hc = ["_blank", "_self", "_top", "_parent"],
  I1 = ["ascii", "utf-8", "utf-16", "latin1", "latin1"],
  M1 = ["get", "post", "put", "delete"],
  L1 = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
  Yn = ["true", "false"],
  ke = {},
  rae = {
    a: { attrs: { href: null, ping: null, type: null, media: null, target: hc, hreflang: null } },
    abbr: ke,
    address: ke,
    area: {
      attrs: {
        alt: null,
        coords: null,
        href: null,
        target: null,
        ping: null,
        media: null,
        hreflang: null,
        type: null,
        shape: ["default", "rect", "circle", "poly"],
      },
    },
    article: ke,
    aside: ke,
    audio: {
      attrs: {
        src: null,
        mediagroup: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["none", "metadata", "auto"],
        autoplay: ["autoplay"],
        loop: ["loop"],
        controls: ["controls"],
      },
    },
    b: ke,
    base: { attrs: { href: null, target: hc } },
    bdi: ke,
    bdo: ke,
    blockquote: { attrs: { cite: null } },
    body: ke,
    br: ke,
    button: {
      attrs: {
        form: null,
        formaction: null,
        name: null,
        value: null,
        autofocus: ["autofocus"],
        disabled: ["autofocus"],
        formenctype: L1,
        formmethod: M1,
        formnovalidate: ["novalidate"],
        formtarget: hc,
        type: ["submit", "reset", "button"],
      },
    },
    canvas: { attrs: { width: null, height: null } },
    caption: ke,
    center: ke,
    cite: ke,
    code: ke,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
      attrs: {
        type: ["command", "checkbox", "radio"],
        label: null,
        icon: null,
        radiogroup: null,
        command: null,
        title: null,
        disabled: ["disabled"],
        checked: ["checked"],
      },
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: ke,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: ke,
    div: ke,
    dl: ke,
    dt: ke,
    em: ke,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: ke,
    figure: ke,
    footer: ke,
    form: {
      attrs: {
        action: null,
        name: null,
        "accept-charset": I1,
        autocomplete: ["on", "off"],
        enctype: L1,
        method: M1,
        novalidate: ["novalidate"],
        target: hc,
      },
    },
    h1: ke,
    h2: ke,
    h3: ke,
    h4: ke,
    h5: ke,
    h6: ke,
    head: { children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"] },
    header: ke,
    hgroup: ke,
    hr: ke,
    html: { attrs: { manifest: null } },
    i: ke,
    iframe: {
      attrs: {
        src: null,
        srcdoc: null,
        name: null,
        width: null,
        height: null,
        sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
        seamless: ["seamless"],
      },
    },
    img: {
      attrs: { alt: null, src: null, ismap: null, usemap: null, width: null, height: null, crossorigin: ["anonymous", "use-credentials"] },
    },
    input: {
      attrs: {
        alt: null,
        dirname: null,
        form: null,
        formaction: null,
        height: null,
        list: null,
        max: null,
        maxlength: null,
        min: null,
        name: null,
        pattern: null,
        placeholder: null,
        size: null,
        src: null,
        step: null,
        value: null,
        width: null,
        accept: ["audio/*", "video/*", "image/*"],
        autocomplete: ["on", "off"],
        autofocus: ["autofocus"],
        checked: ["checked"],
        disabled: ["disabled"],
        formenctype: L1,
        formmethod: M1,
        formnovalidate: ["novalidate"],
        formtarget: hc,
        multiple: ["multiple"],
        readonly: ["readonly"],
        required: ["required"],
        type: [
          "hidden",
          "text",
          "search",
          "tel",
          "url",
          "email",
          "password",
          "datetime",
          "date",
          "month",
          "week",
          "time",
          "datetime-local",
          "number",
          "range",
          "color",
          "checkbox",
          "radio",
          "file",
          "submit",
          "image",
          "reset",
          "button",
        ],
      },
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: ke,
    keygen: { attrs: { challenge: null, form: null, name: null, autofocus: ["autofocus"], disabled: ["disabled"], keytype: ["RSA"] } },
    label: { attrs: { for: null, form: null } },
    legend: ke,
    li: { attrs: { value: null } },
    link: { attrs: { href: null, type: null, hreflang: null, media: null, sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"] } },
    map: { attrs: { name: null } },
    mark: ke,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
      attrs: {
        content: null,
        charset: I1,
        name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
        "http-equiv": ["content-language", "content-type", "default-style", "refresh"],
      },
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: ke,
    noscript: ke,
    object: {
      attrs: { data: null, type: null, name: null, usemap: null, form: null, width: null, height: null, typemustmatch: ["typemustmatch"] },
    },
    ol: {
      attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
      children: ["li", "script", "template", "ul", "ol"],
    },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: ke,
    param: { attrs: { name: null, value: null } },
    pre: ke,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: ke,
    rt: ke,
    ruby: ke,
    samp: ke,
    script: { attrs: { type: ["text/javascript"], src: null, async: ["async"], defer: ["defer"], charset: I1 } },
    section: ke,
    select: { attrs: { form: null, name: null, size: null, autofocus: ["autofocus"], disabled: ["disabled"], multiple: ["multiple"] } },
    slot: { attrs: { name: null } },
    small: ke,
    source: { attrs: { src: null, type: null, media: null } },
    span: ke,
    strong: ke,
    style: { attrs: { type: ["text/css"], media: null, scoped: null } },
    sub: ke,
    summary: ke,
    sup: ke,
    table: ke,
    tbody: ke,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: ke,
    textarea: {
      attrs: {
        dirname: null,
        form: null,
        maxlength: null,
        name: null,
        placeholder: null,
        rows: null,
        cols: null,
        autofocus: ["autofocus"],
        disabled: ["disabled"],
        readonly: ["readonly"],
        required: ["required"],
        wrap: ["soft", "hard"],
      },
    },
    tfoot: ke,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: ke,
    time: { attrs: { datetime: null } },
    title: ke,
    tr: ke,
    track: {
      attrs: {
        src: null,
        label: null,
        default: null,
        kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
        srclang: null,
      },
    },
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: ke,
    video: {
      attrs: {
        src: null,
        poster: null,
        width: null,
        height: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["auto", "metadata", "none"],
        autoplay: ["autoplay"],
        mediagroup: ["movie"],
        muted: ["muted"],
        controls: ["controls"],
      },
    },
    wbr: ke,
  },
  r6 = {
    accesskey: null,
    class: null,
    contenteditable: Yn,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Yn,
    autocorrect: Yn,
    autocapitalize: Yn,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    rel: [
      "stylesheet",
      "alternate",
      "author",
      "bookmark",
      "help",
      "license",
      "next",
      "nofollow",
      "noreferrer",
      "prefetch",
      "prev",
      "search",
      "tag",
    ],
    role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(
      " "
    ),
    "aria-activedescendant": null,
    "aria-atomic": Yn,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Yn,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Yn,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Yn,
    "aria-hidden": Yn,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Yn,
    "aria-multiselectable": Yn,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Yn,
    "aria-relevant": null,
    "aria-required": Yn,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null,
  },
  i6 =
    "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload"
      .split(" ")
      .map((t) => "on" + t);
for (let t of i6) r6[t] = null;
class Mu {
  constructor(e, n) {
    (this.tags = Object.assign(Object.assign({}, rae), e)),
      (this.globalAttrs = Object.assign(Object.assign({}, r6), n)),
      (this.allTags = Object.keys(this.tags)),
      (this.globalAttrNames = Object.keys(this.globalAttrs));
  }
}
Mu.default = new Mu();
function ca(t, e, n = t.length) {
  if (!e) return "";
  let r = e.firstChild,
    i = r && r.getChild("TagName");
  return i ? t.sliceString(i.from, Math.min(i.to, n)) : "";
}
function ua(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e) e = !1;
      else return t;
  return null;
}
function o6(t, e, n) {
  let r = n.tags[ca(t, ua(e))];
  return (r == null ? void 0 : r.children) || n.allTags;
}
function fw(t, e) {
  let n = [];
  for (let r = ua(e); r && !r.type.isTop; r = ua(r.parent)) {
    let i = ca(t, r);
    if (i && r.lastChild.name == "CloseTag") break;
    i && n.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= r.firstChild.to) && n.push(i);
  }
  return n;
}
const s6 = /^[:\-\.\w\u00b7-\uffff]*$/;
function I_(t, e, n, r, i) {
  let o = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">",
    s = ua(n, !0);
  return {
    from: r,
    to: i,
    options: o6(t.doc, s, e)
      .map((l) => ({ label: l, type: "type" }))
      .concat(fw(t.doc, n).map((l, a) => ({ label: "/" + l, apply: "/" + l + o, type: "type", boost: 99 - a }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/,
  };
}
function M_(t, e, n, r) {
  let i = /\s*>/.test(t.sliceDoc(r, r + 5)) ? "" : ">";
  return { from: n, to: r, options: fw(t.doc, e).map((o, s) => ({ label: o, apply: o + i, type: "type", boost: 99 - s })), validFor: s6 };
}
function iae(t, e, n, r) {
  let i = [],
    o = 0;
  for (let s of o6(t.doc, n, e)) i.push({ label: "<" + s, type: "type" });
  for (let s of fw(t.doc, n)) i.push({ label: "</" + s + ">", type: "type", boost: 99 - o++ });
  return { from: r, to: r, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function oae(t, e, n, r, i) {
  let o = ua(n),
    s = o ? e.tags[ca(t.doc, o)] : null,
    l = s && s.attrs ? Object.keys(s.attrs) : [],
    a = s && s.globalAttrs === !1 ? l : l.length ? l.concat(e.globalAttrNames) : e.globalAttrNames;
  return { from: r, to: i, options: a.map((c) => ({ label: c, type: "property" })), validFor: s6 };
}
function sae(t, e, n, r, i) {
  var o;
  let s = (o = n.parent) === null || o === void 0 ? void 0 : o.getChild("AttributeName"),
    l = [],
    a;
  if (s) {
    let c = t.sliceDoc(s.from, s.to),
      u = e.globalAttrs[c];
    if (!u) {
      let h = ua(n),
        d = h ? e.tags[ca(t.doc, h)] : null;
      u = (d == null ? void 0 : d.attrs) && d.attrs[c];
    }
    if (u) {
      let h = t.sliceDoc(r, i).toLowerCase(),
        d = '"',
        f = '"';
      /^['"]/.test(h)
        ? ((a = h[0] == '"' ? /^[^"]*$/ : /^[^']*$/), (d = ""), (f = t.sliceDoc(i, i + 1) == h[0] ? "" : h[0]), (h = h.slice(1)), r++)
        : (a = /^[^\s<>='"]*$/);
      for (let p of u) l.push({ label: p, apply: d + p + f, type: "constant" });
    }
  }
  return { from: r, to: i, options: l, validFor: a };
}
function l6(t, e) {
  let { state: n, pos: r } = e,
    i = at(n).resolveInner(r, -1),
    o = i.resolve(r);
  for (let s = r, l; o == i && (l = i.childBefore(s)); ) {
    let a = l.lastChild;
    if (!a || !a.type.isError || a.from < a.to) break;
    (o = i = l), (s = a.from);
  }
  return i.name == "TagName"
    ? i.parent && /CloseTag$/.test(i.parent.name)
      ? M_(n, i, i.from, r)
      : I_(n, t, i, i.from, r)
    : i.name == "StartTag"
    ? I_(n, t, i, r, r)
    : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag"
    ? M_(n, i, r, r)
    : i.name == "OpenTag" || i.name == "SelfClosingTag" || i.name == "AttributeName"
    ? oae(n, t, i, i.name == "AttributeName" ? i.from : r, r)
    : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue"
    ? sae(n, t, i, i.name == "Is" ? r : i.from, r)
    : e.explicit && (o.name == "Element" || o.name == "Text" || o.name == "Document")
    ? iae(n, t, i, r)
    : null;
}
function a6(t) {
  return l6(Mu.default, t);
}
function c6(t) {
  let { extraTags: e, extraGlobalAttributes: n } = t,
    r = n || e ? new Mu(e, n) : Mu.default;
  return (i) => l6(r, i);
}
const lae = vr.parser.configure({ top: "SingleExpression" }),
  u6 = [
    { tag: "script", attrs: (t) => t.type == "text/typescript" || t.lang == "ts", parser: uw.parser },
    { tag: "script", attrs: (t) => t.type == "text/babel" || t.type == "text/jsx", parser: hw.parser },
    { tag: "script", attrs: (t) => t.type == "text/typescript-jsx", parser: dw.parser },
    {
      tag: "script",
      attrs(t) {
        return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
      },
      parser: lae,
    },
    {
      tag: "script",
      attrs(t) {
        return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
      },
      parser: vr.parser,
    },
    {
      tag: "style",
      attrs(t) {
        return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
      },
      parser: Iu.parser,
    },
  ],
  h6 = [{ name: "style", parser: Iu.parser.configure({ top: "Styles" }) }].concat(i6.map((t) => ({ name: t, parser: vr.parser }))),
  pw = oa.define({
    name: "html",
    parser: ble.configure({
      props: [
        Ih.add({
          Element(t) {
            let e = /^(\s*)(<\/)?/.exec(t.textAfter);
            return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
          },
          "OpenTag CloseTag SelfClosingTag"(t) {
            return t.column(t.node.from) + t.unit;
          },
          Document(t) {
            if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to) return t.continue();
            let e = null,
              n;
            for (let r = t.node; ; ) {
              let i = r.lastChild;
              if (!i || i.name != "Element" || i.to != r.to) break;
              e = r = i;
            }
            return e && !((n = e.lastChild) && (n.name == "CloseTag" || n.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
          },
        }),
        Ba.add({
          Element(t) {
            let e = t.firstChild,
              n = t.lastChild;
            return !e || e.name != "OpenTag" ? null : { from: e.to, to: n.name == "CloseTag" ? n.from : t.to };
          },
        }),
        E4.add({ "OpenTag CloseTag": (t) => t.getChild("TagName") }),
      ],
    }),
    languageData: { commentTokens: { block: { open: "<!--", close: "-->" } }, indentOnInput: /^\s*<\/\w+\W$/, wordChars: "-._" },
  }),
  Wc = pw.configure({ wrap: XR(u6, h6) });
function mw(t = {}) {
  let e = "",
    n;
  t.matchClosingTags === !1 && (e = "noMatch"),
    t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"),
    ((t.nestedLanguages && t.nestedLanguages.length) || (t.nestedAttributes && t.nestedAttributes.length)) &&
      (n = XR((t.nestedLanguages || []).concat(u6), (t.nestedAttributes || []).concat(h6)));
  let r = n ? pw.configure({ wrap: n, dialect: e }) : e ? Wc.configure({ dialect: e }) : Wc;
  return new la(r, [Wc.data.of({ autocomplete: c6(t) }), t.autoCloseTags !== !1 ? d6 : [], Ep().support, ow().support]);
}
const L_ = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")),
  d6 = re.inputHandler.of((t, e, n, r, i) => {
    if (t.composing || t.state.readOnly || e != n || (r != ">" && r != "/") || !Wc.isActiveAt(t.state, e, -1)) return !1;
    let o = i(),
      { state: s } = o,
      l = s.changeByRange((a) => {
        var c, u, h;
        let d = s.doc.sliceString(a.from - 1, a.to) == r,
          { head: f } = a,
          p = at(s).resolveInner(f, -1),
          m;
        if (d && r == ">" && p.name == "EndTag") {
          let O = p.parent;
          if (
            ((u = (c = O.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || u === void 0 ? void 0 : u.name) !=
              "CloseTag" &&
            (m = ca(s.doc, O.parent, f)) &&
            !L_.has(m)
          ) {
            let v = f + (s.doc.sliceString(f, f + 1) === ">" ? 1 : 0),
              g = `</${m}>`;
            return { range: a, changes: { from: f, to: v, insert: g } };
          }
        } else if (d && r == "/" && p.name == "IncompleteCloseTag") {
          let O = p.parent;
          if (
            p.from == f - 2 &&
            ((h = O.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" &&
            (m = ca(s.doc, O, f)) &&
            !L_.has(m)
          ) {
            let v = f + (s.doc.sliceString(f, f + 1) === ">" ? 1 : 0),
              g = `${m}>`;
            return { range: H.cursor(f + g.length, -1), changes: { from: f, to: v, insert: g } };
          }
        }
        return { range: a };
      });
    return l.changes.empty ? !1 : (t.dispatch([o, s.update(l, { userEvent: "input.complete", scrollIntoView: !0 })]), !0);
  }),
  aae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        autoCloseTags: d6,
        html: mw,
        htmlCompletionSource: a6,
        htmlCompletionSourceWith: c6,
        htmlLanguage: Wc,
        htmlPlain: pw,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
var N_ = (function () {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      (i.enumerable = i.enumerable || !1), (i.configurable = !0), "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  return function (e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
})();
function cae(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
var so = [
    [
      { color: "0, 0, 0", class: "ansi-black" },
      { color: "187, 0, 0", class: "ansi-red" },
      { color: "0, 187, 0", class: "ansi-green" },
      { color: "187, 187, 0", class: "ansi-yellow" },
      { color: "0, 0, 187", class: "ansi-blue" },
      { color: "187, 0, 187", class: "ansi-magenta" },
      { color: "0, 187, 187", class: "ansi-cyan" },
      { color: "255,255,255", class: "ansi-white" },
    ],
    [
      { color: "85, 85, 85", class: "ansi-bright-black" },
      { color: "255, 85, 85", class: "ansi-bright-red" },
      { color: "0, 255, 0", class: "ansi-bright-green" },
      { color: "255, 255, 85", class: "ansi-bright-yellow" },
      { color: "85, 85, 255", class: "ansi-bright-blue" },
      { color: "255, 85, 255", class: "ansi-bright-magenta" },
      { color: "85, 255, 255", class: "ansi-bright-cyan" },
      { color: "255, 255, 255", class: "ansi-bright-white" },
    ],
  ],
  uae = (function () {
    N_(t, null, [
      {
        key: "escapeForHtml",
        value: function (n) {
          return new t().escapeForHtml(n);
        },
      },
      {
        key: "linkify",
        value: function (n) {
          return new t().linkify(n);
        },
      },
      {
        key: "ansiToHtml",
        value: function (n, r) {
          return new t().ansiToHtml(n, r);
        },
      },
      {
        key: "ansiToJson",
        value: function (n, r) {
          return new t().ansiToJson(n, r);
        },
      },
      {
        key: "ansiToText",
        value: function (n) {
          return new t().ansiToText(n);
        },
      },
    ]);
    function t() {
      cae(this, t), (this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null), (this.bright = 0), (this.decorations = []);
    }
    return (
      N_(t, [
        {
          key: "setupPalette",
          value: function () {
            this.PALETTE_COLORS = [];
            for (var n = 0; n < 2; ++n) for (var r = 0; r < 8; ++r) this.PALETTE_COLORS.push(so[n][r].color);
            for (
              var i = [0, 95, 135, 175, 215, 255],
                o = function (d, f, p) {
                  return i[d] + ", " + i[f] + ", " + i[p];
                },
                s = 0;
              s < 6;
              ++s
            )
              for (var l = 0; l < 6; ++l) for (var a = 0; a < 6; ++a) this.PALETTE_COLORS.push(o(s, l, a));
            for (var c = 8, u = 0; u < 24; ++u, c += 10) this.PALETTE_COLORS.push(o(c, c, c));
          },
        },
        {
          key: "escapeForHtml",
          value: function (n) {
            return n.replace(/[&<>\"]/gm, function (r) {
              return r == "&" ? "&amp;" : r == '"' ? "&quot;" : r == "<" ? "&lt;" : r == ">" ? "&gt;" : "";
            });
          },
        },
        {
          key: "linkify",
          value: function (n) {
            return n.replace(/(https?:\/\/[^\s]+)/gm, function (r) {
              return '<a href="' + r + '">' + r + "</a>";
            });
          },
        },
        {
          key: "ansiToHtml",
          value: function (n, r) {
            return this.process(n, r, !0);
          },
        },
        {
          key: "ansiToJson",
          value: function (n, r) {
            return (r = r || {}), (r.json = !0), (r.clearLine = !1), this.process(n, r, !0);
          },
        },
        {
          key: "ansiToText",
          value: function (n) {
            return this.process(n, {}, !1);
          },
        },
        {
          key: "process",
          value: function (n, r, i) {
            var o = this,
              s = this,
              l = n.split(/\033\[/),
              a = l.shift();
            r == null && (r = {}), (r.clearLine = /\r/.test(n));
            var c = l.map(function (h) {
              return o.processChunk(h, r, i);
            });
            if (r && r.json) {
              var u = s.processChunkJson("");
              return (
                (u.content = a),
                (u.clearLine = r.clearLine),
                c.unshift(u),
                r.remove_empty &&
                  (c = c.filter(function (h) {
                    return !h.isEmpty();
                  })),
                c
              );
            } else c.unshift(a);
            return c.join("");
          },
        },
        {
          key: "processChunkJson",
          value: function (n, r, i) {
            r = typeof r > "u" ? {} : r;
            var o = (r.use_classes = typeof r.use_classes < "u" && r.use_classes),
              s = (r.key = o ? "class" : "color"),
              l = {
                content: n,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                isInverted: !1,
                clearLine: r.clearLine,
                decoration: null,
                decorations: [],
                was_processed: !1,
                isEmpty: function () {
                  return !l.content;
                },
              },
              a = n.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
            if (!a) return l;
            l.content = a[4];
            var c = a[2].split(";");
            if (a[1] !== "" || a[3] !== "m" || !i) return l;
            for (var u = this; c.length > 0; ) {
              var h = c.shift(),
                d = parseInt(h);
              if (isNaN(d) || d === 0) (u.fg = u.bg = null), (u.decorations = []);
              else if (d === 1) u.decorations.push("bold");
              else if (d === 2) u.decorations.push("dim");
              else if (d === 3) u.decorations.push("italic");
              else if (d === 4) u.decorations.push("underline");
              else if (d === 5) u.decorations.push("blink");
              else if (d === 7) u.decorations.push("reverse");
              else if (d === 8) u.decorations.push("hidden");
              else if (d === 9) u.decorations.push("strikethrough");
              else if (d === 21) u.removeDecoration("bold");
              else if (d === 22) u.removeDecoration("bold"), u.removeDecoration("dim");
              else if (d === 23) u.removeDecoration("italic");
              else if (d === 24) u.removeDecoration("underline");
              else if (d === 25) u.removeDecoration("blink");
              else if (d === 27) u.removeDecoration("reverse");
              else if (d === 28) u.removeDecoration("hidden");
              else if (d === 29) u.removeDecoration("strikethrough");
              else if (d === 39) u.fg = null;
              else if (d === 49) u.bg = null;
              else if (d >= 30 && d < 38) u.fg = so[0][d % 10][s];
              else if (d >= 90 && d < 98) u.fg = so[1][d % 10][s];
              else if (d >= 40 && d < 48) u.bg = so[0][d % 10][s];
              else if (d >= 100 && d < 108) u.bg = so[1][d % 10][s];
              else if (d === 38 || d === 48) {
                var f = d === 38;
                if (c.length >= 1) {
                  var p = c.shift();
                  if (p === "5" && c.length >= 1) {
                    var m = parseInt(c.shift());
                    if (m >= 0 && m <= 255)
                      if (!o)
                        this.PALETTE_COLORS || u.setupPalette(), f ? (u.fg = this.PALETTE_COLORS[m]) : (u.bg = this.PALETTE_COLORS[m]);
                      else {
                        var O = m >= 16 ? "ansi-palette-" + m : so[m > 7 ? 1 : 0][m % 8].class;
                        f ? (u.fg = O) : (u.bg = O);
                      }
                  } else if (p === "2" && c.length >= 3) {
                    var v = parseInt(c.shift()),
                      g = parseInt(c.shift()),
                      b = parseInt(c.shift());
                    if (v >= 0 && v <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                      var x = v + ", " + g + ", " + b;
                      o
                        ? f
                          ? ((u.fg = "ansi-truecolor"), (u.fg_truecolor = x))
                          : ((u.bg = "ansi-truecolor"), (u.bg_truecolor = x))
                        : f
                        ? (u.fg = x)
                        : (u.bg = x);
                    }
                  }
                }
              }
            }
            return (
              (u.fg === null && u.bg === null && u.decorations.length === 0) ||
                ((l.fg = u.fg),
                (l.bg = u.bg),
                (l.fg_truecolor = u.fg_truecolor),
                (l.bg_truecolor = u.bg_truecolor),
                (l.decorations = u.decorations),
                (l.decoration = u.decorations.slice(-1).pop() || null),
                (l.was_processed = !0)),
              l
            );
          },
        },
        {
          key: "processChunk",
          value: function (n, r, i) {
            var o = this;
            r = r || {};
            var s = this.processChunkJson(n, r, i),
              l = r.use_classes;
            if (
              ((s.decorations = s.decorations.filter(function (f) {
                if (f === "reverse") {
                  s.fg || (s.fg = so[0][7][l ? "class" : "color"]), s.bg || (s.bg = so[0][0][l ? "class" : "color"]);
                  var p = s.fg;
                  (s.fg = s.bg), (s.bg = p);
                  var m = s.fg_truecolor;
                  return (s.fg_truecolor = s.bg_truecolor), (s.bg_truecolor = m), (s.isInverted = !0), !1;
                }
                return !0;
              })),
              r.json)
            )
              return s;
            if (s.isEmpty()) return "";
            if (!s.was_processed) return s.content;
            var a = [],
              c = [],
              u = [],
              h = {},
              d = function (p) {
                var m = [],
                  O = void 0;
                for (O in p) p.hasOwnProperty(O) && m.push("data-" + O + '="' + o.escapeForHtml(p[O]) + '"');
                return m.length > 0 ? " " + m.join(" ") : "";
              };
            return (
              s.isInverted && (h["ansi-is-inverted"] = "true"),
              s.fg &&
                (l
                  ? (a.push(s.fg + "-fg"), s.fg_truecolor !== null && ((h["ansi-truecolor-fg"] = s.fg_truecolor), (s.fg_truecolor = null)))
                  : a.push("color:rgb(" + s.fg + ")")),
              s.bg &&
                (l
                  ? (a.push(s.bg + "-bg"), s.bg_truecolor !== null && ((h["ansi-truecolor-bg"] = s.bg_truecolor), (s.bg_truecolor = null)))
                  : a.push("background-color:rgb(" + s.bg + ")")),
              s.decorations.forEach(function (f) {
                if (l) {
                  c.push("ansi-" + f);
                  return;
                }
                f === "bold"
                  ? c.push("font-weight:bold")
                  : f === "dim"
                  ? c.push("opacity:0.5")
                  : f === "italic"
                  ? c.push("font-style:italic")
                  : f === "hidden"
                  ? c.push("visibility:hidden")
                  : f === "strikethrough"
                  ? u.push("line-through")
                  : u.push(f);
              }),
              u.length && c.push("text-decoration:" + u.join(" ")),
              l
                ? '<span class="' + a.concat(c).join(" ") + '"' + d(h) + ">" + s.content + "</span>"
                : '<span style="' + a.concat(c).join(";") + '"' + d(h) + ">" + s.content + "</span>"
            );
          },
        },
        {
          key: "removeDecoration",
          value: function (n) {
            var r = this.decorations.indexOf(n);
            r >= 0 && this.decorations.splice(r, 1);
          },
        },
      ]),
      t
    );
  })(),
  hae = uae;
const dae = Vp(hae);
var gw = { exports: {} };
function Ow(t) {
  if (!t) return "";
  if (!/\r/.test(t)) return t;
  for (
    t = t.replace(
      /\r+\n/gm,
      `
`
    );
    /\r./.test(t);

  )
    t = t.replace(/^([^\r\n]*)\r+([^\r\n]+)/gm, function (e, n, r) {
      return r + n.slice(r.length);
    });
  return t;
}
function fae(t) {
  for (var e = 0, n = 0; n < t.length; n++) t[e].length <= t[n].length && (e = n);
  return e;
}
function Q_(t) {
  if (!/\r/.test(t)) return t;
  for (var e = t.split("\r"), n = []; e.length > 0; ) {
    var r = fae(e);
    n.push(e[r]), (e = e.slice(r + 1));
  }
  return n.join("\r");
}
function pae(t) {
  if (!t) return "";
  if (!/\r/.test(t)) return t;
  if (!/\n/.test(t)) return Q_(t);
  t = t.replace(
    /\r+\n/gm,
    `
`
  );
  var e = t.lastIndexOf(`
`);
  return (
    Ow(t.slice(0, e)) +
    `
` +
    Q_(t.slice(e + 1))
  );
}
gw.exports = Ow;
var mae = (gw.exports.escapeCarriageReturn = Ow);
gw.exports.escapeCarriageReturnSafe = pae;
var vw = { exports: {} };
vw.exports;
(function (t) {
  var e = (function () {
    var n = String.fromCharCode,
      r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
      o = {};
    function s(a, c) {
      if (!o[a]) {
        o[a] = {};
        for (var u = 0; u < a.length; u++) o[a][a.charAt(u)] = u;
      }
      return o[a][c];
    }
    var l = {
      compressToBase64: function (a) {
        if (a == null) return "";
        var c = l._compress(a, 6, function (u) {
          return r.charAt(u);
        });
        switch (c.length % 4) {
          default:
          case 0:
            return c;
          case 1:
            return c + "===";
          case 2:
            return c + "==";
          case 3:
            return c + "=";
        }
      },
      decompressFromBase64: function (a) {
        return a == null
          ? ""
          : a == ""
          ? null
          : l._decompress(a.length, 32, function (c) {
              return s(r, a.charAt(c));
            });
      },
      compressToUTF16: function (a) {
        return a == null
          ? ""
          : l._compress(a, 15, function (c) {
              return n(c + 32);
            }) + " ";
      },
      decompressFromUTF16: function (a) {
        return a == null
          ? ""
          : a == ""
          ? null
          : l._decompress(a.length, 16384, function (c) {
              return a.charCodeAt(c) - 32;
            });
      },
      compressToUint8Array: function (a) {
        for (var c = l.compress(a), u = new Uint8Array(c.length * 2), h = 0, d = c.length; h < d; h++) {
          var f = c.charCodeAt(h);
          (u[h * 2] = f >>> 8), (u[h * 2 + 1] = f % 256);
        }
        return u;
      },
      decompressFromUint8Array: function (a) {
        if (a == null) return l.decompress(a);
        for (var c = new Array(a.length / 2), u = 0, h = c.length; u < h; u++) c[u] = a[u * 2] * 256 + a[u * 2 + 1];
        var d = [];
        return (
          c.forEach(function (f) {
            d.push(n(f));
          }),
          l.decompress(d.join(""))
        );
      },
      compressToEncodedURIComponent: function (a) {
        return a == null
          ? ""
          : l._compress(a, 6, function (c) {
              return i.charAt(c);
            });
      },
      decompressFromEncodedURIComponent: function (a) {
        return a == null
          ? ""
          : a == ""
          ? null
          : ((a = a.replace(/ /g, "+")),
            l._decompress(a.length, 32, function (c) {
              return s(i, a.charAt(c));
            }));
      },
      compress: function (a) {
        return l._compress(a, 16, function (c) {
          return n(c);
        });
      },
      _compress: function (a, c, u) {
        if (a == null) return "";
        var h,
          d,
          f = {},
          p = {},
          m = "",
          O = "",
          v = "",
          g = 2,
          b = 3,
          x = 2,
          k = [],
          w = 0,
          y = 0,
          C;
        for (C = 0; C < a.length; C += 1)
          if (
            ((m = a.charAt(C)),
            Object.prototype.hasOwnProperty.call(f, m) || ((f[m] = b++), (p[m] = !0)),
            (O = v + m),
            Object.prototype.hasOwnProperty.call(f, O))
          )
            v = O;
          else {
            if (Object.prototype.hasOwnProperty.call(p, v)) {
              if (v.charCodeAt(0) < 256) {
                for (h = 0; h < x; h++) (w = w << 1), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++;
                for (d = v.charCodeAt(0), h = 0; h < 8; h++)
                  (w = (w << 1) | (d & 1)), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = d >> 1);
              } else {
                for (d = 1, h = 0; h < x; h++) (w = (w << 1) | d), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = 0);
                for (d = v.charCodeAt(0), h = 0; h < 16; h++)
                  (w = (w << 1) | (d & 1)), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = d >> 1);
              }
              g--, g == 0 && ((g = Math.pow(2, x)), x++), delete p[v];
            } else
              for (d = f[v], h = 0; h < x; h++) (w = (w << 1) | (d & 1)), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = d >> 1);
            g--, g == 0 && ((g = Math.pow(2, x)), x++), (f[O] = b++), (v = String(m));
          }
        if (v !== "") {
          if (Object.prototype.hasOwnProperty.call(p, v)) {
            if (v.charCodeAt(0) < 256) {
              for (h = 0; h < x; h++) (w = w << 1), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++;
              for (d = v.charCodeAt(0), h = 0; h < 8; h++)
                (w = (w << 1) | (d & 1)), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = d >> 1);
            } else {
              for (d = 1, h = 0; h < x; h++) (w = (w << 1) | d), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = 0);
              for (d = v.charCodeAt(0), h = 0; h < 16; h++)
                (w = (w << 1) | (d & 1)), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = d >> 1);
            }
            g--, g == 0 && ((g = Math.pow(2, x)), x++), delete p[v];
          } else
            for (d = f[v], h = 0; h < x; h++) (w = (w << 1) | (d & 1)), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = d >> 1);
          g--, g == 0 && ((g = Math.pow(2, x)), x++);
        }
        for (d = 2, h = 0; h < x; h++) (w = (w << 1) | (d & 1)), y == c - 1 ? ((y = 0), k.push(u(w)), (w = 0)) : y++, (d = d >> 1);
        for (;;)
          if (((w = w << 1), y == c - 1)) {
            k.push(u(w));
            break;
          } else y++;
        return k.join("");
      },
      decompress: function (a) {
        return a == null
          ? ""
          : a == ""
          ? null
          : l._decompress(a.length, 32768, function (c) {
              return a.charCodeAt(c);
            });
      },
      _decompress: function (a, c, u) {
        var h = [],
          d = 4,
          f = 4,
          p = 3,
          m = "",
          O = [],
          v,
          g,
          b,
          x,
          k,
          w,
          y,
          C = { val: u(0), position: c, index: 1 };
        for (v = 0; v < 3; v += 1) h[v] = v;
        for (b = 0, k = Math.pow(2, 2), w = 1; w != k; )
          (x = C.val & C.position),
            (C.position >>= 1),
            C.position == 0 && ((C.position = c), (C.val = u(C.index++))),
            (b |= (x > 0 ? 1 : 0) * w),
            (w <<= 1);
        switch (b) {
          case 0:
            for (b = 0, k = Math.pow(2, 8), w = 1; w != k; )
              (x = C.val & C.position),
                (C.position >>= 1),
                C.position == 0 && ((C.position = c), (C.val = u(C.index++))),
                (b |= (x > 0 ? 1 : 0) * w),
                (w <<= 1);
            y = n(b);
            break;
          case 1:
            for (b = 0, k = Math.pow(2, 16), w = 1; w != k; )
              (x = C.val & C.position),
                (C.position >>= 1),
                C.position == 0 && ((C.position = c), (C.val = u(C.index++))),
                (b |= (x > 0 ? 1 : 0) * w),
                (w <<= 1);
            y = n(b);
            break;
          case 2:
            return "";
        }
        for (h[3] = y, g = y, O.push(y); ; ) {
          if (C.index > a) return "";
          for (b = 0, k = Math.pow(2, p), w = 1; w != k; )
            (x = C.val & C.position),
              (C.position >>= 1),
              C.position == 0 && ((C.position = c), (C.val = u(C.index++))),
              (b |= (x > 0 ? 1 : 0) * w),
              (w <<= 1);
          switch ((y = b)) {
            case 0:
              for (b = 0, k = Math.pow(2, 8), w = 1; w != k; )
                (x = C.val & C.position),
                  (C.position >>= 1),
                  C.position == 0 && ((C.position = c), (C.val = u(C.index++))),
                  (b |= (x > 0 ? 1 : 0) * w),
                  (w <<= 1);
              (h[f++] = n(b)), (y = f - 1), d--;
              break;
            case 1:
              for (b = 0, k = Math.pow(2, 16), w = 1; w != k; )
                (x = C.val & C.position),
                  (C.position >>= 1),
                  C.position == 0 && ((C.position = c), (C.val = u(C.index++))),
                  (b |= (x > 0 ? 1 : 0) * w),
                  (w <<= 1);
              (h[f++] = n(b)), (y = f - 1), d--;
              break;
            case 2:
              return O.join("");
          }
          if ((d == 0 && ((d = Math.pow(2, p)), p++), h[y])) m = h[y];
          else if (y === f) m = g + g.charAt(0);
          else return null;
          O.push(m), (h[f++] = g + m.charAt(0)), d--, (g = m), d == 0 && ((d = Math.pow(2, p)), p++);
        }
      },
    };
    return l;
  })();
  t != null
    ? (t.exports = e)
    : typeof angular < "u" &&
      angular != null &&
      angular.module("LZString", []).factory("LZString", function () {
        return e;
      });
})(vw);
var gae = vw.exports;
const Oae = Vp(gae);
var Z = function () {
  return (
    (Z =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
        }
        return e;
      }),
    Z.apply(this, arguments)
  );
};
function Wt(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function Ec(t, e, n, r) {
  function i(o) {
    return o instanceof n
      ? o
      : new n(function (s) {
          s(o);
        });
  }
  return new (n || (n = Promise))(function (o, s) {
    function l(u) {
      try {
        c(r.next(u));
      } catch (h) {
        s(h);
      }
    }
    function a(u) {
      try {
        c(r.throw(u));
      } catch (h) {
        s(h);
      }
    }
    function c(u) {
      u.done ? o(u.value) : i(u.value).then(l, a);
    }
    c((r = r.apply(t, e || [])).next());
  });
}
function Tc(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (o[0] & 1) throw o[1];
        return o[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    o,
    s;
  return (
    (s = { next: l(0), throw: l(1), return: l(2) }),
    typeof Symbol == "function" &&
      (s[Symbol.iterator] = function () {
        return this;
      }),
    s
  );
  function l(c) {
    return function (u) {
      return a([c, u]);
    };
  }
  function a(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (
          ((r = 1),
          i && (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, c[1])).done)
        )
          return o;
        switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
          case 0:
          case 1:
            o = c;
            break;
          case 4:
            return n.label++, { value: c[1], done: !1 };
          case 5:
            n.label++, (i = c[1]), (c = [0]);
            continue;
          case 7:
            (c = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
              n = 0;
              continue;
            }
            if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
              n.label = c[1];
              break;
            }
            if (c[0] === 6 && n.label < o[1]) {
              (n.label = o[1]), (o = c);
              break;
            }
            if (o && n.label < o[2]) {
              (n.label = o[2]), n.ops.push(c);
              break;
            }
            o[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        c = e.call(t, n);
      } catch (u) {
        (c = [6, u]), (i = 0);
      } finally {
        r = o = 0;
      }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function mn(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, o; r < i; r++) (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), (o[r] = e[r]));
  return t.concat(o || Array.prototype.slice.call(e));
}
var Hr = function (t) {
    return T.jsx(
      "svg",
      Z({ fill: "currentColor", height: "16", viewBox: "0 0 16 16", width: "16", xmlns: "http://www.w3.org/2000/svg" }, t)
    );
  },
  vae = function () {
    return T.jsxs(Hr, {
      viewBox: "0 0 48 48",
      children: [
        T.jsx("title", { children: "Sign in" }),
        T.jsx("path", {
          d: "M9 42q-1.2 0-2.1-.9Q6 40.2 6 39V9q0-1.2.9-2.1Q7.8 6 9 6h14.55v3H9v30h14.55v3Zm24.3-9.25-2.15-2.15 5.1-5.1h-17.5v-3h17.4l-5.1-5.1 2.15-2.15 8.8 8.8Z",
        }),
      ],
    });
  },
  bae = function () {
    return T.jsxs(Hr, {
      viewBox: "0 0 48 48",
      children: [
        T.jsx("title", { children: "Sign out" }),
        T.jsx("path", {
          d: "M9 42q-1.2 0-2.1-.9Q6 40.2 6 39V9q0-1.2.9-2.1Q7.8 6 9 6h14.55v3H9v30h14.55v3Zm24.3-9.25-2.15-2.15 5.1-5.1h-17.5v-3h17.4l-5.1-5.1 2.15-2.15 8.8 8.8Z",
        }),
      ],
    });
  },
  ag = function () {
    return T.jsxs(Hr, {
      fill: "none",
      stroke: "currentColor",
      children: [
        T.jsx("title", { children: "Restart script" }),
        T.jsx("path", { d: "M8 2C4.68629 2 2 4.68629 2 8C2 10.0946 3.07333 11.9385 4.7 13.0118", strokeLinecap: "round" }),
        T.jsx("path", { d: "M14.0005 7.9998C14.0005 5.82095 12.8391 3.91335 11.1016 2.8623", strokeLinecap: "round" }),
        T.jsx("path", { d: "M14.0003 2.3335H11.167C10.8908 2.3335 10.667 2.55735 10.667 2.8335V5.66683", strokeLinecap: "round" }),
        T.jsx("path", {
          d: "M1.99967 13.6665L4.83301 13.6665C5.10915 13.6665 5.33301 13.4426 5.33301 13.1665L5.33301 10.3332",
          strokeLinecap: "round",
        }),
        T.jsx("path", { d: "M10 10L12 12L10 14", strokeLinecap: "round", strokeLinejoin: "round" }),
        T.jsx("path", { d: "M14.667 14L12.667 14", strokeLinecap: "round", strokeLinejoin: "round" }),
      ],
    });
  },
  xae = function () {
    return T.jsxs(Hr, {
      children: [
        T.jsx("title", { children: "Run sandbox" }),
        T.jsx("path", {
          d: "M11.0792 8.1078C11.2793 8.25007 11.27 8.55012 11.0616 8.67981L6.02535 11.8135C5.79638 11.956 5.5 11.7913 5.5 11.5216L5.5 8.40703L5.5 4.80661C5.5 4.52735 5.81537 4.36463 6.04296 4.52647L11.0792 8.1078Z",
        }),
      ],
    });
  },
  yae = function () {
    return T.jsxs(Hr, {
      children: [
        T.jsx("title", { children: "Click to go back" }),
        T.jsx("path", {
          d: "M9.64645 12.3536C9.84171 12.5488 10.1583 12.5488 10.3536 12.3536C10.5488 12.1583 10.5488 11.8417 10.3536 11.6464L9.64645 12.3536ZM10.3536 4.35355C10.5488 4.15829 10.5488 3.84171 10.3536 3.64644C10.1583 3.45118 9.84171 3.45118 9.64645 3.64644L10.3536 4.35355ZM6.07072 7.92929L5.71716 7.57573L6.07072 7.92929ZM10.3536 11.6464L6.42427 7.71716L5.71716 8.42426L9.64645 12.3536L10.3536 11.6464ZM6.42427 8.28284L10.3536 4.35355L9.64645 3.64644L5.71716 7.57573L6.42427 8.28284ZM6.42427 7.71716C6.58048 7.87337 6.58048 8.12663 6.42427 8.28284L5.71716 7.57573C5.48285 7.81005 5.48285 8.18995 5.71716 8.42426L6.42427 7.71716Z",
        }),
      ],
    });
  },
  wae = function () {
    return T.jsxs(Hr, {
      children: [
        T.jsx("title", { children: "Click to go forward" }),
        T.jsx("path", {
          d: "M6.35355 3.64645C6.15829 3.45118 5.84171 3.45118 5.64645 3.64645C5.45118 3.84171 5.45118 4.15829 5.64645 4.35355L6.35355 3.64645ZM5.64645 11.6464C5.45118 11.8417 5.45118 12.1583 5.64645 12.3536C5.84171 12.5488 6.15829 12.5488 6.35355 12.3536L5.64645 11.6464ZM9.92929 8.07071L10.2828 8.42426L9.92929 8.07071ZM5.64645 4.35355L9.57574 8.28284L10.2828 7.57574L6.35355 3.64645L5.64645 4.35355ZM9.57574 7.71716L5.64645 11.6464L6.35355 12.3536L10.2828 8.42426L9.57574 7.71716ZM9.57574 8.28284C9.41952 8.12663 9.41953 7.87337 9.57574 7.71716L10.2828 8.42426C10.5172 8.18995 10.5172 7.81005 10.2828 7.57574L9.57574 8.28284Z",
        }),
      ],
    });
  },
  f6 = function () {
    return T.jsxs(Hr, {
      children: [
        T.jsx("title", { children: "Refresh preview" }),
        T.jsx("path", {
          clipRule: "evenodd",
          d: "M3.83325 7.99992C3.83325 5.69867 5.69853 3.83325 7.99934 3.83325C9.81246 3.83325 11.3563 4.99195 11.9285 6.61097C11.9396 6.6425 11.9536 6.67221 11.97 6.69992H8.80005C8.52391 6.69992 8.30005 6.92378 8.30005 7.19992C8.30005 7.47606 8.52391 7.69992 8.80005 7.69992H12.5667C12.8981 7.69992 13.1667 7.43129 13.1667 7.09992V3.33325C13.1667 3.05711 12.9429 2.83325 12.6667 2.83325C12.3906 2.83325 12.1667 3.05711 12.1667 3.33325V4.94608C11.2268 3.66522 9.7106 2.83325 7.99934 2.83325C5.14613 2.83325 2.83325 5.14651 2.83325 7.99992C2.83325 10.8533 5.14613 13.1666 7.99934 13.1666C9.91218 13.1666 11.5815 12.1266 12.474 10.5836C12.6123 10.3446 12.5306 10.0387 12.2915 9.90044C12.0525 9.76218 11.7466 9.84387 11.6084 10.0829C10.8873 11.3296 9.54072 12.1666 7.99934 12.1666C5.69853 12.1666 3.83325 10.3012 3.83325 7.99992Z",
          fillRule: "evenodd",
        }),
      ],
    });
  },
  Sae = function () {
    return T.jsxs(Hr, {
      fill: "none",
      stroke: "currentColor",
      children: [
        T.jsx("title", { children: "Clean" }),
        T.jsx("circle", { cx: "7.99998", cy: "8.00004", r: "4.66667", strokeLinecap: "round" }),
        T.jsx("path", { d: "M4.66669 4.66663L11.3334 11.3333" }),
      ],
    });
  },
  kae = function () {
    return T.jsxs(Hr, {
      fill: "none",
      stroke: "currentColor",
      children: [
        T.jsx("title", { children: "Open on CodeSandbox" }),
        T.jsx("path", {
          d: "M6.66665 3.33337H4.33331C3.78103 3.33337 3.33331 3.78109 3.33331 4.33337V11.6667C3.33331 12.219 3.78103 12.6667 4.33331 12.6667H11.6666C12.2189 12.6667 12.6666 12.219 12.6666 11.6667V9.33337",
          strokeLinecap: "round",
        }),
        T.jsx("path", { d: "M10 3.33337H12.5667C12.6219 3.33337 12.6667 3.37815 12.6667 3.43337V6.00004", strokeLinecap: "round" }),
        T.jsx("path", { d: "M7.33331 8.66668L12.5333 3.46667", strokeLinecap: "round" }),
      ],
    });
  },
  Cae = function () {
    return T.jsxs(Hr, {
      stroke: "currentColor",
      children: [
        T.jsx("title", { children: "Close file" }),
        T.jsx("path", { d: "M12 4L4 12", strokeLinecap: "round" }),
        T.jsx("path", { d: "M4 4L12 12", strokeLinecap: "round" }),
      ],
    });
  },
  _ae = function () {
    return T.jsxs(Hr, {
      children: [
        T.jsx("title", { children: "Open browser console" }),
        T.jsx("path", {
          d: "M5.65871 3.62037C5.44905 3.44066 5.1334 3.46494 4.95368 3.6746C4.77397 3.88427 4.79825 4.19992 5.00792 4.37963L5.65871 3.62037ZM5.00792 11.6204C4.79825 11.8001 4.77397 12.1157 4.95368 12.3254C5.1334 12.5351 5.44905 12.5593 5.65871 12.3796L5.00792 11.6204ZM9.9114 7.92407L10.2368 7.54445L9.9114 7.92407ZM5.00792 4.37963L9.586 8.3037L10.2368 7.54445L5.65871 3.62037L5.00792 4.37963ZM9.586 7.6963L5.00792 11.6204L5.65871 12.3796L10.2368 8.45555L9.586 7.6963ZM9.586 8.3037C9.39976 8.14407 9.39976 7.85594 9.586 7.6963L10.2368 8.45555C10.5162 8.2161 10.5162 7.7839 10.2368 7.54445L9.586 8.3037Z",
        }),
        T.jsx("path", {
          d: "M10 11.5C9.72386 11.5 9.5 11.7239 9.5 12C9.5 12.2761 9.72386 12.5 10 12.5V11.5ZM14.6667 12.5C14.9428 12.5 15.1667 12.2761 15.1667 12C15.1667 11.7239 14.9428 11.5 14.6667 11.5V12.5ZM10 12.5H14.6667V11.5H10V12.5Z",
        }),
      ],
    });
  },
  N1,
  Vl = {
    colors: {
      surface1: "#ffffff",
      surface2: "#EFEFEF",
      surface3: "#F3F3F3",
      disabled: "#C5C5C5",
      base: "#323232",
      clickable: "#808080",
      hover: "#4D4D4D",
      accent: "#3973E0",
      error: "#EA3323",
      errorSurface: "#FCF1F0",
      warning: "#6A4516",
      warningSurface: "#FEF2C0",
    },
    syntax: {
      plain: "#151515",
      comment: { color: "#999", fontStyle: "italic" },
      keyword: "#7C5AE3",
      tag: "#0971F1",
      punctuation: "#3B3B3B",
      definition: "#85A600",
      property: "#3B3B3B",
      static: "#3B3B3B",
      string: "#2E6BD0",
    },
    font: {
      body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      mono: '"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',
      size: "13px",
      lineHeight: "20px",
    },
  },
  mv = {
    colors: {
      surface1: "#151515",
      surface2: "#252525",
      surface3: "#2F2F2F",
      disabled: "#4D4D4D",
      base: "#808080",
      clickable: "#999999",
      hover: "#C5C5C5",
      accent: "#E5E5E5",
      error: "#FFB4A6",
      errorSurface: "#690000",
      warning: "#E7C400",
      warningSurface: "#3A3000",
    },
    syntax: {
      plain: "#FFFFFF",
      comment: { color: "#757575", fontStyle: "italic" },
      keyword: "#77B7D7",
      tag: "#DFAB5C",
      punctuation: "#ffffff",
      definition: "#86D9CA",
      property: "#77B7D7",
      static: "#C64640",
      string: "#977CDC",
    },
    font: {
      body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      mono: '"Fira Mono", "DejaVu Sans Mono", Menlo, Consolas, "Liberation Mono", Monaco, "Lucida Console", monospace',
      size: "13px",
      lineHeight: "20px",
    },
  },
  Eae = {
    light: Vl,
    dark: mv,
    auto:
      typeof window < "u" &&
      !((N1 = window == null ? void 0 : window.matchMedia) === null || N1 === void 0) &&
      N1.call(window, "(prefers-color-scheme: dark)").matches
        ? mv
        : Vl,
  },
  Tp = function (t) {
    var e = t.lastIndexOf("/");
    return t.slice(e + 1);
  },
  Tae = function (t, e) {
    var n = (t[0] === "/" ? t.slice(1) : t).split("/"),
      r = [];
    if (n.length === 1) r.unshift(n[0]);
    else
      for (var i = 0; i < e.length; i++)
        for (var o = e[i].split("/"), s = 1; s <= n.length; s++) {
          var l = n[n.length - s],
            a = o[o.length - s];
          if ((r.length < s && r.unshift(l), l !== a)) break;
        }
    return r.length < n.length && r.unshift(".."), r.join("/");
  },
  D_ = function (t) {
    var e = 0,
      n = 0,
      r = 0;
    if (t.startsWith("#")) {
      if (t.length < 7) return !0;
      (e = parseInt(t.substr(1, 2), 16)), (n = parseInt(t.substr(3, 2), 16)), (r = parseInt(t.substr(5, 2), 16));
    } else {
      var i = t.replace("rgb(", "").replace("rgba(", "").replace(")", "").split(",");
      if (i.length < 3) return !0;
      (e = parseInt(i[0], 10)), (n = parseInt(i[1], 10)), (r = parseInt(i[2], 10));
    }
    var o = (e * 299 + n * 587 + r * 114) / 1e3;
    return o < 128;
  },
  Pae = 0,
  Pp = function () {
    var t = +(Date.now().toString(10).substr(0, 4) + Pae++);
    return t.toString(16);
  },
  Lu,
  it = "sp",
  Aae = ((Lu = MK({ prefix: it })), Lu.createTheme),
  he = Lu.css;
Lu.getCssText;
var p6 = Lu.keyframes,
  $ae = {
    space: new Array(11).fill(" ").reduce(function (t, e, n) {
      var r;
      return Z(Z({}, t), ((r = {}), (r[n + 1] = "".concat((n + 1) * 4, "px")), r));
    }, {}),
    border: { radius: "4px" },
    layout: { height: "300px", headerHeight: "40px" },
    transitions: { default: "150ms ease" },
    zIndices: { base: "1", overlay: "2", top: "3" },
  },
  Rae = function (t) {
    var e = Object.entries(t.syntax),
      n = e.reduce(function (r, i) {
        var o,
          s = i[0],
          l = i[1],
          a = ((o = {}), (o["color-".concat(s)] = l), o);
        return (
          typeof l == "object" &&
            (a = Object.entries(l).reduce(function (c, u) {
              var h,
                d = u[0],
                f = u[1];
              return Z(Z({}, c), ((h = {}), (h["".concat(d, "-").concat(s)] = f), h));
            }, {})),
          Z(Z({}, r), a)
        );
      }, {});
    return Z(Z({}, $ae), { colors: t.colors, font: t.font, syntax: n });
  },
  Iae = function (t) {
    var e, n, r, i, o;
    t === void 0 && (t = "light");
    var s = "default";
    if (typeof t == "string") {
      var l = Eae[t];
      if (!l) throw new Error("[sandpack-react]: invalid theme '".concat(t, "' provided."));
      return { theme: l, id: t, mode: D_(l.colors.surface1) ? "dark" : "light" };
    }
    var a = D_(
        (n = (e = t == null ? void 0 : t.colors) === null || e === void 0 ? void 0 : e.surface1) !== null && n !== void 0
          ? n
          : Vl.colors.surface1
      )
        ? "dark"
        : "light",
      c = a === "dark" ? mv : Vl,
      u = Z(Z({}, c.colors), (r = t == null ? void 0 : t.colors) !== null && r !== void 0 ? r : {}),
      h = Z(Z({}, c.syntax), (i = t == null ? void 0 : t.syntax) !== null && i !== void 0 ? i : {}),
      d = Z(Z({}, c.font), (o = t == null ? void 0 : t.font) !== null && o !== void 0 ? o : {}),
      f = { colors: u, syntax: h, font: d },
      p = t ? Mae(JSON.stringify(f)) : s;
    return { theme: f, id: "sp-".concat(p), mode: a };
  },
  Mae = function (t) {
    for (var e = 0, n = 0; n < t.length; e &= e) e = 31 * e + t.charCodeAt(n++);
    return Math.abs(e);
  },
  F_ = function () {
    return "";
  };
F_.toString = F_;
var m6 = _.createContext({}),
  Lae = function (t) {
    var e = t.children,
      n = t.classes;
    return T.jsx(m6.Provider, { value: n || {}, children: e });
  },
  nn = function () {
    var t = _.useContext(m6);
    return function (n, r) {
      r === void 0 && (r = []);
      var i = "".concat(it, "-").concat(n);
      return Nae.apply(void 0, mn(mn([], r, !1), [i, t[i]], !1));
    };
  },
  Nae = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return t.filter(Boolean).join(" ");
  },
  Qae = he({
    all: "initial",
    fontSize: "$font$size",
    fontFamily: "$font$body",
    display: "block",
    boxSizing: "border-box",
    textRendering: "optimizeLegibility",
    WebkitTapHighlightColor: "transparent",
    WebkitFontSmoothing: "subpixel-antialiased",
    variants: { variant: { dark: { colorScheme: "dark" }, light: { colorScheme: "light" } } },
    "@media screen and (min-resolution: 2dppx)": { WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale" },
    "*": { boxSizing: "border-box" },
    ".sp-wrapper:focus": { outline: "0" },
  }),
  bw = _.createContext({ theme: Vl, id: "light", mode: "light" }),
  Dae = function (t) {
    var e = t.theme,
      n = t.children,
      r = t.className,
      i = Wt(t, ["theme", "children", "className"]),
      o = _.useState(e),
      s = o[0],
      l = o[1],
      a = Iae(s),
      c = a.theme,
      u = a.id,
      h = a.mode,
      d = nn(),
      f = _.useMemo(
        function () {
          return Aae(u, Rae(c));
        },
        [c, u]
      );
    return (
      _.useEffect(
        function () {
          if (e !== "auto") {
            l(e);
            return;
          }
          var p = function (m) {
            var O = m.matches;
            l(O ? "dark" : "light");
          };
          return (
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", p),
            function () {
              window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", p);
            }
          );
        },
        [e]
      ),
      T.jsx(bw.Provider, {
        value: { theme: c, id: u, mode: h },
        children: T.jsx("div", Z({ className: d("wrapper", [f, Qae({ variant: h }), r]) }, i, { children: n })),
      })
    );
  };
bw.Consumer;
var Dt = {
    "/styles.css": {
      code: `body {
  font-family: sans-serif;
  -webkit-font-smoothing: auto;
  -moz-font-smoothing: auto;
  -moz-osx-font-smoothing: grayscale;
  font-smoothing: auto;
  text-rendering: optimizeLegibility;
  font-smooth: always;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}

h1 {
  font-size: 1.5rem;
}`,
    },
  },
  Fae = {
    files: {
      "/src/styles.css": Dt["/styles.css"],
      "/src/pages/index.astro": {
        code: `---
import "../styles.css";
const data = "world";
---

<h1>Hello {data}</h1>

<style>
  h1 {
    font-size: 1.5rem;
  }
</style>`,
      },
      ".env": { code: 'ASTRO_TELEMETRY_DISABLED="1"' },
      "/package.json": {
        code: JSON.stringify({
          dependencies: { astro: "^1.6.12", "esbuild-wasm": "^0.15.16" },
          scripts: { dev: "astro dev", start: "astro dev", build: "astro build", preview: "astro preview", astro: "astro" },
        }),
      },
    },
    main: "/src/pages/index.astro",
    environment: "node",
  },
  Bae = {
    files: Z(Z({}, Dt), {
      "/pages/_app.js": {
        code: `import '../styles.css'

export default function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}`,
      },
      "/pages/index.js": {
        code: `export default function Home({ data }) {
  return (
    <div>
      <h1>Hello {data}</h1>
    </div>
  );
}
  
export function getServerSideProps() {
  return {
    props: { data: "world" },
  }
}
`,
      },
      "/next.config.js": {
        code: `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
}

module.exports = nextConfig
`,
      },
      "/package.json": {
        code: JSON.stringify({
          name: "my-app",
          version: "0.1.0",
          private: !0,
          scripts: { dev: "NEXT_TELEMETRY_DISABLED=1 next dev", build: "next build", start: "next start", lint: "next lint" },
          dependencies: { next: "12.1.6", react: "18.2.0", "react-dom": "18.2.0", "@next/swc-wasm-nodejs": "12.1.6" },
        }),
      },
    }),
    main: "/pages/index.js",
    environment: "node",
  },
  Vae = {
    files: {
      "/index.js": {
        code: `const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/html');
  res.end('Hello world');
});

server.listen(port, hostname, () => {
  console.log(\`Server running at http://\${hostname}:\${port}/\`);
});`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, scripts: { start: "node index.js" }, main: "index.js" }) },
    },
    main: "/index.js",
    environment: "node",
  },
  jae = {
    files: Z(Z({}, Dt), {
      "/index.js": {
        code: `import "./styles.css";

document.getElementById("app").innerHTML = \`
<h1>Hello world</h1>
\`;
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/index.js"><\/script>
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          devDependencies: { vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
    }),
    main: "/index.js",
    environment: "node",
  },
  Zae = {
    files: Z(Z({}, Dt), {
      "/App.jsx": {
        code: `export default function App() {
  const data = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.jsx": {
        code: `import { render } from "preact";
import "./styles.css";

import App from "./App";

const root = document.getElementById("root");
render(<App />, root);
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.jsx"><\/script>
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          dependencies: { preact: "^10.16.0" },
          devDependencies: { "@preact/preset-vite": "^2.5.0", vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
      "/vite.config.js": {
        code: `import { defineConfig } from "vite";
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()],
});
`,
      },
    }),
    main: "/App.jsx",
    environment: "node",
  },
  zae = {
    files: Z(Z({}, Dt), {
      "/App.tsx": {
        code: `export default function App() {
  const data: string = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.tsx": {
        code: `import { render } from "preact";
import "./styles.css";

import App from "./App";

const root = document.getElementById("root") as HTMLElement;
render(<App />, root);
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"><\/script>
  </body>
</html>
`,
      },
      "/tsconfig.json": {
        code: JSON.stringify(
          {
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              lib: ["DOM", "DOM.Iterable", "ESNext"],
              allowJs: !1,
              skipLibCheck: !0,
              esModuleInterop: !1,
              allowSyntheticDefaultImports: !0,
              strict: !0,
              forceConsistentCasingInFileNames: !0,
              module: "ESNext",
              moduleResolution: "Node",
              resolveJsonModule: !0,
              isolatedModules: !0,
              noEmit: !0,
              jsx: "react-jsx",
              jsxImportSource: "preact",
            },
            include: ["src"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "/tsconfig.node.json": {
        code: JSON.stringify(
          {
            compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node", allowSyntheticDefaultImports: !0 },
            include: ["vite.config.ts"],
          },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            scripts: { dev: "vite", build: "tsc && vite build", preview: "vite preview" },
            dependencies: { preact: "^10.16.0" },
            devDependencies: { "@preact/preset-vite": "^2.5.0", typescript: "^4.9.5", vite: "4.1.4", "esbuild-wasm": "^0.17.12" },
          },
          null,
          2
        ),
      },
      "/vite-env.d.ts": { code: '/// <reference types="vite/client" />' },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()],
})
`,
      },
    }),
    main: "/App.tsx",
    environment: "node",
  },
  Wae = {
    files: Z(Z({}, Dt), {
      "/App.jsx": {
        code: `export default function App() {
  const data = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.jsx": {
        code: `import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.jsx"><\/script>
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          dependencies: { react: "^18.2.0", "react-dom": "^18.2.0" },
          devDependencies: { "@vitejs/plugin-react": "3.1.0", vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
      "/vite.config.js": {
        code: `import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
});
`,
      },
    }),
    main: "/App.jsx",
    environment: "node",
  },
  Xae = {
    files: Z(Z({}, Dt), {
      "/App.tsx": {
        code: `export default function App() {
  const data: string = "world"

  return <h1>Hello {data}</h1>
}
`,
      },
      "/index.tsx": {
        code: `import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";
import React from "react";

const root = createRoot(document.getElementById("root") as HTMLElement);
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"><\/script>
  </body>
</html>
`,
      },
      "/tsconfig.json": {
        code: JSON.stringify(
          {
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              lib: ["DOM", "DOM.Iterable", "ESNext"],
              allowJs: !1,
              skipLibCheck: !0,
              esModuleInterop: !1,
              allowSyntheticDefaultImports: !0,
              strict: !0,
              forceConsistentCasingInFileNames: !0,
              module: "ESNext",
              moduleResolution: "Node",
              resolveJsonModule: !0,
              isolatedModules: !0,
              noEmit: !0,
              jsx: "react-jsx",
            },
            include: ["src"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "/tsconfig.node.json": {
        code: JSON.stringify(
          {
            compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node", allowSyntheticDefaultImports: !0 },
            include: ["vite.config.ts"],
          },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            scripts: { dev: "vite", build: "tsc && vite build", preview: "vite preview" },
            dependencies: { react: "^18.2.0", "react-dom": "^18.2.0" },
            devDependencies: {
              "@types/react": "^18.0.28",
              "@types/react-dom": "^18.0.11",
              "@vitejs/plugin-react": "^3.1.0",
              typescript: "^4.9.5",
              vite: "4.1.4",
              "esbuild-wasm": "^0.17.12",
            },
          },
          null,
          2
        ),
      },
      "/vite-env.d.ts": { code: '/// <reference types="vite/client" />' },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})
`,
      },
    }),
    main: "/App.tsx",
    environment: "node",
  },
  Uae = {
    files: {
      "/src/styles.css": Dt["/styles.css"],
      "/src/App.svelte": {
        code: `<script>
const data = "world";
<\/script>

<h1>Hello {data}</h1>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.js": {
        code: `import App from './App.svelte'
import "./styles.css"

const app = new App({
  target: document.getElementById('app'),
})

export default app`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"><\/script>
  </body>
</html>
`,
      },
      "/vite.config.js": {
        code: `import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte()],
})`,
      },
      "/package.json": {
        code: JSON.stringify({
          type: "module",
          scripts: { dev: "vite" },
          devDependencies: { "@sveltejs/vite-plugin-svelte": "^2.0.2", svelte: "^3.55.1", vite: "4.0.4", "esbuild-wasm": "^0.17.12" },
        }),
      },
    },
    main: "/src/App.svelte",
    environment: "node",
  },
  Hae = {
    files: {
      "/src/styles.css": Dt["/styles.css"],
      "/src/App.svelte": {
        code: `<script lang="ts">
const data: string = "world";
<\/script>

<h1>Hello {data}</h1>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.ts": {
        code: `import App from './App.svelte'
import "./styles.css"

const app = new App({
  target: document.getElementById('app'),
})

export default app`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"><\/script>
  </body>
</html>
`,
      },
      "/vite-env.d.ts": {
        code: `/// <reference types="svelte" />
/// <reference types="vite/client" />`,
      },
      "svelte.config.js": {
        code: `import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
}
`,
      },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte()],
})`,
      },
      "tsconfig.json": {
        code: JSON.stringify(
          {
            extends: "@tsconfig/svelte/tsconfig.json",
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              module: "ESNext",
              resolveJsonModule: !0,
              allowJs: !0,
              checkJs: !0,
              isolatedModules: !0,
            },
            include: ["src/**/*.d.ts", "src/**/*.ts", "src/**/*.js", "src/**/*.svelte"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "tsconfig.node.json": {
        code: JSON.stringify(
          { compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node" }, include: ["vite.config.ts"] },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            type: "module",
            scripts: { dev: "vite" },
            devDependencies: {
              "@sveltejs/vite-plugin-svelte": "^2.0.2",
              "@tsconfig/svelte": "^3.0.0",
              svelte: "^3.55.1",
              "svelte-check": "^2.10.3",
              tslib: "^2.5.0",
              vite: "4.1.4",
              "esbuild-wasm": "^0.17.12",
            },
          },
          null,
          2
        ),
      },
    },
    main: "/src/App.svelte",
    environment: "node",
  },
  qae = {
    files: {
      "/src/styles.css": Dt["/styles.css"],
      "/src/App.vue": {
        code: `<script setup>
import { ref } from "vue";

const data = ref("world");
<\/script>

<template>
  <h1>Hello {{ data }}</h1>
</template>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.js": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css"
            
createApp(App).mount('#app')            
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"><\/script>
  </body>
</html>
`,
      },
      "/vite.config.js": {
        code: `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()]
})
`,
      },
      "/package.json": {
        code: JSON.stringify({
          scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
          dependencies: { vue: "^3.2.45" },
          devDependencies: { "@vitejs/plugin-vue": "3.2.0", vite: "4.1.4", "esbuild-wasm": "0.17.12" },
        }),
      },
    },
    main: "/src/App.vue",
    environment: "node",
  },
  Yae = {
    files: {
      "/src/styles.css": Dt["/styles.css"],
      "/src/App.vue": {
        code: `<script setup lang="ts">
import { ref } from "vue";

const data = ref<string>("world");
<\/script>

<template>
  <h1>Hello {{ data }}</h1>
</template>

<style>
h1 {
  font-size: 1.5rem;
}
</style>`,
      },
      "/src/main.ts": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css"

createApp(App).mount('#app')
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"><\/script>
  </body>
</html>
`,
      },
      "/vite-env.d.ts": { code: '/// <reference types="vite/client" />' },
      "/vite.config.ts": {
        code: `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()]
})
`,
      },
      "tsconfig.json": {
        code: JSON.stringify(
          {
            compilerOptions: {
              target: "ESNext",
              useDefineForClassFields: !0,
              module: "ESNext",
              moduleResolution: "Node",
              strict: !0,
              jsx: "preserve",
              resolveJsonModule: !0,
              isolatedModules: !0,
              esModuleInterop: !0,
              lib: ["ESNext", "DOM"],
              skipLibCheck: !0,
              noEmit: !0,
            },
            include: ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
            references: [{ path: "./tsconfig.node.json" }],
          },
          null,
          2
        ),
      },
      "tsconfig.node.json": {
        code: JSON.stringify(
          {
            compilerOptions: { composite: !0, module: "ESNext", moduleResolution: "Node", allowSyntheticDefaultImports: !0 },
            include: ["vite.config.ts"],
          },
          null,
          2
        ),
      },
      "/package.json": {
        code: JSON.stringify(
          {
            scripts: { dev: "vite", build: "tsc && vite build", preview: "vite preview" },
            dependencies: { vue: "^3.2.47" },
            devDependencies: {
              "@vitejs/plugin-vue": "^4.0.0",
              vite: "4.1.4",
              "vue-tsc": "^1.2.0",
              typescript: "^4.9.5",
              "esbuild-wasm": "^0.17.12",
            },
          },
          null,
          2
        ),
      },
    },
    main: "/src/App.vue",
    environment: "node",
  },
  Gae = {
    files: {
      "/src/app/app.component.css": Dt["/styles.css"],
      "/src/app/app.component.html": {
        code: `<div>
<h1>{{ helloWorld }}</h1>
</div>     
`,
      },
      "/src/app/app.component.ts": {
        code: `import { Component } from "@angular/core";

@Component({
  selector: "app-root",
  templateUrl: "./app.component.html",
  styleUrls: ["./app.component.css"]
})
export class AppComponent {
  helloWorld = "Hello world";
}           
`,
      },
      "/src/app/app.module.ts": {
        code: `import { BrowserModule } from "@angular/platform-browser";
import { NgModule } from "@angular/core";
      
import { AppComponent } from "./app.component";
      
@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}       
`,
      },
      "/src/index.html": {
        code: `<!doctype html>
<html lang="en">
      
<head>
  <meta charset="utf-8">
  <title>Angular</title>
  <base href="/">
      
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
      
<body>
   <app-root></app-root>
</body>
      
</html>
`,
      },
      "/src/main.ts": {
        code: `import { enableProdMode } from "@angular/core";
import { platformBrowserDynamic } from "@angular/platform-browser-dynamic";
      
import { AppModule } from "./app/app.module";      

platformBrowserDynamic()
  .bootstrapModule(AppModule)
  .catch(err => console.log(err));
      
`,
      },
      "/src/polyfills.ts": {
        code: `import "core-js/proposals/reflect-metadata";   
      import "zone.js/dist/zone";
`,
      },
      "/package.json": {
        code: JSON.stringify({
          dependencies: {
            "@angular/core": "^11.2.0",
            "@angular/platform-browser": "^11.2.0",
            "@angular/platform-browser-dynamic": "^11.2.0",
            "@angular/common": "^11.2.0",
            "@angular/compiler": "^11.2.0",
            "zone.js": "0.11.3",
            "core-js": "3.8.3",
            rxjs: "6.6.3",
          },
          main: "/src/main.ts",
        }),
      },
    },
    main: "/src/app/app.component.ts",
    environment: "angular-cli",
  },
  Jae = {
    files: Z(Z({}, Dt), {
      "/App.js": {
        code: `export default function App() {
  return <h1>Hello world</h1>
}
`,
      },
      "/index.js": {
        code: `import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);`,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>`,
      },
      "/package.json": {
        code: JSON.stringify({ dependencies: { react: "^18.0.0", "react-dom": "^18.0.0", "react-scripts": "^5.0.0" }, main: "/index.js" }),
      },
    }),
    main: "/App.js",
    environment: "create-react-app",
  },
  Kae = {
    files: Z(Z({}, Dt), {
      "tsconfig.json": {
        code: `{
  "include": [
    "./**/*"
  ],
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "lib": [ "dom", "es2015" ],
    "jsx": "react-jsx"
  }
}`,
      },
      "/App.tsx": {
        code: `export default function App(): JSX.Element {
  return <h1>Hello world</h1>
}
`,
      },
      "/index.tsx": {
        code: `import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);`,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>`,
      },
      "/package.json": {
        code: JSON.stringify({
          dependencies: { react: "^18.0.0", "react-dom": "^18.0.0", "react-scripts": "^4.0.0" },
          devDependencies: { "@types/react": "^18.0.0", "@types/react-dom": "^18.0.0", typescript: "^4.0.0" },
          main: "/index.tsx",
        }),
      },
    }),
    main: "/App.tsx",
    environment: "create-react-app",
  },
  ece = {
    files: Z(Z({}, Dt), {
      "/App.tsx": {
        code: `import { Component } from "solid-js";

const App: Component = () => {
  return <h1>Hello world</h1>
};

export default App;`,
      },
      "/index.tsx": {
        code: `import { render } from "solid-js/web";
import App from "./App";

import "./styles.css";

render(() => <App />, document.getElementById("app"));`,
      },
      "/index.html": {
        code: `<html>
<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
</head>
<body>
  <div id="app"></div>
  <script src="src/index.tsx"><\/script>
</body>
</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: { "solid-js": "1.3.15" }, main: "/index.tsx" }) },
    }),
    main: "/App.tsx",
    environment: "solid",
  },
  tce = {
    files: Z(Z({}, Dt), {
      "/App.svelte": {
        code: `<style>
  h1 {
    font-size: 1.5rem;
  }
</style>

<script>
  let name = 'world';
<\/script>

<main>
  <h1>Hello {name}</h1>
</main>`,
      },
      "/index.js": {
        code: `import App from "./App.svelte";
import "./styles.css";

const app = new App({
  target: document.body
});

export default app;
      `,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="width=device-width" />

    <title>Svelte app</title>

    <link rel="stylesheet" href="public/bundle.css" />
  </head>

  <body>
    <script src="bundle.js"><\/script>
  </body>
</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: { svelte: "^3.0.0" }, main: "/index.js" }) },
    }),
    main: "/App.svelte",
    environment: "svelte",
  },
  nce = {
    files: {
      "tsconfig.json": {
        code: `{
  "include": [
    "./**/*"
  ],
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "lib": [ "dom", "es2015" ],
    "jsx": "react-jsx"
  }
}`,
      },
      "/add.ts": { code: "export const add = (a: number, b: number): number => a + b;" },
      "/add.test.ts": {
        code: `import { add } from './add';

describe('add', () => {
  test('Commutative Law of Addition', () => {
    expect(add(1, 2)).toBe(add(2, 1));
  });
});`,
      },
      "package.json": { code: JSON.stringify({ dependencies: {}, devDependencies: { typescript: "^4.0.0" }, main: "/add.ts" }) },
    },
    main: "/add.test.ts",
    environment: "parcel",
    mode: "tests",
  },
  rce = {
    files: Z(Z({}, Dt), {
      "/index.js": {
        code: `import "./styles.css";

document.getElementById("app").innerHTML = \`
<h1>Hello world</h1>
\`;
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html>

<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
</head>

<body>
  <div id="app"></div>

  <script src="index.js">
  <\/script>
</body>

</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, main: "/index.js" }) },
    }),
    main: "/index.js",
    environment: "parcel",
  },
  ice = {
    files: Z(Z({}, Dt), {
      "tsconfig.json": {
        code: `{
  "compilerOptions": {
    "strict": true,
    "module": "commonjs",
    "jsx": "preserve",
    "esModuleInterop": true,
    "sourceMap": true,
    "allowJs": true,
    "lib": [
      "es6",
      "dom"
    ],
    "rootDir": "src",
    "moduleResolution": "node"
  }
}`,
      },
      "/index.ts": {
        code: `import "./styles.css";

document.getElementById("app").innerHTML = \`
<h1>Hello world</h1>
\`;
`,
      },
      "/index.html": {
        code: `<!DOCTYPE html>
<html>

<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
</head>

<body>
  <div id="app"></div>

  <script src="index.ts">
  <\/script>
</body>

</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, devDependencies: { typescript: "^4.0.0" }, main: "/index.ts" }) },
    }),
    main: "/index.ts",
    environment: "parcel",
  },
  oce = {
    files: {
      "/src/styles.css": Dt["/styles.css"],
      "/src/App.vue": {
        code: `<template>
  <h1>Hello {{ msg }}</h1>
</template>

<script setup>
import { ref } from 'vue';
const msg = ref('world');
<\/script>`,
      },
      "/src/main.js": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css";

createApp(App).mount('#app')
`,
      },
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>codesandbox</title>
  </head>
  <body>
    <noscript>
      <strong
        >We're sorry but codesandbox doesn't work properly without JavaScript
        enabled. Please enable it to continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          name: "vue3",
          version: "0.1.0",
          private: !0,
          main: "/src/main.js",
          scripts: { serve: "vue-cli-service serve", build: "vue-cli-service build" },
          dependencies: { "core-js": "^3.26.1", vue: "^3.2.45" },
          devDependencies: { "@vue/cli-plugin-babel": "^5.0.8", "@vue/cli-service": "^5.0.8" },
        }),
      },
    },
    main: "/src/App.vue",
    environment: "vue-cli",
  },
  sce = {
    files: {
      "/src/styles.css": Dt["/styles.css"],
      "/src/App.vue": {
        code: `<template>
  <h1>Hello {{ msg }}</h1>
</template>

<script setup lang="ts">
import { ref } from 'vue';
const msg = ref<string>('world');
<\/script>`,
      },
      "/src/main.ts": {
        code: `import { createApp } from 'vue'
import App from './App.vue'
import "./styles.css";

createApp(App).mount('#app')
`,
      },
      "/src/shims-vue.d.ts": `/* eslint-disable */
declare module "*.vue" {
  import type { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}`,
      "/public/index.html": {
        code: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>codesandbox</title>
  </head>
  <body>
    <noscript>
      <strong
        >We're sorry but codesandbox doesn't work properly without JavaScript
        enabled. Please enable it to continue.</strong
      >
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
`,
      },
      "/package.json": {
        code: JSON.stringify({
          name: "vue3-ts",
          version: "0.1.0",
          private: !0,
          main: "/src/main.ts",
          scripts: { serve: "vue-cli-service serve", build: "vue-cli-service build" },
          dependencies: { "core-js": "^3.26.1", vue: "^3.2.45" },
          devDependencies: {
            "@vue/cli-plugin-babel": "^5.0.8",
            "@vue/cli-plugin-typescript": "^5.0.8",
            "@vue/cli-service": "^5.0.8",
            typescript: "^4.9.3",
          },
        }),
      },
      "/tsconfig.json": {
        code: JSON.stringify({
          compilerOptions: {
            target: "esnext",
            module: "esnext",
            strict: !0,
            jsx: "preserve",
            moduleResolution: "node",
            experimentalDecorators: !0,
            skipLibCheck: !0,
            esModuleInterop: !0,
            allowSyntheticDefaultImports: !0,
            forceConsistentCasingInFileNames: !0,
            useDefineForClassFields: !0,
            sourceMap: !1,
            baseUrl: ".",
            types: ["webpack-env"],
            paths: { "@/*": ["src/*"] },
            lib: ["esnext", "dom", "dom.iterable", "scripthost"],
          },
          include: ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "tests/**/*.ts", "tests/**/*.tsx"],
          exclude: ["node_modules"],
        }),
      },
    },
    main: "/src/App.vue",
    environment: "vue-cli",
  },
  lce = {
    files: Z(Z({}, Dt), {
      "/index.html": {
        code: `<!DOCTYPE html>
<html>

<head>
  <title>Parcel Sandbox</title>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="/styles.css" />
</head>

<body>
  <h1>Hello world</h1>
</body>

</html>`,
      },
      "/package.json": { code: JSON.stringify({ dependencies: {}, main: "/index.html" }) },
    }),
    main: "/index.html",
    environment: "static",
  },
  B_ = {
    static: lce,
    angular: Gae,
    react: Jae,
    "react-ts": Kae,
    solid: ece,
    svelte: tce,
    "test-ts": nce,
    "vanilla-ts": ice,
    vanilla: rce,
    vue: oce,
    "vue-ts": sce,
    node: Vae,
    nextjs: Bae,
    vite: jae,
    "vite-react": Wae,
    "vite-react-ts": Xae,
    "vite-preact": Zae,
    "vite-preact-ts": zae,
    "vite-vue": qae,
    "vite-vue-ts": Yae,
    "vite-svelte": Uae,
    "vite-svelte-ts": Hae,
    astro: Fae,
  },
  gv = function (t) {
    var e,
      n,
      r,
      i,
      o,
      s,
      l = Rs(t.files),
      a = ace({ template: t.template, customSetup: t.customSetup, files: l }),
      c = Rs((n = (e = t.options) === null || e === void 0 ? void 0 : e.visibleFiles) !== null && n !== void 0 ? n : []),
      u =
        !((r = t.options) === null || r === void 0) && r.activeFile
          ? V_((i = t.options) === null || i === void 0 ? void 0 : i.activeFile, a.files)
          : void 0;
    c.length === 0 &&
      l &&
      Object.keys(l).forEach(function (f) {
        var p = l[f];
        if (typeof p == "string") {
          c.push(f);
          return;
        }
        !u && p.active && ((u = f), p.hidden === !0 && c.push(f)), p.hidden || c.push(f);
      }),
      c.length === 0 && (c = [a.main]),
      a.entry && !a.files[a.entry] && (a.entry = V_(a.entry, a.files)),
      !u && a.main && (u = a.main),
      (!u || !a.files[u]) && (u = c[0]),
      c.includes(u) || c.push(u);
    var h = WK(
        a.files,
        (o = a.dependencies) !== null && o !== void 0 ? o : {},
        (s = a.devDependencies) !== null && s !== void 0 ? s : {},
        a.entry
      ),
      d = c.filter(function (f) {
        return h[f];
      });
    return { visibleFiles: d, activeFile: u, files: h, environment: a.environment, shouldUpdatePreview: !0 };
  },
  V_ = function (t, e) {
    var n = Rs(e),
      r = Rs(t);
    if (r in n) return r;
    if (!t) return null;
    for (var i = null, o = 0, s = [".js", ".jsx", ".ts", ".tsx"]; !i && o < s.length; ) {
      var l = r.split(".")[0],
        a = "".concat(l).concat(s[o]);
      n[a] !== void 0 && (i = a), o++;
    }
    return i;
  },
  ace = function (t) {
    var e = t.files,
      n = t.template,
      r = t.customSetup;
    if (!n) {
      if (!r) {
        var i = B_.vanilla;
        return Z(Z({}, i), { files: Z(Z({}, i.files), df(e)) });
      }
      if (!e || Object.keys(e).length === 0) throw new Error("[sandpack-react]: without a template, you must pass at least one file");
      return Z(Z({}, r), { files: df(e) });
    }
    var o = B_[n];
    if (!o) throw new Error('[sandpack-react]: invalid template "'.concat(n, '" provided'));
    return !r && !e
      ? o
      : {
          files: df(Z(Z({}, o.files), e)),
          dependencies: Z(Z({}, o.dependencies), r == null ? void 0 : r.dependencies),
          devDependencies: Z(Z({}, o.devDependencies), r == null ? void 0 : r.devDependencies),
          entry: Rs(r == null ? void 0 : r.entry),
          main: o.main,
          environment: (r == null ? void 0 : r.environment) || o.environment,
        };
  },
  df = function (t) {
    return t
      ? Object.keys(t).reduce(function (e, n) {
          return typeof t[n] == "string" ? (e[n] = { code: t[n] }) : (e[n] = t[n]), e;
        }, {})
      : {};
  },
  cce = function (t, e) {
    var n = _.useState({ editorState: "pristine" }),
      r = n[0],
      i = n[1],
      o = gv(t),
      s = Fc(o.files, e) ? "pristine" : "dirty";
    return (
      s !== r.editorState &&
        i(function (l) {
          return Z(Z({}, l), { editorState: s });
        }),
      r
    );
  },
  uce = 4e4,
  hce = function (t, e) {
    var n,
      r,
      i,
      o = t.options,
      s = t.customSetup,
      l = t.teamId,
      a = t.sandboxId;
    o ?? (o = {}), s ?? (s = {});
    var c = (o == null ? void 0 : o.initMode) || "lazy",
      u = _.useState({
        startRoute: o == null ? void 0 : o.startRoute,
        bundlerState: void 0,
        error: null,
        initMode: c,
        reactDevTools: void 0,
        status: !((n = o == null ? void 0 : o.autorun) !== null && n !== void 0) || n ? "initial" : "idle",
      }),
      h = u[0],
      d = u[1],
      f = _.useRef(),
      p = _.useRef(null),
      m = _.useRef(null),
      O = _.useRef({}),
      v = _.useRef({}),
      g = _.useRef(null),
      b = _.useRef({}),
      x = _.useRef(),
      k = _.useRef({ global: {} }),
      w = _.useRef(),
      y = _.useRef(e.environment),
      C = _.useCallback(
        function (A, V, ie) {
          return Ec(void 0, void 0, void 0, function () {
            var M, fe, Se, pe, Y, q, oe;
            return Tc(this, function (ce) {
              switch (ce.label) {
                case 0:
                  return (
                    v.current[V] && v.current[V].destroy(),
                    o ?? (o = {}),
                    s ?? (s = {}),
                    (M = (Y = o == null ? void 0 : o.bundlerTimeOut) !== null && Y !== void 0 ? Y : uce),
                    g.current && clearTimeout(g.current),
                    (fe = typeof x.current != "function"),
                    fe &&
                      (g.current = setTimeout(function () {
                        P(),
                          d(function (Oe) {
                            return Z(Z({}, Oe), { status: "timeout" });
                          });
                      }, M)),
                    [
                      4,
                      GK(
                        A,
                        { files: e.files, template: e.environment },
                        {
                          externalResources: o.externalResources,
                          bundlerURL: o.bundlerURL,
                          startRoute: (q = ie == null ? void 0 : ie.startRoute) !== null && q !== void 0 ? q : o.startRoute,
                          fileResolver: o.fileResolver,
                          skipEval: (oe = o.skipEval) !== null && oe !== void 0 ? oe : !1,
                          logLevel: o.logLevel,
                          showOpenInCodeSandbox: !1,
                          showErrorScreen: !0,
                          showLoadingScreen: !1,
                          reactDevTools: h.reactDevTools,
                          customNpmRegistries: s == null ? void 0 : s.npmRegistries,
                          teamId: l,
                          sandboxId: a,
                        }
                      ),
                    ]
                  );
                case 1:
                  return (
                    (Se = ce.sent()),
                    typeof x.current != "function" && (x.current = Se.listen(Q)),
                    (b.current[V] = b.current[V] || {}),
                    k.current[V] &&
                      (Object.keys(k.current[V]).forEach(function (Oe) {
                        var _e = k.current[V][Oe],
                          Le = Se.listen(_e);
                        b.current[V][Oe] = Le;
                      }),
                      (k.current[V] = {})),
                    (pe = Object.entries(k.current.global)),
                    pe.forEach(function (Oe) {
                      var _e = Oe[0],
                        Le = Oe[1],
                        Ge = Se.listen(Le);
                      b.current[V][_e] = Ge;
                    }),
                    (v.current[V] = Se),
                    [2]
                  );
              }
            });
          });
        },
        [e.environment, e.files, h.reactDevTools]
      ),
      P = _.useCallback(function () {
        Object.keys(v.current).map(D), typeof x.current == "function" && (x.current(), (x.current = void 0));
      }, []),
      E = _.useCallback(
        function () {
          return Ec(void 0, void 0, void 0, function () {
            return Tc(this, function (A) {
              switch (A.label) {
                case 0:
                  return [
                    4,
                    Promise.all(
                      Object.entries(O.current).map(function (V) {
                        var ie = V[0],
                          M = V[1],
                          fe = M.iframe,
                          Se = M.clientPropsOverride,
                          pe = Se === void 0 ? {} : Se;
                        return Ec(void 0, void 0, void 0, function () {
                          return Tc(this, function (Y) {
                            switch (Y.label) {
                              case 0:
                                return [4, C(fe, ie, pe)];
                              case 1:
                                return Y.sent(), [2];
                            }
                          });
                        });
                      })
                    ),
                  ];
                case 1:
                  return (
                    A.sent(),
                    d(function (V) {
                      return Z(Z({}, V), { error: null, status: "running" });
                    }),
                    [2]
                  );
              }
            });
          });
        },
        [C]
      );
    f.current = function (A) {
      A.some(function (V) {
        return V.isIntersecting;
      })
        ? E()
        : P();
    };
    var N = _.useCallback(
        function () {
          var A,
            V,
            ie,
            M = (A = o == null ? void 0 : o.autorun) !== null && A !== void 0 ? A : !0;
          if (M) {
            var fe = (V = o == null ? void 0 : o.initModeObserverOptions) !== null && V !== void 0 ? V : { rootMargin: "1000px 0px" };
            p.current && m.current && ((ie = p.current) === null || ie === void 0 || ie.unobserve(m.current)),
              m.current && h.initMode === "lazy"
                ? ((p.current = new IntersectionObserver(function (Se) {
                    var pe, Y;
                    Se.some(function (q) {
                      return q.isIntersecting;
                    }) &&
                      Se.some(function (q) {
                        return q.isIntersecting;
                      }) &&
                      m.current &&
                      ((pe = f.current) === null || pe === void 0 || pe.call(f, Se),
                      (Y = p.current) === null || Y === void 0 || Y.unobserve(m.current));
                  }, fe)),
                  p.current.observe(m.current))
                : m.current && h.initMode === "user-visible"
                ? ((p.current = new IntersectionObserver(function (Se) {
                    var pe;
                    (pe = f.current) === null || pe === void 0 || pe.call(f, Se);
                  }, fe)),
                  p.current.observe(m.current))
                : E();
          }
        },
        [o == null ? void 0 : o.autorun, o == null ? void 0 : o.initModeObserverOptions, E, h.initMode, P]
      ),
      L = _.useCallback(
        function (A, V, ie) {
          return Ec(void 0, void 0, void 0, function () {
            return Tc(this, function (M) {
              switch (M.label) {
                case 0:
                  return (O.current[V] = { iframe: A, clientPropsOverride: ie }), h.status !== "running" ? [3, 2] : [4, C(A, V, ie)];
                case 1:
                  M.sent(), (M.label = 2);
                case 2:
                  return [2];
              }
            });
          });
        },
        [C, h.status]
      ),
      D = function (A) {
        var V,
          ie,
          M = v.current[A];
        M
          ? (M.destroy(),
            (V = M.iframe.contentWindow) === null || V === void 0 || V.location.replace("about:blank"),
            M.iframe.removeAttribute("src"),
            delete v.current[A])
          : delete O.current[A],
          g.current && clearTimeout(g.current);
        var fe = Object.values((ie = b.current[A]) !== null && ie !== void 0 ? ie : {});
        fe.forEach(function (pe) {
          var Y = Object.values(pe);
          Y.forEach(function (q) {
            return q();
          });
        });
        var Se = Object.keys(v.current).length > 0 ? "running" : "idle";
        d(function (pe) {
          return Z(Z({}, pe), { status: Se });
        });
      },
      Q = function (A) {
        A.type === "start"
          ? d(function (V) {
              return Z(Z({}, V), { error: null });
            })
          : A.type === "state"
          ? d(function (V) {
              return Z(Z({}, V), { bundlerState: A.state });
            })
          : (A.type === "done" && !A.compilatonError) || A.type === "connected"
          ? (g.current && clearTimeout(g.current),
            d(function (V) {
              return Z(Z({}, V), { error: null });
            }))
          : A.type === "action" && A.action === "show-error"
          ? (g.current && clearTimeout(g.current),
            d(function (V) {
              return Z(Z({}, V), { error: XK(A) });
            }))
          : A.type === "action" &&
            A.action === "notification" &&
            A.notificationType === "error" &&
            d(function (V) {
              return Z(Z({}, V), { error: { message: A.title } });
            });
      },
      R = function (A) {
        d(function (V) {
          return Z(Z({}, V), { reactDevTools: A });
        });
      },
      W = (r = o == null ? void 0 : o.recompileMode) !== null && r !== void 0 ? r : "delayed",
      B = (i = o == null ? void 0 : o.recompileDelay) !== null && i !== void 0 ? i : 200,
      K = function (A, V) {
        if (h.status !== "running") {
          console.warn("[sandpack-react]: dispatch cannot be called while in idle mode");
          return;
        }
        V
          ? v.current[V].dispatch(A)
          : Object.values(v.current).forEach(function (ie) {
              ie.dispatch(A);
            });
      },
      ne = function (A, V) {
        if (V)
          if (v.current[V]) {
            var ie = v.current[V].listen(A);
            return ie;
          } else {
            var M = Pp();
            (k.current[V] = k.current[V] || {}), (b.current[V] = b.current[V] || {}), (k.current[V][M] = A);
            var ie = function () {
              k.current[V][M] ? delete k.current[V][M] : b.current[V][M] && (b.current[V][M](), delete b.current[V][M]);
            };
            return ie;
          }
        else {
          var fe = Pp();
          k.current.global[fe] = A;
          var Se = Object.values(v.current),
            pe = Se.map(function (q) {
              return q.listen(A);
            }),
            ie = function () {
              pe.forEach(function (q) {
                return q();
              }),
                delete k.current.global[fe],
                Object.values(b.current).forEach(function (q) {
                  var oe;
                  (oe = q == null ? void 0 : q[fe]) === null || oe === void 0 || oe.call(q);
                });
            };
          return ie;
        }
      };
    return (
      _.useEffect(
        function () {
          if (!(h.status !== "running" || !e.shouldUpdatePreview)) {
            if (
              (y.current !== e.environment &&
                ((y.current = e.environment),
                Object.entries(v.current).forEach(function (V) {
                  var ie = V[0],
                    M = V[1];
                  L(M.iframe, ie);
                })),
              W === "immediate" &&
                Object.values(v.current).forEach(function (V) {
                  V.status === "done" && V.updateSandbox({ files: e.files, template: e.environment });
                }),
              W === "delayed")
            ) {
              if (typeof window > "u") return;
              window.clearTimeout(w.current),
                (w.current = window.setTimeout(function () {
                  Object.values(v.current).forEach(function (V) {
                    V.status === "done" && V.updateSandbox({ files: e.files, template: e.environment });
                  });
                }, B));
            }
            return function () {
              window.clearTimeout(w.current);
            };
          }
        },
        [e.files, e.environment, e.shouldUpdatePreview, B, W, L, h.status]
      ),
      _.useEffect(
        function () {
          c !== h.initMode &&
            (d(function (V) {
              return Z(Z({}, V), { initMode: c });
            }),
            N());
        },
        [c, N, h.initMode]
      ),
      _.useEffect(function () {
        return function () {
          typeof x.current == "function" && x.current(),
            g.current && clearTimeout(g.current),
            w.current && clearTimeout(w.current),
            p.current && p.current.disconnect();
        };
      }, []),
      [
        h,
        {
          clients: v.current,
          initializeSandpackIframe: N,
          runSandpack: E,
          registerBundler: L,
          unregisterBundler: D,
          registerReactDevTools: R,
          addListener: ne,
          dispatchMessage: K,
          lazyAnchorRef: m,
          unsubscribeClientListenersRef: b,
          queuedListenersRef: k,
        },
      ]
    );
  },
  dce = function (t) {
    var e = gv(t),
      n = _.useState(e),
      r = n[0],
      i = n[1],
      o = _.useRef(!1);
    _.useEffect(
      function () {
        o.current ? i(gv(t)) : (o.current = !0);
      },
      [t.files, t.customSetup, t.template]
    );
    var s = function (a, c, u) {
        u === void 0 && (u = !0),
          i(function (h) {
            var d,
              f = h.files;
            return (
              typeof a == "string" && typeof c == "string"
                ? (f = Z(Z({}, f), ((d = {}), (d[a] = Z(Z({}, f[a]), { code: c })), d)))
                : typeof a == "object" && (f = Z(Z({}, f), df(a))),
              Z(Z({}, h), { files: Rs(f), shouldUpdatePreview: u })
            );
          });
      },
      l = {
        openFile: function (a) {
          i(function (c) {
            var u = c.visibleFiles,
              h = Wt(c, ["visibleFiles"]),
              d = u.includes(a) ? u : mn(mn([], u, !0), [a], !1);
            return Z(Z({}, h), { activeFile: a, visibleFiles: d });
          });
        },
        resetFile: function (a) {
          i(function (c) {
            var u;
            return Z(Z({}, c), { files: Z(Z({}, c.files), ((u = {}), (u[a] = e.files[a]), u)) });
          });
        },
        resetAllFiles: function () {
          i(function (a) {
            return Z(Z({}, a), { files: e.files });
          });
        },
        setActiveFile: function (a) {
          r.files[a] &&
            i(function (c) {
              return Z(Z({}, c), { activeFile: a });
            });
        },
        updateCurrentFile: function (a, c) {
          c === void 0 && (c = !0), s(r.activeFile, a, c);
        },
        updateFile: s,
        addFile: s,
        closeFile: function (a) {
          r.visibleFiles.length !== 1 &&
            i(function (c) {
              var u = c.visibleFiles,
                h = c.activeFile,
                d = Wt(c, ["visibleFiles", "activeFile"]),
                f = u.indexOf(a),
                p = u.filter(function (m) {
                  return m !== a;
                });
              return Z(Z({}, d), { activeFile: a === h ? (f === 0 ? u[1] : u[f - 1]) : h, visibleFiles: p });
            });
        },
        deleteFile: function (a, c) {
          c === void 0 && (c = !0),
            i(function (u) {
              var h = u.visibleFiles,
                d = u.files,
                f = u.activeFile,
                p = Wt(u, ["visibleFiles", "files", "activeFile"]),
                m = Z({}, d);
              delete m[a];
              var O = h.filter(function (b) {
                  return b !== a;
                }),
                v = O.length === 0;
              if (v) {
                var g = Object.keys(d)[Object.keys(d).length - 1];
                return Z(Z({}, p), { visibleFiles: [g], activeFile: g, files: m, shouldUpdatePreview: c });
              }
              return Z(Z({}, p), { visibleFiles: O, activeFile: a === f ? O[O.length - 1] : f, files: m, shouldUpdatePreview: c });
            });
        },
      };
    return [Z(Z({}, r), { visibleFilesFromProps: e.visibleFiles }), l];
  },
  xw = _.createContext(null),
  fce = function (t) {
    var e,
      n,
      r,
      i = t.children,
      o = t.options,
      s = t.style,
      l = t.className,
      a = t.theme,
      c = dce(t),
      u = c[0],
      h = c[1],
      d = hce(t, u),
      f = d[0],
      p = d[1],
      m = p.dispatchMessage,
      O = p.addListener,
      v = Wt(p, ["dispatchMessage", "addListener"]),
      g = cce(t, u.files);
    return (
      _.useEffect(function () {
        v.initializeSandpackIframe();
      }, []),
      T.jsx(xw.Provider, {
        value: Z(Z(Z(Z(Z(Z({}, u), f), g), h), v), {
          autoReload: (n = (e = t.options) === null || e === void 0 ? void 0 : e.autoReload) !== null && n !== void 0 ? n : !0,
          teamId: t == null ? void 0 : t.teamId,
          exportOptions: (r = t == null ? void 0 : t.customSetup) === null || r === void 0 ? void 0 : r.exportOptions,
          listen: O,
          dispatch: m,
        }),
        children: T.jsx(Lae, {
          classes: o == null ? void 0 : o.classes,
          children: T.jsx(Dae, { className: l, style: s, theme: a, children: i }),
        }),
      })
    );
  };
xw.Consumer;
function Mt() {
  var t = _.useContext(xw);
  if (t === null) throw new Error('[sandpack-react]: "useSandpack" must be wrapped by a "SandpackProvider"');
  var e = t.dispatch,
    n = t.listen,
    r = Wt(t, ["dispatch", "listen"]);
  return { sandpack: Z({}, r), dispatch: e, listen: n };
}
var g6 = function () {
    var t,
      e,
      n,
      r = Mt().sandpack;
    return {
      code: (t = r.files[r.activeFile]) === null || t === void 0 ? void 0 : t.code,
      readOnly: (n = (e = r.files[r.activeFile]) === null || e === void 0 ? void 0 : e.readOnly) !== null && n !== void 0 ? n : !1,
      updateCode: r.updateCurrentFile,
    };
  },
  dc,
  _d,
  Q1,
  ji = he({ svg: { margin: "auto" } }),
  $n = he(
    ((dc = {
      appearance: "none",
      outline: "none",
      display: "flex",
      alignItems: "center",
      fontSize: "inherit",
      fontFamily: "inherit",
      backgroundColor: "transparent",
      transition: "color $default, background $default",
      cursor: "pointer",
      color: "$colors$clickable",
      border: 0,
      textDecoration: "none",
      "&:disabled": { color: "$colors$disabled" },
      "&:hover:not(:disabled,[data-active='true'])": { color: "$colors$hover" },
      '&[data-active="true"]': { color: "$colors$accent" },
      svg: { minWidth: "$space$4", width: "$space$4", height: "$space$4" },
    }),
    (dc["&.".concat(ji)] = { padding: "$space$1", height: "$space$7", display: "flex" }),
    (dc["&.".concat(ji, "&:not(:has(span))")] = { width: "$space$7" }),
    (dc["&.".concat(ji, "&:has(svg + span)")] = { paddingRight: "$space$3", paddingLeft: "$space$2", gap: "$space$1" }),
    dc)
  ),
  Vs = he({
    backgroundColor: "$colors$surface2",
    borderRadius: "99999px",
    border: "1px solid $colors$surface3",
    '&[data-active="true"]': { color: "$colors$surface1", background: "$colors$accent" },
    "&:hover:not(:disabled,[data-active='true'])": { backgroundColor: "$colors$surface3" },
  }),
  pce = he({ padding: 0 }),
  yw = p6({ "0%": { opacity: 0 }, "100%": { opacity: 1 } }),
  Xc = he({
    position: "absolute",
    bottom: "0",
    left: "0",
    right: "0",
    top: "0",
    margin: "0",
    overflow: "auto",
    height: "100%",
    zIndex: "$top",
  }),
  O6 = he(
    ((_d = {
      whiteSpace: "pre-wrap",
      padding: "$space$10",
      backgroundColor: "$colors$surface1",
      display: "flex",
      gap: "$space$2",
      flexDirection: "column",
    }),
    (_d[".".concat($n)] = { width: "auto", gap: "$space$2", padding: "0 $space$3 0 $space$2", marginTop: "$space$1" }),
    (_d.variants = { solidBg: { true: { backgroundColor: "$colors$errorSurface" } } }),
    _d)
  ),
  Ov = he(
    ((Q1 = { padding: "$space$10", backgroundColor: "$colors$surface1" }),
    (Q1[".".concat($n)] = { marginTop: "$space$6", width: "auto", gap: "$space$2", padding: "0 $space$3 0 $space$2" }),
    Q1)
  ),
  Oo = he({
    animation: "".concat(yw, " 150ms ease"),
    color: "$colors$error",
    display: "flex",
    flexDirection: "column",
    gap: "$space$3",
    variants: { errorCode: { true: { fontFamily: "$font$mono" } } },
    a: { color: "inherit" },
    p: { margin: 0 },
  }),
  D1,
  mce = he({ borderBottom: "1px solid $colors$surface2", background: "$colors$surface1" }),
  gce = he({
    padding: "0 $space$2",
    overflow: "auto",
    display: "flex",
    flexWrap: "nowrap",
    alignItems: "stretch",
    minHeight: "40px",
    marginBottom: "-1px",
  }),
  v6 = he({
    padding: "0 $space$1 0 $space$1",
    borderRadius: "$border$radius",
    marginLeft: "$space$1",
    width: "$space$5",
    visibility: "hidden",
    svg: { width: "$space$3", height: "$space$3", display: "block", position: "relative", top: 1 },
  }),
  Oce = he(
    ((D1 = { padding: "0 $space$2", height: "$layout$headerHeight", whiteSpace: "nowrap", "&:focus": { outline: "none" } }),
    (D1["&:hover > .".concat(v6)] = { visibility: "unset" }),
    D1)
  ),
  b6 = function (t) {
    var e = t.closableTabs,
      n = t.className,
      r = Wt(t, ["closableTabs", "className"]),
      i = Mt().sandpack,
      o = nn(),
      s = i.activeFile,
      l = i.visibleFiles,
      a = i.setActiveFile,
      c = function (h) {
        h.stopPropagation();
        var d = h.target.closest("[data-active]"),
          f = d == null ? void 0 : d.getAttribute("title");
        f && i.closeFile(f);
      },
      u = function (h) {
        var d = Tp(h),
          f = l.reduce(function (p, m) {
            if (m === h) return p;
            var O = Tp(m);
            return O === d && p.push(m), p;
          }, []);
        return f.length === 0 ? d : Tae(h, f);
      };
    return T.jsx(
      "div",
      Z({ className: o("tabs", [mce, n]), translate: "no" }, r, {
        children: T.jsx("div", {
          "aria-label": "Select active file",
          className: o("tabs-scrollable-container", [gce]),
          role: "tablist",
          children: l.map(function (h) {
            return T.jsxs(
              "button",
              {
                "aria-selected": h === s,
                className: o("tab-button", [$n, Oce]),
                "data-active": h === s,
                onClick: function () {
                  return a(h);
                },
                role: "tab",
                title: h,
                type: "button",
                children: [
                  u(h),
                  e && l.length > 1 && T.jsx("span", { className: o("close-button", [v6]), onClick: c, children: T.jsx(Cae, {}) }),
                ],
              },
              h
            );
          }),
        }),
      })
    );
  },
  Nu = function (t) {
    var e = t.onClick,
      n = t.className,
      r = t.children,
      i = nn();
    return T.jsx("button", { className: i("button", [i("icon-standalone"), $n, ji, Vs, n]), onClick: e, type: "button", children: r });
  },
  vce = he({ position: "absolute", bottom: "$space$2", right: "$space$2", paddingRight: "$space$3" }),
  x6 = function (t) {
    t.className;
    var e = t.onClick,
      n = Wt(t, ["className", "onClick"]),
      r = Mt().sandpack;
    return T.jsxs(
      Nu,
      Z(
        {
          className: vce.toString(),
          onClick: function (i) {
            r.runSandpack(), e == null || e(i);
          },
        },
        n,
        { children: [T.jsx(xae, {}), T.jsx("span", { children: "Run" })] }
      )
    );
  },
  F1,
  y6 = he(
    ((F1 = { display: "flex", flexDirection: "column", width: "100%", position: "relative", backgroundColor: "$colors$surface1", gap: 1 }),
    (F1["&:has(.".concat(it, "-stack)")] = { backgroundColor: "$colors$surface2" }),
    F1)
  ),
  cg = function (t) {
    var e = t.className,
      n = Wt(t, ["className"]),
      r = nn();
    return T.jsx("div", Z({ className: r("stack", [y6, e]) }, n));
  },
  bce = function () {
    var t = _.useContext(bw),
      e = t.theme,
      n = t.id,
      r = t.mode;
    return { theme: e, themeId: n, themeMode: r };
  },
  j_ = function (t, e) {
    if (t.length !== e.length) return !1;
    for (var n = !0, r = 0; r < t.length; r++)
      if (t[r] !== e[r]) {
        n = !1;
        break;
      }
    return n;
  },
  vv = function (t, e) {
    var n = e.line,
      r = e.column;
    return t.line(n).from + (r ?? 0) - 1;
  },
  xce = function () {
    return re.theme({
      "&": {
        backgroundColor: "var(--".concat(it, "-colors-surface1)"),
        color: "var(--".concat(it, "-syntax-color-plain)"),
        height: "100%",
      },
      ".cm-matchingBracket, .cm-nonmatchingBracket, &.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
        color: "inherit",
        backgroundColor: "rgba(128,128,128,.25)",
        backgroundBlendMode: "difference",
      },
      "&.cm-editor.cm-focused": { outline: "none" },
      ".cm-activeLine": { backgroundColor: "var(--".concat(it, "-colors-surface3)"), borderRadius: "var(--".concat(it, "-border-radius)") },
      ".cm-errorLine": {
        backgroundColor: "var(--".concat(it, "-colors-errorSurface)"),
        borderRadius: "var(--".concat(it, "-border-radius)"),
      },
      ".cm-content": { caretColor: "var(--".concat(it, "-colors-accent)"), padding: "0 var(--".concat(it, "-space-4)") },
      ".cm-scroller": { fontFamily: "var(--".concat(it, "-font-mono)"), lineHeight: "var(--".concat(it, "-font-lineHeight)") },
      ".cm-gutters": {
        backgroundColor: "var(--".concat(it, "-colors-surface1)"),
        color: "var(--".concat(it, "-colors-disabled)"),
        border: "none",
        paddingLeft: "var(--".concat(it, "-space-1)"),
      },
      ".cm-gutter.cm-lineNumbers": { fontSize: ".6em" },
      ".cm-lineNumbers .cm-gutterElement": {
        lineHeight: "var(--".concat(it, "-font-lineHeight)"),
        minWidth: "var(--".concat(it, "-space-5)"),
      },
      ".cm-content .cm-line": { paddingLeft: "var(--".concat(it, "-space-1)") },
      ".cm-content.cm-readonly .cm-line": { paddingLeft: 0 },
    });
  },
  Kr = function (t) {
    return "".concat(it, "-syntax-").concat(t);
  },
  yce = function () {
    var t = ["string", "plain", "comment", "keyword", "definition", "punctuation", "property", "tag", "static"];
    return t.reduce(function (e, n) {
      var r;
      return Z(
        Z({}, e),
        ((r = {}), (r[".".concat(Kr(n))] = { color: "$syntax$color$".concat(n), fontStyle: "$syntax$fontStyle$".concat(n) }), r)
      );
    }, {});
  },
  wce = function (t) {
    return Va.define([
      { tag: $.link, textDecoration: "underline" },
      { tag: $.emphasis, fontStyle: "italic" },
      { tag: $.strong, fontWeight: "bold" },
      { tag: $.keyword, class: Kr("keyword") },
      { tag: [$.atom, $.number, $.bool], class: Kr("static") },
      { tag: $.variableName, class: Kr("plain") },
      { tag: $.standard($.tagName), class: Kr("tag") },
      { tag: [$.function($.variableName), $.definition($.function($.variableName)), $.tagName], class: Kr("definition") },
      { tag: $.propertyName, class: Kr("property") },
      { tag: [$.literal, $.inserted], class: Kr(t.syntax.string ? "string" : "static") },
      { tag: $.punctuation, class: Kr("punctuation") },
      { tag: [$.comment, $.quote], class: Kr("comment") },
    ]);
  },
  Sce = function (t, e, n) {
    if (!t && !e) return "javascript";
    var r = e;
    if (!r && t) {
      var i = t.lastIndexOf(".");
      r = t.slice(i + 1);
    }
    for (var o = 0, s = n; o < s.length; o++) {
      var l = s[o];
      if (r === l.name || l.extensions.includes(r || "")) return l.name;
    }
    switch (r) {
      case "ts":
      case "tsx":
        return "typescript";
      case "html":
      case "svelte":
      case "vue":
      case "astro":
        return "html";
      case "css":
      case "less":
      case "scss":
        return "css";
      case "js":
      case "jsx":
      case "json":
      default:
        return "javascript";
    }
  },
  kce = function (t, e) {
    for (
      var n = { javascript: Ep({ jsx: !0, typescript: !1 }), typescript: Ep({ jsx: !0, typescript: !0 }), html: mw(), css: ow() },
        r = 0,
        i = e;
      r < i.length;
      r++
    ) {
      var o = i[r];
      if (t === o.name) return o.language;
    }
    return n[t];
  },
  w6 = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return _.useCallback(function (n) {
      return t.forEach(function (r) {
        if (r) {
          if (typeof r == "function") return r(n);
          r.current = n;
        }
      });
    }, t);
  };
function Cce(t) {
  return At.fromClass(
    (function () {
      function e(n) {
        this.decorations = this.getDecoration(n);
      }
      return (
        (e.prototype.update = function (n) {}),
        (e.prototype.getDecoration = function (n) {
          if (!t) return me.none;
          var r = t.map(function (i) {
            var o,
              s,
              l,
              a = me.line({ attributes: { class: (o = i.className) !== null && o !== void 0 ? o : "" } }),
              c = me.mark({
                class: (s = i.className) !== null && s !== void 0 ? s : "",
                attributes: (l = i.elementAttributes) !== null && l !== void 0 ? l : void 0,
              }),
              u = vv(n.state.doc, { line: i.line, column: i.startColumn }) + 1;
            if (i.startColumn && i.endColumn) {
              var h = vv(n.state.doc, { line: i.line, column: i.endColumn }) + 1;
              return c.range(u, h);
            }
            return a.range(u);
          });
          return me.set(r);
        }),
        e
      );
    })(),
    {
      decorations: function (e) {
        return e.decorations;
      },
    }
  );
}
function _ce() {
  return Tce;
}
var Ece = me.line({ attributes: { class: "cm-errorLine" } }),
  Tce = At.fromClass(
    (function () {
      function t() {
        this.decorations = me.none;
      }
      return (
        (t.prototype.update = function (e) {
          var n = this;
          e.transactions.forEach(function (r) {
            var i = r.annotation("show-error");
            if (i !== void 0) {
              var o = vv(e.view.state.doc, { line: i }) + 1;
              n.decorations = me.set([Ece.range(o)]);
            } else r.annotation("remove-errors") && (n.decorations = me.none);
          });
        }),
        t
      );
    })(),
    {
      decorations: function (t) {
        return t.decorations;
      },
    }
  ),
  Ed,
  B1,
  bv = he({
    margin: "0",
    display: "block",
    fontFamily: "$font$mono",
    fontSize: "$font$size",
    color: "$syntax$color$plain",
    lineHeight: "$font$lineHeight",
  }),
  Z_ = he(yce()),
  S6 = he(
    ((Ed = { flex: 1, position: "relative", overflow: "auto", background: "$colors$surface1", ".cm-scroller": { padding: "$space$4 0" } }),
    (Ed[".".concat(bv)] = { padding: "$space$4 0" }),
    (Ed["@media screen and (max-width: 768px)"] = {
      "@supports (-webkit-overflow-scrolling: touch)": { ".cm-content": { fontSize: "16px" } },
    }),
    Ed)
  ),
  z_ = he({ margin: "0", outline: "none", height: "100%" }),
  Pce = he(
    ((B1 = {
      fontFamily: "$font$mono",
      fontSize: "0.8em",
      position: "absolute",
      right: "$space$2",
      bottom: "$space$2",
      zIndex: "$top",
      color: "$colors$clickable",
      backgroundColor: "$colors$surface2",
      borderRadius: "99999px",
      padding: "calc($space$1 / 2) $space$2",
    }),
    (B1["& + .".concat($n)] = { right: "calc($space$11 * 2)" }),
    B1)
  ),
  Ace = function (t) {
    var e = t.langSupport,
      n = t.highlightTheme,
      r = t.code,
      i = r === void 0 ? "" : r,
      o = e.language.parser.parse(i),
      s = 0,
      l = [],
      a = function (c, u) {
        if (c > s) {
          var h = i.slice(s, c);
          l.push(u ? _.createElement("span", { children: h, className: u, key: "".concat(c).concat(s) }) : h), (s = c);
        }
      };
    return (
      c4(o, n, function (c, u, h) {
        a(c, ""), a(u, h);
      }),
      s < i.length &&
        i != null &&
        i.includes(`
`) &&
        l.push(`

`),
      l
    );
  },
  ww = _.forwardRef(function (t, e) {
    var n = t.code,
      r = n === void 0 ? "" : n,
      i = t.filePath,
      o = t.fileType,
      s = t.onCodeUpdate,
      l = t.showLineNumbers,
      a = l === void 0 ? !1 : l,
      c = t.showInlineErrors,
      u = c === void 0 ? !1 : c,
      h = t.wrapContent,
      d = h === void 0 ? !1 : h,
      f = t.editorState,
      p = f === void 0 ? "pristine" : f,
      m = t.readOnly,
      O = m === void 0 ? !1 : m,
      v = t.showReadOnly,
      g = v === void 0 ? !0 : v,
      b = t.decorators,
      x = t.initMode,
      k = x === void 0 ? "lazy" : x,
      w = t.extensions,
      y = w === void 0 ? [] : w,
      C = t.extensionsKeymap,
      P = C === void 0 ? [] : C,
      E = t.additionalLanguages,
      N = E === void 0 ? [] : E,
      L = _.useRef(null),
      D = w6(L, e),
      Q = _.useRef(),
      R = bce(),
      W = R.theme,
      B = R.themeId,
      K = _.useState(r),
      ne = K[0],
      A = K[1],
      V = _.useState(k === "immediate"),
      ie = V[0],
      M = V[1],
      fe = nn(),
      Se = Mt(),
      pe = Se.listen,
      Y = Se.sandpack.autoReload,
      q = _.useRef([]),
      oe = _.useRef([]),
      ce = tse(L, { rootMargin: "600px 0px", threshold: 0.2 }).isIntersecting;
    _.useImperativeHandle(e, function () {
      return {
        getCodemirror: function () {
          return Q.current;
        },
      };
    }),
      _.useEffect(
        function () {
          var We = k === "lazy" || k === "user-visible";
          We && ce && M(!0);
        },
        [k, ce]
      );
    var Oe = Sce(i, o, N),
      _e = kce(Oe, N),
      Le = wce(W),
      Ge = Ace({ langSupport: _e, highlightTheme: Le, code: r }),
      Ct = _.useMemo(
        function () {
          return (
            b &&
            b.sort(function (We, Ne) {
              return We.line - Ne.line;
            })
          );
        },
        [b]
      );
    _.useEffect(
      function () {
        if (!(!L.current || !ie)) {
          var We = L.current,
            Ne = We.querySelector(".sp-pre-placeholder");
          Ne && We.removeChild(Ne);
          var je = new re({
            doc: r,
            extensions: [],
            parent: We,
            dispatch: function (Ie) {
              if ((je.update([Ie]), Ie.docChanged)) {
                var Ft = Ie.newDoc.sliceString(0, Ie.newDoc.length);
                A(Ft), s == null || s(Ft);
              }
            },
          });
          return (
            je.contentDOM.setAttribute("data-gramm", "false"),
            je.contentDOM.setAttribute("data-lt-active", "false"),
            je.contentDOM.setAttribute("aria-label", i ? "Code Editor for ".concat(Tp(i)) : "Code Editor"),
            O ? je.contentDOM.classList.add("cm-readonly") : je.contentDOM.setAttribute("tabIndex", "-1"),
            (Q.current = je),
            function () {
              var Ie;
              (Ie = Q.current) === null || Ie === void 0 || Ie.destroy();
            }
          );
        }
      },
      [ie]
    ),
      _.useEffect(
        function () {
          if (Q.current) {
            var We = [
                {
                  key: "Tab",
                  run: function (je) {
                    var Ie, Ft;
                    CR(je);
                    var Tt = P.find(function (Je) {
                      var rn = Je.key;
                      return rn === "Tab";
                    });
                    return (Ft = (Ie = Tt == null ? void 0 : Tt.run) === null || Ie === void 0 ? void 0 : Ie.call(Tt, je)) !== null &&
                      Ft !== void 0
                      ? Ft
                      : !0;
                  },
                },
                {
                  key: "Shift-Tab",
                  run: function (je) {
                    var Ie, Ft;
                    _R({ state: je.state, dispatch: je.dispatch });
                    var Tt = P.find(function (Je) {
                      var rn = Je.key;
                      return rn === "Shift-Tab";
                    });
                    return (Ft = (Ie = Tt == null ? void 0 : Tt.run) === null || Ie === void 0 ? void 0 : Ie.call(Tt, je)) !== null &&
                      Ft !== void 0
                      ? Ft
                      : !0;
                  },
                },
                {
                  key: "Escape",
                  run: function () {
                    return O || (L.current && L.current.focus()), !0;
                  },
                },
                { key: "mod-Backspace", run: rw },
              ],
              Ne = mn(
                mn([U7(), G4(), j4()], y, !0),
                [Qs.of(mn(mn(mn(mn(mn([], W4, !0), ER, !0), tR, !0), We, !0), P, !0)), _e, xce(), zy(Le)],
                !1
              );
            O ? (Ne.push(Me.readOnly.of(!0)), Ne.push(re.editable.of(!1))) : (Ne.push(_4()), Ne.push(H7())),
              Ct && Ne.push(Cce(Ct)),
              d && Ne.push(re.lineWrapping),
              a && Ne.push(Jm()),
              u && Ne.push(_ce()),
              Q.current.dispatch({ effects: Ee.reconfigure.of(Ne) });
          }
        },
        [ie, Ct, a, d, B, O, Y]
      ),
      _.useEffect(
        function () {
          var Ne = Q.current,
            je = !j_(y, q.current) || !j_(P, oe.current);
          Ne &&
            je &&
            (Ne.dispatch({ effects: Ee.appendConfig.of(y) }),
            Ne.dispatch({ effects: Ee.appendConfig.of(Qs.of(mn([], P, !0))) }),
            (q.current = y),
            (oe.current = P));
        },
        [y, P]
      ),
      _.useEffect(function () {
        Q.current && p === "dirty" && window.matchMedia("(min-width: 768px)").matches && Q.current.contentDOM.focus();
      }, []),
      _.useEffect(
        function () {
          if (Q.current && typeof r == "string" && r !== ne) {
            var We = Q.current,
              Ne = We.state.selection.ranges.some(function (Ie) {
                var Ft = Ie.to,
                  Tt = Ie.from;
                return Ft > r.length || Tt > r.length;
              })
                ? H.cursor(r.length)
                : We.state.selection,
              je = { from: 0, to: We.state.doc.length, insert: r };
            We.dispatch({ changes: je, selection: Ne });
          }
        },
        [r]
      ),
      _.useEffect(
        function () {
          if (u) {
            var Ne = pe(function (je) {
              var Ie = Q.current;
              je.type === "success"
                ? Ie == null || Ie.dispatch({ annotations: [new Lr("remove-errors", !0)] })
                : je.type === "action" &&
                  je.action === "show-error" &&
                  je.path === i &&
                  je.line &&
                  (Ie == null || Ie.dispatch({ annotations: [new Lr("show-error", je.line)] }));
            });
            return function () {
              return Ne();
            };
          }
        },
        [pe, u]
      );
    var $t = function (We) {
        We.key === "Enter" && Q.current && (We.preventDefault(), Q.current.contentDOM.focus());
      },
      Rt = function () {
        var We = 4;
        return a && (We += 6), O || (We += 1), "var(--".concat(it, "-space-").concat(We, ")");
      };
    return O
      ? T.jsxs(T.Fragment, {
          children: [
            T.jsx("pre", {
              ref: D,
              className: fe("cm", [fe(p), fe(Oe), z_, Z_]),
              translate: "no",
              children: T.jsx("code", { className: fe("pre-placeholder", [bv]), style: { marginLeft: Rt() }, children: Ge }),
            }),
            O && g && T.jsx("span", Z({ className: fe("read-only", [Pce]) }, {}, { children: "Read-only" })),
          ],
        })
      : T.jsx("div", {
          ref: D,
          "aria-autocomplete": "list",
          "aria-label": i ? "Code Editor for ".concat(Tp(i)) : "Code Editor",
          "aria-multiline": "true",
          className: fe("cm", [fe(p), fe(Oe), z_, Z_]),
          onKeyDown: $t,
          role: "textbox",
          tabIndex: 0,
          translate: "no",
          suppressHydrationWarning: !0,
          children: T.jsx("pre", { className: fe("pre-placeholder", [bv]), style: { marginLeft: Rt() }, children: Ge }),
        });
  }),
  $ce = _.forwardRef(function (t, e) {
    var n = t.showTabs,
      r = t.showLineNumbers,
      i = r === void 0 ? !1 : r,
      o = t.showInlineErrors,
      s = o === void 0 ? !1 : o,
      l = t.showRunButton,
      a = l === void 0 ? !0 : l,
      c = t.wrapContent,
      u = c === void 0 ? !1 : c,
      h = t.closableTabs,
      d = h === void 0 ? !1 : h,
      f = t.initMode,
      p = t.extensions,
      m = t.extensionsKeymap,
      O = t.readOnly,
      v = t.showReadOnly,
      g = t.additionalLanguages,
      b = t.className,
      x = Wt(t, [
        "showTabs",
        "showLineNumbers",
        "showInlineErrors",
        "showRunButton",
        "wrapContent",
        "closableTabs",
        "initMode",
        "extensions",
        "extensionsKeymap",
        "readOnly",
        "showReadOnly",
        "additionalLanguages",
        "className",
      ]),
      k = Mt().sandpack,
      w = g6(),
      y = w.code,
      C = w.updateCode,
      P = w.readOnly,
      E = k.activeFile,
      N = k.status,
      L = k.editorState,
      D = n ?? k.visibleFiles.length > 1,
      Q = nn(),
      R = function (W, B) {
        B === void 0 && (B = !0), C(W, B);
      };
    return T.jsxs(
      cg,
      Z({ className: Q("editor", [b]) }, x, {
        children: [
          D && T.jsx(b6, { closableTabs: d }),
          T.jsxs("div", {
            className: Q("code-editor", [S6]),
            children: [
              T.jsx(
                ww,
                {
                  ref: e,
                  additionalLanguages: g,
                  code: y,
                  editorState: L,
                  extensions: p,
                  extensionsKeymap: m,
                  filePath: E,
                  initMode: f || k.initMode,
                  onCodeUpdate: function (W) {
                    var B;
                    return R(W, (B = k.autoReload) !== null && B !== void 0 ? B : !0);
                  },
                  readOnly: O || P,
                  showInlineErrors: s,
                  showLineNumbers: i,
                  showReadOnly: v,
                  wrapContent: u,
                },
                E
              ),
              a && (!k.autoReload || N === "idle") ? T.jsx(x6, {}) : null,
            ],
          }),
        ],
      })
    );
  });
_.forwardRef(function (t, e) {
  var n = t.showTabs,
    r = t.showLineNumbers,
    i = t.decorators,
    o = t.code,
    s = t.initMode,
    l = t.wrapContent,
    a = t.additionalLanguages,
    c = Wt(t, ["showTabs", "showLineNumbers", "decorators", "code", "initMode", "wrapContent", "additionalLanguages"]),
    u = Mt().sandpack,
    h = g6().code,
    d = nn(),
    f = n ?? u.visibleFiles.length > 1;
  return T.jsxs(
    cg,
    Z({ className: d("editor-viewer") }, c, {
      children: [
        f ? T.jsx(b6, {}) : null,
        T.jsx("div", {
          className: d("code-editor", [S6]),
          children: T.jsx(ww, {
            ref: e,
            additionalLanguages: a,
            code: o ?? h,
            decorators: i,
            filePath: u.activeFile,
            initMode: s || u.initMode,
            showLineNumbers: r,
            showReadOnly: !1,
            wrapContent: l,
            readOnly: !0,
          }),
        }),
        u.status === "idle" ? T.jsx(x6, {}) : null,
      ],
    })
  );
});
var Td,
  Pd,
  Rce = he(
    ((Td = {
      border: "1px solid $colors$surface2",
      display: "flex",
      flexWrap: "wrap",
      alignItems: "stretch",
      borderRadius: "$border$radius",
      overflow: "hidden",
      position: "relative",
      backgroundColor: "$colors$surface2",
      gap: 1,
    }),
    (Td["> .".concat(y6)] = {
      flexGrow: 1,
      flexShrink: 1,
      flexBasis: "0",
      height: "$layout$height",
      overflow: "hidden",
      "@media print": { height: "auto", display: "block" },
      "@media screen and (max-width: 768px)":
        ((Pd = {}),
        (Pd["&:not(.".concat(it, "-preview, .").concat(it, "-editor, .").concat(it, "-preset-column)")] = {
          height: "calc($layout$height / 2)",
        }),
        (Pd.minWidth = "100%;"),
        Pd),
    }),
    (Td["> .".concat(it, "-file-explorer")] = { flex: 0.2, minWidth: 200, "@media screen and (max-width: 768px)": { flex: 1 } }),
    Td)
  ),
  Ice = _.forwardRef(function (t, e) {
    var n = t.children,
      r = t.className,
      i = Wt(t, ["children", "className"]),
      o = Mt().sandpack,
      s = nn(),
      l = w6(o.lazyAnchorRef, e);
    return T.jsx("div", Z({ ref: l, className: s("layout", [Rce, r]) }, i, { children: n }));
  }),
  Mce = function () {
    var t,
      e = Mt().sandpack,
      n = e.error;
    return (t = n == null ? void 0 : n.message) !== null && t !== void 0 ? t : null;
  },
  k6 = 200,
  Lce = function (t, e) {
    var n = Mt(),
      r = n.sandpack,
      i = n.listen,
      o = _.useState("LOADING"),
      s = o[0],
      l = o[1];
    return (
      _.useEffect(
        function () {
          var a = i(function (c) {
            c.type === "start" && c.firstLoad === !0 && l("LOADING"),
              c.type === "done" &&
                l(function (u) {
                  return u === "LOADING" ? "PRE_FADING" : "HIDDEN";
                });
          }, t);
          return function () {
            a();
          };
        },
        [t, r.status === "idle"]
      ),
      _.useEffect(
        function () {
          var a;
          return (
            s === "PRE_FADING" && !e
              ? l("FADING")
              : s === "FADING" &&
                (a = setTimeout(function () {
                  return l("HIDDEN");
                }, k6)),
            function () {
              clearTimeout(a);
            }
          );
        },
        [s, e]
      ),
      r.status === "timeout" ? "TIMEOUT" : r.status !== "running" ? "HIDDEN" : s
    );
  },
  Nce = function (t) {
    var e = Mt().dispatch;
    return {
      refresh: function () {
        return e({ type: "refresh" }, t);
      },
      back: function () {
        return e({ type: "urlback" }, t);
      },
      forward: function () {
        return e({ type: "urlforward" }, t);
      },
    };
  },
  C6 = function (t) {
    var e = Mt(),
      n = e.sandpack,
      r = e.listen,
      i = e.dispatch,
      o = _.useRef(null),
      s = _.useRef(Pp());
    _.useEffect(function () {
      var a = o.current,
        c = s.current;
      return (
        a !== null && n.registerBundler(a, c, t),
        function () {
          return n.unregisterBundler(c);
        }
      );
    }, []);
    var l = function () {
      return n.clients[s.current] || null;
    };
    return {
      sandpack: n,
      getClient: l,
      clientId: s.current,
      iframe: o,
      listen: function (a) {
        return r(a, s.current);
      },
      dispatch: function (a) {
        return i(a, s.current);
      },
    };
  },
  Sw = function (t) {
    var e = Mt().dispatch;
    return {
      restart: function () {
        return e({ type: "shell/restart" }, t);
      },
      openPreview: function () {
        return e({ type: "shell/openPreview" }, t);
      },
    };
  },
  Qce = function (t, e) {
    var n;
    switch (t.state) {
      case "downloading_manifest":
        return "[1/3] Downloading manifest";
      case "downloaded_module":
        return "[2/3] Downloaded "
          .concat(t.name, " (")
          .concat(e - t.totalPending, "/")
          .concat(e, ")");
      case "starting_command":
        return "[3/3] Starting command";
      case "command_running":
        return '[3/3] Running "'.concat((n = t.command) === null || n === void 0 ? void 0 : n.trim(), '"');
    }
  },
  _6 = function (t) {
    var e = _.useState(!1),
      n = e[0],
      r = e[1],
      i = _.useState(),
      o = i[0],
      s = i[1],
      l = _.useState(null),
      a = l[0],
      c = l[1],
      u = t == null ? void 0 : t.timeout,
      h = t == null ? void 0 : t.clientId,
      d = Mt().listen;
    return (
      _.useEffect(
        function () {
          var f,
            p = d(function (m) {
              m.type === "start" && m.firstLoad && r(!1),
                u &&
                  (f = setTimeout(function () {
                    c(null);
                  }, u)),
                m.type === "dependencies"
                  ? c(function () {
                      switch (m.data.state) {
                        case "downloading_manifest":
                          return "[1/3] Downloading manifest";
                        case "downloaded_module":
                          return "[2/3] Downloaded ".concat(m.data.name, " (").concat(m.data.progress, "/").concat(m.data.total, ")");
                        case "starting":
                          return "[3/3] Starting";
                      }
                      return null;
                    })
                  : m.type === "shell/progress" &&
                    !n &&
                    (!o && m.data.state === "downloaded_module" && s(m.data.totalPending), o !== void 0 && c(Qce(m.data, o))),
                m.type === "done" && m.compilatonError === !1 && (c(null), r(!0), clearTimeout(f));
            }, h);
          return function () {
            f && clearTimeout(f), p();
          };
        },
        [h, n, o, u]
      ),
      a
    );
  },
  Dce = 400 * 2,
  E6 = function (t) {
    var e = t.clientId,
      n = t.maxMessageCount,
      r = n === void 0 ? Dce : n;
    t.resetOnPreviewRestart;
    var i = _.useState([]),
      o = i[0],
      s = i[1],
      l = Mt().listen;
    return (
      _.useEffect(
        function () {
          var a = l(function (c) {
            c.type === "start"
              ? s([])
              : c.type === "stdout" &&
                c.payload.data &&
                c.payload.data.trim() &&
                s(function (u) {
                  for (var h = mn(mn([], u, !0), [{ data: c.payload.data, id: Pp() }], !1); h.length > r; ) h.shift();
                  return h;
                });
          }, e);
          return a;
        },
        [r, e]
      ),
      {
        logs: o,
        reset: function () {
          return s([]);
        },
      }
    );
  },
  Fce = function (t) {
    var e = t.replace("[sandpack-client]: ", "");
    if (/process.exit/.test(e)) {
      var n = e.match(/process.exit\((\d+)\)/);
      return n
        ? Number(n[1]) === 0
          ? "Server is not running, would you like to start it again?"
          : "Server has crashed with status code ".concat(n[1], ", would you like to restart the server?")
        : e;
    }
    return e;
  },
  Bce = function (t) {
    var e = t.children,
      n = t.className,
      r = Wt(t, ["children", "className"]),
      i = Mce(),
      o = Sw().restart,
      s = nn(),
      l = Mt().sandpack,
      a = l.runSandpack,
      c = l.teamId,
      u = Mt().dispatch;
    if (!i && !e) return null;
    var h = i == null ? void 0 : i.startsWith("[sandpack-client]"),
      d = i == null ? void 0 : i.includes("NPM_REGISTRY_UNAUTHENTICATED_REQUEST"),
      f = function () {
        c && u({ type: "sign-in", teamId: c });
      };
    return d
      ? T.jsxs(
          "div",
          Z({ className: s("overlay", [s("error"), Xc, Ov, n]) }, t, {
            children: [
              T.jsx("p", {
                className: s("error-message", [Oo]),
                children: T.jsx("strong", { children: "Unable to fetch required dependency." }),
              }),
              T.jsx("div", {
                className: s("error-message", [Oo]),
                children: T.jsxs("p", {
                  children: [
                    "Authentication required. Please sign in to your account (make sure to allow pop-ups to this page) and try again. If the issue persists, contact",
                    " ",
                    T.jsx("a", { href: "mailto:hello@codesandbox.io?subject=Sandpack Timeout Error", children: "support" }),
                    " ",
                    "for further assistance.",
                  ],
                }),
              }),
              T.jsx("div", {
                children: T.jsxs("button", {
                  className: s("button", [$n, ji, Vs]),
                  onClick: f,
                  children: [T.jsx(vae, {}), T.jsx("span", { children: "Sign in" })],
                }),
              }),
            ],
          })
        )
      : h && i
      ? T.jsx(
          "div",
          Z({ className: s("overlay", [s("error"), Xc, Ov, n]) }, r, {
            children: T.jsxs("div", {
              className: s("error-message", [Oo]),
              children: [
                T.jsx("p", { className: s("error-title", [he({ fontWeight: "bold" })]), children: "Couldn't connect to server" }),
                T.jsx("p", { children: Fce(i) }),
                T.jsx("div", {
                  children: T.jsxs("button", {
                    className: s("button", [s("icon-standalone"), $n, ji, Vs]),
                    onClick: function () {
                      o(), a();
                    },
                    title: "Restart script",
                    type: "button",
                    children: [T.jsx(ag, {}), " ", T.jsx("span", { children: "Restart" })],
                  }),
                }),
              ],
            }),
          })
        )
      : T.jsxs(
          "div",
          Z({ className: s("overlay", [s("error"), Xc, O6({ solidBg: !0 }), n]), translate: "no" }, r, {
            children: [
              T.jsx("p", { className: s("error-message", [Oo]), children: T.jsx("strong", { children: "Something went wrong" }) }),
              T.jsx("p", { className: s("error-message", [Oo({ errorCode: !0 })]), children: i || e }),
            ],
          })
        );
  };
function Vce(t, e) {
  return e === void 0 && (e = !1), (t = mae(Xce(t))), dae.ansiToJson(t, { json: !0, remove_empty: !0, use_classes: e });
}
function jce(t) {
  var e = "";
  return (
    t.bg && (e += "".concat(t.bg, "-bg ")),
    t.fg && (e += "".concat(t.fg, "-fg ")),
    t.decoration && (e += "ansi-".concat(t.decoration, " ")),
    e === "" ? null : ((e = e.substring(0, e.length - 1)), e)
  );
}
function Zce(t) {
  var e = {};
  switch ((t.bg && (e.backgroundColor = "rgb(".concat(t.bg, ")")), t.fg && (e.color = "rgb(".concat(t.fg, ")")), t.decoration)) {
    case "bold":
      e.fontWeight = "bold";
      break;
    case "dim":
      e.opacity = "0.5";
      break;
    case "italic":
      e.fontStyle = "italic";
      break;
    case "hidden":
      e.visibility = "hidden";
      break;
    case "strikethrough":
      e.textDecoration = "line-through";
      break;
    case "underline":
      e.textDecoration = "underline";
      break;
    case "blink":
      e.textDecoration = "blink";
      break;
  }
  return e;
}
function zce(t, e, n, r) {
  var i = e ? null : Zce(n),
    o = e ? jce(n) : null;
  if (!t) return _.createElement("span", { style: i, key: r, className: o }, n.content);
  for (
    var s = [], l = /(\s|^)(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/g, a = 0, c;
    (c = l.exec(n.content)) !== null;

  ) {
    var u = c[1],
      h = c[2],
      d = c.index + u.length;
    d > a && s.push(n.content.substring(a, d));
    var f = h.startsWith("www.") ? "http://".concat(h) : h;
    s.push(_.createElement("a", { key: a, href: f, target: "_blank" }, "".concat(h))), (a = l.lastIndex);
  }
  return a < n.content.length && s.push(n.content.substring(a)), _.createElement("span", { style: i, key: r, className: o }, s);
}
function Wce(t) {
  var e = t.className,
    n = t.useClasses,
    r = t.children,
    i = t.linkify;
  return _.createElement("code", { className: e }, Vce(r ?? "", n ?? !1).map(zce.bind(null, i ?? !1, n ?? !1)));
}
function Xce(t) {
  var e = t;
  do (t = e), (e = t.replace(/[^\n]\x08/gm, ""));
  while (e.length < t.length);
  return t;
}
var T6 = function (t) {
    var e = t.data,
      n = nn();
    return T.jsx(T.Fragment, {
      children: e.map(function (r) {
        var i = r.data,
          o = r.id;
        return T.jsx("div", { className: n("console-item", [Uce]), children: T.jsx(Wce, { children: i }) }, o);
      }),
    });
  },
  Uce = he({
    width: "100%",
    padding: "$space$3 $space$2",
    fontSize: ".85em",
    position: "relative",
    whiteSpace: "pre",
    "&:not(:first-child):after": {
      content: "",
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      height: 1,
      background: "$colors$surface3",
    },
  }),
  Hce = function (t) {
    return Oae.compressToBase64(JSON.stringify(t)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  },
  W_ = "https://codesandbox.io/api/v1/sandboxes/define",
  qce = function (t, e) {
    var n = Object.keys(t).reduce(function (r, i) {
      var o,
        s = i.replace("/", ""),
        l = { content: t[i].code, isBinary: !1 };
      return Z(Z({}, r), ((o = {}), (o[s] = l), o));
    }, {});
    return Hce(Z({ files: n }, e ? { template: e } : null));
  },
  Yce = function (t) {
    var e = Mt().sandpack;
    return e.exportOptions ? T.jsx(Gce, Z({ state: e }, t)) : T.jsx(Jce, Z({ state: e }, t));
  },
  Gce = function (t) {
    var e = t.children,
      n = t.state,
      r = Wt(t, ["children", "state"]),
      i = function () {
        return Ec(void 0, void 0, void 0, function () {
          var o, s, l, a;
          return Tc(this, function (c) {
            switch (c.label) {
              case 0:
                if (!(!((a = n.exportOptions) === null || a === void 0) && a.apiToken)) throw new Error("Missing `apiToken` property");
                return (
                  (o = Object.keys(n.files).reduce(function (u, h) {
                    var d,
                      f = h.replace("/", "");
                    return Z(Z({}, u), ((d = {}), (d[f] = n.files[h]), d));
                  }, {})),
                  [
                    4,
                    fetch("https://api.codesandbox.io/sandbox", {
                      method: "POST",
                      body: JSON.stringify({ template: n.environment, files: o, privacy: n.exportOptions.privacy === "public" ? 0 : 2 }),
                      headers: {
                        Authorization: "Bearer ".concat(n.exportOptions.apiToken),
                        "Content-Type": "application/json",
                        "X-CSB-API-Version": "2023-07-01",
                      },
                    }),
                  ]
                );
              case 1:
                return (s = c.sent()), [4, s.json()];
              case 2:
                return (
                  (l = c.sent()),
                  window.open(
                    "https://codesandbox.io/p/sandbox/".concat(l.data.alias, "?file=/").concat(n.activeFile, "&utm-source=storybook-addon"),
                    "_blank"
                  ),
                  [2]
                );
            }
          });
        });
      };
    return T.jsx("button", Z({ onClick: i, title: "Export to workspace in CodeSandbox", type: "button" }, r, { children: e }));
  },
  Jce = function (t) {
    var e,
      n,
      r,
      i = t.children,
      o = t.state,
      s = Wt(t, ["children", "state"]),
      l = _.useRef(null),
      a = _.useState(),
      c = a[0],
      u = a[1];
    return (
      _.useEffect(
        function () {
          var d = setTimeout(function () {
            var f = qce(o.files, o.environment),
              p = new URLSearchParams({
                parameters: f,
                query: new URLSearchParams({ file: o.activeFile, utm_medium: "sandpack" }).toString(),
              });
            u(p);
          }, 600);
          return function () {
            clearTimeout(d);
          };
        },
        [o.activeFile, o.environment, o.files]
      ),
      ((r =
        (n = (e = c == null ? void 0 : c.get) === null || e === void 0 ? void 0 : e.call(c, "parameters")) === null || n === void 0
          ? void 0
          : n.length) !== null && r !== void 0
        ? r
        : 0) > 1500
        ? T.jsxs(
            "button",
            Z(
              {
                onClick: function () {
                  var h;
                  return (h = l.current) === null || h === void 0 ? void 0 : h.submit();
                },
                title: "Open in CodeSandbox",
                type: "button",
              },
              s,
              {
                children: [
                  T.jsxs("form", {
                    ref: l,
                    action: W_,
                    method: "POST",
                    style: { visibility: "hidden" },
                    target: "_blank",
                    children: [
                      T.jsx("input", { name: "environment", type: "hidden", value: o.environment === "node" ? "server" : o.environment }),
                      Array.from(c, function (h) {
                        var d = h[0],
                          f = h[1];
                        return T.jsx("input", { name: d, type: "hidden", value: f }, d);
                      }),
                    ],
                  }),
                  i,
                ],
              }
            )
          )
        : T.jsx(
            "a",
            Z(
              {
                href: ""
                  .concat(W_, "?")
                  .concat(c == null ? void 0 : c.toString(), "&environment=")
                  .concat(o.environment === "node" ? "server" : o.environment),
                rel: "noreferrer noopener",
                target: "_blank",
                title: "Open in CodeSandbox",
              },
              s,
              { children: i }
            )
          )
    );
  },
  P6 = function () {
    var t = nn();
    return T.jsxs(Yce, {
      className: t("button", [t("icon-standalone"), $n, ji, Vs]),
      children: [T.jsx(kae, {}), T.jsx("span", { children: "Open Sandbox" })],
    });
  },
  hs,
  xv = he({ transform: "translate(-4px, 9px) scale(0.13, 0.13)", "*": { position: "absolute", width: "96px", height: "96px" } }),
  Kce = he(
    ((hs = {
      position: "absolute",
      right: "$space$2",
      bottom: "$space$2",
      zIndex: "$top",
      width: "32px",
      height: "32px",
      borderRadius: "$border$radius",
    }),
    (hs[".".concat(xv)] = { display: "flex" }),
    (hs[".sp-button.".concat($n)] = { display: "none" }),
    (hs["&:hover .sp-button.".concat($n)] = { display: "flex" }),
    (hs["&:hover .sp-button.".concat($n, " > span")] = { display: "none" }),
    (hs["&:hover .".concat(xv)] = { display: "none" }),
    hs)
  ),
  eue = p6({ "0%": { transform: "rotateX(-25.5deg) rotateY(45deg)" }, "100%": { transform: "rotateX(-25.5deg) rotateY(405deg)" } }),
  tue = he({
    animation: "".concat(eue, " 1s linear infinite"),
    animationFillMode: "forwards",
    transformStyle: "preserve-3d",
    transform: "rotateX(-25.5deg) rotateY(45deg)",
    "*": { border: "10px solid $colors$clickable", borderRadius: "8px", background: "$colors$surface1" },
    ".top": { transform: "rotateX(90deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".bottom": { transform: "rotateX(-90deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".front": { transform: "rotateY(0deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".back": { transform: "rotateY(-180deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".left": { transform: "rotateY(-90deg) translateZ(44px)", transformOrigin: "50% 50%" },
    ".right": { transform: "rotateY(90deg) translateZ(44px)", transformOrigin: "50% 50%" },
  }),
  nue = function (t) {
    var e = t.className,
      n = t.showOpenInCodeSandbox,
      r = Wt(t, ["className", "showOpenInCodeSandbox"]),
      i = nn();
    return T.jsxs(
      "div",
      Z({ className: i("cube-wrapper", [Kce, e]), title: "Open in CodeSandbox" }, r, {
        children: [
          n && T.jsx(P6, {}),
          T.jsx("div", {
            className: i("cube", [xv]),
            children: T.jsxs("div", {
              className: i("sides", [tue]),
              children: [
                T.jsx("div", { className: "top" }),
                T.jsx("div", { className: "right" }),
                T.jsx("div", { className: "bottom" }),
                T.jsx("div", { className: "left" }),
                T.jsx("div", { className: "front" }),
                T.jsx("div", { className: "back" }),
              ],
            }),
          }),
        ],
      })
    );
  },
  rue = he({ backgroundColor: "$colors$surface1" }),
  iue = function (t) {
    var e = t.clientId,
      n = t.loading,
      r = t.className,
      i = t.style,
      o = t.showOpenInCodeSandbox,
      s = Wt(t, ["clientId", "loading", "className", "style", "showOpenInCodeSandbox"]),
      l = nn(),
      a = Mt().sandpack,
      c = a.runSandpack,
      u = a.environment,
      h = _.useState(!1),
      d = h[0],
      f = h[1],
      p = Lce(e, n),
      m = _6({ clientId: e }),
      O = E6({ clientId: e }).logs;
    if (
      (_.useEffect(
        function () {
          var g;
          return (
            m != null &&
              m.includes("Running") &&
              (g = setTimeout(function () {
                f(!0);
              }, 3e3)),
            function () {
              g && clearTimeout(g);
            }
          );
        },
        [m]
      ),
      p === "HIDDEN")
    )
      return null;
    if (p === "TIMEOUT")
      return T.jsx(
        "div",
        Z({ className: l("overlay", [l("error"), Xc, O6, Ov, r]) }, s, {
          children: T.jsxs("div", {
            className: l("error-message", [Oo]),
            children: [
              T.jsx("p", { className: l("error-title", [he({ fontWeight: "bold" })]), children: "Couldn't connect to server" }),
              T.jsx("div", {
                className: l("error-message", [Oo]),
                children: T.jsxs("p", {
                  children: [
                    "This means sandpack cannot connect to the runtime or your network is having some issues. Please check the network tab in your browser and try again. If the problem persists, report it via",
                    " ",
                    T.jsx("a", { href: "mailto:hello@codesandbox.io?subject=Sandpack Timeout Error", children: "email" }),
                    " ",
                    "or submit an issue on",
                    " ",
                    T.jsx("a", {
                      href: "https://github.com/codesandbox/sandpack/issues",
                      rel: "noreferrer noopener",
                      target: "_blank",
                      children: "GitHub.",
                    }),
                  ],
                }),
              }),
              T.jsxs("p", {
                className: l("error-message", [Oo({ errorCode: !0 })]),
                children: ["ENV: ", u, T.jsx("br", {}), "ERROR: TIME_OUT"],
              }),
              T.jsx("div", {
                children: T.jsxs("button", {
                  className: l("button", [l("icon-standalone"), $n, ji, Vs]),
                  onClick: c,
                  title: "Restart script",
                  type: "button",
                  children: [T.jsx(ag, {}), " ", T.jsx("span", { children: "Try again" })],
                }),
              }),
            ],
          }),
        })
      );
    var v = p === "LOADING" || p === "PRE_FADING";
    return T.jsxs(T.Fragment, {
      children: [
        T.jsxs(
          "div",
          Z(
            {
              className: l("overlay", [l("loading"), Xc, rue, r]),
              style: Z(Z({}, i), { opacity: v ? 1 : 0, transition: "opacity ".concat(k6, "ms ease-out") }),
            },
            s,
            {
              children: [
                d && T.jsx("div", { className: oue.toString(), children: T.jsx(T6, { data: O }) }),
                T.jsx(nue, { showOpenInCodeSandbox: o }),
              ],
            }
          )
        ),
        m && T.jsx("div", { className: sue.toString(), children: T.jsx("p", { children: m }) }),
      ],
    });
  },
  oue = he({ position: "absolute", left: 0, right: 0, bottom: "$space$8", overflow: "auto", opacity: 0.5, overflowX: "hidden" }),
  sue = he({
    position: "absolute",
    left: "$space$5",
    bottom: "$space$4",
    zIndex: "$top",
    color: "$colors$clickable",
    animation: "".concat(yw, " 150ms ease"),
    fontFamily: "$font$mono",
    fontSize: ".8em",
    width: "75%",
    p: { whiteSpace: "nowrap", margin: 0, textOverflow: "ellipsis", overflow: "hidden" },
  }),
  lue = function (t) {
    var e = t.clientId,
      n = _6({ timeout: 3e3, clientId: e });
    return n ? T.jsx("div", { className: aue.toString(), children: T.jsx("p", { children: n }) }) : null;
  },
  aue = he({
    position: "absolute",
    left: "$space$5",
    bottom: "$space$4",
    zIndex: "$top",
    color: "$colors$clickable",
    animation: "".concat(yw, " 150ms ease"),
    fontFamily: "$font$mono",
    fontSize: ".8em",
    width: "75%",
    p: { whiteSpace: "nowrap", margin: 0, textOverflow: "ellipsis", overflow: "hidden" },
  });
he({
  borderRadius: "0",
  width: "100%",
  padding: 0,
  marginBottom: "$space$2",
  span: { textOverflow: "ellipsis", whiteSpace: "nowrap", overflow: "hidden" },
  svg: { marginRight: "$space$1" },
});
he({ padding: "$space$3", overflow: "auto", height: "100%" });
var cue = function (t) {
    var e = t.match(/(https?:\/\/.*?)\//);
    return e && e[1] ? [e[1], t.replace(e[1], "")] : [t, "/"];
  },
  uue = he({
    display: "flex",
    alignItems: "center",
    height: "$layout$headerHeight",
    borderBottom: "1px solid $colors$surface2",
    padding: "$space$3 $space$2",
    background: "$colors$surface1",
  }),
  hue = he({
    backgroundColor: "$colors$surface2",
    color: "$colors$clickable",
    padding: "$space$1 $space$3",
    borderRadius: "99999px",
    border: "1px solid $colors$surface2",
    height: "24px",
    lineHeight: "24px",
    fontSize: "inherit",
    outline: "none",
    flex: 1,
    marginLeft: "$space$4",
    width: "0",
    transition: "background $transitions$default",
    "&:hover": { backgroundColor: "$colors$surface3" },
    "&:focus": { backgroundColor: "$surface1", border: "1px solid $colors$accent", color: "$colors$base" },
  }),
  due = function (t) {
    var e,
      n = t.clientId,
      r = t.onURLChange,
      i = t.className,
      o = t.startRoute,
      s = Wt(t, ["clientId", "onURLChange", "className", "startRoute"]),
      l = _.useState(""),
      a = l[0],
      c = l[1],
      u = Mt(),
      h = u.sandpack,
      d = u.dispatch,
      f = u.listen,
      p = _.useState((e = o ?? h.startRoute) !== null && e !== void 0 ? e : "/"),
      m = p[0],
      O = p[1],
      v = _.useState(!1),
      g = v[0],
      b = v[1],
      x = _.useState(!1),
      k = x[0],
      w = x[1],
      y = nn();
    _.useEffect(function () {
      var Q = f(function (R) {
        if (R.type === "urlchange") {
          var W = R.url,
            B = R.back,
            K = R.forward,
            ne = cue(W),
            A = ne[0],
            V = ne[1];
          c(A), O(V), b(B), w(K);
        }
      }, n);
      return function () {
        return Q();
      };
    }, []);
    var C = function (Q) {
        var R = Q.target.value.startsWith("/") ? Q.target.value : "/".concat(Q.target.value);
        O(R);
      },
      P = function (Q) {
        Q.code === "Enter" && (Q.preventDefault(), Q.stopPropagation(), typeof r == "function" && r(a + Q.currentTarget.value));
      },
      E = function () {
        d({ type: "refresh" });
      },
      N = function () {
        d({ type: "urlback" });
      },
      L = function () {
        d({ type: "urlforward" });
      },
      D = y("button", [y("icon"), $n, pce, he({ minWidth: "$space$6", justifyContent: "center" })]);
    return T.jsxs(
      "div",
      Z({ className: y("navigator", [uue, i]) }, s, {
        children: [
          T.jsx("button", {
            "aria-label": "Go back one page",
            className: D,
            disabled: !g,
            onClick: N,
            type: "button",
            children: T.jsx(yae, {}),
          }),
          T.jsx("button", {
            "aria-label": "Go forward one page",
            className: D,
            disabled: !k,
            onClick: L,
            type: "button",
            children: T.jsx(wae, {}),
          }),
          T.jsx("button", { "aria-label": "Refresh page", className: D, onClick: E, type: "button", children: T.jsx(f6, {}) }),
          T.jsx("input", {
            "aria-label": "Current Sandpack URL",
            className: y("input", [hue]),
            name: "Current Sandpack URL",
            onChange: C,
            onKeyDown: P,
            type: "text",
            value: m,
          }),
        ],
      })
    );
  },
  V1,
  fue = he(
    ((V1 = { flex: 1, display: "flex", flexDirection: "column", background: "white", overflow: "auto", position: "relative" }),
    (V1[".".concat(it, "-bridge-frame")] = {
      border: 0,
      position: "absolute",
      left: "$space$2",
      bottom: "$space$2",
      zIndex: "$top",
      height: 12,
      width: "30%",
      mixBlendMode: "multiply",
      pointerEvents: "none",
    }),
    V1)
  ),
  pue = he({ border: "0", outline: "0", width: "100%", height: "100%", minHeight: "160px", maxHeight: "2000px", flex: 1 }),
  mue = he({ display: "flex", position: "absolute", bottom: "$space$2", right: "$space$2", zIndex: "$overlay", gap: "$space$2" }),
  gue = _.forwardRef(function (t, e) {
    var n = t.showNavigator,
      r = n === void 0 ? !1 : n,
      i = t.showRefreshButton,
      o = i === void 0 ? !0 : i,
      s = t.showOpenInCodeSandbox,
      l = s === void 0 ? !0 : s,
      a = t.showSandpackErrorOverlay,
      c = a === void 0 ? !0 : a;
    t.showOpenNewtab;
    var u = t.showRestartButton,
      h = u === void 0 ? !0 : u,
      d = t.actionsChildren,
      f = d === void 0 ? T.jsx(T.Fragment, {}) : d,
      p = t.children,
      m = t.className,
      O = t.startRoute,
      v = O === void 0 ? "/" : O,
      g = Wt(t, [
        "showNavigator",
        "showRefreshButton",
        "showOpenInCodeSandbox",
        "showSandpackErrorOverlay",
        "showOpenNewtab",
        "showRestartButton",
        "actionsChildren",
        "children",
        "className",
        "startRoute",
      ]),
      b = C6({ startRoute: v }),
      x = b.sandpack,
      k = b.listen,
      w = b.iframe,
      y = b.getClient,
      C = b.clientId,
      P = b.dispatch,
      E = _.useState(null),
      N = E[0],
      L = E[1],
      D = x.status,
      Q = Nce(C).refresh,
      R = Sw(C).restart,
      W = nn();
    _.useEffect(function () {
      var K = k(function (ne) {
        ne.type === "resize" && L(ne.height);
      });
      return K;
    }, []),
      _.useImperativeHandle(
        e,
        function () {
          return { clientId: C, getClient: y };
        },
        [y, C]
      );
    var B = function (K) {
      w.current && (w.current.src = K);
    };
    return T.jsxs(
      cg,
      Z({ className: W("preview", [m]) }, g, {
        children: [
          r && T.jsx(due, { clientId: C, onURLChange: B, startRoute: v }),
          T.jsxs("div", {
            className: W("preview-container", [fue]),
            children: [
              T.jsx("iframe", { ref: w, className: W("preview-iframe", [pue]), style: { height: N || void 0 }, title: "Sandpack Preview" }),
              T.jsxs("div", {
                className: W("preview-actions", [mue]),
                children: [
                  f,
                  h && x.environment === "node" && T.jsx(Nu, { onClick: R, children: T.jsx(ag, {}) }),
                  !r && o && D === "running" && T.jsx(Nu, { onClick: Q, children: T.jsx(f6, {}) }),
                  x.teamId &&
                    T.jsx("button", {
                      className: W("button", [W("icon-standalone"), $n, ji, Vs]),
                      onClick: function () {
                        return P({ type: "sign-out" });
                      },
                      title: "Sign out",
                      type: "button",
                      children: T.jsx(bae, {}),
                    }),
                  l && T.jsx(P6, {}),
                ],
              }),
              T.jsx(iue, { clientId: C, showOpenInCodeSandbox: l }),
              c && T.jsx(Bce, {}),
              p,
            ],
          }),
        ],
      })
    );
  }),
  j1;
he(
  ((j1 = { display: "flex", flexDirection: "column", width: "100%", position: "relative", overflow: "auto", minHeight: "160px", flex: 1 }),
  (j1[".".concat(it, "-stack")] = { height: "100%" }),
  j1)
);
he({
  justifyContent: "space-between",
  borderBottom: "1px solid $colors$surface2",
  padding: "0 $space$2",
  fontFamily: "$font$mono",
  height: "$layout$headerHeight",
  minHeight: "$layout$headerHeight",
  overflowX: "auto",
  whiteSpace: "nowrap",
});
he({ display: "flex", flexDirection: "row", alignItems: "center", gap: "$space$2" });
var ug = he({
  variants: {
    status: {
      pass: { color: "var(--test-pass)" },
      fail: { color: "var(--test-fail)" },
      skip: { color: "var(--test-skip)" },
      title: { color: "var(--test-title)" },
    },
  },
});
ug({ status: "pass" });
ug({ status: "fail" });
ug({ status: "skip" });
ug({ status: "title" });
var kw = he({
  variants: {
    status: {
      pass: { background: "var(--test-pass)", color: "$colors$surface1" },
      fail: { background: "var(--test-fail)", color: "$colors$surface1" },
      run: { background: "var(--test-run)", color: "$colors$surface1" },
    },
  },
});
kw({ status: "run" });
kw({ status: "pass" });
kw({ status: "fail" });
he({ marginLeft: "$space$4" });
he({ marginBottom: "$space$2", color: "$colors$clickable" });
he({ marginBottom: "$space$2", color: "$colors$hover" });
he({ marginLeft: "$space$2" });
he({ marginRight: "$space$2" });
he({ color: "$colors$hover", marginBottom: "$space$2" });
he({ marginLeft: "$space$4" });
he({ color: "$colors$hover", fontSize: "$font$size", padding: "$space$2", whiteSpace: "pre-wrap" });
he({ display: "flex", flexDirection: "row", alignItems: "center", marginBottom: "$space$2" });
he({ marginBottom: "$space$2" });
he({ fontWeight: "bold" });
he({ borderRadius: "calc($border$radius / 2)" });
he({ padding: "$space$1 $space$2", fontFamily: "$font$mono", textTransform: "uppercase", marginRight: "$space$2" });
he({ fontFamily: "$font$mono", cursor: "pointer", display: "inline-block" });
he({ color: "$colors$clickable", textDecorationStyle: "dotted", textDecorationLine: "underline" });
he({ color: "$colors$hover", fontWeight: "bold", textDecorationStyle: "dotted", textDecorationLine: "underline" });
he({ marginBottom: "$space$2" });
he({ fontWeight: "bold", color: "$colors$hover", whiteSpace: "pre-wrap" });
he({ fontWeight: "bold", color: "$colors$clickable" });
he({ display: "flex", position: "absolute", bottom: "$space$2", right: "$space$2", zIndex: "$overlay", "> *": { marginLeft: "$space$2" } });
he({
  padding: "$space$4",
  height: "100%",
  overflow: "auto",
  display: "flex",
  flexDirection: "column",
  position: "relative",
  fontFamily: "$font$mono",
});
he({ fontWeight: "bold", color: "$colors$base" });
var Oue = ["SyntaxError: ", "Error in sandbox:"],
  vue = { id: "random", method: "clear", data: ["Console was cleared"] },
  X_ = "@t",
  U_ = "#@t",
  H_ = "@r",
  q_ = 1e4,
  A6 = 2,
  yv = 400,
  bue = yv * 2,
  Z1 = (function () {
    var e = eval;
    return e("this");
  })(),
  xue = typeof ArrayBuffer == "function",
  yue = typeof Map == "function",
  wue = typeof Set == "function",
  Uc;
(function (t) {
  (t[(t.infinity = 0)] = "infinity"), (t[(t.minusInfinity = 1)] = "minusInfinity"), (t[(t.minusZero = 2)] = "minusZero");
})(Uc || (Uc = {}));
var Y_ = {
    Arithmetic: function (t) {
      return t === Uc.infinity ? 1 / 0 : t === Uc.minusInfinity ? -1 / 0 : t === Uc.minusZero ? -0 : t;
    },
    HTMLElement: function (t) {
      var e = document.implementation.createHTMLDocument("sandbox");
      try {
        var n = e.createElement(t.tagName);
        n.innerHTML = t.innerHTML;
        for (var r = 0, i = Object.keys(t.attributes); r < i.length; r++) {
          var o = i[r];
          try {
            n.setAttribute(o, t.attributes[o]);
          } catch {}
        }
        return n;
      } catch {
        return t;
      }
    },
    Function: function (t) {
      var e = function () {};
      return (
        Object.defineProperty(e, "toString", {
          value: function () {
            return "function ".concat(t.name, "() {").concat(t.body, "}");
          },
        }),
        e
      );
    },
    "[[NaN]]": function () {
      return NaN;
    },
    "[[undefined]]": function () {},
    "[[Date]]": function (t) {
      var e = new Date();
      return e.setTime(t), e;
    },
    "[[RegExp]]": function (t) {
      return new RegExp(t.src, t.flags);
    },
    "[[Error]]": function (t) {
      var e = Z1[t.name] || Error,
        n = new e(t.message);
      return (n.stack = t.stack), n;
    },
    "[[ArrayBuffer]]": function (t) {
      if (xue) {
        var e = new ArrayBuffer(t.length),
          n = new Int8Array(e);
        return n.set(t), e;
      }
      return t;
    },
    "[[TypedArray]]": function (t) {
      return typeof Z1[t.ctorName] == "function" ? new Z1[t.ctorName](t.arr) : t.arr;
    },
    "[[Map]]": function (t) {
      if (yue) {
        for (var e = new Map(), n = 0; n < t.length; n += 2) e.set(t[n], t[n + 1]);
        return e;
      }
      for (var r = [], i = 0; i < t.length; i += 2) r.push([t[n], t[n + 1]]);
      return r;
    },
    "[[Set]]": function (t) {
      if (wue) {
        for (var e = new Set(), n = 0; n < t.length; n++) e.add(t[n]);
        return e;
      }
      return t;
    },
  },
  wv = function (t) {
    var e;
    if (typeof t == "string" || typeof t == "number" || t === null) return t;
    if (Array.isArray(t)) return t.map(wv);
    if (typeof t == "object" && X_ in t) {
      var n = t[X_],
        r = Y_[n];
      return r(t.data);
    } else if (typeof t == "object" && U_ in t) {
      var n = t[U_],
        r = Y_[n];
      return r(t.data);
    } else if (typeof t == "object" && ((e = t.constructor) === null || e === void 0 ? void 0 : e.name) === "NodeList") {
      var i = {};
      return (
        Object.entries(t).forEach(function (o) {
          var s = o[0],
            l = o[1];
          i[s] = wv(l);
        }),
        i
      );
    }
    return t;
  },
  Sue = function (t, e, n) {
    var r = t.reduce(function (i, o, s) {
      return ""
        .concat(i)
        .concat(s ? ", " : "")
        .concat(Qu(o, e, n));
    }, "");
    return "[".concat(r, "]");
  },
  kue = function (t, e, n) {
    var r = t.constructor.name !== "Object" ? "".concat(t.constructor.name, " ") : "";
    if (n > A6) return r;
    var i = Object.entries(t),
      o = Object.entries(t).reduce(function (s, l, a) {
        var c = l[0],
          u = l[1],
          h = a === 0 ? "" : ", ",
          d =
            i.length > 10
              ? `
  `
              : "",
          f = Qu(u, e, n);
        return a === yv ? s + d + "..." : a > yv ? s : s + "".concat(h).concat(d).concat(c, ": ") + f;
      }, "");
    return ""
      .concat(r, "{ ")
      .concat(o)
      .concat(
        i.length > 10
          ? `
`
          : " ",
        "}"
      );
  },
  Qu = function (t, e, n) {
    var r;
    n === void 0 && (n = 0);
    try {
      var i = wv(t);
      if (Array.isArray(i)) return Sue(i, e, n + 1);
      switch (typeof i) {
        case "string":
          return '"'.concat(i, '"').slice(0, q_);
        case "number":
        case "function":
        case "symbol":
          return i.toString();
        case "boolean":
          return String(i);
        case "undefined":
          return "undefined";
        case "object":
        default:
          if (i instanceof RegExp || i instanceof Error || i instanceof Date) return i.toString();
          if (i === null) return String(null);
          if (i instanceof HTMLElement) return i.outerHTML.slice(0, q_);
          if (Object.entries(i).length === 0) return "{}";
          if (H_ in i) {
            if (n > A6) return "Unable to print information";
            var o = e[i[H_]];
            return Qu(o, e, n + 1);
          }
          if (((r = i.constructor) === null || r === void 0 ? void 0 : r.name) === "NodeList") {
            var s = i.length,
              l = new Array(s).fill(null).map(function (a, c) {
                return Qu(i[c], e);
              });
            return "NodeList(".concat(i.length, ")[").concat(l, "]");
          }
          return kue(i, e, n + 1);
      }
    } catch {
      return "Unable to print information";
    }
  },
  Cue = function (t) {
    switch (t) {
      case "warn":
        return "warning";
      case "clear":
        return "clear";
      case "error":
        return "error";
      case "log":
      case "info":
      default:
        return "info";
    }
  },
  Ad,
  _ue = function (t) {
    var e = t.data,
      n = nn();
    return T.jsx(T.Fragment, {
      children: e.map(function (r, i, o) {
        var s = r.data,
          l = r.id,
          a = r.method;
        return s && Array.isArray(s)
          ? T.jsx(
              _.Fragment,
              {
                children: s.map(function (c, u) {
                  var h = o.slice(i, o.length);
                  return T.jsx(
                    "div",
                    {
                      className: n("console-item", [Eue({ variant: Cue(a) })]),
                      children: T.jsx(ww, {
                        code: a === "clear" ? c : Qu(c, h),
                        fileType: "js",
                        initMode: "user-visible",
                        showReadOnly: !1,
                        readOnly: !0,
                        wrapContent: !0,
                      }),
                    },
                    "".concat(l, "-").concat(u)
                  );
                }),
              },
              l
            )
          : null;
      }),
    });
  },
  Eue = he(
    ((Ad = {
      width: "100%",
      padding: "$space$3 $space$2",
      fontSize: ".8em",
      position: "relative",
      "&:not(:first-child):after": {
        content: "",
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: 1,
        background: "$colors$surface3",
      },
      ".sp-cm": { padding: 0 },
      ".cm-editor": { background: "none" },
      ".cm-content": { padding: 0 },
    }),
    (Ad[".".concat(it, "-pre-placeholder")] = { margin: "0 !important", fontSize: "1em" }),
    (Ad.variants = {
      variant: {
        error: {
          color: "$colors$error",
          background: "$colors$errorSurface",
          "&:not(:first-child):after": { background: "$colors$error", opacity: 0.07 },
        },
        warning: {
          color: "$colors$warning",
          background: "$colors$warningSurface",
          "&:not(:first-child):after": { background: "$colors$warning", opacity: 0.07 },
        },
        clear: { fontStyle: "italic" },
        info: {},
      },
    }),
    Ad)
  ),
  Tue = he({
    justifyContent: "space-between",
    borderBottom: "1px solid $colors$surface2",
    padding: "0 $space$2",
    fontFamily: "$font$mono",
    height: "$layout$headerHeight",
    minHeight: "$layout$headerHeight",
    overflowX: "auto",
    whiteSpace: "nowrap",
  }),
  G_ = he({ display: "flex", flexDirection: "row", alignItems: "center", gap: "$space$2" }),
  Pue = function (t) {
    var e = t.currentTab,
      n = t.setCurrentTab,
      r = t.node,
      i = nn(),
      o = i("console-header-button", [$n, Vs, he({ padding: "$space$1 $space$3" })]);
    return T.jsxs("div", {
      className: i("console-header", [Tue, G_]),
      children: [
        T.jsxs("p", {
          className: i("console-header-title", [
            he({
              lineHeight: 1,
              margin: 0,
              color: "$colors$base",
              fontSize: "$font$size",
              display: "flex",
              alignItems: "center",
              gap: "$space$2",
            }),
          ]),
          children: [T.jsx(_ae, {}), T.jsx("span", { children: "Terminal" })],
        }),
        r &&
          T.jsxs("div", {
            className: i("console-header-actions", [G_]),
            children: [
              T.jsx("button", {
                className: o,
                "data-active": e === "server",
                onClick: function () {
                  return n("server");
                },
                type: "button",
                children: "Server",
              }),
              T.jsx("button", {
                className: o,
                "data-active": e === "client",
                onClick: function () {
                  return n("client");
                },
                type: "button",
                children: "Client",
              }),
            ],
          }),
      ],
    });
  },
  Aue = function (t) {
    var e = t.clientId,
      n = t.maxMessageCount,
      r = n === void 0 ? bue : n,
      i = t.showSyntaxError,
      o = i === void 0 ? !1 : i,
      s = t.resetOnPreviewRestart,
      l = s === void 0 ? !1 : s,
      a = _.useState([]),
      c = a[0],
      u = a[1],
      h = Mt().listen;
    return (
      _.useEffect(
        function () {
          var d = h(function (f) {
            if (l && f.type === "start") u([]);
            else if (f.type === "console" && f.codesandbox) {
              var p = Array.isArray(f.log) ? f.log : [f.log];
              if (
                p.find(function (O) {
                  var v = O.method;
                  return v === "clear";
                })
              )
                return u([vue]);
              var m = o
                ? p
                : p.filter(function (O) {
                    var v,
                      g,
                      b,
                      x =
                        (b =
                          (g = (v = O == null ? void 0 : O.data) === null || v === void 0 ? void 0 : v.filter) === null || g === void 0
                            ? void 0
                            : g.call(v, function (k) {
                                if (typeof k != "string") return !0;
                                var w = Oue.filter(function (y) {
                                  return k.startsWith(y);
                                });
                                return w.length === 0;
                              })) !== null && b !== void 0
                          ? b
                          : [];
                    return x.length > 0;
                  });
              if (!m) return;
              u(function (O) {
                for (
                  var v = mn(mn([], O, !0), m, !0).filter(function (g, b, x) {
                    return (
                      b ===
                      x.findIndex(function (k) {
                        return k.id === g.id;
                      })
                    );
                  });
                  v.length > r;

                )
                  v.shift();
                return v;
              });
            }
          }, e);
          return d;
        },
        [o, r, e, l]
      ),
      {
        logs: c,
        reset: function () {
          return u([]);
        },
      }
    );
  };
_.forwardRef(function (t, e) {
  var n,
    r = t.showHeader,
    i = r === void 0 ? !0 : r,
    o = t.showSyntaxError,
    s = o === void 0 ? !1 : o,
    l = t.maxMessageCount,
    a = t.onLogsChange,
    c = t.className;
  t.showSetupProgress;
  var u = t.showResetConsoleButton,
    h = u === void 0 ? !0 : u,
    d = t.showRestartButton,
    f = d === void 0 ? !0 : d,
    p = t.resetOnPreviewRestart,
    m = p === void 0 ? !1 : p,
    O = t.actionsChildren,
    v = O === void 0 ? T.jsx(T.Fragment, {}) : O,
    g = t.standalone,
    b = g === void 0 ? !1 : g,
    x = Wt(t, [
      "showHeader",
      "showSyntaxError",
      "maxMessageCount",
      "onLogsChange",
      "className",
      "showSetupProgress",
      "showResetConsoleButton",
      "showRestartButton",
      "resetOnPreviewRestart",
      "actionsChildren",
      "standalone",
    ]),
    k = Mt().sandpack.environment,
    w = C6(),
    y = w.iframe,
    C = w.clientId,
    P = Sw().restart,
    E = _.useState(k === "node" ? "server" : "client"),
    N = E[0],
    L = E[1],
    D = b ? C : void 0,
    Q = Aue({ maxMessageCount: l, showSyntaxError: s, resetOnPreviewRestart: m, clientId: D }),
    R = Q.logs,
    W = Q.reset,
    B = E6({ maxMessageCount: l, resetOnPreviewRestart: m, clientId: D }),
    K = B.logs,
    ne = B.reset,
    A = _.useRef(null);
  _.useEffect(
    function () {
      a == null || a(R), A.current && (A.current.scrollTop = A.current.scrollHeight);
    },
    [a, R, K, N]
  );
  var V = N === "server",
    ie = k === "node";
  _.useImperativeHandle(e, function () {
    return {
      reset: function () {
        W(), ne();
      },
    };
  });
  var M = nn();
  return T.jsxs(
    cg,
    Z(
      {
        className: M("console", [
          he(
            ((n = { height: "100%", background: "$surface1", iframe: { display: "none" } }),
            (n[".".concat(it, "-bridge-frame")] = {
              display: "block",
              border: 0,
              position: "absolute",
              left: "$space$2",
              bottom: "$space$2",
              zIndex: "$top",
              height: 12,
              width: "30%",
              mixBlendMode: "multiply",
              pointerEvents: "none",
            }),
            n)
          ),
          c,
        ]),
      },
      x,
      {
        children: [
          i && ie && T.jsx(Pue, { currentTab: N, node: ie, setCurrentTab: L }),
          T.jsx("div", {
            ref: A,
            className: M("console-list", [he({ overflow: "auto", scrollBehavior: "smooth" })]),
            children: V ? T.jsx(T6, { data: K }) : T.jsx(_ue, { data: R }),
          }),
          T.jsxs("div", {
            className: M("console-actions", [
              he({ position: "absolute", bottom: "$space$2", right: "$space$2", display: "flex", gap: "$space$2" }),
            ]),
            children: [
              v,
              f &&
                V &&
                T.jsx(Nu, {
                  onClick: function () {
                    P(), W(), ne();
                  },
                  children: T.jsx(ag, {}),
                }),
              h &&
                T.jsx(Nu, {
                  onClick: function () {
                    N === "client" ? W() : ne();
                  },
                  children: T.jsx(Sae, {}),
                }),
            ],
          }),
          b && T.jsxs(T.Fragment, { children: [T.jsx(lue, { clientId: D }), T.jsx("iframe", { ref: y })] }),
        ],
      }
    )
  );
});
he({
  position: "absolute",
  zIndex: "$top",
  variants: {
    direction: {
      vertical: { right: 0, left: 0, height: 10, cursor: "ns-resize" },
      horizontal: { top: 0, bottom: 0, width: 10, cursor: "ew-resize" },
    },
  },
  "@media screen and (max-width: 768px)": { display: "none" },
});
he({
  position: "relative",
  strong: {
    background: "$colors$clickable",
    color: "$colors$surface1",
    minWidth: 12,
    height: 12,
    padding: "0 2px",
    borderRadius: 12,
    fontSize: 8,
    lineHeight: "12px",
    position: "absolute",
    top: 0,
    right: 0,
    fontWeight: "normal",
  },
});
he({ width: "100%", overflow: "hidden" });
he({
  flexDirection: "row-reverse",
  "@media screen and (max-width: 768px)": { flexFlow: "wrap-reverse !important", flexDirection: "initial" },
});
function $6(t, e, n, r) {
  const i = mt(St),
    o = He(Ho),
    s = S.useRef(null),
    { lexicalNode: l } = ta(),
    a = S.useRef(!1),
    c = S.useRef(!1),
    u = S.useCallback(() => {
      o({ editorType: e, rootNode: l });
    }, [e, l, o]),
    h = S.useCallback(
      (d) => {
        var f, p, m, O, v, g;
        if (d.key === "ArrowDown") {
          const b = (p = (f = s.current) == null ? void 0 : f.getCodemirror()) == null ? void 0 : p.state;
          if (b) {
            const x = b.doc.length,
              k = b.selection.ranges[0].to;
            x === k &&
              (a.current
                ? (i == null ||
                    i.update(() => {
                      var w, y;
                      const C = dt(t);
                      C.getNextSibling()
                        ? ((y = (w = s.current) == null ? void 0 : w.getCodemirror()) == null || y.contentDOM.blur(), C.selectNext())
                        : C.insertAfter(tt());
                    }),
                  (a.current = !1))
                : (a.current = !0));
          }
        } else if (d.key === "ArrowUp") {
          const b = (O = (m = s.current) == null ? void 0 : m.getCodemirror()) == null ? void 0 : O.state;
          b &&
            b.selection.ranges[0].from === 0 &&
            (c.current
              ? (i == null ||
                  i.update(() => {
                    var k, w;
                    const y = dt(t);
                    y.getPreviousSibling() &&
                      ((w = (k = s.current) == null ? void 0 : k.getCodemirror()) == null || w.contentDOM.blur(), y.selectPrevious());
                  }),
                (c.current = !1))
              : (c.current = !0));
        } else if (d.key === "Enter") d.stopPropagation();
        else if (d.key === "Backspace" || d.key === "Delete") {
          const b = (g = (v = s.current) == null ? void 0 : v.getCodemirror()) == null ? void 0 : g.state;
          (b == null ? void 0 : b.doc.length) === 0 &&
            (i == null ||
              i.update(() => {
                dt(t).remove();
              }));
        }
      },
      [i, t]
    );
  return (
    S.useEffect(() => {
      const d = s.current;
      return (
        setTimeout(() => {
          var f, p;
          (f = d == null ? void 0 : d.getCodemirror()) == null || f.contentDOM.addEventListener("focus", u),
            (p = d == null ? void 0 : d.getCodemirror()) == null || p.contentDOM.addEventListener("keydown", h);
        }, 300),
        () => {
          var f, p;
          (f = d == null ? void 0 : d.getCodemirror()) == null || f.contentDOM.removeEventListener("focus", u),
            (p = d == null ? void 0 : d.getCodemirror()) == null || p.contentDOM.removeEventListener("keydown", h);
        }
      );
    }, [s, u, h, n]),
    S.useEffect(() => {
      r.subscribe(() => {
        var d, f;
        (f = (d = s.current) == null ? void 0 : d.getCodemirror()) == null || f.focus(), u();
      });
    }, [r, s, t, u]),
    s
  );
}
const $ue = ({ onChange: t, snippetFileName: e }) => {
    const { sandpack: n } = Mt();
    return t(n.files[e].code), null;
  },
  Rue = ({ nodeKey: t, code: e, focusEmitter: n, preset: r }) => {
    const i = $6(t, "sandpack", "jsx", n),
      [o, s] = Ye(Gt, st),
      { setCode: l } = ta(),
      { parentEditor: a, lexicalNode: c } = ta(),
      u = nt();
    return S.createElement(
      "div",
      { className: F.sandPackWrapper },
      S.createElement(
        "div",
        { className: F.codeMirrorToolbar },
        S.createElement(
          "button",
          {
            className: F.iconButton,
            type: "button",
            title: u("codeblock.delete", "Delete code block"),
            onClick: (h) => {
              h.preventDefault(),
                a.update(() => {
                  c.remove();
                });
            },
          },
          s("delete_small")
        )
      ),
      S.createElement(
        fce,
        {
          template: r.sandpackTemplate,
          theme: r.sandpackTheme,
          files: {
            [r.snippetFileName]: e,
            ...Object.entries(r.files ?? {}).reduce((h, [d, f]) => ({ ...h, [d]: { code: f, readOnly: !0 } }), {}),
          },
          customSetup: { dependencies: r.dependencies },
        },
        S.createElement(
          Ice,
          null,
          S.createElement($ce, { readOnly: o, showLineNumbers: !0, showInlineErrors: !0, ref: i }),
          S.createElement(gue, null)
        ),
        S.createElement($ue, { onChange: l, snippetFileName: r.snippetFileName })
      )
    );
  },
  Iue = `
export default function App() {
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}
`,
  Mue = {
    defaultPreset: "react",
    presets: [
      {
        name: "react",
        meta: "live react",
        label: "React",
        sandpackTemplate: "react",
        sandpackTheme: "light",
        snippetFileName: "/App.js",
        snippetLanguage: "jsx",
        initialSnippetContent: Iue,
      },
    ],
  },
  js = we(Mue),
  Cw = kt((t) => {
    t.link(
      t.pipe(
        Cw,
        pt(js),
        mr(([e, n]) => {
          const r = e ? n.presets.find((i) => i.name === e) : n.presets.find((i) => i.name == n.defaultPreset);
          if (!r) throw new Error(`No sandpack preset found with name ${e}`);
          return { code: r.initialSnippetContent ?? "", language: r.snippetLanguage ?? "jsx", meta: r.meta };
        })
      ),
      Eh
    );
  }),
  Lue = Ut({
    init(t, e) {
      t.pubIn({ [js]: e == null ? void 0 : e.sandpackConfig, [Sy]: Nue() });
    },
    update(t, e) {
      t.pub(js, e == null ? void 0 : e.sandpackConfig);
    },
  });
function Nue() {
  return {
    match(t, e) {
      return !!(e != null && e.startsWith("live"));
    },
    Editor(t) {
      const n = mt(js).presets.find((r) => r.meta === t.meta);
      if (!n) throw new Error(`No sandpack preset found with ${t.meta}`);
      return S.createElement(Rue, { ...t, preset: n });
    },
    priority: 1,
  };
}
function G(t) {
  return new la(Wy.define(t));
}
function lo(t) {
  return z(
    () => import("./index-4042914b.js"),
    [
      "./index-4042914b.js",
      "./index-c6dae603.js",
      "./PolarisAutoForm-e187dbdc.js",
      "./apis-d6201c92.js",
      "./index-eb008d06.js",
      "./iframe-5aa777a6.js",
      "./useAction-e2e8ce4c.js",
      "./index-0511f421.js",
      "./extends-98964cd2.js",
      "./index-baeb160b.js",
    ],
    import.meta.url
  ).then((e) => e.sql({ dialect: e[t] }));
}
const Que = [
    j.of({
      name: "C",
      extensions: ["c", "h", "ino"],
      load() {
        return z(
          () => import("./index-826cda84.js"),
          [
            "./index-826cda84.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.cpp());
      },
    }),
    j.of({
      name: "C++",
      alias: ["cpp"],
      extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
      load() {
        return z(
          () => import("./index-826cda84.js"),
          [
            "./index-826cda84.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.cpp());
      },
    }),
    j.of({
      name: "CQL",
      alias: ["cassandra"],
      extensions: ["cql"],
      load() {
        return lo("Cassandra");
      },
    }),
    j.of({
      name: "CSS",
      extensions: ["css"],
      load() {
        return z(() => Promise.resolve().then(() => Nse), void 0, import.meta.url).then((t) => t.css());
      },
    }),
    j.of({
      name: "Go",
      extensions: ["go"],
      load() {
        return z(
          () => import("./index-4ace8c09.js"),
          [
            "./index-4ace8c09.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.go());
      },
    }),
    j.of({
      name: "HTML",
      alias: ["xhtml"],
      extensions: ["html", "htm", "handlebars", "hbs"],
      load() {
        return z(() => Promise.resolve().then(() => aae), void 0, import.meta.url).then((t) => t.html());
      },
    }),
    j.of({
      name: "Java",
      extensions: ["java"],
      load() {
        return z(
          () => import("./index-1f8da066.js"),
          [
            "./index-1f8da066.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.java());
      },
    }),
    j.of({
      name: "JavaScript",
      alias: ["ecmascript", "js", "node"],
      extensions: ["js", "mjs", "cjs"],
      load() {
        return z(() => Promise.resolve().then(() => Cd), void 0, import.meta.url).then((t) => t.javascript());
      },
    }),
    j.of({
      name: "JSON",
      alias: ["json5"],
      extensions: ["json", "map"],
      load() {
        return z(
          () => import("./index-9683df3c.js"),
          [
            "./index-9683df3c.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.json());
      },
    }),
    j.of({
      name: "JSX",
      extensions: ["jsx"],
      load() {
        return z(() => Promise.resolve().then(() => Cd), void 0, import.meta.url).then((t) => t.javascript({ jsx: !0 }));
      },
    }),
    j.of({
      name: "LESS",
      extensions: ["less"],
      load() {
        return z(
          () => import("./index-879132eb.js"),
          [
            "./index-879132eb.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.less());
      },
    }),
    j.of({
      name: "Liquid",
      extensions: ["liquid"],
      load() {
        return z(
          () => import("./index-6c88bf28.js"),
          [
            "./index-6c88bf28.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.liquid());
      },
    }),
    j.of({
      name: "MariaDB SQL",
      load() {
        return lo("MariaSQL");
      },
    }),
    j.of({
      name: "Markdown",
      extensions: ["md", "markdown", "mkd"],
      load() {
        return z(() => Promise.resolve().then(() => Ppe), void 0, import.meta.url).then((t) => t.markdown());
      },
    }),
    j.of({
      name: "MS SQL",
      load() {
        return lo("MSSQL");
      },
    }),
    j.of({
      name: "MySQL",
      load() {
        return lo("MySQL");
      },
    }),
    j.of({
      name: "PHP",
      extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
      load() {
        return z(
          () => import("./index-8960a5b8.js"),
          [
            "./index-8960a5b8.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.php());
      },
    }),
    j.of({
      name: "PLSQL",
      extensions: ["pls"],
      load() {
        return lo("PLSQL");
      },
    }),
    j.of({
      name: "PostgreSQL",
      load() {
        return lo("PostgreSQL");
      },
    }),
    j.of({
      name: "Python",
      extensions: ["BUILD", "bzl", "py", "pyw"],
      filename: /^(BUCK|BUILD)$/,
      load() {
        return z(
          () => import("./index-8051d5eb.js"),
          [
            "./index-8051d5eb.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.python());
      },
    }),
    j.of({
      name: "Rust",
      extensions: ["rs"],
      load() {
        return z(
          () => import("./index-0699433d.js"),
          [
            "./index-0699433d.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.rust());
      },
    }),
    j.of({
      name: "Sass",
      extensions: ["sass"],
      load() {
        return z(
          () => import("./index-a29dd7bc.js"),
          [
            "./index-a29dd7bc.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.sass({ indented: !0 }));
      },
    }),
    j.of({
      name: "SCSS",
      extensions: ["scss"],
      load() {
        return z(
          () => import("./index-a29dd7bc.js"),
          [
            "./index-a29dd7bc.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.sass());
      },
    }),
    j.of({
      name: "SQL",
      extensions: ["sql"],
      load() {
        return lo("StandardSQL");
      },
    }),
    j.of({
      name: "SQLite",
      load() {
        return lo("SQLite");
      },
    }),
    j.of({
      name: "TSX",
      extensions: ["tsx"],
      load() {
        return z(() => Promise.resolve().then(() => Cd), void 0, import.meta.url).then((t) => t.javascript({ jsx: !0, typescript: !0 }));
      },
    }),
    j.of({
      name: "TypeScript",
      alias: ["ts"],
      extensions: ["ts", "mts", "cts"],
      load() {
        return z(() => Promise.resolve().then(() => Cd), void 0, import.meta.url).then((t) => t.javascript({ typescript: !0 }));
      },
    }),
    j.of({
      name: "WebAssembly",
      extensions: ["wat", "wast"],
      load() {
        return z(
          () => import("./index-9726042a.js"),
          [
            "./index-9726042a.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.wast());
      },
    }),
    j.of({
      name: "XML",
      alias: ["rss", "wsdl", "xsd"],
      extensions: ["xml", "xsl", "xsd", "svg"],
      load() {
        return z(
          () => import("./index-5eaa26b8.js"),
          [
            "./index-5eaa26b8.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.xml());
      },
    }),
    j.of({
      name: "YAML",
      alias: ["yml"],
      extensions: ["yaml", "yml"],
      load() {
        return z(
          () => import("./index-15e0a1d8.js"),
          [
            "./index-15e0a1d8.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.yaml());
      },
    }),
    j.of({
      name: "APL",
      extensions: ["dyalog", "apl"],
      load() {
        return z(() => import("./apl-f73da2d7.js"), [], import.meta.url).then((t) => G(t.apl));
      },
    }),
    j.of({
      name: "PGP",
      alias: ["asciiarmor"],
      extensions: ["asc", "pgp", "sig"],
      load() {
        return z(() => import("./asciiarmor-e7973ceb.js"), [], import.meta.url).then((t) => G(t.asciiArmor));
      },
    }),
    j.of({
      name: "ASN.1",
      extensions: ["asn", "asn1"],
      load() {
        return z(() => import("./asn1-f9c290f0.js"), [], import.meta.url).then((t) => G(t.asn1({})));
      },
    }),
    j.of({
      name: "Asterisk",
      filename: /^extensions\.conf$/i,
      load() {
        return z(() => import("./asterisk-9c249b4c.js"), [], import.meta.url).then((t) => G(t.asterisk));
      },
    }),
    j.of({
      name: "Brainfuck",
      extensions: ["b", "bf"],
      load() {
        return z(() => import("./brainfuck-637b9bf0.js"), [], import.meta.url).then((t) => G(t.brainfuck));
      },
    }),
    j.of({
      name: "Cobol",
      extensions: ["cob", "cpy"],
      load() {
        return z(() => import("./cobol-3c0e8dcf.js"), [], import.meta.url).then((t) => G(t.cobol));
      },
    }),
    j.of({
      name: "C#",
      alias: ["csharp", "cs"],
      extensions: ["cs"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => G(t.csharp));
      },
    }),
    j.of({
      name: "Clojure",
      extensions: ["clj", "cljc", "cljx"],
      load() {
        return z(() => import("./clojure-46c215dd.js"), [], import.meta.url).then((t) => G(t.clojure));
      },
    }),
    j.of({
      name: "ClojureScript",
      extensions: ["cljs"],
      load() {
        return z(() => import("./clojure-46c215dd.js"), [], import.meta.url).then((t) => G(t.clojure));
      },
    }),
    j.of({
      name: "Closure Stylesheets (GSS)",
      extensions: ["gss"],
      load() {
        return z(() => import("./css-ae0ae1d0.js"), [], import.meta.url).then((t) => G(t.gss));
      },
    }),
    j.of({
      name: "CMake",
      extensions: ["cmake", "cmake.in"],
      filename: /^CMakeLists\.txt$/,
      load() {
        return z(() => import("./cmake-f314e514.js"), [], import.meta.url).then((t) => G(t.cmake));
      },
    }),
    j.of({
      name: "CoffeeScript",
      alias: ["coffee", "coffee-script"],
      extensions: ["coffee"],
      load() {
        return z(() => import("./coffeescript-cf6fb77c.js"), [], import.meta.url).then((t) => G(t.coffeeScript));
      },
    }),
    j.of({
      name: "Common Lisp",
      alias: ["lisp"],
      extensions: ["cl", "lisp", "el"],
      load() {
        return z(() => import("./commonlisp-0ea12945.js"), [], import.meta.url).then((t) => G(t.commonLisp));
      },
    }),
    j.of({
      name: "Cypher",
      extensions: ["cyp", "cypher"],
      load() {
        return z(() => import("./cypher-236a65ad.js"), [], import.meta.url).then((t) => G(t.cypher));
      },
    }),
    j.of({
      name: "Cython",
      extensions: ["pyx", "pxd", "pxi"],
      load() {
        return z(() => import("./python-fa45e8d1.js"), [], import.meta.url).then((t) => G(t.cython));
      },
    }),
    j.of({
      name: "Crystal",
      extensions: ["cr"],
      load() {
        return z(() => import("./crystal-02658b69.js"), [], import.meta.url).then((t) => G(t.crystal));
      },
    }),
    j.of({
      name: "D",
      extensions: ["d"],
      load() {
        return z(() => import("./d-76ab4361.js"), [], import.meta.url).then((t) => G(t.d));
      },
    }),
    j.of({
      name: "Dart",
      extensions: ["dart"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => G(t.dart));
      },
    }),
    j.of({
      name: "diff",
      extensions: ["diff", "patch"],
      load() {
        return z(() => import("./diff-1bf42f34.js"), [], import.meta.url).then((t) => G(t.diff));
      },
    }),
    j.of({
      name: "Dockerfile",
      filename: /^Dockerfile$/,
      load() {
        return z(() => import("./dockerfile-c8a8b9da.js"), ["./dockerfile-c8a8b9da.js", "./simple-mode-851e42ff.js"], import.meta.url).then(
          (t) => G(t.dockerFile)
        );
      },
    }),
    j.of({
      name: "DTD",
      extensions: ["dtd"],
      load() {
        return z(() => import("./dtd-8d673f3f.js"), [], import.meta.url).then((t) => G(t.dtd));
      },
    }),
    j.of({
      name: "Dylan",
      extensions: ["dylan", "dyl", "intr"],
      load() {
        return z(() => import("./dylan-94e68d48.js"), [], import.meta.url).then((t) => G(t.dylan));
      },
    }),
    j.of({
      name: "EBNF",
      load() {
        return z(() => import("./ebnf-9a58f677.js"), [], import.meta.url).then((t) => G(t.ebnf));
      },
    }),
    j.of({
      name: "ECL",
      extensions: ["ecl"],
      load() {
        return z(() => import("./ecl-8c848bde.js"), [], import.meta.url).then((t) => G(t.ecl));
      },
    }),
    j.of({
      name: "edn",
      extensions: ["edn"],
      load() {
        return z(() => import("./clojure-46c215dd.js"), [], import.meta.url).then((t) => G(t.clojure));
      },
    }),
    j.of({
      name: "Eiffel",
      extensions: ["e"],
      load() {
        return z(() => import("./eiffel-c812667a.js"), [], import.meta.url).then((t) => G(t.eiffel));
      },
    }),
    j.of({
      name: "Elm",
      extensions: ["elm"],
      load() {
        return z(() => import("./elm-389625db.js"), [], import.meta.url).then((t) => G(t.elm));
      },
    }),
    j.of({
      name: "Erlang",
      extensions: ["erl"],
      load() {
        return z(() => import("./erlang-72724d5c.js"), [], import.meta.url).then((t) => G(t.erlang));
      },
    }),
    j.of({
      name: "Esper",
      load() {
        return z(() => import("./sql-62feda9f.js"), [], import.meta.url).then((t) => G(t.esper));
      },
    }),
    j.of({
      name: "Factor",
      extensions: ["factor"],
      load() {
        return z(() => import("./factor-7bfcb4fc.js"), ["./factor-7bfcb4fc.js", "./simple-mode-851e42ff.js"], import.meta.url).then((t) =>
          G(t.factor)
        );
      },
    }),
    j.of({
      name: "FCL",
      load() {
        return z(() => import("./fcl-d5e95185.js"), [], import.meta.url).then((t) => G(t.fcl));
      },
    }),
    j.of({
      name: "Forth",
      extensions: ["forth", "fth", "4th"],
      load() {
        return z(() => import("./forth-a6c07be1.js"), [], import.meta.url).then((t) => G(t.forth));
      },
    }),
    j.of({
      name: "Fortran",
      extensions: ["f", "for", "f77", "f90", "f95"],
      load() {
        return z(() => import("./fortran-b746f455.js"), [], import.meta.url).then((t) => G(t.fortran));
      },
    }),
    j.of({
      name: "F#",
      alias: ["fsharp"],
      extensions: ["fs"],
      load() {
        return z(() => import("./mllike-1f866598.js"), [], import.meta.url).then((t) => G(t.fSharp));
      },
    }),
    j.of({
      name: "Gas",
      extensions: ["s"],
      load() {
        return z(() => import("./gas-a519128b.js"), [], import.meta.url).then((t) => G(t.gas));
      },
    }),
    j.of({
      name: "Gherkin",
      extensions: ["feature"],
      load() {
        return z(() => import("./gherkin-0efe02ac.js"), [], import.meta.url).then((t) => G(t.gherkin));
      },
    }),
    j.of({
      name: "Groovy",
      extensions: ["groovy", "gradle"],
      filename: /^Jenkinsfile$/,
      load() {
        return z(() => import("./groovy-4592a472.js"), [], import.meta.url).then((t) => G(t.groovy));
      },
    }),
    j.of({
      name: "Haskell",
      extensions: ["hs"],
      load() {
        return z(() => import("./haskell-b620645c.js"), [], import.meta.url).then((t) => G(t.haskell));
      },
    }),
    j.of({
      name: "Haxe",
      extensions: ["hx"],
      load() {
        return z(() => import("./haxe-7215664e.js"), [], import.meta.url).then((t) => G(t.haxe));
      },
    }),
    j.of({
      name: "HXML",
      extensions: ["hxml"],
      load() {
        return z(() => import("./haxe-7215664e.js"), [], import.meta.url).then((t) => G(t.hxml));
      },
    }),
    j.of({
      name: "HTTP",
      load() {
        return z(() => import("./http-e091c18d.js"), [], import.meta.url).then((t) => G(t.http));
      },
    }),
    j.of({
      name: "IDL",
      extensions: ["pro"],
      load() {
        return z(() => import("./idl-91cb7788.js"), [], import.meta.url).then((t) => G(t.idl));
      },
    }),
    j.of({
      name: "JSON-LD",
      alias: ["jsonld"],
      extensions: ["jsonld"],
      load() {
        return z(() => import("./javascript-da64953c.js"), [], import.meta.url).then((t) => G(t.jsonld));
      },
    }),
    j.of({
      name: "Jinja2",
      extensions: ["j2", "jinja", "jinja2"],
      load() {
        return z(() => import("./jinja2-580c43a7.js"), [], import.meta.url).then((t) => G(t.jinja2));
      },
    }),
    j.of({
      name: "Julia",
      extensions: ["jl"],
      load() {
        return z(() => import("./julia-2f39a740.js"), [], import.meta.url).then((t) => G(t.julia));
      },
    }),
    j.of({
      name: "Kotlin",
      extensions: ["kt", "kts"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => G(t.kotlin));
      },
    }),
    j.of({
      name: "LiveScript",
      alias: ["ls"],
      extensions: ["ls"],
      load() {
        return z(() => import("./livescript-a3318e59.js"), [], import.meta.url).then((t) => G(t.liveScript));
      },
    }),
    j.of({
      name: "Lua",
      extensions: ["lua"],
      load() {
        return z(() => import("./lua-ee237842.js"), [], import.meta.url).then((t) => G(t.lua));
      },
    }),
    j.of({
      name: "mIRC",
      extensions: ["mrc"],
      load() {
        return z(() => import("./mirc-c043bc0a.js"), [], import.meta.url).then((t) => G(t.mirc));
      },
    }),
    j.of({
      name: "Mathematica",
      extensions: ["m", "nb", "wl", "wls"],
      load() {
        return z(() => import("./mathematica-4db1ec63.js"), [], import.meta.url).then((t) => G(t.mathematica));
      },
    }),
    j.of({
      name: "Modelica",
      extensions: ["mo"],
      load() {
        return z(() => import("./modelica-c19c47b8.js"), [], import.meta.url).then((t) => G(t.modelica));
      },
    }),
    j.of({
      name: "MUMPS",
      extensions: ["mps"],
      load() {
        return z(() => import("./mumps-82310ef4.js"), [], import.meta.url).then((t) => G(t.mumps));
      },
    }),
    j.of({
      name: "Mbox",
      extensions: ["mbox"],
      load() {
        return z(() => import("./mbox-b40e52ca.js"), [], import.meta.url).then((t) => G(t.mbox));
      },
    }),
    j.of({
      name: "Nginx",
      filename: /nginx.*\.conf$/i,
      load() {
        return z(() => import("./nginx-0992a7c8.js"), [], import.meta.url).then((t) => G(t.nginx));
      },
    }),
    j.of({
      name: "NSIS",
      extensions: ["nsh", "nsi"],
      load() {
        return z(() => import("./nsis-419655c7.js"), ["./nsis-419655c7.js", "./simple-mode-851e42ff.js"], import.meta.url).then((t) =>
          G(t.nsis)
        );
      },
    }),
    j.of({
      name: "NTriples",
      extensions: ["nt", "nq"],
      load() {
        return z(() => import("./ntriples-8490b09b.js"), [], import.meta.url).then((t) => G(t.ntriples));
      },
    }),
    j.of({
      name: "Objective-C",
      alias: ["objective-c", "objc"],
      extensions: ["m"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => G(t.objectiveC));
      },
    }),
    j.of({
      name: "Objective-C++",
      alias: ["objective-c++", "objc++"],
      extensions: ["mm"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => G(t.objectiveCpp));
      },
    }),
    j.of({
      name: "OCaml",
      extensions: ["ml", "mli", "mll", "mly"],
      load() {
        return z(() => import("./mllike-1f866598.js"), [], import.meta.url).then((t) => G(t.oCaml));
      },
    }),
    j.of({
      name: "Octave",
      extensions: ["m"],
      load() {
        return z(() => import("./octave-3f516c2f.js"), [], import.meta.url).then((t) => G(t.octave));
      },
    }),
    j.of({
      name: "Oz",
      extensions: ["oz"],
      load() {
        return z(() => import("./oz-a640e05c.js"), [], import.meta.url).then((t) => G(t.oz));
      },
    }),
    j.of({
      name: "Pascal",
      extensions: ["p", "pas"],
      load() {
        return z(() => import("./pascal-bcac1c04.js"), [], import.meta.url).then((t) => G(t.pascal));
      },
    }),
    j.of({
      name: "Perl",
      extensions: ["pl", "pm"],
      load() {
        return z(() => import("./perl-a9455719.js"), [], import.meta.url).then((t) => G(t.perl));
      },
    }),
    j.of({
      name: "Pig",
      extensions: ["pig"],
      load() {
        return z(() => import("./pig-3510ca5f.js"), [], import.meta.url).then((t) => G(t.pig));
      },
    }),
    j.of({
      name: "PowerShell",
      extensions: ["ps1", "psd1", "psm1"],
      load() {
        return z(() => import("./powershell-c2c54630.js"), [], import.meta.url).then((t) => G(t.powerShell));
      },
    }),
    j.of({
      name: "Properties files",
      alias: ["ini", "properties"],
      extensions: ["properties", "ini", "in"],
      load() {
        return z(() => import("./properties-aba123c1.js"), [], import.meta.url).then((t) => G(t.properties));
      },
    }),
    j.of({
      name: "ProtoBuf",
      extensions: ["proto"],
      load() {
        return z(() => import("./protobuf-1713bf80.js"), [], import.meta.url).then((t) => G(t.protobuf));
      },
    }),
    j.of({
      name: "Pug",
      alias: ["jade"],
      extensions: ["pug", "jade"],
      load() {
        return z(() => import("./pug-c3549eac.js"), ["./pug-c3549eac.js", "./javascript-da64953c.js"], import.meta.url).then((t) =>
          G(t.pug)
        );
      },
    }),
    j.of({
      name: "Puppet",
      extensions: ["pp"],
      load() {
        return z(() => import("./puppet-3229bfe4.js"), [], import.meta.url).then((t) => G(t.puppet));
      },
    }),
    j.of({
      name: "Q",
      extensions: ["q"],
      load() {
        return z(() => import("./q-887a0cfa.js"), [], import.meta.url).then((t) => G(t.q));
      },
    }),
    j.of({
      name: "R",
      alias: ["rscript"],
      extensions: ["r", "R"],
      load() {
        return z(() => import("./r-3ca97919.js"), [], import.meta.url).then((t) => G(t.r));
      },
    }),
    j.of({
      name: "RPM Changes",
      load() {
        return z(() => import("./rpm-aa81b362.js"), [], import.meta.url).then((t) => G(t.rpmChanges));
      },
    }),
    j.of({
      name: "RPM Spec",
      extensions: ["spec"],
      load() {
        return z(() => import("./rpm-aa81b362.js"), [], import.meta.url).then((t) => G(t.rpmSpec));
      },
    }),
    j.of({
      name: "Ruby",
      alias: ["jruby", "macruby", "rake", "rb", "rbx"],
      extensions: ["rb"],
      filename: /^(Gemfile|Rakefile)$/,
      load() {
        return z(() => import("./ruby-e88f1f8d.js"), [], import.meta.url).then((t) => G(t.ruby));
      },
    }),
    j.of({
      name: "SAS",
      extensions: ["sas"],
      load() {
        return z(() => import("./sas-4096b960.js"), [], import.meta.url).then((t) => G(t.sas));
      },
    }),
    j.of({
      name: "Scala",
      extensions: ["scala"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => G(t.scala));
      },
    }),
    j.of({
      name: "Scheme",
      extensions: ["scm", "ss"],
      load() {
        return z(() => import("./scheme-ca3e6863.js"), [], import.meta.url).then((t) => G(t.scheme));
      },
    }),
    j.of({
      name: "Shell",
      alias: ["bash", "sh", "zsh"],
      extensions: ["sh", "ksh", "bash"],
      filename: /^PKGBUILD$/,
      load() {
        return z(() => import("./shell-61e14131.js"), [], import.meta.url).then((t) => G(t.shell));
      },
    }),
    j.of({
      name: "Sieve",
      extensions: ["siv", "sieve"],
      load() {
        return z(() => import("./sieve-4b1eb6fb.js"), [], import.meta.url).then((t) => G(t.sieve));
      },
    }),
    j.of({
      name: "Smalltalk",
      extensions: ["st"],
      load() {
        return z(() => import("./smalltalk-b41561ee.js"), [], import.meta.url).then((t) => G(t.smalltalk));
      },
    }),
    j.of({
      name: "Solr",
      load() {
        return z(() => import("./solr-eac40f87.js"), [], import.meta.url).then((t) => G(t.solr));
      },
    }),
    j.of({
      name: "SML",
      extensions: ["sml", "sig", "fun", "smackspec"],
      load() {
        return z(() => import("./mllike-1f866598.js"), [], import.meta.url).then((t) => G(t.sml));
      },
    }),
    j.of({
      name: "SPARQL",
      alias: ["sparul"],
      extensions: ["rq", "sparql"],
      load() {
        return z(() => import("./sparql-a1ae2f33.js"), [], import.meta.url).then((t) => G(t.sparql));
      },
    }),
    j.of({
      name: "Spreadsheet",
      alias: ["excel", "formula"],
      load() {
        return z(() => import("./spreadsheet-9f4dc4c6.js"), [], import.meta.url).then((t) => G(t.spreadsheet));
      },
    }),
    j.of({
      name: "Squirrel",
      extensions: ["nut"],
      load() {
        return z(() => import("./clike-c6a401fb.js"), [], import.meta.url).then((t) => G(t.squirrel));
      },
    }),
    j.of({
      name: "Stylus",
      extensions: ["styl"],
      load() {
        return z(() => import("./stylus-2d29a832.js"), [], import.meta.url).then((t) => G(t.stylus));
      },
    }),
    j.of({
      name: "Swift",
      extensions: ["swift"],
      load() {
        return z(() => import("./swift-b6dd686e.js"), [], import.meta.url).then((t) => G(t.swift));
      },
    }),
    j.of({
      name: "sTeX",
      load() {
        return z(() => import("./stex-611747c4.js"), [], import.meta.url).then((t) => G(t.stex));
      },
    }),
    j.of({
      name: "LaTeX",
      alias: ["tex"],
      extensions: ["text", "ltx", "tex"],
      load() {
        return z(() => import("./stex-611747c4.js"), [], import.meta.url).then((t) => G(t.stex));
      },
    }),
    j.of({
      name: "SystemVerilog",
      extensions: ["v", "sv", "svh"],
      load() {
        return z(() => import("./verilog-701759f4.js"), [], import.meta.url).then((t) => G(t.verilog));
      },
    }),
    j.of({
      name: "Tcl",
      extensions: ["tcl"],
      load() {
        return z(() => import("./tcl-9a9d281f.js"), [], import.meta.url).then((t) => G(t.tcl));
      },
    }),
    j.of({
      name: "Textile",
      extensions: ["textile"],
      load() {
        return z(() => import("./textile-27197230.js"), [], import.meta.url).then((t) => G(t.textile));
      },
    }),
    j.of({
      name: "TiddlyWiki",
      load() {
        return z(() => import("./tiddlywiki-053c4b39.js"), [], import.meta.url).then((t) => G(t.tiddlyWiki));
      },
    }),
    j.of({
      name: "Tiki wiki",
      load() {
        return z(() => import("./tiki-f8970e14.js"), [], import.meta.url).then((t) => G(t.tiki));
      },
    }),
    j.of({
      name: "TOML",
      extensions: ["toml"],
      load() {
        return z(() => import("./toml-fed73c05.js"), [], import.meta.url).then((t) => G(t.toml));
      },
    }),
    j.of({
      name: "Troff",
      extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
      load() {
        return z(() => import("./troff-1c50c70f.js"), [], import.meta.url).then((t) => G(t.troff));
      },
    }),
    j.of({
      name: "TTCN",
      extensions: ["ttcn", "ttcn3", "ttcnpp"],
      load() {
        return z(() => import("./ttcn-a4846d83.js"), [], import.meta.url).then((t) => G(t.ttcn));
      },
    }),
    j.of({
      name: "TTCN_CFG",
      extensions: ["cfg"],
      load() {
        return z(() => import("./ttcn-cfg-0c96bcc1.js"), [], import.meta.url).then((t) => G(t.ttcnCfg));
      },
    }),
    j.of({
      name: "Turtle",
      extensions: ["ttl"],
      load() {
        return z(() => import("./turtle-b550492d.js"), [], import.meta.url).then((t) => G(t.turtle));
      },
    }),
    j.of({
      name: "Web IDL",
      extensions: ["webidl"],
      load() {
        return z(() => import("./webidl-beade871.js"), [], import.meta.url).then((t) => G(t.webIDL));
      },
    }),
    j.of({
      name: "VB.NET",
      extensions: ["vb"],
      load() {
        return z(() => import("./vb-e9655ff4.js"), [], import.meta.url).then((t) => G(t.vb));
      },
    }),
    j.of({
      name: "VBScript",
      extensions: ["vbs"],
      load() {
        return z(() => import("./vbscript-e62417ba.js"), [], import.meta.url).then((t) => G(t.vbScript));
      },
    }),
    j.of({
      name: "Velocity",
      extensions: ["vtl"],
      load() {
        return z(() => import("./velocity-5bdd1b6a.js"), [], import.meta.url).then((t) => G(t.velocity));
      },
    }),
    j.of({
      name: "Verilog",
      extensions: ["v"],
      load() {
        return z(() => import("./verilog-701759f4.js"), [], import.meta.url).then((t) => G(t.verilog));
      },
    }),
    j.of({
      name: "VHDL",
      extensions: ["vhd", "vhdl"],
      load() {
        return z(() => import("./vhdl-288f0dde.js"), [], import.meta.url).then((t) => G(t.vhdl));
      },
    }),
    j.of({
      name: "XQuery",
      extensions: ["xy", "xquery"],
      load() {
        return z(() => import("./xquery-f004ff15.js"), [], import.meta.url).then((t) => G(t.xQuery));
      },
    }),
    j.of({
      name: "Yacas",
      extensions: ["ys"],
      load() {
        return z(() => import("./yacas-d031e2ab.js"), [], import.meta.url).then((t) => G(t.yacas));
      },
    }),
    j.of({
      name: "Z80",
      extensions: ["z80"],
      load() {
        return z(() => import("./z80-bb7f2654.js"), [], import.meta.url).then((t) => G(t.z80));
      },
    }),
    j.of({
      name: "MscGen",
      extensions: ["mscgen", "mscin", "msc"],
      load() {
        return z(() => import("./mscgen-96577242.js"), [], import.meta.url).then((t) => G(t.mscgen));
      },
    }),
    j.of({
      name: "Xù",
      extensions: ["xu"],
      load() {
        return z(() => import("./mscgen-96577242.js"), [], import.meta.url).then((t) => G(t.xu));
      },
    }),
    j.of({
      name: "MsGenny",
      extensions: ["msgenny"],
      load() {
        return z(() => import("./mscgen-96577242.js"), [], import.meta.url).then((t) => G(t.msgenny));
      },
    }),
    j.of({
      name: "Vue",
      extensions: ["vue"],
      load() {
        return z(
          () => import("./index-372d2075.js"),
          [
            "./index-372d2075.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.vue());
      },
    }),
    j.of({
      name: "Angular Template",
      load() {
        return z(
          () => import("./index-a0a6df2e.js"),
          [
            "./index-a0a6df2e.js",
            "./index-c6dae603.js",
            "./PolarisAutoForm-e187dbdc.js",
            "./apis-d6201c92.js",
            "./index-eb008d06.js",
            "./iframe-5aa777a6.js",
            "./useAction-e2e8ce4c.js",
            "./index-0511f421.js",
            "./extends-98964cd2.js",
            "./index-baeb160b.js",
          ],
          import.meta.url
        ).then((t) => t.angular());
      },
    }),
  ],
  J_ = "#2e3440",
  _w = "#3b4252",
  K_ = "#434c5e",
  $d = "#4c566a",
  eE = "#e5e9f0",
  Sv = "#eceff4",
  z1 = "#8fbcbb",
  tE = "#88c0d0",
  Due = "#81a1c1",
  kr = "#5e81ac",
  Fue = "#bf616a",
  ol = "#d08770",
  W1 = "#ebcb8b",
  nE = "#a3be8c",
  Bue = "#b48ead",
  rE = "#d30102",
  Ew = Sv,
  X1 = Ew,
  Vue = "#ffffff",
  U1 = _w,
  jue = Ew,
  iE = _w,
  Zue = re.theme(
    {
      "&": { color: J_, backgroundColor: Vue },
      ".cm-content": { caretColor: iE },
      ".cm-cursor, .cm-dropCursor": { borderLeftColor: iE },
      "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: jue },
      ".cm-panels": { backgroundColor: Ew, color: $d },
      ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
      ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
      ".cm-searchMatch": { backgroundColor: "#72a1ff59", outline: `1px solid ${$d}` },
      ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: eE },
      ".cm-activeLine": { backgroundColor: X1 },
      ".cm-selectionMatch": { backgroundColor: eE },
      "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": { outline: `1px solid ${$d}` },
      "&.cm-focused .cm-matchingBracket": { backgroundColor: Sv },
      ".cm-gutters": { backgroundColor: Sv, color: J_, border: "none" },
      ".cm-activeLineGutter": { backgroundColor: X1 },
      ".cm-foldPlaceholder": { backgroundColor: "transparent", border: "none", color: "#ddd" },
      ".cm-tooltip": { border: "none", backgroundColor: U1 },
      ".cm-tooltip .cm-tooltip-arrow:before": { borderTopColor: "transparent", borderBottomColor: "transparent" },
      ".cm-tooltip .cm-tooltip-arrow:after": { borderTopColor: U1, borderBottomColor: U1 },
      ".cm-tooltip-autocomplete": { "& > ul > li[aria-selected]": { backgroundColor: X1, color: $d } },
    },
    { dark: !1 }
  ),
  zue = Va.define([
    { tag: $.keyword, color: kr },
    { tag: [$.name, $.deleted, $.character, $.propertyName, $.macroName], color: ol },
    { tag: [$.variableName], color: ol },
    { tag: [$.function($.variableName)], color: kr },
    { tag: [$.labelName], color: Due },
    { tag: [$.color, $.constant($.name), $.standard($.name)], color: kr },
    { tag: [$.definition($.name), $.separator], color: nE },
    { tag: [$.brace], color: z1 },
    { tag: [$.annotation], color: rE },
    { tag: [$.number, $.changed, $.annotation, $.modifier, $.self, $.namespace], color: tE },
    { tag: [$.typeName, $.className], color: W1 },
    { tag: [$.operator, $.operatorKeyword], color: nE },
    { tag: [$.tagName], color: Bue },
    { tag: [$.squareBracket], color: Fue },
    { tag: [$.angleBracket], color: ol },
    { tag: [$.attributeName], color: W1 },
    { tag: [$.regexp], color: kr },
    { tag: [$.quote], color: _w },
    { tag: [$.string], color: ol },
    { tag: $.link, color: z1, textDecoration: "underline", textUnderlinePosition: "under" },
    { tag: [$.url, $.escape, $.special($.string)], color: ol },
    { tag: [$.meta], color: tE },
    { tag: [$.comment], color: K_, fontStyle: "italic" },
    { tag: $.strong, fontWeight: "bold", color: kr },
    { tag: $.emphasis, fontStyle: "italic", color: kr },
    { tag: $.strikethrough, textDecoration: "line-through" },
    { tag: $.heading, fontWeight: "bold", color: kr },
    { tag: $.special($.heading1), fontWeight: "bold", color: kr },
    { tag: $.heading1, fontWeight: "bold", color: kr },
    { tag: [$.heading2, $.heading3, $.heading4], fontWeight: "bold", color: kr },
    { tag: [$.heading5, $.heading6], color: kr },
    { tag: [$.atom, $.bool, $.special($.variableName)], color: ol },
    { tag: [$.processingInstruction, $.inserted], color: z1 },
    { tag: [$.contentSeparator], color: W1 },
    { tag: $.invalid, color: K_, borderBottom: `1px dotted ${rE}` },
  ]),
  R6 = [Zue, zy(zue)];
function Ot() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1,
    n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n)
      if (Object.prototype.hasOwnProperty.call(n, r)) {
        var i = n[r];
        typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++) I6(t, arguments[e]);
  return t;
}
function I6(t, e) {
  if (typeof e == "string") t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null) t.appendChild(e);
    else if (Array.isArray(e)) for (var n = 0; n < e.length; n++) I6(t, e[n]);
    else throw new RangeError("Unsupported child node: " + e);
}
const oE = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class ha {
  constructor(e, n, r = 0, i = e.length, o, s) {
    (this.test = s),
      (this.value = { from: 0, to: 0 }),
      (this.done = !1),
      (this.matches = []),
      (this.buffer = ""),
      (this.bufferPos = 0),
      (this.iter = e.iterRange(r, i)),
      (this.bufferStart = r),
      (this.normalize = o ? (l) => o(oE(l)) : oE),
      (this.query = this.normalize(n));
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (((this.bufferStart += this.buffer.length), this.iter.next(), this.iter.done)) return -1;
      (this.bufferPos = 0), (this.buffer = this.iter.value);
    }
    return an(this.buffer, this.bufferPos);
  }
  next() {
    for (; this.matches.length; ) this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (;;) {
      let e = this.peek();
      if (e < 0) return (this.done = !0), this;
      let n = Cy(e),
        r = this.bufferStart + this.bufferPos;
      this.bufferPos += dr(e);
      let i = this.normalize(n);
      for (let o = 0, s = r; ; o++) {
        let l = i.charCodeAt(o),
          a = this.match(l, s, this.bufferPos + this.bufferStart);
        if (o == i.length - 1) {
          if (a) return (this.value = a), this;
          break;
        }
        s == r && o < n.length && n.charCodeAt(o) == l && s++;
      }
    }
  }
  match(e, n, r) {
    let i = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let s = this.matches[o],
        l = !1;
      this.query.charCodeAt(s) == e &&
        (s == this.query.length - 1 ? (i = { from: this.matches[o + 1], to: r }) : (this.matches[o]++, (l = !0))),
        l || (this.matches.splice(o, 2), (o -= 2));
    }
    return (
      this.query.charCodeAt(0) == e && (this.query.length == 1 ? (i = { from: n, to: r }) : this.matches.push(1, n)),
      i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null),
      i
    );
  }
}
typeof Symbol < "u" &&
  (ha.prototype[Symbol.iterator] = function () {
    return this;
  });
const M6 = { from: -1, to: -1, match: /.*/.exec("") },
  Tw = "gm" + (/x/.unicode == null ? "" : "u");
class L6 {
  constructor(e, n, r, i = 0, o = e.length) {
    if (((this.text = e), (this.to = o), (this.curLine = ""), (this.done = !1), (this.value = M6), /\\[sWDnr]|\n|\r|\[\^/.test(n)))
      return new N6(e, n, r, i, o);
    (this.re = new RegExp(n, Tw + (r != null && r.ignoreCase ? "i" : ""))),
      (this.test = r == null ? void 0 : r.test),
      (this.iter = e.iter());
    let s = e.lineAt(i);
    (this.curLineStart = s.from), (this.matchPos = Ap(e, i)), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e),
      this.iter.lineBreak
        ? (this.curLine = "")
        : ((this.curLine = this.iter.value),
          this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)),
          this.iter.next());
  }
  nextLine() {
    (this.curLineStart = this.curLineStart + this.curLine.length + 1), this.curLineStart > this.to ? (this.curLine = "") : this.getLine(0);
  }
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index,
          i = r + n[0].length;
        if (
          ((this.matchPos = Ap(this.text, i + (r == i ? 1 : 0))),
          r == this.curLineStart + this.curLine.length && this.nextLine(),
          (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
        )
          return (this.value = { from: r, to: i, match: n }), this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) this.nextLine(), (e = 0);
      else return (this.done = !0), this;
    }
  }
}
const H1 = new WeakMap();
class jl {
  constructor(e, n) {
    (this.from = e), (this.text = n);
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, r) {
    let i = H1.get(e);
    if (!i || i.from >= r || i.to <= n) {
      let l = new jl(n, e.sliceString(n, r));
      return H1.set(e, l), l;
    }
    if (i.from == n && i.to == r) return i;
    let { text: o, from: s } = i;
    return (
      s > n && ((o = e.sliceString(n, s) + o), (s = n)),
      i.to < r && (o += e.sliceString(i.to, r)),
      H1.set(e, new jl(s, o)),
      new jl(n, o.slice(n - s, r - s))
    );
  }
}
class N6 {
  constructor(e, n, r, i, o) {
    (this.text = e),
      (this.to = o),
      (this.done = !1),
      (this.value = M6),
      (this.matchPos = Ap(e, i)),
      (this.re = new RegExp(n, Tw + (r != null && r.ignoreCase ? "i" : ""))),
      (this.test = r == null ? void 0 : r.test),
      (this.flat = jl.get(e, i, this.chunkEnd(i + 5e3)));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (;;) {
      let e = (this.re.lastIndex = this.matchPos - this.flat.from),
        n = this.re.exec(this.flat.text);
      if ((n && !n[0] && n.index == e && ((this.re.lastIndex = e + 1), (n = this.re.exec(this.flat.text))), n)) {
        let r = this.flat.from + n.index,
          i = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
          return (this.value = { from: r, to: i, match: n }), (this.matchPos = Ap(this.text, i + (r == i ? 1 : 0))), this;
      }
      if (this.flat.to == this.to) return (this.done = !0), this;
      this.flat = jl.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" &&
  (L6.prototype[Symbol.iterator] = N6.prototype[Symbol.iterator] =
    function () {
      return this;
    });
function Wue(t) {
  try {
    return new RegExp(t, Tw), !0;
  } catch {
    return !1;
  }
}
function Ap(t, e) {
  if (e >= t.length) return e;
  let n = t.lineAt(e),
    r;
  for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; ) e++;
  return e;
}
function kv(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number),
    n = Ot("input", { class: "cm-textfield", name: "line", value: e }),
    r = Ot(
      "form",
      {
        class: "cm-gotoLine",
        onkeydown: (o) => {
          o.keyCode == 27
            ? (o.preventDefault(), t.dispatch({ effects: $p.of(!1) }), t.focus())
            : o.keyCode == 13 && (o.preventDefault(), i());
        },
        onsubmit: (o) => {
          o.preventDefault(), i();
        },
      },
      Ot("label", t.state.phrase("Go to line"), ": ", n),
      " ",
      Ot("button", { class: "cm-button", type: "submit" }, t.state.phrase("go"))
    );
  function i() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!o) return;
    let { state: s } = t,
      l = s.doc.lineAt(s.selection.main.head),
      [, a, c, u, h] = o,
      d = u ? +u.slice(1) : 0,
      f = c ? +c : l.number;
    if (c && h) {
      let O = f / 100;
      a && (O = O * (a == "-" ? -1 : 1) + l.number / s.doc.lines), (f = Math.round(s.doc.lines * O));
    } else c && a && (f = f * (a == "-" ? -1 : 1) + l.number);
    let p = s.doc.line(Math.max(1, Math.min(s.doc.lines, f))),
      m = H.cursor(p.from + Math.max(0, Math.min(d, p.length)));
    t.dispatch({ effects: [$p.of(!1), re.scrollIntoView(m.from, { y: "center" })], selection: m }), t.focus();
  }
  return { dom: r };
}
const $p = Ee.define(),
  sE = Qt.define({
    create() {
      return !0;
    },
    update(t, e) {
      for (let n of e.effects) n.is($p) && (t = n.value);
      return t;
    },
    provide: (t) => ku.from(t, (e) => (e ? kv : null)),
  }),
  Xue = (t) => {
    let e = Su(t, kv);
    if (!e) {
      let n = [$p.of(!0)];
      t.state.field(sE, !1) == null && n.push(Ee.appendConfig.of([sE, Uue])), t.dispatch({ effects: n }), (e = Su(t, kv));
    }
    return e && e.dom.querySelector("input").select(), !0;
  },
  Uue = re.baseTheme({ ".cm-panel.cm-gotoLine": { padding: "2px 6px 4px", "& label": { fontSize: "80%" } } }),
  Hue = { highlightWordAroundCursor: !1, minSelectionLength: 1, maxMatches: 100, wholeWords: !1 },
  Q6 = xe.define({
    combine(t) {
      return Si(t, Hue, { highlightWordAroundCursor: (e, n) => e || n, minSelectionLength: Math.min, maxMatches: Math.min });
    },
  });
function que(t) {
  let e = [ehe, Kue];
  return t && e.push(Q6.of(t)), e;
}
const Yue = me.mark({ class: "cm-selectionMatch" }),
  Gue = me.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function lE(t, e, n, r) {
  return (n == 0 || t(e.sliceDoc(n - 1, n)) != Et.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != Et.Word);
}
function Jue(t, e, n, r) {
  return t(e.sliceDoc(n, n + 1)) == Et.Word && t(e.sliceDoc(r - 1, r)) == Et.Word;
}
const Kue = At.fromClass(
    class {
      constructor(t) {
        this.decorations = this.getDeco(t);
      }
      update(t) {
        (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
      }
      getDeco(t) {
        let e = t.state.facet(Q6),
          { state: n } = t,
          r = n.selection;
        if (r.ranges.length > 1) return me.none;
        let i = r.main,
          o,
          s = null;
        if (i.empty) {
          if (!e.highlightWordAroundCursor) return me.none;
          let a = n.wordAt(i.head);
          if (!a) return me.none;
          (s = n.charCategorizer(i.head)), (o = n.sliceDoc(a.from, a.to));
        } else {
          let a = i.to - i.from;
          if (a < e.minSelectionLength || a > 200) return me.none;
          if (e.wholeWords) {
            if (((o = n.sliceDoc(i.from, i.to)), (s = n.charCategorizer(i.head)), !(lE(s, n, i.from, i.to) && Jue(s, n, i.from, i.to))))
              return me.none;
          } else if (((o = n.sliceDoc(i.from, i.to)), !o)) return me.none;
        }
        let l = [];
        for (let a of t.visibleRanges) {
          let c = new ha(n.doc, o, a.from, a.to);
          for (; !c.next().done; ) {
            let { from: u, to: h } = c.value;
            if (
              (!s || lE(s, n, u, h)) &&
              (i.empty && u <= i.from && h >= i.to ? l.push(Gue.range(u, h)) : (u >= i.to || h <= i.from) && l.push(Yue.range(u, h)),
              l.length > e.maxMatches)
            )
              return me.none;
          }
        }
        return me.set(l);
      }
    },
    { decorations: (t) => t.decorations }
  ),
  ehe = re.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" },
  }),
  the = ({ state: t, dispatch: e }) => {
    let { selection: n } = t,
      r = H.create(
        n.ranges.map((i) => t.wordAt(i.head) || H.cursor(i.head)),
        n.mainIndex
      );
    return r.eq(n) ? !1 : (e(t.update({ selection: r })), !0);
  };
function nhe(t, e) {
  let { main: n, ranges: r } = t.selection,
    i = t.wordAt(n.head),
    o = i && i.from == n.from && i.to == n.to;
  for (let s = !1, l = new ha(t.doc, e, r[r.length - 1].to); ; )
    if ((l.next(), l.done)) {
      if (s) return null;
      (l = new ha(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1))), (s = !0);
    } else {
      if (s && r.some((a) => a.from == l.value.from)) continue;
      if (o) {
        let a = t.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to) continue;
      }
      return l.value;
    }
}
const rhe = ({ state: t, dispatch: e }) => {
    let { ranges: n } = t.selection;
    if (n.some((o) => o.from === o.to)) return the({ state: t, dispatch: e });
    let r = t.sliceDoc(n[0].from, n[0].to);
    if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != r)) return !1;
    let i = nhe(t, r);
    return i ? (e(t.update({ selection: t.selection.addRange(H.range(i.from, i.to), !1), effects: re.scrollIntoView(i.to) })), !0) : !1;
  },
  za = xe.define({
    combine(t) {
      return Si(t, {
        top: !1,
        caseSensitive: !1,
        literal: !1,
        regexp: !1,
        wholeWord: !1,
        createPanel: (e) => new mhe(e),
        scrollToMatch: (e) => re.scrollIntoView(e),
      });
    },
  });
class D6 {
  constructor(e) {
    (this.search = e.search),
      (this.caseSensitive = !!e.caseSensitive),
      (this.literal = !!e.literal),
      (this.regexp = !!e.regexp),
      (this.replace = e.replace || ""),
      (this.valid = !!this.search && (!this.regexp || Wue(this.search))),
      (this.unquoted = this.unquote(this.search)),
      (this.wholeWord = !!e.wholeWord);
  }
  unquote(e) {
    return this.literal
      ? e
      : e.replace(/\\([nrt\\])/g, (n, r) =>
          r == "n"
            ? `
`
            : r == "r"
            ? "\r"
            : r == "t"
            ? "	"
            : "\\"
        );
  }
  eq(e) {
    return (
      this.search == e.search &&
      this.replace == e.replace &&
      this.caseSensitive == e.caseSensitive &&
      this.regexp == e.regexp &&
      this.wholeWord == e.wholeWord
    );
  }
  create() {
    return this.regexp ? new lhe(this) : new ohe(this);
  }
  getCursor(e, n = 0, r) {
    let i = e.doc ? e : Me.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? fl(this, i, n, r) : dl(this, i, n, r);
  }
}
class F6 {
  constructor(e) {
    this.spec = e;
  }
}
function dl(t, e, n, r) {
  return new ha(
    e.doc,
    t.unquoted,
    n,
    r,
    t.caseSensitive ? void 0 : (i) => i.toLowerCase(),
    t.wholeWord ? ihe(e.doc, e.charCategorizer(e.selection.main.head)) : void 0
  );
}
function ihe(t, e) {
  return (n, r, i, o) => (
    (o > n || o + i.length < r) && ((o = Math.max(0, n - 2)), (i = t.sliceString(o, Math.min(t.length, r + 2)))),
    (e(Rp(i, n - o)) != Et.Word || e(Ip(i, n - o)) != Et.Word) && (e(Ip(i, r - o)) != Et.Word || e(Rp(i, r - o)) != Et.Word)
  );
}
class ohe extends F6 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, r) {
    let i = dl(this.spec, e, r, e.doc.length).nextOverlapping();
    return i.done && (i = dl(this.spec, e, 0, n).nextOverlapping()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = r; ; ) {
      let o = Math.max(n, i - 1e4 - this.spec.unquoted.length),
        s = dl(this.spec, e, o, i),
        l = null;
      for (; !s.nextOverlapping().done; ) l = s.value;
      if (l) return l;
      if (o == n) return null;
      i -= 1e4;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let r = dl(this.spec, e, 0, e.doc.length),
      i = [];
    for (; !r.next().done; ) {
      if (i.length >= n) return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let o = dl(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; ) i(o.value.from, o.value.to);
  }
}
function fl(t, e, n, r) {
  return new L6(
    e.doc,
    t.search,
    { ignoreCase: !t.caseSensitive, test: t.wholeWord ? she(e.charCategorizer(e.selection.main.head)) : void 0 },
    n,
    r
  );
}
function Rp(t, e) {
  return t.slice(dn(t, e, !1), e);
}
function Ip(t, e) {
  return t.slice(e, dn(t, e));
}
function she(t) {
  return (e, n, r) =>
    !r[0].length ||
    ((t(Rp(r.input, r.index)) != Et.Word || t(Ip(r.input, r.index)) != Et.Word) &&
      (t(Ip(r.input, r.index + r[0].length)) != Et.Word || t(Rp(r.input, r.index + r[0].length)) != Et.Word));
}
class lhe extends F6 {
  nextMatch(e, n, r) {
    let i = fl(this.spec, e, r, e.doc.length).next();
    return i.done && (i = fl(this.spec, e, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = 1; ; i++) {
      let o = Math.max(n, r - i * 1e4),
        s = fl(this.spec, e, o, r),
        l = null;
      for (; !s.next().done; ) l = s.value;
      if (l && (o == n || l.from > o + 10)) return l;
      if (o == n) return null;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec
      .unquote(this.spec.replace)
      .replace(/\$([$&\d+])/g, (n, r) => (r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : n));
  }
  matchAll(e, n) {
    let r = fl(this.spec, e, 0, e.doc.length),
      i = [];
    for (; !r.next().done; ) {
      if (i.length >= n) return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let o = fl(this.spec, e, Math.max(0, n - 250), Math.min(r + 250, e.doc.length));
    for (; !o.next().done; ) i(o.value.from, o.value.to);
  }
}
const Du = Ee.define(),
  Pw = Ee.define(),
  Ao = Qt.define({
    create(t) {
      return new q1(Cv(t).create(), null);
    },
    update(t, e) {
      for (let n of e.effects) n.is(Du) ? (t = new q1(n.value.create(), t.panel)) : n.is(Pw) && (t = new q1(t.query, n.value ? Aw : null));
      return t;
    },
    provide: (t) => ku.from(t, (e) => e.panel),
  });
class q1 {
  constructor(e, n) {
    (this.query = e), (this.panel = n);
  }
}
const ahe = me.mark({ class: "cm-searchMatch" }),
  che = me.mark({ class: "cm-searchMatch cm-searchMatch-selected" }),
  uhe = At.fromClass(
    class {
      constructor(t) {
        (this.view = t), (this.decorations = this.highlight(t.state.field(Ao)));
      }
      update(t) {
        let e = t.state.field(Ao);
        (e != t.startState.field(Ao) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
      }
      highlight({ query: t, panel: e }) {
        if (!e || !t.spec.valid) return me.none;
        let { view: n } = this,
          r = new lr();
        for (let i = 0, o = n.visibleRanges, s = o.length; i < s; i++) {
          let { from: l, to: a } = o[i];
          for (; i < s - 1 && a > o[i + 1].from - 2 * 250; ) a = o[++i].to;
          t.highlight(n.state, l, a, (c, u) => {
            let h = n.state.selection.ranges.some((d) => d.from == c && d.to == u);
            r.add(c, u, h ? che : ahe);
          });
        }
        return r.finish();
      }
    },
    { decorations: (t) => t.decorations }
  );
function Qh(t) {
  return (e) => {
    let n = e.state.field(Ao, !1);
    return n && n.query.spec.valid ? t(e, n) : j6(e);
  };
}
const Mp = Qh((t, { query: e }) => {
    let { to: n } = t.state.selection.main,
      r = e.nextMatch(t.state, n, n);
    if (!r) return !1;
    let i = H.single(r.from, r.to),
      o = t.state.facet(za);
    return t.dispatch({ selection: i, effects: [$w(t, r), o.scrollToMatch(i.main, t)], userEvent: "select.search" }), V6(t), !0;
  }),
  Lp = Qh((t, { query: e }) => {
    let { state: n } = t,
      { from: r } = n.selection.main,
      i = e.prevMatch(n, r, r);
    if (!i) return !1;
    let o = H.single(i.from, i.to),
      s = t.state.facet(za);
    return t.dispatch({ selection: o, effects: [$w(t, i), s.scrollToMatch(o.main, t)], userEvent: "select.search" }), V6(t), !0;
  }),
  hhe = Qh((t, { query: e }) => {
    let n = e.matchAll(t.state, 1e3);
    return !n || !n.length
      ? !1
      : (t.dispatch({ selection: H.create(n.map((r) => H.range(r.from, r.to))), userEvent: "select.search.matches" }), !0);
  }),
  dhe = ({ state: t, dispatch: e }) => {
    let n = t.selection;
    if (n.ranges.length > 1 || n.main.empty) return !1;
    let { from: r, to: i } = n.main,
      o = [],
      s = 0;
    for (let l = new ha(t.doc, t.sliceDoc(r, i)); !l.next().done; ) {
      if (o.length > 1e3) return !1;
      l.value.from == r && (s = o.length), o.push(H.range(l.value.from, l.value.to));
    }
    return e(t.update({ selection: H.create(o, s), userEvent: "select.search.matches" })), !0;
  },
  aE = Qh((t, { query: e }) => {
    let { state: n } = t,
      { from: r, to: i } = n.selection.main;
    if (n.readOnly) return !1;
    let o = e.nextMatch(n, r, r);
    if (!o) return !1;
    let s = [],
      l,
      a,
      c = [];
    if (
      (o.from == r &&
        o.to == i &&
        ((a = n.toText(e.getReplacement(o))),
        s.push({ from: o.from, to: o.to, insert: a }),
        (o = e.nextMatch(n, o.from, o.to)),
        c.push(re.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))),
      o)
    ) {
      let u = s.length == 0 || s[0].from >= o.to ? 0 : o.to - o.from - a.length;
      (l = H.single(o.from - u, o.to - u)), c.push($w(t, o)), c.push(n.facet(za).scrollToMatch(l.main, t));
    }
    return t.dispatch({ changes: s, selection: l, effects: c, userEvent: "input.replace" }), !0;
  }),
  fhe = Qh((t, { query: e }) => {
    if (t.state.readOnly) return !1;
    let n = e.matchAll(t.state, 1e9).map((i) => {
      let { from: o, to: s } = i;
      return { from: o, to: s, insert: e.getReplacement(i) };
    });
    if (!n.length) return !1;
    let r = t.state.phrase("replaced $ matches", n.length) + ".";
    return t.dispatch({ changes: n, effects: re.announce.of(r), userEvent: "input.replace.all" }), !0;
  });
function Aw(t) {
  return t.state.facet(za).createPanel(t);
}
function Cv(t, e) {
  var n, r, i, o, s;
  let l = t.selection.main,
    a = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to);
  if (e && !a) return e;
  let c = t.facet(za);
  return new D6({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : c.regexp,
    wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : c.wholeWord,
  });
}
function B6(t) {
  let e = Su(t, Aw);
  return e && e.dom.querySelector("[main-field]");
}
function V6(t) {
  let e = B6(t);
  e && e == t.root.activeElement && e.select();
}
const j6 = (t) => {
    let e = t.state.field(Ao, !1);
    if (e && e.panel) {
      let n = B6(t);
      if (n && n != t.root.activeElement) {
        let r = Cv(t.state, e.query.spec);
        r.valid && t.dispatch({ effects: Du.of(r) }), n.focus(), n.select();
      }
    } else t.dispatch({ effects: [Pw.of(!0), e ? Du.of(Cv(t.state, e.query.spec)) : Ee.appendConfig.of(Ohe)] });
    return !0;
  },
  Z6 = (t) => {
    let e = t.state.field(Ao, !1);
    if (!e || !e.panel) return !1;
    let n = Su(t, Aw);
    return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: Pw.of(!1) }), !0;
  },
  phe = [
    { key: "Mod-f", run: j6, scope: "editor search-panel" },
    { key: "F3", run: Mp, shift: Lp, scope: "editor search-panel", preventDefault: !0 },
    { key: "Mod-g", run: Mp, shift: Lp, scope: "editor search-panel", preventDefault: !0 },
    { key: "Escape", run: Z6, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: dhe },
    { key: "Mod-Alt-g", run: Xue },
    { key: "Mod-d", run: rhe, preventDefault: !0 },
  ];
class mhe {
  constructor(e) {
    this.view = e;
    let n = (this.query = e.state.field(Ao).query.spec);
    (this.commit = this.commit.bind(this)),
      (this.searchField = Ot("input", {
        value: n.search,
        placeholder: Gn(e, "Find"),
        "aria-label": Gn(e, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit,
      })),
      (this.replaceField = Ot("input", {
        value: n.replace,
        placeholder: Gn(e, "Replace"),
        "aria-label": Gn(e, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit,
      })),
      (this.caseField = Ot("input", { type: "checkbox", name: "case", form: "", checked: n.caseSensitive, onchange: this.commit })),
      (this.reField = Ot("input", { type: "checkbox", name: "re", form: "", checked: n.regexp, onchange: this.commit })),
      (this.wordField = Ot("input", { type: "checkbox", name: "word", form: "", checked: n.wholeWord, onchange: this.commit }));
    function r(i, o, s) {
      return Ot("button", { class: "cm-button", name: i, onclick: o, type: "button" }, s);
    }
    this.dom = Ot("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Mp(e), [Gn(e, "next")]),
      r("prev", () => Lp(e), [Gn(e, "previous")]),
      r("select", () => hhe(e), [Gn(e, "all")]),
      Ot("label", null, [this.caseField, Gn(e, "match case")]),
      Ot("label", null, [this.reField, Gn(e, "regexp")]),
      Ot("label", null, [this.wordField, Gn(e, "by word")]),
      ...(e.state.readOnly
        ? []
        : [
            Ot("br"),
            this.replaceField,
            r("replace", () => aE(e), [Gn(e, "replace")]),
            r("replaceAll", () => fhe(e), [Gn(e, "replace all")]),
          ]),
      Ot("button", { name: "close", onclick: () => Z6(e), "aria-label": Gn(e, "close"), type: "button" }, ["×"]),
    ]);
  }
  commit() {
    let e = new D6({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value,
    });
    e.eq(this.query) || ((this.query = e), this.view.dispatch({ effects: Du.of(e) }));
  }
  keydown(e) {
    Xte(this.view, e, "search-panel")
      ? e.preventDefault()
      : e.keyCode == 13 && e.target == this.searchField
      ? (e.preventDefault(), (e.shiftKey ? Lp : Mp)(this.view))
      : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), aE(this.view));
  }
  update(e) {
    for (let n of e.transactions) for (let r of n.effects) r.is(Du) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    (this.query = e),
      (this.searchField.value = e.search),
      (this.replaceField.value = e.replace),
      (this.caseField.checked = e.caseSensitive),
      (this.reField.checked = e.regexp),
      (this.wordField.checked = e.wholeWord);
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(za).top;
  }
}
function Gn(t, e) {
  return t.state.phrase(e);
}
const Rd = 30,
  Id = /[\s\.,:;?!]/;
function $w(t, { from: e, to: n }) {
  let r = t.state.doc.lineAt(e),
    i = t.state.doc.lineAt(n).to,
    o = Math.max(r.from, e - Rd),
    s = Math.min(i, n + Rd),
    l = t.state.sliceDoc(o, s);
  if (o != r.from) {
    for (let a = 0; a < Rd; a++)
      if (!Id.test(l[a + 1]) && Id.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (s != i) {
    for (let a = l.length - 1; a > l.length - Rd; a--)
      if (!Id.test(l[a - 1]) && Id.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return re.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${r.number}.`);
}
const ghe = re.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0,
      },
      "& input, & button, & label": { margin: ".2em .6em .2em 0" },
      "& input[type=checkbox]": { marginRight: ".2em" },
      "& label": { fontSize: "80%", whiteSpace: "pre" },
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" },
  }),
  Ohe = [Ao, zr.low(uhe), ghe];
class vhe {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.diagnostic = r);
  }
}
class ps {
  constructor(e, n, r) {
    (this.diagnostics = e), (this.panel = n), (this.selected = r);
  }
  static init(e, n, r) {
    let i = e,
      o = r.facet(Fu).markerFilter;
    o && (i = o(i, r));
    let s = me.set(
      i.map((l) =>
        l.from == l.to || (l.from == l.to - 1 && r.doc.lineAt(l.from).to == l.from)
          ? me.widget({ widget: new Ehe(l), diagnostic: l }).range(l.from)
          : me
              .mark({
                attributes: { class: "cm-lintRange cm-lintRange-" + l.severity + (l.markClass ? " " + l.markClass : "") },
                diagnostic: l,
              })
              .range(l.from, l.to)
      ),
      !0
    );
    return new ps(s, n, da(s));
  }
}
function da(t, e = null, n = 0) {
  let r = null;
  return (
    t.between(n, 1e9, (i, o, { spec: s }) => {
      if (!(e && s.diagnostic != e)) return (r = new vhe(i, o, s.diagnostic)), !1;
    }),
    r
  );
}
function bhe(t, e) {
  let n = e.pos,
    r = e.end || n,
    i = t.state.facet(Fu).hideOn(t, n, r);
  if (i != null) return i;
  let o = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((s) => s.is(z6)) || t.changes.touchesRange(o.from, Math.max(o.to, r)));
}
function xhe(t, e) {
  return t.field(or, !1) ? e : e.concat(Ee.appendConfig.of(Ahe));
}
const z6 = Ee.define(),
  Rw = Ee.define(),
  W6 = Ee.define(),
  or = Qt.define({
    create() {
      return new ps(me.none, null, null);
    },
    update(t, e) {
      if (e.docChanged && t.diagnostics.size) {
        let n = t.diagnostics.map(e.changes),
          r = null,
          i = t.panel;
        if (t.selected) {
          let o = e.changes.mapPos(t.selected.from, 1);
          r = da(n, t.selected.diagnostic, o) || da(n, null, o);
        }
        !n.size && i && e.state.facet(Fu).autoPanel && (i = null), (t = new ps(n, i, r));
      }
      for (let n of e.effects)
        if (n.is(z6)) {
          let r = e.state.facet(Fu).autoPanel ? (n.value.length ? Bu.open : null) : t.panel;
          t = ps.init(n.value, r, e.state);
        } else
          n.is(Rw)
            ? (t = new ps(t.diagnostics, n.value ? Bu.open : null, t.selected))
            : n.is(W6) && (t = new ps(t.diagnostics, t.panel, n.value));
      return t;
    },
    provide: (t) => [ku.from(t, (e) => e.panel), re.decorations.from(t, (e) => e.diagnostics)],
  }),
  yhe = me.mark({ class: "cm-lintRange cm-lintRange-active" });
function whe(t, e, n) {
  let { diagnostics: r } = t.state.field(or),
    i = [],
    o = 2e8,
    s = 0;
  r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (a, c, { spec: u }) => {
    e >= a &&
      e <= c &&
      (a == c || ((e > a || n > 0) && (e < c || n < 0))) &&
      (i.push(u.diagnostic), (o = Math.min(a, o)), (s = Math.max(c, s)));
  });
  let l = t.state.facet(Fu).tooltipFilter;
  return (
    l && (i = l(i, t.state)),
    i.length
      ? {
          pos: o,
          end: s,
          above: t.state.doc.lineAt(o).to < s,
          create() {
            return { dom: She(t, i) };
          },
        }
      : null
  );
}
function She(t, e) {
  return Ot(
    "ul",
    { class: "cm-tooltip-lint" },
    e.map((n) => U6(t, n, !1))
  );
}
const khe = (t) => {
    let e = t.state.field(or, !1);
    (!e || !e.panel) && t.dispatch({ effects: xhe(t.state, [Rw.of(!0)]) });
    let n = Su(t, Bu.open);
    return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
  },
  cE = (t) => {
    let e = t.state.field(or, !1);
    return !e || !e.panel ? !1 : (t.dispatch({ effects: Rw.of(!1) }), !0);
  },
  Che = (t) => {
    let e = t.state.field(or, !1);
    if (!e) return !1;
    let n = t.state.selection.main,
      r = e.diagnostics.iter(n.to + 1);
    return !r.value && ((r = e.diagnostics.iter(0)), !r.value || (r.from == n.from && r.to == n.to))
      ? !1
      : (t.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
  },
  _he = [
    { key: "Mod-Shift-m", run: khe, preventDefault: !0 },
    { key: "F8", run: Che },
  ],
  Fu = xe.define({
    combine(t) {
      return Object.assign(
        { sources: t.map((e) => e.source).filter((e) => e != null) },
        Si(
          t.map((e) => e.config),
          { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null, hideOn: () => null },
          { needsRefresh: (e, n) => (e ? (n ? (r) => e(r) || n(r) : e) : n) }
        )
      );
    },
  });
function X6(t) {
  let e = [];
  if (t)
    e: for (let { name: n } of t) {
      for (let r = 0; r < n.length; r++) {
        let i = n[r];
        if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function U6(t, e, n) {
  var r;
  let i = n ? X6(e.actions) : [];
  return Ot(
    "li",
    { class: "cm-diagnostic cm-diagnostic-" + e.severity },
    Ot("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message),
    (r = e.actions) === null || r === void 0
      ? void 0
      : r.map((o, s) => {
          let l = !1,
            a = (d) => {
              if ((d.preventDefault(), l)) return;
              l = !0;
              let f = da(t.state.field(or).diagnostics, e);
              f && o.apply(t, f.from, f.to);
            },
            { name: c } = o,
            u = i[s] ? c.indexOf(i[s]) : -1,
            h = u < 0 ? c : [c.slice(0, u), Ot("u", c.slice(u, u + 1)), c.slice(u + 1)];
          return Ot(
            "button",
            {
              type: "button",
              class: "cm-diagnosticAction",
              onclick: a,
              onmousedown: a,
              "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[s]})"`}.`,
            },
            h
          );
        }),
    e.source && Ot("div", { class: "cm-diagnosticSource" }, e.source)
  );
}
class Ehe extends Wr {
  constructor(e) {
    super(), (this.diagnostic = e);
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Ot("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class uE {
  constructor(e, n) {
    (this.diagnostic = n),
      (this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16)),
      (this.dom = U6(e, n, !0)),
      (this.dom.id = this.id),
      this.dom.setAttribute("role", "option");
  }
}
class Bu {
  constructor(e) {
    (this.view = e), (this.items = []);
    let n = (i) => {
        if (i.keyCode == 27) cE(this.view), this.view.focus();
        else if (i.keyCode == 38 || i.keyCode == 33) this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        else if (i.keyCode == 40 || i.keyCode == 34) this.moveSelection((this.selectedIndex + 1) % this.items.length);
        else if (i.keyCode == 36) this.moveSelection(0);
        else if (i.keyCode == 35) this.moveSelection(this.items.length - 1);
        else if (i.keyCode == 13) this.view.focus();
        else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic: o } = this.items[this.selectedIndex],
            s = X6(o.actions);
          for (let l = 0; l < s.length; l++)
            if (s[l].toUpperCase().charCodeAt(0) == i.keyCode) {
              let a = da(this.view.state.field(or).diagnostics, o);
              a && o.actions[l].apply(e, a.from, a.to);
            }
        } else return;
        i.preventDefault();
      },
      r = (i) => {
        for (let o = 0; o < this.items.length; o++) this.items[o].dom.contains(i.target) && this.moveSelection(o);
      };
    (this.list = Ot("ul", { tabIndex: 0, role: "listbox", "aria-label": this.view.state.phrase("Diagnostics"), onkeydown: n, onclick: r })),
      (this.dom = Ot(
        "div",
        { class: "cm-panel-lint" },
        this.list,
        Ot("button", { type: "button", name: "close", "aria-label": this.view.state.phrase("close"), onclick: () => cE(this.view) }, "×")
      )),
      this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(or).selected;
    if (!e) return -1;
    for (let n = 0; n < this.items.length; n++) if (this.items[n].diagnostic == e.diagnostic) return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(or),
      r = 0,
      i = !1,
      o = null;
    for (
      e.between(0, this.view.state.doc.length, (s, l, { spec: a }) => {
        let c = -1,
          u;
        for (let h = r; h < this.items.length; h++)
          if (this.items[h].diagnostic == a.diagnostic) {
            c = h;
            break;
          }
        c < 0
          ? ((u = new uE(this.view, a.diagnostic)), this.items.splice(r, 0, u), (i = !0))
          : ((u = this.items[c]), c > r && (this.items.splice(r, c - r), (i = !0))),
          n && u.diagnostic == n.diagnostic
            ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), (o = u))
            : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"),
          r++;
      });
      r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0);

    )
      (i = !0), this.items.pop();
    this.items.length == 0 &&
      (this.items.push(new uE(this.view, { from: -1, to: -1, severity: "info", message: this.view.state.phrase("No diagnostics") })),
      (i = !0)),
      o
        ? (this.list.setAttribute("aria-activedescendant", o.id),
          this.view.requestMeasure({
            key: this,
            read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
            write: ({ sel: s, panel: l }) => {
              let a = l.height / this.list.offsetHeight;
              s.top < l.top
                ? (this.list.scrollTop -= (l.top - s.top) / a)
                : s.bottom > l.bottom && (this.list.scrollTop += (s.bottom - l.bottom) / a);
            },
          }))
        : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"),
      i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let r = e;
      (e = r.nextSibling), r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; ) n();
        e = r.dom.nextSibling;
      } else this.list.insertBefore(r.dom, e);
    for (; e; ) n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0) return;
    let n = this.view.state.field(or),
      r = da(n.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0, effects: W6.of(r) });
  }
  static open(e) {
    return new Bu(e);
  }
}
function The(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Md(t) {
  return The(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const Phe = re.baseTheme({
    ".cm-diagnostic": { padding: "3px 6px 3px 8px", marginLeft: "-1px", display: "block", whiteSpace: "pre-wrap" },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer",
    },
    ".cm-diagnosticSource": { fontSize: "70%", opacity: 0.7 },
    ".cm-lintRange": { backgroundPosition: "left bottom", backgroundRepeat: "repeat-x", paddingBottom: "0.7px" },
    ".cm-lintRange-error": { backgroundImage: Md("#d11") },
    ".cm-lintRange-warning": { backgroundImage: Md("orange") },
    ".cm-lintRange-info": { backgroundImage: Md("#999") },
    ".cm-lintRange-hint": { backgroundImage: Md("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": { padding: 0, margin: 0 },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11",
      },
    },
    ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } },
    ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } },
    ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": { backgroundColor: "#ddd", "& u": { textDecoration: "underline" } },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText",
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0,
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0,
      },
    },
  }),
  Ahe = [
    or,
    re.decorations.compute([or], (t) => {
      let { selected: e, panel: n } = t.field(or);
      return !e || !n || e.from == e.to ? me.none : me.set([yhe.range(e.from, e.to)]);
    }),
    Ane(whe, { hideOn: bhe }),
    Phe,
  ],
  H6 = (() => [
    Jm(),
    Bne(),
    U7(),
    G4(),
    Are(),
    Jte(),
    rne(),
    Me.allowMultipleSelections.of(!0),
    vre(),
    zy(Mre, { fallback: !0 }),
    _4(),
    j4(),
    Zie(),
    bne(),
    wne(),
    H7(),
    que(),
    Qs.of([...W4, ...ER, ...phe, ...tR, ..._re, ...U4, ..._he]),
  ])();
function hE(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
function $he(t) {
  const e = _.useRef({ value: t, previous: t });
  return _.useMemo(
    () => (e.current.value !== t && ((e.current.previous = e.current.value), (e.current.value = t)), e.current.previous),
    [t]
  );
}
var Rhe = "VisuallyHidden",
  Iw = _.forwardRef((t, e) =>
    T.jsx(qe.span, {
      ...t,
      ref: e,
      style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...t.style,
      },
    })
  );
Iw.displayName = Rhe;
var Ihe = Iw,
  Mhe = [" ", "Enter", "ArrowUp", "ArrowDown"],
  Lhe = [" ", "Enter"],
  Dh = "Select",
  [hg, dg, Nhe] = x$(Dh),
  [Wa, Hme] = Jo(Dh, [Nhe, Ra]),
  fg = Ra(),
  [Qhe, ns] = Wa(Dh),
  [Dhe, Fhe] = Wa(Dh),
  q6 = (t) => {
    const {
        __scopeSelect: e,
        children: n,
        open: r,
        defaultOpen: i,
        onOpenChange: o,
        value: s,
        defaultValue: l,
        onValueChange: a,
        dir: c,
        name: u,
        autoComplete: h,
        disabled: d,
        required: f,
      } = t,
      p = fg(e),
      [m, O] = _.useState(null),
      [v, g] = _.useState(null),
      [b, x] = _.useState(!1),
      k = Mm(c),
      [w = !1, y] = Fo({ prop: r, defaultProp: i, onChange: o }),
      [C, P] = Fo({ prop: s, defaultProp: l, onChange: a }),
      E = _.useRef(null),
      N = m ? !!m.closest("form") : !0,
      [L, D] = _.useState(new Set()),
      Q = Array.from(L)
        .map((R) => R.props.value)
        .join(";");
    return T.jsx(Px, {
      ...p,
      children: T.jsxs(Qhe, {
        required: f,
        scope: e,
        trigger: m,
        onTriggerChange: O,
        valueNode: v,
        onValueNodeChange: g,
        valueNodeHasChildren: b,
        onValueNodeHasChildrenChange: x,
        contentId: Ta(),
        value: C,
        onValueChange: P,
        open: w,
        onOpenChange: y,
        dir: k,
        triggerPointerDownPosRef: E,
        disabled: d,
        children: [
          T.jsx(hg.Provider, {
            scope: e,
            children: T.jsx(Dhe, {
              scope: t.__scopeSelect,
              onNativeOptionAdd: _.useCallback((R) => {
                D((W) => new Set(W).add(R));
              }, []),
              onNativeOptionRemove: _.useCallback((R) => {
                D((W) => {
                  const B = new Set(W);
                  return B.delete(R), B;
                });
              }, []),
              children: n,
            }),
          }),
          N
            ? T.jsxs(
                g8,
                {
                  "aria-hidden": !0,
                  required: f,
                  tabIndex: -1,
                  name: u,
                  autoComplete: h,
                  value: C,
                  onChange: (R) => P(R.target.value),
                  disabled: d,
                  children: [C === void 0 ? T.jsx("option", { value: "" }) : null, Array.from(L)],
                },
                Q
              )
            : null,
        ],
      }),
    });
  };
q6.displayName = Dh;
var Y6 = "SelectTrigger",
  G6 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = t,
      o = fg(n),
      s = ns(Y6, n),
      l = s.disabled || r,
      a = Pt(e, s.onTriggerChange),
      c = dg(n),
      [u, h, d] = O8((p) => {
        const m = c().filter((g) => !g.disabled),
          O = m.find((g) => g.value === s.value),
          v = v8(m, p, O);
        v !== void 0 && s.onValueChange(v.value);
      }),
      f = () => {
        l || (s.onOpenChange(!0), d());
      };
    return T.jsx(_m, {
      asChild: !0,
      ...o,
      children: T.jsx(qe.button, {
        type: "button",
        role: "combobox",
        "aria-controls": s.contentId,
        "aria-expanded": s.open,
        "aria-required": s.required,
        "aria-autocomplete": "none",
        dir: s.dir,
        "data-state": s.open ? "open" : "closed",
        disabled: l,
        "data-disabled": l ? "" : void 0,
        "data-placeholder": m8(s.value) ? "" : void 0,
        ...i,
        ref: a,
        onClick: Be(i.onClick, (p) => {
          p.currentTarget.focus();
        }),
        onPointerDown: Be(i.onPointerDown, (p) => {
          const m = p.target;
          m.hasPointerCapture(p.pointerId) && m.releasePointerCapture(p.pointerId),
            p.button === 0 &&
              p.ctrlKey === !1 &&
              (f(), (s.triggerPointerDownPosRef.current = { x: Math.round(p.pageX), y: Math.round(p.pageY) }), p.preventDefault());
        }),
        onKeyDown: Be(i.onKeyDown, (p) => {
          const m = u.current !== "";
          !(p.ctrlKey || p.altKey || p.metaKey) && p.key.length === 1 && h(p.key),
            !(m && p.key === " ") && Mhe.includes(p.key) && (f(), p.preventDefault());
        }),
      }),
    });
  });
G6.displayName = Y6;
var J6 = "SelectValue",
  K6 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, className: r, style: i, children: o, placeholder: s = "", ...l } = t,
      a = ns(J6, n),
      { onValueNodeHasChildrenChange: c } = a,
      u = o !== void 0,
      h = Pt(e, a.onValueNodeChange);
    return (
      Rn(() => {
        c(u);
      }, [c, u]),
      T.jsx(qe.span, { ...l, ref: h, style: { pointerEvents: "none" }, children: m8(a.value) ? T.jsx(T.Fragment, { children: s }) : o })
    );
  });
K6.displayName = J6;
var Bhe = "SelectIcon",
  e8 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, children: r, ...i } = t;
    return T.jsx(qe.span, { "aria-hidden": !0, ...i, ref: e, children: r || "▼" });
  });
e8.displayName = Bhe;
var Vhe = "SelectPortal",
  t8 = (t) => T.jsx(Em, { asChild: !0, ...t });
t8.displayName = Vhe;
var Zs = "SelectContent",
  n8 = _.forwardRef((t, e) => {
    const n = ns(Zs, t.__scopeSelect),
      [r, i] = _.useState();
    if (
      (Rn(() => {
        i(new DocumentFragment());
      }, []),
      !n.open)
    ) {
      const o = r;
      return o
        ? Ss.createPortal(
            T.jsx(r8, {
              scope: t.__scopeSelect,
              children: T.jsx(hg.Slot, { scope: t.__scopeSelect, children: T.jsx("div", { children: t.children }) }),
            }),
            o
          )
        : null;
    }
    return T.jsx(i8, { ...t, ref: e });
  });
n8.displayName = Zs;
var $i = 10,
  [r8, rs] = Wa(Zs),
  jhe = "SelectContentImpl",
  i8 = _.forwardRef((t, e) => {
    const {
        __scopeSelect: n,
        position: r = "item-aligned",
        onCloseAutoFocus: i,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        side: l,
        sideOffset: a,
        align: c,
        alignOffset: u,
        arrowPadding: h,
        collisionBoundary: d,
        collisionPadding: f,
        sticky: p,
        hideWhenDetached: m,
        avoidCollisions: O,
        ...v
      } = t,
      g = ns(Zs, n),
      [b, x] = _.useState(null),
      [k, w] = _.useState(null),
      y = Pt(e, (Y) => x(Y)),
      [C, P] = _.useState(null),
      [E, N] = _.useState(null),
      L = dg(n),
      [D, Q] = _.useState(!1),
      R = _.useRef(!1);
    _.useEffect(() => {
      if (b) return iT(b);
    }, [b]),
      NA();
    const W = _.useCallback(
        (Y) => {
          const [q, ...oe] = L().map((_e) => _e.ref.current),
            [ce] = oe.slice(-1),
            Oe = document.activeElement;
          for (const _e of Y)
            if (
              _e === Oe ||
              (_e == null || _e.scrollIntoView({ block: "nearest" }),
              _e === q && k && (k.scrollTop = 0),
              _e === ce && k && (k.scrollTop = k.scrollHeight),
              _e == null || _e.focus(),
              document.activeElement !== Oe)
            )
              return;
        },
        [L, k]
      ),
      B = _.useCallback(() => W([C, b]), [W, C, b]);
    _.useEffect(() => {
      D && B();
    }, [D, B]);
    const { onOpenChange: K, triggerPointerDownPosRef: ne } = g;
    _.useEffect(() => {
      if (b) {
        let Y = { x: 0, y: 0 };
        const q = (ce) => {
            var Oe, _e;
            Y = {
              x: Math.abs(Math.round(ce.pageX) - (((Oe = ne.current) == null ? void 0 : Oe.x) ?? 0)),
              y: Math.abs(Math.round(ce.pageY) - (((_e = ne.current) == null ? void 0 : _e.y) ?? 0)),
            };
          },
          oe = (ce) => {
            Y.x <= 10 && Y.y <= 10 ? ce.preventDefault() : b.contains(ce.target) || K(!1),
              document.removeEventListener("pointermove", q),
              (ne.current = null);
          };
        return (
          ne.current !== null &&
            (document.addEventListener("pointermove", q), document.addEventListener("pointerup", oe, { capture: !0, once: !0 })),
          () => {
            document.removeEventListener("pointermove", q), document.removeEventListener("pointerup", oe, { capture: !0 });
          }
        );
      }
    }, [b, K, ne]),
      _.useEffect(() => {
        const Y = () => K(!1);
        return (
          window.addEventListener("blur", Y),
          window.addEventListener("resize", Y),
          () => {
            window.removeEventListener("blur", Y), window.removeEventListener("resize", Y);
          }
        );
      }, [K]);
    const [A, V] = O8((Y) => {
        const q = L().filter((Oe) => !Oe.disabled),
          oe = q.find((Oe) => Oe.ref.current === document.activeElement),
          ce = v8(q, Y, oe);
        ce && setTimeout(() => ce.ref.current.focus());
      }),
      ie = _.useCallback(
        (Y, q, oe) => {
          const ce = !R.current && !oe;
          ((g.value !== void 0 && g.value === q) || ce) && (P(Y), ce && (R.current = !0));
        },
        [g.value]
      ),
      M = _.useCallback(() => (b == null ? void 0 : b.focus()), [b]),
      fe = _.useCallback(
        (Y, q, oe) => {
          const ce = !R.current && !oe;
          ((g.value !== void 0 && g.value === q) || ce) && N(Y);
        },
        [g.value]
      ),
      Se = r === "popper" ? _v : o8,
      pe =
        Se === _v
          ? {
              side: l,
              sideOffset: a,
              align: c,
              alignOffset: u,
              arrowPadding: h,
              collisionBoundary: d,
              collisionPadding: f,
              sticky: p,
              hideWhenDetached: m,
              avoidCollisions: O,
            }
          : {};
    return T.jsx(r8, {
      scope: n,
      content: b,
      viewport: k,
      onViewportChange: w,
      itemRefCallback: ie,
      selectedItem: C,
      onItemLeave: M,
      itemTextRefCallback: fe,
      focusSelectedItem: B,
      selectedItemText: E,
      position: r,
      isPositioned: D,
      searchRef: A,
      children: T.jsx(a$, {
        as: Yl,
        allowPinchZoom: !0,
        children: T.jsx(bx, {
          asChild: !0,
          trapped: g.open,
          onMountAutoFocus: (Y) => {
            Y.preventDefault();
          },
          onUnmountAutoFocus: Be(i, (Y) => {
            var q;
            (q = g.trigger) == null || q.focus({ preventScroll: !0 }), Y.preventDefault();
          }),
          children: T.jsx(km, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown: o,
            onPointerDownOutside: s,
            onFocusOutside: (Y) => Y.preventDefault(),
            onDismiss: () => g.onOpenChange(!1),
            children: T.jsx(Se, {
              role: "listbox",
              id: g.contentId,
              "data-state": g.open ? "open" : "closed",
              dir: g.dir,
              onContextMenu: (Y) => Y.preventDefault(),
              ...v,
              ...pe,
              onPlaced: () => Q(!0),
              ref: y,
              style: { display: "flex", flexDirection: "column", outline: "none", ...v.style },
              onKeyDown: Be(v.onKeyDown, (Y) => {
                const q = Y.ctrlKey || Y.altKey || Y.metaKey;
                if (
                  (Y.key === "Tab" && Y.preventDefault(),
                  !q && Y.key.length === 1 && V(Y.key),
                  ["ArrowUp", "ArrowDown", "Home", "End"].includes(Y.key))
                ) {
                  let ce = L()
                    .filter((Oe) => !Oe.disabled)
                    .map((Oe) => Oe.ref.current);
                  if ((["ArrowUp", "End"].includes(Y.key) && (ce = ce.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(Y.key))) {
                    const Oe = Y.target,
                      _e = ce.indexOf(Oe);
                    ce = ce.slice(_e + 1);
                  }
                  setTimeout(() => W(ce)), Y.preventDefault();
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
i8.displayName = jhe;
var Zhe = "SelectItemAlignedPosition",
  o8 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, onPlaced: r, ...i } = t,
      o = ns(Zs, n),
      s = rs(Zs, n),
      [l, a] = _.useState(null),
      [c, u] = _.useState(null),
      h = Pt(e, (y) => u(y)),
      d = dg(n),
      f = _.useRef(!1),
      p = _.useRef(!0),
      { viewport: m, selectedItem: O, selectedItemText: v, focusSelectedItem: g } = s,
      b = _.useCallback(() => {
        if (o.trigger && o.valueNode && l && c && m && O && v) {
          const y = o.trigger.getBoundingClientRect(),
            C = c.getBoundingClientRect(),
            P = o.valueNode.getBoundingClientRect(),
            E = v.getBoundingClientRect();
          if (o.dir !== "rtl") {
            const Oe = E.left - C.left,
              _e = P.left - Oe,
              Le = y.left - _e,
              Ge = y.width + Le,
              Ct = Math.max(Ge, C.width),
              $t = window.innerWidth - $i,
              Rt = hE(_e, [$i, $t - Ct]);
            (l.style.minWidth = Ge + "px"), (l.style.left = Rt + "px");
          } else {
            const Oe = C.right - E.right,
              _e = window.innerWidth - P.right - Oe,
              Le = window.innerWidth - y.right - _e,
              Ge = y.width + Le,
              Ct = Math.max(Ge, C.width),
              $t = window.innerWidth - $i,
              Rt = hE(_e, [$i, $t - Ct]);
            (l.style.minWidth = Ge + "px"), (l.style.right = Rt + "px");
          }
          const N = d(),
            L = window.innerHeight - $i * 2,
            D = m.scrollHeight,
            Q = window.getComputedStyle(c),
            R = parseInt(Q.borderTopWidth, 10),
            W = parseInt(Q.paddingTop, 10),
            B = parseInt(Q.borderBottomWidth, 10),
            K = parseInt(Q.paddingBottom, 10),
            ne = R + W + D + K + B,
            A = Math.min(O.offsetHeight * 5, ne),
            V = window.getComputedStyle(m),
            ie = parseInt(V.paddingTop, 10),
            M = parseInt(V.paddingBottom, 10),
            fe = y.top + y.height / 2 - $i,
            Se = L - fe,
            pe = O.offsetHeight / 2,
            Y = O.offsetTop + pe,
            q = R + W + Y,
            oe = ne - q;
          if (q <= fe) {
            const Oe = O === N[N.length - 1].ref.current;
            l.style.bottom = "0px";
            const _e = c.clientHeight - m.offsetTop - m.offsetHeight,
              Le = Math.max(Se, pe + (Oe ? M : 0) + _e + B),
              Ge = q + Le;
            l.style.height = Ge + "px";
          } else {
            const Oe = O === N[0].ref.current;
            l.style.top = "0px";
            const Le = Math.max(fe, R + m.offsetTop + (Oe ? ie : 0) + pe) + oe;
            (l.style.height = Le + "px"), (m.scrollTop = q - fe + m.offsetTop);
          }
          (l.style.margin = `${$i}px 0`),
            (l.style.minHeight = A + "px"),
            (l.style.maxHeight = L + "px"),
            r == null || r(),
            requestAnimationFrame(() => (f.current = !0));
        }
      }, [d, o.trigger, o.valueNode, l, c, m, O, v, o.dir, r]);
    Rn(() => b(), [b]);
    const [x, k] = _.useState();
    Rn(() => {
      c && k(window.getComputedStyle(c).zIndex);
    }, [c]);
    const w = _.useCallback(
      (y) => {
        y && p.current === !0 && (b(), g == null || g(), (p.current = !1));
      },
      [b, g]
    );
    return T.jsx(Whe, {
      scope: n,
      contentWrapper: l,
      shouldExpandOnScrollRef: f,
      onScrollButtonChange: w,
      children: T.jsx("div", {
        ref: a,
        style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: x },
        children: T.jsx(qe.div, { ...i, ref: h, style: { boxSizing: "border-box", maxHeight: "100%", ...i.style } }),
      }),
    });
  });
o8.displayName = Zhe;
var zhe = "SelectPopperPosition",
  _v = _.forwardRef((t, e) => {
    const { __scopeSelect: n, align: r = "start", collisionPadding: i = $i, ...o } = t,
      s = fg(n);
    return T.jsx(Ax, {
      ...s,
      ...o,
      ref: e,
      align: r,
      collisionPadding: i,
      style: {
        boxSizing: "border-box",
        ...o.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)",
      },
    });
  });
_v.displayName = zhe;
var [Whe, Mw] = Wa(Zs, {}),
  Ev = "SelectViewport",
  s8 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, nonce: r, ...i } = t,
      o = rs(Ev, n),
      s = Mw(Ev, n),
      l = Pt(e, o.onViewportChange),
      a = _.useRef(0);
    return T.jsxs(T.Fragment, {
      children: [
        T.jsx("style", {
          dangerouslySetInnerHTML: {
            __html:
              "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}",
          },
          nonce: r,
        }),
        T.jsx(hg.Slot, {
          scope: n,
          children: T.jsx(qe.div, {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...i,
            ref: l,
            style: { position: "relative", flex: 1, overflow: "auto", ...i.style },
            onScroll: Be(i.onScroll, (c) => {
              const u = c.currentTarget,
                { contentWrapper: h, shouldExpandOnScrollRef: d } = s;
              if (d != null && d.current && h) {
                const f = Math.abs(a.current - u.scrollTop);
                if (f > 0) {
                  const p = window.innerHeight - $i * 2,
                    m = parseFloat(h.style.minHeight),
                    O = parseFloat(h.style.height),
                    v = Math.max(m, O);
                  if (v < p) {
                    const g = v + f,
                      b = Math.min(p, g),
                      x = g - b;
                    (h.style.height = b + "px"),
                      h.style.bottom === "0px" && ((u.scrollTop = x > 0 ? x : 0), (h.style.justifyContent = "flex-end"));
                  }
                }
              }
              a.current = u.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
s8.displayName = Ev;
var l8 = "SelectGroup",
  [Xhe, Uhe] = Wa(l8),
  Hhe = _.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t,
      i = Ta();
    return T.jsx(Xhe, { scope: n, id: i, children: T.jsx(qe.div, { role: "group", "aria-labelledby": i, ...r, ref: e }) });
  });
Hhe.displayName = l8;
var a8 = "SelectLabel",
  qhe = _.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t,
      i = Uhe(a8, n);
    return T.jsx(qe.div, { id: i.id, ...r, ref: e });
  });
qhe.displayName = a8;
var Np = "SelectItem",
  [Yhe, c8] = Wa(Np),
  u8 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, value: r, disabled: i = !1, textValue: o, ...s } = t,
      l = ns(Np, n),
      a = rs(Np, n),
      c = l.value === r,
      [u, h] = _.useState(o ?? ""),
      [d, f] = _.useState(!1),
      p = Pt(e, (v) => {
        var g;
        return (g = a.itemRefCallback) == null ? void 0 : g.call(a, v, r, i);
      }),
      m = Ta(),
      O = () => {
        i || (l.onValueChange(r), l.onOpenChange(!1));
      };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return T.jsx(Yhe, {
      scope: n,
      value: r,
      disabled: i,
      textId: m,
      isSelected: c,
      onItemTextChange: _.useCallback((v) => {
        h((g) => g || ((v == null ? void 0 : v.textContent) ?? "").trim());
      }, []),
      children: T.jsx(hg.ItemSlot, {
        scope: n,
        value: r,
        disabled: i,
        textValue: u,
        children: T.jsx(qe.div, {
          role: "option",
          "aria-labelledby": m,
          "data-highlighted": d ? "" : void 0,
          "aria-selected": c && d,
          "data-state": c ? "checked" : "unchecked",
          "aria-disabled": i || void 0,
          "data-disabled": i ? "" : void 0,
          tabIndex: i ? void 0 : -1,
          ...s,
          ref: p,
          onFocus: Be(s.onFocus, () => f(!0)),
          onBlur: Be(s.onBlur, () => f(!1)),
          onPointerUp: Be(s.onPointerUp, O),
          onPointerMove: Be(s.onPointerMove, (v) => {
            var g;
            i ? (g = a.onItemLeave) == null || g.call(a) : v.currentTarget.focus({ preventScroll: !0 });
          }),
          onPointerLeave: Be(s.onPointerLeave, (v) => {
            var g;
            v.currentTarget === document.activeElement && ((g = a.onItemLeave) == null || g.call(a));
          }),
          onKeyDown: Be(s.onKeyDown, (v) => {
            var b;
            (((b = a.searchRef) == null ? void 0 : b.current) !== "" && v.key === " ") ||
              (Lhe.includes(v.key) && O(), v.key === " " && v.preventDefault());
          }),
        }),
      }),
    });
  });
u8.displayName = Np;
var Pc = "SelectItemText",
  h8 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, className: r, style: i, ...o } = t,
      s = ns(Pc, n),
      l = rs(Pc, n),
      a = c8(Pc, n),
      c = Fhe(Pc, n),
      [u, h] = _.useState(null),
      d = Pt(
        e,
        (v) => h(v),
        a.onItemTextChange,
        (v) => {
          var g;
          return (g = l.itemTextRefCallback) == null ? void 0 : g.call(l, v, a.value, a.disabled);
        }
      ),
      f = u == null ? void 0 : u.textContent,
      p = _.useMemo(() => T.jsx("option", { value: a.value, disabled: a.disabled, children: f }, a.value), [a.disabled, a.value, f]),
      { onNativeOptionAdd: m, onNativeOptionRemove: O } = c;
    return (
      Rn(() => (m(p), () => O(p)), [m, O, p]),
      T.jsxs(T.Fragment, {
        children: [
          T.jsx(qe.span, { id: a.textId, ...o, ref: d }),
          a.isSelected && s.valueNode && !s.valueNodeHasChildren ? Ss.createPortal(o.children, s.valueNode) : null,
        ],
      })
    );
  });
h8.displayName = Pc;
var d8 = "SelectItemIndicator",
  Ghe = _.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return c8(d8, n).isSelected ? T.jsx(qe.span, { "aria-hidden": !0, ...r, ref: e }) : null;
  });
Ghe.displayName = d8;
var Tv = "SelectScrollUpButton",
  Jhe = _.forwardRef((t, e) => {
    const n = rs(Tv, t.__scopeSelect),
      r = Mw(Tv, t.__scopeSelect),
      [i, o] = _.useState(!1),
      s = Pt(e, r.onScrollButtonChange);
    return (
      Rn(() => {
        if (n.viewport && n.isPositioned) {
          let l = function () {
            const c = a.scrollTop > 0;
            o(c);
          };
          const a = n.viewport;
          return l(), a.addEventListener("scroll", l), () => a.removeEventListener("scroll", l);
        }
      }, [n.viewport, n.isPositioned]),
      i
        ? T.jsx(f8, {
            ...t,
            ref: s,
            onAutoScroll: () => {
              const { viewport: l, selectedItem: a } = n;
              l && a && (l.scrollTop = l.scrollTop - a.offsetHeight);
            },
          })
        : null
    );
  });
Jhe.displayName = Tv;
var Pv = "SelectScrollDownButton",
  Khe = _.forwardRef((t, e) => {
    const n = rs(Pv, t.__scopeSelect),
      r = Mw(Pv, t.__scopeSelect),
      [i, o] = _.useState(!1),
      s = Pt(e, r.onScrollButtonChange);
    return (
      Rn(() => {
        if (n.viewport && n.isPositioned) {
          let l = function () {
            const c = a.scrollHeight - a.clientHeight,
              u = Math.ceil(a.scrollTop) < c;
            o(u);
          };
          const a = n.viewport;
          return l(), a.addEventListener("scroll", l), () => a.removeEventListener("scroll", l);
        }
      }, [n.viewport, n.isPositioned]),
      i
        ? T.jsx(f8, {
            ...t,
            ref: s,
            onAutoScroll: () => {
              const { viewport: l, selectedItem: a } = n;
              l && a && (l.scrollTop = l.scrollTop + a.offsetHeight);
            },
          })
        : null
    );
  });
Khe.displayName = Pv;
var f8 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, onAutoScroll: r, ...i } = t,
      o = rs("SelectScrollButton", n),
      s = _.useRef(null),
      l = dg(n),
      a = _.useCallback(() => {
        s.current !== null && (window.clearInterval(s.current), (s.current = null));
      }, []);
    return (
      _.useEffect(() => () => a(), [a]),
      Rn(() => {
        var u;
        const c = l().find((h) => h.ref.current === document.activeElement);
        (u = c == null ? void 0 : c.ref.current) == null || u.scrollIntoView({ block: "nearest" });
      }, [l]),
      T.jsx(qe.div, {
        "aria-hidden": !0,
        ...i,
        ref: e,
        style: { flexShrink: 0, ...i.style },
        onPointerDown: Be(i.onPointerDown, () => {
          s.current === null && (s.current = window.setInterval(r, 50));
        }),
        onPointerMove: Be(i.onPointerMove, () => {
          var c;
          (c = o.onItemLeave) == null || c.call(o), s.current === null && (s.current = window.setInterval(r, 50));
        }),
        onPointerLeave: Be(i.onPointerLeave, () => {
          a();
        }),
      })
    );
  }),
  ede = "SelectSeparator",
  p8 = _.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return T.jsx(qe.div, { "aria-hidden": !0, ...r, ref: e });
  });
p8.displayName = ede;
var Av = "SelectArrow",
  tde = _.forwardRef((t, e) => {
    const { __scopeSelect: n, ...r } = t,
      i = fg(n),
      o = ns(Av, n),
      s = rs(Av, n);
    return o.open && s.position === "popper" ? T.jsx($x, { ...i, ...r, ref: e }) : null;
  });
tde.displayName = Av;
function m8(t) {
  return t === "" || t === void 0;
}
var g8 = _.forwardRef((t, e) => {
  const { value: n, ...r } = t,
    i = _.useRef(null),
    o = Pt(e, i),
    s = $he(n);
  return (
    _.useEffect(() => {
      const l = i.current,
        a = window.HTMLSelectElement.prototype,
        u = Object.getOwnPropertyDescriptor(a, "value").set;
      if (s !== n && u) {
        const h = new Event("change", { bubbles: !0 });
        u.call(l, n), l.dispatchEvent(h);
      }
    }, [s, n]),
    T.jsx(Iw, { asChild: !0, children: T.jsx("select", { ...r, ref: o, defaultValue: n }) })
  );
});
g8.displayName = "BubbleSelect";
function O8(t) {
  const e = vi(t),
    n = _.useRef(""),
    r = _.useRef(0),
    i = _.useCallback(
      (s) => {
        const l = n.current + s;
        e(l),
          (function a(c) {
            (n.current = c), window.clearTimeout(r.current), c !== "" && (r.current = window.setTimeout(() => a(""), 1e3));
          })(l);
      },
      [e]
    ),
    o = _.useCallback(() => {
      (n.current = ""), window.clearTimeout(r.current);
    }, []);
  return _.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, o];
}
function v8(t, e, n) {
  const i = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e,
    o = n ? t.indexOf(n) : -1;
  let s = nde(t, Math.max(o, 0));
  i.length === 1 && (s = s.filter((c) => c !== n));
  const a = s.find((c) => c.textValue.toLowerCase().startsWith(i.toLowerCase()));
  return a !== n ? a : void 0;
}
function nde(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var b8 = q6,
  x8 = G6,
  rde = K6,
  y8 = e8,
  ide = t8,
  ode = n8,
  sde = s8,
  lde = u8,
  ade = h8,
  cde = p8,
  [pg, qme] = Jo("Tooltip", [Ra]),
  mg = Ra(),
  w8 = "TooltipProvider",
  ude = 700,
  $v = "tooltip.open",
  [hde, Lw] = pg(w8),
  S8 = (t) => {
    const { __scopeTooltip: e, delayDuration: n = ude, skipDelayDuration: r = 300, disableHoverableContent: i = !1, children: o } = t,
      [s, l] = _.useState(!0),
      a = _.useRef(!1),
      c = _.useRef(0);
    return (
      _.useEffect(() => {
        const u = c.current;
        return () => window.clearTimeout(u);
      }, []),
      T.jsx(hde, {
        scope: e,
        isOpenDelayed: s,
        delayDuration: n,
        onOpen: _.useCallback(() => {
          window.clearTimeout(c.current), l(!1);
        }, []),
        onClose: _.useCallback(() => {
          window.clearTimeout(c.current), (c.current = window.setTimeout(() => l(!0), r));
        }, [r]),
        isPointerInTransitRef: a,
        onPointerInTransitChange: _.useCallback((u) => {
          a.current = u;
        }, []),
        disableHoverableContent: i,
        children: o,
      })
    );
  };
S8.displayName = w8;
var gg = "Tooltip",
  [dde, Fh] = pg(gg),
  k8 = (t) => {
    const {
        __scopeTooltip: e,
        children: n,
        open: r,
        defaultOpen: i = !1,
        onOpenChange: o,
        disableHoverableContent: s,
        delayDuration: l,
      } = t,
      a = Lw(gg, t.__scopeTooltip),
      c = mg(e),
      [u, h] = _.useState(null),
      d = Ta(),
      f = _.useRef(0),
      p = s ?? a.disableHoverableContent,
      m = l ?? a.delayDuration,
      O = _.useRef(!1),
      [v = !1, g] = Fo({
        prop: r,
        defaultProp: i,
        onChange: (y) => {
          y ? (a.onOpen(), document.dispatchEvent(new CustomEvent($v))) : a.onClose(), o == null || o(y);
        },
      }),
      b = _.useMemo(() => (v ? (O.current ? "delayed-open" : "instant-open") : "closed"), [v]),
      x = _.useCallback(() => {
        window.clearTimeout(f.current), (O.current = !1), g(!0);
      }, [g]),
      k = _.useCallback(() => {
        window.clearTimeout(f.current), g(!1);
      }, [g]),
      w = _.useCallback(() => {
        window.clearTimeout(f.current),
          (f.current = window.setTimeout(() => {
            (O.current = !0), g(!0);
          }, m));
      }, [m, g]);
    return (
      _.useEffect(() => () => window.clearTimeout(f.current), []),
      T.jsx(Px, {
        ...c,
        children: T.jsx(dde, {
          scope: e,
          contentId: d,
          open: v,
          stateAttribute: b,
          trigger: u,
          onTriggerChange: h,
          onTriggerEnter: _.useCallback(() => {
            a.isOpenDelayed ? w() : x();
          }, [a.isOpenDelayed, w, x]),
          onTriggerLeave: _.useCallback(() => {
            p ? k() : window.clearTimeout(f.current);
          }, [k, p]),
          onOpen: x,
          onClose: k,
          disableHoverableContent: p,
          children: n,
        }),
      })
    );
  };
k8.displayName = gg;
var Rv = "TooltipTrigger",
  C8 = _.forwardRef((t, e) => {
    const { __scopeTooltip: n, ...r } = t,
      i = Fh(Rv, n),
      o = Lw(Rv, n),
      s = mg(n),
      l = _.useRef(null),
      a = Pt(e, l, i.onTriggerChange),
      c = _.useRef(!1),
      u = _.useRef(!1),
      h = _.useCallback(() => (c.current = !1), []);
    return (
      _.useEffect(() => () => document.removeEventListener("pointerup", h), [h]),
      T.jsx(_m, {
        asChild: !0,
        ...s,
        children: T.jsx(qe.button, {
          "aria-describedby": i.open ? i.contentId : void 0,
          "data-state": i.stateAttribute,
          ...r,
          ref: a,
          onPointerMove: Be(t.onPointerMove, (d) => {
            d.pointerType !== "touch" && !u.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), (u.current = !0));
          }),
          onPointerLeave: Be(t.onPointerLeave, () => {
            i.onTriggerLeave(), (u.current = !1);
          }),
          onPointerDown: Be(t.onPointerDown, () => {
            (c.current = !0), document.addEventListener("pointerup", h, { once: !0 });
          }),
          onFocus: Be(t.onFocus, () => {
            c.current || i.onOpen();
          }),
          onBlur: Be(t.onBlur, i.onClose),
          onClick: Be(t.onClick, i.onClose),
        }),
      })
    );
  });
C8.displayName = Rv;
var Nw = "TooltipPortal",
  [fde, pde] = pg(Nw, { forceMount: void 0 }),
  _8 = (t) => {
    const { __scopeTooltip: e, forceMount: n, children: r, container: i } = t,
      o = Fh(Nw, e);
    return T.jsx(fde, {
      scope: e,
      forceMount: n,
      children: T.jsx(hh, { present: n || o.open, children: T.jsx(Em, { asChild: !0, container: i, children: r }) }),
    });
  };
_8.displayName = Nw;
var fa = "TooltipContent",
  E8 = _.forwardRef((t, e) => {
    const n = pde(fa, t.__scopeTooltip),
      { forceMount: r = n.forceMount, side: i = "top", ...o } = t,
      s = Fh(fa, t.__scopeTooltip);
    return T.jsx(hh, {
      present: r || s.open,
      children: s.disableHoverableContent ? T.jsx(T8, { side: i, ...o, ref: e }) : T.jsx(mde, { side: i, ...o, ref: e }),
    });
  }),
  mde = _.forwardRef((t, e) => {
    const n = Fh(fa, t.__scopeTooltip),
      r = Lw(fa, t.__scopeTooltip),
      i = _.useRef(null),
      o = Pt(e, i),
      [s, l] = _.useState(null),
      { trigger: a, onClose: c } = n,
      u = i.current,
      { onPointerInTransitChange: h } = r,
      d = _.useCallback(() => {
        l(null), h(!1);
      }, [h]),
      f = _.useCallback(
        (p, m) => {
          const O = p.currentTarget,
            v = { x: p.clientX, y: p.clientY },
            g = vde(v, O.getBoundingClientRect()),
            b = bde(v, g),
            x = xde(m.getBoundingClientRect()),
            k = wde([...b, ...x]);
          l(k), h(!0);
        },
        [h]
      );
    return (
      _.useEffect(() => () => d(), [d]),
      _.useEffect(() => {
        if (a && u) {
          const p = (O) => f(O, u),
            m = (O) => f(O, a);
          return (
            a.addEventListener("pointerleave", p),
            u.addEventListener("pointerleave", m),
            () => {
              a.removeEventListener("pointerleave", p), u.removeEventListener("pointerleave", m);
            }
          );
        }
      }, [a, u, f, d]),
      _.useEffect(() => {
        if (s) {
          const p = (m) => {
            const O = m.target,
              v = { x: m.clientX, y: m.clientY },
              g = (a == null ? void 0 : a.contains(O)) || (u == null ? void 0 : u.contains(O)),
              b = !yde(v, s);
            g ? d() : b && (d(), c());
          };
          return document.addEventListener("pointermove", p), () => document.removeEventListener("pointermove", p);
        }
      }, [a, u, s, c, d]),
      T.jsx(T8, { ...t, ref: o })
    );
  }),
  [gde, Ode] = pg(gg, { isInside: !1 }),
  T8 = _.forwardRef((t, e) => {
    const { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: o, onPointerDownOutside: s, ...l } = t,
      a = Fh(fa, n),
      c = mg(n),
      { onClose: u } = a;
    return (
      _.useEffect(() => (document.addEventListener($v, u), () => document.removeEventListener($v, u)), [u]),
      _.useEffect(() => {
        if (a.trigger) {
          const h = (d) => {
            const f = d.target;
            f != null && f.contains(a.trigger) && u();
          };
          return window.addEventListener("scroll", h, { capture: !0 }), () => window.removeEventListener("scroll", h, { capture: !0 });
        }
      }, [a.trigger, u]),
      T.jsx(km, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        onFocusOutside: (h) => h.preventDefault(),
        onDismiss: u,
        children: T.jsxs(Ax, {
          "data-state": a.stateAttribute,
          ...c,
          ...l,
          ref: e,
          style: {
            ...l.style,
            "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
            "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)",
          },
          children: [
            T.jsx(IA, { children: r }),
            T.jsx(gde, { scope: n, isInside: !0, children: T.jsx(Ihe, { id: a.contentId, role: "tooltip", children: i || r }) }),
          ],
        }),
      })
    );
  });
E8.displayName = fa;
var P8 = "TooltipArrow",
  A8 = _.forwardRef((t, e) => {
    const { __scopeTooltip: n, ...r } = t,
      i = mg(n);
    return Ode(P8, n).isInside ? null : T.jsx($x, { ...i, ...r, ref: e });
  });
A8.displayName = P8;
function vde(t, e) {
  const n = Math.abs(e.top - t.y),
    r = Math.abs(e.bottom - t.y),
    i = Math.abs(e.right - t.x),
    o = Math.abs(e.left - t.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function bde(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push({ x: t.x - n, y: t.y + n }, { x: t.x + n, y: t.y + n });
      break;
    case "bottom":
      r.push({ x: t.x - n, y: t.y - n }, { x: t.x + n, y: t.y - n });
      break;
    case "left":
      r.push({ x: t.x + n, y: t.y - n }, { x: t.x + n, y: t.y + n });
      break;
    case "right":
      r.push({ x: t.x - n, y: t.y - n }, { x: t.x - n, y: t.y + n });
      break;
  }
  return r;
}
function xde(t) {
  const { top: e, right: n, bottom: r, left: i } = t;
  return [
    { x: i, y: e },
    { x: n, y: e },
    { x: n, y: r },
    { x: i, y: r },
  ];
}
function yde(t, e) {
  const { x: n, y: r } = t;
  let i = !1;
  for (let o = 0, s = e.length - 1; o < e.length; s = o++) {
    const l = e[o].x,
      a = e[o].y,
      c = e[s].x,
      u = e[s].y;
    a > r != u > r && n < ((c - l) * (r - a)) / (u - a) + l && (i = !i);
  }
  return i;
}
function wde(t) {
  const e = t.slice();
  return e.sort((n, r) => (n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0)), Sde(e);
}
function Sde(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    for (; e.length >= 2; ) {
      const o = e[e.length - 1],
        s = e[e.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) e.pop();
      else break;
    }
    e.push(i);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1],
        s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var $8 = S8,
  R8 = k8,
  I8 = C8,
  M8 = _8,
  L8 = E8,
  kde = A8;
const is = S.forwardRef(({ title: t, children: e }, n) => {
    const r = mt(jr);
    return S.createElement(
      $8,
      { delayDuration: 100 },
      S.createElement(
        R8,
        null,
        S.createElement(I8, { ref: n, asChild: !0 }, S.createElement("span", { className: F.tooltipTrigger }, e)),
        S.createElement(
          M8,
          { container: r == null ? void 0 : r.current },
          S.createElement(L8, { className: Fe(F.tooltipContent), sideOffset: 10 }, t)
        )
      )
    );
  }),
  Qw = S.forwardRef(({ children: t, className: e, ...n }, r) =>
    S.createElement(lde, { ...n, ref: r, className: Fe(e, F.selectItem) }, S.createElement(ade, null, t))
  ),
  N8 = ({ title: t, placeholder: e, className: n }) => {
    const [r, i] = Ye(Gt, st);
    return S.createElement(
      is,
      { title: t },
      S.createElement(
        x8,
        { "aria-label": e, className: Fe(F.selectTrigger, n), "data-toolbar-item": !0, disabled: r },
        S.createElement(rde, { placeholder: e }),
        S.createElement(y8, { className: F.selectDropdownArrow }, i("arrow_drop_down"))
      )
    );
  },
  Dw = ({ children: t, className: e = F.selectContainer }) => {
    const n = mt(jr);
    return S.createElement(
      ide,
      { container: n == null ? void 0 : n.current },
      S.createElement(
        ode,
        {
          className: Fe(e, "mdxeditor-select-content"),
          onCloseAutoFocus: (r) => {
            r.preventDefault();
          },
          position: "popper",
        },
        S.createElement(sde, { "data-editor-dropdown": !0 }, t)
      )
    );
  },
  Q8 = ({ children: t, title: e, className: n }) => {
    const [r, i] = Ye(Gt, st);
    return S.createElement(
      is,
      { title: e },
      S.createElement(
        x8,
        { className: Fe(F.toolbarButtonSelectTrigger, n), disabled: r },
        t,
        S.createElement(y8, { className: F.selectDropdownArrow }, i("arrow_drop_down"))
      )
    );
  },
  Bh = (t) =>
    S.createElement(
      b8,
      { value: t.value || void 0, onValueChange: t.onChange },
      S.createElement(N8, { title: t.triggerTitle, placeholder: t.placeholder }),
      S.createElement(
        Dw,
        null,
        t.items.map((e, n) =>
          e === "separator" ? S.createElement(cde, { key: n }) : S.createElement(Qw, { key: n, value: e.value }, e.label)
        )
      )
    ),
  Cde = [],
  dE = "__EMPTY_VALUE__",
  D8 = ({ language: t, nodeKey: e, code: n, focusEmitter: r }) => {
    const i = nt(),
      { parentEditor: o, lexicalNode: s } = ta(),
      [l, a, c, u, h] = Ye(Gt, Qp, Dp, st, Vu),
      d = $6(e, "codeblock", t, r),
      { setCode: f } = ta(),
      p = S.useRef(null),
      m = S.useRef(null),
      O = S.useRef(f);
    return (
      (O.current = f),
      (d.current = { getCodemirror: () => p.current }),
      S.useEffect(
        () => (
          (async () => {
            const v = [
              ...a,
              H6,
              R6,
              Jm(),
              re.lineWrapping,
              re.updateListener.of(({ state: g }) => {
                O.current(g.doc.toString());
              }),
            ];
            if ((l && v.push(Me.readOnly.of(!0)), t !== "" && c)) {
              const g = Que.find((b) => b.name === t || b.alias.includes(t) || b.extensions.includes(t));
              if (g)
                try {
                  const b = await g.load();
                  v.push(b.extension);
                } catch {
                  console.warn("failed to load language support for", t);
                }
            }
            (m.current.innerHTML = ""), (p.current = new re({ parent: m.current, state: Me.create({ doc: n, extensions: v }) }));
          })(),
          () => {
            var v;
            (v = p.current) == null || v.destroy(), (p.current = null);
          }
        ),
        [l, t]
      ),
      S.createElement(
        "div",
        {
          className: F.codeMirrorWrapper,
          onKeyDown: (v) => {
            v.stopPropagation();
          },
        },
        S.createElement(
          "div",
          { className: F.codeMirrorToolbar },
          S.createElement(Bh, {
            value: t,
            onChange: (v) => {
              o.update(() => {
                s.setLanguage(v === dE ? "" : v),
                  setTimeout(() => {
                    o.update(() => {
                      s.getLatest().select();
                    });
                  });
              });
            },
            triggerTitle: i("codeBlock.selectLanguage", "Select code block language"),
            placeholder: i("codeBlock.inlineLanguage", "Language"),
            items: Object.entries(h).map(([v, g]) => ({ value: v || dE, label: g })),
          }),
          S.createElement(
            "button",
            {
              className: F.iconButton,
              type: "button",
              title: i("codeblock.delete", "Delete code block"),
              onClick: (v) => {
                v.preventDefault(),
                  o.update(() => {
                    s.remove();
                  });
              },
            },
            u("delete_small")
          )
        ),
        S.createElement("div", { ref: m })
      )
    );
  },
  Vu = we({ js: "JavaScript", ts: "TypeScript", tsx: "TypeScript (React)", jsx: "JavaScript (React)", css: "CSS" }),
  F8 = kt((t) => {
    t.link(
      t.pipe(
        F8,
        mr(({ language: e, code: n }) => ({ code: n, language: e, meta: "" }))
      ),
      Eh
    );
  }),
  Qp = we([]),
  Dp = we(!0),
  _de = Ut({
    update(t, e) {
      t.pubIn({
        [Vu]: e == null ? void 0 : e.codeBlockLanguages,
        [Qp]: (e == null ? void 0 : e.codeMirrorExtensions) ?? [],
        [Dp]: (e == null ? void 0 : e.autoLoadLanguageSupport) ?? !0,
      });
    },
    init(t, e) {
      t.pubIn({
        [Vu]: e == null ? void 0 : e.codeBlockLanguages,
        [Qp]: (e == null ? void 0 : e.codeMirrorExtensions) ?? [],
        [Sy]: Ede((e == null ? void 0 : e.codeBlockLanguages) ?? {}),
        [Dp]: (e == null ? void 0 : e.autoLoadLanguageSupport) ?? !0,
      });
    },
  });
function Ede(t) {
  return {
    match(e, n) {
      return !!Object.hasOwn(t, e ?? "") && !n;
    },
    priority: 1,
    Editor: D8,
  };
}
const Tde = {}.hasOwnProperty,
  fE = /^[^\t\n\r "#'.<=>`}]+$/;
ff.peek = Nde;
function Pde() {
  return {
    canContainEols: ["textDirective"],
    enter: {
      directiveContainer: $de,
      directiveContainerAttributes: G1,
      directiveContainerLabel: Mde,
      directiveLeaf: Rde,
      directiveLeafAttributes: G1,
      directiveText: Ide,
      directiveTextAttributes: G1,
    },
    exit: {
      directiveContainer: r0,
      directiveContainerAttributeClassValue: K1,
      directiveContainerAttributeIdValue: J1,
      directiveContainerAttributeName: t0,
      directiveContainerAttributeValue: e0,
      directiveContainerAttributes: n0,
      directiveContainerLabel: Lde,
      directiveContainerName: Y1,
      directiveLeaf: r0,
      directiveLeafAttributeClassValue: K1,
      directiveLeafAttributeIdValue: J1,
      directiveLeafAttributeName: t0,
      directiveLeafAttributeValue: e0,
      directiveLeafAttributes: n0,
      directiveLeafName: Y1,
      directiveText: r0,
      directiveTextAttributeClassValue: K1,
      directiveTextAttributeIdValue: J1,
      directiveTextAttributeName: t0,
      directiveTextAttributeValue: e0,
      directiveTextAttributes: n0,
      directiveTextName: Y1,
    },
  };
}
function Ade() {
  return {
    unsafe: [
      { character: "\r", inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"] },
      {
        character: `
`,
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"],
      },
      { before: "[^:]", character: ":", after: "[A-Za-z]", inConstruct: ["phrasing"] },
      { atBreak: !0, character: ":", after: ":" },
    ],
    handlers: { containerDirective: ff, leafDirective: ff, textDirective: ff },
  };
}
function $de(t) {
  Fw.call(this, "containerDirective", t);
}
function Rde(t) {
  Fw.call(this, "leafDirective", t);
}
function Ide(t) {
  Fw.call(this, "textDirective", t);
}
function Fw(t, e) {
  this.enter({ type: t, name: "", attributes: {}, children: [] }, e);
}
function Y1(t) {
  const e = this.stack[this.stack.length - 1];
  e.type === "containerDirective" || e.type === "leafDirective" || e.type, (e.name = this.sliceSerialize(t));
}
function Mde(t) {
  this.enter({ type: "paragraph", data: { directiveLabel: !0 }, children: [] }, t);
}
function Lde(t) {
  this.exit(t);
}
function G1() {
  (this.data.directiveAttributes = []), this.buffer();
}
function J1(t) {
  this.data.directiveAttributes.push(["id", fm(this.sliceSerialize(t), { attribute: !0 })]);
}
function K1(t) {
  this.data.directiveAttributes.push(["class", fm(this.sliceSerialize(t), { attribute: !0 })]);
}
function e0(t) {
  const e = this.data.directiveAttributes;
  e[e.length - 1][1] = fm(this.sliceSerialize(t), { attribute: !0 });
}
function t0(t) {
  this.data.directiveAttributes.push([this.sliceSerialize(t), ""]);
}
function n0() {
  const t = this.data.directiveAttributes,
    e = {};
  let n = -1;
  for (; ++n < t.length; ) {
    const i = t[n];
    i[0] === "class" && e.class ? (e.class += " " + i[1]) : (e[i[0]] = i[1]);
  }
  (this.data.directiveAttributes = void 0), this.resume();
  const r = this.stack[this.stack.length - 1];
  r.type === "containerDirective" || r.type === "leafDirective" || r.type, (r.attributes = e);
}
function r0(t) {
  this.exit(t);
}
function ff(t, e, n, r) {
  const i = n.createTracker(r),
    o = Dde(t),
    s = n.enter(t.type);
  let l = i.move(o + (t.name || "")),
    a;
  if (t.type === "containerDirective") {
    const c = (t.children || [])[0];
    a = pE(c) ? c : void 0;
  } else a = t;
  if (a && a.children && a.children.length > 0) {
    const c = n.enter("label"),
      u = `${t.type}Label`,
      h = n.enter(u);
    (l += i.move("[")), (l += i.move(n.containerPhrasing(a, { ...i.current(), before: l, after: "]" }))), (l += i.move("]")), h(), c();
  }
  if (((l += i.move(Qde(t, n))), t.type === "containerDirective")) {
    const c = (t.children || [])[0];
    let u = t;
    pE(c) && (u = Object.assign({}, t, { children: t.children.slice(1) })),
      u &&
        u.children &&
        u.children.length > 0 &&
        ((l += i.move(`
`)),
        (l += i.move(n.containerFlow(u, i.current())))),
      (l += i.move(
        `
` + o
      ));
  }
  return s(), l;
}
function Nde() {
  return ":";
}
function Qde(t, e) {
  const n = e.options.quote || '"',
    r =
      t.type === "textDirective"
        ? [n]
        : [
            n,
            `
`,
            "\r",
          ],
    i = t.attributes || {},
    o = [];
  let s, l, a, c;
  for (c in i)
    if (Tde.call(i, c) && i[c] !== void 0 && i[c] !== null) {
      const h = String(i[c]);
      if (c === "id") a = fE.test(h) ? "#" + h : u("id", h);
      else if (c === "class") {
        const d = h.split(/[\t\n\r ]+/g),
          f = [],
          p = [];
        let m = -1;
        for (; ++m < d.length; ) (fE.test(d[m]) ? p : f).push(d[m]);
        (s = f.length > 0 ? u("class", f.join(" ")) : ""), (l = p.length > 0 ? "." + p.join(".") : "");
      } else o.push(u(c, h));
    }
  return s && o.unshift(s), l && o.unshift(l), a && o.unshift(a), o.length > 0 ? "{" + o.join(" ") + "}" : "";
  function u(h, d) {
    return h + (d ? "=" + n + vP(d, { subset: r }) + n : "");
  }
}
function pE(t) {
  return !!(t && t.type === "paragraph" && t.data && t.data.directiveLabel);
}
function Dde(t) {
  let e = 0;
  return (
    t.type === "containerDirective"
      ? (RP(t, function (n, r) {
          if (n.type === "containerDirective") {
            let i = r.length,
              o = 0;
            for (; i--; ) r[i].type === "containerDirective" && o++;
            o > e && (e = o);
          }
        }),
        (e += 3))
      : t.type === "leafDirective"
      ? (e = 2)
      : (e = 1),
    ":".repeat(e)
  );
}
function Bw(t, e, n, r, i, o, s, l, a, c, u, h, d, f, p) {
  let m, O;
  return v;
  function v(R) {
    return t.enter(r), t.enter(i), t.consume(R), t.exit(i), g;
  }
  function g(R) {
    return R === 35
      ? ((m = s), b(R))
      : R === 46
      ? ((m = l), b(R))
      : R === 58 || R === 95 || tr(R)
      ? (t.enter(o), t.enter(a), t.consume(R), w)
      : p && Pe(R)
      ? Re(t, g, "whitespace")(R)
      : !p && Ke(R)
      ? Ni(t, g)(R)
      : Q(R);
  }
  function b(R) {
    const W = m + "Marker";
    return t.enter(o), t.enter(m), t.enter(W), t.consume(R), t.exit(W), x;
  }
  function x(R) {
    if (R === null || R === 34 || R === 35 || R === 39 || R === 46 || R === 60 || R === 61 || R === 62 || R === 96 || R === 125 || Ke(R))
      return n(R);
    const W = m + "Value";
    return t.enter(W), t.consume(R), k;
  }
  function k(R) {
    if (R === null || R === 34 || R === 39 || R === 60 || R === 61 || R === 62 || R === 96) return n(R);
    if (R === 35 || R === 46 || R === 125 || Ke(R)) {
      const W = m + "Value";
      return t.exit(W), t.exit(m), t.exit(o), g(R);
    }
    return t.consume(R), k;
  }
  function w(R) {
    return R === 45 || R === 46 || R === 58 || R === 95 || rr(R)
      ? (t.consume(R), w)
      : (t.exit(a), p && Pe(R) ? Re(t, y, "whitespace")(R) : !p && Ke(R) ? Ni(t, y)(R) : y(R));
  }
  function y(R) {
    return R === 61 ? (t.enter(c), t.consume(R), t.exit(c), C) : (t.exit(o), g(R));
  }
  function C(R) {
    return R === null || R === 60 || R === 61 || R === 62 || R === 96 || R === 125 || (p && de(R))
      ? n(R)
      : R === 34 || R === 39
      ? (t.enter(u), t.enter(d), t.consume(R), t.exit(d), (O = R), E)
      : p && Pe(R)
      ? Re(t, C, "whitespace")(R)
      : !p && Ke(R)
      ? Ni(t, C)(R)
      : (t.enter(h), t.enter(f), t.consume(R), (O = void 0), P);
  }
  function P(R) {
    return R === null || R === 34 || R === 39 || R === 60 || R === 61 || R === 62 || R === 96
      ? n(R)
      : R === 125 || Ke(R)
      ? (t.exit(f), t.exit(h), t.exit(o), g(R))
      : (t.consume(R), P);
  }
  function E(R) {
    return R === O ? (t.enter(d), t.consume(R), t.exit(d), t.exit(u), t.exit(o), D) : (t.enter(h), N(R));
  }
  function N(R) {
    return R === O ? (t.exit(h), E(R)) : R === null ? n(R) : de(R) ? (p ? n(R) : Ni(t, N)(R)) : (t.enter(f), t.consume(R), L);
  }
  function L(R) {
    return R === O || R === null || de(R) ? (t.exit(f), N(R)) : (t.consume(R), L);
  }
  function D(R) {
    return R === 125 || Ke(R) ? g(R) : Q(R);
  }
  function Q(R) {
    return R === 125 ? (t.enter(i), t.consume(R), t.exit(i), t.exit(r), e) : n(R);
  }
}
function Vw(t, e, n, r, i, o, s) {
  let l = 0,
    a = 0,
    c;
  return u;
  function u(O) {
    return t.enter(r), t.enter(i), t.consume(O), t.exit(i), h;
  }
  function h(O) {
    return O === 93 ? (t.enter(i), t.consume(O), t.exit(i), t.exit(r), e) : (t.enter(o), d(O));
  }
  function d(O) {
    if (O === 93 && !a) return m(O);
    const v = t.enter("chunkText", { contentType: "text", previous: c });
    return c && (c.next = v), (c = v), f(O);
  }
  function f(O) {
    return O === null || l > 999 || (O === 91 && ++a > 32)
      ? n(O)
      : O === 93 && !a--
      ? (t.exit("chunkText"), m(O))
      : de(O)
      ? s
        ? n(O)
        : (t.consume(O), t.exit("chunkText"), d)
      : (t.consume(O), O === 92 ? p : f);
  }
  function p(O) {
    return O === 91 || O === 92 || O === 93 ? (t.consume(O), l++, f) : f(O);
  }
  function m(O) {
    return t.exit(o), t.enter(i), t.consume(O), t.exit(i), t.exit(r), e;
  }
}
function jw(t, e, n, r) {
  const i = this;
  return o;
  function o(l) {
    return tr(l) ? (t.enter(r), t.consume(l), s) : n(l);
  }
  function s(l) {
    return l === 45 || l === 95 || rr(l) ? (t.consume(l), s) : (t.exit(r), i.previous === 45 || i.previous === 95 ? n(l) : e(l));
  }
}
const Fde = { tokenize: jde, concrete: !0 },
  Bde = { tokenize: Zde, partial: !0 },
  Vde = { tokenize: zde, partial: !0 },
  mE = { tokenize: Wde, partial: !0 };
function jde(t, e, n) {
  const r = this,
    i = r.events[r.events.length - 1],
    o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let s = 0,
    l;
  return a;
  function a(y) {
    return t.enter("directiveContainer"), t.enter("directiveContainerFence"), t.enter("directiveContainerSequence"), c(y);
  }
  function c(y) {
    return y === 58
      ? (t.consume(y), s++, c)
      : s < 3
      ? n(y)
      : (t.exit("directiveContainerSequence"), jw.call(r, t, u, n, "directiveContainerName")(y));
  }
  function u(y) {
    return y === 91 ? t.attempt(Bde, h, h)(y) : h(y);
  }
  function h(y) {
    return y === 123 ? t.attempt(Vde, d, d)(y) : d(y);
  }
  function d(y) {
    return Re(t, f, "whitespace")(y);
  }
  function f(y) {
    return t.exit("directiveContainerFence"), y === null ? p(y) : de(y) ? (r.interrupt ? e(y) : t.attempt(mE, m, p)(y)) : n(y);
  }
  function p(y) {
    return t.exit("directiveContainer"), e(y);
  }
  function m(y) {
    return y === null ? (t.exit("directiveContainer"), e(y)) : (t.enter("directiveContainerContent"), O(y));
  }
  function O(y) {
    return y === null ? k(y) : t.attempt({ tokenize: w, partial: !0 }, k, o ? Re(t, v, "linePrefix", o + 1) : v)(y);
  }
  function v(y) {
    if (y === null) return k(y);
    const C = t.enter("chunkDocument", { contentType: "document", previous: l });
    return l && (l.next = C), (l = C), g(y);
  }
  function g(y) {
    if (y === null) {
      const C = t.exit("chunkDocument");
      return (r.parser.lazy[C.start.line] = !1), k(y);
    }
    return de(y) ? t.check(mE, b, x)(y) : (t.consume(y), g);
  }
  function b(y) {
    t.consume(y);
    const C = t.exit("chunkDocument");
    return (r.parser.lazy[C.start.line] = !1), O;
  }
  function x(y) {
    const C = t.exit("chunkDocument");
    return (r.parser.lazy[C.start.line] = !1), k(y);
  }
  function k(y) {
    return t.exit("directiveContainerContent"), t.exit("directiveContainer"), e(y);
  }
  function w(y, C, P) {
    let E = 0;
    return Re(y, N, "linePrefix", 4);
    function N(Q) {
      return y.enter("directiveContainerFence"), y.enter("directiveContainerSequence"), L(Q);
    }
    function L(Q) {
      return Q === 58 ? (y.consume(Q), E++, L) : E < s ? P(Q) : (y.exit("directiveContainerSequence"), Re(y, D, "whitespace")(Q));
    }
    function D(Q) {
      return Q === null || de(Q) ? (y.exit("directiveContainerFence"), C(Q)) : P(Q);
    }
  }
}
function Zde(t, e, n) {
  return Vw(t, e, n, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", !0);
}
function zde(t, e, n) {
  return Bw(
    t,
    e,
    n,
    "directiveContainerAttributes",
    "directiveContainerAttributesMarker",
    "directiveContainerAttribute",
    "directiveContainerAttributeId",
    "directiveContainerAttributeClass",
    "directiveContainerAttributeName",
    "directiveContainerAttributeInitializerMarker",
    "directiveContainerAttributeValueLiteral",
    "directiveContainerAttributeValue",
    "directiveContainerAttributeValueMarker",
    "directiveContainerAttributeValueData",
    !0
  );
}
function Wde(t, e, n) {
  const r = this;
  return i;
  function i(s) {
    return t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), o;
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : e(s);
  }
}
const Xde = { tokenize: qde },
  Ude = { tokenize: Yde, partial: !0 },
  Hde = { tokenize: Gde, partial: !0 };
function qde(t, e, n) {
  const r = this;
  return i;
  function i(u) {
    return t.enter("directiveLeaf"), t.enter("directiveLeafSequence"), t.consume(u), o;
  }
  function o(u) {
    return u === 58 ? (t.consume(u), t.exit("directiveLeafSequence"), jw.call(r, t, s, n, "directiveLeafName")) : n(u);
  }
  function s(u) {
    return u === 91 ? t.attempt(Ude, l, l)(u) : l(u);
  }
  function l(u) {
    return u === 123 ? t.attempt(Hde, a, a)(u) : a(u);
  }
  function a(u) {
    return Re(t, c, "whitespace")(u);
  }
  function c(u) {
    return u === null || de(u) ? (t.exit("directiveLeaf"), e(u)) : n(u);
  }
}
function Yde(t, e, n) {
  return Vw(t, e, n, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", !0);
}
function Gde(t, e, n) {
  return Bw(
    t,
    e,
    n,
    "directiveLeafAttributes",
    "directiveLeafAttributesMarker",
    "directiveLeafAttribute",
    "directiveLeafAttributeId",
    "directiveLeafAttributeClass",
    "directiveLeafAttributeName",
    "directiveLeafAttributeInitializerMarker",
    "directiveLeafAttributeValueLiteral",
    "directiveLeafAttributeValue",
    "directiveLeafAttributeValueMarker",
    "directiveLeafAttributeValueData",
    !0
  );
}
const Jde = { tokenize: nfe, previous: tfe },
  Kde = { tokenize: rfe, partial: !0 },
  efe = { tokenize: ife, partial: !0 };
function tfe(t) {
  return t !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function nfe(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return (
      t.enter("directiveText"),
      t.enter("directiveTextMarker"),
      t.consume(a),
      t.exit("directiveTextMarker"),
      jw.call(r, t, o, n, "directiveTextName")
    );
  }
  function o(a) {
    return a === 58 ? n(a) : a === 91 ? t.attempt(Kde, s, s)(a) : s(a);
  }
  function s(a) {
    return a === 123 ? t.attempt(efe, l, l)(a) : l(a);
  }
  function l(a) {
    return t.exit("directiveText"), e(a);
  }
}
function rfe(t, e, n) {
  return Vw(t, e, n, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function ife(t, e, n) {
  return Bw(
    t,
    e,
    n,
    "directiveTextAttributes",
    "directiveTextAttributesMarker",
    "directiveTextAttribute",
    "directiveTextAttributeId",
    "directiveTextAttributeClass",
    "directiveTextAttributeName",
    "directiveTextAttributeInitializerMarker",
    "directiveTextAttributeValueLiteral",
    "directiveTextAttributeValue",
    "directiveTextAttributeValueMarker",
    "directiveTextAttributeValueData"
  );
}
function ofe() {
  return { text: { 58: Jde }, flow: { 58: [Fde, Xde] } };
}
var sfe = Object.defineProperty,
  lfe = (t, e, n) => (e in t ? sfe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
  i0 = (t, e, n) => (lfe(t, typeof e != "symbol" ? e + "" : e, n), n);
class Xa extends wi {
  constructor(e, n) {
    super(n),
      i0(this, "__mdastNode"),
      i0(this, "__focusEmitter", Hm()),
      i0(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__mdastNode = e);
  }
  static getType() {
    return "directive";
  }
  static clone(e) {
    return new Xa(structuredClone(e.__mdastNode), e.__key);
  }
  static importJSON(e) {
    return Og(e.mdastNode);
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  exportJSON() {
    return { mdastNode: structuredClone(this.__mdastNode), type: "directive", version: 1 };
  }
  createDOM() {
    return document.createElement(this.__mdastNode.type === "textDirective" ? "span" : "div");
  }
  updateDOM() {
    return !1;
  }
  setMdastNode(e) {
    this.getWritable().__mdastNode = e;
  }
  decorate(e, n) {
    return S.createElement(afe, {
      lexicalNode: this,
      mdastNode: this.getMdastNode(),
      parentEditor: e,
      config: n,
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return this.__mdastNode.type === "textDirective";
  }
  isKeyboardSelectable() {
    return !0;
  }
}
const afe = (t) => {
  const { mdastNode: e } = t,
    [n] = Ye(Es),
    r = n.find((o) => o.testNode(e));
  if (!r) throw new Error(`No descriptor found for directive ${e.name}`);
  const i = r.Editor;
  return S.createElement(
    Wm.Provider,
    { value: t },
    S.createElement(i, { descriptor: r, mdastNode: e, lexicalNode: t.lexicalNode, parentEditor: t.parentEditor })
  );
};
function Og(t, e) {
  return new Xa(t, e);
}
function B8(t) {
  return t instanceof Xa;
}
const cfe = {
    testLexicalNode: B8,
    visitLexicalNode({ actions: t, mdastParent: e, lexicalNode: n }) {
      t.appendToParent(e, n.getMdastNode());
    },
  },
  ufe = ["leafDirective", "containerDirective", "textDirective"];
function hfe(t) {
  return ufe.includes(t.type);
}
const dfe = {
    testNode: (t, { directiveDescriptors: e }) => (hfe(t) ? e.find((r) => r.testNode(t)) !== void 0 : !1),
    visitNode({ lexicalParent: t, mdastNode: e }) {
      t.append(Og(e));
    },
  },
  Zw = kt((t) => {
    t.link(
      t.pipe(
        Zw,
        mr((e) => () => Og({ children: [], ...e }))
      ),
      _a
    );
  }),
  ffe = Ut({
    update: (t, e) => {
      t.pub(Es, (e == null ? void 0 : e.directiveDescriptors) ?? []);
    },
    init: (t, e) => {
      t.pubIn({
        [Es]: (e == null ? void 0 : e.directiveDescriptors) ?? [],
        [Lo]: Pde(),
        [Mo]: ofe(),
        [Wn]: dfe,
        [ar]: Xa,
        [cr]: cfe,
        [Hs]: Ade(),
      });
    },
  }),
  vg = ["note", "tip", "danger", "info", "caution"],
  pfe = {
    name: "admonition",
    attributes: [],
    hasChildren: !0,
    testNode(t) {
      return vg.includes(t.name);
    },
    Editor({ mdastNode: t }) {
      const {
        config: { theme: e },
      } = Sh();
      return S.createElement(
        "div",
        { className: e.admonition[t.name] },
        S.createElement(Um, { block: !0, getContent: (n) => n.children, getUpdatedMdastNode: (n, r) => ({ ...n, children: r }) })
      );
    },
  },
  mfe = ({ mdastNode: t, descriptor: e }) => {
    const n = Xm(),
      r = S.useMemo(
        () =>
          e.attributes.reduce((o, s) => {
            var l;
            return (o[s] = ((l = t.attributes) == null ? void 0 : l[s]) ?? ""), o;
          }, {}),
        [t, e]
      ),
      i = S.useCallback(
        (o) => {
          n({ attributes: Object.fromEntries(Object.entries(o).filter(([, s]) => s !== "")) });
        },
        [n]
      );
    return S.createElement(
      "div",
      { className: t.type === "textDirective" ? F.inlineEditor : F.blockEditor },
      e.attributes.length == 0 && e.hasChildren && t.type !== "textDirective"
        ? S.createElement("span", { className: F.genericComponentName }, t.name)
        : null,
      e.attributes.length > 0 ? S.createElement(wy, { properties: r, title: t.name || "", onChange: i }) : null,
      e.hasChildren
        ? S.createElement(Um, {
            block: t.type === "containerDirective",
            getContent: (o) => o.children,
            getUpdatedMdastNode: (o, s) => ({ ...o, children: s }),
          })
        : S.createElement("span", { className: F.genericComponentName }, t.name)
    );
  };
function gfe(t, e) {
  let n = null;
  return (
    t.getEditorState().read(() => {
      n = e();
    }),
    n
  );
}
function V8(t) {
  try {
    const e = t.anchor,
      n = t.focus,
      r = t.anchor.getNode(),
      i = t.focus.getNode();
    return r === i ? r : t.isBackward() ? (GS(n) ? r : i) : GS(e) ? r : i;
  } catch {
    return null;
  }
}
function zw(t) {
  const e = ae(),
    n = window.getSelection(),
    r = document.activeElement,
    i = t.getRootElement();
  if (e !== null && n !== null && i !== null && i.contains(n.anchorNode) && t.isEditable()) {
    const o = n.getRangeAt(0);
    let s;
    if (n.isCollapsed) {
      let l = n.anchorNode;
      (l == null ? void 0 : l.nodeType) == 3 && (l = l.parentNode), (s = l.getBoundingClientRect()), (s.width = 0);
    } else if (n.anchorNode === i) {
      let l = i;
      for (; l.firstElementChild != null; ) l = l.firstElementChild;
      s = l.getBoundingClientRect();
    } else s = o.getBoundingClientRect();
    return { top: Math.round(s.top), left: Math.round(s.left), width: Math.round(s.width), height: Math.round(s.height) };
  } else if (!r || r.className !== "link-input") return null;
  return null;
}
function Ofe(t, e) {
  return tb({ markdown: "" }, (n) => {
    t.getEditorState().read(() => {
      n.markdown = Wb({ root: Qe(), ...e });
    });
  }).markdown;
}
function vfe({ url: t, title: e, onSubmit: n, onCancel: r, linkAutocompleteSuggestions: i }) {
  const { register: o, handleSubmit: s, control: l, setValue: a, reset: c } = jp({ values: { url: t, title: e } }),
    u = nt();
  return S.createElement(
    "form",
    {
      onSubmit: (h) => {
        s(n)(h), h.stopPropagation(), h.preventDefault();
      },
      onReset: (h) => {
        h.stopPropagation(), r();
      },
      className: Fe(F.multiFieldForm, F.linkDialogEditForm),
    },
    S.createElement(
      "div",
      { className: F.formField },
      S.createElement("label", { htmlFor: "link-url" }, u("createLink.url", "URL")),
      S.createElement(w3, {
        register: o,
        initialInputValue: t,
        inputName: "url",
        suggestions: i,
        setValue: a,
        control: l,
        placeholder: u("createLink.urlPlaceholder", "Select or paste an URL"),
        autofocus: !0,
      })
    ),
    S.createElement(
      "div",
      { className: F.formField },
      S.createElement("label", { htmlFor: "link-title" }, u("createLink.title", "Title")),
      S.createElement("input", { id: "link-title", className: F.textInput, size: 40, ...o("title") })
    ),
    S.createElement(
      "div",
      { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
      S.createElement(
        "button",
        {
          type: "submit",
          title: u("createLink.saveTooltip", "Set URL"),
          "aria-label": u("createLink.saveTooltip", "Set URL"),
          className: Fe(F.primaryButton),
        },
        u("dialogControls.save", "Save")
      ),
      S.createElement(
        "button",
        {
          type: "reset",
          title: u("createLink.cancelTooltip", "Cancel change"),
          "aria-label": u("createLink.cancelTooltip", "Cancel change"),
          className: Fe(F.secondaryButton),
        },
        u("dialogControls.cancel", "Cancel")
      )
    )
  );
}
const bfe = () => {
    const [t, e, n, r, i, o] = Ye(jr, St, st, kn, Yw, Gw),
      s = He(Ww),
      l = He(Xw),
      a = He(Uw),
      c = He(Hw),
      u = He(qw);
    S.useEffect(() => {
      const O = () => {
        e == null ||
          e.getEditorState().read(() => {
            s(!0);
          });
      };
      return (
        window.addEventListener("resize", O),
        window.addEventListener("scroll", O),
        () => {
          window.removeEventListener("resize", O), window.removeEventListener("scroll", O);
        }
      );
    }, [e, s]);
    const [h, d] = S.useState(!1),
      f = nt(),
      p = r.rectangle,
      m = r.type === "preview" && r.url.startsWith("http");
    return S.createElement(
      $m,
      { open: r.type !== "inactive" },
      S.createElement(lU, {
        "data-visible": r.type === "edit",
        className: F.linkDialogAnchor,
        style: {
          top: `${(p == null ? void 0 : p.top) ?? 0}px`,
          left: `${(p == null ? void 0 : p.left) ?? 0}px`,
          width: `${(p == null ? void 0 : p.width) ?? 0}px`,
          height: `${(p == null ? void 0 : p.height) ?? 0}px`,
        },
      }),
      S.createElement(
        Rm,
        { container: t == null ? void 0 : t.current },
        S.createElement(
          b$,
          {
            className: Fe(F.linkDialogPopoverContent),
            sideOffset: 5,
            onOpenAutoFocus: (O) => {
              O.preventDefault();
            },
            key: r.linkNodeKey,
          },
          r.type === "edit" &&
            S.createElement(vfe, { url: r.url, title: r.title, onSubmit: l, onCancel: a.bind(null), linkAutocompleteSuggestions: i }),
          r.type === "preview" &&
            S.createElement(
              S.Fragment,
              null,
              S.createElement(
                "a",
                {
                  className: F.linkDialogPreviewAnchor,
                  href: r.url,
                  ...(m ? { target: "_blank", rel: "noreferrer" } : {}),
                  onClick: (O) => {
                    o !== null && (O.preventDefault(), o(r.url));
                  },
                  title: m ? f("linkPreview.open", "Open {{url}} in new window", { url: r.url }) : r.url,
                },
                S.createElement("span", null, r.url),
                m && n("open_in_new")
              ),
              S.createElement(
                o0,
                {
                  onClick: () => {
                    c();
                  },
                  title: f("linkPreview.edit", "Edit link URL"),
                  "aria-label": f("linkPreview.edit", "Edit link URL"),
                },
                n("edit")
              ),
              S.createElement(
                $8,
                null,
                S.createElement(
                  R8,
                  { open: h },
                  S.createElement(
                    I8,
                    { asChild: !0 },
                    S.createElement(
                      o0,
                      {
                        title: f("linkPreview.copyToClipboard", "Copy to clipboard"),
                        "aria-label": f("linkPreview.copyToClipboard", "Copy to clipboard"),
                        onClick: () => {
                          window.navigator.clipboard.writeText(r.url).then(() => {
                            d(!0),
                              setTimeout(() => {
                                d(!1);
                              }, 1e3);
                          });
                        },
                      },
                      n(h ? "check" : "content_copy")
                    )
                  ),
                  S.createElement(
                    M8,
                    { container: t == null ? void 0 : t.current },
                    S.createElement(
                      L8,
                      { className: Fe(F.tooltipContent), sideOffset: 5 },
                      f("linkPreview.copied", "Copied!"),
                      S.createElement(kde, null)
                    )
                  )
                )
              ),
              S.createElement(
                o0,
                {
                  title: f("linkPreview.remove", "Remove link"),
                  "aria-label": f("linkPreview.remove", "Remove link"),
                  onClick: () => {
                    u();
                  },
                },
                n("link_off")
              )
            ),
          S.createElement(Im, { className: F.popoverArrow })
        )
      )
    );
  },
  o0 = S.forwardRef(({ className: t, ...e }, n) => S.createElement("button", { className: Fe(F.actionButton, t), ref: n, ...e }));
function Iv(t) {
  if (!t) return null;
  const e = V8(t);
  if (e === null) return null;
  const n = e.getParent();
  return ni(n) ? n : ni(e) ? e : null;
}
const Ww = kt(),
  kn = we({ type: "inactive" }, (t) => {
    t.pub(iu, (e) => e.registerCommand(Uu, () => (t.getValue(kn).type === "preview" ? (t.pub(kn, { type: "inactive" }), !0) : !1), ht)),
      t.pub(iu, (e) =>
        e.registerCommand(
          dT,
          (n) => {
            if (n.key === "k" && (ru ? n.metaKey : n.ctrlKey) && !t.getValue(Gt)) {
              const r = ae();
              return ee(r) ? (t.pub(bg), n.stopPropagation(), n.preventDefault(), !0) : !1;
            }
            return !1;
          },
          $f
        )
      ),
      t.link(
        t.pipe(
          Hw,
          pt(kn),
          mr(([, e]) => {
            if (e.type === "preview")
              return { type: "edit", initialUrl: e.url, url: e.url, title: e.title, linkNodeKey: e.linkNodeKey, rectangle: e.rectangle };
            throw new Error("Cannot switch to edit mode when not in preview mode");
          })
        ),
        kn
      ),
      t.sub(t.pipe(Xw, pt(St, kn, _s)), ([e, n, r, i]) => {
        var o, s;
        const l = ((o = e.url) == null ? void 0 : o.trim()) ?? "",
          a = ((s = e.title) == null ? void 0 : s.trim()) ?? "";
        if (l !== "") {
          if (i != null && i.isCollapsed()) {
            const c = a || l;
            n == null ||
              n.update(
                () => {
                  const u = Iv(i);
                  if (u) u.setURL(l), u.setTitle(a);
                  else {
                    const h = $s(l, { title: a });
                    h.append(yt(c)), ya([h]), h.select();
                  }
                },
                { discrete: !0 }
              );
          } else n == null || n.dispatchCommand(Kl, { url: l, title: a });
          t.pub(kn, { type: "preview", linkNodeKey: r.linkNodeKey, rectangle: r.rectangle, title: a, url: l });
        } else r.type === "edit" && r.initialUrl !== "" && (n == null || n.dispatchCommand(Kl, null)), t.pub(kn, { type: "inactive" });
      }),
      t.link(
        t.pipe(
          Uw,
          pt(kn, St),
          mr(([, e, n]) => {
            if (e.type === "edit")
              return (
                n == null || n.focus(),
                e.initialUrl === ""
                  ? { type: "inactive" }
                  : { type: "preview", url: e.initialUrl, linkNodeKey: e.linkNodeKey, rectangle: e.rectangle }
              );
            throw new Error("Cannot cancel edit when not in edit mode");
          })
        ),
        kn
      ),
      t.link(
        t.pipe(
          t.combine(_s, Ww),
          pt(St, kn, Gt),
          mr(([[e], n, r, i]) => {
            if (ee(e) && n && !i) {
              const o = Iv(e);
              return o
                ? { type: "preview", url: o.getURL(), linkNodeKey: o.getKey(), title: o.getTitle(), rectangle: zw(n) }
                : { type: "inactive" };
            } else return { type: "inactive" };
          })
        ),
        kn
      );
  }),
  Xw = kt(),
  Uw = Fr(),
  xfe = Fr(),
  Hw = Fr(),
  qw = Fr((t) => {
    t.sub(t.pipe(qw, pt(St)), ([, e]) => {
      e == null || e.dispatchCommand(Kl, null);
    });
  }),
  bg = Fr((t) => {
    t.sub(
      t.pipe(
        bg,
        pt(_s, St),
        va(([, e]) => ee(e))
      ),
      ([, e, n]) => {
        n == null ||
          n.focus(() => {
            n.getEditorState().read(() => {
              const r = Iv(e),
                i = zw(n);
              r
                ? t.pub(kn, {
                    type: "edit",
                    initialUrl: r.getURL(),
                    initialTitle: r.getTitle() ?? "",
                    url: r.getURL(),
                    title: r.getTitle() ?? "",
                    linkNodeKey: r.getKey(),
                    rectangle: i,
                  })
                : t.pub(kn, { type: "edit", initialUrl: "", initialTitle: "", title: "", url: "", linkNodeKey: "", rectangle: i });
            });
          });
      }
    );
  }),
  Yw = we([]),
  Gw = we(null),
  yfe = Ut({
    init(t, e) {
      t.pub(qo, (e == null ? void 0 : e.LinkDialog) ?? bfe), t.pub(Gw, (e == null ? void 0 : e.onClickLinkCallback) ?? null);
    },
    update(t, e = {}) {
      t.pub(Yw, e.linkAutocompleteSuggestions ?? []);
    },
  });
function Jw(t, e) {
  return S.forwardRef((n, r) => {
    const i = Fe(e.className, n.className);
    return S.createElement(t, { ...e, ...n, className: i, ref: r });
  });
}
function wfe(t) {
  return ({ title: e, children: n, ...r }) => S.createElement(t, { ...r }, S.createElement(is, { title: e }, n));
}
const j8 = ({ readOnly: t, children: e }) =>
    S.createElement(
      Fx,
      { className: Fe("mdxeditor-toolbar", F.toolbarRoot, { [F.readOnlyToolbarRoot]: t }), ...(t ? { tabIndex: -1 } : {}) },
      e
    ),
  Z8 = Jw(Fi, { className: F.toolbarButton, "data-toolbar-item": !0 }),
  os = wfe(Z8),
  Kw = Jw(Yd, { className: F.toolbarToggleItem, "data-toolbar-item": !0 }),
  Sfe = Jw(Qm, { type: "single", className: F.toolbarToggleSingleGroup }),
  eS = S.forwardRef(({ on: t, title: e, children: n, disabled: r, ...i }, o) =>
    S.createElement(
      Qm,
      { type: "single", className: F.toolbarToggleSingleGroup, ...i, value: t ? "on" : "off", ref: o },
      S.createElement(Kw, { title: e, value: "on", disabled: r }, S.createElement(is, { title: e }, n))
    )
  ),
  tS = ({ items: t }) =>
    S.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      t.map((e, n) =>
        S.createElement(
          eS,
          {
            key: n,
            title: e.title,
            on: e.active,
            onValueChange: (r) => {
              e.onChange(r === "on");
            },
            disabled: e.disabled,
          },
          e.contents
        )
      )
    ),
  nS = ({ value: t, onChange: e, className: n, items: r }) => {
    const i = nt();
    return S.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      S.createElement(
        Qm,
        {
          "aria-label": i("toolbar.toggleGroup", "toggle group"),
          type: "single",
          className: Fe(F.toolbarToggleSingleGroup, n),
          onValueChange: e,
          value: t || "",
          onFocus: (o) => {
            o.preventDefault();
          },
        },
        r.map((o, s) =>
          S.createElement(Kw, { key: s, "aria-label": o.title, value: o.value }, S.createElement(is, { title: o.title }, o.contents))
        )
      )
    );
  },
  rS = (t) => {
    const e = mt(Gt);
    return S.createElement(
      S.Fragment,
      null,
      t.items.length === 1
        ? S.createElement(
            os,
            {
              title: t.title,
              onClick: () => {
                t.onChoose("");
              },
              disabled: e,
            },
            t.children
          )
        : S.createElement(
            b8,
            { value: "", onValueChange: t.onChoose },
            S.createElement(Q8, { title: t.title }, t.children),
            S.createElement(
              Dw,
              { className: F.toolbarButtonDropdownContainer },
              t.items.map((n, r) => S.createElement(Qw, { key: r, value: n.value }, n.label))
            )
          )
    );
  };
function gE(t) {
  return Object.hasOwn(t, "when");
}
const pf = ({ options: t }) => {
    const e = mt(Ho),
      n = S.useMemo(() => {
        const r = t.find((i) => {
          if (gE(i)) {
            if (i.when(e)) return !0;
          } else return !0;
        });
        return r ? (gE(r) ? r.contents() : r.fallback()) : null;
      }, [t, e]);
    return S.createElement("div", { style: { display: "flex" } }, n);
  },
  ei = z$,
  mf = we(() => null),
  OE = () =>
    "This is an empty toolbar. Pass `{toolbarContents: () => { return <>toolbar components</> }}` to the toolbarPlugin to customize it.",
  kfe = Ut({
    init(t, e) {
      t.pubIn({
        [mf]: (e == null ? void 0 : e.toolbarContents) ?? OE,
        [fA]: () => {
          const [n, r] = Ye(mf, Gt);
          return S.createElement(j8, { readOnly: r }, n());
        },
      });
    },
    update(t, e) {
      t.pub(mf, (e == null ? void 0 : e.toolbarContents) ?? OE);
    },
  });
class Nt {
  constructor(e, n, r, i) {
    (this.fromA = e), (this.toA = n), (this.fromB = r), (this.toB = i);
  }
  offset(e, n) {
    return new Nt(this.fromA + e, this.toA + e, this.fromB + n, this.toB + n);
  }
}
function zs(t, e, n, r, i, o) {
  if (t == r) return [];
  let s = iS(t, e, n, r, i, o),
    l = oS(t, e + s, n, r, i + s, o);
  (e += s), (n -= l), (i += s), (o -= l);
  let a = n - e,
    c = o - i;
  if (!a || !c) return [new Nt(e, n, i, o)];
  if (a > c) {
    let h = t.slice(e, n).indexOf(r.slice(i, o));
    if (h > -1) return [new Nt(e, e + h, i, i), new Nt(e + h + c, n, o, o)];
  } else if (c > a) {
    let h = r.slice(i, o).indexOf(t.slice(e, n));
    if (h > -1) return [new Nt(e, e, i, i + h), new Nt(n, n, i + h + a, o)];
  }
  if (a == 1 || c == 1) return [new Nt(e, n, i, o)];
  let u = X8(t, e, n, r, i, o);
  if (u) {
    let [h, d, f] = u;
    return zs(t, e, h, r, i, d).concat(zs(t, h + f, n, r, d + f, o));
  }
  return Cfe(t, e, n, r, i, o);
}
let Ac = 1e9;
function Cfe(t, e, n, r, i, o) {
  let s = n - e,
    l = o - i;
  if (Ac < 1e9 && Math.min(s, l) > Ac * 16) return Math.min(s, l) > Ac * 64 ? [new Nt(e, n, i, o)] : vE(t, e, n, r, i, o);
  let a = Math.ceil((s + l) / 2);
  s0.reset(a), l0.reset(a);
  let c = (f, p) => t.charCodeAt(e + f) == r.charCodeAt(i + p),
    u = (f, p) => t.charCodeAt(n - f - 1) == r.charCodeAt(o - p - 1),
    h = (s - l) % 2 != 0 ? l0 : null,
    d = h ? null : s0;
  for (let f = 0; f < a; f++) {
    if (f > Ac) return vE(t, e, n, r, i, o);
    let p = s0.advance(f, s, l, a, h, !1, c) || l0.advance(f, s, l, a, d, !0, u);
    if (p) return _fe(t, e, n, e + p[0], r, i, o, i + p[1]);
  }
  return [new Nt(e, n, i, o)];
}
class z8 {
  constructor() {
    this.vec = [];
  }
  reset(e) {
    this.len = e << 1;
    for (let n = 0; n < this.len; n++) this.vec[n] = -1;
    (this.vec[e + 1] = 0), (this.start = this.end = 0);
  }
  advance(e, n, r, i, o, s, l) {
    for (let a = -e + this.start; a <= e - this.end; a += 2) {
      let c = i + a,
        u = a == -e || (a != e && this.vec[c - 1] < this.vec[c + 1]) ? this.vec[c + 1] : this.vec[c - 1] + 1,
        h = u - a;
      for (; u < n && h < r && l(u, h); ) u++, h++;
      if (((this.vec[c] = u), u > n)) this.end += 2;
      else if (h > r) this.start += 2;
      else if (o) {
        let d = i + (n - r) - a;
        if (d >= 0 && d < this.len && o.vec[d] != -1)
          if (s) {
            let f = o.vec[d];
            if (f >= n - u) return [f, i + f - d];
          } else {
            let f = n - o.vec[d];
            if (u >= f) return [u, h];
          }
      }
    }
    return null;
  }
}
const s0 = new z8(),
  l0 = new z8();
function _fe(t, e, n, r, i, o, s, l) {
  let a = !1;
  return (
    !pa(t, r) && ++r == n && (a = !0),
    !pa(i, l) && ++l == s && (a = !0),
    a ? [new Nt(e, n, o, s)] : zs(t, e, r, i, o, l).concat(zs(t, r, n, i, l, s))
  );
}
function W8(t, e) {
  let n = 1,
    r = Math.min(t, e);
  for (; n < r; ) n = n << 1;
  return n;
}
function iS(t, e, n, r, i, o) {
  if (e == n || e == o || t.charCodeAt(e) != r.charCodeAt(i)) return 0;
  let s = W8(n - e, o - i);
  for (let l = e, a = i; ; ) {
    let c = l + s,
      u = a + s;
    if (c > n || u > o || t.slice(l, c) != r.slice(a, u)) {
      if (s == 1) return l - e - (pa(t, l) ? 0 : 1);
      s = s >> 1;
    } else {
      if (c == n || u == o) return c - e;
      (l = c), (a = u);
    }
  }
}
function oS(t, e, n, r, i, o) {
  if (e == n || i == o || t.charCodeAt(n - 1) != r.charCodeAt(o - 1)) return 0;
  let s = W8(n - e, o - i);
  for (let l = n, a = o; ; ) {
    let c = l - s,
      u = a - s;
    if (c < e || u < i || t.slice(c, l) != r.slice(u, a)) {
      if (s == 1) return n - l - (pa(t, l) ? 0 : 1);
      s = s >> 1;
    } else {
      if (c == e || u == i) return n - c;
      (l = c), (a = u);
    }
  }
}
function Mv(t, e, n, r, i, o, s, l) {
  let a = r.slice(i, o),
    c = null;
  for (;;) {
    if (c || s < l) return c;
    for (let u = e + s; ; ) {
      pa(t, u) || u++;
      let h = u + s;
      if ((pa(t, h) || (h += h == u + 1 ? 1 : -1), h >= n)) break;
      let d = t.slice(u, h),
        f = -1;
      for (; (f = a.indexOf(d, f + 1)) != -1; ) {
        let p = iS(t, h, n, r, i + f + d.length, o),
          m = oS(t, e, u, r, i, i + f),
          O = d.length + p + m;
        (!c || c[2] < O) && (c = [u - m, i + f - m, O]);
      }
      u = h;
    }
    if (l < 0) return c;
    s = s >> 1;
  }
}
function X8(t, e, n, r, i, o) {
  let s = n - e,
    l = o - i;
  if (s < l) {
    let a = X8(r, i, o, t, e, n);
    return a && [a[1], a[0], a[2]];
  }
  return s < 4 || l * 2 < s ? null : Mv(t, e, n, r, i, o, Math.floor(s / 4), -1);
}
function vE(t, e, n, r, i, o) {
  let s = n - e,
    l = o - i,
    a;
  if (s < l) {
    let d = Mv(r, i, o, t, e, n, Math.floor(s / 6), 50);
    a = d && [d[1], d[0], d[2]];
  } else a = Mv(t, e, n, r, i, o, Math.floor(l / 6), 50);
  if (!a) return [new Nt(e, n, i, o)];
  let [c, u, h] = a;
  return zs(t, e, c, r, i, u).concat(zs(t, c + h, n, r, u + h, o));
}
function U8(t, e) {
  for (let n = 1; n < t.length; n++) {
    let r = t[n - 1],
      i = t[n];
    r.toA > i.fromA - e && r.toB > i.fromB - e && ((t[n - 1] = new Nt(r.fromA, i.toA, r.fromB, i.toB)), t.splice(n--, 1));
  }
}
function Efe(t, e, n) {
  for (;;) {
    U8(n, 1);
    let r = !1;
    for (let i = 0; i < n.length; i++) {
      let o = n[i],
        s,
        l;
      (s = iS(t, o.fromA, o.toA, e, o.fromB, o.toB)) && (o = n[i] = new Nt(o.fromA + s, o.toA, o.fromB + s, o.toB)),
        (l = oS(t, o.fromA, o.toA, e, o.fromB, o.toB)) && (o = n[i] = new Nt(o.fromA, o.toA - l, o.fromB, o.toB - l));
      let a = o.toA - o.fromA,
        c = o.toB - o.fromB;
      if (a && c) continue;
      let u = o.fromA - (i ? n[i - 1].toA : 0),
        h = (i < n.length - 1 ? n[i + 1].fromA : t.length) - o.toA;
      if (!u || !h) continue;
      let d = a ? t.slice(o.fromA, o.toA) : e.slice(o.fromB, o.toB);
      u <= d.length && t.slice(o.fromA - u, o.fromA) == d.slice(d.length - u)
        ? ((n[i] = new Nt(o.fromA - u, o.toA - u, o.fromB - u, o.toB - u)), (r = !0))
        : h <= d.length &&
          t.slice(o.toA, o.toA + h) == d.slice(0, h) &&
          ((n[i] = new Nt(o.fromA + h, o.toA + h, o.fromB + h, o.toB + h)), (r = !0));
    }
    if (!r) break;
  }
  return n;
}
function Tfe(t, e, n) {
  for (let r = 0, i = 0; i < t.length; i++) {
    let o = t[i],
      s = o.toA - o.fromA,
      l = o.toB - o.fromB;
    if ((s && l) || s > 3 || l > 3) {
      let a = i == t.length - 1 ? e.length : t[i + 1].fromA,
        c = o.fromA - r,
        u = a - o.toA,
        h = xE(e, o.fromA, Math.min(c, 5)),
        d = bE(e, o.toA, Math.min(u, 5)),
        f = o.fromA - h,
        p = d - o.toA;
      if (!s || !l) {
        let m = Math.max(s, l),
          [O, v, g] = s ? [e, o.fromA, o.toA] : [n, o.fromB, o.toB],
          b,
          x;
        f && p
          ? (m > f && e.slice(h, o.fromA) == O.slice(g - f, g)
              ? ((o = t[i] = new Nt(h, h + s, o.fromB - f, o.toB - f)), (h = o.fromA), (d = bE(e, o.toA, Math.min(a - o.toA, 5))))
              : m > p &&
                e.slice(o.toA, d) == O.slice(v, v + p) &&
                ((o = t[i] = new Nt(d - s, d, o.fromB + p, o.toB + p)), (d = o.toA), (h = xE(e, o.fromA, Math.min(o.fromA - r, 5)))),
            (f = o.fromA - h),
            (p = d - o.toA))
          : !f &&
            !p &&
            (x = o.fromA - (b = Pfe(e, o.fromA, c))) &&
            e.slice(b, o.fromA) == O.slice(g - x, g) &&
            (o = t[i] = new Nt(b, b + s, o.fromB - x, o.toB - x));
      }
      (f || p) && (o = t[i] = new Nt(o.fromA - f, o.toA + p, o.fromB - f, o.toB + p)), (r = o.toA);
    }
  }
  return U8(t, 3), t;
}
let ws;
try {
  ws = new RegExp("[\\p{Alphabetic}\\p{Number}]", "u");
} catch {}
function H8(t) {
  return (t > 48 && t < 58) || (t > 64 && t < 91) || (t > 96 && t < 123);
}
function q8(t, e) {
  if (e == t.length) return 0;
  let n = t.charCodeAt(e);
  return n < 192
    ? H8(n)
      ? 1
      : 0
    : ws
    ? !G8(n) || e == t.length - 1
      ? ws.test(String.fromCharCode(n))
        ? 1
        : 0
      : ws.test(t.slice(e, e + 2))
      ? 2
      : 0
    : 0;
}
function Y8(t, e) {
  if (!e) return 0;
  let n = t.charCodeAt(e - 1);
  return n < 192
    ? H8(n)
      ? 1
      : 0
    : ws
    ? !J8(n) || e == 1
      ? ws.test(String.fromCharCode(n))
        ? 1
        : 0
      : ws.test(t.slice(e - 2, e))
      ? 2
      : 0
    : 0;
}
function bE(t, e, n) {
  if (e == t.length || !Y8(t, e)) return e;
  for (let r = e, i = e + n; ; ) {
    let o = q8(t, r);
    if (!o) return r;
    if (((r += o), r > i)) return e;
  }
}
function xE(t, e, n) {
  if (!e || !q8(t, e)) return e;
  for (let r = e, i = e - n; ; ) {
    let o = Y8(t, r);
    if (!o) return r;
    if (((r -= o), r < i)) return e;
  }
}
function Pfe(t, e, n) {
  for (let r = e, i = e - n; ; ) {
    let o = r ? t.charCodeAt(r - 1) : 10;
    if (o == 10) return r;
    if ((r--, r < i || (o != 32 && o != 9))) return e;
  }
}
const G8 = (t) => t >= 55296 && t <= 56319,
  J8 = (t) => t >= 56320 && t <= 57343;
function pa(t, e) {
  return !e || e == t.length || !G8(t.charCodeAt(e - 1)) || !J8(t.charCodeAt(e));
}
function Afe(t, e, n) {
  var r;
  return (
    (Ac = ((r = n == null ? void 0 : n.scanLimit) !== null && r !== void 0 ? r : 1e9) >> 1), Efe(t, e, zs(t, 0, t.length, e, 0, e.length))
  );
}
function K8(t, e, n) {
  return Tfe(Afe(t, e, n), t, e);
}
const oi = xe.define({ combine: (t) => t[0] }),
  Lv = Ee.define(),
  ma = Qt.define({
    create(t) {
      return null;
    },
    update(t, e) {
      for (let n of e.effects) n.is(Lv) && (t = n.value);
      return t;
    },
  });
class Zl {
  constructor(e, n, r, i, o) {
    (this.changes = e), (this.fromA = n), (this.toA = r), (this.fromB = i), (this.toB = o);
  }
  offset(e, n) {
    return e || n ? new Zl(this.changes, this.fromA + e, this.toA + e, this.fromB + n, this.toB + n) : this;
  }
  get endA() {
    return Math.max(this.fromA, this.toA - 1);
  }
  get endB() {
    return Math.max(this.fromB, this.toB - 1);
  }
  static build(e, n, r) {
    return eI(K8(e.toString(), n.toString(), r), e, n, 0, 0);
  }
  static updateA(e, n, r, i, o) {
    return CE(kE(e, i, !0, r.length), e, n, r, o);
  }
  static updateB(e, n, r, i, o) {
    return CE(kE(e, i, !1, n.length), e, n, r, o);
  }
}
function yE(t, e, n, r) {
  let i = n.lineAt(t),
    o = r.lineAt(e);
  return i.to == t && o.to == e && t < n.length && e < r.length ? [t + 1, e + 1] : [i.from, o.from];
}
function wE(t, e, n, r) {
  let i = n.lineAt(t),
    o = r.lineAt(e);
  return i.from == t && o.from == e ? [t, e] : [i.to + 1, o.to + 1];
}
function eI(t, e, n, r, i) {
  let o = [];
  for (let s = 0; s < t.length; s++) {
    let l = t[s],
      [a, c] = yE(l.fromA + r, l.fromB + i, e, n),
      [u, h] = wE(l.toA + r, l.toB + i, e, n),
      d = [l.offset(-a + r, -c + i)];
    for (; s < t.length - 1; ) {
      let f = t[s + 1],
        [p, m] = yE(f.fromA + r, f.fromB + i, e, n);
      if (p > u + 1 && m > h + 1) break;
      d.push(f.offset(-a + r, -c + i)), ([u, h] = wE(f.toA + r, f.toB + i, e, n)), s++;
    }
    o.push(new Zl(d, a, Math.max(a, u), c, Math.max(c, h)));
  }
  return o;
}
const Ld = 1e3;
function SE(t, e, n, r) {
  let i = 0,
    o = t.length;
  for (;;) {
    if (i == o) {
      let u = 0,
        h = 0;
      i && ({ toA: u, toB: h } = t[i - 1]);
      let d = e - (n ? u : h);
      return [u + d, h + d];
    }
    let s = (i + o) >> 1,
      l = t[s],
      [a, c] = n ? [l.fromA, l.toA] : [l.fromB, l.toB];
    if (a > e) o = s;
    else if (c <= e) i = s + 1;
    else return r ? [l.fromA, l.fromB] : [l.toA, l.toB];
  }
}
function kE(t, e, n, r) {
  let i = [];
  return (
    e.iterChangedRanges((o, s, l, a) => {
      let c = 0,
        u = n ? e.length : r,
        h = 0,
        d = n ? r : e.length;
      o > Ld && ([c, h] = SE(t, o - Ld, n, !0)), s < e.length - Ld && ([u, d] = SE(t, s + Ld, n, !1));
      let f = a - l - (s - o),
        p,
        [m, O] = n ? [f, 0] : [0, f];
      i.length && (p = i[i.length - 1]).toA >= c
        ? (i[i.length - 1] = { fromA: p.fromA, fromB: p.fromB, toA: u, toB: d, diffA: p.diffA + m, diffB: p.diffB + O })
        : i.push({ fromA: c, toA: u, fromB: h, toB: d, diffA: m, diffB: O });
    }),
    i
  );
}
function CE(t, e, n, r, i) {
  if (!t.length) return e;
  let o = [];
  for (let s = 0, l = 0, a = 0, c = 0; ; s++) {
    let u = s == t.length ? null : t[s],
      h = u ? u.fromA + l : n.length,
      d = u ? u.fromB + a : r.length;
    for (; c < e.length; ) {
      let O = e[c];
      if (O.toA + l > h || O.toB + a > d) break;
      o.push(O.offset(l, a)), c++;
    }
    if (!u) break;
    let f = u.toA + l + u.diffA,
      p = u.toB + a + u.diffB,
      m = K8(n.sliceString(h, f), r.sliceString(d, p), i);
    for (let O of eI(m, n, r, h, d)) o.push(O);
    for (l += u.diffA, a += u.diffB; c < e.length; ) {
      let O = e[c];
      if (O.fromA + l > f && O.fromB + a > p) break;
      c++;
    }
  }
  return o;
}
const $fe = { scanLimit: 500 },
  tI = At.fromClass(
    class {
      constructor(t) {
        ({ deco: this.deco, gutter: this.gutter } = TE(t));
      }
      update(t) {
        (t.docChanged || t.viewportChanged || Rfe(t.startState, t.state) || Ife(t.startState, t.state)) &&
          ({ deco: this.deco, gutter: this.gutter } = TE(t.view));
      }
    },
    { decorations: (t) => t.deco }
  ),
  Nd = zr.low(
    J7({
      class: "cm-changeGutter",
      markers: (t) => {
        var e;
        return ((e = t.plugin(tI)) === null || e === void 0 ? void 0 : e.gutter) || ze.empty;
      },
    })
  );
function Rfe(t, e) {
  return t.field(ma, !1) != e.field(ma, !1);
}
function Ife(t, e) {
  return t.facet(oi) != e.facet(oi);
}
const _E = me.line({ class: "cm-changedLine" }),
  Mfe = me.mark({ class: "cm-changedText" }),
  Lfe = me.mark({ tagName: "ins", class: "cm-insertedLine" }),
  Nfe = me.mark({ tagName: "del", class: "cm-deletedLine" }),
  EE = new (class extends yi {
    constructor() {
      super(...arguments), (this.elementClass = "cm-changedLineGutter");
    }
  })();
function Qfe(t, e, n, r, i, o) {
  let s = n ? t.fromA : t.fromB,
    l = n ? t.toA : t.toB,
    a = 0;
  if (s != l) {
    i.add(s, s, _E), i.add(s, l, n ? Nfe : Lfe), o && o.add(s, s, EE);
    for (let c = e.iterRange(s, l - 1), u = s; !c.next().done; ) {
      if (c.lineBreak) {
        u++, i.add(u, u, _E), o && o.add(u, u, EE);
        continue;
      }
      let h = u + c.value.length;
      if (r)
        for (; a < t.changes.length; ) {
          let d = t.changes[a],
            f = s + (n ? d.fromA : d.fromB),
            p = s + (n ? d.toA : d.toB),
            m = Math.max(u, f),
            O = Math.min(h, p);
          if ((m < O && i.add(m, O, Mfe), p < h)) a++;
          else break;
        }
      u = h;
    }
  }
}
function TE(t) {
  let e = t.state.field(ma),
    { side: n, highlightChanges: r, markGutter: i } = t.state.facet(oi),
    o = n == "a",
    s = new lr(),
    l = i ? new lr() : null,
    { from: a, to: c } = t.viewport;
  for (let u of e) {
    if ((o ? u.fromA : u.fromB) >= c) break;
    (o ? u.toA : u.toB) > a && Qfe(u, t.state.doc, o, r, s, l);
  }
  return { deco: s.finish(), gutter: l && l.finish() };
}
class Qd extends Wr {
  constructor(e) {
    super(), (this.height = e);
  }
  eq(e) {
    return this.height == e.height;
  }
  toDOM() {
    let e = document.createElement("div");
    return (e.className = "cm-mergeSpacer"), (e.style.height = this.height + "px"), e;
  }
  updateDOM(e) {
    return (e.style.height = this.height + "px"), !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
const Fp = Ee.define({ map: (t, e) => t.map(e) }),
  $c = Qt.define({
    create: () => me.none,
    update: (t, e) => {
      for (let n of e.effects) if (n.is(Fp)) return n.value;
      return t.map(e.changes);
    },
    provide: (t) => re.decorations.from(t),
  }),
  Dd = 0.01;
function Dfe(t, e, n) {
  let r = new lr(),
    i = new lr(),
    o = t.state.field($c).iter(),
    s = e.state.field($c).iter(),
    l = 0,
    a = 0,
    c = 0,
    u = 0;
  for (let p = 0; ; p++) {
    let m = p < n.length ? n[p] : null;
    if (l < (m ? m.fromA : t.state.doc.length)) {
      let O = t.lineBlockAt(l).top + c,
        v = e.lineBlockAt(a).top + u,
        g = O - v;
      g < -Dd
        ? ((c -= g), r.add(l, l, me.widget({ widget: new Qd(-g), block: !0, side: -1 })))
        : g > Dd && ((u += g), i.add(a, a, me.widget({ widget: new Qd(g), block: !0, side: -1 })));
    }
    if (!m) break;
    for (l = m.toA, a = m.toB; o.value && o.from < l; ) (c -= o.value.spec.widget.height), o.next();
    for (; s.value && s.from < a; ) (u -= s.value.spec.widget.height), s.next();
  }
  for (; o.value; ) (c -= o.value.spec.widget.height), o.next();
  for (; s.value; ) (u -= s.value.spec.widget.height), s.next();
  let h = t.contentHeight + c - (e.contentHeight + u);
  h < Dd
    ? r.add(t.state.doc.length, t.state.doc.length, me.widget({ widget: new Qd(-h), block: !0, side: 1 }))
    : h > Dd && i.add(e.state.doc.length, e.state.doc.length, me.widget({ widget: new Qd(h), block: !0, side: 1 }));
  let d = r.finish(),
    f = i.finish();
  ze.eq([d], [t.state.field($c)]) || t.dispatch({ effects: Fp.of(d) }),
    ze.eq([f], [e.state.field($c)]) || e.dispatch({ effects: Fp.of(f) });
}
const Nv = Ee.define({ map: (t, e) => e.mapPos(t) });
class Ffe extends Wr {
  constructor(e) {
    super(), (this.lines = e);
  }
  eq(e) {
    return this.lines == e.lines;
  }
  toDOM(e) {
    let n = document.createElement("div");
    return (
      (n.className = "cm-collapsedLines"),
      (n.textContent = "⦚ " + e.state.phrase("$ unchanged lines", this.lines) + " ⦚"),
      n.addEventListener("click", (r) => {
        let i = e.posAtDOM(r.target);
        e.dispatch({ effects: Nv.of(i) });
        let { side: o, sibling: s } = e.state.facet(oi);
        s && s().dispatch({ effects: Nv.of(Bfe(i, e.state.field(ma), o == "a")) });
      }),
      n
    );
  }
  ignoreEvent(e) {
    return e instanceof MouseEvent;
  }
  get estimatedHeight() {
    return 27;
  }
}
function Bfe(t, e, n) {
  let r = 0,
    i = 0;
  for (let o = 0; ; o++) {
    let s = o < e.length ? e[o] : null;
    if (!s || (n ? s.fromA : s.fromB) >= t) return i + (t - r);
    [r, i] = n ? [s.toA, s.toB] : [s.toB, s.toA];
  }
}
const Vfe = Qt.define({
  create(t) {
    return me.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects) n.is(Nv) && (t = t.update({ filter: (r) => r != n.value }));
    return t;
  },
  provide: (t) => re.decorations.from(t),
});
function PE({ margin: t = 3, minSize: e = 4 }) {
  return Vfe.init((n) => jfe(n, t, e));
}
function jfe(t, e, n) {
  let r = new lr(),
    i = t.facet(oi).side == "a",
    o = t.field(ma),
    s = 1;
  for (let l = 0; ; l++) {
    let a = l < o.length ? o[l] : null,
      c = l ? s + e : 1,
      u = a ? t.doc.lineAt(i ? a.fromA : a.fromB).number - 1 - e : t.doc.lines,
      h = u - c + 1;
    if ((h >= n && r.add(t.doc.line(c).from, t.doc.line(u).to, me.replace({ widget: new Ffe(h), block: !0 })), !a)) break;
    s = t.doc.lineAt(Math.min(t.doc.length, i ? a.toA : a.toB)).number;
  }
  return r.finish();
}
const Zfe = re.styleModule.of(
    new qi({
      ".cm-mergeView": { overflowY: "auto" },
      ".cm-mergeViewEditors": { display: "flex", alignItems: "stretch" },
      ".cm-mergeViewEditor": { flexGrow: 1, flexBasis: 0, overflow: "hidden" },
      ".cm-merge-revert": { width: "1.6em", flexGrow: 0, flexShrink: 0, position: "relative" },
      ".cm-merge-revert button": {
        position: "absolute",
        display: "block",
        width: "100%",
        boxSizing: "border-box",
        textAlign: "center",
        background: "none",
        border: "none",
        font: "inherit",
        cursor: "pointer",
      },
    })
  ),
  zfe = re.baseTheme({
    ".cm-mergeView & .cm-scroller, .cm-mergeView &": { height: "auto !important", overflowY: "visible !important" },
    "&.cm-merge-a .cm-changedLine, .cm-deletedChunk": { backgroundColor: "rgba(160, 128, 100, .08)" },
    "&.cm-merge-b .cm-changedLine": { backgroundColor: "rgba(100, 160, 128, .08)" },
    "&light.cm-merge-a .cm-changedText, &light .cm-deletedChunk .cm-deletedText": {
      background: "linear-gradient(#ee443366, #ee443366) bottom/100% 2px no-repeat",
    },
    "&dark.cm-merge-a .cm-changedText, &dark .cm-deletedChunk .cm-deletedText": {
      background: "linear-gradient(#ffaa9966, #ffaa9966) bottom/100% 2px no-repeat",
    },
    "&light.cm-merge-b .cm-changedText": { background: "linear-gradient(#22bb2266, #22bb2266) bottom/100% 2px no-repeat" },
    "&dark.cm-merge-b .cm-changedText": { background: "linear-gradient(#88ff8866, #88ff8866) bottom/100% 2px no-repeat" },
    ".cm-insertedLine, .cm-deletedLine": { textDecoration: "none" },
    ".cm-deletedChunk": {
      paddingLeft: "6px",
      "& .cm-chunkButtons": { position: "absolute", insetInlineEnd: "5px" },
      "& button": {
        border: "none",
        cursor: "pointer",
        color: "white",
        margin: "0 2px",
        borderRadius: "3px",
        "&[name=accept]": { background: "#2a2" },
        "&[name=reject]": { background: "#d43" },
      },
    },
    ".cm-collapsedLines": { padding: "5px 5px 5px 10px", cursor: "pointer" },
    "&light .cm-collapsedLines": {
      color: "#444",
      background: "linear-gradient(to bottom, transparent 0, #f3f3f3 30%, #f3f3f3 70%, transparent 100%)",
    },
    "&dark .cm-collapsedLines": {
      color: "#ddd",
      background: "linear-gradient(to bottom, transparent 0, #222 30%, #222 70%, transparent 100%)",
    },
    ".cm-changeGutter": { width: "3px", paddingLeft: "1px" },
    "&light.cm-merge-a .cm-changedLineGutter, &light .cm-deletedLineGutter": { background: "#e43" },
    "&dark.cm-merge-a .cm-changedLineGutter, &dark .cm-deletedLineGutter": { background: "#fa9" },
    "&light.cm-merge-b .cm-changedLineGutter": { background: "#2b2" },
    "&dark.cm-merge-b .cm-changedLineGutter": { background: "#8f8" },
  }),
  AE = new Qa(),
  Fd = new Qa();
class Wfe {
  constructor(e) {
    (this.revertDOM = null), (this.revertToA = !1), (this.revertToLeft = !1), (this.measuring = -1), (this.diffConf = e.diffConfig || $fe);
    let n = [
        zr.low(tI),
        zfe,
        Zfe,
        $c,
        re.updateListener.of((h) => {
          this.measuring < 0 &&
            (h.heightChanged || h.viewportChanged) &&
            !h.transactions.some((d) => d.effects.some((f) => f.is(Fp))) &&
            this.measure();
        }),
      ],
      r = [oi.of({ side: "a", sibling: () => this.b, highlightChanges: e.highlightChanges !== !1, markGutter: e.gutter !== !1 })];
    e.gutter !== !1 && r.push(Nd);
    let i = Me.create({
        doc: e.a.doc,
        selection: e.a.selection,
        extensions: [e.a.extensions || [], re.editorAttributes.of({ class: "cm-merge-a" }), Fd.of(r), n],
      }),
      o = [oi.of({ side: "b", sibling: () => this.a, highlightChanges: e.highlightChanges !== !1, markGutter: e.gutter !== !1 })];
    e.gutter !== !1 && o.push(Nd);
    let s = Me.create({
      doc: e.b.doc,
      selection: e.b.selection,
      extensions: [e.b.extensions || [], re.editorAttributes.of({ class: "cm-merge-b" }), Fd.of(o), n],
    });
    this.chunks = Zl.build(i.doc, s.doc, this.diffConf);
    let l = [ma.init(() => this.chunks), AE.of(e.collapseUnchanged ? PE(e.collapseUnchanged) : [])];
    (i = i.update({ effects: Ee.appendConfig.of(l) }).state),
      (s = s.update({ effects: Ee.appendConfig.of(l) }).state),
      (this.dom = document.createElement("div")),
      (this.dom.className = "cm-mergeView"),
      (this.editorDOM = this.dom.appendChild(document.createElement("div"))),
      (this.editorDOM.className = "cm-mergeViewEditors");
    let a = e.orientation || "a-b",
      c = document.createElement("div");
    c.className = "cm-mergeViewEditor";
    let u = document.createElement("div");
    (u.className = "cm-mergeViewEditor"),
      this.editorDOM.appendChild(a == "a-b" ? c : u),
      this.editorDOM.appendChild(a == "a-b" ? u : c),
      (this.a = new re({ state: i, parent: c, root: e.root, dispatchTransactions: (h) => this.dispatch(h, this.a) })),
      (this.b = new re({ state: s, parent: u, root: e.root, dispatchTransactions: (h) => this.dispatch(h, this.b) })),
      this.setupRevertControls(!!e.revertControls, e.revertControls == "b-to-a", e.renderRevertControl),
      e.parent && e.parent.appendChild(this.dom),
      this.scheduleMeasure();
  }
  dispatch(e, n) {
    if (e.some((r) => r.docChanged)) {
      let r = e[e.length - 1],
        i = e.reduce((s, l) => s.compose(l.changes), jt.empty(e[0].startState.doc.length));
      (this.chunks =
        n == this.a
          ? Zl.updateA(this.chunks, r.newDoc, this.b.state.doc, i, this.diffConf)
          : Zl.updateB(this.chunks, this.a.state.doc, r.newDoc, i, this.diffConf)),
        n.update([...e, r.state.update({ effects: Lv.of(this.chunks) })]);
      let o = n == this.a ? this.b : this.a;
      o.update([o.state.update({ effects: Lv.of(this.chunks) })]), this.scheduleMeasure();
    } else n.update(e);
  }
  reconfigure(e) {
    if (("diffConfig" in e && (this.diffConf = e.diffConfig), "orientation" in e)) {
      let o = e.orientation != "b-a";
      if (o != (this.editorDOM.firstChild == this.a.dom.parentNode)) {
        let s = this.a.dom.parentNode,
          l = this.b.dom.parentNode;
        s.remove(),
          l.remove(),
          this.editorDOM.insertBefore(o ? s : l, this.editorDOM.firstChild),
          this.editorDOM.appendChild(o ? l : s),
          (this.revertToLeft = !this.revertToLeft),
          this.revertDOM && (this.revertDOM.textContent = "");
      }
    }
    if ("revertControls" in e || "renderRevertControl" in e) {
      let o = !!this.revertDOM,
        s = this.revertToA,
        l = this.renderRevert;
      "revertControls" in e && ((o = !!e.revertControls), (s = e.revertControls == "b-to-a")),
        "renderRevertControl" in e && (l = e.renderRevertControl),
        this.setupRevertControls(o, s, l);
    }
    let n = "highlightChanges" in e,
      r = "gutter" in e,
      i = "collapseUnchanged" in e;
    if (n || r || i) {
      let o = [],
        s = [];
      if (n || r) {
        let l = this.a.state.facet(oi),
          a = r ? e.gutter !== !1 : l.markGutter,
          c = n ? e.highlightChanges !== !1 : l.highlightChanges;
        o.push(Fd.reconfigure([oi.of({ side: "a", sibling: () => this.b, highlightChanges: c, markGutter: a }), a ? Nd : []])),
          s.push(Fd.reconfigure([oi.of({ side: "b", sibling: () => this.a, highlightChanges: c, markGutter: a }), a ? Nd : []]));
      }
      if (i) {
        let l = AE.reconfigure(e.collapseUnchanged ? PE(e.collapseUnchanged) : []);
        o.push(l), s.push(l);
      }
      this.a.dispatch({ effects: o }), this.b.dispatch({ effects: s });
    }
    this.scheduleMeasure();
  }
  setupRevertControls(e, n, r) {
    (this.revertToA = n),
      (this.revertToLeft = this.revertToA == (this.editorDOM.firstChild == this.a.dom.parentNode)),
      (this.renderRevert = r),
      !e && this.revertDOM
        ? (this.revertDOM.remove(), (this.revertDOM = null))
        : e && !this.revertDOM
        ? ((this.revertDOM = this.editorDOM.insertBefore(document.createElement("div"), this.editorDOM.firstChild.nextSibling)),
          this.revertDOM.addEventListener("mousedown", (i) => this.revertClicked(i)),
          (this.revertDOM.className = "cm-merge-revert"))
        : this.revertDOM && (this.revertDOM.textContent = "");
  }
  scheduleMeasure() {
    if (this.measuring < 0) {
      let e = this.dom.ownerDocument.defaultView || window;
      this.measuring = e.requestAnimationFrame(() => {
        (this.measuring = -1), this.measure();
      });
    }
  }
  measure() {
    Dfe(this.a, this.b, this.chunks), this.revertDOM && this.updateRevertButtons();
  }
  updateRevertButtons() {
    let e = this.revertDOM,
      n = e.firstChild,
      r = this.a.viewport,
      i = this.b.viewport;
    for (let o = 0; o < this.chunks.length; o++) {
      let s = this.chunks[o];
      if (s.fromA > r.to || s.fromB > i.to) break;
      if (s.fromA < r.from || s.fromB < i.from) continue;
      let l = this.a.lineBlockAt(s.fromA).top + "px";
      for (; n && +n.dataset.chunk < o; ) n = $E(n);
      n && n.dataset.chunk == String(o)
        ? (n.style.top != l && (n.style.top = l), (n = n.nextSibling))
        : e.insertBefore(this.renderRevertButton(l, o), n);
    }
    for (; n; ) n = $E(n);
  }
  renderRevertButton(e, n) {
    let r;
    if (this.renderRevert) r = this.renderRevert();
    else {
      r = document.createElement("button");
      let i = this.a.state.phrase("Revert this chunk");
      r.setAttribute("aria-label", i), r.setAttribute("title", i), (r.textContent = this.revertToLeft ? "⇜" : "⇝");
    }
    return (r.style.top = e), r.setAttribute("data-chunk", String(n)), r;
  }
  revertClicked(e) {
    let n = e.target,
      r;
    for (; n && n.parentNode != this.revertDOM; ) n = n.parentNode;
    if (n && (r = this.chunks[n.dataset.chunk])) {
      let [i, o, s, l, a, c] = this.revertToA
          ? [this.b, this.a, r.fromB, r.toB, r.fromA, r.toA]
          : [this.a, this.b, r.fromA, r.toA, r.fromB, r.toB],
        u = i.state.sliceDoc(s, Math.max(s, l - 1));
      s != l && c <= o.state.doc.length && (u += i.state.lineBreak),
        o.dispatch({ changes: { from: a, to: Math.min(o.state.doc.length, c), insert: u }, userEvent: "revert" }),
        e.preventDefault();
    }
  }
  destroy() {
    this.a.destroy(),
      this.b.destroy(),
      this.measuring > -1 && (this.dom.ownerDocument.defaultView || window).cancelAnimationFrame(this.measuring),
      this.dom.remove();
  }
}
function $E(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
class Bp {
  static create(e, n, r, i, o) {
    let s = (i + (i << 8) + e + (n << 4)) | 0;
    return new Bp(e, n, r, s, o, [], []);
  }
  constructor(e, n, r, i, o, s, l) {
    (this.type = e),
      (this.value = n),
      (this.from = r),
      (this.hash = i),
      (this.end = o),
      (this.children = s),
      (this.positions = l),
      (this.hashProp = [[Ae.contextHash, i]]);
  }
  addChild(e, n) {
    e.prop(Ae.contextHash) != this.hash && (e = new Ve(e.type, e.children, e.positions, e.length, this.hashProp)),
      this.children.push(e),
      this.positions.push(n);
  }
  toTree(e, n = this.end) {
    let r = this.children.length - 1;
    return (
      r >= 0 && (n = Math.max(n, this.positions[r] + this.children[r].length + this.from)),
      new Ve(e.types[this.type], this.children, this.positions, n - this.from).balance({
        makeTree: (i, o, s) => new Ve(Xt.none, i, o, s, this.hashProp),
      })
    );
  }
}
var se;
(function (t) {
  (t[(t.Document = 1)] = "Document"),
    (t[(t.CodeBlock = 2)] = "CodeBlock"),
    (t[(t.FencedCode = 3)] = "FencedCode"),
    (t[(t.Blockquote = 4)] = "Blockquote"),
    (t[(t.HorizontalRule = 5)] = "HorizontalRule"),
    (t[(t.BulletList = 6)] = "BulletList"),
    (t[(t.OrderedList = 7)] = "OrderedList"),
    (t[(t.ListItem = 8)] = "ListItem"),
    (t[(t.ATXHeading1 = 9)] = "ATXHeading1"),
    (t[(t.ATXHeading2 = 10)] = "ATXHeading2"),
    (t[(t.ATXHeading3 = 11)] = "ATXHeading3"),
    (t[(t.ATXHeading4 = 12)] = "ATXHeading4"),
    (t[(t.ATXHeading5 = 13)] = "ATXHeading5"),
    (t[(t.ATXHeading6 = 14)] = "ATXHeading6"),
    (t[(t.SetextHeading1 = 15)] = "SetextHeading1"),
    (t[(t.SetextHeading2 = 16)] = "SetextHeading2"),
    (t[(t.HTMLBlock = 17)] = "HTMLBlock"),
    (t[(t.LinkReference = 18)] = "LinkReference"),
    (t[(t.Paragraph = 19)] = "Paragraph"),
    (t[(t.CommentBlock = 20)] = "CommentBlock"),
    (t[(t.ProcessingInstructionBlock = 21)] = "ProcessingInstructionBlock"),
    (t[(t.Escape = 22)] = "Escape"),
    (t[(t.Entity = 23)] = "Entity"),
    (t[(t.HardBreak = 24)] = "HardBreak"),
    (t[(t.Emphasis = 25)] = "Emphasis"),
    (t[(t.StrongEmphasis = 26)] = "StrongEmphasis"),
    (t[(t.Link = 27)] = "Link"),
    (t[(t.Image = 28)] = "Image"),
    (t[(t.InlineCode = 29)] = "InlineCode"),
    (t[(t.HTMLTag = 30)] = "HTMLTag"),
    (t[(t.Comment = 31)] = "Comment"),
    (t[(t.ProcessingInstruction = 32)] = "ProcessingInstruction"),
    (t[(t.Autolink = 33)] = "Autolink"),
    (t[(t.HeaderMark = 34)] = "HeaderMark"),
    (t[(t.QuoteMark = 35)] = "QuoteMark"),
    (t[(t.ListMark = 36)] = "ListMark"),
    (t[(t.LinkMark = 37)] = "LinkMark"),
    (t[(t.EmphasisMark = 38)] = "EmphasisMark"),
    (t[(t.CodeMark = 39)] = "CodeMark"),
    (t[(t.CodeText = 40)] = "CodeText"),
    (t[(t.CodeInfo = 41)] = "CodeInfo"),
    (t[(t.LinkTitle = 42)] = "LinkTitle"),
    (t[(t.LinkLabel = 43)] = "LinkLabel"),
    (t[(t.URL = 44)] = "URL");
})(se || (se = {}));
class Xfe {
  constructor(e, n) {
    (this.start = e), (this.content = n), (this.marks = []), (this.parsers = []);
  }
}
class Ufe {
  constructor() {
    (this.text = ""),
      (this.baseIndent = 0),
      (this.basePos = 0),
      (this.depth = 0),
      (this.markers = []),
      (this.pos = 0),
      (this.indent = 0),
      (this.next = -1);
  }
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    (this.indent = this.countIndent(e, this.pos, this.indent)),
      (this.pos = e),
      (this.next = e == this.text.length ? -1 : this.text.charCodeAt(e));
  }
  skipSpace(e) {
    return Hc(this.text, e);
  }
  reset(e) {
    for (
      this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1;
      this.markers.length;

    )
      this.markers.pop();
  }
  moveBase(e) {
    (this.basePos = e), (this.baseIndent = this.countIndent(e, this.pos, this.indent));
  }
  moveBaseColumn(e) {
    (this.baseIndent = e), (this.basePos = this.findColumn(e));
  }
  addMarker(e) {
    this.markers.push(e);
  }
  countIndent(e, n = 0, r = 0) {
    for (let i = n; i < e; i++) r += this.text.charCodeAt(i) == 9 ? 4 - (r % 4) : 1;
    return r;
  }
  findColumn(e) {
    let n = 0;
    for (let r = 0; n < this.text.length && r < e; n++) r += this.text.charCodeAt(n) == 9 ? 4 - (r % 4) : 1;
    return n;
  }
  scrub() {
    if (!this.baseIndent) return this.text;
    let e = "";
    for (let n = 0; n < this.basePos; n++) e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function RE(t, e, n) {
  if (n.pos == n.text.length || (t != e.block && n.indent >= e.stack[n.depth + 1].value + n.baseIndent)) return !0;
  if (n.indent >= n.baseIndent + 4) return !1;
  let r = (t.type == se.OrderedList ? aS : lS)(n, e, !1);
  return r > 0 && (t.type != se.BulletList || sS(n, e, !1) < 0) && n.text.charCodeAt(n.pos + r - 1) == t.value;
}
const nI = {
  [se.Blockquote](t, e, n) {
    return n.next != 62
      ? !1
      : (n.markers.push(Xe(se.QuoteMark, e.lineStart + n.pos, e.lineStart + n.pos + 1)),
        n.moveBase(n.pos + (yr(n.text.charCodeAt(n.pos + 1)) ? 2 : 1)),
        (t.end = e.lineStart + n.text.length),
        !0);
  },
  [se.ListItem](t, e, n) {
    return n.indent < n.baseIndent + t.value && n.next > -1 ? !1 : (n.moveBaseColumn(n.baseIndent + t.value), !0);
  },
  [se.OrderedList]: RE,
  [se.BulletList]: RE,
  [se.Document]() {
    return !0;
  },
};
function yr(t) {
  return t == 32 || t == 9 || t == 10 || t == 13;
}
function Hc(t, e = 0) {
  for (; e < t.length && yr(t.charCodeAt(e)); ) e++;
  return e;
}
function IE(t, e, n) {
  for (; e > n && yr(t.charCodeAt(e - 1)); ) e--;
  return e;
}
function rI(t) {
  if (t.next != 96 && t.next != 126) return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; ) e++;
  if (e < t.pos + 3) return -1;
  if (t.next == 96) {
    for (let n = e; n < t.text.length; n++) if (t.text.charCodeAt(n) == 96) return -1;
  }
  return e;
}
function iI(t) {
  return t.next != 62 ? -1 : t.text.charCodeAt(t.pos + 1) == 32 ? 2 : 1;
}
function sS(t, e, n) {
  if (t.next != 42 && t.next != 45 && t.next != 95) return -1;
  let r = 1;
  for (let i = t.pos + 1; i < t.text.length; i++) {
    let o = t.text.charCodeAt(i);
    if (o == t.next) r++;
    else if (!yr(o)) return -1;
  }
  return (n && t.next == 45 && lI(t) > -1 && t.depth == e.stack.length) || r < 3 ? -1 : 1;
}
function oI(t, e) {
  for (let n = t.stack.length - 1; n >= 0; n--) if (t.stack[n].type == e) return !0;
  return !1;
}
function lS(t, e, n) {
  return (t.next == 45 || t.next == 43 || t.next == 42) &&
    (t.pos == t.text.length - 1 || yr(t.text.charCodeAt(t.pos + 1))) &&
    (!n || oI(e, se.BulletList) || t.skipSpace(t.pos + 2) < t.text.length)
    ? 1
    : -1;
}
function aS(t, e, n) {
  let r = t.pos,
    i = t.next;
  for (; i >= 48 && i <= 57; ) {
    r++;
    if (r == t.text.length) return -1;
    i = t.text.charCodeAt(r);
  }
  return r == t.pos ||
    r > t.pos + 9 ||
    (i != 46 && i != 41) ||
    (r < t.text.length - 1 && !yr(t.text.charCodeAt(r + 1))) ||
    (n && !oI(e, se.OrderedList) && (t.skipSpace(r + 1) == t.text.length || r > t.pos + 1 || t.next != 49))
    ? -1
    : r + 1 - t.pos;
}
function sI(t) {
  if (t.next != 35) return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == 35; ) e++;
  if (e < t.text.length && t.text.charCodeAt(e) != 32) return -1;
  let n = e - t.pos;
  return n > 6 ? -1 : n;
}
function lI(t) {
  if ((t.next != 45 && t.next != 61) || t.indent >= t.baseIndent + 4) return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; ) e++;
  let n = e;
  for (; e < t.text.length && yr(t.text.charCodeAt(e)); ) e++;
  return e == t.text.length ? n : -1;
}
const Qv = /^[ \t]*$/,
  aI = /-->/,
  cI = /\?>/,
  Dv = [
    [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
    [/^\s*<!--/, aI],
    [/^\s*<\?/, cI],
    [/^\s*<![A-Z]/, />/],
    [/^\s*<!\[CDATA\[/, /\]\]>/],
    [
      /^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i,
      Qv,
    ],
    [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Qv],
  ];
function uI(t, e, n) {
  if (t.next != 60) return -1;
  let r = t.text.slice(t.pos);
  for (let i = 0, o = Dv.length - (n ? 1 : 0); i < o; i++) if (Dv[i][0].test(r)) return i;
  return -1;
}
function ME(t, e) {
  let n = t.countIndent(e, t.pos, t.indent),
    r = t.countIndent(t.skipSpace(e), e, n);
  return r >= n + 5 ? n + 1 : r;
}
function ds(t, e, n) {
  let r = t.length - 1;
  r >= 0 && t[r].to == e && t[r].type == se.CodeText ? (t[r].to = n) : t.push(Xe(se.CodeText, e, n));
}
const Bd = {
  LinkReference: void 0,
  IndentedCode(t, e) {
    let n = e.baseIndent + 4;
    if (e.indent < n) return !1;
    let r = e.findColumn(n),
      i = t.lineStart + r,
      o = t.lineStart + e.text.length,
      s = [],
      l = [];
    for (ds(s, i, o); t.nextLine() && e.depth >= t.stack.length; )
      if (e.pos == e.text.length) {
        ds(l, t.lineStart - 1, t.lineStart);
        for (let a of e.markers) l.push(a);
      } else {
        if (e.indent < n) break;
        {
          if (l.length) {
            for (let c of l) c.type == se.CodeText ? ds(s, c.from, c.to) : s.push(c);
            l = [];
          }
          ds(s, t.lineStart - 1, t.lineStart);
          for (let c of e.markers) s.push(c);
          o = t.lineStart + e.text.length;
          let a = t.lineStart + e.findColumn(e.baseIndent + 4);
          a < o && ds(s, a, o);
        }
      }
    return (
      l.length && ((l = l.filter((a) => a.type != se.CodeText)), l.length && (e.markers = l.concat(e.markers))),
      t.addNode(t.buffer.writeElements(s, -i).finish(se.CodeBlock, o - i), i),
      !0
    );
  },
  FencedCode(t, e) {
    let n = rI(e);
    if (n < 0) return !1;
    let r = t.lineStart + e.pos,
      i = e.next,
      o = n - e.pos,
      s = e.skipSpace(n),
      l = IE(e.text, e.text.length, s),
      a = [Xe(se.CodeMark, r, r + o)];
    s < l && a.push(Xe(se.CodeInfo, t.lineStart + s, t.lineStart + l));
    for (let c = !0; t.nextLine() && e.depth >= t.stack.length; c = !1) {
      let u = e.pos;
      if (e.indent - e.baseIndent < 4) for (; u < e.text.length && e.text.charCodeAt(u) == i; ) u++;
      if (u - e.pos >= o && e.skipSpace(u) == e.text.length) {
        for (let h of e.markers) a.push(h);
        a.push(Xe(se.CodeMark, t.lineStart + e.pos, t.lineStart + u)), t.nextLine();
        break;
      } else {
        c || ds(a, t.lineStart - 1, t.lineStart);
        for (let f of e.markers) a.push(f);
        let h = t.lineStart + e.basePos,
          d = t.lineStart + e.text.length;
        h < d && ds(a, h, d);
      }
    }
    return t.addNode(t.buffer.writeElements(a, -r).finish(se.FencedCode, t.prevLineEnd() - r), r), !0;
  },
  Blockquote(t, e) {
    let n = iI(e);
    return n < 0
      ? !1
      : (t.startContext(se.Blockquote, e.pos),
        t.addNode(se.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1),
        e.moveBase(e.pos + n),
        null);
  },
  HorizontalRule(t, e) {
    if (sS(e, t, !1) < 0) return !1;
    let n = t.lineStart + e.pos;
    return t.nextLine(), t.addNode(se.HorizontalRule, n), !0;
  },
  BulletList(t, e) {
    let n = lS(e, t, !1);
    if (n < 0) return !1;
    t.block.type != se.BulletList && t.startContext(se.BulletList, e.basePos, e.next);
    let r = ME(e, e.pos + 1);
    return (
      t.startContext(se.ListItem, e.basePos, r - e.baseIndent),
      t.addNode(se.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + n),
      e.moveBaseColumn(r),
      null
    );
  },
  OrderedList(t, e) {
    let n = aS(e, t, !1);
    if (n < 0) return !1;
    t.block.type != se.OrderedList && t.startContext(se.OrderedList, e.basePos, e.text.charCodeAt(e.pos + n - 1));
    let r = ME(e, e.pos + n);
    return (
      t.startContext(se.ListItem, e.basePos, r - e.baseIndent),
      t.addNode(se.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + n),
      e.moveBaseColumn(r),
      null
    );
  },
  ATXHeading(t, e) {
    let n = sI(e);
    if (n < 0) return !1;
    let r = e.pos,
      i = t.lineStart + r,
      o = IE(e.text, e.text.length, r),
      s = o;
    for (; s > r && e.text.charCodeAt(s - 1) == e.next; ) s--;
    (s == o || s == r || !yr(e.text.charCodeAt(s - 1))) && (s = e.text.length);
    let l = t.buffer.write(se.HeaderMark, 0, n).writeElements(t.parser.parseInline(e.text.slice(r + n + 1, s), i + n + 1), -i);
    s < e.text.length && l.write(se.HeaderMark, s - r, o - r);
    let a = l.finish(se.ATXHeading1 - 1 + n, e.text.length - r);
    return t.nextLine(), t.addNode(a, i), !0;
  },
  HTMLBlock(t, e) {
    let n = uI(e, t, !1);
    if (n < 0) return !1;
    let r = t.lineStart + e.pos,
      i = Dv[n][1],
      o = [],
      s = i != Qv;
    for (; !i.test(e.text) && t.nextLine(); ) {
      if (e.depth < t.stack.length) {
        s = !1;
        break;
      }
      for (let c of e.markers) o.push(c);
    }
    s && t.nextLine();
    let l = i == aI ? se.CommentBlock : i == cI ? se.ProcessingInstructionBlock : se.HTMLBlock,
      a = t.prevLineEnd();
    return t.addNode(t.buffer.writeElements(o, -r).finish(l, a - r), r), !0;
  },
  SetextHeading: void 0,
};
class Hfe {
  constructor(e) {
    (this.stage = 0), (this.elts = []), (this.pos = 0), (this.start = e.start), this.advance(e.content);
  }
  nextLine(e, n, r) {
    if (this.stage == -1) return !1;
    let i =
        r.content +
        `
` +
        n.scrub(),
      o = this.advance(i);
    return o > -1 && o < i.length ? this.complete(e, r, o) : !1;
  }
  finish(e, n) {
    return (this.stage == 2 || this.stage == 3) && Hc(n.content, this.pos) == n.content.length ? this.complete(e, n, n.content.length) : !1;
  }
  complete(e, n, r) {
    return e.addLeafElement(n, Xe(se.LinkReference, this.start, this.start + r, this.elts)), !0;
  }
  nextStage(e) {
    return e ? ((this.pos = e.to - this.start), this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (;;) {
      if (this.stage == -1) return -1;
      if (this.stage == 0) {
        if (!this.nextStage(bI(e, this.pos, this.start, !0))) return -1;
        if (e.charCodeAt(this.pos) != 58) return (this.stage = -1);
        this.elts.push(Xe(se.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(OI(e, Hc(e, this.pos), this.start))) return -1;
      } else if (this.stage == 2) {
        let n = Hc(e, this.pos),
          r = 0;
        if (n > this.pos) {
          let i = vI(e, n, this.start);
          if (i) {
            let o = a0(e, i.to - this.start);
            o > 0 && (this.nextStage(i), (r = o));
          }
        }
        return r || (r = a0(e, this.pos)), r > 0 && r < e.length ? r : -1;
      } else return a0(e, this.pos);
    }
  }
}
function a0(t, e) {
  for (; e < t.length; e++) {
    let n = t.charCodeAt(e);
    if (n == 10) break;
    if (!yr(n)) return -1;
  }
  return e;
}
class qfe {
  nextLine(e, n, r) {
    let i = n.depth < e.stack.length ? -1 : lI(n),
      o = n.next;
    if (i < 0) return !1;
    let s = Xe(se.HeaderMark, e.lineStart + n.pos, e.lineStart + i);
    return (
      e.nextLine(),
      e.addLeafElement(
        r,
        Xe(o == 61 ? se.SetextHeading1 : se.SetextHeading2, r.start, e.prevLineEnd(), [...e.parser.parseInline(r.content, r.start), s])
      ),
      !0
    );
  }
  finish() {
    return !1;
  }
}
const Yfe = {
    LinkReference(t, e) {
      return e.content.charCodeAt(0) == 91 ? new Hfe(e) : null;
    },
    SetextHeading() {
      return new qfe();
    },
  },
  Gfe = [
    (t, e) => sI(e) >= 0,
    (t, e) => rI(e) >= 0,
    (t, e) => iI(e) >= 0,
    (t, e) => lS(e, t, !0) >= 0,
    (t, e) => aS(e, t, !0) >= 0,
    (t, e) => sS(e, t, !0) >= 0,
    (t, e) => uI(e, t, !0) >= 0,
  ],
  Jfe = { text: "", end: 0 };
class Kfe {
  constructor(e, n, r, i) {
    (this.parser = e),
      (this.input = n),
      (this.ranges = i),
      (this.line = new Ufe()),
      (this.atEnd = !1),
      (this.reusePlaceholders = new Map()),
      (this.stoppedAt = null),
      (this.rangeI = 0),
      (this.to = i[i.length - 1].to),
      (this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = i[0].from),
      (this.block = Bp.create(se.Document, 0, this.lineStart, 0, 0)),
      (this.stack = [this.block]),
      (this.fragments = r.length ? new rpe(r, n) : null),
      this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt) return this.finish();
    let { line: e } = this;
    for (;;) {
      for (let r = 0; ; ) {
        let i = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; r < e.markers.length && (!i || e.markers[r].from < i.end); ) {
          let o = e.markers[r++];
          this.addNode(o.type, o.from, o.to);
        }
        if (!i) break;
        this.finishContext();
      }
      if (e.pos < e.text.length) break;
      if (!this.nextLine()) return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos)) return null;
    e: for (;;) {
      for (let r of this.parser.blockParsers)
        if (r) {
          let i = r(this, e);
          if (i != !1) {
            if (i == !0) return null;
            e.forward();
            continue e;
          }
        }
      break;
    }
    let n = new Xfe(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let r of this.parser.leafBlockParsers)
      if (r) {
        let i = r(this, n);
        i && n.parsers.push(i);
      }
    e: for (; this.nextLine() && e.pos != e.text.length; ) {
      if (e.indent < e.baseIndent + 4) {
        for (let r of this.parser.endLeafBlock) if (r(this, e, n)) break e;
      }
      for (let r of n.parsers) if (r.nextLine(this, e, n)) return null;
      n.content +=
        `
` + e.scrub();
      for (let r of e.markers) n.marks.push(r);
    }
    return this.finishLeaf(n), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash)) return !1;
    let n = this.fragments.takeNodes(this);
    return n
      ? ((this.absoluteLineStart += n),
        (this.lineStart = xI(this.absoluteLineStart, this.ranges)),
        this.moveRangeI(),
        this.absoluteLineStart < this.to
          ? (this.lineStart++, this.absoluteLineStart++, this.readLine())
          : ((this.atEnd = !0), this.readLine()),
        !0)
      : !1;
  }
  get depth() {
    return this.stack.length;
  }
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  nextLine() {
    return (
      (this.lineStart += this.line.text.length),
      this.absoluteLineEnd >= this.to
        ? ((this.absoluteLineStart = this.absoluteLineEnd), (this.atEnd = !0), this.readLine(), !1)
        : (this.lineStart++, (this.absoluteLineStart = this.absoluteLineEnd + 1), this.moveRangeI(), this.readLine(), !0)
    );
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, (this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from));
  }
  scanLine(e) {
    let n = Jfe;
    if (((n.end = e), e >= this.to)) n.text = "";
    else if (((n.text = this.lineChunkAt(e)), (n.end += n.text.length), this.ranges.length > 1)) {
      let r = this.absoluteLineStart,
        i = this.rangeI;
      for (; this.ranges[i].to < n.end; ) {
        i++;
        let o = this.ranges[i].from,
          s = this.lineChunkAt(o);
        (n.end = o + s.length), (n.text = n.text.slice(0, this.ranges[i - 1].to - r) + s), (r = n.end - n.text.length);
      }
    }
    return n;
  }
  readLine() {
    let { line: e } = this,
      { text: n, end: r } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = r, e.reset(n); e.depth < this.stack.length; e.depth++) {
      let i = this.stack[e.depth],
        o = this.parser.skipContextMarkup[i.type];
      if (!o) throw new Error("Unhandled block context " + se[i.type]);
      if (!o(i, this, e)) break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let n = this.input.chunk(e),
      r;
    if (this.input.lineChunks)
      r =
        n ==
        `
`
          ? ""
          : n;
    else {
      let i = n.indexOf(`
`);
      r = i < 0 ? n : n.slice(0, i);
    }
    return e + r.length > this.to ? r.slice(0, this.to - e) : r;
  }
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  startContext(e, n, r = 0) {
    (this.block = Bp.create(e, r, this.lineStart + n, this.block.hash, this.lineStart + this.line.text.length)),
      this.stack.push(this.block);
  }
  startComposite(e, n, r = 0) {
    this.startContext(this.parser.getNodeType(e), n, r);
  }
  addNode(e, n, r) {
    typeof e == "number" && (e = new Ve(this.parser.nodeSet.types[e], ga, ga, (r ?? this.prevLineEnd()) - n)),
      this.block.addChild(e, n - this.block.from);
  }
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  addLeafElement(e, n) {
    this.addNode(this.buffer.writeElements(Vv(n.children, e.marks), -n.from).finish(n.type, n.to - n.from), n.from);
  }
  finishContext() {
    let e = this.stack.pop(),
      n = this.stack[this.stack.length - 1];
    n.addChild(e.toTree(this.parser.nodeSet), e.from - n.from), (this.block = n);
  }
  finish() {
    for (; this.stack.length > 1; ) this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? hI(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  finishLeaf(e) {
    for (let r of e.parsers) if (r.finish(this, e)) return;
    let n = Vv(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(n, -e.start).finish(se.Paragraph, e.content.length), e.start);
  }
  elt(e, n, r, i) {
    return typeof e == "string" ? Xe(this.parser.getNodeType(e), n, r, i) : new pI(e, n);
  }
  get buffer() {
    return new fI(this.parser.nodeSet);
  }
}
function hI(t, e, n, r, i) {
  let o = t[e].to,
    s = [],
    l = [],
    a = n.from + r;
  function c(u, h) {
    for (; h ? u >= o : u > o; ) {
      let d = t[e + 1].from - o;
      (r += d), (u += d), e++, (o = t[e].to);
    }
  }
  for (let u = n.firstChild; u; u = u.nextSibling) {
    c(u.from + r, !0);
    let h = u.from + r,
      d,
      f = i.get(u.tree);
    f ? (d = f) : u.to + r > o ? ((d = hI(t, e, u, r, i)), c(u.to + r, !1)) : (d = u.toTree()), s.push(d), l.push(h - a);
  }
  return c(n.to + r, !1), new Ve(n.type, s, l, n.to + r - a, n.tree ? n.tree.propValues : void 0);
}
class xg extends Km {
  constructor(e, n, r, i, o, s, l, a, c) {
    super(),
      (this.nodeSet = e),
      (this.blockParsers = n),
      (this.leafBlockParsers = r),
      (this.blockNames = i),
      (this.endLeafBlock = o),
      (this.skipContextMarkup = s),
      (this.inlineParsers = l),
      (this.inlineNames = a),
      (this.wrappers = c),
      (this.nodeTypes = Object.create(null));
    for (let u of e.types) this.nodeTypes[u.name] = u.id;
  }
  createParse(e, n, r) {
    let i = new Kfe(this, e, n, r);
    for (let o of this.wrappers) i = o(i, e, n, r);
    return i;
  }
  configure(e) {
    let n = Fv(e);
    if (!n) return this;
    let { nodeSet: r, skipContextMarkup: i } = this,
      o = this.blockParsers.slice(),
      s = this.leafBlockParsers.slice(),
      l = this.blockNames.slice(),
      a = this.inlineParsers.slice(),
      c = this.inlineNames.slice(),
      u = this.endLeafBlock.slice(),
      h = this.wrappers;
    if (fc(n.defineNodes)) {
      i = Object.assign({}, i);
      let d = r.types.slice(),
        f;
      for (let p of n.defineNodes) {
        let { name: m, block: O, composite: v, style: g } = typeof p == "string" ? { name: p } : p;
        if (d.some((k) => k.name == m)) continue;
        v && (i[d.length] = (k, w, y) => v(w, y, k.value));
        let b = d.length,
          x = v
            ? ["Block", "BlockContext"]
            : O
            ? b >= se.ATXHeading1 && b <= se.SetextHeading2
              ? ["Block", "LeafBlock", "Heading"]
              : ["Block", "LeafBlock"]
            : void 0;
        d.push(Xt.define({ id: b, name: m, props: x && [[Ae.group, x]] })),
          g && (f || (f = {}), Array.isArray(g) || g instanceof Tr ? (f[m] = g) : Object.assign(f, g));
      }
      (r = new Da(d)), f && (r = r.extend(Fa(f)));
    }
    if ((fc(n.props) && (r = r.extend(...n.props)), fc(n.remove)))
      for (let d of n.remove) {
        let f = this.blockNames.indexOf(d),
          p = this.inlineNames.indexOf(d);
        f > -1 && (o[f] = s[f] = void 0), p > -1 && (a[p] = void 0);
      }
    if (fc(n.parseBlock))
      for (let d of n.parseBlock) {
        let f = l.indexOf(d.name);
        if (f > -1) (o[f] = d.parse), (s[f] = d.leaf);
        else {
          let p = d.before ? Vd(l, d.before) : d.after ? Vd(l, d.after) + 1 : l.length - 1;
          o.splice(p, 0, d.parse), s.splice(p, 0, d.leaf), l.splice(p, 0, d.name);
        }
        d.endLeaf && u.push(d.endLeaf);
      }
    if (fc(n.parseInline))
      for (let d of n.parseInline) {
        let f = c.indexOf(d.name);
        if (f > -1) a[f] = d.parse;
        else {
          let p = d.before ? Vd(c, d.before) : d.after ? Vd(c, d.after) + 1 : c.length - 1;
          a.splice(p, 0, d.parse), c.splice(p, 0, d.name);
        }
      }
    return n.wrap && (h = h.concat(n.wrap)), new xg(r, o, s, l, u, i, a, c, h);
  }
  getNodeType(e) {
    let n = this.nodeTypes[e];
    if (n == null) throw new RangeError(`Unknown node type '${e}'`);
    return n;
  }
  parseInline(e, n) {
    let r = new tpe(this, e, n);
    e: for (let i = n; i < r.end; ) {
      let o = r.char(i);
      for (let s of this.inlineParsers)
        if (s) {
          let l = s(r, o, i);
          if (l >= 0) {
            i = l;
            continue e;
          }
        }
      i++;
    }
    return r.resolveMarkers(0);
  }
}
function fc(t) {
  return t != null && t.length > 0;
}
function Fv(t) {
  if (!Array.isArray(t)) return t;
  if (t.length == 0) return null;
  let e = Fv(t[0]);
  if (t.length == 1) return e;
  let n = Fv(t.slice(1));
  if (!n || !e) return e || n;
  let r = (s, l) => (s || ga).concat(l || ga),
    i = e.wrap,
    o = n.wrap;
  return {
    props: r(e.props, n.props),
    defineNodes: r(e.defineNodes, n.defineNodes),
    parseBlock: r(e.parseBlock, n.parseBlock),
    parseInline: r(e.parseInline, n.parseInline),
    remove: r(e.remove, n.remove),
    wrap: i ? (o ? (s, l, a, c) => i(o(s, l, a, c), l, a, c) : i) : o,
  };
}
function Vd(t, e) {
  let n = t.indexOf(e);
  if (n < 0) throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return n;
}
let dI = [Xt.none];
for (let t = 1, e; (e = se[t]); t++)
  dI[t] = Xt.define({
    id: t,
    name: e,
    props: t >= se.Escape ? [] : [[Ae.group, t in nI ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document",
  });
const ga = [];
class fI {
  constructor(e) {
    (this.nodeSet = e), (this.content = []), (this.nodes = []);
  }
  write(e, n, r, i = 0) {
    return this.content.push(e, n, r, 4 + i * 4), this;
  }
  writeElements(e, n = 0) {
    for (let r of e) r.writeTo(this, n);
    return this;
  }
  finish(e, n) {
    return Ve.build({ buffer: this.content, nodeSet: this.nodeSet, reused: this.nodes, topID: e, length: n });
  }
}
let ju = class {
  constructor(e, n, r, i = ga) {
    (this.type = e), (this.from = n), (this.to = r), (this.children = i);
  }
  writeTo(e, n) {
    let r = e.content.length;
    e.writeElements(this.children, n), e.content.push(this.type, this.from + n, this.to + n, e.content.length + 4 - r);
  }
  toTree(e) {
    return new fI(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
class pI {
  constructor(e, n) {
    (this.tree = e), (this.from = n);
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return ga;
  }
  writeTo(e, n) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + n, this.to + n, -1);
  }
  toTree() {
    return this.tree;
  }
}
function Xe(t, e, n, r) {
  return new ju(t, e, n, r);
}
const mI = { resolve: "Emphasis", mark: "EmphasisMark" },
  gI = { resolve: "Emphasis", mark: "EmphasisMark" },
  pl = {},
  Bv = {};
class ur {
  constructor(e, n, r, i) {
    (this.type = e), (this.from = n), (this.to = r), (this.side = i);
  }
}
const LE = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Zu = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Zu = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {}
const c0 = {
  Escape(t, e, n) {
    if (e != 92 || n == t.end - 1) return -1;
    let r = t.char(n + 1);
    for (let i = 0; i < LE.length; i++) if (LE.charCodeAt(i) == r) return t.append(Xe(se.Escape, n, n + 2));
    return -1;
  },
  Entity(t, e, n) {
    if (e != 38) return -1;
    let r = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(t.slice(n + 1, n + 31));
    return r ? t.append(Xe(se.Entity, n, n + 1 + r[0].length)) : -1;
  },
  InlineCode(t, e, n) {
    if (e != 96 || (n && t.char(n - 1) == 96)) return -1;
    let r = n + 1;
    for (; r < t.end && t.char(r) == 96; ) r++;
    let i = r - n,
      o = 0;
    for (; r < t.end; r++)
      if (t.char(r) == 96) {
        if ((o++, o == i && t.char(r + 1) != 96))
          return t.append(Xe(se.InlineCode, n, r + 1, [Xe(se.CodeMark, n, n + i), Xe(se.CodeMark, r + 1 - i, r + 1)]));
      } else o = 0;
    return -1;
  },
  HTMLTag(t, e, n) {
    if (e != 60 || n == t.end - 1) return -1;
    let r = t.slice(n + 1, t.end),
      i =
        /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(
          r
        );
    if (i)
      return t.append(
        Xe(se.Autolink, n, n + 1 + i[0].length, [
          Xe(se.LinkMark, n, n + 1),
          Xe(se.URL, n + 1, n + i[0].length),
          Xe(se.LinkMark, n + i[0].length, n + 1 + i[0].length),
        ])
      );
    let o = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(r);
    if (o) return t.append(Xe(se.Comment, n, n + 1 + o[0].length));
    let s = /^\?[^]*?\?>/.exec(r);
    if (s) return t.append(Xe(se.ProcessingInstruction, n, n + 1 + s[0].length));
    let l =
      /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(
        r
      );
    return l ? t.append(Xe(se.HTMLTag, n, n + 1 + l[0].length)) : -1;
  },
  Emphasis(t, e, n) {
    if (e != 95 && e != 42) return -1;
    let r = n + 1;
    for (; t.char(r) == e; ) r++;
    let i = t.slice(n - 1, n),
      o = t.slice(r, r + 1),
      s = Zu.test(i),
      l = Zu.test(o),
      a = /\s|^$/.test(i),
      c = /\s|^$/.test(o),
      u = !c && (!l || a || s),
      h = !a && (!s || c || l),
      d = u && (e == 42 || !h || s),
      f = h && (e == 42 || !u || l);
    return t.append(new ur(e == 95 ? mI : gI, n, r, (d ? 1 : 0) | (f ? 2 : 0)));
  },
  HardBreak(t, e, n) {
    if (e == 92 && t.char(n + 1) == 10) return t.append(Xe(se.HardBreak, n, n + 2));
    if (e == 32) {
      let r = n + 1;
      for (; t.char(r) == 32; ) r++;
      if (t.char(r) == 10 && r >= n + 2) return t.append(Xe(se.HardBreak, n, r + 1));
    }
    return -1;
  },
  Link(t, e, n) {
    return e == 91 ? t.append(new ur(pl, n, n + 1, 1)) : -1;
  },
  Image(t, e, n) {
    return e == 33 && t.char(n + 1) == 91 ? t.append(new ur(Bv, n, n + 2, 1)) : -1;
  },
  LinkEnd(t, e, n) {
    if (e != 93) return -1;
    for (let r = t.parts.length - 1; r >= 0; r--) {
      let i = t.parts[r];
      if (i instanceof ur && (i.type == pl || i.type == Bv)) {
        if (!i.side || (t.skipSpace(i.to) == n && !/[(\[]/.test(t.slice(n + 1, n + 2)))) return (t.parts[r] = null), -1;
        let o = t.takeContent(r),
          s = (t.parts[r] = epe(t, o, i.type == pl ? se.Link : se.Image, i.from, n + 1));
        if (i.type == pl)
          for (let l = 0; l < r; l++) {
            let a = t.parts[l];
            a instanceof ur && a.type == pl && (a.side = 0);
          }
        return s.to;
      }
    }
    return -1;
  },
};
function epe(t, e, n, r, i) {
  let { text: o } = t,
    s = t.char(i),
    l = i;
  if ((e.unshift(Xe(se.LinkMark, r, r + (n == se.Image ? 2 : 1))), e.push(Xe(se.LinkMark, i - 1, i)), s == 40)) {
    let a = t.skipSpace(i + 1),
      c = OI(o, a - t.offset, t.offset),
      u;
    c && ((a = t.skipSpace(c.to)), a != c.to && ((u = vI(o, a - t.offset, t.offset)), u && (a = t.skipSpace(u.to)))),
      t.char(a) == 41 && (e.push(Xe(se.LinkMark, i, i + 1)), (l = a + 1), c && e.push(c), u && e.push(u), e.push(Xe(se.LinkMark, a, l)));
  } else if (s == 91) {
    let a = bI(o, i - t.offset, t.offset, !1);
    a && (e.push(a), (l = a.to));
  }
  return Xe(n, r, l, e);
}
function OI(t, e, n) {
  if (t.charCodeAt(e) == 60) {
    for (let i = e + 1; i < t.length; i++) {
      let o = t.charCodeAt(i);
      if (o == 62) return Xe(se.URL, e + n, i + 1 + n);
      if (o == 60 || o == 10) return !1;
    }
    return null;
  } else {
    let i = 0,
      o = e;
    for (let s = !1; o < t.length; o++) {
      let l = t.charCodeAt(o);
      if (yr(l)) break;
      if (s) s = !1;
      else if (l == 40) i++;
      else if (l == 41) {
        if (!i) break;
        i--;
      } else l == 92 && (s = !0);
    }
    return o > e ? Xe(se.URL, e + n, o + n) : o == t.length ? null : !1;
  }
}
function vI(t, e, n) {
  let r = t.charCodeAt(e);
  if (r != 39 && r != 34 && r != 40) return !1;
  let i = r == 40 ? 41 : r;
  for (let o = e + 1, s = !1; o < t.length; o++) {
    let l = t.charCodeAt(o);
    if (s) s = !1;
    else {
      if (l == i) return Xe(se.LinkTitle, e + n, o + 1 + n);
      l == 92 && (s = !0);
    }
  }
  return null;
}
function bI(t, e, n, r) {
  for (let i = !1, o = e + 1, s = Math.min(t.length, o + 999); o < s; o++) {
    let l = t.charCodeAt(o);
    if (i) i = !1;
    else {
      if (l == 93) return r ? !1 : Xe(se.LinkLabel, e + n, o + 1 + n);
      if ((r && !yr(l) && (r = !1), l == 91)) return !1;
      l == 92 && (i = !0);
    }
  }
  return null;
}
class tpe {
  constructor(e, n, r) {
    (this.parser = e), (this.text = n), (this.offset = r), (this.parts = []);
  }
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  get end() {
    return this.offset + this.text.length;
  }
  slice(e, n) {
    return this.text.slice(e - this.offset, n - this.offset);
  }
  append(e) {
    return this.parts.push(e), e.to;
  }
  addDelimiter(e, n, r, i, o) {
    return this.append(new ur(e, n, r, (i ? 1 : 0) | (o ? 2 : 0)));
  }
  get hasOpenLink() {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let n = this.parts[e];
      if (n instanceof ur && (n.type == pl || n.type == Bv)) return !0;
    }
    return !1;
  }
  addElement(e) {
    return this.append(e);
  }
  resolveMarkers(e) {
    for (let r = e; r < this.parts.length; r++) {
      let i = this.parts[r];
      if (!(i instanceof ur && i.type.resolve && i.side & 2)) continue;
      let o = i.type == mI || i.type == gI,
        s = i.to - i.from,
        l,
        a = r - 1;
      for (; a >= e; a--) {
        let m = this.parts[a];
        if (
          m instanceof ur &&
          m.side & 1 &&
          m.type == i.type &&
          !(o && (i.side & 1 || m.side & 2) && (m.to - m.from + s) % 3 == 0 && ((m.to - m.from) % 3 || s % 3))
        ) {
          l = m;
          break;
        }
      }
      if (!l) continue;
      let c = i.type.resolve,
        u = [],
        h = l.from,
        d = i.to;
      if (o) {
        let m = Math.min(2, l.to - l.from, s);
        (h = l.to - m), (d = i.from + m), (c = m == 1 ? "Emphasis" : "StrongEmphasis");
      }
      l.type.mark && u.push(this.elt(l.type.mark, h, l.to));
      for (let m = a + 1; m < r; m++) this.parts[m] instanceof ju && u.push(this.parts[m]), (this.parts[m] = null);
      i.type.mark && u.push(this.elt(i.type.mark, i.from, d));
      let f = this.elt(c, h, d, u);
      (this.parts[a] = o && l.from != h ? new ur(l.type, l.from, h, l.side) : null),
        (this.parts[r] = o && i.to != d ? new ur(i.type, d, i.to, i.side) : null) ? this.parts.splice(r, 0, f) : (this.parts[r] = f);
    }
    let n = [];
    for (let r = e; r < this.parts.length; r++) {
      let i = this.parts[r];
      i instanceof ju && n.push(i);
    }
    return n;
  }
  findOpeningDelimiter(e) {
    for (let n = this.parts.length - 1; n >= 0; n--) {
      let r = this.parts[n];
      if (r instanceof ur && r.type == e) return n;
    }
    return null;
  }
  takeContent(e) {
    let n = this.resolveMarkers(e);
    return (this.parts.length = e), n;
  }
  skipSpace(e) {
    return Hc(this.text, e - this.offset) + this.offset;
  }
  elt(e, n, r, i) {
    return typeof e == "string" ? Xe(this.parser.getNodeType(e), n, r, i) : new pI(e, n);
  }
}
function Vv(t, e) {
  if (!e.length) return t;
  if (!t.length) return e;
  let n = t.slice(),
    r = 0;
  for (let i of e) {
    for (; r < n.length && n[r].to < i.to; ) r++;
    if (r < n.length && n[r].from < i.from) {
      let o = n[r];
      o instanceof ju && (n[r] = new ju(o.type, o.from, o.to, Vv(o.children, [i])));
    } else n.splice(r++, 0, i);
  }
  return n;
}
const npe = [se.CodeBlock, se.ListItem, se.OrderedList, se.BulletList];
class rpe {
  constructor(e, n) {
    (this.fragments = e),
      (this.input = n),
      (this.i = 0),
      (this.fragment = null),
      (this.fragmentEnd = -1),
      (this.cursor = null),
      e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    (this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null), (this.cursor = null), (this.fragmentEnd = -1);
  }
  moveTo(e, n) {
    for (; this.fragment && this.fragment.to <= e; ) this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0)) return !1;
    if (this.fragmentEnd < 0) {
      let o = this.fragment.to;
      for (
        ;
        o > 0 &&
        this.input.read(o - 1, o) !=
          `
`;

      )
        o--;
      this.fragmentEnd = o ? o - 1 : 0;
    }
    let r = this.cursor;
    r || ((r = this.cursor = this.fragment.tree.cursor()), r.firstChild());
    let i = e + this.fragment.offset;
    for (; r.to <= i; ) if (!r.parent()) return !1;
    for (;;) {
      if (r.from >= i) return this.fragment.from <= n;
      if (!r.childAfter(i)) return !1;
    }
  }
  matches(e) {
    let n = this.cursor.tree;
    return n && n.prop(Ae.contextHash) == e;
  }
  takeNodes(e) {
    let n = this.cursor,
      r = this.fragment.offset,
      i = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0),
      o = e.absoluteLineStart,
      s = o,
      l = e.block.children.length,
      a = s,
      c = l;
    for (;;) {
      if (n.to - r > i) {
        if (n.type.isAnonymous && n.firstChild()) continue;
        break;
      }
      let u = xI(n.from - r, e.ranges);
      if (n.to - r <= e.ranges[e.rangeI].to) e.addNode(n.tree, u);
      else {
        let h = new Ve(e.parser.nodeSet.types[se.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(h, n.tree), e.addNode(h, u);
      }
      if (
        (n.type.is("Block") &&
          (npe.indexOf(n.type.id) < 0
            ? ((s = n.to - r), (l = e.block.children.length))
            : ((s = a), (l = c), (a = n.to - r), (c = e.block.children.length))),
        !n.nextSibling())
      )
        break;
    }
    for (; e.block.children.length > l; ) e.block.children.pop(), e.block.positions.pop();
    return s - o;
  }
}
function xI(t, e) {
  let n = t;
  for (let r = 1; r < e.length; r++) {
    let i = e[r - 1].to,
      o = e[r].from;
    i < t && (n -= o - i);
  }
  return n;
}
const ipe = Fa({
    "Blockquote/...": $.quote,
    HorizontalRule: $.contentSeparator,
    "ATXHeading1/... SetextHeading1/...": $.heading1,
    "ATXHeading2/... SetextHeading2/...": $.heading2,
    "ATXHeading3/...": $.heading3,
    "ATXHeading4/...": $.heading4,
    "ATXHeading5/...": $.heading5,
    "ATXHeading6/...": $.heading6,
    "Comment CommentBlock": $.comment,
    Escape: $.escape,
    Entity: $.character,
    "Emphasis/...": $.emphasis,
    "StrongEmphasis/...": $.strong,
    "Link/... Image/...": $.link,
    "OrderedList/... BulletList/...": $.list,
    "BlockQuote/...": $.quote,
    "InlineCode CodeText": $.monospace,
    "URL Autolink": $.url,
    "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": $.processingInstruction,
    "CodeInfo LinkLabel": $.labelName,
    LinkTitle: $.string,
    Paragraph: $.content,
  }),
  ope = new xg(
    new Da(dI).extend(ipe),
    Object.keys(Bd).map((t) => Bd[t]),
    Object.keys(Bd).map((t) => Yfe[t]),
    Object.keys(Bd),
    Gfe,
    nI,
    Object.keys(c0).map((t) => c0[t]),
    Object.keys(c0),
    []
  );
function spe(t, e, n) {
  let r = [];
  for (let i = t.firstChild, o = e; ; i = i.nextSibling) {
    let s = i ? i.from : n;
    if ((s > o && r.push({ from: o, to: s }), !i)) break;
    o = i.to;
  }
  return r;
}
function lpe(t) {
  let { codeParser: e, htmlParser: n } = t;
  return {
    wrap: s4((i, o) => {
      let s = i.type.id;
      if (e && (s == se.CodeBlock || s == se.FencedCode)) {
        let l = "";
        if (s == se.FencedCode) {
          let c = i.node.getChild(se.CodeInfo);
          c && (l = o.read(c.from, c.to));
        }
        let a = e(l);
        if (a) return { parser: a, overlay: (c) => c.type.id == se.CodeText };
      } else if (n && (s == se.HTMLBlock || s == se.HTMLTag)) return { parser: n, overlay: spe(i.node, i.from, i.to) };
      return null;
    }),
  };
}
const ape = { resolve: "Strikethrough", mark: "StrikethroughMark" },
  cpe = {
    defineNodes: [
      { name: "Strikethrough", style: { "Strikethrough/...": $.strikethrough } },
      { name: "StrikethroughMark", style: $.processingInstruction },
    ],
    parseInline: [
      {
        name: "Strikethrough",
        parse(t, e, n) {
          if (e != 126 || t.char(n + 1) != 126 || t.char(n + 2) == 126) return -1;
          let r = t.slice(n - 1, n),
            i = t.slice(n + 2, n + 3),
            o = /\s|^$/.test(r),
            s = /\s|^$/.test(i),
            l = Zu.test(r),
            a = Zu.test(i);
          return t.addDelimiter(ape, n, n + 2, !s && (!a || o || l), !o && (!l || s || a));
        },
        after: "Emphasis",
      },
    ],
  };
function qc(t, e, n = 0, r, i = 0) {
  let o = 0,
    s = !0,
    l = -1,
    a = -1,
    c = !1,
    u = () => {
      r.push(t.elt("TableCell", i + l, i + a, t.parser.parseInline(e.slice(l, a), i + l)));
    };
  for (let h = n; h < e.length; h++) {
    let d = e.charCodeAt(h);
    d == 124 && !c
      ? ((!s || l > -1) && o++, (s = !1), r && (l > -1 && u(), r.push(t.elt("TableDelimiter", h + i, h + i + 1))), (l = a = -1))
      : (c || (d != 32 && d != 9)) && (l < 0 && (l = h), (a = h + 1)),
      (c = !c && d == 92);
  }
  return l > -1 && (o++, r && u()), o;
}
function NE(t, e) {
  for (let n = e; n < t.length; n++) {
    let r = t.charCodeAt(n);
    if (r == 124) return !0;
    r == 92 && n++;
  }
  return !1;
}
const yI = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class QE {
  constructor() {
    this.rows = null;
  }
  nextLine(e, n, r) {
    if (this.rows == null) {
      this.rows = !1;
      let i;
      if ((n.next == 45 || n.next == 58 || n.next == 124) && yI.test((i = n.text.slice(n.pos)))) {
        let o = [];
        qc(e, r.content, 0, o, r.start) == qc(e, i, n.pos) &&
          (this.rows = [
            e.elt("TableHeader", r.start, r.start + r.content.length, o),
            e.elt("TableDelimiter", e.lineStart + n.pos, e.lineStart + n.text.length),
          ]);
      }
    } else if (this.rows) {
      let i = [];
      qc(e, n.text, n.pos, i, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + n.pos, e.lineStart + n.text.length, i));
    }
    return !1;
  }
  finish(e, n) {
    return this.rows ? (e.addLeafElement(n, e.elt("Table", n.start, n.start + n.content.length, this.rows)), !0) : !1;
  }
}
const upe = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": $.heading } },
    "TableRow",
    { name: "TableCell", style: $.content },
    { name: "TableDelimiter", style: $.processingInstruction },
  ],
  parseBlock: [
    {
      name: "Table",
      leaf(t, e) {
        return NE(e.content, 0) ? new QE() : null;
      },
      endLeaf(t, e, n) {
        if (n.parsers.some((i) => i instanceof QE) || !NE(e.text, e.basePos)) return !1;
        let r = t.scanLine(t.absoluteLineEnd + 1).text;
        return yI.test(r) && qc(t, e.text, e.basePos) == qc(t, r, e.basePos);
      },
      before: "SetextHeading",
    },
  ],
};
class hpe {
  nextLine() {
    return !1;
  }
  finish(e, n) {
    return (
      e.addLeafElement(
        n,
        e.elt("Task", n.start, n.start + n.content.length, [
          e.elt("TaskMarker", n.start, n.start + 3),
          ...e.parser.parseInline(n.content.slice(3), n.start + 3),
        ])
      ),
      !0
    );
  }
}
const dpe = {
    defineNodes: [
      { name: "Task", block: !0, style: $.list },
      { name: "TaskMarker", style: $.atom },
    ],
    parseBlock: [
      {
        name: "TaskList",
        leaf(t, e) {
          return /^\[[ xX]\][ \t]/.test(e.content) && t.parentType().name == "ListItem" ? new hpe() : null;
        },
        after: "SetextHeading",
      },
    ],
  },
  DE = /(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy,
  FE = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy,
  fpe = /[\w-]+\.[\w-]+($|\/)/,
  BE = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy,
  VE = /\/[a-zA-Z\d@.]+/gy;
function jE(t, e, n, r) {
  let i = 0;
  for (let o = e; o < n; o++) t[o] == r && i++;
  return i;
}
function ppe(t, e) {
  FE.lastIndex = e;
  let n = FE.exec(t);
  if (!n || fpe.exec(n[0])[0].indexOf("_") > -1) return -1;
  let r = e + n[0].length;
  for (;;) {
    let i = t[r - 1],
      o;
    if (/[?!.,:*_~]/.test(i) || (i == ")" && jE(t, e, r, ")") > jE(t, e, r, "("))) r--;
    else if (i == ";" && (o = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(t.slice(e, r)))) r = e + o.index;
    else break;
  }
  return r;
}
function ZE(t, e) {
  BE.lastIndex = e;
  let n = BE.exec(t);
  if (!n) return -1;
  let r = n[0][n[0].length - 1];
  return r == "_" || r == "-" ? -1 : e + n[0].length - (r == "." ? 1 : 0);
}
const mpe = {
    parseInline: [
      {
        name: "Autolink",
        parse(t, e, n) {
          let r = n - t.offset;
          DE.lastIndex = r;
          let i = DE.exec(t.text),
            o = -1;
          if (!i) return -1;
          if (i[1] || i[2]) {
            if (((o = ppe(t.text, r + i[0].length)), o > -1 && t.hasOpenLink)) {
              let s = /([^\[\]]|\[[^\]]*\])*/.exec(t.text.slice(r, o));
              o = r + s[0].length;
            }
          } else
            i[3]
              ? (o = ZE(t.text, r))
              : ((o = ZE(t.text, r + i[0].length)),
                o > -1 && i[0] == "xmpp:" && ((VE.lastIndex = o), (i = VE.exec(t.text)), i && (o = i.index + i[0].length)));
          return o < 0 ? -1 : (t.addElement(t.elt("URL", n, o + t.offset)), o + t.offset);
        },
      },
    ],
  },
  gpe = [upe, dpe, cpe, mpe];
function wI(t, e, n) {
  return (r, i, o) => {
    if (i != t || r.char(o + 1) == t) return -1;
    let s = [r.elt(n, o, o + 1)];
    for (let l = o + 1; l < r.end; l++) {
      let a = r.char(l);
      if (a == t) return r.addElement(r.elt(e, o, l + 1, s.concat(r.elt(n, l, l + 1))));
      if ((a == 92 && s.push(r.elt("Escape", l, l++ + 2)), yr(a))) break;
    }
    return -1;
  };
}
const Ope = {
    defineNodes: [
      { name: "Superscript", style: $.special($.content) },
      { name: "SuperscriptMark", style: $.processingInstruction },
    ],
    parseInline: [{ name: "Superscript", parse: wI(94, "Superscript", "SuperscriptMark") }],
  },
  vpe = {
    defineNodes: [
      { name: "Subscript", style: $.special($.content) },
      { name: "SubscriptMark", style: $.processingInstruction },
    ],
    parseInline: [{ name: "Subscript", parse: wI(126, "Subscript", "SubscriptMark") }],
  },
  bpe = {
    defineNodes: [{ name: "Emoji", style: $.character }],
    parseInline: [
      {
        name: "Emoji",
        parse(t, e, n) {
          let r;
          return e != 58 || !(r = /^[a-zA-Z_0-9]+:/.exec(t.slice(n + 1, t.end)))
            ? -1
            : t.addElement(t.elt("Emoji", n, n + 1 + r[0].length));
        },
      },
    ],
  },
  SI = eg({ commentTokens: { block: { open: "<!--", close: "-->" } } }),
  kI = new Ae(),
  CI = ope.configure({
    props: [
      Ba.add((t) =>
        !t.is("Block") || t.is("Document") || jv(t) != null || xpe(t) ? void 0 : (e, n) => ({ from: n.doc.lineAt(e.from).to, to: e.to })
      ),
      kI.add(jv),
      Ih.add({ Document: () => null }),
      ko.add({ Document: SI }),
    ],
  });
function jv(t) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(t.name);
  return e ? +e[1] : void 0;
}
function xpe(t) {
  return t.name == "OrderedList" || t.name == "BulletList";
}
function ype(t, e) {
  let n = t;
  for (;;) {
    let r = n.nextSibling,
      i;
    if (!r || ((i = jv(r.type)) != null && i <= e)) break;
    n = r;
  }
  return n.to;
}
const wpe = p4.of((t, e, n) => {
  for (let r = at(t).resolveInner(n, -1); r && !(r.from < e); r = r.parent) {
    let i = r.type.prop(kI);
    if (i == null) continue;
    let o = ype(r, i);
    if (o > n) return { from: n, to: o };
  }
  return null;
});
function cS(t) {
  return new ir(SI, t, [wpe], "markdown");
}
const _I = cS(CI),
  Spe = CI.configure([gpe, vpe, Ope, bpe, { props: [Ba.add({ Table: (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to }) })] }]),
  uS = cS(Spe);
function kpe(t, e) {
  return (n) => {
    if (n && t) {
      let r = null;
      if (((n = /\S*/.exec(n)[0]), typeof t == "function" ? (r = t(n)) : (r = j.matchLanguageName(t, n, !0)), r instanceof j))
        return r.support ? r.support.language.parser : Ds.getSkippingParser(r.load());
      if (r) return r.parser;
    }
    return e ? e.parser : null;
  };
}
class jd {
  constructor(e, n, r, i, o, s, l) {
    (this.node = e), (this.from = n), (this.to = r), (this.spaceBefore = i), (this.spaceAfter = o), (this.type = s), (this.item = l);
  }
  blank(e, n = !0) {
    let r = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; r.length < e; ) r += " ";
      return r;
    } else {
      for (let i = this.to - this.from - r.length - this.spaceAfter.length; i > 0; i--) r += " ";
      return r + (n ? this.spaceAfter : "");
    }
  }
  marker(e, n) {
    let r = this.node.name == "OrderedList" ? String(+TI(this.item, e)[2] + n) : "";
    return this.spaceBefore + r + this.type + this.spaceAfter;
  }
}
function EI(t, e) {
  let n = [];
  for (let i = t; i && i.name != "Document"; i = i.parent)
    (i.name == "ListItem" || i.name == "Blockquote" || i.name == "FencedCode") && n.push(i);
  let r = [];
  for (let i = n.length - 1; i >= 0; i--) {
    let o = n[i],
      s,
      l = e.lineAt(o.from),
      a = o.from - l.from;
    if (o.name == "FencedCode") r.push(new jd(o, a, a, "", "", "", null));
    else if (o.name == "Blockquote" && (s = /^ *>( ?)/.exec(l.text.slice(a)))) r.push(new jd(o, a, a + s[0].length, "", s[1], ">", null));
    else if (o.name == "ListItem" && o.parent.name == "OrderedList" && (s = /^( *)\d+([.)])( *)/.exec(l.text.slice(a)))) {
      let c = s[3],
        u = s[0].length;
      c.length >= 4 && ((c = c.slice(0, c.length - 4)), (u -= 4)), r.push(new jd(o.parent, a, a + u, s[1], c, s[2], o));
    } else if (o.name == "ListItem" && o.parent.name == "BulletList" && (s = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(l.text.slice(a)))) {
      let c = s[4],
        u = s[0].length;
      c.length > 4 && ((c = c.slice(0, c.length - 4)), (u -= 4));
      let h = s[2];
      s[3] && (h += s[3].replace(/[xX]/, " ")), r.push(new jd(o.parent, a, a + u, s[1], c, h, o));
    }
  }
  return r;
}
function TI(t, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(t.from, t.from + 10));
}
function u0(t, e, n, r = 0) {
  for (let i = -1, o = t; ; ) {
    if (o.name == "ListItem") {
      let l = TI(o, e),
        a = +l[2];
      if (i >= 0) {
        if (a != i + 1) return;
        n.push({ from: o.from + l[1].length, to: o.from + l[0].length, insert: String(i + 2 + r) });
      }
      i = a;
    }
    let s = o.nextSibling;
    if (!s) break;
    o = s;
  }
}
function hS(t, e) {
  let n = /^[ \t]*/.exec(t)[0].length;
  if (!n || e.facet(Rh) != "	") return t;
  let r = Nr(t, 4, n),
    i = "";
  for (let o = r; o > 0; ) o >= 4 ? ((i += "	"), (o -= 4)) : ((i += " "), o--);
  return i + t.slice(n);
}
const PI = ({ state: t, dispatch: e }) => {
  let n = at(t),
    { doc: r } = t,
    i = null,
    o = t.changeByRange((s) => {
      if (!s.empty || !uS.isActiveAt(t, s.from)) return (i = { range: s });
      let l = s.from,
        a = r.lineAt(l),
        c = EI(n.resolveInner(l, -1), r);
      for (; c.length && c[c.length - 1].from > l - a.from; ) c.pop();
      if (!c.length) return (i = { range: s });
      let u = c[c.length - 1];
      if (u.to - u.spaceAfter.length > l - a.from) return (i = { range: s });
      let h = l >= u.to - u.spaceAfter.length && !/\S/.test(a.text.slice(u.to));
      if (u.item && h) {
        let O = u.node.firstChild,
          v = u.node.getChild("ListItem", "ListItem");
        if (O.to >= l || (v && v.to < l) || (a.from > 0 && !/[^\s>]/.test(r.lineAt(a.from - 1).text))) {
          let g = c.length > 1 ? c[c.length - 2] : null,
            b,
            x = "";
          g && g.item ? ((b = a.from + g.from), (x = g.marker(r, 1))) : (b = a.from + (g ? g.to : 0));
          let k = [{ from: b, to: l, insert: x }];
          return (
            u.node.name == "OrderedList" && u0(u.item, r, k, -2),
            g && g.node.name == "OrderedList" && u0(g.item, r, k),
            { range: H.cursor(b + x.length), changes: k }
          );
        } else {
          let g = WE(c, t, a);
          return { range: H.cursor(l + g.length + 1), changes: { from: a.from, insert: g + t.lineBreak } };
        }
      }
      if (u.node.name == "Blockquote" && h && a.from) {
        let O = r.lineAt(a.from - 1),
          v = />\s*$/.exec(O.text);
        if (v && v.index == u.from) {
          let g = t.changes([
            { from: O.from + v.index, to: O.to },
            { from: a.from + u.from, to: a.to },
          ]);
          return { range: s.map(g), changes: g };
        }
      }
      let d = [];
      u.node.name == "OrderedList" && u0(u.item, r, d);
      let f = u.item && u.item.from < a.from,
        p = "";
      if (!f || /^[\s\d.)\-+*>]*/.exec(a.text)[0].length >= u.to)
        for (let O = 0, v = c.length - 1; O <= v; O++)
          p += O == v && !f ? c[O].marker(r, 1) : c[O].blank(O < v ? Nr(a.text, 4, c[O + 1].from) - p.length : null);
      let m = l;
      for (; m > a.from && /\s/.test(a.text.charAt(m - a.from - 1)); ) m--;
      return (
        (p = hS(p, t)),
        Cpe(u.node, t.doc) && (p = WE(c, t, a) + t.lineBreak + p),
        d.push({ from: m, to: l, insert: t.lineBreak + p }),
        { range: H.cursor(m + p.length + 1), changes: d }
      );
    });
  return i ? !1 : (e(t.update(o, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function zE(t) {
  return t.name == "QuoteMark" || t.name == "ListMark";
}
function Cpe(t, e) {
  if (t.name != "OrderedList" && t.name != "BulletList") return !1;
  let n = t.firstChild,
    r = t.getChild("ListItem", "ListItem");
  if (!r) return !1;
  let i = e.lineAt(n.to),
    o = e.lineAt(r.from),
    s = /^[\s>]*$/.test(i.text);
  return i.number + (s ? 0 : 1) < o.number;
}
function WE(t, e, n) {
  let r = "";
  for (let i = 0, o = t.length - 2; i <= o; i++) r += t[i].blank(i < o ? Nr(n.text, 4, t[i + 1].from) - r.length : null, i < o);
  return hS(r, e);
}
function _pe(t, e) {
  let n = t.resolveInner(e, -1),
    r = e;
  zE(n) && ((r = n.from), (n = n.parent));
  for (let i; (i = n.childBefore(r)); )
    if (zE(i)) r = i.from;
    else if (i.name == "OrderedList" || i.name == "BulletList") (n = i.lastChild), (r = n.to);
    else break;
  return n;
}
const AI = ({ state: t, dispatch: e }) => {
    let n = at(t),
      r = null,
      i = t.changeByRange((o) => {
        let s = o.from,
          { doc: l } = t;
        if (o.empty && uS.isActiveAt(t, o.from)) {
          let a = l.lineAt(s),
            c = EI(_pe(n, s), l);
          if (c.length) {
            let u = c[c.length - 1],
              h = u.to - u.spaceAfter.length + (u.spaceAfter ? 1 : 0);
            if (s - a.from > h && !/\S/.test(a.text.slice(h, s - a.from)))
              return { range: H.cursor(a.from + h), changes: { from: a.from + h, to: s } };
            if (s - a.from == h && (!u.item || a.from <= u.item.from || !/\S/.test(a.text.slice(0, u.to)))) {
              let d = a.from + u.from;
              if (u.item && u.node.from < u.item.from && /\S/.test(a.text.slice(u.from, u.to))) {
                let f = u.blank(Nr(a.text, 4, u.to) - Nr(a.text, 4, u.from));
                return d == a.from && (f = hS(f, t)), { range: H.cursor(d + f.length), changes: { from: d, to: a.from + u.to, insert: f } };
              }
              if (d < s) return { range: H.cursor(d), changes: { from: d, to: s } };
            }
          }
        }
        return (r = { range: o });
      });
    return r ? !1 : (e(t.update(i, { scrollIntoView: !0, userEvent: "delete" })), !0);
  },
  $I = [
    { key: "Enter", run: PI },
    { key: "Backspace", run: AI },
  ],
  Zv = mw({ matchClosingTags: !1 });
function RI(t = {}) {
  let { codeLanguages: e, defaultCodeLanguage: n, addKeymap: r = !0, base: { parser: i } = _I, completeHTMLTags: o = !0 } = t;
  if (!(i instanceof xg)) throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let s = t.extensions ? [t.extensions] : [],
    l = [Zv.support],
    a;
  n instanceof la ? (l.push(n.support), (a = n.language)) : n && (a = n);
  let c = e || a ? kpe(e, a) : void 0;
  s.push(lpe({ codeParser: c, htmlParser: Zv.language.parser })), r && l.push(zr.high(Qs.of($I)));
  let u = cS(i.configure(s));
  return o && l.push(u.data.of({ autocomplete: Epe })), new la(u, l);
}
function Epe(t) {
  let { state: e, pos: n } = t,
    r = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(n - 25, n));
  if (!r) return null;
  let i = at(e).resolveInner(n, -1);
  for (; i && !i.type.isTop; ) {
    if (
      i.name == "CodeBlock" ||
      i.name == "FencedCode" ||
      i.name == "ProcessingInstructionBlock" ||
      i.name == "CommentBlock" ||
      i.name == "Link" ||
      i.name == "Image"
    )
      return null;
    i = i.parent;
  }
  return { from: n - r[0].length, to: n, options: Tpe(), validFor: /^<[:\-\.\w\u00b7-\uffff]*$/ };
}
let h0 = null;
function Tpe() {
  if (h0) return h0;
  let t = a6(new Hy(Me.create({ extensions: Zv }), 0, !0));
  return (h0 = t ? t.options : []);
}
const Ppe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        commonmarkLanguage: _I,
        deleteMarkupBackward: AI,
        insertNewlineContinueMarkup: PI,
        markdown: RI,
        markdownKeymap: $I,
        markdownLanguage: uS,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  zv = [H6, R6, RI(), Jm(), re.lineWrapping],
  Ape = () => {
    const [t, e, n] = Ye(Ir, Gt, yg),
      r = He(Ts),
      i = He(ql),
      o = S.useRef(null),
      s = S.useCallback(
        (l) => {
          var a;
          if (l !== null) {
            const c = [
              ...n,
              ...zv,
              re.updateListener.of(({ state: u }) => {
                r(u.doc.toString());
              }),
              re.focusChangeEffect.of((u, h) => (h || i(new FocusEvent("blur")), null)),
            ];
            e && c.push(Me.readOnly.of(!0)),
              (l.innerHTML = ""),
              (o.current = new re({ parent: l, state: Me.create({ doc: t, extensions: c }) }));
          } else (a = o.current) == null || a.destroy(), (o.current = null);
        },
        [t, e, r, n, i]
      );
    return S.createElement("div", { ref: s, className: "cm-sourceView mdxeditor-source-editor" });
  };
function XE(t, e) {
  t !== void 0 && t.dispatch({ changes: { from: 0, to: t.state.doc.length, insert: e } });
}
const $pe = () => {
    const t = Oa(),
      [e, n, r, i] = Ye(Ir, zu, Gt, dS),
      o = He(Ts),
      s = S.useRef(null),
      l = S.useRef(null),
      a = mt(yg),
      c = He(ql);
    return (
      S.useEffect(
        () =>
          t.sub(zu, (u) => {
            var h;
            XE((h = l.current) == null ? void 0 : h.a, u);
          }),
        [t]
      ),
      S.useEffect(
        () =>
          t.sub(Ir, (u) => {
            var h;
            XE((h = l.current) == null ? void 0 : h.b, u);
          }),
        [t]
      ),
      S.useEffect(() => {
        const u = r || i,
          h = u
            ? { renderRevertControl: void 0, revertControls: void 0 }
            : {
                renderRevertControl: () => {
                  const d = document.createElement("button");
                  return d.classList.add("cm-merge-revert"), d.appendChild(document.createTextNode("⮕")), d;
                },
                revertControls: "a-to-b",
              };
        return (
          (l.current = new Wfe({
            ...h,
            parent: s.current,
            orientation: "a-b",
            gutter: !0,
            a: { doc: n, extensions: [...a, ...zv, Me.readOnly.of(!0)] },
            b: {
              doc: e,
              extensions: [
                ...a,
                ...zv,
                Me.readOnly.of(u),
                re.updateListener.of(({ state: d }) => {
                  const f = d.doc.toString();
                  o(f);
                }),
                re.focusChangeEffect.of((d, f) => (f || c(new FocusEvent("blur")), null)),
              ],
            },
          })),
          () => {
            var d;
            (d = l.current) == null || d.destroy(), (l.current = null);
          }
        );
      }, [o, a]),
      S.createElement("div", { ref: s, className: "mdxeditor-diff-editor" })
    );
  },
  Rpe = ({ children: t }) => {
    const [e, n] = Ye(Hl, No);
    return S.createElement(
      "div",
      { className: "mdxeditor-diff-source-wrapper" },
      e
        ? S.createElement(
            "div",
            { className: F.markdownParseError },
            S.createElement("p", null, e.error, "."),
            S.createElement("p", null, "You can fix the errors in source mode and switch to rich text mode when you are ready.")
          )
        : null,
      S.createElement(
        "div",
        { className: "mdxeditor-rich-text-editor", style: { display: n === "rich-text" && e == null ? "block" : "none" } },
        t
      ),
      n === "diff" ? S.createElement($pe, null) : null,
      n === "source" ? S.createElement(Ape, null) : null
    );
  },
  zu = we(""),
  yg = we([]),
  dS = we(!1),
  Ipe = Ut({
    update: (t, e) => {
      t.pub(zu, (e == null ? void 0 : e.diffMarkdown) ?? "");
    },
    init(t, e) {
      t.pubIn({
        [zu]: (e == null ? void 0 : e.diffMarkdown) ?? "",
        [yg]: (e == null ? void 0 : e.codeMirrorExtensions) ?? [],
        [pA]: Rpe,
        [dS]: (e == null ? void 0 : e.readOnlyDiff) ?? !1,
        [No]: (e == null ? void 0 : e.viewMode) ?? "rich-text",
      });
    },
  });
var Mpe = { exports: {} };
(function (t) {
  var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */ var n = (function (r) {
    var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,
      o = 0,
      s = {},
      l = {
        manual: r.Prism && r.Prism.manual,
        disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,
        util: {
          encode: function g(b) {
            return b instanceof a
              ? new a(b.type, g(b.content), b.alias)
              : Array.isArray(b)
              ? b.map(g)
              : b
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/\u00a0/g, " ");
          },
          type: function (g) {
            return Object.prototype.toString.call(g).slice(8, -1);
          },
          objId: function (g) {
            return g.__id || Object.defineProperty(g, "__id", { value: ++o }), g.__id;
          },
          clone: function g(b, x) {
            x = x || {};
            var k, w;
            switch (l.util.type(b)) {
              case "Object":
                if (((w = l.util.objId(b)), x[w])) return x[w];
                (k = {}), (x[w] = k);
                for (var y in b) b.hasOwnProperty(y) && (k[y] = g(b[y], x));
                return k;
              case "Array":
                return (
                  (w = l.util.objId(b)),
                  x[w]
                    ? x[w]
                    : ((k = []),
                      (x[w] = k),
                      b.forEach(function (C, P) {
                        k[P] = g(C, x);
                      }),
                      k)
                );
              default:
                return b;
            }
          },
          getLanguage: function (g) {
            for (; g; ) {
              var b = i.exec(g.className);
              if (b) return b[1].toLowerCase();
              g = g.parentElement;
            }
            return "none";
          },
          setLanguage: function (g, b) {
            (g.className = g.className.replace(RegExp(i, "gi"), "")), g.classList.add("language-" + b);
          },
          currentScript: function () {
            if (typeof document > "u") return null;
            if ("currentScript" in document && 1 < 2) return document.currentScript;
            try {
              throw new Error();
            } catch (k) {
              var g = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(k.stack) || [])[1];
              if (g) {
                var b = document.getElementsByTagName("script");
                for (var x in b) if (b[x].src == g) return b[x];
              }
              return null;
            }
          },
          isActive: function (g, b, x) {
            for (var k = "no-" + b; g; ) {
              var w = g.classList;
              if (w.contains(b)) return !0;
              if (w.contains(k)) return !1;
              g = g.parentElement;
            }
            return !!x;
          },
        },
        languages: {
          plain: s,
          plaintext: s,
          text: s,
          txt: s,
          extend: function (g, b) {
            var x = l.util.clone(l.languages[g]);
            for (var k in b) x[k] = b[k];
            return x;
          },
          insertBefore: function (g, b, x, k) {
            k = k || l.languages;
            var w = k[g],
              y = {};
            for (var C in w)
              if (w.hasOwnProperty(C)) {
                if (C == b) for (var P in x) x.hasOwnProperty(P) && (y[P] = x[P]);
                x.hasOwnProperty(C) || (y[C] = w[C]);
              }
            var E = k[g];
            return (
              (k[g] = y),
              l.languages.DFS(l.languages, function (N, L) {
                L === E && N != g && (this[N] = y);
              }),
              y
            );
          },
          DFS: function g(b, x, k, w) {
            w = w || {};
            var y = l.util.objId;
            for (var C in b)
              if (b.hasOwnProperty(C)) {
                x.call(b, C, b[C], k || C);
                var P = b[C],
                  E = l.util.type(P);
                E === "Object" && !w[y(P)]
                  ? ((w[y(P)] = !0), g(P, x, null, w))
                  : E === "Array" && !w[y(P)] && ((w[y(P)] = !0), g(P, x, C, w));
              }
          },
        },
        plugins: {},
        highlightAll: function (g, b) {
          l.highlightAllUnder(document, g, b);
        },
        highlightAllUnder: function (g, b, x) {
          var k = {
            callback: x,
            container: g,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
          };
          l.hooks.run("before-highlightall", k),
            (k.elements = Array.prototype.slice.apply(k.container.querySelectorAll(k.selector))),
            l.hooks.run("before-all-elements-highlight", k);
          for (var w = 0, y; (y = k.elements[w++]); ) l.highlightElement(y, b === !0, k.callback);
        },
        highlightElement: function (g, b, x) {
          var k = l.util.getLanguage(g),
            w = l.languages[k];
          l.util.setLanguage(g, k);
          var y = g.parentElement;
          y && y.nodeName.toLowerCase() === "pre" && l.util.setLanguage(y, k);
          var C = g.textContent,
            P = { element: g, language: k, grammar: w, code: C };
          function E(L) {
            (P.highlightedCode = L),
              l.hooks.run("before-insert", P),
              (P.element.innerHTML = P.highlightedCode),
              l.hooks.run("after-highlight", P),
              l.hooks.run("complete", P),
              x && x.call(P.element);
          }
          if (
            (l.hooks.run("before-sanity-check", P),
            (y = P.element.parentElement),
            y && y.nodeName.toLowerCase() === "pre" && !y.hasAttribute("tabindex") && y.setAttribute("tabindex", "0"),
            !P.code)
          ) {
            l.hooks.run("complete", P), x && x.call(P.element);
            return;
          }
          if ((l.hooks.run("before-highlight", P), !P.grammar)) {
            E(l.util.encode(P.code));
            return;
          }
          if (b && r.Worker) {
            var N = new Worker(l.filename);
            (N.onmessage = function (L) {
              E(L.data);
            }),
              N.postMessage(JSON.stringify({ language: P.language, code: P.code, immediateClose: !0 }));
          } else E(l.highlight(P.code, P.grammar, P.language));
        },
        highlight: function (g, b, x) {
          var k = { code: g, grammar: b, language: x };
          if ((l.hooks.run("before-tokenize", k), !k.grammar)) throw new Error('The language "' + k.language + '" has no grammar.');
          return (
            (k.tokens = l.tokenize(k.code, k.grammar)), l.hooks.run("after-tokenize", k), a.stringify(l.util.encode(k.tokens), k.language)
          );
        },
        tokenize: function (g, b) {
          var x = b.rest;
          if (x) {
            for (var k in x) b[k] = x[k];
            delete b.rest;
          }
          var w = new h();
          return d(w, w.head, g), u(g, w, b, w.head, 0), p(w);
        },
        hooks: {
          all: {},
          add: function (g, b) {
            var x = l.hooks.all;
            (x[g] = x[g] || []), x[g].push(b);
          },
          run: function (g, b) {
            var x = l.hooks.all[g];
            if (!(!x || !x.length)) for (var k = 0, w; (w = x[k++]); ) w(b);
          },
        },
        Token: a,
      };
    r.Prism = l;
    function a(g, b, x, k) {
      (this.type = g), (this.content = b), (this.alias = x), (this.length = (k || "").length | 0);
    }
    a.stringify = function g(b, x) {
      if (typeof b == "string") return b;
      if (Array.isArray(b)) {
        var k = "";
        return (
          b.forEach(function (E) {
            k += g(E, x);
          }),
          k
        );
      }
      var w = { type: b.type, content: g(b.content, x), tag: "span", classes: ["token", b.type], attributes: {}, language: x },
        y = b.alias;
      y && (Array.isArray(y) ? Array.prototype.push.apply(w.classes, y) : w.classes.push(y)), l.hooks.run("wrap", w);
      var C = "";
      for (var P in w.attributes) C += " " + P + '="' + (w.attributes[P] || "").replace(/"/g, "&quot;") + '"';
      return "<" + w.tag + ' class="' + w.classes.join(" ") + '"' + C + ">" + w.content + "</" + w.tag + ">";
    };
    function c(g, b, x, k) {
      g.lastIndex = b;
      var w = g.exec(x);
      if (w && k && w[1]) {
        var y = w[1].length;
        (w.index += y), (w[0] = w[0].slice(y));
      }
      return w;
    }
    function u(g, b, x, k, w, y) {
      for (var C in x)
        if (!(!x.hasOwnProperty(C) || !x[C])) {
          var P = x[C];
          P = Array.isArray(P) ? P : [P];
          for (var E = 0; E < P.length; ++E) {
            if (y && y.cause == C + "," + E) return;
            var N = P[E],
              L = N.inside,
              D = !!N.lookbehind,
              Q = !!N.greedy,
              R = N.alias;
            if (Q && !N.pattern.global) {
              var W = N.pattern.toString().match(/[imsuy]*$/)[0];
              N.pattern = RegExp(N.pattern.source, W + "g");
            }
            for (var B = N.pattern || N, K = k.next, ne = w; K !== b.tail && !(y && ne >= y.reach); ne += K.value.length, K = K.next) {
              var A = K.value;
              if (b.length > g.length) return;
              if (!(A instanceof a)) {
                var V = 1,
                  ie;
                if (Q) {
                  if (((ie = c(B, ne, g, D)), !ie || ie.index >= g.length)) break;
                  var pe = ie.index,
                    M = ie.index + ie[0].length,
                    fe = ne;
                  for (fe += K.value.length; pe >= fe; ) (K = K.next), (fe += K.value.length);
                  if (((fe -= K.value.length), (ne = fe), K.value instanceof a)) continue;
                  for (var Se = K; Se !== b.tail && (fe < M || typeof Se.value == "string"); Se = Se.next) V++, (fe += Se.value.length);
                  V--, (A = g.slice(ne, fe)), (ie.index -= ne);
                } else if (((ie = c(B, 0, A, D)), !ie)) continue;
                var pe = ie.index,
                  Y = ie[0],
                  q = A.slice(0, pe),
                  oe = A.slice(pe + Y.length),
                  ce = ne + A.length;
                y && ce > y.reach && (y.reach = ce);
                var Oe = K.prev;
                q && ((Oe = d(b, Oe, q)), (ne += q.length)), f(b, Oe, V);
                var _e = new a(C, L ? l.tokenize(Y, L) : Y, R, Y);
                if (((K = d(b, Oe, _e)), oe && d(b, K, oe), V > 1)) {
                  var Le = { cause: C + "," + E, reach: ce };
                  u(g, b, x, K.prev, ne, Le), y && Le.reach > y.reach && (y.reach = Le.reach);
                }
              }
            }
          }
        }
    }
    function h() {
      var g = { value: null, prev: null, next: null },
        b = { value: null, prev: g, next: null };
      (g.next = b), (this.head = g), (this.tail = b), (this.length = 0);
    }
    function d(g, b, x) {
      var k = b.next,
        w = { value: x, prev: b, next: k };
      return (b.next = w), (k.prev = w), g.length++, w;
    }
    function f(g, b, x) {
      for (var k = b.next, w = 0; w < x && k !== g.tail; w++) k = k.next;
      (b.next = k), (k.prev = b), (g.length -= w);
    }
    function p(g) {
      for (var b = [], x = g.head.next; x !== g.tail; ) b.push(x.value), (x = x.next);
      return b;
    }
    if (!r.document)
      return (
        r.addEventListener &&
          (l.disableWorkerMessageHandler ||
            r.addEventListener(
              "message",
              function (g) {
                var b = JSON.parse(g.data),
                  x = b.language,
                  k = b.code,
                  w = b.immediateClose;
                r.postMessage(l.highlight(k, l.languages[x], x)), w && r.close();
              },
              !1
            )),
        l
      );
    var m = l.util.currentScript();
    m && ((l.filename = m.src), m.hasAttribute("data-manual") && (l.manual = !0));
    function O() {
      l.manual || l.highlightAll();
    }
    if (!l.manual) {
      var v = document.readyState;
      v === "loading" || (v === "interactive" && m && m.defer)
        ? document.addEventListener("DOMContentLoaded", O)
        : window.requestAnimationFrame
        ? window.requestAnimationFrame(O)
        : window.setTimeout(O, 16);
    }
    return l;
  })(e);
  t.exports && (t.exports = n),
    typeof gS < "u" && (gS.Prism = n),
    (n.languages.markup = {
      comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
      prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
      doctype: {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null },
          string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/,
        },
      },
      cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                { pattern: /^=/, alias: "attr-equals" },
                { pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
              ],
            },
          },
          punctuation: /\/?>/,
          "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
        },
      },
      entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i],
    }),
    (n.languages.markup.tag.inside["attr-value"].inside.entity = n.languages.markup.entity),
    (n.languages.markup.doctype.inside["internal-subset"].inside = n.languages.markup),
    n.hooks.add("wrap", function (r) {
      r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
    }),
    Object.defineProperty(n.languages.markup.tag, "addInlined", {
      value: function (i, o) {
        var s = {};
        (s["language-" + o] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: n.languages[o] }),
          (s.cdata = /^<!\[CDATA\[|\]\]>$/i);
        var l = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: s } };
        l["language-" + o] = { pattern: /[\s\S]+/, inside: n.languages[o] };
        var a = {};
        (a[i] = {
          pattern: RegExp(
            /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
              return i;
            }),
            "i"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: l,
        }),
          n.languages.insertBefore("markup", "cdata", a);
      },
    }),
    Object.defineProperty(n.languages.markup.tag, "addAttribute", {
      value: function (r, i) {
        n.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(/(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [i, "language-" + i],
                  inside: n.languages[i],
                },
                punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/],
              },
            },
          },
        });
      },
    }),
    (n.languages.html = n.languages.markup),
    (n.languages.mathml = n.languages.markup),
    (n.languages.svg = n.languages.markup),
    (n.languages.xml = n.languages.extend("markup", {})),
    (n.languages.ssml = n.languages.xml),
    (n.languages.atom = n.languages.xml),
    (n.languages.rss = n.languages.xml),
    (function (r) {
      var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      (r.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector",
            },
            keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 },
          },
        },
        url: {
          pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + i.source + "$"), alias: "url" } },
        },
        selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"), lookbehind: !0 },
        string: { pattern: i, greedy: !0 },
        property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 },
        important: /!important\b/i,
        function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 },
        punctuation: /[(){};:,]/,
      }),
        (r.languages.css.atrule.inside.rest = r.languages.css);
      var o = r.languages.markup;
      o && (o.tag.addInlined("style", "css"), o.tag.addAttribute("style", "css"));
    })(n),
    (n.languages.clike = {
      comment: [
        { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 },
        { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
      ],
      string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: { punctuation: /[.\\]/ },
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/,
    }),
    (n.languages.javascript = n.languages.extend("clike", {
      "class-name": [
        n.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0,
        },
      ],
      keyword: [
        { pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
        {
          pattern:
            /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0,
        },
      ],
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source +
            "(?:" +
            (/NaN|Infinity/.source +
              "|" +
              /0[bB][01]+(?:_[01]+)*n?/.source +
              "|" +
              /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
              "|" +
              /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
              "|" +
              /\d+(?:_\d+)*n/.source +
              "|" +
              /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) +
            ")" +
            /(?![\w$])/.source
        ),
        lookbehind: !0,
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
    })),
    (n.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/),
    n.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
            /\//.source +
            "(?:" +
            /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
            "|" +
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
              .source +
            ")" +
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: "language-regex", inside: n.languages.regex },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/,
        },
      },
      "function-variable": {
        pattern:
          /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function",
      },
      parameter: [
        {
          pattern:
            /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
        { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: !0, inside: n.languages.javascript },
        {
          pattern:
            /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
    }),
    n.languages.insertBefore("javascript", "string", {
      hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": { pattern: /^`|`$/, alias: "string" },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: n.languages.javascript },
          },
          string: /[\s\S]+/,
        },
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
      },
    }),
    n.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property",
      },
    }),
    n.languages.markup &&
      (n.languages.markup.tag.addInlined("script", "javascript"),
      n.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
          .source,
        "javascript"
      )),
    (n.languages.js = n.languages.javascript),
    (function () {
      if (typeof n > "u" || typeof document > "u") return;
      Element.prototype.matches ||
        (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var r = "Loading…",
        i = function (m, O) {
          return "✖ Error " + m + " while fetching file: " + O;
        },
        o = "✖ Error: File does not exist or is empty",
        s = {
          js: "javascript",
          py: "python",
          rb: "ruby",
          ps1: "powershell",
          psm1: "powershell",
          sh: "bash",
          bat: "batch",
          h: "c",
          tex: "latex",
        },
        l = "data-src-status",
        a = "loading",
        c = "loaded",
        u = "failed",
        h = "pre[data-src]:not([" + l + '="' + c + '"]):not([' + l + '="' + a + '"])';
      function d(m, O, v) {
        var g = new XMLHttpRequest();
        g.open("GET", m, !0),
          (g.onreadystatechange = function () {
            g.readyState == 4 &&
              (g.status < 400 && g.responseText ? O(g.responseText) : g.status >= 400 ? v(i(g.status, g.statusText)) : v(o));
          }),
          g.send(null);
      }
      function f(m) {
        var O = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(m || "");
        if (O) {
          var v = Number(O[1]),
            g = O[2],
            b = O[3];
          return g ? (b ? [v, Number(b)] : [v, void 0]) : [v, v];
        }
      }
      n.hooks.add("before-highlightall", function (m) {
        m.selector += ", " + h;
      }),
        n.hooks.add("before-sanity-check", function (m) {
          var O = m.element;
          if (O.matches(h)) {
            (m.code = ""), O.setAttribute(l, a);
            var v = O.appendChild(document.createElement("CODE"));
            v.textContent = r;
            var g = O.getAttribute("data-src"),
              b = m.language;
            if (b === "none") {
              var x = (/\.(\w+)$/.exec(g) || [, "none"])[1];
              b = s[x] || x;
            }
            n.util.setLanguage(v, b), n.util.setLanguage(O, b);
            var k = n.plugins.autoloader;
            k && k.loadLanguages(b),
              d(
                g,
                function (w) {
                  O.setAttribute(l, c);
                  var y = f(O.getAttribute("data-range"));
                  if (y) {
                    var C = w.split(/\r\n?|\n/g),
                      P = y[0],
                      E = y[1] == null ? C.length : y[1];
                    P < 0 && (P += C.length),
                      (P = Math.max(0, Math.min(P - 1, C.length))),
                      E < 0 && (E += C.length),
                      (E = Math.max(0, Math.min(E, C.length))),
                      (w = C.slice(P, E).join(`
`)),
                      O.hasAttribute("data-start") || O.setAttribute("data-start", String(P + 1));
                  }
                  (v.textContent = w), n.highlightElement(v);
                },
                function (w) {
                  O.setAttribute(l, u), (v.textContent = w);
                }
              );
          }
        }),
        (n.plugins.fileHighlight = {
          highlight: function (O) {
            for (var v = (O || document).querySelectorAll(h), g = 0, b; (b = v[g++]); ) n.highlightElement(b);
          },
        });
      var p = !1;
      n.fileHighlight = function () {
        p || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), (p = !0)),
          n.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
})(Mpe);
Prism.languages.clike = {
  comment: [
    { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
  ],
  string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: !0,
    inside: { punctuation: /[.\\]/ },
  },
  keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: /[{}[\];(),.:]/,
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: !0 },
  ],
  keyword: [
    { pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
    {
      pattern:
        /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: !0,
    },
  ],
  function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  number: {
    pattern: RegExp(
      /(^|[^\w$])/.source +
        "(?:" +
        (/NaN|Infinity/.source +
          "|" +
          /0[bB][01]+(?:_[01]+)*n?/.source +
          "|" +
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
          "|" +
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
          "|" +
          /\d+(?:_\d+)*n/.source +
          "|" +
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) +
        ")" +
        /(?![\w$])/.source
    ),
    lookbehind: !0,
  },
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: RegExp(
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
        /\//.source +
        "(?:" +
        /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
        "|" +
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
          .source +
        ")" +
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: !0,
    greedy: !0,
    inside: {
      "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: "language-regex", inside: Prism.languages.regex },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/,
    },
  },
  "function-variable": {
    pattern:
      /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function",
  },
  parameter: [
    {
      pattern:
        /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
    { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: !0, inside: Prism.languages.javascript },
    {
      pattern:
        /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
});
Prism.languages.insertBefore("javascript", "string", {
  hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: !0,
    inside: {
      "template-punctuation": { pattern: /^`|`$/, alias: "string" },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: !0,
        inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript },
      },
      string: /[\s\S]+/,
    },
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
  },
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: !0,
    alias: "property",
  },
});
Prism.languages.markup &&
  (Prism.languages.markup.tag.addInlined("script", "javascript"),
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
      .source,
    "javascript"
  ));
Prism.languages.js = Prism.languages.javascript;
Prism.languages.markup = {
  comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
  prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
  doctype: {
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: !0,
    inside: {
      "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null },
      string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
      punctuation: /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      name: /[^\s<>'"]+/,
    },
  },
  cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: !0,
    inside: {
      tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          punctuation: [
            { pattern: /^=/, alias: "attr-equals" },
            { pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
          ],
        },
      },
      punctuation: /\/?>/,
      "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
    },
  },
  entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i],
};
Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity;
Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function (t) {
  t.type === "entity" && (t.attributes.title = t.content.replace(/&amp;/, "&"));
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  value: function (e, n) {
    var r = {};
    (r["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: Prism.languages[n] }),
      (r.cdata = /^<!\[CDATA\[|\]\]>$/i);
    var i = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: r } };
    i["language-" + n] = { pattern: /[\s\S]+/, inside: Prism.languages[n] };
    var o = {};
    (o[e] = {
      pattern: RegExp(
        /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
          return e;
        }),
        "i"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: i,
    }),
      Prism.languages.insertBefore("markup", "cdata", o);
  },
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  value: function (t, e) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + t + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: !0,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            value: {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: !0,
              alias: [e, "language-" + e],
              inside: Prism.languages[e],
            },
            punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/],
          },
        },
      },
    });
  },
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function (t) {
  var e = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n(u) {
    return (
      (u = u.replace(/<inner>/g, function () {
        return e;
      })),
      RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + u + ")")
    );
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source,
    i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () {
      return r;
    }),
    o = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  (t.languages.markdown = t.languages.extend("markup", {})),
    t.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: t.languages.yaml },
        },
      },
      blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" },
      table: {
        pattern: RegExp("^" + i + o + "(?:" + i + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + i + o + ")(?:" + i + ")*$"),
            lookbehind: !0,
            inside: { "table-data": { pattern: RegExp(r), inside: t.languages.markdown }, punctuation: /\|/ },
          },
          "table-line": { pattern: RegExp("^(" + i + ")" + o + "$"), lookbehind: !0, inside: { punctuation: /\||:?-{3,}:?/ } },
          "table-header-row": {
            pattern: RegExp("^" + i + "$"),
            inside: { "table-header": { pattern: RegExp(r), alias: "important", inside: t.languages.markdown }, punctuation: /\|/ },
          },
        },
      },
      code: [
        {
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword",
        },
        {
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: !0 },
            "code-language": { pattern: /^(```).+/, lookbehind: !0 },
            punctuation: /```/,
          },
        },
      ],
      title: [
        { pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } },
        { pattern: /(^\s*)#.+/m, lookbehind: !0, alias: "important", inside: { punctuation: /^#+|#+$/ } },
      ],
      hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: !0, alias: "punctuation" },
      list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: !0, alias: "punctuation" },
      "url-reference": {
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/,
        },
        alias: "url",
      },
      bold: {
        pattern: n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: !0, inside: {} }, punctuation: /\*\*|__/ },
      },
      italic: {
        pattern: n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: !0, inside: {} }, punctuation: /[*_]/ },
      },
      strike: {
        pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: !0, inside: {} }, punctuation: /~~?/ },
      },
      "code-snippet": {
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"],
      },
      url: {
        pattern: n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: !0, inside: {} },
          variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: !0 },
          url: { pattern: /(^\]\()[^\s)]+/, lookbehind: !0 },
          string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: !0 },
        },
      },
    }),
    ["url", "bold", "italic", "strike"].forEach(function (u) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function (h) {
        u !== h && (t.languages.markdown[u].inside.content.inside[h] = t.languages.markdown[h]);
      });
    }),
    t.hooks.add("after-tokenize", function (u) {
      if (u.language !== "markdown" && u.language !== "md") return;
      function h(d) {
        if (!(!d || typeof d == "string"))
          for (var f = 0, p = d.length; f < p; f++) {
            var m = d[f];
            if (m.type !== "code") {
              h(m.content);
              continue;
            }
            var O = m.content[1],
              v = m.content[3];
            if (O && v && O.type === "code-language" && v.type === "code-block" && typeof O.content == "string") {
              var g = O.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              g = (/[a-z][\w-]*/i.exec(g) || [""])[0].toLowerCase();
              var b = "language-" + g;
              v.alias ? (typeof v.alias == "string" ? (v.alias = [v.alias, b]) : v.alias.push(b)) : (v.alias = [b]);
            }
          }
      }
      h(u.tokens);
    }),
    t.hooks.add("wrap", function (u) {
      if (u.type === "code-block") {
        for (var h = "", d = 0, f = u.classes.length; d < f; d++) {
          var p = u.classes[d],
            m = /language-(.+)/.exec(p);
          if (m) {
            h = m[1];
            break;
          }
        }
        var O = t.languages[h];
        if (O) u.content = t.highlight(c(u.content), O, h);
        else if (h && h !== "none" && t.plugins.autoloader) {
          var v = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
          (u.attributes.id = v),
            t.plugins.autoloader.loadLanguages(h, function () {
              var g = document.getElementById(v);
              g && (g.innerHTML = t.highlight(g.textContent, t.languages[h], h));
            });
        }
      }
    });
  var s = RegExp(t.languages.markup.tag.pattern.source, "gi"),
    l = { amp: "&", lt: "<", gt: ">", quot: '"' },
    a = String.fromCodePoint || String.fromCharCode;
  function c(u) {
    var h = u.replace(s, "");
    return (
      (h = h.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (d, f) {
        if (((f = f.toLowerCase()), f[0] === "#")) {
          var p;
          return f[1] === "x" ? (p = parseInt(f.slice(2), 16)) : (p = Number(f.slice(1))), a(p);
        } else {
          var m = l[f];
          return m || d;
        }
      })),
      h
    );
  }
  t.languages.md = t.languages.markdown;
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 },
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
  "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: !0 },
  keyword:
    /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/,
});
Prism.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: !0 } });
Prism.languages.insertBefore("c", "string", {
  macro: {
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
    inside: {
      string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: !0 }, Prism.languages.c.string],
      char: Prism.languages.c.char,
      comment: Prism.languages.c.comment,
      "macro-name": [
        { pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: !0 },
        { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: !0, alias: "function" },
      ],
      directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: !0, alias: "keyword" },
      "directive-hash": /^#/,
      punctuation: /##|\\(?=[\r\n])/,
      expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c },
    },
  },
});
Prism.languages.insertBefore("c", "function", {
  constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/,
});
delete Prism.languages.c.boolean;
(function (t) {
  var e = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  (t.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + e.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        rule: /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: !0,
          alias: "selector",
        },
        keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 },
      },
    },
    url: {
      pattern: RegExp("\\burl\\((?:" + e.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: !0,
      inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + e.source + "$"), alias: "url" } },
    },
    selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + e.source + ")*(?=\\s*\\{)"), lookbehind: !0 },
    string: { pattern: e, greedy: !0 },
    property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 },
    important: /!important\b/i,
    function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 },
    punctuation: /[(){};:,]/,
  }),
    (t.languages.css.atrule.inside.rest = t.languages.css);
  var n = t.languages.markup;
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
  keyword:
    /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/,
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
Prism.languages.sql = {
  comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: !0 },
  variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: !0 }, /@[\w.$]+/],
  string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: !0, lookbehind: !0 },
  identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: !0, lookbehind: !0, inside: { punctuation: /^`|`$/ } },
  function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  keyword:
    /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  punctuation: /[;[\]()`,.]/,
};
(function (t) {
  var e = (t.languages.powershell = {
    comment: [
      { pattern: /(^|[^`])<#[\s\S]*?#>/, lookbehind: !0 },
      { pattern: /(^|[^`])#.*/, lookbehind: !0 },
    ],
    string: [
      { pattern: /"(?:`[\s\S]|[^`"])*"/, greedy: !0, inside: null },
      { pattern: /'(?:[^']|'')*'/, greedy: !0 },
    ],
    namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    boolean: /\$(?:false|true)\b/i,
    variable: /\$\w+\b/,
    function: [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i,
    ],
    keyword:
      /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    operator: {
      pattern:
        /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: !0,
    },
    punctuation: /[|{}[\];(),.]/,
  });
  e.string[0].inside = {
    function: { pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/, lookbehind: !0, inside: e },
    boolean: e.boolean,
    variable: e.variable,
  };
})(Prism);
Prism.languages.python = {
  comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0, greedy: !0 },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: !0,
    inside: {
      interpolation: {
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: !0,
        inside: {
          "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: !0 },
          "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" },
          rest: null,
        },
      },
      string: /[\s\S]+/,
    },
  },
  "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: !0, alias: "string" },
  string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: !0 },
  function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: !0 },
  "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: !0 },
  decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: !0, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } },
  keyword:
    /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  builtin:
    /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  boolean: /\b(?:False|None|True)\b/,
  number:
    /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/,
};
Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function (t) {
  for (var e = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0; n < 2; n++)
    e = e.replace(/<self>/g, function () {
      return e;
    });
  (e = e.replace(/<self>/g, function () {
    return /[^\s\S]/.source;
  })),
    (t.languages.rust = {
      comment: [
        { pattern: RegExp(/(^|[^\\])/.source + e), lookbehind: !0, greedy: !0 },
        { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
      ],
      string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: !0 },
      char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: !0 },
      attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: !0, alias: "attr-name", inside: { string: null } },
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null },
      },
      "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" },
      "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: !0, alias: "punctuation" },
      variable: /\$\w+/,
      "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: !0, alias: "function" },
      "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: !0, alias: "class-name" },
      "module-declaration": [
        { pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: !0, alias: "namespace" },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: { punctuation: /::/ },
        },
      ],
      keyword: [
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/,
      ],
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: { pattern: /\b\w+!/, alias: "property" },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } },
      number:
        /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/,
    }),
    (t.languages.rust["closure-params"].inside.rest = t.languages.rust),
    (t.languages.rust.attribute.inside.string = t.languages.rust.string);
})(Prism);
Prism.languages.swift = {
  comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: !0, greedy: !0 },
  "string-literal": [
    {
      pattern: RegExp(
        /(^|[^"#])/.source +
          "(?:" +
          /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source +
          "|" +
          /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source +
          ")" +
          /(?!["#])/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null },
        "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" },
        punctuation: /\\(?=[\r\n])/,
        string: /[\s\S]+/,
      },
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source +
          "(?:" +
          /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source +
          "|" +
          /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source +
          ")\\2"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null },
        "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" },
        string: /[\s\S]+/,
      },
    },
  ],
  directive: {
    pattern: RegExp(
      /#/.source +
        "(?:" +
        (/(?:elseif|if)\b/.source +
          "(?:[ 	]*" +
          /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source +
          ")+") +
        "|" +
        /(?:else|endif)\b/.source +
        ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      boolean: /\b(?:false|true)\b/,
      number: /\b\d+(?:\.\d+)*\b/,
      operator: /!|&&|\|\||[<>]=?/,
      punctuation: /[(),]/,
    },
  },
  literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" },
  "other-directive": { pattern: /#\w+\b/, alias: "property" },
  attribute: { pattern: /@\w+/, alias: "atrule" },
  "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: !0, alias: "function" },
  label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: !0, alias: "important" },
  keyword:
    /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  boolean: /\b(?:false|true)\b/,
  nil: { pattern: /\bnil\b/, alias: "constant" },
  "short-argument": /\$\d+\b/,
  omit: { pattern: /\b_\b/, alias: "keyword" },
  number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  punctuation: /[{}[\]();,.:\\]/,
};
Prism.languages.swift["string-literal"].forEach(function (t) {
  t.inside.interpolation.inside = Prism.languages.swift;
});
(function (t) {
  (t.languages.typescript = t.languages.extend("javascript", {
    "class-name": {
      pattern:
        /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null,
    },
    builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
  })),
    t.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      /\btype\b(?=\s*(?:[\{*]|$))/
    ),
    delete t.languages.typescript.parameter,
    delete t.languages.typescript["literal-property"];
  var e = t.languages.extend("typescript", {});
  delete e["class-name"],
    (t.languages.typescript["class-name"].inside = e),
    t.languages.insertBefore("typescript", "function", {
      decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } },
      "generic-function": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e },
        },
      },
    }),
    (t.languages.ts = t.languages.typescript);
})(Prism);
(function (t) {
  var e =
      /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,
    n = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source,
    r = {
      pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: { namespace: { pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/, inside: { punctuation: /\./ } }, punctuation: /\./ },
    };
  (t.languages.java = t.languages.extend("clike", {
    string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/, lookbehind: !0, greedy: !0 },
    "class-name": [
      r,
      {
        pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: !0,
        inside: r.inside,
      },
      {
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + n + /[A-Z]\w*\b/.source),
        lookbehind: !0,
        inside: r.inside,
      },
    ],
    keyword: e,
    function: [t.languages.clike.function, { pattern: /(::\s*)[a-z_]\w*/, lookbehind: !0 }],
    number:
      /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    operator: { pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m, lookbehind: !0 },
    constant: /\b[A-Z][A-Z_\d]+\b/,
  })),
    t.languages.insertBefore("java", "string", {
      "triple-quoted-string": { pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/, greedy: !0, alias: "string" },
      char: { pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/, greedy: !0 },
    }),
    t.languages.insertBefore("java", "class-name", {
      annotation: { pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/, lookbehind: !0, alias: "punctuation" },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: { "class-name": r, keyword: e, punctuation: /[<>(),.:]/, operator: /[?&|]/ },
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + n + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: { namespace: r.inside.namespace, punctuation: /\./, operator: /\*/, "class-name": /\w+/ },
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + n + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: { namespace: r.inside.namespace, static: /\b\w+$/, punctuation: /\./, operator: /\*/, "class-name": /\w+/ },
        },
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
            /<keyword>/g,
            function () {
              return e.source;
            }
          )
        ),
        lookbehind: !0,
        inside: { punctuation: /\./ },
      },
    });
})(Prism);
(function (t) {
  var e =
      /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
    n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function () {
      return e.source;
    });
  (t.languages.cpp = t.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(
          /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function () {
            return e.source;
          })
        ),
        lookbehind: !0,
      },
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/,
    ],
    keyword: e,
    number: {
      pattern:
        /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: !0,
    },
    operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    boolean: /\b(?:false|true)\b/,
  })),
    t.languages.insertBefore("cpp", "string", {
      module: {
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source +
            "(?:" +
            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source +
            "|" +
            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function () {
              return n;
            }) +
            ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ },
      },
      "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: !0 },
    }),
    t.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: t.languages.cpp } },
      },
    }),
    t.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }),
    t.languages.insertBefore("cpp", "class-name", {
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: t.languages.extend("cpp", {}),
      },
    }),
    t.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, t.languages.cpp["base-clause"]);
})(Prism);
function Lpe(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
Lpe(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
const UE = (t) => {
  try {
    return !!t && window.Prism.languages.hasOwnProperty(t);
  } catch {
    return !1;
  }
};
function II(t, e) {
  for (const n of t.childNodes) {
    if ($r(n) && n.tagName === e) return !0;
    II(n, e);
  }
  return !1;
}
const Rc = "data-language",
  Zd = "data-highlight-language";
class Vh extends Vr {
  static getType() {
    return "code";
  }
  static clone(e) {
    return new Vh(e.__language, e.__key);
  }
  constructor(e, n) {
    super(n), (this.__language = e), (this.__isSyntaxHighlightSupported = UE(e));
  }
  createDOM(e) {
    const n = document.createElement("code");
    Rr(n, e.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Rc, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(Zd, r)), n;
  }
  updateDOM(e, n, r) {
    const i = this.__language,
      o = e.__language;
    return (
      i
        ? i !== o && (n.setAttribute(Rc, i), this.__isSyntaxHighlightSupported && n.setAttribute(Zd, i))
        : o && (n.removeAttribute(Rc), e.__isSyntaxHighlightSupported && n.removeAttribute(Zd)),
      !1
    );
  }
  exportDOM(e) {
    const n = document.createElement("pre");
    Rr(n, e._config.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Rc, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(Zd, r)), { element: n };
  }
  static importDOM() {
    return {
      code: (e) => (e.textContent != null && (/\r?\n/.test(e.textContent) || II(e, "BR")) ? { conversion: HE, priority: 1 } : null),
      div: () => ({ conversion: Npe, priority: 1 }),
      pre: () => ({ conversion: HE, priority: 0 }),
      table: (e) => (d0(e) ? { conversion: Qpe, priority: 3 } : null),
      td: (e) => {
        const n = e,
          r = n.closest("table");
        return n.classList.contains("js-file-line") || (r && d0(r)) ? { conversion: qE, priority: 3 } : null;
      },
      tr: (e) => {
        const n = e.closest("table");
        return n && d0(n) ? { conversion: qE, priority: 3 } : null;
      },
    };
  }
  static importJSON(e) {
    const n = Ua(e.language);
    return n.setFormat(e.format), n.setIndent(e.indent), n.setDirection(e.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
  }
  insertNewAfter(e, n = !0) {
    const r = this.getChildren(),
      i = r.length;
    if (
      i >= 2 &&
      r[i - 1].getTextContent() ===
        `
` &&
      r[i - 2].getTextContent() ===
        `
` &&
      e.isCollapsed() &&
      e.anchor.key === this.__key &&
      e.anchor.offset === i
    ) {
      r[i - 1].remove(), r[i - 2].remove();
      const a = tt();
      return this.insertAfter(a, n), a;
    }
    const { anchor: o, focus: s } = e,
      l = (o.isBefore(s) ? o : s).getNode();
    if (te(l)) {
      let a = Dpe(l);
      const c = [];
      for (;;)
        if (Ab(a)) c.push(xa()), (a = a.getNextSibling());
        else {
          if (!LI(a)) break;
          {
            let O = 0;
            const v = a.getTextContent(),
              g = a.getTextContentSize();
            for (; O < g && v[O] === " "; ) O++;
            if ((O !== 0 && c.push(MI(" ".repeat(O))), O !== g)) break;
            a = a.getNextSibling();
          }
        }
      const u = l.splitText(o.offset)[0],
        h = o.offset === 0 ? 0 : 1,
        d = u.getIndexWithinParent() + h,
        f = l.getParentOrThrow(),
        p = [gi(), ...c];
      f.splice(d, 0, p);
      const m = c[c.length - 1];
      m ? m.select() : o.offset === 0 ? u.selectPrevious() : u.getNextSibling().selectNext(0, 0);
    }
    if (fS(l)) {
      const { offset: a } = e.anchor;
      l.splice(a, 0, [gi()]), l.select(a + 1, a + 1);
    }
    return null;
  }
  canIndent() {
    return !1;
  }
  collapseAtStart() {
    const e = tt();
    return this.getChildren().forEach((n) => e.append(n)), this.replace(e), !0;
  }
  setLanguage(e) {
    const n = this.getWritable();
    (n.__language = e), (n.__isSyntaxHighlightSupported = UE(e));
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
}
function Ua(t) {
  return Mn(new Vh(t));
}
function fS(t) {
  return t instanceof Vh;
}
function HE(t) {
  return { node: Ua(t.getAttribute(Rc)) };
}
function Npe(t) {
  const e = t,
    n = YE(e);
  return n ||
    (function (r) {
      let i = r.parentElement;
      for (; i !== null; ) {
        if (YE(i)) return !0;
        i = i.parentElement;
      }
      return !1;
    })(e)
    ? { node: n ? Ua() : null }
    : { node: null };
}
function Qpe() {
  return { node: Ua() };
}
function qE() {
  return { node: null };
}
function YE(t) {
  return t.style.fontFamily.match("monospace") !== null;
}
function d0(t) {
  return t.classList.contains("js-file-line-container");
}
class wg extends Ki {
  constructor(e, n, r) {
    super(e, r), (this.__highlightType = n);
  }
  static getType() {
    return "code-highlight";
  }
  static clone(e) {
    return new wg(e.__text, e.__highlightType || void 0, e.__key);
  }
  getHighlightType() {
    return this.getLatest().__highlightType;
  }
  canHaveFormat() {
    return !1;
  }
  createDOM(e) {
    const n = super.createDOM(e),
      r = f0(e.theme, this.__highlightType);
    return Rr(n, r), n;
  }
  updateDOM(e, n, r) {
    const i = super.updateDOM(e, n, r),
      o = f0(r.theme, e.__highlightType),
      s = f0(r.theme, this.__highlightType);
    return o !== s && (o && cm(n, o), s && Rr(n, s)), i;
  }
  static importJSON(e) {
    const n = MI(e.text, e.highlightType);
    return n.setFormat(e.format), n.setDetail(e.detail), n.setMode(e.mode), n.setStyle(e.style), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
  }
  setFormat(e) {
    return this;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return Ua();
  }
}
function f0(t, e) {
  return e && t && t.codeHighlight && t.codeHighlight[e];
}
function MI(t, e) {
  return Mn(new wg(t, e));
}
function LI(t) {
  return t instanceof wg;
}
function Dpe(t) {
  let e = t,
    n = t;
  for (; LI(n) || Ab(n); ) (e = n), (n = n.getPreviousSibling());
  return e;
}
function Wv(t, e) {
  const n = {};
  for (const r of t) {
    const i = e(r);
    n[i] ? n[i].push(r) : (n[i] = [r]);
  }
  return n;
}
function Fpe(t) {
  const e = Wv(t, (n) => n.type);
  return { element: e.element || [], textFormat: e["text-format"] || [], textMatch: e["text-match"] || [] };
}
const GE = /[!-/:-@[-`{-~\s]/,
  NI = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  Bpe = NI && "documentMode" in document ? document.documentMode : null;
NI && "InputEvent" in window && !Bpe && new window.InputEvent("input");
function Vpe(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var jpe = Vpe(function (t) {
  const e = new URLSearchParams();
  e.append("code", t);
  for (let n = 1; n < arguments.length; n++) e.append("v", arguments[n]);
  throw Error(
    `Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
  );
});
function JE(t, e, n) {
  const r = n.length;
  for (let i = e; i >= r; i--) {
    const o = i - r;
    if (QI(t, o, n, 0, r) && t[o + r] !== " ") return o;
  }
  return -1;
}
function QI(t, e, n, r, i) {
  for (let o = 0; o < i; o++) if (t[e + o] !== n[r + o]) return !1;
  return !0;
}
function Zpe(t, e = GI) {
  const n = Fpe(e),
    r = Wv(n.textFormat, ({ tag: s }) => s[s.length - 1]),
    i = Wv(n.textMatch, ({ trigger: s }) => s);
  for (const s of e) {
    const l = s.type;
    if (l === "element" || l === "text-match") {
      const a = s.dependencies;
      for (const c of a) t.hasNode(c) || jpe(173, c.getType());
    }
  }
  const o = (s, l, a) => {
    (function (c, u, h, d) {
      const f = c.getParent();
      if (!Yt(f) || c.getFirstChild() !== u) return !1;
      const p = u.getTextContent();
      if (p[h - 1] !== " ") return !1;
      for (const { regExp: m, replace: O } of d) {
        const v = p.match(m);
        if (v && v[0].length === h) {
          const g = u.getNextSiblings(),
            [b, x] = u.splitText(h);
          return b.remove(), O(c, x ? [x, ...g] : g, v, !1), !0;
        }
      }
      return !1;
    })(s, l, a, n.element) ||
      (function (c, u, h) {
        let d = c.getTextContent();
        const f = h[d[u - 1]];
        if (f == null) return !1;
        u < d.length && (d = d.slice(0, u));
        for (const p of f) {
          const m = d.match(p.regExp);
          if (m === null) continue;
          const O = m.index || 0,
            v = O + m[0].length;
          let g;
          return O === 0 ? ([g] = c.splitText(v)) : ([, g] = c.splitText(O, v)), g.selectNext(0, 0), p.replace(g, m), !0;
        }
        return !1;
      })(l, a, i) ||
      (function (c, u, h) {
        const d = c.getTextContent(),
          f = u - 1,
          p = d[f],
          m = h[p];
        if (!m) return !1;
        for (const O of m) {
          const { tag: v } = O,
            g = v.length,
            b = f - g + 1;
          if ((g > 1 && !QI(d, b, v, 0, g)) || d[b - 1] === " ") continue;
          const x = d[f + 1];
          if (O.intraword === !1 && x && !GE.test(x)) continue;
          const k = c;
          let w = k,
            y = JE(d, b, v),
            C = w;
          for (; y < 0 && (C = C.getPreviousSibling()) && !Ar(C); )
            if (te(C)) {
              const B = C.getTextContent();
              (w = C), (y = JE(B, B.length, v));
            }
          if (y < 0 || (w === k && y + g === b)) continue;
          const P = w.getTextContent();
          if (y > 0 && P[y - 1] === p) continue;
          const E = P[y - 1];
          if (O.intraword === !1 && E && !GE.test(E)) continue;
          const N = k.getTextContent(),
            L = N.slice(0, b) + N.slice(f + 1);
          k.setTextContent(L);
          const D = w === k ? L : P;
          w.setTextContent(D.slice(0, y) + D.slice(y + g));
          const Q = ae(),
            R = lm();
          pn(R);
          const W = f - g * (w === k ? 2 : 1) + 1;
          R.anchor.set(w.__key, y, "text"), R.focus.set(k.__key, W, "text");
          for (const B of O.format) R.hasFormat(B) || R.formatText(B);
          R.anchor.set(R.focus.key, R.focus.offset, R.focus.type);
          for (const B of O.format) R.hasFormat(B) && R.toggleFormat(B);
          return ee(Q) && (R.format = Q.format), !0;
        }
      })(l, a, r);
  };
  return t.registerUpdateListener(({ tags: s, dirtyLeaves: l, editorState: a, prevEditorState: c }) => {
    if (s.has("collaboration") || s.has("historic") || t.isComposing()) return;
    const u = a.read(ae),
      h = c.read(ae);
    if (!ee(h) || !ee(u) || !u.isCollapsed()) return;
    const d = u.anchor.key,
      f = u.anchor.offset,
      p = a._nodeMap.get(d);
    !te(p) ||
      !l.has(d) ||
      (f !== 1 && f > h.anchor.offset + 1) ||
      t.update(() => {
        if (p.hasFormat("code")) return;
        const m = p.getParent();
        m === null || fS(m) || o(m, p, u.anchor.offset);
      });
  });
}
const DI = (t) => (e, n, r) => {
    const i = t(r);
    i.append(...n), e.replace(i), i.select(0, 0);
  },
  pS = (t) => (e, n, r) => {
    const i = e.getPreviousSibling(),
      o = e.getNextSibling(),
      s = xn(t === "check" ? r[3] === "x" : void 0);
    if ($e(o) && o.getListType() === t) {
      const a = o.getFirstChild();
      a !== null ? a.insertBefore(s) : o.append(s), e.remove();
    } else if ($e(i) && i.getListType() === t) i.append(s), e.remove();
    else {
      const a = vn(t, t === "number" ? Number(r[2]) : void 0);
      a.append(s), e.replace(a);
    }
    s.append(...n), s.select(0, 0);
    const l = (function (a) {
      const c = a.match(/\t/g),
        u = a.match(/ /g);
      let h = 0;
      return c && (h += c.length), u && (h += Math.floor(u.length / 4)), h;
    })(r[1]);
    l && s.setIndent(l);
  },
  Sg = (t, e, n) => {
    const r = [],
      i = t.getChildren();
    let o = 0;
    for (const s of i)
      if (Ue(s)) {
        if (s.getChildrenSize() === 1) {
          const u = s.getFirstChild();
          if ($e(u)) {
            r.push(Sg(u, e, n + 1));
            continue;
          }
        }
        const l = " ".repeat(4 * n),
          a = t.getListType(),
          c = a === "number" ? `${t.getStart() + o}. ` : a === "check" ? `- [${s.getChecked() ? "x" : " "}] ` : "- ";
        r.push(l + c + e(s)), o++;
      }
    return r.join(`
`);
  },
  zpe = {
    dependencies: [eh],
    export: (t, e) => {
      if (!hm(t)) return null;
      const n = Number(t.getTag().slice(1));
      return "#".repeat(n) + " " + e(t);
    },
    regExp: /^(#{1,6})\s/,
    replace: DI((t) => {
      const e = "h" + t[1].length;
      return si(e);
    }),
    type: "element",
  },
  FI = {
    dependencies: [um],
    export: (t, e) => {
      if (!Q0(t)) return null;
      const n = e(t).split(`
`),
        r = [];
      for (const i of n) r.push("> " + i);
      return r.join(`
`);
    },
    regExp: /^>\s/,
    replace: (t, e, n, r) => {
      if (r) {
        const o = t.getPreviousSibling();
        if (Q0(o)) return o.splice(o.getChildrenSize(), 0, [gi(), ...e]), o.select(0, 0), void t.remove();
      }
      const i = Ku();
      i.append(...e), t.replace(i), i.select(0, 0);
    },
    type: "element",
  },
  BI = {
    dependencies: [Vh],
    export: (t) => {
      if (!fS(t)) return null;
      const e = t.getTextContent();
      return (
        "```" +
        (t.getLanguage() || "") +
        (e
          ? `
` + e
          : "") +
        "\n```"
      );
    },
    regExp: /^[ \t]*```(\w{1,10})?\s/,
    replace: DI((t) => Ua(t ? t[1] : void 0)),
    type: "element",
  },
  VI = {
    dependencies: [Go, Yo],
    export: (t, e) => ($e(t) ? Sg(t, e, 0) : null),
    regExp: /^(\s*)[-*+]\s/,
    replace: pS("bullet"),
    type: "element",
  },
  Wpe = {
    dependencies: [Go, Yo],
    export: (t, e) => ($e(t) ? Sg(t, e, 0) : null),
    regExp: /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i,
    replace: pS("check"),
    type: "element",
  },
  jI = {
    dependencies: [Go, Yo],
    export: (t, e) => ($e(t) ? Sg(t, e, 0) : null),
    regExp: /^(\s*)(\d{1,})\.\s/,
    replace: pS("number"),
    type: "element",
  },
  ZI = { format: ["code"], tag: "`", type: "text-format" },
  Xpe = { format: ["highlight"], tag: "==", type: "text-format" },
  zI = { format: ["bold", "italic"], tag: "***", type: "text-format" },
  WI = { format: ["bold", "italic"], intraword: !1, tag: "___", type: "text-format" },
  XI = { format: ["bold"], tag: "**", type: "text-format" },
  UI = { format: ["bold"], intraword: !1, tag: "__", type: "text-format" },
  Upe = { format: ["strikethrough"], tag: "~~", type: "text-format" },
  HI = { format: ["italic"], tag: "*", type: "text-format" },
  qI = { format: ["italic"], intraword: !1, tag: "_", type: "text-format" },
  YI = {
    dependencies: [La],
    export: (t, e, n) => {
      if (!ni(t)) return null;
      const r = t.getTitle(),
        i = r ? `[${t.getTextContent()}](${t.getURL()} "${r}")` : `[${t.getTextContent()}](${t.getURL()})`,
        o = t.getFirstChild();
      return t.getChildrenSize() === 1 && te(o) ? n(o, i) : i;
    },
    importRegExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/,
    regExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/,
    replace: (t, e) => {
      const [, n, r, i] = e,
        o = $s(r, { title: i }),
        s = yt(n);
      s.setFormat(t.getFormat()), o.append(s), t.replace(o);
    },
    trigger: ")",
    type: "text-match",
  },
  Hpe = [zpe, FI, BI, VI, jI],
  qpe = [ZI, zI, WI, XI, UI, Xpe, HI, qI, Upe],
  Ype = [YI],
  GI = [...Hpe, ...qpe, ...Ype],
  Gpe = [
    {
      dependencies: [Sm],
      export: (t) => (mx(t) ? "***" : null),
      regExp: /^(---|\*\*\*|___)\s?$/,
      replace: (t, e, n, r) => {
        const i = ch();
        r || t.getNextSibling() != null ? t.replace(i) : t.insertBefore(i), i.selectNext();
      },
      type: "element",
    },
    ...GI,
  ];
function KE({ transformers: t = Gpe }) {
  const [e] = In();
  return _.useEffect(() => Zpe(e, t), [e, t]), null;
}
const Jpe = Ut({
    init(t) {
      const e = t.getValue(wm),
        n = e.includes("headings") ? t.getValue(ah) : [],
        r = eme(e, n);
      t.pubIn({ [qo]: () => S.createElement(KE, { transformers: r }), [ax]: () => S.createElement(KE, { transformers: r }) });
    },
  }),
  Kpe = (t) => (e, n, r) => {
    const i = t(r);
    i.append(...n), e.replace(i), i.select(0, 0);
  };
function eme(t, e) {
  const n = [zI, WI, XI, UI, ZI, HI, qI];
  if (t.includes("headings")) {
    const r = Math.min(...e),
      i = Math.max(...e),
      o = new RegExp(`^(#{${r},${i}})\\s`),
      s = {
        dependencies: [eh],
        export: (l, a) => {
          if (!hm(l)) return null;
          const c = Number(l.getTag().slice(1));
          return "#".repeat(c) + " " + a(l);
        },
        regExp: o,
        replace: Kpe((l) => {
          const a = `h${l[1].length}`;
          return si(a);
        }),
        type: "element",
      };
    n.push(s);
  }
  if (
    (t.includes("quote") && n.push(FI),
    t.includes("link") && n.push(YI),
    t.includes("lists") && n.push(jI, VI, Wpe),
    t.includes("codeblock"))
  ) {
    const r = {
      ...BI,
      dependencies: [qs],
      replace: (i, o, s) => {
        const l = _h({ code: "", language: s[1] ?? "", meta: "" });
        i.replace(l),
          setTimeout(() => {
            l.select();
          }, 80);
      },
    };
    n.push(r);
  }
  return n;
}
const JI = () => {
    const t = He(ou),
      e = mt(cx),
      n = mt(wm),
      r = n.includes("quote"),
      i = n.includes("headings"),
      o = nt();
    if (!r && !i) return null;
    const s = [{ label: o("toolbar.blockTypes.paragraph", "Paragraph"), value: "paragraph" }];
    if ((r && s.push({ label: o("toolbar.blockTypes.quote", "Quote"), value: "quote" }), i)) {
      const l = mt(ah);
      s.push(...l.map((a) => ({ label: o("toolbar.blockTypes.heading", "Heading {{level}}", { level: a }), value: `h${a}` })));
    }
    return S.createElement(Bh, {
      value: e,
      onChange: (l) => {
        switch (l) {
          case "quote":
            t(() => Ku());
            break;
          case "paragraph":
            t(() => tt());
            break;
          case "":
            break;
          default:
            if (l.startsWith("h")) t(() => si(l));
            else throw new Error(`Unknown block type: ${l}`);
        }
      },
      triggerTitle: o("toolbar.blockTypeSelect.selectBlockTypeTooltip", "Select block type"),
      placeholder: o("toolbar.blockTypeSelect.placeholder", "Block type"),
      items: s,
    });
  },
  zl = ({ format: t, addTitle: e, removeTitle: n, icon: r, formatName: i }) => {
    const [o, s] = Ye(vm, st),
      l = He(bm),
      a = (o & t) !== 0;
    return S.createElement(
      eS,
      {
        title: a ? n : e,
        on: a,
        onValueChange: () => {
          l(i);
        },
      },
      s(r)
    );
  },
  KI = ({ options: t }) => {
    const e = nt(),
      n = typeof t > "u";
    return S.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      n || t.includes("Bold")
        ? S.createElement(zl, {
            format: Tl,
            addTitle: e("toolbar.bold", "Bold"),
            removeTitle: e("toolbar.removeBold", "Remove bold"),
            icon: "format_bold",
            formatName: "bold",
          })
        : null,
      n || t.includes("Italic")
        ? S.createElement(zl, {
            format: Pl,
            addTitle: e("toolbar.italic", "Italic"),
            removeTitle: e("toolbar.removeItalic", "Remove italic"),
            icon: "format_italic",
            formatName: "italic",
          })
        : null,
      n || t.includes("Underline")
        ? S.createElement(zl, {
            format: $l,
            addTitle: e("toolbar.underline", "Underline"),
            removeTitle: e("toolbar.removeUnderline", "Remove underline"),
            icon: "format_underlined",
            formatName: "underline",
          })
        : null
    );
  },
  eM = ({ options: t }) => {
    const e = nt(),
      n = typeof t > "u";
    return S.createElement(
      "div",
      { className: F.toolbarGroupOfGroups },
      n || t.includes("Strikethrough")
        ? S.createElement(zl, {
            format: Al,
            addTitle: e("toolbar.strikethrough", "Strikethrough"),
            removeTitle: e("toolbar.removeStrikethrough", "Remove strikethrough"),
            icon: "strikeThrough",
            formatName: "strikethrough",
          })
        : null,
      n || t.includes("Sup")
        ? S.createElement(zl, {
            format: Il,
            addTitle: e("toolbar.superscript", "Superscript"),
            removeTitle: e("toolbar.removeSuperscript", "Remove superscript"),
            icon: "superscript",
            formatName: "superscript",
          })
        : null,
      n || t.includes("Sub")
        ? S.createElement(zl, {
            format: Rl,
            addTitle: e("toolbar.subscript", "Subscript"),
            removeTitle: e("toolbar.removeSubscript", "Remove subscript"),
            icon: "subscript",
            formatName: "subscript",
          })
        : null
    );
  };
function mS(t) {
  return {
    note: t("admonitions.note", "Note"),
    tip: t("admonitions.tip", "Tip"),
    danger: t("admonitions.danger", "Danger"),
    info: t("admonitions.info", "Info"),
    caution: t("admonitions.caution", "Caution"),
  };
}
const tM = () => {
    const [t, e] = Ye(Ho, Un),
      n = t.rootNode,
      r = nt(),
      i = mS(r);
    return S.createElement(Bh, {
      value: n.getMdastNode().name,
      onChange: (o) => {
        e == null ||
          e.update(() => {
            n.setMdastNode({ ...n.getMdastNode(), name: o }),
              setTimeout(() => {
                e.update(() => {
                  n.getLatest().select();
                });
              }, 80);
          });
      },
      triggerTitle: r("admonitions.changeType", "Select admonition type"),
      placeholder: r("admonitions.placeholder", "Admonition type"),
      items: vg.map((o) => ({ label: i[o], value: o })),
    });
  },
  p0 = "__EMPTY_VALUE__",
  nM = () => {
    const [t, e, n] = Ye(Ho, St, Vu),
      r = t.rootNode,
      i = nt();
    let o = r.getLanguage();
    return (
      o === "" && (o = p0),
      S.createElement(
        "div",
        { className: F.selectWithLabel },
        S.createElement("label", null, i("codeBlock.language", "Code block language")),
        S.createElement(Bh, {
          value: o,
          onChange: (s) => {
            e == null ||
              e.update(() => {
                r.setLanguage(s === p0 ? "" : s),
                  setTimeout(() => {
                    e.update(() => {
                      r.getLatest().select();
                    });
                  });
              });
          },
          triggerTitle: i("codeBlock.selectLanguage", "Select code block language"),
          placeholder: i("codeBlock.language", "Code block language"),
          items: Object.entries(n).map(([s, l]) => ({ value: s || p0, label: l })),
        })
      )
    );
  },
  rM = () => {
    const [t, e] = Ye(vm, st),
      n = He(bm),
      r = nt(),
      i = (t & nh) !== 0,
      o = i ? r("toolbar.removeInlineCode", "Remove code format") : r("toolbar.inlineCode", "Inline code format");
    return S.createElement(tS, { items: [{ title: o, contents: e("code"), active: i, onChange: n.bind(null, "code") }] });
  },
  iM = () => {
    const t = He(bg),
      e = mt(st),
      n = nt();
    return S.createElement(
      os,
      {
        "aria-label": n("toolbar.link", "Create link"),
        title: n("toolbar.link", "Create link"),
        onClick: (r) => {
          t();
        },
      },
      e("link")
    );
  },
  oM = ({ children: t, options: e = ["rich-text", "diff", "source"] }) => {
    const [n, r] = Ye(No, st),
      i = He(No),
      o = nt(),
      s = [];
    return (
      e.includes("rich-text") && s.push({ title: o("toolbar.richText", "Rich text"), contents: r("rich_text"), value: "rich-text" }),
      e.includes("diff") && s.push({ title: o("toolbar.diffMode", "Diff mode"), contents: r("difference"), value: "diff" }),
      e.includes("source") && s.push({ title: o("toolbar.source", "Source mode"), contents: r("markdown"), value: "source" }),
      S.createElement(
        S.Fragment,
        null,
        n === "rich-text"
          ? t
          : n === "diff"
          ? S.createElement("span", { className: F.toolbarTitleMode }, o("toolbar.diffMode", "Diff mode"))
          : S.createElement("span", { className: F.toolbarTitleMode }, o("toolbar.source", "Source mode")),
        S.createElement(
          "div",
          { style: { marginLeft: "auto", pointerEvents: "auto", opacity: 1 } },
          S.createElement(nS, {
            className: F.diffSourceToggle,
            value: n,
            items: s,
            onChange: (l) => {
              i(l === "" ? "rich-text" : l);
            },
          })
        )
      )
    );
  },
  sM = () => {
    const t = He(Zw),
      e = mt(st),
      n = nt(),
      r = S.useMemo(() => {
        const i = mS(n);
        return vg.map((o) => ({ value: o, label: i[o] }));
      }, [n]);
    return S.createElement(
      rS,
      {
        title: n("toolbar.admonition", "Insert Admonition"),
        onChoose: (i) => {
          t({ type: "containerDirective", name: i });
        },
        items: r,
      },
      e("admonition")
    );
  },
  lM = () => {
    const t = He(Eh),
      e = mt(st),
      n = nt();
    return S.createElement(
      os,
      {
        title: n("toolbar.codeBlock", "Insert Code Block"),
        onClick: () => {
          t({});
        },
      },
      e("frame_source")
    );
  },
  aM = () => {
    const t = He(by),
      [e, n] = Ye(yy, st),
      r = nt();
    return S.createElement(
      os,
      {
        title: e ? r("toolbar.editFrontmatter", "Edit frontmatter") : r("toolbar.insertFrontmatter", "Insert frontmatter"),
        className: Fe({ [F.activeToolbarButton]: e }),
        onClick: () => {
          t();
        },
      },
      n("frontmatter")
    );
  },
  cM = S.forwardRef((t, e) => {
    const n = He(oy),
      [r, i] = Ye(Gt, st),
      o = nt();
    return S.createElement(
      Fi,
      {
        className: F.toolbarButton,
        ref: e,
        disabled: r,
        onClick: () => {
          n();
        },
      },
      S.createElement(is, { title: o("toolbar.image", "Insert image") }, i("add_photo"))
    );
  }),
  uM = () => {
    const [t, e] = Ye(js, st),
      n = He(Cw),
      r = S.useMemo(() => t.presets.map((o) => ({ value: o.name, label: o.label })), [t]),
      i = nt();
    return S.createElement(rS, { title: i("toolbar.insertSandpack", "Insert Sandpack"), onChoose: n, items: r }, e("sandpack"));
  },
  hM = () => {
    const t = mt(st),
      e = He(Bx),
      n = nt();
    return S.createElement(
      os,
      {
        title: n("toolbar.table", "Insert Table"),
        onClick: () => {
          e({ rows: 3, columns: 3 });
        },
      },
      t("table")
    );
  },
  dM = () => {
    const t = He(gx),
      e = mt(st),
      n = nt();
    return S.createElement(
      os,
      {
        title: n("toolbar.thematicBreak", "Insert thematic break"),
        onClick: () => {
          t();
        },
      },
      e("horizontal_rule")
    );
  },
  tme = { bullet: "format_list_bulleted", number: "format_list_numbered", check: "format_list_checked" },
  fM = ({ options: t = ["bullet", "number", "check"] }) => {
    const [e, n] = Ye(Zf, st),
      r = He(vx),
      i = nt(),
      o = {
        bullet: i("toolbar.bulletedList", "Bulleted list"),
        number: i("toolbar.numberedList", "Numbered list"),
        check: i("toolbar.checkList", "Check list"),
      },
      s = t.map((l) => ({ value: l, title: o[l], contents: n(tme[l]) }));
    return S.createElement(nS, { value: e || "", items: s, onChange: r });
  },
  pM = () => {
    const [t, e, n, r] = Ye(Ho, St, st, js),
      i = t.rootNode,
      o = nt(),
      s = r.presets.find((l) => l.meta === i.getMeta());
    return S.createElement(
      "div",
      { className: F.selectWithLabel },
      S.createElement(
        os,
        {
          title: o("toolbar.deleteSandpack", "Delete this code block"),
          onClick: () => {
            e == null ||
              e.update(() => {
                i.getNextSibling() ? i.selectNext() : i.selectPrevious(), i.remove();
              });
          },
        },
        n("delete_big")
      ),
      S.createElement("label", null, "Sandpack preset: ", s.name)
    );
  },
  mM = () => {
    const [t, e] = Ye(st, St),
      [n, r] = S.useState(!1),
      [i, o] = S.useState(!1),
      s = nt();
    return (
      S.useEffect(() => {
        if (e)
          return Xn(
            e.registerCommand(mc, (l) => (r(l), !1), Bn),
            e.registerCommand(pc, (l) => (o(l), !1), Bn)
          );
      }, [e]),
      S.createElement(tS, {
        items: [
          {
            title: s("toolbar.undo", "Undo {{shortcut}}", { shortcut: ru ? "⌘Z" : "Ctrl+Z" }),
            disabled: !n,
            contents: t("undo"),
            active: !1,
            onChange: () => (e == null ? void 0 : e.dispatchCommand(Xp, void 0)),
          },
          {
            title: s("toolbar.redo", "Redo {{shortcut}}", { shortcut: ru ? "⌘Y" : "Ctrl+Y" }),
            disabled: !i,
            contents: t("redo"),
            active: !1,
            onChange: () => (e == null ? void 0 : e.dispatchCommand(Up, void 0)),
          },
        ],
      })
    );
  };
function eT(t) {
  const e = t == null ? void 0 : t.rootNode;
  return !e || e.getType() !== "directive" ? !1 : ["note", "tip", "danger", "info", "caution"].includes(e.getMdastNode().name);
}
const nme = () =>
    S.createElement(
      oM,
      null,
      S.createElement(pf, {
        options: [
          { when: (t) => (t == null ? void 0 : t.editorType) === "codeblock", contents: () => S.createElement(nM, null) },
          { when: (t) => (t == null ? void 0 : t.editorType) === "sandpack", contents: () => S.createElement(pM, null) },
          {
            fallback: () =>
              S.createElement(
                S.Fragment,
                null,
                S.createElement(mM, null),
                S.createElement(ei, null),
                S.createElement(KI, null),
                S.createElement(rM, null),
                S.createElement(ei, null),
                S.createElement(eM, null),
                S.createElement(ei, null),
                S.createElement(fM, null),
                S.createElement(ei, null),
                S.createElement(pf, {
                  options: [{ when: eT, contents: () => S.createElement(tM, null) }, { fallback: () => S.createElement(JI, null) }],
                }),
                S.createElement(ei, null),
                S.createElement(iM, null),
                S.createElement(cM, null),
                S.createElement(ei, null),
                S.createElement(hM, null),
                S.createElement(dM, null),
                S.createElement(ei, null),
                S.createElement(lM, null),
                S.createElement(uM, null),
                S.createElement(pf, {
                  options: [
                    {
                      when: (t) => !eT(t),
                      contents: () => S.createElement(S.Fragment, null, S.createElement(ei, null), S.createElement(sM, null)),
                    },
                  ],
                }),
                S.createElement(ei, null),
                S.createElement(aM, null)
              ),
          },
        ],
      })
    ),
  tT = 20,
  rme = S.forwardRef(
    (
      { autocompleteSuggestions: t = [], submitButtonTitle: e, dialogInputPlaceholder: n, onSubmit: r, tooltipTitle: i, buttonContent: o },
      s
    ) => {
      const [l, a] = Ye(jr, Gt),
        [c, u] = S.useState(!1),
        h = S.useCallback(
          (d) => {
            r(d), u(!1);
          },
          [r]
        );
      return S.createElement(
        Xv,
        { open: c, onOpenChange: u },
        S.createElement(
          PM,
          { asChild: !0 },
          S.createElement(Fi, { className: F.toolbarButton, ref: s, disabled: a }, S.createElement(is, { title: i }, o))
        ),
        S.createElement(
          Uv,
          { container: l == null ? void 0 : l.current },
          S.createElement(Hv, { className: F.dialogOverlay }),
          S.createElement(
            qv,
            { className: F.dialogContent },
            S.createElement(ime, { submitButtonTitle: e, autocompleteSuggestions: t, onSubmitCallback: h, dialogInputPlaceholder: n })
          )
        )
      );
    }
  ),
  ime = ({ autocompleteSuggestions: t, onSubmitCallback: e, dialogInputPlaceholder: n, submitButtonTitle: r }) => {
    const [i, o] = S.useState(t.slice(0, tT)),
      s = mt(st),
      l = t.length > 0,
      {
        isOpen: a,
        getToggleButtonProps: c,
        getMenuProps: u,
        getInputProps: h,
        highlightedIndex: d,
        getItemProps: f,
        selectedItem: p,
      } = ry({
        initialInputValue: "",
        onInputValueChange({ inputValue: x }) {
          x = (x == null ? void 0 : x.toLowerCase()) ?? "";
          const k = [];
          for (const w of t) if (w.toLowerCase().includes(x) && (k.push(w), k.length >= tT)) break;
          o(k);
        },
        items: i,
        itemToString(x) {
          return x ?? "";
        },
      }),
      m = S.useCallback(
        (x) => {
          var k;
          x.key === "Escape"
            ? (k = x.target.form) == null || k.reset()
            : x.key === "Enter" && (!a || i.length === 0) && (x.preventDefault(), e(x.target.value));
        },
        [a, i, e]
      ),
      O = h(),
      v = {
        ...O,
        onKeyDown: (x) => {
          m(x), O.onKeyDown(x);
        },
      },
      g = (x) => {
        x.preventDefault(), x.stopPropagation(), e(v.value);
      },
      b = a && i.length > 0;
    return S.createElement(
      "form",
      { onSubmit: g, className: Fe(F.dialogForm) },
      S.createElement(
        "div",
        { className: F.linkDialogInputContainer },
        S.createElement(
          "div",
          { "data-visible-dropdown": b, className: F.linkDialogInputWrapper },
          S.createElement("input", {
            placeholder: n,
            className: F.linkDialogInput,
            ...v,
            autoFocus: !0,
            size: 30,
            "data-editor-dialog": !0,
          }),
          l && S.createElement("button", { "aria-label": "toggle menu", type: "button", ...c() }, s("arrow_drop_down"))
        ),
        S.createElement(
          "div",
          { className: F.downshiftAutocompleteContainer },
          S.createElement(
            "ul",
            { ...u(), "data-visible": b },
            i.map((x, k) =>
              S.createElement(
                "li",
                { "data-selected": p === x, "data-highlighted": d === k, key: `${x}${k}`, ...f({ item: x, index: k }) },
                x
              )
            )
          )
        )
      ),
      S.createElement(
        "button",
        { type: "submit", title: r, "aria-label": r, className: Fe(F.actionButton, F.primaryActionButton) },
        s("check")
      ),
      S.createElement(Yv, { className: F.actionButton }, s("close"))
    );
  };
function ome(t, e) {
  return t.replace("hsl", "hsla").replace(")", `, ${e})`);
}
const sme = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      $createCodeBlockNode: _h,
      $createDirectiveNode: Og,
      $createGenericHTMLNode: qb,
      $createImageNode: es,
      $createTableNode: Fm,
      $isCodeBlockNode: b9,
      $isDirectiveNode: B8,
      $isGenericHTMLNode: cA,
      $isImageNode: cu,
      $isTableNode: H$,
      ADMONITION_TYPES: vg,
      ALL_HEADING_LEVELS: px,
      Action: Fr,
      AdmonitionDirectiveDescriptor: pfe,
      Appender: Ln,
      BlockTypeSelect: JI,
      BoldItalicUnderlineToggles: KI,
      Button: Z8,
      ButtonOrDropdownButton: rS,
      ButtonWithTooltip: os,
      CAN_USE_DOM: Ub,
      COMMON_STATE_CONFIG_EXTENSIONS: Cde,
      Cell: we,
      ChangeAdmonitionType: tM,
      ChangeCodeMirrorLanguage: nM,
      CodeBlockNode: qs,
      CodeMirrorEditor: D8,
      CodeToggle: rM,
      ConditionalContents: pf,
      CreateLink: iM,
      DEFAULT_FORMAT: YB,
      DialogButton: rme,
      DiffSourceToggleWrapper: oM,
      DirectiveNode: Xa,
      GenericDirectiveEditor: mfe,
      GenericHTMLNode: Ca,
      GenericJsxEditor: m9,
      INSERT_IMAGE_COMMAND: uu,
      IS_APPLE: ru,
      IS_BOLD: Tl,
      IS_CODE: nh,
      IS_HIGHLIGHT: GB,
      IS_ITALIC: Pl,
      IS_STRIKETHROUGH: Al,
      IS_SUBSCRIPT: Rl,
      IS_SUPERSCRIPT: Il,
      IS_UNDERLINE: $l,
      ImageNode: Na,
      InsertAdmonition: sM,
      InsertCodeBlock: lM,
      InsertFrontmatter: aM,
      InsertImage: cM,
      InsertSandpack: uM,
      InsertTable: hM,
      InsertThematicBreak: dM,
      KitchenSinkToolbar: nme,
      ListsToggle: fM,
      MDXEditor: nz,
      MarkdownParseError: Lf,
      MultipleChoiceToggleGroup: tS,
      NESTED_EDITOR_UPDATED_COMMAND: Ro,
      NestedEditorsContext: Wm,
      NestedLexicalEditor: Um,
      PropertyPopover: wy,
      Realm: Jv,
      RealmContext: zp,
      RealmProvider: VM,
      RealmWithPlugins: lT,
      Root: j8,
      Select: Bh,
      SelectButtonTrigger: Q8,
      SelectContent: Dw,
      SelectItem: Qw,
      SelectTrigger: N8,
      Separator: ei,
      ShowSandpackInfo: pM,
      Signal: kt,
      SingleChoiceToggleGroup: nS,
      SingleToggleGroup: Sfe,
      StrikeThroughSupSubToggles: eM,
      TYPE_NAME: z0,
      TableNode: Ma,
      ToggleSingleGroupWithItem: eS,
      ToolbarToggleItem: Kw,
      TooltipWrap: is,
      UndoRedo: mM,
      UnrecognizedMarkdownConstructError: Nf,
      activeEditor$: St,
      activeEditorSubscriptions$: tx,
      activePlugins$: wm,
      addActivePlugin$: Ea,
      addComposerChild$: qo,
      addEditorWrapper$: pA,
      addExportVisitor$: cr,
      addImportVisitor$: Wn,
      addLexicalNode$: ar,
      addMdastExtension$: Lo,
      addNestedEditorChild$: ax,
      addSyntaxExtension$: Mo,
      addToMarkdownExtension$: Hs,
      addTopAreaChild$: fA,
      admonitionLabelsMap: mS,
      allowedHeadingLevels$: ah,
      always: eL,
      appendCodeBlockEditorDescriptor$: Sy,
      applyBlockType$: LV,
      applyFormat$: bm,
      applyLinkChanges$: xfe,
      applyListType$: vx,
      autoFocus$: W0,
      call: sT,
      cancelLinkEdit$: Uw,
      closeImageDialog$: ly,
      cmExtensions$: yg,
      codeBlockEditorDescriptors$: Us,
      codeBlockLanguages$: Vu,
      codeBlockPlugin: sK,
      codeMirrorAutoLoadLanguageSupport$: Dp,
      codeMirrorExtensions$: Qp,
      codeMirrorPlugin: _de,
      compose: qM,
      composerChildren$: ix,
      contentEditableClassName$: Qf,
      controlOrMeta: Hb,
      convertSelectionToNode$: ou,
      corePlugin: gA,
      createActiveEditorSubscription$: iu,
      createRootEditorSubscription$: lh,
      currentBlockType$: cx,
      currentFormat$: vm,
      currentListType$: Zf,
      currentSelection$: _s,
      curry1to0: JM,
      curry2to1: GM,
      debounceTime: WM,
      defaultCodeBlockLanguage$: qm,
      defaultComparator: m0,
      delayWithMicrotask: XM,
      diffMarkdown$: zu,
      diffSourcePlugin: Ipe,
      directiveDescriptors$: Es,
      directivesPlugin: ffe,
      disableAutoLink$: t3,
      disableImageResize$: Jf,
      disableImageSettingsButton$: ay,
      editorInFocus$: Ho,
      editorRootElementRef$: jr,
      editorWrappers$: sx,
      exportLexicalTreeToMdast: mm,
      exportMarkdownFromLexical: Wb,
      exportVisitors$: oh,
      filter: va,
      fromWithinEditorRead: gfe,
      frontmatterDialogOpen$: mu,
      frontmatterPlugin: uJ,
      getSelectedNode: V8,
      getSelectionRectangle: zw,
      getStateAsMarkdown: Ofe,
      handlePromise: HM,
      hasFrontmatter$: yy,
      headingsPlugin: lz,
      historyState$: mA,
      htmlTags: UP,
      iconComponentFor$: st,
      imageAutocompleteSuggestions$: Gf,
      imageDialogState$: Eo,
      imagePlugin: bq,
      imagePreviewHandler$: Kf,
      imageUploadHandler$: xo,
      importMarkdownToLexical: aA,
      importMdastTreeToLexical: gm,
      importVisitors$: rh,
      inFocus$: Ul,
      initialMarkdown$: Yb,
      insertCodeBlock$: Eh,
      insertCodeMirror$: F8,
      insertDecoratorNode$: _a,
      insertDirective$: Zw,
      insertFrontmatter$: by,
      insertImage$: S3,
      insertJsx$: O9,
      insertMarkdown$: ex,
      insertSandpack$: Cw,
      insertTable$: Bx,
      insertThematicBreak$: gx,
      isMdastHTMLNode: zb,
      isMdastJsxNode: g9,
      isPartOftheEditorUI: Dm,
      joinProc: tL,
      jsxComponentDescriptors$: Io,
      jsxIsAvailable$: sh,
      jsxPlugin: KJ,
      linkAutocompleteSuggestions$: Yw,
      linkDialogPlugin: yfe,
      linkDialogState$: kn,
      linkPlugin: dH,
      listsPlugin: Nz,
      makeHslTransparent: ome,
      map: mr,
      mapTo: Kv,
      markdown$: Ir,
      markdownErrorSignal$: Ff,
      markdownProcessingError$: Hl,
      markdownShortcutPlugin: Jpe,
      markdownSourceEditorValue$: Ts,
      maxLengthPlugin: pJ,
      mdastExtensions$: Jb,
      muteChange$: Vf,
      nestedEditorChildren$: lx,
      noop: Co,
      onBlur$: ql,
      onClickLinkCallback$: Gw,
      onNext: UM,
      onWindowChange$: Ww,
      once: ZM,
      openEditImageDialog$: sy,
      openLinkEditDialog$: bg,
      openNewImageDialog$: oy,
      placeholder$: Df,
      prop: KM,
      quotePlugin: fJ,
      readOnly$: Gt,
      readOnlyDiff$: dS,
      realmPlugin: Ut,
      removeFrontmatter$: xy,
      removeLink$: qw,
      rootEditor$: Un,
      rootEditorSubscriptions$: nx,
      sandpackConfig$: js,
      sandpackPlugin: Lue,
      saveImage$: cy,
      scan: eb,
      setMarkdown$: ym,
      switchFromPreviewToLinkEdit$: Hw,
      syntaxExtensions$: Gb,
      tablePlugin: HU,
      tap: tb,
      thematicBreakPlugin: fz,
      throttleTime: zM,
      thrush: YM,
      toMarkdownExtensions$: Kb,
      toMarkdownOptions$: Bf,
      toolbarContents$: mf,
      toolbarPlugin: kfe,
      topAreaChildren$: ox,
      translation$: ux,
      updateLink$: Xw,
      useCell: jM,
      useCellValue: mt,
      useCellValues: Ye,
      useCodeBlockEditorContext: ta,
      useLexicalNodeRemove: f9,
      useMdastNodeUpdater: Xm,
      useNestedEditorContext: Sh,
      usePublisher: He,
      useRealm: Oa,
      useTranslation: nt,
      usedLexicalNodes$: ih,
      uuidv4: W$,
      viewMode$: No,
      voidEmitter: Hm,
      withLatestFrom: pt,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
const lme =
    (...t) =>
    (e) => {
      for (const n of t) n && (typeof n == "function" ? n(e) : (n.current = e));
    },
  {
    MDXEditor: ame,
    BoldItalicUnderlineToggles: cme,
    ListsToggle: ume,
    CodeToggle: hme,
    CreateLink: dme,
    headingsPlugin: fme,
    listsPlugin: pme,
    quotePlugin: mme,
    thematicBreakPlugin: gme,
    markdownShortcutPlugin: Ome,
    linkDialogPlugin: vme,
    diffSourcePlugin: bme,
    toolbarPlugin: xme,
    DiffSourceToggleWrapper: yme,
    UndoRedo: wme,
    BlockTypeSelect: Sme,
    Separator: kme,
  } = sme,
  gM = nT((t) => {
    var c, u;
    const { formState: e } = IM(),
      { field: n, control: r, editorRef: i, ...o } = t,
      s = rT({ field: n, control: r }),
      l = _.useRef(null);
    _.useEffect(() => {
      var h;
      l.current && l.current.setMarkdown(((h = s.value) == null ? void 0 : h.markdown) ?? "");
    }, [s.value]);
    const a = lme(l, i);
    return S.createElement(ame, {
      plugins: [
        fme(),
        pme(),
        mme(),
        gme(),
        Ome(),
        vme(),
        bme({ diffMarkdown: ((c = MM(e.defaultValues, n)) == null ? void 0 : c.markdown) ?? "", viewMode: "rich-text", readOnlyDiff: !0 }),
        xme({
          toolbarContents: () =>
            S.createElement(
              yme,
              null,
              S.createElement(wme, null),
              S.createElement(Sme, null),
              S.createElement(kme, null),
              S.createElement(cme, null),
              S.createElement(ume, null),
              S.createElement(hme, null),
              S.createElement(dme, null)
            ),
        }),
      ],
      contentEditableClassName: "autoform-prose",
      markdown: ((u = s.value) == null ? void 0 : u.markdown) ?? "",
      onChange: (h) => s.onChange({ markdown: h }),
      ...(a && { ref: a }),
      ...o,
    });
  }),
  Cme = gM;
gM.__docgenInfo = { description: "", methods: [], displayName: "AutoRichTextInput" };
const OM = nT((t) => {
  const e = rT({ field: t.field, control: t.control });
  return S.createElement(
    "div",
    { className: "Polaris-FormLayout__Item" },
    S.createElement(
      "div",
      { className: "Polaris-Labelled__LabelWrapper" },
      S.createElement(LM, { id: e.id, requiredIndicator: e.metadata.requiredArgumentForInput }, t.label ?? e.metadata.name)
    ),
    S.createElement("div", { className: "Autoform-RichTextInput" }, S.createElement(Cme, { ...t }))
  );
});
OM.__docgenInfo = {
  description: "Prefer using the LazyLoadedMUIAutoRichTextInput.tsx variant of this component to reduce the bundle size by default.",
  methods: [],
  displayName: "PolarisAutoRichTextInput",
};
const Gme = Object.freeze(Object.defineProperty({ __proto__: null, default: OM }, Symbol.toStringTag, { value: "Module" }));
export {
  Fme as A,
  BK as B,
  VK as C,
  XK as D,
  Ur as E,
  gre as F,
  PR as G,
  Qn as H,
  vt as I,
  E4 as J,
  oa as L,
  o4 as N,
  Gme as P,
  k2 as S,
  Dme as _,
  la as a,
  aa as b,
  cf as c,
  Gre as d,
  M4 as e,
  Ba as f,
  at as g,
  m4 as h,
  Ih as i,
  MR as j,
  re as k,
  H as l,
  mre as m,
  mw as n,
  Sp as o,
  s4 as p,
  vr as q,
  Fc as r,
  Fa as s,
  $ as t,
  jK as u,
  y9 as v,
  xl as w,
  zK as x,
  WK as y,
  r1 as z,
};
